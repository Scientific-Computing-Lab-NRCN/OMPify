{"code": "for (unsigned int i = 1; i < (TDim + 1); ++i)\n{\n  if (N[i] > max)\n  {\n    max = N[i];\n    i_nearest_node = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/15"}
{"code": "for (unsigned i = 0; i < size; ++i)\n{\n  (out << rand()) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_1/parallel_1/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (mask1[i][index1] && mask2[i][index2])\n  {\n    double term1 = data1[i][index1];\n    double term2 = data2[i][index2];\n    double w = weight[i];\n    sum1 += w * term1;\n    sum2 += w * term2;\n    result += (w * term1) * term2;\n    denom1 += (w * term1) * term1;\n    denom2 += (w * term2) * term2;\n    tweight += w;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/38"}
{"code": "for (int i = 0; i < w; i++)\n  for (int j = 0; j < h; j++)\n  f[i + (j * w)] = 1 / (1 + ((((i - (w / 2)) * (i - (w / 2))) + ((j - (h / 2)) * (j - (h / 2)))) / ((1.0 * r) * r)));\n\n\n", "pragma": "     #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/5"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/39"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    if (percentDiff(E[(i * 1024) + j], E_GPU[(i * 1024) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/2MM/src/2mm/4"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if ((j + 1) == n)\n    {\n      sprintf(buf, \"%d\\n\", matrix[(i * n) + j]);\n    }\n    else\n    {\n      sprintf(buf, \"%d \", matrix[(i * n) + j]);\n    }\n\n    fwrite(buf, strlen(buf), 1, file);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ralph-101-dev/matrix_generator/matrix_generator/1"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  for (size_t j = 0; j < n; j++)\n  {\n    for (size_t k = 0; k < m; k++)\n    {\n      for (size_t p = 0; p < m; p++)\n      {\n        x = (i + k) - 1;\n        y = (j + p) - 1;\n        if ((((x >= 0) && (y >= 0)) && (x < n)) && (y < n))\n          output[(i * n) + j] += mask[(k * m) + p] * image[(x * n) + y];\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sand47/ME759-CUDA-Assignments/HW08/convolution/0"}
{"code": "for (i = 0; i < numprocs; i++)\n{\n  sendCounts[i] = k / numprocs;\n  if ((k % numprocs) > i)\n  {\n    sendCounts[i] += 1;\n  }\n\n  sendCounts[i + numprocs] = sendCounts[i] * centers[0].dimension;\n  displ[i] = (i != 0) ? (displ[i - 1] + sendCounts[i - 1]) : (0);\n  displ[i + numprocs] = (i != 0) ? (displ[(i - 1) + numprocs] + sendCounts[(i - 1) + numprocs]) : (0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roiedanino/K-Means-Parallel-Implementation/kMeansRoieDanino/MPI_Functions/0"}
{"code": "for (unsigned int i = 1; i < DIMEN; i++)\n  (cout << \", \") << global_best.best_coord.ref[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/imhele/pso-openmp/main/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double a_scalar = sqrt((pow(water_system[i].Acceleration_total[0], 2.0) + pow(water_system[i].Acceleration_total[1], 2.0)) + pow(water_system[i].Acceleration_total[2], 2.0));\n  for (int j = 0; j < 3; j++)\n  {\n    for (int k = 1; k <= 3; k++)\n    {\n      water_system[i].FormerCoor[j][k - 1] = water_system[i].coordinates[j][k];\n      water_system[i].coordinates[j][k] += ((0.01 * OptCoefficient) * water_system[i].Acceleration_total[k - 1]) / a_scalar;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DFTheory/Water-system-openMP/water_system/3"}
{"code": "for (int k = 0; k < 256; k++)\n  for (int j = 0; j < 256; j++)\n  for (int i = 0; i < 256; i++)\n{\n  in_fftw[k][j][i][0] = (float) ((sin((M_PI * ((float) i)) / 64.0) + sin((M_PI * ((float) i)) / 32.0)) + sin(M_PI * (((float) i) / 16.0)));\n  in_fftw[k][j][i][1] = 0;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adriacabeza/PAR/LAB1/Codes/3dfft_omp/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  loop_1[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/parallel-region-with-multiple-loops/parallel-region-with-multiple-loops/9"}
{"code": "for (i = 1; i < (p - 1); i++)\n{\n  for (j = chunkSize; j < (((i - 1) * chunkSize) + 1); j++)\n  {\n    m |= a[j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/2"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  l = test_label[i];\n  Feature features = {0};\n  for (int j = 0; j < 28; j++)\n  {\n    features.input[0][j + 2][2] = (((_Float64) test_data[i][j][0]) - 128) / 256;\n    features.input[0][j + 2][3] = (((_Float64) test_data[i][j][1]) - 128) / 256;\n    features.input[0][j + 2][4] = (((_Float64) test_data[i][j][2]) - 128) / 256;\n    features.input[0][j + 2][5] = (((_Float64) test_data[i][j][3]) - 128) / 256;\n    features.input[0][j + 2][6] = (((_Float64) test_data[i][j][4]) - 128) / 256;\n    features.input[0][j + 2][7] = (((_Float64) test_data[i][j][5]) - 128) / 256;\n    features.input[0][j + 2][8] = (((_Float64) test_data[i][j][6]) - 128) / 256;\n    features.input[0][j + 2][9] = (((_Float64) test_data[i][j][7]) - 128) / 256;\n    features.input[0][j + 2][10] = (((_Float64) test_data[i][j][8]) - 128) / 256;\n    features.input[0][j + 2][11] = (((_Float64) test_data[i][j][9]) - 128) / 256;\n    features.input[0][j + 2][12] = (((_Float64) test_data[i][j][10]) - 128) / 256;\n    features.input[0][j + 2][13] = (((_Float64) test_data[i][j][11]) - 128) / 256;\n    features.input[0][j + 2][14] = (((_Float64) test_data[i][j][12]) - 128) / 256;\n    features.input[0][j + 2][15] = (((_Float64) test_data[i][j][13]) - 128) / 256;\n    features.input[0][j + 2][16] = (((_Float64) test_data[i][j][14]) - 128) / 256;\n    features.input[0][j + 2][17] = (((_Float64) test_data[i][j][15]) - 128) / 256;\n    features.input[0][j + 2][18] = (((_Float64) test_data[i][j][16]) - 128) / 256;\n    features.input[0][j + 2][19] = (((_Float64) test_data[i][j][17]) - 128) / 256;\n    features.input[0][j + 2][20] = (((_Float64) test_data[i][j][18]) - 128) / 256;\n    features.input[0][j + 2][21] = (((_Float64) test_data[i][j][19]) - 128) / 256;\n    features.input[0][j + 2][22] = (((_Float64) test_data[i][j][20]) - 128) / 256;\n    features.input[0][j + 2][23] = (((_Float64) test_data[i][j][21]) - 128) / 256;\n    features.input[0][j + 2][24] = (((_Float64) test_data[i][j][22]) - 128) / 256;\n    features.input[0][j + 2][25] = (((_Float64) test_data[i][j][23]) - 128) / 256;\n    features.input[0][j + 2][26] = (((_Float64) test_data[i][j][24]) - 128) / 256;\n    features.input[0][j + 2][27] = (((_Float64) test_data[i][j][25]) - 128) / 256;\n    features.input[0][j + 2][28] = (((_Float64) test_data[i][j][26]) - 128) / 256;\n    features.input[0][j + 2][29] = (((_Float64) test_data[i][j][27]) - 128) / 256;\n  }\n\n  forward(net, &features);\n  _Float64 *output = (_Float64 *) features.output;\n  int result = 0;\n  _Float64 maxvalue = *output;\n  if (output[1] > maxvalue)\n  {\n    maxvalue = output[1];\n    result = 1;\n  }\n\n  if (output[2] > maxvalue)\n  {\n    maxvalue = output[2];\n    result = 2;\n  }\n\n  if (output[3] > maxvalue)\n  {\n    maxvalue = output[3];\n    result = 3;\n  }\n\n  if (output[4] > maxvalue)\n  {\n    maxvalue = output[4];\n    result = 4;\n  }\n\n  if (output[5] > maxvalue)\n  {\n    maxvalue = output[5];\n    result = 5;\n  }\n\n  if (output[6] > maxvalue)\n  {\n    maxvalue = output[6];\n    result = 6;\n  }\n\n  if (output[7] > maxvalue)\n  {\n    maxvalue = output[7];\n    result = 7;\n  }\n\n  if (output[8] > maxvalue)\n  {\n    maxvalue = output[8];\n    result = 8;\n  }\n\n  if (output[9] > maxvalue)\n  {\n    maxvalue = output[9];\n    result = 9;\n  }\n\n  p = result;\n  if (l == p)\n    truePredict++;\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREAD) private(l) reduction(+:truePredict) schedule(static, COUNT_TEST/NUM_THREAD)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NegarNd/CNN-Inference-Acceleration/main_omp/0"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  spmatrix->val[i] = (real_t *) malloc(msize * (sizeof(real_t)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/4"}
{"code": "for (l = 0; l < (ISIZ1 * ISIZ2); l++)\n{\n  for (n = 0; n < 5; n++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      a[n][m][l] = 0.0;\n      b[n][m][l] = 0.0;\n      c[n][m][l] = 0.0;\n      d[n][m][l] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/ssor/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a += x[i];\n  b ^= y[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(x, y, n) reduction(+:a) reduction(^:b)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.31.1/0"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  temp[i] = 4.0 / (1 + (x * x));\n  sum += temp[i];\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Param-29/OpenMP-with-cpp/Pi Program/ThreadLimitedLoop/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  float V = in[i * n] = sinf((pi * i) / (n - 1));\n  in[((i * n) + n) - 1] = V * expf(-pi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikustosz/OpenMPlab/lapFusion/1"}
{"code": "for (k = 1; k < 4096; k++)\n{\n  symmat[(k * (4096 + 1)) + k] = 1.0;\n  for (j = k + 1; j < (4096 + 1); j++)\n  {\n    symmat[(k * (4096 + 1)) + j] = 0.0;\n    for (int i = 1; i < (4096 + 1); i++)\n    {\n      symmat[(k * (4096 + 1)) + j] += data[(i * (4096 + 1)) + k] * data[(i * (4096 + 1)) + j];\n    }\n\n    symmat[(j * (4096 + 1)) + k] = symmat[(k * (4096 + 1)) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/4"}
{"code": "for (y = 0; y < height; y += width)\n  for (x = 1; x < maxColumnLimit; x++)\n{\n  if (((!edge_pix[y + x]) && edge_pix[y + (x + 1)]) && edge_pix[y + (x - 1)])\n    edge_pix[y + x] = 255;\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/5"}
{"code": "for (i = 0; i < N; i++)\n  s2.b[i]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/8"}
{"code": "for (i = adj_list[v].begin(); i != adj_list[v].end(); ++i)\n  if (!visited[*i])\n  helper(*i, visited);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pratapabhay/Parallel/dfs_parallel/0"}
{"code": "for (int d = 0; d < ndim; d++)\n  periods[d] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vbugaevskii/msu.supercomputers.course/parallel-hw2-03/parallel-mpi-omp/main/0"}
{"code": "for (int z = 0; z < sizeZ; ++z)\n{\n  for (int y = 0; y < sizeY; ++y)\n  {\n    sectionStart = (z * realSizeZ) + (y * realSizeY);\n    for (int x = 0; x < realSizeX; ++x)\n    {\n      sp.values[index] = taskexpr.z1;\n      sp.columns[index] = (z == 0) ? ((x + sectionStart) + (realSizeZ * (sizeZ - 1))) : ((x + sectionStart) - realSizeZ);\n      sp.pointerB[pIndex++] = index;\n      ++index;\n      sp.values[index] = taskexpr.y1;\n      sp.columns[index] = (y == 0) ? ((x + sectionStart) + (realSizeY * (sizeY - 1))) : ((x + sectionStart) - realSizeY);\n      ++index;\n      sp.values[index] = taskexpr.x1;\n      sp.columns[index] = x - 1;\n      ++index;\n      sp.values[index] = taskexpr.x2Comp;\n      sp.columns[index] = x;\n      ++index;\n      sp.values[index] = taskexpr.x1;\n      sp.columns[index] = x + 1;\n      ++index;\n      sp.values[index] = taskexpr.y1;\n      sp.columns[index] = (y == (sizeY - 1)) ? ((x + sectionStart) - (realSizeY * (sizeY - 1))) : ((x + sectionStart) + realSizeY);\n      ++index;\n      sp.values[index] = taskexpr.z1;\n      sp.columns[index] = (z == (sizeZ - 1)) ? ((x + sectionStart) - (realSizeZ * (sizeZ - 1))) : ((x + sectionStart) + realSizeZ);\n      ++index;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/suicide-squad/heat-equation/modules/Sergey/MPI/src/SparseMatrix/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  dist[i][i] = 0.0;\n  for (int j = i + 1; j < N; j++)\n  {\n    dist[i][j] = (dist[j][i] = (float) sqrt((double) (((coordinates[j][0] - coordinates[i][0]) * (coordinates[j][0] - coordinates[i][0])) + ((coordinates[j][1] - coordinates[i][1]) * (coordinates[j][1] - coordinates[i][1])))));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rachit95arora/travelling-salesman-openmp/src/main/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (i = 0; i < 6; i++)\n  {\n    printf(\" * \");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp for schedule(dynamic,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ishanjogalekar/Parallel-distributed-computing-programs/Programs/Star_Dynamic/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (!((a_arr[i] == b_arr[i]) && (a_arr[i] == c_arr[i])))\n  {\n    ok = false;\n    break;\n  }\n\n  printf(\"%f\\t%f\\t%f\\n\", a_arr[i], b_arr[i], c_arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gitsebste/openmpDoubleintegral/doubleIntegral/doubleIntegral/doubleIntegral/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  (cout << val[i]) << ((i == (m - 1)) ? (\"\") : (\", \"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/Matrix/2"}
{"code": "for (i = 1; i < (columns + 1); i++)\n{\n  matrix[0][i] = matrix[lines][i];\n  matrix[lines + 1][i] = matrix[1][i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexmustata19/C-OpenMP-Game-of-life/g_omp/1"}
{"code": "for (i = 0; i < cnt_13; i++)\n{\n  y[i] = x[i] * x[i];\n  if (((i == 0) || (i == (cnt_13 / 2))) || (i == (cnt_13 - 1)))\n  {\n    printf(\"compute13: x[%d] = %f y[%d] = %f \\n\", i, x[i], i, y[i]);\n    fflush(0);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/samples_2016/en/compiler_c/psxe/mic_samples/intro_sampleC/src/sampleC13/6"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    a3[i][j] = 0;\n    for (k = 0; k < r; k++)\n    {\n      a3[i][j] += a1[i][k] * a2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog2_MatrixMul_opemmp/0"}
{"code": "for (int i = 0; i < (world_size - 1); i++)\n{\n  MPI_Recv(receivedFactName, factAllocatedSize, FactorNameType, -2, msgtag, (MPI_Comm) 0x44000000, &stat);\n  MPI_Get_count(&stat, FactorNameType, &realNumOfReceivedFactors);\n  for (int j = 0; j < realNumOfReceivedFactors; ++j)\n  {\n    if (!isFactorPresent(receivedFactName[j].factorName, factNames, factNum))\n    {\n      factNum++;\n      if (factNum == factAllocatedSize)\n      {\n        factAllocatedSize = factNum + 10;\n        factNames = realloc(factNames, (sizeof(FactorName)) * factAllocatedSize);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/10"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  uint32_t src;\n  uint32_t dest;\n  src = edgeList->edges_array_src[i];\n  dest = edgeList->edges_array_dest[i];\n  edgeList->edges_array_src[i] = src | mask_array[src];\n  edgeList->edges_array_dest[i] = dest | mask_array[dest];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/11"}
{"code": "for (int i = 0; i < height; i++)\n  for (int j = 0; j < width; j++)\n  input[(i * width) + j] = rand() % 16;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/entropy-omp/main/5"}
{"code": "for (i2 = 0; i2 < 2; i2++)\n  for (int j = 0; j < 2; j++)\n  for (int k = 0; k < 2; k++)\n  if (a[i2][j][k] != ((i2 + (j * 4)) + (k * 16)))\n  l = 1;\n\n\n\n\n", "pragma": "omp for collapse(2) reduction(|:l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/collapse-3/1"}
{"code": "force = (vector < SpaceVector) > objs\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/SoaSimulator/5"}
{"code": "for (unsigned int k = 0; k < SIFT_SIZE; k++)\n{\n  send_array_sift[((begin_desc + j) * SIFT_SIZE) + k] = get_sift(desc[i], j)[k];\n}\n\n", "pragma": "                                #pragma omp parallel for num_threads(omp_get_num_procs()) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/14"}
{"code": "for (int i = 1; i < (SIZE_X - 1); i++)\n{\n  int iUp;\n  int iDown;\n  int jLeft;\n  int jRight;\n  int nIndex = 0;\n  for (int j = 0; j < SIZE_Y; j++)\n  {\n    if (NULL == MeshA[i][j])\n      continue;\n\n    MeshA[i][j]->Grow();\n    MeshA[i][j]->ChangeToZombie();\n    iUp = ((i - 1) + SIZE_X) % SIZE_X;\n    iDown = ((i + 1) + SIZE_X) % SIZE_X;\n    jLeft = ((j - 1) + SIZE_Y) % SIZE_Y;\n    jRight = ((j + 1) + SIZE_Y) % SIZE_Y;\n    double move = mtRand[nIndex].randExc();\n    if (((move < (1.0 * MOVE)) && (NULL == MeshA[iUp][j])) && (NULL == MeshB[iUp][j]))\n    {\n      MeshB[iUp][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (2.0 * MOVE)) && (NULL == MeshA[iDown][j])) && (NULL == MeshB[iDown][j]))\n    {\n      MeshB[iDown][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (3.0 * MOVE)) && (NULL == MeshA[i][jLeft])) && (NULL == MeshB[i][jLeft]))\n    {\n      MeshB[i][jLeft] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (4.0 * MOVE)) && (NULL == MeshA[i][jRight])) && (NULL == MeshB[i][jRight]))\n    {\n      MeshB[i][jRight] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n    {\n      MeshB[i][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n\n\n\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(MeshA, MeshB, mtRand)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  r[i] = 1 / sqrt((double) N);\n  v0[i] = (v1[i] = 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/78"}
{"code": "for (int i = 0; i < len; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(tofrom: arr[:len])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/declare_target_pointer/declare_target_pointer/0"}
{"code": "for (i = 0; i < (256 + 1); i++)\n{\n  for (j = 0; j < (256 + 1); j++)\n  {\n    data[(i * (256 + 1)) + j] = (((DATA_TYPE) i) * j) / (256 + 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/19"}
{"code": "for (unsigned int var = 0; var < QwD.size(); var++)\n{\n  if (var == procID)\n  {\n    for (unsigned int var3 = 0; var3 < pt.size(); var3++)\n    {\n      int exist = false;\n      for (unsigned int var2 = 0; var2 < QwD[var].size(); var2++)\n      {\n        if (pt[var3] == QwD[var].at(var2).getTId())\n        {\n          exist = true;\n          break;\n        }\n\n      }\n\n      if (!exist)\n      {\n        QwD[var].push_back(taskList[pt[var3]]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/2"}
{"code": "for (int i = c; i >= 0; i--)\n{\n  if ((newPos->_Cases[j][i] == 2) || (newPos->_Cases[j][i] == 3))\n  {\n    newPos->_PionsPris[joueur] += newPos->_Cases[j][i];\n    newPos->_Cases[j][i] = 0;\n  }\n  else\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/10"}
{"code": "for (i = 0; i < NumberOfProcecess; i++)\n{\n  if (i == (NumberOfProcecess - 1))\n  {\n    quantiaResultados[i] = quantidadePiorCasoB;\n    displacementResultados[i] = proporcao * i;\n  }\n  else\n  {\n    quantiaResultados[i] = proporcao;\n    displacementResultados[i] = proporcao * i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/12"}
{"code": "for (d = 0; d < 3; d++)\n{\n  rms[m] = rms[m] / ((double) (grid_points[d] - 2));\n}\n\n", "pragma": "omp parallel for firstprivate(m ,rms )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/6"}
{"code": "for (int j = 0; j < (ENCRYPTEDLEN - 1); ++j)\n  total += scores[(ALPHABET * decrMsg[j]) + decrMsg[j + 1]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/columnarSolver-omp/main/1"}
{"code": "for (int i = 0; i < 100; i++)\n  a[i] += i;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 4/code1/1"}
{"code": "for (int i = 2; i < 5; i++)\n{\n  timeStart = omp_get_wtime();\n  SumCReductor(masC, MasLen, i);\n  timeEnd = omp_get_wtime();\n  ((cout << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\") << i) << \": \";\n  ((cout << \"\u0412\u0440\u0435\u043c\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0441\u0443\u043c\u043c\u044b \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u041f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e\u043c \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0440\u0435\u0434\u0443\u043a\u0442\u043e\u0440\u043e\u0432 = \") << (timeEnd - timeStart)) << endl;\n  (SaveOut << (timeEnd - timeStart)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/4"}
{"code": "for (int i = 0; i < len; i++)\n{\n  for (int j = 0; j < str_len; j++)\n  {\n    data[i][j] = a[rand() % 4];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_2/search/0"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  A[i] = ((float) i) + (3 * i);\n  B[i] = ((float) i) + (2 * i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/vector-product/src/vector-product_gpu/0"}
{"code": "for (int i = 0; i < length; i++)\n  printf(\"%c\", *(ptr1 + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/5"}
{"code": "for (i = r2; i < (sz + r2); i++)\n{\n  for (j = c2; j < sz; j++)\n  {\n    r[i][j] = p[(i - r2) + r1][(j - c2) + c1] - q[i - r2][j - c2];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LalitDhupar/Large-Matrix-Multiplication-Using-OpenMP/Large_Matrix_Multplication_OpenMP/5"}
{"code": "for (int i = 0; i <= (n - 2); i = i + 2)\n{\n  if (arr[i] > arr[i + 1])\n  {\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[i];\n    arr[i] = temp;\n    isSorted = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for if (isParallel)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Osmanyasal/openmpExamples/6-parallelSortingAlgorithms/parallelOddEven/1"}
{"code": "for (node_t c = 0; c < noofComm; c++)\n{\n  clusterPositions[cd[c].id] = c;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    (cout << A[(i * n) + j]) << '\\t';\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhaseeb123/omp_gaussian_elimination/src/GaussianElimination/3"}
{"code": "for (taskCounter = 1; taskCounter < taskCount; taskCounter++)\n{\n  MPI_Recv(&offset, 1, (MPI_Datatype) 0x4c000405, taskCounter, 1, (MPI_Comm) 0x44000000, &status);\n  MPI_Recv(&data[offset], chunkSize, (MPI_Datatype) 0x4c00040a, taskCounter, 2, (MPI_Comm) 0x44000000, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/batux/hybrid_high_performance_parallel_computing/sample_array_processing_01/main/3"}
{"code": "for (i = 0; i < dim; i++)\n{\n  printf(\"%d \", A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adricarda/parallel-Bucket-Sort/parallelBucketSort/parallelBucketSort/4"}
{"code": "for (idx = 0; idx < nkeyfiles; idx++)\n{\n  p = strchr(p, '$') + 1;\n  q = strchr(p, '$');\n  if (!q)\n  {\n    if (idx != (nkeyfiles - 1))\n      return 0;\n\n    len = strlen(p);\n  }\n  else\n  {\n    len = q - p;\n  }\n\n  if (len > ((sizeof(tpath)) - 1))\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/truecrypt_fmt_plug/1"}
{"code": "for (i = 0; i <= nsub; i++)\n{\n  if (i == 0)\n  {\n    if ((ibc == 1) || (ibc == 3))\n    {\n      u = ul;\n    }\n    else\n    {\n      u = f[indx[i] - 1];\n    }\n\n  }\n  else\n    if (i == nsub)\n  {\n    if ((ibc == 2) || (ibc == 3))\n    {\n      u = ur;\n    }\n    else\n    {\n      u = f[indx[i] - 1];\n    }\n\n  }\n  else\n  {\n    u = f[indx[i] - 1];\n  }\n\n\n  printf(\"  %8d  %8f  %14f\\n\", i, xn[i], u);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/19"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = malloc(n * (sizeof(double *)));\n  a_copy[i] = malloc(n * (sizeof(double *)));\n  l[i] = malloc(n * (sizeof(double *)));\n  u[i] = malloc(n * (sizeof(double *)));\n  pi[i] = i;\n  for (j = 0; j < n; j++)\n  {\n    fscanf(file, \"%lf\", &a[i][j]);\n    a_copy[i][j] = a[i][j];\n    if (i == j)\n    {\n      l[i][j] = 1;\n      drand48_r(&drand_buf, &u[i][j]);\n    }\n    else\n    {\n      if (i > j)\n      {\n        drand48_r(&drand_buf, &l[i][j]);\n        u[i][j] = 0;\n      }\n      else\n      {\n        drand48_r(&drand_buf, &u[i][j]);\n        l[i][j] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp_latest/0"}
{"code": "for (int i = 0; i < ((n - k) - 1); i++)\n{\n  temp_u[i] = u[k][(i + k) + 1];\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brijeshvp/LU-Decomposition-using-Parallel-Programming/omp_parallel/LU_omp/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  int j;\n  for (j = 0; j < n; j++)\n  {\n    int k;\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tavorestrepo98/openMP/m6/mult_openmp6/0"}
{"code": "for (int i = 0; i < s; i++)\n{\n  int a = matB[0][c];\n  for (int j = 1; j < 2; j++)\n  {\n    matB[j - 1][c] = matB[j][c];\n  }\n\n  matB[2 - 1][c] = a;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/5"}
{"code": "for (int i = 0; i < CITIES; i++)\n{\n  if (arr[i] == val)\n  {\n    pos = i;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for default( none ) shared( arr,pos,val)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeffyjahfar/TSP_GeneticAlgorithm_openMP/EvalXOverMutate/2"}
{"code": "for (int i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (int i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    double r1[M];\n    double r2[M];\n    if (n1 < 8)\n      for (int i1 = 0; i1 < n1; i1++)\n    {\n      r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n      r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n    }\n\n    else\n    {\n      for (int i1 = 0; i1 < n1; i1++)\n        r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n\n      for (int i1 = 0; i1 < n1; i1++)\n        r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n\n    }\n\n    double c0 = c[0];\n    double c1 = c[1];\n    double c2 = c[2];\n    for (int i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      u[i3][i2][i1] += ((c0 * r[i3][i2][i1]) + (c1 * ((r[i3][i2][i1 - 1] + r[i3][i2][i1 + 1]) + r1[i1]))) + (c2 * ((r2[i1] + r1[i1 - 1]) + r1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment10/real/real/0"}
{"code": "for (i = 0; i < 8; i += 1)\n{\n  stop = 0;\n  a = x + D[i][0];\n  b = y + D[i][1];\n  while (((((!stop) && (a >= 0)) && (a <= 7)) && (b >= 0)) && (b <= 7))\n  {\n    if (conf.mat[a][b] < 0)\n      stop = 1;\n    else\n    {\n      copier(&conf, &T[*n]);\n      T[*n].mat[x][y] = 0;\n      if (T[*n].mat[a][b] > 0)\n        stop = 1;\n\n      T[*n].mat[a][b] = -'n';\n      if ((T[*n].xrB == a) && (T[*n].yrB == b))\n      {\n        T[*n].xrB = -1;\n        T[*n].yrB = -1;\n      }\n\n      (*n)++;\n      a = a + D[i][0];\n      b = b + D[i][1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/11"}
{"code": "for (it = IDF.begin(); it != IDF.end(); it++)\n{\n  it->second = log(count / it->second);\n  (((idout << it->first) << \" -> \") << it->second) << endl;\n  IDF2.insert(mp(it->first, it->second));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rklohana/Cosine-Similarity-using-TF-IDF-vectors-using-hybrid-openmp-mpi-and-cuda/tfidfstg/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  cin >> a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/parallel_sorts/bubble_sort/1"}
{"code": "for (i = 0; i < N; i++)\n  s1.q[i]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/6"}
{"code": "for (i = 0; i < 10; i++)\n{\n  suma_parallel += a[i][j];\n  printf(\"(%2d,%2d)-W(%1d,%1d) \", i, j, omp_get_thread_num(), id_z);\n}\n\n", "pragma": "omp parallel for reduction(+:suma_parallel) firstprivate(id_z) ordered schedule(static,2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_9/openmp_petle/5"}
{"code": "for (i = low - 1; i >= 0; i--)\n{\n  k = (int) scal[i];\n  if (k != i)\n    for (j = 0; j < n; j++)\n  {\n    double t;\n    t = eivec[i][j];\n    eivec[i][j] = eivec[k][j];\n    eivec[k][j] = t;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/10"}
{"code": "for (int i = rb; i < re; i++)\n{\n  if (equation == 0)\n  {\n    Mcoefs[2][i] = KK(i) / (dL[i] * dL[i]);\n    Mcoefs[1][i] = -((KK(i) / (dL[i] * dL[i])) + (KK(i - 1) / (dL[i] * dL[i - 1])));\n    Mcoefs[0][i] = KK(i - 1) / (dL[i] * dL[i - 1]);\n  }\n\n  if (equation == 1)\n  {\n    Mcoefs[2][i] = (D / sigma) * (1.0 / (dL[i] * dL[i]));\n    Mcoefs[1][i] = (-(D / sigma)) * ((1.0 / (dL[i] * dL[i - 1])) + (1.0 / (dL[i] * dL[i])));\n    Mcoefs[0][i] = (D / sigma) * (1.0 / (dL[i] * dL[i - 1]));\n  }\n\n  if (equation == 2)\n  {\n    Mcoefs[2][i] = (lambda / Ct) * (1.0 / (dL[i] * dL[i]));\n    Mcoefs[1][i] = (-(lambda / Ct)) * ((1.0 / (dL[i] * dL[i - 1])) + (1.0 / (dL[i] * dL[i])));\n    Mcoefs[0][i] = (lambda / Ct) * (1.0 / (dL[i] * dL[i - 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/90"}
{"code": "for (size_t i = 0; i < particleVec.size(); i++)\n{\n  avg_density += particleVec[i].corrected_density;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/agam-kashyap/Fluid-Simulation-Rendering/Simulation/src/iisph-forces/1"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  if (argv[i][0] != '-')\n    continue;\n\n  switch (argv[i][1])\n  {\n    case 'i':\n    {\n      if (((++i) >= argc) && (infile == 0))\n      {\n        usage();\n        error(\"No input file specified.\");\n      }\n      else\n        if (i < argc)\n      {\n        if (strncmp(\"-\", argv[i], 2) == 0)\n        {\n          open_from_stdin = 1;\n        }\n\n        infile = argv[i];\n      }\n\n\n    }\n      break;\n\n    case 'o':\n    {\n      if (((++i) >= argc) && (outfile == 0))\n      {\n        usage();\n        error(\"No output file specified.\");\n      }\n      else\n        if (i < argc)\n      {\n        if (strncmp(\"-\", argv[i], 2) == 0)\n        {\n          output_to_stdout = 1;\n        }\n\n        outfile = argv[i];\n      }\n\n\n    }\n      break;\n\n    case 's':\n    {\n      if ((++i) >= argc)\n      {\n        usage();\n        error(\"No number specified with spread.\");\n      }\n\n      spread = strtoull(argv[i], 0, 10);\n    }\n      break;\n\n    case 'q':\n    {\n      if ((++i) >= argc)\n      {\n        usage();\n        error(\"No number specified with quality.\");\n      }\n\n      quality = strtoull(argv[i], 0, 10);\n    }\n      break;\n\n    case 'f':\n    {\n      if ((++i) >= argc)\n      {\n        usage();\n        error(\"Filetype not specified with filetype switch.\");\n      }\n\n      if ((filetype = read_filetype(argv[i])) == FT_NONE)\n      {\n        usage();\n        error(\"Invalid filetype specified.\");\n      }\n\n    }\n      break;\n\n    default:\n    {\n      size_t j = 1;\n      while (argv[i][j])\n      {\n        switch (argv[i][j])\n        {\n          case 'h':\n          {\n            usage();\n            return 0;\n          }\n\n          case 'n':\n          {\n            test_above = 0;\n          }\n            break;\n\n          case 'l':\n          {\n            test_channel = 0;\n          }\n            break;\n\n          case 'a':\n          {\n            asymmetric = 1;\n          }\n            break;\n\n        }\n\n        ++j;\n      }\n\n    }\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chaquator/chaq-sdfgen/openmp/sdfgen/5"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  phi = data.pseudo_K0RS[(nuc * input.numL) + i] * sqrt(E);\n  if (i == 1)\n    phi -= -atan(phi);\n  else\n    if (i == 2)\n    phi -= atan((3.0 * phi) / (3.0 - (phi * phi)));\n  else\n    if (i == 3)\n    phi -= atan((phi * (15.0 - (phi * phi))) / (15.0 - ((6.0 * phi) * phi)));\n\n\n\n  phi *= 2.0;\n  sigTfactors[i].r = cos(phi);\n  sigTfactors[i].i = -sin(phi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/7"}
{"code": "for (k = iBegin; k < iEnd; k++)\n{\n  if ((i < iMiddle) && ((j >= iEnd) || (tablica[i] <= tablica[j])))\n  {\n    t[k] = tablica[i];\n    i = i + 1;\n  }\n  else\n  {\n    t[k] = tablica[j];\n    j = j + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TomaszAugustyn/multicore-mergesort-with-openmp/OpenMP2/main/0"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  for (j = 1; j < (columns - 1); j++)\n  {\n    fscanf(f, \"%d\\n\", &matrixData[(i * columns) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/parallel-scan-sky/openmp/src/ScanSky_openmp/6"}
{"code": "for (i = 0; i < ((int) transactions.size()); i++)\n  for (int j = 0; j < ((int) transactions[i].size()); j++)\n  tmp[transactions[i][j]]++;\n\n\n", "pragma": "\t#pragma omp share (i) for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yeshwanth495/Parallelizing-Apriori-Algorithm/FinalCode/0"}
{"code": "for (j = 1; j <= i__1; ++j)\n{\n  i__2 = *n;\n  for (i__ = j; i__ <= i__2; ++i__)\n  {\n    temp = 0.f;\n    i__3 = *k;\n    for (l = 1; l <= i__3; ++l)\n    {\n      temp += a[l + (i__ * a_dim1)] * a[l + (j * a_dim1)];\n    }\n\n    if ((*beta) == 0.f)\n    {\n      c__[i__ + (j * c_dim1)] = (*alpha) * temp;\n    }\n    else\n    {\n      c__[i__ + (j * c_dim1)] = ((*alpha) * temp) + ((*beta) * c__[i__ + (j * c_dim1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/18"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  __sync_fetch_and_add(&colorPtr[((long) color[i]) + 1], 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/parallelLouvainWithColoring/1"}
{"code": "for (int shellTypeA = 0; shellTypeA < maxShellType; ++shellTypeA)\n{\n  for (int shellTypeB = 0; shellTypeB < maxShellType; ++shellTypeB)\n  {\n    const int shellTypeAB = (shellTypeA * maxShellType) + shellTypeB;\n    for (int shellTypeC = 0; shellTypeC < maxShellType; ++shellTypeC)\n    {\n      const int shellTypeABC = (shellTypeAB * maxShellType) + shellTypeC;\n      for (int shellTypeD = 0; shellTypeD < maxShellType; ++shellTypeD)\n      {\n        const int shellTypeABCD = (shellTypeABC * maxShellType) + shellTypeD;\n        if (this->cutoffAll_schwartz_[shellTypeABCD] != 0)\n        {\n          hasCutoffSchwarz = true;\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    c[i][j] = 0.0;\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mohrobati/OpenMP/MatrixMultiplication/parallel/1"}
{"code": "for (int t = 0; t <= nt; t++)\n{\n  if (t > 0)\n    start[t - 1] = MPI_Wtime();\n\n  int offset;\n  if (rank == 0)\n    offset = 17;\n  else\n    offset = (((((rows / numprocs) * cols) * rank) + (r_offset * cols)) - (winRadius * cols)) + 17;\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    input_start[t - 1] = MPI_Wtime();\n\n  MPI_File_open(MPI_COMM_WORLD, rightImgName, MPI_MODE_RDONLY, MPI_INFO_NULL, &fh);\n  MPI_File_read_at(fh, offset, rImgSegPtr_8u, bufsize, MPI_CHAR, &status);\n  MPI_File_open(MPI_COMM_WORLD, leftImgName, MPI_MODE_RDONLY, MPI_INFO_NULL, &fh);\n  MPI_File_read_at(fh, offset, lImgSegPtr_8u, bufsize, MPI_CHAR, &status);\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    input_end[t - 1] = MPI_Wtime();\n\n  imgCharToFloat(lImgSegPtr_8u, lImgSegPtr_f, bufsize, false);\n  imgCharToFloat(rImgSegPtr_8u, rImgSegPtr_f, bufsize, false);\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    main_start[t - 1] = MPI_Wtime();\n\n  PatchMatchStereo(lImgSegPtr_f, rImgSegPtr_f, lDispPtr, rDispPtr, lPlanePtr, rPlanePtr, (rows / numprocs) + extraRow);\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    main_end[t - 1] = MPI_Wtime();\n\n  imgCharToFloat(lImgSegPtr_8u, rDispPtr, bufsize, true);\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    output_start[t - 1] = MPI_Wtime();\n\n  MPI_File_open(MPI_COMM_WORLD, \"disp_mpi_.pgm\", MPI_MODE_CREATE | MPI_MODE_WRONLY, MPI_INFO_NULL, &fh);\n  if (rank == 0)\n    MPI_File_write_at(fh, 0, lImgSegPtr_8u, bufsize - (winRadius * cols), MPI_CHAR, &status);\n  else\n    if (rank == (numprocs - 1))\n    MPI_File_write_at(fh, (((rows / numprocs) * rank) * cols) + (r_offset * cols), lImgSegPtr_8u + (winRadius * cols), bufsize - (winRadius * cols), MPI_CHAR, &status);\n  else\n    MPI_File_write_at(fh, (((rows / numprocs) * rank) * cols) + (r_offset * cols), lImgSegPtr_8u + (winRadius * cols), bufsize - ((2 * winRadius) * cols), MPI_CHAR, &status);\n\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    output_end[t - 1] = MPI_Wtime();\n\n  MPI_File_close(&fh);\n  MPI_Barrier(MPI_COMM_WORLD);\n  if (t > 0)\n    end[t - 1] = MPI_Wtime();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/freesdyla/Math-424-Semester-Project/stereo/0"}
{"code": "for (int myrow = 0; myrow < SIZE; myrow++)\n{\n  if (myrow != uniquerow)\n    possiblevalues[myrow][row][num] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/11"}
{"code": "for (int i = 0; i < get_npart(); ++i)\n{\n  particles_[i].pos[0] = unif_d(gen);\n  particles_[i].pos[1] = unif_d(gen);\n  particles_[i].pos[2] = unif_d(gen);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nbody-omp/GSimulation/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/1/if-clause/1"}
{"code": "for (l = 0; l < nze; l++)\n{\n  ll = nnxye * l;\n  for (k = 0; k < nye; k++)\n  {\n    for (j = 0; j < nxe; j++)\n    {\n      for (i = 0; i < ndim; i++)\n      {\n        a[(i + (ndim * (j + (nxe * k)))) + ll] = b[(i + (ndim * (j + (nxe * k)))) + ll] + c[(i + (ndim * (j + (nxe * k)))) + ll];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/14"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  int source = i;\n  MPI_Recv(&buffer[offset], chunksize * i_y_max, (MPI_Datatype) 0x4c000101, source, 1, 1, &status);\n  offset += chunksize * i_y_max;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP2/MPI+OMP/mandelbrot_openmpi+omp/2"}
{"code": "for (i = 1; i < (width - 1); i++)\n{\n  mainField[i][0].present = LifeorDeath(mainField[i][0], mainField[i - 1][0], mainField[i + 1][0], mainField[i][1], mainField[i - 1][1], mainField[i + 1][1], mainField[i][height - 1], mainField[i - 1][height - 1], mainField[i + 1][height - 1]);\n  mainField[i][height - 1].present = LifeorDeath(mainField[i][height - 1], mainField[i - 1][height - 1], mainField[i + 1][height - 1], mainField[i][height - 2], mainField[i - 1][height - 2], mainField[i + 1][height - 2], mainField[i][0], mainField[i - 1][0], mainField[i + 1][0]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timac11/openMP/lgame/2"}
{"code": "for (i = 0; i < M; i = i + 4)\n{\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[(i * M) + k] * B[(k * M) + j]);\n      r = r + (A[((i * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[((i * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[((i * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[(i * M) + j] = (alpha * r) + (beta * C[(i * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 1) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 1) * M) + j] = (alpha * r) + (beta * C[((i + 1) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 2) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 2) * M) + j] = (alpha * r) + (beta * C[((i + 2) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 3) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 3) * M) + j] = (alpha * r) + (beta * C[((i + 3) * M) + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i, j, k, r)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/0"}
{"code": "for (j = offset; j < (offset + size); ++j)\n{\n  y_ompacc[j] += a * x[j];\n}\n\n", "pragma": "omp parallel for shared(size, a) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/axpy_ompacc3/0"}
{"code": "for (p = 0; p < _PB_NP; p++)\n{\n  sum[p] = SCALAR_VAL(0.0);\n  for (s = 0; s < _PB_NP; s++)\n    sum[p] += A[r][q][s] * C4[s][p];\n\n}\n\n", "pragma": "omp parallel for private(s)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/doitgen/doitgen/0"}
{"code": "for (int i = 1; i <= nxr; i++)\n  for (int j = 1; j <= nyr; j++)\n  vector[i][j][1] += vector[i][j][0];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/21"}
{"code": "for (i = 0; i < (*numOfPoints); i++)\n{\n  fscanf(f, \"%lf %lf %lf\", &allPoints[i].x, &allPoints[i].y, &allPoints[i].z);\n  fscanf(f, \"%lf %lf %lf\\n\", &allPoints[i].vX, &allPoints[i].vY, &allPoints[i].vZ);\n  allPoints[i].clusterId = -1;\n  allPoints[i].minDis = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/10"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  if (cg[i]->isHidden())\n  {\n    n = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/0"}
{"code": "for (i = 0; i <= N; i++)\n  printf(\"%d \", final_path[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhishekgupta-1/Parallel-Computing-Assignment/submission/tsp_openmp/tsp_openmp/7"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-m\") == 0)\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    m = atoi(argv[i + 1]);\n    i++;\n    continue;\n  }\n\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    n = atoi(argv[i + 1]);\n    i++;\n    continue;\n  }\n\n  if (strcmp(argv[i], \"-k\") == 0)\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    k = atoi(argv[i + 1]);\n    i++;\n    continue;\n  }\n\n  if ((!strcmp(argv[i], \"-t\")) || (!strcmp(argv[i], \"--threads\")))\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    numThreads = atoi(argv[i + 1]);\n    i++;\n    continue;\n  }\n\n  if ((!strcmp(argv[i], \"-i\")) || (!strcmp(argv[i], \"--input-file\")))\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    inputFile = argv[i + 1];\n    i++;\n    continue;\n  }\n\n  if ((!strcmp(argv[i], \"-o\")) || (!strcmp(argv[i], \"--output-file\")))\n  {\n    if ((i + 1) >= argc)\n    {\n      errx(6, \"Incorrect program usage\");\n    }\n\n    outputFile = argv[i + 1];\n    i++;\n    continue;\n  }\n\n  if ((!strcmp(argv[i], \"-h\")) || (!strcmp(argv[i], \"--help\")))\n  {\n    help();\n    exit(0);\n  }\n\n  if ((!strcmp(argv[i], \"-q\")) || (!strcmp(argv[i], \"--quiet\")))\n  {\n    isQuiet = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KManolov3/parallel-matrix-mult/parallel-matrix-multiply/main/9"}
{"code": "for (i = 0; i < l; i++)\n  for (j = 0; j < c; j++)\n  M2[i][j] = M[i][j] * M[i][j];\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/viniolvs/openMP-OAC/matrix/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  for (int i = 0; i < N; i++)\n  {\n    for (int n = 0; n < N; n++)\n    {\n      C[i][j] += A[i][n] * B[n][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elyaishere/sk_high_performance_computing/openmp/MatMul/1"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  warning[i] += (omp_get_num_threads() == 1) ? (1) : (0);\n  if (attempt >= 70)\n  {\n    a[i] += (isOffloading && omp_is_initial_device()) ? (10) : (0);\n  }\n  else\n  {\n    a[i] += (omp_is_initial_device()) ? (1) : (100);\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for if(target: attempt >= ATTEMPT_THRESHOLD) map(tofrom: a) num_threads(OMPVV_NUM_THREADS_DEVICE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_if_target_modifier/0"}
{"code": "for (i = 1; i <= max; i += 2)\n{\n  if (isprime(i))\n    p++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/salihkilicli/Databases-and-Computational-Tools-Used-in-Big-Data/prime/1"}
{"code": "for (i = 0; (i < latent_template.m_nrof_minu_templates) && rolled_template.m_nrof_minu_templates; ++i)\n{\n  float s = One2One_minutiae_matching(latent_template.m_minu_templates[i], rolled_template.m_minu_templates[0]);\n  score[i] = s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/2"}
{"code": "for (int bb = 0; bb < mpi_size; bb++)\n  for (int i = 0; i <= sN; i++)\n  for (int j = 0; j <= _M; j++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (sN / mpi_size)\n    bi = i / (sN / mpi_size);\n\n  if (_M / mpi_size)\n    bj = j / (_M / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = bi - bj;\n  if (st < 0)\n    st += mpi_size;\n\n  st = (st + mpi_rank) % mpi_size;\n  if (bb == st)\n  {\n    rb = bb * (K / mpi_size);\n    re = rb + (K / mpi_size);\n    if (bb == 0)\n      rb = 0;\n\n    if (bb == (mpi_size - 1))\n      re = K + 1;\n\n    for (int k = rb; k < re; k++)\n      A[idx(i, j, k)] = B[idx(i, j, k)];\n\n  }\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/107"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  matrixa[i] = a_block + (i * SIZE);\n  matrixc[i] = c_block + (i * SIZE);\n  matrixb[i] = b_block + (i * SIZE);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/21"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f %f %f \", (float) npcdDeviation[i * 3], (float) npcdDeviation[(i * 3) + 1], (float) npcdDeviation[(i * 3) + 2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/105"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_min = fmin(host_min, a[x] + b[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_min/1"}
{"code": "for (int i = 0; i < nE; ++i)\n{\n  ((cin >> from) >> to) >> weight;\n  graph[to][from] = weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"loop: %d, thread: %lu, iteration: %d\\n\", loop_index, 0, i);\n  loop_2[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/13"}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (buffer_offset + k) + (((j + depth) - 1) * depth);\n  field[FTNREF2D(j, (y_max + y_inc) + k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = top_rcv_buffer[FTNREF1D(index, 1)];\n}\n\n", "pragma": "omp parallel for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/pack_kernel_c/7"}
{"code": "for (int i = 0; i < NRA; i++)\n{\n  for (int j = 0; j < NCB; j++)\n    fprintf(fptr, \"%6.2f   \", c[i][j]);\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPMatrixMult/Ex5MM_Multiply/1"}
{"code": "for (i = l1; i < l2; i++)\n{\n  for (j = 1; j < (width - 1); j++)\n  {\n    sum = 0;\n    for (k = -1; k <= 1; k++)\n    {\n      for (l = -1; l <= 1; l++)\n      {\n        sum += before[i + k][j + l].white_black * (v[1 + k][1 + l] / pondere);\n      }\n\n    }\n\n    after[i][j].white_black = (unsigned char) sum;\n  }\n\n}\n\n", "pragma": "omp for private(i, j, k ,l, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/0"}
{"code": "for (int i = 0; i < treen_points_val.size(); i++)\n{\n  treen_points_val[i] = (ccoeff * treec_points_val[i]) - (pcoeff * treep_points_val[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashb/tbslas/src/applications/src/advdiff-ss-tv/1"}
{"code": "for (int i = 0; i < siz; i++)\n{\n  for (int j = 0; j < siz; j++)\n  {\n    (((((fout << i) << \" \") << j) << \" \") << grid[i][j]) << endl;\n  }\n\n  fout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/6"}
{"code": "for (i = myid + 1; i <= n; i += numprocs)\n{\n  x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kc9qey/mpi_openmp/cpi/0"}
{"code": "for (i = 0; i <= 4; i += 1)\n{\n  switch ('A')\n  {\n    case 'S':\n      test_index_array[i] = S_test_index_array[i];\n      test_rank_array[i] = S_test_rank_array[i];\n      break;\n\n    case 'A':\n      test_index_array[i] = A_test_index_array[i];\n      test_rank_array[i] = A_test_rank_array[i];\n      break;\n\n    case 'W':\n      test_index_array[i] = W_test_index_array[i];\n      test_rank_array[i] = W_test_rank_array[i];\n      break;\n\n    case 'B':\n      test_index_array[i] = B_test_index_array[i];\n      test_rank_array[i] = B_test_rank_array[i];\n      break;\n\n    case 'C':\n      test_index_array[i] = C_test_index_array[i];\n      test_rank_array[i] = C_test_rank_array[i];\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/7"}
{"code": "for (i = 0; i < size; i++)\n{\n  allPoints[i].x = allPoints[i].x + (moment * allPoints[i].vX);\n  allPoints[i].y = allPoints[i].y + (moment * allPoints[i].vY);\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Point/2"}
{"code": "for (i = 1; i < ((*my_rows) - 1); i++)\n  for (j = 1; j < (10 - 1); j++)\n  (*u)[i][j] = mean;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/estsaon/parallel-programming-in-c-with-mpi-and-openmp/openmp/chapter18/jacobi/jacobi/6"}
{"code": "for (p = 0; p < GA_POPULATION; p++)\n{\n  for (unsigned v = 0; v < ndv; v++)\n  {\n    NewPop[(p * ndv) + v] = MatePop[(p * ndv) + v];\n    unsigned mut = rand() & ndv;\n    if (mut == v)\n    {\n      float MAX = pow(2, GA_RESOLUTION) - 1.0f;\n      unsigned MAXi = (unsigned) MAX;\n      int rndint = rand() % (MAXi + 1);\n      float rndf = ((((float) rndint) / MAX) * (UB[v] - LB[v])) + LB[v];\n      NewPop[(p * ndv) + v] = rndf;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feildawproton/Genetic-Algorithm-with-OpenMP/GA/GA/4"}
{"code": "for (int iat = 0; iat < Z.size(); iat++)\n  Z[iat] = mySpecies(qind, GroupID[iat]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/5"}
{"code": "for (int t = 0; t < N; t++)\n  a[t] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satyatejachikatla/OpenMP-examples/01-Basic/main/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  input[((i * n) + i) - 1] = B1_Orig[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/3"}
{"code": "for (int i = 0; i < size; ++i)\n  model->jump[i] = (updateFactor == 1) ? (1) : ((rand() % (2 * model->updateFactor)) + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/0"}
{"code": "for (unsigned i = 1; i < NumPlace; ++i)\n{\n  if ((isa < CXXDefaultArgExpr) > E->getPlacementArg(i))\n    break;\n\n  OS << \", \";\n  PrintExpr(E->getPlacementArg(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/AST/StmtPrinter/10"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  estimate_threshold(num, i, minP, maxP, minK, maxK, minN, maxN, minF, maxF, minT, maxT, topoinfo, dist, SF);\n  if (minT[i] < 0.01)\n  {\n    tmpfold = 10.0;\n    while ((minT[i] * tmpfold) < 0.01)\n    {\n      tmpfold = tmpfold * 10.0;\n    }\n\n    amplifyfold[i] = tmpfold;\n  }\n  else\n  {\n    amplifyfold[i] = 1;\n  }\n\n  printf(\"%s\\t%f\\n\", topoinfo->Gname[i], amplifyfold[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/24"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 3; k < (grid_points[2] - 3); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/122"}
{"code": "for (i = 0; i < HWC_conv_t2; i++)\n  conv_t2[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-gpu/5"}
{"code": "for (int i = 0; i < nonzeros; i++)\n{\n  int row_index = row_indexes[i];\n  int col_index = col_indexes[i];\n  float val = values[i];\n  int tid = omp_get_thread_num();\n  temp[tid][row_index] += B[col_index] * val;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muneeb706/Sparse-Matrix-Vector-Mul/spmv-openmp/0"}
{"code": "for (m = 1; m <= nnnn; m++)\n{\n  RestrictionNd(q, vv, m, nn, n0);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Restriction/1"}
{"code": "for (i = 1; i < M; i++)\n  for (j = 1; j < M; j++)\n{\n  L2 = sizedim[i];\n  L3 = sizedim[j];\n  futures.push_back(async(ProcessInnerBlock, &A[((x + start[i]) * N) + (y + start[j])], &A[(x * N) + (y + start[j])], &A[((x + start[i]) * N) + y], L1, L2, L3, N));\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/hpx/bench/lu/hpx-lu/6"}
{"code": "for (int i = 0; i < line; i++)\n{\n  if (len[i] > 0)\n  {\n    for (int j = 0; j < len[i]; j++)\n      (encrypted << outmsg_ll[i][j]) << \" \";\n\n    (encrypted << 0) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ReinhartC/Parallel-RSA-on-Raspberry-Pi/Builds/LB_OMP_MPI/RSA_LB_OMP_MPI/7"}
{"code": "for (j = 0; j < M; j++)\n{\n  printf(\"%g\", B[j * ((250 * 1024) / 256)]);\n  for (k = 1; k < ((250 * 1024) / 256); k++)\n  {\n    printf(\" %g\", B[(j * ((250 * 1024) / 256)) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/8"}
{"code": "for (j = first; j < (N - 1); j += 1)\n{\n  if (A[j] > A[j + 1])\n  {\n    swap(&A[j], &A[j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none),shared(A,first,N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dudaeitelven/OpenMp/main/0"}
{"code": "for (j = nrows; j >= 1; j--)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/24"}
{"code": "for (long i = 0; i < 1000; ++i)\n{\n  TEST_ASSERT_IN_RANGE(random_scalar(min, max), min, max);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kwasniok/cpp-raytracing/src/test/cpp_raytracing/random/1"}
{"code": "for (int i = 0; i < 2000; i++)\n{\n  for (int j = 0; j < 2000; j++)\n  {\n    res += matrice_A[(i * 2000) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omar-E-R/tp-programmation-parallel-openMP/TP1/calculmatV4/0"}
{"code": "for (i = 0; i < ((int) max_iter); ++i)\n{\n  if (!strcmp(crypted, tab))\n  {\n    printf(\">>> Thread n\u00b0%d: password found: %s\\n\", omp_get_thread_num(), tab);\n    ret = i;\n  }\n\n  if (ret != 0)\n  {\n  }\n\n  ++tab[0];\n  for (j = 0; j < (length - 1); ++j)\n  {\n    if (last_char == tab[j])\n    {\n      tab[j] = first_char;\n      ++tab[j + 1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Yulypso/Richarallele/OpenMp/Ex3/breaker_for/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = (y[i] * 2) + (b * i);\n  y[i] = x[i] + (a / (i + 1));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment9/Task1/Dependency/3"}
{"code": "for (size_t i = 0; i < partitions.size(); i++)\n{\n  createBalancedSubtree(partitions.at(i), maxLevel);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csteuer/ParallelBottomUpBalancedOctreeBuilder/octreebuilder/octree_utils/0"}
{"code": "for (k = 1; k < n; ++k)\n  s += (data[k]) ? (1.L / data[k]) : (0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/5"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/128"}
{"code": "for (size_t y = 0; y < height; y++)\n{\n  for (size_t x = 0; x < width; x++)\n  {\n    ss << ((data[get_index(x, y, width)]) ? ('*') : (' '));\n  }\n\n  ss << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bart1259/ConwayOpenMP/gameOfLife/0"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  A[i] = i / 2.0;\n  B[i] = ((8192 - 1) - i) / 3.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/OMPSpec/target-3c/src/target-3c/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvgeniiSamarin/OPenMP/openMP/main/6"}
{"code": "for (i = 0; i < (384 - 2); ++i)\n{\n  *(redmeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 2));\n  *(greenmeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 2));\n  *(bluemeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 2));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-3/codes/with-sections/meanfilter3x3/3"}
{"code": "for (i = 0; i < model->t_vec->size; ++i)\n{\n  for (j = 0; j < model->tB_vec->size; ++j)\n  {\n    tmp = model->t_vec->data[i] - model->tB_vec->data[j];\n    if (tmp > max_t)\n      max_t = tmp;\n\n    if (tmp < min_t)\n      min_t = tmp;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/7"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < coulmns; j++)\n  {\n    a[i][j] = 3;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yousaf2018/OpenMP-programming-/mulitplication_using_omp_dynamic_memory_allocation/0"}
{"code": "for (i = 0; i < this->input_size; ++i)\n{\n  intermediate = intermediate + ((*(this->weights + i)) * (*(_input + i)));\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/Machine Learning/LinearRegression/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  float city_probs[10000] = {0};\n  for (int j = 0; j < (10000 - 1); j++)\n  {\n    register int curr = ants[i].currentCity;\n    float prob = ((float) randUint()) / 0xffffffffU;\n    float denominator = 0;\n    for (int k = 0; k < 10000; k++)\n    {\n      if (ants[i].city_flags[k])\n      {\n        float len = dist(curr, k);\n        len = 1.0 / len;\n        register float tmp = sqrt(pheromones[curr][k] * len);\n        city_probs[k] = tmp;\n        denominator += tmp;\n      }\n\n    }\n\n    prob *= denominator;\n    float cumulativeProb = 0;\n    for (int k = 0; k < 10000; k++)\n    {\n      if (ants[i].city_flags[k])\n      {\n        cumulativeProb += city_probs[k];\n        if (prob < cumulativeProb)\n        {\n          ants[i].city_flags[k] = 0;\n          ants[i].pathLength += dist(curr, k);\n          ants[i].currentCity = k;\n          ants[i].route[j + 1] = k;\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n  ants[i].pathLength += dist(ants[i].currentCity, ants[i].initialCity);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project3/Ant-Colony/1"}
{"code": "for (n = 0; n < nThreads; n++)\n{\n  for (int i = 1; i < nOfLayers; i++)\n  {\n    for (int j = 0; j < layers[i].nOfNeurons; j++)\n    {\n      copys[n][i].neurons[j].out = layers[i].neurons[j].out;\n      for (int k = 0; k < (layers[i - 1].nOfNeurons + 1); k++)\n      {\n        if (layers[i].neurons[j].deltaW != NULL)\n        {\n          copys[n][i].neurons[j].deltaW[k] = layers[i].neurons[j].deltaW[k];\n          copys[n][i].neurons[j].w[k] = layers[i].neurons[j].w[k];\n          copys[n][i].neurons[j].wCopy[k] = layers[i].neurons[j].wCopy[k];\n          copys[n][i].neurons[j].lastDeltaW[k] = layers[i].neurons[j].lastDeltaW[k];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/23"}
{"code": "for (i = 0; i < 8; i++)\n{\n  Vertex a = {.title = i, .visited = 0};\n  vertices[i] = a;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/upadhyatejas/HPC-parallelization/djiparallel/6"}
{"code": "for (i = 0; i < 26; i++)\n{\n  g_trie = merge_all(g_trie, trie_list, num_threads, i);\n}\n\n", "pragma": "omp for private(i) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svaderia/ParallelDF/driver/1"}
{"code": "for (l = 1; l < 760; l++)\n{\n  y[l] = c + (l * k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/7"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (2 * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    v_t3 = _mm_loadl_pi(v_t3, (__m64 *) (&sct[kmr * j]));\n    v_t3 = _mm_movelh_ps(v_t3, v_t3);\n    v_t3 = _mm_shuffle_ps(v_t3, v_t3, 177);\n    v_t2 = _mm_load_ps((float *) (&f[(2 * (nxh - j)) + joff]));\n    v_t2 = _mm_mul_ps(v_t2, v_n);\n    v_t4 = _mm_load_ps((float *) (&f[(2 * j) + joff]));\n    v_t1 = _mm_add_ps(v_t4, v_t2);\n    v_t2 = _mm_sub_ps(v_t4, v_t2);\n    v_t4 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t3, v_t3, 160));\n    v_t2 = _mm_shuffle_ps(v_t2, v_t2, 177);\n    v_t2 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t3, v_t3, 245));\n    v_t2 = _mm_add_ps(v_t4, _mm_mul_ps(v_t2, v_m));\n    v_t3 = _mm_add_ps(v_t1, v_t2);\n    _mm_store_ps((float *) (&f[(2 * j) + joff]), v_t3);\n    v_t4 = _mm_mul_ps(_mm_sub_ps(v_t1, v_t2), v_n);\n    _mm_store_ps((float *) (&f[(2 * (nxh - j)) + joff]), v_t4);\n  }\n\n  for (jj = 0; jj < 2; jj++)\n  {\n    f[(jj + (2 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (2 * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      v_t1 = _mm_load_ps((float *) (&f[(2 * j1) + joff]));\n      v_t2 = _mm_load_ps((float *) (&f[(2 * j) + joff]));\n      _mm_store_ps((float *) (&f[(2 * j1) + joff]), v_t2);\n      _mm_store_ps((float *) (&f[(2 * j) + joff]), v_t1);\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (2 * ns2) * k;\n      k2 = k1 + (2 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        v_t1 = _mm_loadl_pi(v_t1, (__m64 *) (&sct[kmr * j]));\n        v_t1 = _mm_movelh_ps(v_t1, v_t1);\n        v_t1 = _mm_mul_ps(v_t1, v_n);\n        v_t2 = _mm_load_ps((float *) (&f[((2 * j) + k2) + joff]));\n        v_t3 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 160));\n        v_t2 = _mm_shuffle_ps(v_t2, v_t2, 177);\n        v_t2 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 245));\n        v_t2 = _mm_add_ps(v_t3, _mm_mul_ps(v_t2, v_m));\n        v_t3 = _mm_load_ps((float *) (&f[((2 * j) + k1) + joff]));\n        v_t4 = _mm_sub_ps(v_t3, v_t2);\n        _mm_store_ps((float *) (&f[((2 * j) + k2) + joff]), v_t4);\n        v_t2 = _mm_add_ps(v_t3, v_t2);\n        _mm_store_ps((float *) (&f[((2 * j) + k1) + joff]), v_t2);\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    v_t1 = _mm_load_ps((float *) (&f[(2 * j) + joff]));\n    v_t1 = _mm_shuffle_ps(v_t1, v_t1, 216);\n    _mm_store_ps((float *) (&f[(2 * j) + joff]), v_t1);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/ssempush2/4"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  in3[i] = 0.0;\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  scanf(\"%d\", &ar[i]);\n  sum[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gunjapandey/Introduction-to-OpenMP/l2_prog3/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  inout[i] += u[i] * v[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/7"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int result_x_r = 0;\n    int result_x_g = 0;\n    int result_x_b = 0;\n    int result_y_r = 0;\n    int result_y_g = 0;\n    int result_y_b = 0;\n    for (int s = -1; s <= 1; s++)\n    {\n      if (((i + s) < 0) || ((i + s) >= height))\n      {\n        result_x_r += 0;\n        result_x_g += 0;\n        result_x_b += 0;\n        result_y_r += 0;\n        result_y_g += 0;\n        result_y_b += 0;\n      }\n      else\n      {\n        for (int t = -1; t <= 1; t++)\n        {\n          if (((j + t) < 0) || ((j + t) >= width))\n          {\n            result_x_r += 0;\n            result_x_g += 0;\n            result_x_b += 0;\n            result_y_r += 0;\n            result_y_g += 0;\n            result_y_b += 0;\n          }\n          else\n          {\n            result_x_r += m_x[s + 1][t + 1] * pixels[i + s][j + t].r;\n            result_x_g += m_x[s + 1][t + 1] * pixels[i + s][j + t].g;\n            result_x_b += m_x[s + 1][t + 1] * pixels[i + s][j + t].b;\n            result_y_r += m_y[s + 1][t + 1] * pixels[i + s][j + t].r;\n            result_y_g += m_y[s + 1][t + 1] * pixels[i + s][j + t].g;\n            result_y_b += m_y[s + 1][t + 1] * pixels[i + s][j + t].b;\n          }\n\n        }\n\n      }\n\n    }\n\n    pixels_aux[i][j].r = abs(weight * result_x_r) + abs(weight * result_y_r);\n    pixels_aux[i][j].g = abs(weight * result_x_g) + abs(weight * result_y_g);\n    pixels_aux[i][j].b = abs(weight * result_x_b) + abs(weight * result_y_b);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariomnz/Cpp-parallelism-image-filter/image-par/1"}
{"code": "for (n = 0; buf; n++, input_chain->next = input_chain_alloc(), input_chain = input_chain->next)\n{\n  t = atof(buf);\n  avg += t;\n  input_chain_append(t, input_chain);\n  buf = fgets(buf, 0xffff, stdin);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Terminus-IMRC/stddev_openmp/stddev/1"}
{"code": "for (i = ID; i < 20; i += nthreads)\n{\n  v[i]++;\n  printf(\"v[%d] = %d, ID = %d\\n\", i, v[i], ID);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eliBiagioli/OpenMP_esercizi/prova_C/prova3/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    A[j + (i * n)] = (double) ((i == j) ? (i * i) : (i + j));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/2"}
{"code": "for (int i = 0; i < data_.height(); ++i)\n{\n  for (int j = 0; j < data_.width(); ++j)\n  {\n    frame_[i][j] = evaluatePixel(j, i);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DenDunno/MandelbrotSet/MandelbrotSet/openmpalgorithm/0"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  xRef[i][0] = 0.0;\n  xRef[i][1] = 0.0;\n  xRef[i][2] = 0.0;\n  neigh[i][0] = 0;\n  for (j = i + 1; j < N2; j++)\n  {\n    if ((i == 0) && (j == (N2 - 2)))\n      continue;\n\n    if ((i == 1) && (j == (N2 - 1)))\n      continue;\n\n    if (j == (i + 2))\n      continue;\n\n    del[0] = x[i][0] - x[j][0];\n    del[1] = x[i][1] - x[j][1];\n    del[2] = x[i][2] - x[j][2];\n    rsq = ((del[0] * del[0]) + (del[1] * del[1])) + (del[2] * del[2]);\n    if (rsq < neighCutSq)\n    {\n      neigh[i][++neigh[i][0]] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided,100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/neighbour/4"}
{"code": "for (int i = y; i < (y + height); i++)\n  for (int j = x; j < (x + width); j++)\n{\n  compute_new_state(i, j);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/19"}
{"code": "for (i = 0; i < NGROUPS; i += 40)\n{\n  printf(\"\\n  z%2d -- \", i);\n  for (j = 0; j < NFEAT; j++)\n    printf(\"%5.1f\", cent[i][j]);\n\n  printf(\"\\n          %5.6f\\n\", compact[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/12"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    DxDxu[IDX(ie - 2, j, k)] = ((u[IDX(ie - 3, j, k)] - (2.0 * u[IDX(ie - 2, j, k)])) + u[IDX(ie - 1, j, k)]) * idx_sqrd;\n    DxDxu[IDX(ie - 1, j, k)] = ((((-u[IDX(ie - 4, j, k)]) + (4.0 * u[IDX(ie - 3, j, k)])) - (5.0 * u[IDX(ie - 2, j, k)])) + (2.0 * u[IDX(ie - 1, j, k)])) * idx_sqrd;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/15"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int temp = ele_in_row_bloc[i];\n  row_bloc_pref[i] = pref_sum;\n  pref_sum += temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prakharg24/openmpi_openmp_2d_sort/2d_sort/10"}
{"code": "for (long i = 0; i < contRelationOk; i++)\n{\n  vect_solution[i] = 0;\n  vect_pivot[i] = -1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_gmp/4"}
{"code": "for (int i = 0; i < (num_elements * num_elements); i++)\n  if (data[i] != NULL)\n{\n  fftw_free(data[i]);\n  data[i] = NULL;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/spectral_methods/spectral_methods_omp/0"}
{"code": "for (i = 0; i < (20 + 1); i++)\n{\n  int j;\n  omp_lock_t *my_lcks = &lcks[i * 1000];\n  for (j = 0; j < 1000; j++)\n  {\n    omp_init_lock(&my_lcks[j]);\n  }\n\n  for (j = 0; j < (1000 * 100); j++)\n  {\n    omp_set_lock(&my_lcks[j % 1000]);\n    omp_unset_lock(&my_lcks[j % 1000]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) num_threads(NUM_TASKS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/lock/omp_init_lock/0"}
{"code": "for (int i = 0; i < no_clauses; i++)\n{\n  if (equation[i][var] != 0)\n  {\n    assgn[i][var] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdkul22/satsolve/satool_omp/12"}
{"code": "for (i = 0; i < l; ++i)\n  kvalue[i] = k_function(x, model->SV[i], model->param);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/billyeh/cs194project/libsvm-3.20/svm/1"}
{"code": "for (int i = k + 1; i < size; i++)\n{\n  __temp[i] = (l_[i][k] = a_[i][k] / _v);\n  u_r[i] = a_r[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/new_openmp/0"}
{"code": "for (int i = 0; i < outm; i++)\n{\n  for (int j = 0; j < outm; j++)\n  {\n    int a = 0;\n    int wh = ((i * outm) * convAw) + (j * convAw);\n    for (int m = 0; m < convAw; m++)\n    {\n      a += A_convert[wh + m] * B[m];\n    }\n\n    C[(i * map) + j] = a;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lizhanggg/Juanji_OpenMP/Juanji_OpenMP/1"}
{"code": "for (j = 1; j <= n; j++)\n{\n  rowstr[j] = 0;\n  mark[j] = FALSE;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/17"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    b[i][j] = randomize(&seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kothiga/Matrix-Matrix-Parallel/MatMultOpenMP/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Fib[%lld] = %lld\\n\", i, fib(i));\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/add19/Parallel-Programming/parallel_fib/0"}
{"code": "for (i = 1; i < Nx; i++)\n{\n  for (j = 1; j < Ny; j++)\n  {\n    u[i][j] = (((pow(dt, 2) * f(x[i], y[j], t[n])) + (g * (((u_1[i + 1][j] + u_1[i][j + 1]) + u_1[i - 1][j]) + u_1[i][j - 1]))) + ((2 * u_1[i][j]) * (1 - (2 * g)))) - u_2[i][j];\n    r[i][j] = analytical(x[i], y[j], t[n]);\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/8"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 0; k <= (grid_points[2] - 3); k++)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n    lhs[n + 1][i][j][k2] = lhs[n + 1][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j][k2] = lhs[n + 2][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k2] = rhs[m][i][j][k2] - (lhs[n + 0][i][j][k2] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,fac1 ,k1 ,m ,n )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/194"}
{"code": "for (i = 0; i < uZ.nx; i++)\n{\n  for (j = 0; j < uZ.ny; j++)\n  {\n    dist = GeoDistOnSphere(uZ.getX(i, j), uZ.getY(i, j), eq.fault[0].lon, eq.fault[0].lat) * 1000;\n    if (dist < effRad)\n      uZ(i, j) = effMax * cos(((M_PI / 2) * dist) / effRad);\n    else\n      uZ(i, j) = 0.;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/14"}
{"code": "for (j = 0; j < m; j++)\n{\n  for (i = 0; i < n; i++)\n  {\n    a[i][j] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(a,n,m) private(tid,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunobehnken/OpenMP-Studies/Classes/Class_2/p2_matriz_paralela/0"}
{"code": "for (i = 0; i < num_elements; i++)\n{\n  sum += vector_a[i] * vector_b[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum) schedule(guided)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_synchronization_constructs/2"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n  A[i][j] = ((DATA_TYPE) ((i + j) % n)) / (5 * m);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/atax/atax/4"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double ni = pndi[i];\n  if (((particleType[i] == fluid) && (particleNearWall[i] == true)) && (ni > 1.0e-8))\n  {\n    double DivV = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double Rinv_i[9];\n    double Rref_i[9];\n    double normaliw[3];\n    double normalMod2;\n    normaliw[0] = 0.5 * (posXi - posMirrorXi);\n    normaliw[1] = 0.5 * (posYi - posMirrorYi);\n    normaliw[2] = 0.5 * (posZi - posMirrorZi);\n    normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n    if (normalMod2 > 1.0e-8)\n    {\n      double normalMod = sqrt(normalMod2);\n      normaliw[0] = normaliw[0] / normalMod;\n      normaliw[1] = normaliw[1] / normalMod;\n      normaliw[2] = normaliw[2] / normalMod;\n    }\n    else\n    {\n      normaliw[0] = 0;\n      normaliw[1] = 0;\n      normaliw[2] = 0;\n    }\n\n    Rinv_i[0] = -1.0;\n    Rinv_i[1] = 0.0;\n    Rinv_i[2] = 0.0;\n    Rinv_i[3] = 0.0;\n    Rinv_i[4] = -1.0;\n    Rinv_i[5] = 0.0;\n    Rinv_i[6] = 0.0;\n    Rinv_i[7] = 0.0;\n    Rinv_i[8] = -1.0;\n    Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n    Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n    Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n    Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n    Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n    Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n    Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n    Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n    Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n    double viwall[3];\n    double vtil[3];\n    viwall[0] = (viwall[1] = (viwall[2] = 0.0));\n    if (nearMeshType[i] == FORCED)\n    {\n      viwall[0] = velVWall[0];\n      viwall[1] = velVWall[1];\n      viwall[2] = velVWall[2];\n    }\n\n    double dotnv = ((normaliw[0] * viwall[0]) + (normaliw[1] * viwall[1])) + (normaliw[2] * viwall[2]);\n    vtil[0] = velXi - (2.0 * (viwall[0] - (dotnv * normaliw[0])));\n    vtil[1] = velYi - (2.0 * (viwall[1] - (dotnv * normaliw[1])));\n    vtil[2] = velZi - (2.0 * (viwall[2] - (dotnv * normaliw[2])));\n    double velMirrorXi = ((Rinv_i[0] * vtil[0]) + (Rinv_i[1] * vtil[1])) + (Rinv_i[2] * vtil[2]);\n    double velMirrorYi = ((Rinv_i[3] * vtil[0]) + (Rinv_i[4] * vtil[1])) + (Rinv_i[5] * vtil[2]);\n    double velMirrorZi = ((Rinv_i[6] * vtil[0]) + (Rinv_i[7] * vtil[1])) + (Rinv_i[8] * vtil[2]);\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if (((dstij2 < reS2) && (dstimj2 < reS2)) && (dstij2 < dstimj2))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstimj2);\n                double wS = weight(dst, reS, weightType);\n                double vijx = -(vel[j * 3] - velMirrorXi);\n                double vijy = -(vel[(j * 3) + 1] - velMirrorYi);\n                double vijz = -(vel[(j * 3) + 2] - velMirrorZi);\n                double v0m = ((Rref_i[0] * v0imj) + (Rref_i[1] * v1imj)) + (Rref_i[2] * v2imj);\n                double v1m = ((Rref_i[3] * v0imj) + (Rref_i[4] * v1imj)) + (Rref_i[5] * v2imj);\n                double v2m = ((Rref_i[6] * v0imj) + (Rref_i[7] * v1imj)) + (Rref_i[8] * v2imj);\n                DivV += ((((dim / pndSmallZero) * (pndi[j] / ni)) * (((vijx * v0m) + (vijy * v1m)) + (vijz * v2m))) * wS) / dstimj2;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    double v0imi;\n    double v1imi;\n    double v2imi;\n    double dstimi2;\n    sqrDistBetweenParticles(i, posMirrorXi, posMirrorYi, posMirrorZi, v0imi, v1imi, v2imi, dstimi2);\n    if (dstimi2 < reS2)\n    {\n      double dst = sqrt(dstimi2);\n      double wS = weight(dst, reS, weightType);\n      double vijx = -(velXi - velMirrorXi);\n      double vijy = -(velYi - velMirrorYi);\n      double vijz = -(velZi - velMirrorZi);\n      double v0m = ((Rref_i[0] * v0imi) + (Rref_i[1] * v1imi)) + (Rref_i[2] * v2imi);\n      double v1m = ((Rref_i[3] * v0imi) + (Rref_i[4] * v1imi)) + (Rref_i[5] * v2imi);\n      double v2m = ((Rref_i[6] * v0imi) + (Rref_i[7] * v1imi)) + (Rref_i[8] * v2imi);\n      DivV += ((((dim / pndSmallZero) * (pndi[i] / ni)) * (((vijx * v0m) + (vijy * v1m)) + (vijz * v2m))) * wS) / dstimi2;\n    }\n\n    acc[i * 3] += ((-pndi[i]) * timeStep) * DivV;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/40"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < height; j++)\n    array2D[(i * height) + j] = colorF(i, j);\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mustafamajid1/SpeedUpFractals/main/2"}
{"code": "for (i = 0; i < array_size; i++)\n{\n  int disarium = disarium_number(numbers[i]);\n  if (disarium == i)\n  {\n    checked[disarium] = 1;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(numbers, checked) private(i) \\", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/itwitch13/parallel-solutions/DisariumNumber/openMPDisarium/2"}
{"code": "for (int ii = 0; ii < num_test; ii++)\n{\n  t0 = clock();\n  const size_t nMatches = index.radiusSearch(mesh.vert[test_indeces[ii]].P().V(), queryDist, ret_matches, params);\n  avgTime += elapsed(t0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dfsp-spirit/cpp_geodesics/third_party/vcglib/apps/sample/trimesh_indexing/trimesh_indexing/2"}
{"code": "for (bits = 0; bits < dstbits; bits += 6)\n{\n  uint32_t c = atoi64[*(src++)];\n  if (c > 63)\n  {\n    *dst = 0;\n    return 0;\n  }\n\n  *dst |= c << bits;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/scrypt_fmt/2"}
{"code": "for (k = lt; k >= (lb + 1); k--)\n{\n  j = k - 1;\n  rprj3(&r[ir[k]], m1[k], m2[k], m3[k], &r[ir[j]], m1[j], m2[j], m3[j], k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/15"}
{"code": "for (int k = 0; k < num_vertices; k++)\n{\n  if (cheap[k] != (-1))\n  {\n    if (sets.same(edges[cheap[k]].source, edges[cheap[k]].dest))\n    {\n      continue;\n    }\n\n    int source = sets.find(edges[cheap[k]].source);\n    int dest = sets.find(edges[cheap[k]].dest);\n    printf(\"Edge %d->%d included in MST\\n\", edges[cheap[k]].source, edges[cheap[k]].dest, edges[cheap[k]].weight);\n    sets.unite(source, dest);\n    sum[k] = edges[cheap[k]].weight;\n    comp[k] = 1;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic,1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/3"}
{"code": "for (int i = 0; i < 10000000; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/argha072k/openmp/arr2/1"}
{"code": "for (int i = 0; i < list.size(); i++)\n{\n  if (((get < 0) > list[i]) != 0.0)\n  {\n    return (get < 1) > list[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SebaSwash/Tarea3_SO/t3b/0"}
{"code": "for (int i = 0; i < m_dims[0]; i++)\n{\n  for (int j = 0; j < m_Ny; j++)\n  {\n    for (int k = 0; k < m_dims[2]; k++)\n    {\n      f[(i + (j * m_dims[0])) + ((k * m_dims[0]) * m_Ny)] = tmp[(k + (m_dims[2] * j)) + ((m_dims[2] * m_Ny) * i)];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/src/Scalar/14"}
{"code": "for (int count_column = 0; count_column < columns; count_column++)\n{\n  ptrmatrixOMP[count_row][count_column] = ptrarray[(count_row * columns) + count_column];\n}\n\n", "pragma": "                #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/OMPmultMatrixAndVector/OMPmultMatrixAndVector/OMPmultMatrixAndVector/7"}
{"code": "for (unsigned n = 0; n < set->natoms; n++)\n{\n  for (int i = 0; i < 3; i++)\n  {\n    if (set->pos.x[n + (i * set->offset)] < domain->min_ext[i])\n    {\n      set->pos.x[n + (i * set->offset)] = domain->min_ext[i];\n      set->speed.dx[n + (i * set->offset)] *= -1;\n      atom_state[n] = 50;\n    }\n\n    if (set->pos.x[n + (i * set->offset)] > domain->max_ext[i])\n    {\n      set->pos.x[n + (i * set->offset)] = domain->max_ext[i];\n      set->speed.dx[n + (i * set->offset)] *= -1;\n      atom_state[n] = 50;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP2/Particules/fichiers/libsotl/src/openmp/5"}
{"code": "for (int j = 0; j < matrixN; j++)\n{\n  for (int i = 0; i < matrixN; i++)\n  {\n    colMat[i][j] += Mat[i][j] * Vec[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/3/3/9"}
{"code": "for (i = 0; i < 10; i++)\n  vec[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/parallel/cluster-system/openmp/reduction-omp-carte/1"}
{"code": "for (wJ = wI; wJ < (wI + (SMALLN / 4)); wJ++)\n{\n  wReturned += aVect1[wJ] * aVect2[wJ];\n}\n\n", "pragma": "omp parallel for reduction(+:wReturned) firstprivate(wI) private(wJ)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/vects/4"}
{"code": "for (int x = x_M / 2; x < x_M; x += 1)\n{\n  for (int y = y_m; y < y_M; y += 1)\n  {\n    u[y + (x * GRID_SIZE)] = u[y + (x * GRID_SIZE)] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/omp-par-for/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  for (i = 0; i < n; i++)\n  {\n    for (j = 0; j < n; j++)\n    {\n      int ij = (i * n) + j;\n      int ik = (i * n) + k;\n      int kj = (k * n) + j;\n      if ((dist[ik] + dist[kj]) < dist[ij])\n      {\n        dist[ij] = dist[ik] + dist[kj];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/1"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  for (k = 0; k < 1000; k++)\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/autoParallelization/tests/matrixmultiply/0"}
{"code": "for (int i = 0; i < n_max; ++i)\n{\n  printf(\"%.3f \", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zsxoff/course-parallel-programming/task-3/src/omp/1"}
{"code": "for (i = 0; i < 100000; ++i)\n{\n  suma[i] = A[i] + B[i];\n}\n\n", "pragma": "omp parallel for private(i) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_sections/main/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (i,n,i1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/175"}
{"code": "for (i = 0; i < numOfPoints; i++)\n{\n  if (points[i].belongTo != belongTo[i])\n    *change = 1;\n\n  points[i].belongTo = belongTo[i];\n  clusters[belongTo[i]].numOfPointsInProc++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/KmeansParallel/9"}
{"code": "for (j = 0; j < bucket_size; j++)\n{\n  for (i = 0; i < buckets[j].count; i++)\n  {\n    data[buckets[j].index + i] = buckets[j].data[i];\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/mainK/2"}
{"code": "for (long v = 0; v < NVer; v++)\n{\n  long adj1 = verPtr[v];\n  long adj2 = verPtr[v + 1];\n  if (vtxColor[v] == maxColor)\n  {\n    __sync_fetch_and_add(&unColored, 1);\n    continue;\n  }\n\n  for (long k = adj1; k < adj2; k++)\n  {\n    if (v == verInd[k].tail)\n      continue;\n\n    if (vtxColor[v] == vtxColor[verInd[k].tail])\n    {\n      __sync_fetch_and_add(&myConflicts, 1);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringMultiHashMaxMin/4"}
{"code": "for (int n = 0; n < n_time_steps; n++)\n{\n  calculate_centers_of_mass(particles, cells, grid_size, number_particles);\n  calculate_new_iteration(particles, cells, grid_size, number_particles);\n  memset(cells[0], 0, (((sizeof(cell_t)) * grid_size) * grid_size) * num_max_threads);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/openmp/simpar-omp/6"}
{"code": "for (int i = 2 * (i & x); i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/42"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double posXi = pos[i * 3];\n  double posYi = pos[(i * 3) + 1];\n  double posZi = pos[(i * 3) + 2];\n  double posMirrorXi = mirrorParticlePos[i * 3];\n  double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n  double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n  double wSum = 0.0;\n  numNeigh[i] = 0;\n  npcdDeviation[i * 3] = (npcdDeviation[(i * 3) + 1] = (npcdDeviation[(i * 3) + 2] = 0.0));\n  int ix;\n  int iy;\n  int iz;\n  bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n  int minZ = (iz - 1) * ((int) (dim - 2.0));\n  int maxZ = (iz + 1) * ((int) (dim - 2.0));\n  for (int jz = minZ; jz <= maxZ; jz++)\n  {\n    for (int jy = iy - 1; jy <= (iy + 1); jy++)\n    {\n      for (int jx = ix - 1; jx <= (ix + 1); jx++)\n      {\n        int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n        int j = firstParticleInBucket[jb];\n        if (j == (-1))\n          continue;\n\n        double plx;\n        double ply;\n        double plz;\n        getPeriodicLengths(jb, plx, ply, plz);\n        while (true)\n        {\n          double v0ij;\n          double v1ij;\n          double v2ij;\n          double v0imj;\n          double v1imj;\n          double v2imj;\n          double dstij2;\n          double dstimj2;\n          sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n          sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n          if ((dstij2 < reL2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n          {\n            if (j != i)\n            {\n              numNeigh[i] += 1;\n              if (dstij2 < reS2)\n              {\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                pndi[i] += wS;\n                npcdDeviation[i * 3] += v0ij * wS;\n                npcdDeviation[(i * 3) + 1] += v1ij * wS;\n                npcdDeviation[(i * 3) + 2] += v2ij * wS;\n                wSum += wS;\n              }\n\n            }\n\n          }\n\n          j = nextParticleInSameBucket[j];\n          if (j == (-1))\n            break;\n\n        }\n\n      }\n\n    }\n\n  }\n\n  pndi[i] += pndWallContribution[i];\n  if (particleType[i] == wall)\n    pndi[i] = pndSmallZero;\n\n  pndSmall[i] = pndi[i];\n  pndki[i] = pndi[i];\n  numNeigh[i] += numNeighWallContribution[i];\n  if (wSum > 1.0e-8)\n  {\n    npcdDeviation[i * 3] /= pndSmall[i];\n    npcdDeviation[(i * 3) + 1] /= pndSmall[i];\n    npcdDeviation[(i * 3) + 2] /= pndSmall[i];\n  }\n\n  npcdDeviation2[i] = ((npcdDeviation[i * 3] * npcdDeviation[i * 3]) + (npcdDeviation[(i * 3) + 1] * npcdDeviation[(i * 3) + 1])) + (npcdDeviation[(i * 3) + 2] * npcdDeviation[(i * 3) + 2]);\n  if ((((npcdDeviation[i * 3] * polygonNormal[i * 3]) + (npcdDeviation[(i * 3) + 1] * polygonNormal[(i * 3) + 1])) + (npcdDeviation[(i * 3) + 2] * polygonNormal[(i * 3) + 2])) < 0.0)\n    deviationDotPolygonNormal[i] = 1;\n  else\n    deviationDotPolygonNormal[i] = -1;\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/9"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/71"}
{"code": "for (size_t n = 0; n < (x * y); ++n)\n{\n  size_t i = n / x;\n  size_t j = n % x;\n  l_ret->MutableData()[n] = a_mat->Data()[(y * j) + i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/curiousinspiration/Optimizing-Our-Neural-Network-With-BLAS-and-OpenMP/src/tensor_math/0"}
{"code": "for (i = 0; i < len; i++)\n  sum2 += a[i] * b[i];\n\n", "pragma": "omp parallel for reduction (+:sum2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB097-target-teams-distribute-orig-no/1"}
{"code": "for (j = 1; j < m; j++)\n  b[i][j] = b[i][j - 1];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/truedepseconddimension-orig-yes/0"}
{"code": "for (int i = 0; i < xelem; i++)\n{\n  sclr.p[i].resize(yelem);\n  sclr.u[i].resize(yelem);\n  sclr.v[i].resize(yelem);\n  sclr.phi[i].resize(yelem);\n  sclr.rho[i].resize(yelem);\n  sclr.mu[i].resize(yelem);\n  for (int j = 0; j < yelem; j++)\n  {\n    sclr.p[i][j].resize(zelem, 0.0);\n    sclr.u[i][j].resize(zelem, 0.0);\n    sclr.v[i][j].resize(zelem, 0.0);\n    sclr.phi[i][j].resize(zelem, 0.0);\n    sclr.rho[i][j].resize(zelem, rhof);\n    sclr.mu[i][j].resize(zelem, muf);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jichenglee/INS_LevelSet/NE577/main/2"}
{"code": "for (int z = 0; z < n; z++)\n{\n  L[z] = l[z];\n  p[0][z] = l[z];\n}\n\n", "pragma": "omp parallel for num_threads ( NUMERO_TH_TEST )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/0"}
{"code": "for (size_t i = 0; i < (*this).rows(); ++i)\n{\n  for (size_t j = 0; j < (*this).cols(); ++j)\n  {\n    ss << (*this)(i, j);\n    if (j != ((*this).cols() - 1))\n      ss << \" \";\n\n  }\n\n  ss << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/first/Matrix/3"}
{"code": "for (int i = 0; i < (n * n); i++)\n{\n  original_matrix[i] = matrix[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/10"}
{"code": "for (size_t i = 0; i < N_BUCKETS; i++)\n{\n  for (size_t j = 0; j < size; j++)\n  {\n    size_t n_bucket = ((arr[j] + abs(min)) * N_BUCKETS) / abs(max + abs(min));\n    n_bucket = (n_bucket >= N_BUCKETS) ? (N_BUCKETS - 1) : (n_bucket);\n    if (n_bucket == i)\n    {\n      fprintf(stderr, \"%zu<- %d\\n\", i, arr[j]);\n      buckets[i]->array[buckets[i]->n_elem++] = arr[j];\n    }\n\n  }\n\n  qsort(buckets[i]->array, buckets[i]->n_elem, sizeof(int), cmpfunc);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/final_code/main/5"}
{"code": "for (unsigned int i = 0; i < LEN; i++)\n  sum += arr[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sergioge99/vectorization_and_parallelism/practicas_paralelizacion/p6_iaca_valgrind_aps/triad/5"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1332[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/54"}
{"code": "for (k = 0; k < 10; k++)\n  printf(\"%9d\", k);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/15"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (n = 0; n < 5; n++)\n  {\n    lhs[i][j][k][0][m][n] = 0.0;\n    lhs[i][j][k][1][m][n] = 0.0;\n    lhs[i][j][k][2][m][n] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/18"}
{"code": "for (int dimension = start_2D; dimension <= end_2D; dimension += interval_2D)\n{\n  ijk_algorithmTest(dimension, iterations);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyamramawat/Large_Multiplication_Matrix_OPENMP/19210520_CA670_Assignment_2/Code/7"}
{"code": "for (j = 0; j < 10; ++j)\n{\n  for (k = 0; k < 10; ++k)\n    x[i][j][k] = k;\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr56883/6"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    sum = 0;\n    for (k = 0; k < 1000; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,sum) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/multiply/0"}
{"code": "for (i = 0; i < NoofRows; i++)\n{\n  for (j = 0; j < NoofCols; j++)\n    printf(\"%f \\t\", Matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/5"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  for (j = 0; j < npp; j++)\n  {\n    dx = ppart[j + (nppmx * (idimp * l))];\n    dy = ppart[j + (nppmx * (1 + (idimp * l)))];\n    dz = ppart[j + (nppmx * (2 + (idimp * l)))];\n    ist = 0;\n    if (dx < edgelx)\n      ist = 1;\n\n    if (dx >= edgerx)\n      ist = 2;\n\n    if (dy < edgely)\n      ist += 3;\n\n    if (dy >= edgery)\n      ist += 6;\n\n    if (dz < edgelz)\n      ist += 9;\n\n    if (dz >= edgerz)\n      ist += 18;\n\n    if (ist > 0)\n      *irc = l + 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,l,noff,moff,loff,npp,nn,mm,ll,ist,edgelx,edgely,edgelz, edgerx,edgery,edgerz,dx,dy,dz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/1"}
{"code": "for (i = 0; i < 15000; i++)\n  unique_words[i].numDocsWithWord = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deepakguptancsu/TFIDF-implementation-parallel-computing/TFIDF_mpi_omp/5"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  float t = m_meanTemp[i];\n  float t1 = m_meanTempPre1[i];\n  float t2 = m_meanTempPre2[i];\n  if ((((t > 60.f) || (t < (-90.f))) || ((t1 > 60.f) || (t1 < (-90.f)))) || ((t2 > 60.f) || (t2 < (-90.f))))\n  {\n    ((((((cout << \"cell index: \") << i) << \", t1: \") << t1) << \", t2: \") << t2) << endl;\n    errCount++;\n  }\n  else\n  {\n    if (FloatEqual(CVT_INT(m_landUse[i]), LANDUSE_ID_WATR))\n    {\n      m_soilTemp[i] = t;\n    }\n    else\n    {\n      float t10 = ((((((m_a0 + (m_a1 * t2)) + (m_a2 * t1)) + (m_a3 * t)) + (m_b1 * sin(radWt * m_dayOfYear))) + (m_d1 * cos(radWt * m_dayOfYear))) + (m_b2 * sin((2.f * radWt) * m_dayOfYear))) + (m_d2 * cos((2.f * radWt) * m_dayOfYear));\n      m_soilTemp[i] = (t10 * m_kSoil10) + m_soilTempRelFactor10[i];\n      if ((m_soilTemp[i] > 60.f) || (m_soilTemp[i] < (-90.f)))\n      {\n        ((((((((((((((cout << \"The calculated soil temperature at cell (\") << i) << \") is out of reasonable range: \") << m_soilTemp[i]) << \". JulianDay: \") << m_dayOfYear) << \",t: \") << t) << \", t1: \") << t1) << \", t2: \") << t2) << \", relativeFactor: \") << m_soilTempRelFactor10[i]) << endl;\n        errCount++;\n      }\n\n    }\n\n    m_meanTempPre2[i] = m_meanTempPre1[i];\n    m_meanTempPre1[i] = t;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: errCount)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/STP_FP/SoilTemperatureFINPL/0"}
{"code": "for (i = 0; i < k; i += B)\n  for (j = 0; j < k; j += B)\n  FW(A, k, i, j, B);\n\n\n", "pragma": "omp for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/4"}
{"code": "for (int i = 0; i < (height * width); ++i)\n{\n  if (pixel_sizeof == 1)\n  {\n    max_grey = max(max_grey, data[i]);\n    min_grey = min(min_grey, data[i]);\n  }\n  else\n  {\n    max_r = max(max_r, data[i * pixel_sizeof]);\n    min_r = min(min_r, data[i * pixel_sizeof]);\n    max_g = max(max_g, data[(i * pixel_sizeof) + 1]);\n    min_g = min(min_g, data[(i * pixel_sizeof) + 1]);\n    max_b = max(max_b, data[(i * pixel_sizeof) + 2]);\n    min_b = min(min_b, data[(i * pixel_sizeof) + 2]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(min: min_grey, min_r, min_g, min_b) reduction(max: max_grey, max_r, max_g, max_b) shared(data, pixel_sizeof) schedule(static) num_threads(threads_c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FeggieBoss/OpenMP/src/main/0"}
{"code": "for (int i = row + 1; i < kernel.width; i++)\n{\n  if (kernel.pixels[i][row])\n  {\n    swap(kernel, row, i, rank);\n    reduce = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/1"}
{"code": "for (int i = 1; i < (N - 1); i++)\n{\n  if (implicit_row_scaling == 1)\n    tmp[i - 1] /= s->RS[i];\n\n  r[i] += tmp[i - 1] * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/130"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (getBit(bitmapCurr, v))\n  {\n    degree = graph->vertices[v].out_degree;\n    nodes = graph->vertices[v].outNodes;\n    uint32_t j;\n    for (j = 0; j < degree; j++)\n    {\n      uint32_t u = nodes->dest;\n      uint32_t w = 1;\n      nodes = nodes->next;\n      if (arguments->algo_numThreads == 1)\n        activeVertices += bellmanFordRelax(v, u, w, stats, bitmapNext);\n      else\n        activeVertices += bellmanFordAtomicRelax(v, u, w, stats, bitmapNext);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(nodes,degree,v) shared(graph,stats,bitmapNext,bitmapCurr) reduction(+ : activeVertices) schedule (dynamic,128)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/13"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#2#0\n  #pragma cetus parallel\n  for (j = 0; j < 100; j++)\n  {\n    b[i][j] = b[i][j] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB113-default-orig-no/2"}
{"code": "for (int py = 0; py < nPixXMap; py++)\n{\n  for (int px = 0; px < nPixYMap; px++)\n  {\n    const double xNormData = nDetX - (d_pObjX[py] / d_pDetmX[0]);\n    const int xData = floor(xNormData);\n    const double alpha = xNormData - xData;\n    const double yNormData = (d_pObjY[px] / d_pDetmX[0]) - (d_pDetmY[0] / d_pDetmX[0]);\n    const int yData = floor(yNormData);\n    const double beta = yNormData - yData;\n    double d00;\n    double d01;\n    double d10;\n    double d11;\n    if ((((xNormData >= 0) && (xNormData <= nDetX)) && (yNormData >= 0)) && (yNormData <= nDetY))\n      d00 = d_pProj[((np * nDetYMap) * nDetXMap) + ((xData * nDetYMap) + yData)];\n    else\n      d00 = 0.0;\n\n    if (((((xData + 1) > 0) && ((xData + 1) <= nDetX)) && (yNormData >= 0)) && (yNormData <= nDetY))\n      d10 = d_pProj[((np * nDetYMap) * nDetXMap) + (((xData + 1) * nDetYMap) + yData)];\n    else\n      d10 = 0.0;\n\n    if ((((xNormData >= 0) && (xNormData <= nDetX)) && ((yData + 1) > 0)) && ((yData + 1) <= nDetY))\n      d01 = d_pProj[((np * nDetYMap) * nDetXMap) + (((xData * nDetYMap) + yData) + 1)];\n    else\n      d01 = 0.0;\n\n    if (((((xData + 1) > 0) && ((xData + 1) <= nDetX)) && ((yData + 1) > 0)) && ((yData + 1) <= nDetY))\n      d11 = d_pProj[((np * nDetYMap) * nDetXMap) + ((((xData + 1) * nDetYMap) + yData) + 1)];\n    else\n      d11 = 0.0;\n\n    double result_temp1 = (alpha * d10) + (((-d00) * alpha) + d00);\n    double result_temp2 = (alpha * d11) + (((-d01) * alpha) + d01);\n    d_sliceI[(py * nPixYMap) + px] = (beta * result_temp2) + (((-result_temp1) * beta) + result_temp1);\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/6"}
{"code": "for (i = (11 * n) / 16; i < ((12 * n) / 16); i++)\n  U[i][i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/12"}
{"code": "for (j = 1; j <= i; j++)\n{\n  parallelArray[j][(i - j) + 1] = (((f1(parallelArray[j - 1][((i - j) + 1) - 1]) + f1(parallelArray[j][((i - j) + 1) - 1])) + f1(parallelArray[j - 1][(i - j) + 1])) * f1((parallelArray[j - 1][((i - j) + 1) - 1] + parallelArray[j][((i - j) + 1) - 1]) + parallelArray[j - 1][(i - j) + 1])) % 1000;\n  if (parallelArray[j][(i - j) + 1] == 0)\n    parallelArray[j][(i - j) + 1] = 999;\n\n}\n\n", "pragma": "         #pragma omp for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torniketoka/OpenMP/stencil/2"}
{"code": "for (i = 0; i < N; i++)\n  a[i] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/8/pmm-secuencial/0"}
{"code": "for (i = 0; i < nra; i++)\n{\n  for (j = 0; j < nra; j++)\n    for (k = 0; k < nra; k++)\n    a[((2 * nra) * nra) + ((i * nra) + j)] += a[((0 * nra) * nra) + ((i * nra) + k)] * a[((1 * nra) * nra) + ((k * nra) + j)];\n\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/0"}
{"code": "for (int i = 0; i < probs.size(); ++i)\n{\n  probs[i] /= cur_w;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ctiely/gbdt/tree/ClassificationTree/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    (cout << mat[i][j]) << \" \";\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TeoGavrilescu31/Parallel-Programming-Project-OPENMP/proiect/3"}
{"code": "for (int p = start; p < size; p++)\n{\n  pcls[p].fetch_x() *= -1;\n  pcls[p].fetch_u() *= -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/2"}
{"code": "for (long i = 0; i < N; i += 2)\n{\n  _mm_storeu_pd(&prevSolution[i], _mm_loadu_pd(&solution[i]));\n  _mm_storeu_pd(&r[i], _mm_loadu_pd(&rNext[i]));\n  _mm_storeu_pd(&z[i], _mm_loadu_pd(&zNext[i]));\n}\n\n", "pragma": "#pragma omp parallel for shared(solution, prevSolution, r, rNext, z, zNext, N, chunkSize) BASE_CLAUSE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_1_SSE/5"}
{"code": "for (i = 1; i < 33; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n  if (p >= q)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/clipperz_srp_fmt_plug/3"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    D[(i * N) + j] *= d;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/2"}
{"code": "for (i = 0; i < 4; i++)\n{\n  msg_mac[i] = msg_mac[i + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus85_fmt_plug/6"}
{"code": "for (i = rb; i < re; i++)\n  norm += p_Au[i] * p_Au[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/17"}
{"code": "for (i = 0; i < uZ.nx; i++)\n{\n  for (j = 0; j < uZ.ny; j++)\n  {\n    if (fabs(uZ(i, j)) < absuzmin)\n      uZ(i, j) = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/15"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    if (hashTable[i][j])\n    {\n      pHead = hashTable[i][j];\n      if (pHead)\n      {\n        free(pHead->Key);\n        free(pHead);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Songrui9269/Parallel-Programming-Project-2/Step1 WordCount openMP/1"}
{"code": "for (j = 0; j < 4096; j++)\n{\n  for (i = 0; i < 4096; i++)\n  {\n    s[j] = s[j] + (r[i] * A[(i * 4096) + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/10"}
{"code": "for (int i = 0; i < alto; i++)\n{\n  for (int j = 0; j < ancho; j++)\n  {\n    arr_blur[(((i + n) * (ancho + m)) + j) + n] = arr_flip[(i * ancho) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A01021190/IoTTutorialIan/schedule/4"}
{"code": "for (i = 1; i < nthreads; ++i)\n{\n  in_seed = (unsigned long) ((MULTIPLIER * in_seed) % PMOD);\n  pseed[i] = in_seed;\n  mult_n = (mult_n * MULTIPLIER) % PMOD;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParallelProgTeam/Aula-3-OpenMP/OMP_Exercises/solutions/pi_mc_par_array/1"}
{"code": "for (int i = 0; i < thread_num; i++)\n{\n  if (remaining_rows == 0)\n  {\n    thread_p[i].start = i * rows_per_thread;\n    thread_p[i].end = (thread_p[i].start + rows_per_thread) - 1;\n  }\n  else\n  {\n    if (i <= remaining_rows)\n    {\n      ci = i;\n    }\n\n    thread_p[i].start = (i * rows_per_thread) + ci;\n    thread_p[i].end = (i < remaining_rows) ? (thread_p[i].start + rows_per_thread) : ((thread_p[i].start + rows_per_thread) - 1);\n  }\n\n  thread_p[i].n = n;\n  thread_p[i].dst = (void *) dist;\n  thread_p[i].id = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/7"}
{"code": "for (i = n / 2; i < n; i++)\n{\n  masC[i][0] = masA[i][0] + masB[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/12"}
{"code": "for (i = 0; i < 512; i++)\n{\n  #pragma acc loop independent\n  for (j = 0; j < 512; j++)\n  {\n    D[(i * 512) + j] = (((DATA_TYPE) i) * (j + 2)) / 512;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/3mm_AI/3"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    r = rand() % 100;\n    M[i][j] = r;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Helogizzy/Matrix_Multiplication_OpenMP/main/1"}
{"code": "for (size_t s = 0; s < (1 << 28); ++s)\n{\n  x = rand_MWC_co(&rng_state_tid, &rng_const[tid]);\n  y = rand_MWC_co(&rng_state_tid, &rng_const[tid]);\n  if (sqrt((((double) x) * x) + (y * y)) <= 1.0)\n  {\n    ++hits;\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 1 << 20)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/practicos/practico3/falsesharing/0"}
{"code": "for (j = pivot_column + 1; j < (n + 1); j++)\n{\n  sub_a[(i * (n + 1)) + j] = sub_a[(i * (n + 1)) + j] / sub_a[(i * (n + 1)) + pivot_column];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/5"}
{"code": "for (j = 0; j < w; j++)\n{\n  printf(\"%f \", flip_gaussDeriv[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Robert-M-Hughes/High-Preformance-Computing/Project04/Project04Serial/main/0"}
{"code": "for (int a = r; a < (r + window); a++)\n{\n  for (int b = c; b < (c + window); b++)\n  {\n    sum += mat[a][b];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/4"}
{"code": "for (int i = queue_front; i <= queue_rear; i++)\n{\n  queue[i]->solutions = 0;\n  solve(instance, queue[i]);\n  solutions += queue[i]->solutions;\n}\n\n", "pragma": "omp parallel for reduction(+:solutions) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/0"}
{"code": "for (j = 0; j < 25; j++)\n{\n  for (i = 0; i < 5; i++)\n  {\n    tag_new[(j * 5) + i].newtempx1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempx1_2D_25_5) + (tag_h[5 + i].hprimewgll_xxT * utemp[(j * 5) + 1].tempx1_2D_25_5)) + (tag_h[10 + i].hprimewgll_xxT * utemp[(j * 5) + 2].tempx1_2D_25_5)) + (tag_h[15 + i].hprimewgll_xxT * utemp[(j * 5) + 3].tempx1_2D_25_5)) + (tag_h[20 + i].hprimewgll_xxT * utemp[(j * 5) + 4].tempx1_2D_25_5);\n    tag_new[(j * 5) + i].newtempy1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempy1_2D_25_5) + (tag_h[i + 5].hprimewgll_xxT * utemp[(j * 5) + 1].tempy1_2D_25_5)) + (tag_h[i + 10].hprimewgll_xxT * utemp[(j * 5) + 2].tempy1_2D_25_5)) + (tag_h[i + 15].hprimewgll_xxT * utemp[(j * 5) + 3].tempy1_2D_25_5)) + (tag_h[i + 20].hprimewgll_xxT * utemp[(j * 5) + 4].tempy1_2D_25_5);\n    tag_new[(j * 5) + i].newtempz1_2D_25_5 = ((((tag_h[i].hprimewgll_xxT * utemp[j * 5].tempz1_2D_25_5) + (tag_h[i + 5].hprimewgll_xxT * utemp[(j * 5) + 1].tempz1_2D_25_5)) + (tag_h[i + 10].hprimewgll_xxT * utemp[(j * 5) + 2].tempz1_2D_25_5)) + (tag_h[i + 15].hprimewgll_xxT * utemp[(j * 5) + 3].tempz1_2D_25_5)) + (tag_h[i + 20].hprimewgll_xxT * utemp[(j * 5) + 4].tempz1_2D_25_5);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/specfem3d/aos-omp-for/specfem3D-omp-for/7"}
{"code": "for (int iBox = 0; iBox < nBoxes; iBox++)\n{\n  for (int iOff = MAXATOMS * iBox, ii = 0; ii < s->boxes->nAtoms[iBox]; ii++, iOff++)\n  {\n    s->atoms->p[iOff][0] += dt * s->atoms->f[iOff][0];\n    s->atoms->p[iOff][1] += dt * s->atoms->f[iOff][1];\n    s->atoms->p[iOff][2] += dt * s->atoms->f[iOff][2];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/timestep/0"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  a[x] = 1 + (((int) rand()) / ((double) 32767));\n  num_threads[x] = -x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_multiply/1"}
{"code": "for (i = 0; i < rowptr[nrows]; i++)\n  clens[rowind[i]].key++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/25"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  free(ptr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/1"}
{"code": "for (i = 1; i < (blockDimension + 1); i += blockDimension - 1)\n{\n  for (j = 1; j < (blockDimension + 1); j++)\n  {\n    neighbors = 0;\n    if (block[j - 1][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j - 1][i] == 'X')\n      neighbors++;\n\n    if (block[j - 1][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i - 1] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i] == 'X')\n      neighbors++;\n\n    if (block[j + 1][i + 1] == 'X')\n      neighbors++;\n\n    if (block[j][i] == 'X')\n    {\n      if (neighbors <= 1)\n      {\n        changed++;\n        newblock[j][i] = '.';\n      }\n      else\n        if ((neighbors == 2) || (neighbors == 3))\n      {\n        newblock[j][i] = 'X';\n      }\n      else\n        if (neighbors > 3)\n      {\n        changed++;\n        newblock[j][i] = '.';\n      }\n\n\n\n    }\n    else\n    {\n      if (neighbors == 3)\n      {\n        changed++;\n        newblock[j][i] = 'X';\n      }\n      else\n      {\n        newblock[j][i] = '.';\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(neighbors,i,j) reduction(+:changed) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ippokratoys/Game-Of-Life-MPI-OpenMp-CUDA/openMp/2"}
{"code": "for (i = 0; i < n; i++)\n  threads[omp_get_thread_num()]++;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/MC-SD02-I/OmpFor/0"}
{"code": "for (i = 1; i < size; i++)\n{\n  displs[i] = (N_samples + ((i - 1) * N_samples_slave)) * N_features;\n  sendcounts[i] = N_samples_slave * N_features;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JiaweiZhuang/CS205_final_project/Parallel_Algorithm/MPI/Kmean_mpi/1"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at2 = (-ci2) * crealf(ffe[j]);\n  at1 = at2 * at2;\n  exy[3 * j] = at2 * dcu[3 * j];\n  exy[1 + (3 * j)] = at2 * dcu[1 + (3 * j)];\n  exy[2 + (3 * j)] = at2 * dcu[2 + (3 * j)];\n  exy[(3 * j) + k1] = zero;\n  exy[(1 + (3 * j)) + k1] = zero;\n  exy[(2 + (3 * j)) + k1] = zero;\n  wp += at1 * (((dcu[3 * j] * conjf(dcu[3 * j])) + (dcu[1 + (3 * j)] * conjf(dcu[1 + (3 * j)]))) + (dcu[2 + (3 * j)] * conjf(dcu[2 + (3 * j)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/22"}
{"code": "for (int i = 0; i < sz; i++)\n  arr[i] = rand() % 100000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MG-98/OpenMP/mergesort/2"}
{"code": "for (i = 0; i < 8; i++)\n  for (j = 0; j < 8; j++)\n  if (conf.mat[i][j] > 0)\n  deplacementsB(conf, i, j, T, n);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/18"}
{"code": "for (size_t i = 0; i < chunks; i++)\n{\n  splits0[i] = i * chunkSize;\n  splits1[i] = (i * chunkSize) + (chunkSize / 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/InsertionSortCollider/0"}
{"code": "for (row = 0; row < size2; row++)\n  result[row] = (vector[row] = 0.0);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Sparse/sparse/0"}
{"code": "for (i = nxi - 1; i < nxt; i++)\n{\n  for (k = 0; k < ny; k++)\n  {\n    koff = nxhd * k;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = nxhd * k1;\n      t1 = f[i + k1];\n      f[i + k1] = f[i + koff];\n      f[i + koff] = t1;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhd * (j + k1);\n        j2 = nxhd * (j + k2);\n        t1 = sct[kmr * j];\n        t2 = t1 * f[i + j2];\n        f[i + j2] = f[i + j1] - t2;\n        f[i + j1] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,j1,j2,koff,t1,t2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/16"}
{"code": "for (int i = 0; i < n; i++)\n  x[i] *= k;\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(THREADS_PER_BLOCK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lanczos-omp/lanczos/0"}
{"code": "for (int k = 0; k < n; k++)\n{\n  vx[k] = (vx[k] + ex1[k]) + ((xx[k] - xi[k]) * dex1[k]);\n  xx[k] = (xx[k] + vx[k]) + flx;\n  ir[k] = xx[k];\n  rx[k] = xx[k] - ir[k];\n  ir[k] = (ir[k] & (2048 - 1)) + 1;\n  xx[k] = rx[k] + ir[k];\n}\n\n", "pragma": "      #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/18"}
{"code": "for (i = 0; i < imax_num_mesh; i++)\n{\n  MC_ind[i] = 0;\n  MC_compact_ind[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/DEM/C/dem/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  primes[i] = isPrime(i);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gustkust/Primes-OpenMP/primes_par/0"}
{"code": "for (j = i; j < (i + m); j++)\n{\n  k = ((m + i) - 1) - j;\n  if (k == 0)\n  {\n    if (X[k] == Y[j])\n      L[k][j] = 1;\n    else\n      L[k][j] = L[k][j - 1];\n\n  }\n  else\n  {\n    if (X[k] == Y[j])\n      L[k][j] = L[k - 1][j - 1] + 1;\n    else\n      L[k][j] = (L[k - 1][j] >= L[k][j - 1]) ? (L[k - 1][j]) : (L[k][j - 1]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_diagonal/1"}
{"code": "for (int i = 0; i < arr_size; i++)\n{\n  arr[i].x = ((RAND_START + rand()) % RAND_STOP) * PRECISION;\n  arr[i].y = ((RAND_START + rand()) % RAND_STOP) * PRECISION;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  dist[i] = INF;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sunnlo/BellmanFord/openmp_bellman_ford/3"}
{"code": "for (int i = 0; i < num_inner_loop_instructions; ++i)\n{\n  vmovntdq(ptr[rdi + (i * 64)], zmm0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/3"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  cargarLocal(local, srcImage, ii);\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValue = 0;\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = local[i + 1][j + 1];\n        pixelValue += weight[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    if (pixelValue > 255)\n      pixelValue = 255;\n\n    if (pixelValue < 0)\n      pixelValue = 0;\n\n    dstImage->setPixel(jj, ii, QColor(pixelValue, pixelValue, pixelValue).rgba());\n    if (jj != (srcImage->width() - 2))\n    {\n      desplazarLocal(local, ii, jj, srcImage);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidCarneros/Arco_OpenMP/sobel2/sobel2/1"}
{"code": "for (int k = 0; k < mode; ++k)\n  printf(\"%d\", (k + 1) % 10);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/49"}
{"code": "for (int k = 0; k < D; k++)\n{\n  for (int i = 0; i < tree->root->child2->data.size(); i++)\n  {\n    dim[k] += tree->root->child2->data.at(i)->dim[k];\n  }\n\n  dim[k] = dim[k] / tree->root->child2->data.size();\n  tree->root->child2->pivot[k] = dim[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/12"}
{"code": "for (i__ = mp1; i__ <= i__1; i__ += 5)\n{\n  stemp = ((((stemp + (sx[i__] * sy[i__])) + (sx[i__ + 1] * sy[i__ + 1])) + (sx[i__ + 2] * sy[i__ + 2])) + (sx[i__ + 3] * sy[i__ + 3])) + (sx[i__ + 4] * sy[i__ + 4]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/47"}
{"code": "for (y = 0; y < 10; y++)\n  v++;\n\n", "pragma": "omp for reduction(+: v)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr53580/1"}
{"code": "for (int i0 = 0; i0 < N0; i0++)\n{\n  const int idx = i0;\n  pD[idx] = pS[idx];\n}\n\n", "pragma": "  #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TApplencourt/OvO/test_src/cpp/hierarchical_parallelism/memcopy-complex_double/target__parallel__for/0"}
{"code": "for (int i = 1; i < nOfLayers; i++)\n{\n  ((cout << \"Layer \") << i) << '\\n';\n  (cout << \"------\") << '\\n';\n  for (int j = 0; j < layers[i].nOfNeurons; j++)\n  {\n    for (int k = 0; k < (layers[i - 1].nOfNeurons + 1); k++)\n    {\n      if (layers[i].neurons[j].w != NULL)\n      {\n        (cout << layers[i].neurons[j].w[k]) << \" \";\n      }\n\n    }\n\n    cout << '\\n';\n  }\n\n  cout << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/18"}
{"code": "for (size_t i = 0; i < K; ++i)\n{\n  centroids[i] = data[UniformRandom(data_size - 1)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/3"}
{"code": "for (int i = 0; i <= loc_num; i++)\n{\n  UFLUX[i] = uss[i];\n  FR[i] = dss[i] * uss[i];\n  FRU[i] = ((dss[i] * uss[i]) * uss[i]) + pss[i];\n  FRE[i] = (((pss[i] / (GAMMA - 1.0)) + (((0.5 * dss[i]) * uss[i]) * uss[i])) * uss[i]) + (pss[i] * uss[i]);\n}\n\n", "pragma": "#pragma omp for simd schedule(simd:static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/5"}
{"code": "for (i = 0; i < sc_threads; i++)\n  alloc_region_t(&memory[i], mem_size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/5"}
{"code": "for (int i = 0; i < mNumberOfThreads; i++)\n{\n  total_contacts += neighbour_counter[i];\n  total_sum += sum[i];\n  total_non_skin_particles += number_of_non_skin_particles[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/8"}
{"code": "for (j = 0; j < secondPartSize; j++)\n{\n  secondPart[j] = dataArray[(positionMiddle + 1) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/3"}
{"code": "for (int i = 0; i < NUM_BINS; i += 2)\n  localBins[tID][i] += localBins[tID + offset][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/10"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  long degree = vtxPtr[i + 1] - vtxPtr[i];\n  sum_sq += degree * degree;\n  sum += degree;\n  if (degree > maxDegree)\n    maxDegree = degree;\n\n  if (degree == 0)\n    isolated++;\n\n  if (degree == 1)\n    degreeOne++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/7"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"Proc#%d Num is %d\\n\", omp_get_thread_num(), num);\n\n", "pragma": "\t#pragma omp parallel for firstprivate(num)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR6/LR6_2/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i][j][k - 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tz1) * dz1;\n    a[i][j][0][1] = 0.0;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = (-dt) * tz2;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = (((-dt) * tz2) * ((-(u[i][j][k - 1][1] * u[i][j][k - 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k - 1][1]));\n    a[i][j][1][1] = ((((-dt) * tz2) * (u[i][j][k - 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    a[i][j][1][2] = 0.0;\n    a[i][j][1][3] = ((-dt) * tz2) * (u[i][j][k - 1][1] * tmp1);\n    a[i][j][1][4] = 0.0;\n    a[i][j][2][0] = (((-dt) * tz2) * ((-(u[i][j][k - 1][2] * u[i][j][k - 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k - 1][2]));\n    a[i][j][2][1] = 0.0;\n    a[i][j][2][2] = ((((-dt) * tz2) * (u[i][j][k - 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    a[i][j][2][3] = ((-dt) * tz2) * (u[i][j][k - 1][2] * tmp1);\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = (((-dt) * tz2) * (((-(u[i][j][k - 1][3] * tmp1)) * (u[i][j][k - 1][3] * tmp1)) + ((0.50 * C2) * ((((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + (u[i][j][k - 1][3] * u[i][j][k - 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k - 1][3]));\n    a[i][j][3][1] = ((-dt) * tz2) * ((-C2) * (u[i][j][k - 1][1] * tmp1));\n    a[i][j][3][2] = ((-dt) * tz2) * ((-C2) * (u[i][j][k - 1][2] * tmp1));\n    a[i][j][3][3] = (((((-dt) * tz2) * (2.0 - C2)) * (u[i][j][k - 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    a[i][j][3][4] = ((-dt) * tz2) * C2;\n    a[i][j][4][0] = (((-dt) * tz2) * ((((C2 * (((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + (u[i][j][k - 1][3] * u[i][j][k - 1][3]))) * tmp2) - (C1 * (u[i][j][k - 1][4] * tmp1))) * (u[i][j][k - 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k - 1][1] * u[i][j][k - 1][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k - 1][2] * u[i][j][k - 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k - 1][3] * u[i][j][k - 1][3]))) - ((c1345 * tmp2) * u[i][j][k - 1][4])));\n    a[i][j][4][1] = (((-dt) * tz2) * (((-C2) * (u[i][j][k - 1][1] * u[i][j][k - 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k - 1][1]);\n    a[i][j][4][2] = (((-dt) * tz2) * (((-C2) * (u[i][j][k - 1][2] * u[i][j][k - 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k - 1][2]);\n    a[i][j][4][3] = (((-dt) * tz2) * ((C1 * (u[i][j][k - 1][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + ((3.0 * u[i][j][k - 1][3]) * u[i][j][k - 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k - 1][3]);\n    a[i][j][4][4] = ((((-dt) * tz2) * (C1 * (u[i][j][k - 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n    tmp1 = 1.0 / u[i][j - 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = (-dt) * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = (((-dt) * ty2) * ((-(u[i][j - 1][k][1] * u[i][j - 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j - 1][k][1]));\n    b[i][j][1][1] = ((((-dt) * ty2) * (u[i][j - 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = ((-dt) * ty2) * (u[i][j - 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = (((-dt) * ty2) * (((-(u[i][j - 1][k][2] * tmp1)) * (u[i][j - 1][k][2] * tmp1)) + ((0.50 * C2) * ((((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + (u[i][j - 1][k][2] * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j - 1][k][2]));\n    b[i][j][2][1] = ((-dt) * ty2) * ((-C2) * (u[i][j - 1][k][1] * tmp1));\n    b[i][j][2][2] = ((((-dt) * ty2) * ((2.0 - C2) * (u[i][j - 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = ((-dt) * ty2) * ((-C2) * (u[i][j - 1][k][3] * tmp1));\n    b[i][j][2][4] = ((-dt) * ty2) * C2;\n    b[i][j][3][0] = (((-dt) * ty2) * ((-(u[i][j - 1][k][2] * u[i][j - 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j - 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = ((-dt) * ty2) * (u[i][j - 1][k][3] * tmp1);\n    b[i][j][3][3] = ((((-dt) * ty2) * (u[i][j - 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = (((-dt) * ty2) * ((((C2 * (((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + (u[i][j - 1][k][2] * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3]))) * tmp2) - (C1 * (u[i][j - 1][k][4] * tmp1))) * (u[i][j - 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j - 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j - 1][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j - 1][k][3]))) - ((c1345 * tmp2) * u[i][j - 1][k][4])));\n    b[i][j][4][1] = (((-dt) * ty2) * (((-C2) * (u[i][j - 1][k][1] * u[i][j - 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j - 1][k][1]);\n    b[i][j][4][2] = (((-dt) * ty2) * ((C1 * (u[i][j - 1][k][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + ((3.0 * u[i][j - 1][k][2]) * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j - 1][k][2]);\n    b[i][j][4][3] = (((-dt) * ty2) * (((-C2) * (u[i][j - 1][k][2] * u[i][j - 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j - 1][k][3]);\n    b[i][j][4][4] = ((((-dt) * ty2) * (C1 * (u[i][j - 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i - 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tx1) * dx1;\n    c[i][j][0][1] = (-dt) * tx2;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = 0.0;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = (((-dt) * tx2) * (((-(u[i - 1][j][k][1] * tmp1)) * (u[i - 1][j][k][1] * tmp1)) + (((C2 * 0.50) * (((u[i - 1][j][k][1] * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i - 1][j][k][1]));\n    c[i][j][1][1] = ((((-dt) * tx2) * ((2.0 - C2) * (u[i - 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    c[i][j][1][2] = ((-dt) * tx2) * ((-C2) * (u[i - 1][j][k][2] * tmp1));\n    c[i][j][1][3] = ((-dt) * tx2) * ((-C2) * (u[i - 1][j][k][3] * tmp1));\n    c[i][j][1][4] = ((-dt) * tx2) * C2;\n    c[i][j][2][0] = (((-dt) * tx2) * ((-(u[i - 1][j][k][1] * u[i - 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i - 1][j][k][2]));\n    c[i][j][2][1] = ((-dt) * tx2) * (u[i - 1][j][k][2] * tmp1);\n    c[i][j][2][2] = ((((-dt) * tx2) * (u[i - 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    c[i][j][2][3] = 0.0;\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = (((-dt) * tx2) * ((-(u[i - 1][j][k][1] * u[i - 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i - 1][j][k][3]));\n    c[i][j][3][1] = ((-dt) * tx2) * (u[i - 1][j][k][3] * tmp1);\n    c[i][j][3][2] = 0.0;\n    c[i][j][3][3] = ((((-dt) * tx2) * (u[i - 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    c[i][j][3][4] = 0.0;\n    c[i][j][4][0] = (((-dt) * tx2) * ((((C2 * (((u[i - 1][j][k][1] * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3]))) * tmp2) - (C1 * (u[i - 1][j][k][4] * tmp1))) * (u[i - 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i - 1][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i - 1][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i - 1][j][k][3]))) - ((c1345 * tmp2) * u[i - 1][j][k][4])));\n    c[i][j][4][1] = (((-dt) * tx2) * ((C1 * (u[i - 1][j][k][4] * tmp1)) - ((0.50 * C2) * (((((3.0 * u[i - 1][j][k][1]) * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i - 1][j][k][1]);\n    c[i][j][4][2] = (((-dt) * tx2) * (((-C2) * (u[i - 1][j][k][2] * u[i - 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i - 1][j][k][2]);\n    c[i][j][4][3] = (((-dt) * tx2) * (((-C2) * (u[i - 1][j][k][3] * u[i - 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i - 1][j][k][3]);\n    c[i][j][4][4] = ((((-dt) * tx2) * (C1 * (u[i - 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n  }\n\n}\n\n", "pragma": "omp for private(tmp1, tmp2, tmp3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/21"}
{"code": "for (int i = 0; i < m_numParticles; i++)\n{\n  vels[i] = m_parts[i]->getVel2();\n  if (vels[i] > maxvel)\n    maxvel = vels[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KunstDerFuge/PartSim/Space/6"}
{"code": "for (i = oldI; i < NumPart; i++)\n{\n  ndone++;\n  for (j = 0; j < NTask; j++)\n    Exportflag2[(i * NTask) + j] = 0;\n\n  force_treeevaluate_potential(i, 0);\n}\n\n", "pragma": "omp parallel for reduction(+:ndone) schedule(guided,8)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/potential/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d \", a2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/22"}
{"code": "for (int ii = 0; ii < row; ii++)\n{\n  for (int jj = 0; jj < col; jj++)\n  {\n    mat_out[ii][jj] = (mat_in[ii][jj] - mid) * factor;\n    if (mat_out[ii][jj] < 0)\n    {\n      mat_out[ii][jj] += 0.25;\n    }\n    else\n    {\n      mat_out[ii][jj] -= 0.25;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adaickalavan/python-c-extension/lib/cpp/lib/feature/feature/0"}
{"code": "for (int jj = 0; jj < params->ny; jj++)\n{\n  for (int ii = 0; ii < params->nx; ii++)\n  {\n    (*obstacles_ptr)[ii + (jj * params->nx)] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bkazi/lattice-boltzmann/d2q9-bgk/8"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  lambda.nV[i] -= D_lambda.nV[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/10"}
{"code": "for (j = 13; j >= 1; j--)\n{\n  if (size[j] == '.')\n    size[j] = ' ';\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/EP/ep/1"}
{"code": "for (int i = 0; i < r; i++)\n{\n  for (int j = 0; j < c; j++)\n    printf(\"%f \", M[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matrix/6"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      ru1 = rho_i[k][j][i];\n      uu = us[k][j][i];\n      vv = vs[k][j][i];\n      ww = ws[k][j][i];\n      ac = speed[k][j][i];\n      ac2inv = ac * ac;\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      t1 = (c2 / ac2inv) * (((((qs[k][j][i] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n      t2 = (bt * ru1) * ((uu * r1) - r2);\n      t3 = ((bt * ru1) * ac) * t1;\n      rhs[k][j][i][0] = r1 - t1;\n      rhs[k][j][i][1] = (-ru1) * ((ww * r1) - r4);\n      rhs[k][j][i][2] = ru1 * ((vv * r1) - r3);\n      rhs[k][j][i][3] = (-t2) + t3;\n      rhs[k][j][i][4] = t2 + t3;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,t1,t2,t3,ac,ru1,uu,vv,ww,r1,r2,r3,r4,r5,ac2inv)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/txinvr/0"}
{"code": "for (i = 0; i < (100000000 - 2); i++)\n{\n  if (final_array[i] > final_array[i + 1])\n  {\n    sorted = 'N';\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training6/b0521229-train6/7"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"--steps\") == 0)\n  {\n    steps = atoi(argv[i + 1]);\n  }\n  else\n    if (strcmp(argv[i], \"--num-threads\") == 0)\n  {\n    num_threads = atoi(argv[i + 1]);\n  }\n  else\n    if (strcmp(argv[i], \"--write-to-file\") == 0)\n  {\n    write_to_file = 1;\n  }\n  else\n    if (strcmp(argv[i], \"--investigate-threading\") == 0)\n  {\n    investigate_threading(steps);\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eddireeder/heat-transfer-simulation/hte/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  printf(\"x%d: %.1f\\n\", i, x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/9"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm8_start = wtime();\n  bc_all_openmp(g, thd_num);\n  btm8_sum += wtime() - btm8_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/7"}
{"code": "for (j = x_min - 2; j <= (x_max + 2); j++)\n{\n  celldx[FTNREF1D(j, x_min - 2)] = d_x;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/initialise_chunk_kernel_c/5"}
{"code": "for (int ii = 0; ii < NN; ii++)\n{\n  int i = ii / N;\n  int j = ii % N;\n  avg += M[i][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/k21226/omptst/main/2"}
{"code": "for (k = 0; k < nn; k++)\n{\n  for (i = 0; i < nn; i++)\n  {\n    for (j = 0; j < nn; j++)\n    {\n      if (dist_mat[(i * nn) + j] > (dist_mat[(i * nn) + k] + dist_mat[(k * nn) + j]))\n      {\n        dist_mat[(i * nn) + j] = dist_mat[(i * nn) + k] + dist_mat[(k * nn) + j];\n        pred_mat[(i * nn) + j] = k;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for                                ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TransientObject/ParallelizeAlgos/lib/floyd_warshall/floyd/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((((x[i] >= xmin) & (x[i] <= xmax)) & (y[i] >= ymin)) & (y[i] <= ymax))\n  {\n    kview[idx] = i;\n    idx += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/7"}
{"code": "for (int i = 0; i < x; i++)\n{\n  for (int j = 0; j < y; j++)\n    cin >> b[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rohankurekar/HPC/OpenMP/matrix_matrix_multiplication/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  matrix[i] = (int *) malloc((sizeof(int)) * cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcFW/CITS3402/Assignment1/OpenMP/1"}
{"code": "for (i = 0; i < 4; i++)\n  dest[i] = source[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/2"}
{"code": "for (i = 1; i < m_size; i++)\n{\n  double t = aArray[k][i];\n  aArray[k][i] = aArray[k_other][i];\n  aArray[k_other][i] = t;\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/6"}
{"code": "for (int gid = 0; gid < segments; gid++)\n{\n  const float dz = 0.1f;\n  const float zin = 0.3f;\n  const float weight = 0.5f;\n  const float mu = 0.9f;\n  const float mu2 = 0.3f;\n  const float ds = 0.7f;\n  int QSR_id = QSR_id_acc[gid];\n  int FAI_id = FAI_id_acc[gid];\n  int offset = (QSR_id * fine_axial_intervals) * egroups;\n  float *FSR_flux = (fine_flux_acc + offset) + (FAI_id * egroups);\n  float *q0 = v_acc;\n  float *q1 = v_acc + egroups;\n  float *q2 = v_acc + (egroups * 2);\n  float *sigT = v_acc + (egroups * 3);\n  float *tau = v_acc + (egroups * 4);\n  float *sigT2 = v_acc + (egroups * 5);\n  float *expVal = v_acc + (egroups * 6);\n  float *reuse = v_acc + (egroups * 7);\n  float *flux_integral = v_acc + (egroups * 8);\n  float *tally = v_acc + (egroups * 9);\n  float *t1 = v_acc + (egroups * 10);\n  float *t2 = v_acc + (egroups * 11);\n  float *t3 = v_acc + (egroups * 12);\n  float *t4 = v_acc + (egroups * 13);\n  if (FAI_id == 0)\n  {\n    float *f2 = (fine_source_acc + offset) + (FAI_id * egroups);\n    float *f3 = (fine_source_acc + offset) + ((FAI_id + 1) * egroups);\n    for (int g = 0; g < egroups; g++)\n    {\n      const float y2 = f2[g];\n      const float y3 = f3[g];\n      const float c0 = y2;\n      const float c1 = (y3 - y2) / dz;\n      q0[g] = c0 + (c1 * zin);\n      q1[g] = c1;\n      q2[g] = 0;\n    }\n\n  }\n  else\n    if (FAI_id == (fine_axial_intervals - 1))\n  {\n    float *f1 = (fine_source_acc + offset) + ((FAI_id - 1) * egroups);\n    float *f2 = (fine_source_acc + offset) + (FAI_id * egroups);\n    for (int g = 0; g < egroups; g++)\n    {\n      const float y1 = f1[g];\n      const float y2 = f2[g];\n      const float c0 = y2;\n      const float c1 = (y2 - y1) / dz;\n      q0[g] = c0 + (c1 * zin);\n      q1[g] = c1;\n      q2[g] = 0;\n    }\n\n  }\n  else\n  {\n    float *f1 = (fine_source_acc + offset) + ((FAI_id - 1) * egroups);\n    float *f2 = (fine_source_acc + offset) + (FAI_id * egroups);\n    float *f3 = (fine_source_acc + offset) + ((FAI_id + 1) * egroups);\n    for (int g = 0; g < egroups; g++)\n    {\n      const float y1 = f1[g];\n      const float y2 = f2[g];\n      const float y3 = f3[g];\n      const float c0 = y2;\n      const float c1 = (y1 - y3) / (2.f * dz);\n      const float c2 = ((y1 - (2.f * y2)) + y3) / ((2.f * dz) * dz);\n      q0[g] = (c0 + (c1 * zin)) + ((c2 * zin) * zin);\n      q1[g] = c1 + ((2.f * c2) * zin);\n      q2[g] = c2;\n    }\n\n  }\n\n\n  offset = QSR_id * egroups;\n  for (int g = 0; g < egroups; g++)\n  {\n    sigT[g] = sigT_acc[offset + g];\n    tau[g] = sigT[g] * ds;\n    sigT2[g] = sigT[g] * sigT[g];\n    expVal[g] = 1.f - expf(-tau[g]);\n    reuse[g] = (tau[g] * (tau[g] - 2.f)) + ((2.f * expVal[g]) / (sigT[g] * sigT2[g]));\n    flux_integral[g] = ((((q0[g] * tau[g]) + (((sigT[g] * state_flux_acc[g]) - q0[g]) * expVal[g])) / sigT2[g]) + ((q1[g] * mu) * reuse[g])) + (((q2[g] * mu2) * ((tau[g] * ((tau[g] * (tau[g] - 3.f)) + 6.f)) - (6.f * expVal[g]))) / ((3.f * sigT2[g]) * sigT2[g]));\n    tally[g] = weight * flux_integral[g];\n    FSR_flux[g] += tally[g];\n    t1[g] = (q0[g] * expVal[g]) / sigT[g];\n    t2[g] = ((q1[g] * mu) * (tau[g] - expVal[g])) / sigT2[g];\n    t3[g] = (q2[g] * mu2) * reuse[g];\n    t4[g] = state_flux_acc[g] * (1.f - expVal[g]);\n    state_flux_acc[g] = ((t1[g] + t2[g]) + t3[g]) + t4[g];\n  }\n\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/17"}
{"code": "for (i = 0; i < n; i++)\n{\n  score2 = minmax_ab(T[i], -1, niv - 1, score, beta, nb_noeuds, nb_coupes);\n  if (score2 > score)\n    score = score2;\n\n  if (score > beta)\n  {\n    *nb_coupes += 1;\n    return beta;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/25"}
{"code": "for (int i = M - 100; i < M; ++i)\n{\n  (cout << alleleFreqVec[i]) << ' ';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/7"}
{"code": "for (size_t i = 0; i != dev.size(); ++i)\n{\n  m_buffers.emplace_back(dev[i].m_context, CL_MEM_READ_WRITE, alloc_size());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_opencl/1"}
{"code": "for (int ncnt = 0; ncnt < cont_cnt; ncnt++)\n{\n  if (topo[(curr_node_name * cont_cnt) + ncnt] == 1)\n  {\n    if ((curr_node_name == docker_host_name) && (nodeHashing(nodeEncoding(ncnt, 4), nodeTable, addr) == 1))\n    {\n      int reversed = nodeHashing(edgeDirEncoding(ncnt, curr_node_name, 4), edgeDirTable, addr2);\n      if (reversed)\n        continue;\n      else\n      {\n        unsigned int curr_edge_dir_val = edgeDirEncoding(curr_node_name, ncnt, 4);\n        nodeHashing(curr_edge_dir_val, edgeDirTable, addr2);\n        edgeDirTable[*addr2].hashNum = curr_edge_dir_val;\n      }\n\n      unsigned int nvalue = nodeEncoding(ncnt, 4);\n      unsigned int newNodeID;\n      if (nodeHashing(nvalue, nodeTable, addr) == 0)\n      {\n        newNodeID = ++(*node_cnt);\n        nodeTable[*addr].hashNum = nvalue;\n        nodeTable[*addr].ID = newNodeID;\n        node_name[newNodeID] = ncnt;\n        node_priv[newNodeID] = 4;\n        fifo_write(masterQueue, newNodeID);\n      }\n      else\n      {\n        newNodeID = nodeTable[*addr].ID;\n      }\n\n      unsigned int curr_edge_val = edgeEncoding(curr_node_id, newNodeID);\n      if (nodeHashing(curr_edge_val, edgeTable, addr2) == 0)\n      {\n        unsigned int newEdgeID = ++(*edge_cnt);\n        edgeTable[*addr2].hashNum = curr_edge_val;\n        edgeTable[*addr2].ID = newEdgeID;\n        edge_start[newEdgeID] = curr_node_id;\n        edge_end[newEdgeID] = newNodeID;\n        int *edge_label_cnt = &edge_label[newEdgeID * 100];\n        int *edge_label_row = &edge_label[(newEdgeID * 100) + 1];\n        if ((*edge_label_cnt) < 99)\n        {\n          edge_label_row[*edge_label_cnt] = -1;\n          (*edge_label_cnt)++;\n        }\n\n      }\n      else\n      {\n        unsigned int existing_edge_id = edgeTable[*addr2].ID;\n        int *edge_label_cnt = &edge_label[existing_edge_id * 100];\n        int *edge_label_row = &edge_label[(existing_edge_id * 100) + 1];\n        if ((*edge_label_cnt) < 99)\n        {\n          edge_label_row[*edge_label_cnt] = -1;\n          (*edge_label_cnt)++;\n        }\n\n      }\n\n    }\n    else\n      if ((ncnt == docker_host_name) && (pacc[curr_node_name] == 1))\n    {\n      int reversed = nodeHashing(edgeDirEncoding(ncnt, curr_node_name, curr_node_priv), edgeDirTable, addr2);\n      if (reversed)\n        continue;\n      else\n      {\n        unsigned int curr_edge_dir_val = edgeDirEncoding(curr_node_name, ncnt, 4);\n        nodeHashing(curr_edge_dir_val, edgeDirTable, addr2);\n        edgeDirTable[*addr2].hashNum = curr_edge_dir_val;\n      }\n\n      unsigned int nvalue = nodeEncoding(ncnt, 4);\n      unsigned int newNodeID;\n      if (nodeHashing(nvalue, nodeTable, addr) == 0)\n      {\n        newNodeID = ++(*node_cnt);\n        nodeTable[*addr].hashNum = nvalue;\n        nodeTable[*addr].ID = newNodeID;\n        node_name[newNodeID] = ncnt;\n        node_priv[newNodeID] = 4;\n        fifo_write(masterQueue, newNodeID);\n      }\n      else\n      {\n        newNodeID = nodeTable[*addr].ID;\n      }\n\n      unsigned int curr_edge_val = edgeEncoding(curr_node_id, newNodeID);\n      if (nodeHashing(curr_edge_val, edgeTable, addr2) == 0)\n      {\n        unsigned int newEdgeID = ++(*edge_cnt);\n        edgeTable[*addr2].hashNum = curr_edge_val;\n        edgeTable[*addr2].ID = newEdgeID;\n        edge_start[newEdgeID] = curr_node_id;\n        edge_end[newEdgeID] = newNodeID;\n        int *edge_label_cnt = &edge_label[newEdgeID * 100];\n        int *edge_label_row = &edge_label[(newEdgeID * 100) + 1];\n        if ((*edge_label_cnt) < 99)\n        {\n          edge_label_row[*edge_label_cnt] = -2;\n          (*edge_label_cnt)++;\n        }\n\n      }\n      else\n      {\n        unsigned int existing_edge_id = edgeTable[*addr2].ID;\n        int *edge_label_cnt = &edge_label[existing_edge_id * 100];\n        int *edge_label_row = &edge_label[(existing_edge_id * 100) + 1];\n        if ((*edge_label_cnt) < 99)\n        {\n          edge_label_row[*edge_label_cnt] = -2;\n          (*edge_label_cnt)++;\n        }\n\n      }\n\n    }\n    else\n      if ((ncnt != outside_name) && (ncnt != docker_host_name))\n    {\n      for (int ecnt = 0; ecnt < num_ex[ncnt]; ecnt++)\n      {\n        int ex_idx = (ncnt * max_num_ex) + ecnt;\n        if ((curr_node_priv >= pre_priv[ex_idx]) && (((ncnt != curr_node_name) && (post_priv[ex_idx] != 0)) || ((ncnt == curr_node_name) && (curr_node_priv < post_priv[ex_idx]))))\n        {\n          int reversed = nodeHashing(edgeDirEncoding(ncnt, curr_node_name, curr_node_priv), edgeDirTable, addr2);\n          if (reversed)\n            continue;\n          else\n          {\n            unsigned int curr_edge_dir_val = edgeDirEncoding(curr_node_name, ncnt, post_priv[ex_idx]);\n            nodeHashing(curr_edge_dir_val, edgeDirTable, addr2);\n            edgeDirTable[*addr2].hashNum = curr_edge_dir_val;\n          }\n\n          unsigned int nvalue = nodeEncoding(ncnt, post_priv[ex_idx]);\n          unsigned int newNodeID;\n          if (nodeHashing(nvalue, nodeTable, addr) == 0)\n          {\n            newNodeID = ++(*node_cnt);\n            nodeTable[*addr].hashNum = nvalue;\n            nodeTable[*addr].ID = newNodeID;\n            node_name[newNodeID] = ncnt;\n            node_priv[newNodeID] = post_priv[ex_idx];\n            fifo_write(masterQueue, newNodeID);\n          }\n          else\n          {\n            newNodeID = nodeTable[*addr].ID;\n          }\n\n          unsigned int curr_edge_val = edgeEncoding(curr_node_id, newNodeID);\n          if (nodeHashing(curr_edge_val, edgeTable, addr2) == 0)\n          {\n            unsigned int newEdgeID = ++(*edge_cnt);\n            edgeTable[*addr2].hashNum = curr_edge_val;\n            edgeTable[*addr2].ID = newEdgeID;\n            edge_start[newEdgeID] = curr_node_id;\n            edge_end[newEdgeID] = newNodeID;\n            int *edge_label_cnt = &edge_label[newEdgeID * 100];\n            int *edge_label_row = &edge_label[(newEdgeID * 100) + 1];\n            if ((*edge_label_cnt) < 99)\n            {\n              edge_label_row[*edge_label_cnt] = ex_names[ex_idx];\n              (*edge_label_cnt)++;\n            }\n\n          }\n          else\n          {\n            unsigned int existing_edge_id = edgeTable[*addr2].ID;\n            int *edge_label_cnt = &edge_label[existing_edge_id * 100];\n            int *edge_label_row = &edge_label[(existing_edge_id * 100) + 1];\n            if ((*edge_label_cnt) < 99)\n            {\n              edge_label_row[*edge_label_cnt] = ex_names[ex_idx];\n              (*edge_label_cnt)++;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apollo12221/Parallel-AG-Gen-Docker/c_bfs/5"}
{"code": "for (int i = 0; i < (threadnum - distance); i += 2 * distance)\n{\n  mergeBorough(borough_map_array[i + distance], borough_map_array[i]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/borough/1"}
{"code": "for (i = 1; i < (((2048 / 1) + 2) - 1); i++)\n{\n  j = ((2048 / NODESY) + 2) - 1;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = gre[i];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = gre[i];\n\n  j = 0;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = gro[i];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = gro[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/81"}
{"code": "for (long v = 0; v < NVer; v++)\n{\n  long adj1 = verPtr[v];\n  long adj2 = verPtr[v + 1];\n  if (adj2 == adj1)\n    continue;\n\n  long numTopEdges = round(pow(adj2 - adj1, alpha));\n  if (numTopEdges < 1)\n    numTopEdges = 1;\n\n  double minWeight = simWeights[adj1];\n  long minNeighbor = adj1;\n  isEdgePresent[adj1] = true;\n  long edgesAddedSoFar = 1;\n  for (long i = adj1 + 1; i < adj2; i++)\n  {\n    if (edgesAddedSoFar < numTopEdges)\n    {\n      isEdgePresent[i] = true;\n      edgesAddedSoFar++;\n      if (simWeights[i] < minWeight)\n      {\n        minWeight = simWeights[i];\n        minNeighbor = i;\n      }\n\n    }\n    else\n    {\n      if (simWeights[i] > minWeight)\n      {\n        isEdgePresent[i] = true;\n        isEdgePresent[minNeighbor] = false;\n        minWeight = simWeights[i];\n        minNeighbor = i;\n        for (long k = adj1; k < i; k++)\n        {\n          if (isEdgePresent[k] && (simWeights[k] < minWeight))\n          {\n            minWeight = simWeights[k];\n            minNeighbor = k;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilitySparsificationFunctions/4"}
{"code": "for (kk = 0; kk < en; kk += 32)\n  for (jj = 0; jj < en; jj += 32)\n  for (i = 0; i < 512; i++)\n  for (j = jj; j < (jj + 32); j++)\n{\n  sum = c[i][j];\n  for (k = kk; k < (kk + 32); k = k + 4)\n  {\n    sum += a[i][k + 0] * b[k + 0][j];\n    sum += a[i][k + 1] * b[k + 1][j];\n    sum += a[i][k + 2] * b[k + 2][j];\n    sum += a[i][k + 3] * b[k + 3][j];\n  }\n\n  c[i][j] = sum;\n}\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohinarora/OpenMP/Dense_MatMul_OpenMP/M-M_blocked_omp/3"}
{"code": "for (i = 0; i < 8; i++)\n{\n  MPI_Start(&sendReq[pos][i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/billDrett/GameOfLife-MPI-OpenMp-Cuda-/openMP/openmpParrallelCommunication/main/0"}
{"code": "for (int i = 0; i < row; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coherent17/Matrix-Multiplication-optimize-by-OpenMP/Parallel_Matrix_Multiplication_With_Openmp/ijk_optimize/2"}
{"code": "for (int p = 0; p < itt; p++)\n  Avg += AvgM();\n\n", "pragma": "\t#pragma omp parallel for reduction(+:Avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/k21226/omptst/main/1"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    a[i + (j * size)] = (float) (i + j);\n    b[i + (j * size)] = (float) (i - j);\n    c[i + (j * size)] = 0.0f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moreandres/hotspot/tests/examples/matrix/matrix/1"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    C[(i * 512) + j] *= 2123.0f;\n    for (k = 0; k < 512; ++k)\n    {\n      C[(i * 512) + j] += (32412.0f * A[(i * 512) + k]) * B[(k * 512) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/GEMM/src/gemm/0"}
{"code": "for (k = 0, K = 0; k < n; k += bs, K++)\n{\n  kl = k + bs;\n  if (kl > n)\n  {\n    kl = n;\n  }\n\n  A = &a[k + (k * n)];\n  lu0(A, kl - k, strI);\n  D = &a[k + (k * n)];\n  for (i = kl, I = K + 1; i < n; i += bs, I++)\n  {\n    il = i + bs;\n    if (il > n)\n    {\n      il = n;\n    }\n\n    A = &a[i + (k * n)];\n    bdiv(A, D, strI, n, il - i, kl - k);\n  }\n\n  for (j = kl, J = K + 1; j < n; j += bs, J++)\n  {\n    jl = j + bs;\n    if (jl > n)\n    {\n      jl = n;\n    }\n\n    A = &a[k + (j * n)];\n    bmodd(D, A, kl - k, jl - j, n, strI);\n  }\n\n  for (i = kl, I = K + 1; i < n; i += bs, I++)\n  {\n    il = i + bs;\n    if (il > n)\n    {\n      il = n;\n    }\n\n    A = &a[i + (k * n)];\n    for (j = kl, J = K + 1; j < n; j += bs, J++)\n    {\n      jl = j + bs;\n      if (jl > n)\n      {\n        jl = n;\n      }\n\n      B = &a[k + (j * n)];\n      C = &a[i + (j * n)];\n      bmod(A, B, C, il - i, jl - j, kl - k, n);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/5"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  if (array[i] > mx)\n  {\n    mx = array[i];\n    mx_index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn07/10"}
{"code": "for (int i = 0; i < (_counterMax + 1); i++)\n{\n  long currXpos = xMax[i];\n  long currYpos = yMax[i];\n  char xElem = Q[currXpos];\n  char yElem = D[currYpos];\n  char currNode = ScoreTable[currXpos][currYpos];\n  char *_qOut = 0;\n  _qOut = (char *) malloc(((xMax[i] + 1) * (yMax[i] + 1)) * (sizeof(char)));\n  if (_qOut == 0)\n  {\n    printf(\"Error occured while trying to allocate memory for traceback.Terminating....\");\n    exit(-1);\n  }\n\n  char *_dOut = 0;\n  _dOut = (char *) malloc(((xMax[i] + 1) * (yMax[i] + 1)) * (sizeof(char)));\n  if (_dOut == 0)\n  {\n    printf(\"Error occured while trying to allocate memory for traceback.Terminating....\");\n    exit(-1);\n  }\n\n  int lengthCount = 0;\n  u_int8_t traceFlag = 0;\n  while (traceFlag != 1)\n  {\n    int up;\n    int left;\n    int diag;\n    up = ScoreTable[currXpos - 1][currYpos];\n    left = ScoreTable[currXpos][currYpos - 1];\n    diag = ScoreTable[currXpos - 1][currYpos - 1];\n    if ((diag == 0) && ((ScoreTable[currXpos][currYpos] - MATCH) == 0))\n    {\n      traceFlag = 1;\n      currYpos--;\n      currXpos--;\n      xElem = Q[currXpos];\n      yElem = D[currYpos];\n    }\n    else\n    {\n      if ((up > left) && (up > diag))\n      {\n        currXpos--;\n        xElem = Q[currXpos];\n        yElem = '-';\n      }\n      else\n        if ((left > up) && (left > diag))\n      {\n        currYpos--;\n        xElem = '-';\n        yElem = D[currYpos];\n      }\n      else\n        if ((diag >= up) && (diag >= left))\n      {\n        if ((Q[currXpos - 1] == D[currYpos - 1]) || ((diag > up) && (diag > left)))\n        {\n          currYpos--;\n          currXpos--;\n          xElem = Q[currXpos];\n          yElem = D[currYpos];\n        }\n        else\n          if (Q[currXpos - 1] == D[currYpos])\n        {\n          currXpos--;\n          xElem = Q[currXpos];\n          yElem = '-';\n        }\n        else\n        {\n          currYpos--;\n          xElem = '-';\n          yElem = D[currYpos];\n        }\n\n\n      }\n      else\n      {\n        if (Q[currXpos] == D[currYpos - 1])\n        {\n          currYpos--;\n          xElem = '-';\n          yElem = D[currYpos];\n        }\n        else\n        {\n          currXpos--;\n          xElem = Q[currXpos];\n          yElem = '-';\n        }\n\n      }\n\n\n\n    }\n\n    _traceSteps++;\n    _qOut[lengthCount] = xElem;\n    _dOut[lengthCount] = yElem;\n    lengthCount++;\n  }\n\n  _qOut[lengthCount] = '\\0';\n  _dOut[lengthCount] = '\\0';\n  _dOut = reverseArr(_dOut, strlen(_dOut));\n  _qOut = reverseArr(_qOut, strlen(_qOut));\n  fprintf(finFile, \"\\nMATCH %d [SCORE: %d,START: %ld,STOP: %ld]\\n\\tD: %s\\n\\tQ: %s\\n\", i + 1, _MAX_SIMILARITY, _endKeeper[i] - lengthCount, _endKeeper[i] - 1, _dOut, _qOut);\n  free(_qOut);\n  free(_dOut);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skalogerakis/TUC_Parallel_Computer_Architecture/Smith-Waterman/OpenMP_FineGrained/main/6"}
{"code": "for (int i = start; i <= end; i++)\n  if (distArr[i] <= pivot)\n{\n  swapDouble(distArr + i, distArr + store);\n  swapInt(idArr + i, idArr + store);\n  store++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/karelispanagiotis/VP_Tree_Construction/src/vptree_openmp/2"}
{"code": "for (i = 0; i < N; ++i)\n{\n  x = ((double) rand_r(&id)) / 32767;\n  y = ((double) rand_r(&id)) / 32767;\n  d = (x * x) + (y * y);\n  in_quadrant += d <= 1;\n}\n\n", "pragma": "omp for private(x, y, d, id, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elyaishere/sk_high_performance_computing/openmp/Pi/0"}
{"code": "for (int h = 0; h < NumQs; h++)\n{\n  *(tmpMiQx_NN + h) = 0;\n  *(tmpMiQx_MM + h) = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/18"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  koff = nxhd * k;\n  k1 = (nxhd * ny) - koff;\n  t1 = f[k1];\n  f[k1] = 0.5 * (cimagf(f[koff] + t1) + (crealf(f[koff] - t1) * _Complex_I));\n  f[koff] = 0.5 * (crealf(f[koff] + t1) + (cimagf(f[koff] - t1) * _Complex_I));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/45"}
{"code": "for (i = 0; i < histogram_size; i++)\n{\n  histogram[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/histogram/6"}
{"code": "for (i = 0; i < 256; i++)\n  buf[i] += i;\n\n", "pragma": "omp for schedule (auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-8/0"}
{"code": "for (k = 0; k < num_possible_vaules_aux; k++)\n{\n  for (aux2 = 0; aux2 < taules_aux[k][0].nelem; aux2++)\n  {\n    taules_result[aux3] = taules_aux[k][aux2];\n    aux3++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/15"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  if (verT[i])\n    continue;\n\n  clusterWeightInternal[i] = 0;\n  cUpdate[i].degree = 0;\n  cUpdate[i].size = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/FullSyncOptimization/parallelLouvainMethodEarlyTerminate/1"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  frct[i][j][k][0] = frct[i][j][k][0] + ((dy1 * ty1) * ((rsd[i][j - 1][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i][j + 1][k][0]));\n  frct[i][j][k][1] = (frct[i][j][k][1] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][1] - flux[i][j][k][1]))) + ((dy2 * ty1) * ((rsd[i][j - 1][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i][j + 1][k][1]));\n  frct[i][j][k][2] = (frct[i][j][k][2] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][2] - flux[i][j][k][2]))) + ((dy3 * ty1) * ((rsd[i][j - 1][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i][j + 1][k][2]));\n  frct[i][j][k][3] = (frct[i][j][k][3] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][3] - flux[i][j][k][3]))) + ((dy4 * ty1) * ((rsd[i][j - 1][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i][j + 1][k][3]));\n  frct[i][j][k][4] = (frct[i][j][k][4] + (((ty3 * 1.00e-01) * 1.00e+00) * (flux[i][j + 1][k][4] - flux[i][j][k][4]))) + ((dy5 * ty1) * ((rsd[i][j - 1][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i][j + 1][k][4]));\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (ty1,ty3,dy1,dy2,dy3,dy4,dy5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/38"}
{"code": "for (int i = 4; i <= 64; i += 4)\n{\n  omp_set_num_threads(i);\n  testDrand48_avxengine(80000000000, i);\n  printf(\"avxengine   | %4d | %12.0f | %12.3f | %12.5f\\n\", omp_get_max_threads(), stopc(), stop(), stopt() / 8e10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProfChristianBoehm/AVXrandom/avxrandom/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((cur_solution->forest[a][i] && cur_solution->even[i]) && (even != i))\n  {\n    *next1 = ilist(i, next2);\n    if ((head = find_head_exposed(i, next1, avoid)) != NULL)\n    {\n      return head;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xelaadryth/Edmonds-Parallel/OMP/src/eba/0"}
{"code": "for (i = 0; i < 2000; i++)\n  result[i] = (double *) malloc(2000 * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pradeepsinngh/practice-parallel-programming/openmp/matrix_multiplication_openmp/4"}
{"code": "for (unsigned int k = 0; k < microenvironment.mesh.z_coordinates.size(); k++)\n{\n  int I = microenvironment.mesh.x_coordinates.size() - 1;\n  ;\n  for (unsigned int j = 0; j < microenvironment.mesh.y_coordinates.size(); j++)\n  {\n    microenvironment.add_dirichlet_node(microenvironment.voxel_index(I, j, k), default_microenvironment_options.Dirichlet_xmax_values);\n    microenvironment.set_substrate_dirichlet_activation(microenvironment.voxel_index(I, j, k), default_microenvironment_options.Dirichlet_xmax);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/23"}
{"code": "for (int i = 0; i < size; i++)\n{\n  (cout << \"\\t\") << val[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/matxvec_sparse/matxvec_sparse/6"}
{"code": "for (k = 0; k < N; k++)\n{\n  y[k] *= y[k];\n  if (k < N)\n    a[k] += b[k];\n\n  z[k] = a[k] * k;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/enhancing_efficiency/2"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  count += table[as_bytes[i]];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (fabs(A[(i * N) + j] - B[(i * N) + j]) > 1e-9)\n      return 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/06matmul_omp/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double d = sphere_intersect(&spheres[i], ray_origin, ray_direction);\n  if ((d > 0) && (d < (*t)))\n  {\n    *t = d;\n    *id = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_mpi-omp-simd/pathracer_mpi-omp-simd/11"}
{"code": "for (i = 0; i < heigth; i++)\n{\n  fwrite(imagen[i], sizeof(float), width, f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NicolasRomeroF/mandelbrot_openmp/mandelbrotp/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%f \", (float) MEU_Y[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/137"}
{"code": "for (int i = 1; i < cfg.num_threads; i++)\n{\n  pre[i] = pre[i - 1] + temp[i - 1].size();\n  total += temp[i].size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankitsultana/parallel-df/src/populate_htables/0"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  if ((i % 30) == 0)\n    printf(\"\\n\");\n\n  printf(\"%d \", L[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iamtsac/Khan-Algorithm-openmp/parallel/2"}
{"code": "for (int j = 0; j < ny; j++)\n{\n  positiony[j] = stepy * j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mircuz/travelling_wave/travelling_wave/support/1"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB070-simd1-orig-no/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  a[i] = i;\n  b[i] = 2 * i;\n  c[i] = 3 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_target/test_declare_target_nested/2"}
{"code": "for (int i = 0; i < (empty_flag * size); i++)\n{\n  if (F[i] != 0)\n  {\n    empty_flag = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/0"}
{"code": "for (unsigned int i = 0; i < lpofa.size2(); ++i)\n{\n  for (unsigned int j = 1; j < lpofa.size1(); ++j)\n  {\n    SideLength = norm_2(rGeometry[lpofa(0, i)].Coordinates() - rGeometry[lpofa(j, i)].Coordinates());\n    if (SideLength < rMinimumSideLength)\n      rMinimumSideLength = SideLength;\n\n    if (SideLength > rMaximumSideLength)\n      rMaximumSideLength = SideLength;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/14"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  norm2 += (this->vec_[i].real() * this->vec_[i].real()) + (this->vec_[i].imag() * this->vec_[i].imag());\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : norm2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/25"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (i == j)\n    {\n      dis[i][j] = 0;\n    }\n    else\n    {\n      dis[i][j] = adj_mat[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Project on Floyd Warshall/Approach 1) Naive Approach/parallel/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (A[i][j] != B[i][j])\n    {\n      printf(\"A[%d][%d] = %d, B[%d][%d] = %d\\n\", i, j, A[i][j], i, j, B[i][j]);\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AYaddaden/matrix-multiplication/main/7"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    printf(\"Myid = %d\\t A[%d][%d] \\n\", idx, i, j);\n  }\n\n}\n\n", "pragma": "omp for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/OMP/hello_world_omp3/0"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  solution[i] = score_new[i];\n  score_new[i] = 0.0;\n}\n\n", "pragma": "          #pragma omp for       ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank - C\u00f3pia/page_rank/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double AynTmp = 0.0;\n  for (int j = 0; j < n; ++j)\n  {\n    AynTmp += A[j + (i * n)] * yn[j];\n  }\n\n  tn1 += yn[i] * AynTmp;\n  tn2 += AynTmp * AynTmp;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) reduction(+: tn1, tn2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/7"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"%d:i%d\\t\", id, i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filipecosta90/Parallel-Computing-Paradigms/aula1/exec2.4/0"}
{"code": "for (int pidx = 0; pidx < pcls.size(); pidx++)\n  for (int i = 0; i < num_ids; i++)\n  if (pcls[pidx].get_ID() == id_list[i])\n{\n  dprintf(\"--- particle %d.%d ---\", ns, pidx);\n  dprintf(\"u[%d] = %+6.4f\", pidx, pcls[pidx].get_u());\n  dprintf(\"v[%d] = %+6.4f\", pidx, pcls[pidx].get_v());\n  dprintf(\"w[%d] = %+6.4f\", pidx, pcls[pidx].get_w());\n  dprintf(\"q[%d] = %+6.4f\", pidx, pcls[pidx].get_q());\n  dprintf(\"x[%d] = %+6.4f\", pidx, pcls[pidx].get_x());\n  dprintf(\"y[%d] = %+6.4f\", pidx, pcls[pidx].get_y());\n  dprintf(\"z[%d] = %+6.4f\", pidx, pcls[pidx].get_z());\n  dprintf(\"t[%d] = %5.0f\", pidx, pcls[pidx].get_t());\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/1"}
{"code": "for (i = 0; i < (nx + (2 * d)); i++)\n{\n  for (j = 0; j < (ny + (2 * d)); j++)\n  {\n    fuzzyPadded[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/z4/dosharpen/3"}
{"code": "for (int i = 0; i < ITERATIONS; i++)\n{\n  finalCenters[i] = malloc(K * (sizeof(void *)));\n  for (int j = 0; j < K; j++)\n  {\n    finalCenters[i][j] = malloc((DIM + 1) * (sizeof(double)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hejohns/kmeans/kmeans/0"}
{"code": "for (i = 0; i < 2048; i++)\n  one_step();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo2a/headless/0"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  printf(\"[%d] \", pos->_Cases[0][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/4"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    D[(i * 500) + j] = (((DATA_TYPE) i) * (j + 2)) / 500;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm_cpu/6"}
{"code": "for (i = 0; i < maxthreads; i++)\n{\n  float currentT = t + iddt[i];\n  if ((qs[i] < QC) || (currentT >= tmax))\n  {\n    for (v = 0; v < (K + 1); v++)\n    {\n      weights[v] = tempweights[(i * (K + 1)) + v];\n    }\n\n    t += iddt[i];\n    finalQT[0] = qs[i];\n    finalQT[1] = t;\n    free(iddt);\n    free(qs);\n    free(validarr);\n    free(tempweights);\n    return (currentT >= tmax) ? (0) : (1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/11"}
{"code": "for (c1 = nm; c1 <= (nj + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/29"}
{"code": "for (i = 0; i < N; i++)\n{\n  temp = (struct node *) malloc(sizeof(struct node));\n  p->next = temp;\n  p = temp;\n  p->data = (FS + i) + 1;\n  p->fibdata = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BuzzHari/openmp-notes/linked_mysol/4"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    (cout << matriz_C[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SidSan97/OMP---Algebra-Linear/OMP - Algebra Linear/main/4"}
{"code": "for (k = 0; k < MATRIX_SIZE; k += BLOCK_SIZE)\n{\n  for (j = 0; j < MATRIX_SIZE; j += BLOCK_SIZE)\n  {\n    for (i = 0; i < MATRIX_SIZE; ++i)\n    {\n      for (jj = j; jj < min(j + BLOCK_SIZE, MATRIX_SIZE); ++jj)\n      {\n        for (kk = k; kk < min(k + BLOCK_SIZE, MATRIX_SIZE); ++kk)\n        {\n          C[i][jj] += A[i][kk] * B[kk][jj];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, i, jj, kk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/magiciiboy/openmp-matmul/Block matrix multiplication/Outer_1/block_mm/0"}
{"code": "for (i = 0; i < tablesize; i++)\n{\n  if (Table[i] != ((u64Int) i))\n  {\n    error++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Random/random/3"}
{"code": "for (int j = 0; j < length; ++j)\n{\n  str[(length - j) - 1] = (i % 10) + '0';\n  i /= 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filhei/OpenMP/cell_distance/5"}
{"code": "for (int i = 1; i < (dim->rows - 1); i++)\n{\n  for (int j = 1; j < (dim->columns - 1); j++)\n    util_grid->cells[i][j] = change_cell_state(i, j, ptr, syms);\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/0"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    copy_double_kernel(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[5 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[5].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/copy_double_kernel_kernel/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && SPARSE)\n    {\n      B[(i * 1000) + j] = 0;\n    }\n    else\n    {\n      B[(i * 1000) + j] = (((float) i) * (j + 1)) / 1000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/9"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  f_tn[i][0] = (f_tn[i][ny - 1] = 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mircuz/travelling_wave/travelling_wave/support/12"}
{"code": "for (int i = 0; i < q->size; i++)\n{\n  M->current[i] = (((pmax->current[i] - ssum->current[i]) + q->current[i]) + smax->current[i]) - psum->current[i];\n  if (M->current[i] > max)\n  {\n    max = M->current[i];\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/10"}
{"code": "for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n{\n  for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n  {\n    for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        forcing[i][j][k][m] = (-1.0) * forcing[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/32"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  a[i] = rand();\n  srand(a[i] + omp_get_thread_num());\n  b[i] = rand();\n  srand(a[i] + b[i]);\n}\n\n", "pragma": "#pragma omp for schedule(static,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task7/0"}
{"code": "for (int i = 0; i < filesCount; i++)\n{\n  for (int i2 = 0; i2 < fileFindings[i].used; i2++)\n  {\n    freeFileFindings(&fileFindings[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcingolenia/KMP-using-C-and-OMP/main_omp/4"}
{"code": "for (i = 0; i < 10; i -= 3, j += 2)\n  baz(i);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-1/6"}
{"code": "for (int i = 0; i < 1000; i++)\n  sum += i;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/atomic/0"}
{"code": "for (size_t i = 0; i < domain_size; ++i)\n{\n  var_comp_vect[i] = &Get(r_base_variable_name + comp_list[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/utilities/rve_periodicity_utility/1"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  const double *old_variable = &data0[5 * n_op];\n  const double *variable = &data1[5 * n_op];\n  double *residual = &data2[5 * n_op];\n  for (int v = 0; v < NVAR; v++)\n  {\n    residual[v] = variable[v] - old_variable[v];\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/residual_kernel_omp4kernel_func/0"}
{"code": "for (omp_sched_t sched = omp_sched_static; ((int) sched) < max_sched; sched = (omp_sched_t) (((int) sched) + 1))\n{\n  if (strcmp(argv[1], sched_str[(int) sched]) == 0)\n  {\n    omp_sched = sched;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD1_OMP/omp_scheduling/scheduling/1"}
{"code": "for (i = th + thread; i < dim; i = i + thread)\n  if (sum_p[th] < fabs(tx[i] - xn_1[i]))\n  sum_p[th] = fabs(tx[i] - xn_1[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jr/jacobi_omp/7"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = (float) strtod(head, &tail);\n    if (tail == head)\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n    if (mat->rsizes[i] < 0)\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n      if (tail == head)\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = strtof(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/41"}
{"code": "for (int i = 0; i < 36; i++)\n{\n  xCoordinates[i] += center[0];\n  yCoordinates[i] += center[1];\n  zCoordinates[i] += center[2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/shape/cube/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 10; j++)\n    for (k = 0; k < 10; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luxifeo/openmp/OMP_matmul/0"}
{"code": "for (int i = 0; i < V; i++)\n  (cout << a.route[i]) << \"->\";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize_tsp_ga/9"}
{"code": "for (i = 0; i < docList.size(); i++)\n{\n  for (int j = 0; j < dictMap.size(); j++)\n  {\n    (outFile << result[(i * dictMap.size()) + j]) << \" \";\n  }\n\n  outFile << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZeyuuOne/Lab_3_OpenMP/Lab_3_OpenMP/main/0"}
{"code": "for (i = 0; i < N; i++)\n  L[(i * N) + i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/hpx/bench/lu/hpx-lu/3"}
{"code": "for (i = 0; i < 2; i++)\n{\n  printf(\"%ld,\", (long int) (((double) 3.611) * ((double) ((1000000000 * time_stamp[i].tv_sec) + time_stamp[i].tv_nsec))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/3"}
{"code": "for (int i = 0; i < ((3 * w) * h); i++)\n{\n  if (abs(rgbSequential[i] - rgbParallel[i]) > 0.01)\n  {\n    failed = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/za_predaju/dz1z2/0"}
{"code": "for (size_t ii = 0; ii < (*atoms).size(); ++ii)\n{\n  computeEDT(temp_cpk_model, surface, numberOfQueues, min_sdist, (*atoms)[ii], ptran, resolution, solventRadius, pwidth, pheight, dMap, cpk_model);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebastiandaberdaku/VoxMeshSurfOpenMP/src/MolecularSurface/MolecularSurface/2"}
{"code": "for (size_t i = 0; i < len; i++)\n  vec_ptr[i] = vec_ptr[i] * omp_get_team_num();\n\n", "pragma": "  #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Platforms/OMPTarget/map_structure/1"}
{"code": "for (i = 0; i < 5; i++)\n  sum1 += i;\n\n", "pragma": "omp for schedule(static) nowait reduction(+: sum1)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PRUNERS/archer/test/reduction/parallel-reduction-nowait/0"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    if (percentDiff(C[(i * 3072) + j], D[(i * 3072) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk_cpu/8"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  y += x[i];\n}\n\n", "pragma": "omp parallel for shared(x) reduction(+:y)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/reduction/2"}
{"code": "for (long i = 0; i < size; i++)\n{\n  RandVec[i] = RngArray[myRank].RandU01();\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/0"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  c[i] = a[i];\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UoB-HPC/BabelStream/src/omp/OMPStream/2"}
{"code": "for (i = 0; i < xx; i += 2)\n  temp[i >> 1] = input[i] + input[i + 1];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/Old/2"}
{"code": "for (int x = 0; x < WIDTH; x++)\n{\n  for (int y = 0; y < HEIGHT; y++)\n  {\n    a = (rand() % 10) + 1;\n    if (a < 6)\n    {\n      board[x][y] = 0;\n    }\n    else\n    {\n      board[x][y] = 1;\n    }\n\n    storage[x][y] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samueldelamotte/Game-of-Life-using-OpenMP-in-C/GoL/3"}
{"code": "for (n = 1; n <= block_len; n++)\n{\n  buffer = -INFINITY;\n  for (s = 0; s < chtrellis.stateNb; s++)\n  {\n    A[s + (n * chtrellis.stateNb)] = -INFINITY;\n    for (k = 0; k < chtrellis.numInputSymbols; k++)\n    {\n      sp = chtrellis.prevState[s + (k * chtrellis.stateNb)];\n      i = chtrellis.input[s + (k * chtrellis.stateNb)];\n      in_chips = dec2bin(nb_usr, i);\n      A[s + (n * chtrellis.stateNb)] = max(A[s + (n * chtrellis.stateNb)], (A[sp + ((n - 1) * chtrellis.stateNb)] - (sqr(rec_sig[n - 1] - chtrellis.output[sp + (i * chtrellis.stateNb)]) / (2 * sigma2))) + (to_vec(in_chips) * apriori_data.get_col(n - 1)));\n    }\n\n    buffer = max(buffer, A[s + (n * chtrellis.stateNb)]);\n  }\n\n  for (s = 0; s < chtrellis.stateNb; s++)\n  {\n    A[s + (n * chtrellis.stateNb)] -= buffer;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_mud/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  pos[i] = (cube.temp_counter - i) - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikos912000/octree-partitioning/octree_openmp/octree_openmp/8"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n  rho = rho + (r[j] * r[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ric113/ParallelProgramming/HW02/cg/0"}
{"code": "for (i = 0; i < 960; i++)\n{\n  printf(\"Vector %d [\", i);\n  for (j = 0; j < 9600; j++)\n  {\n    printf(\"%d \", bag_of_tasks[i][j]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_hybrid/8"}
{"code": "for (ie = 0; ie < nelt; ie++)\n{\n  for (k = 0; k < LX1; k++)\n  {\n    for (j = 0; j < LX1; j++)\n    {\n      for (i = 0; i < LX1; i++)\n      {\n        pdiff[ie][k][j][i] = dpcelm[ie][k][j][i] * trhs[ie][k][j][i];\n        rho1 = rho1 + ((trhs[ie][k][j][i] * pdiff[ie][k][j][i]) * tmult[ie][k][j][i]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/diffuse/1"}
{"code": "for (i = 1; i < n; ++i)\n{\n  int ID = omp_get_thread_num();\n  if ((ID == 1) && (f_time == 1))\n  {\n    a[i] = a[i];\n    f_time = 0;\n  }\n  else\n  {\n    a[i] = a[i] + a[i - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-lab-/4/code/1/0"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz0 - 2); k++)\n  {\n    sum0 = sum0 + (v[i][j][k][0] * v[i][j][k][0]);\n    sum1 = sum1 + (v[i][j][k][1] * v[i][j][k][1]);\n    sum2 = sum2 + (v[i][j][k][2] * v[i][j][k][2]);\n    sum3 = sum3 + (v[i][j][k][3] * v[i][j][k][3]);\n    sum4 = sum4 + (v[i][j][k][4] * v[i][j][k][4]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum4) reduction(+:sum3) reduction(+:sum2) reduction(+:sum1) reduction(+:sum0)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/24"}
{"code": "for (int i = 0; i < w; i++)\n  for (int j = 0; j < h; j++)\n  f[i + (j * w)] = 1 / (1 + (((1.0 * r) * r) / (((i - (w / 2)) * (i - (w / 2))) + ((j - (h / 2)) * (j - (h / 2))))));\n\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/6"}
{"code": "for (converg_i = 1; converg_i < a_bound; converg_i++)\n{\n  local_result = 1;\n  for (converg_j = 1; converg_j < b_bound; converg_j++)\n  {\n    local_result = local_result & (((fabs(u[0][converg_i][converg_j] - u[1][converg_i][converg_j]) * 100) / u[1][converg_i][converg_j]) <= 5);\n  }\n\n  result = result & local_result;\n}\n\n", "pragma": "omp parallel for private(vongerg_i,converg_j,local_result) reduction(&:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MikeAndroulakis/MPI-simulation-program/mpi_openmp_convergence/0"}
{"code": "for (uint32_t i = 0; i < rows; ++i)\n{\n  for (uint32_t j = 0; j < cols; ++j)\n  {\n    this->operator()(i, j) = rhs[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/0"}
{"code": "for (int i = 0; i < ((sizeof(column_r)) / (sizeof(*column_r))); i++)\n{\n  (cout << column_r[i]) << \" \\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CanBoran/Fractal-OpenMP/parallel_sparse/5"}
{"code": "for (int no_outgoing = 0; no_outgoing < numNodes; no_outgoing++)\n{\n  if (outgoing_size(g, no_outgoing) == 0)\n    sum_of_no_outgoing += (damping * old_solution[no_outgoing]) / numNodes;\n\n}\n\n", "pragma": "            #pragma omp for reduction (+:sum_of_no_outgoing)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/steven112163/Parallel-Programming/HW3/part2/page_rank/page_rank/1"}
{"code": "for (int i = 0; i < adj[rmp[u]].size(); i++)\n{\n  int e = adj[rmp[u]][i];\n  if (find_root(mp[edges[e].u]) != find_root(mp[edges[e].v]))\n  {\n    if (edges[e].w < minW)\n    {\n      minW = edges[e].w;\n      minE = e;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prateekami1994/Parallel-Programming/project/src/prim_hybridPMA/0"}
{"code": "for (ii = 0; ii < 10; ii++)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for firstprivate(ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/39"}
{"code": "for (int i = 1; i < processes_count; i++)\n{\n  MPI_Recv(&nz_counter, 1, (MPI_Datatype) 0x4c000405, i, 2, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n  buffer_i = (unsigned int *) malloc(nz_counter * (sizeof(unsigned int)));\n  MPI_Recv(buffer_i, nz_counter, (MPI_Datatype) 0x4c000406, i, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n  buffer_j = (unsigned int *) malloc(nz_counter * (sizeof(unsigned int)));\n  MPI_Recv(buffer_j, nz_counter, (MPI_Datatype) 0x4c000406, i, 1, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n  for (int k = *C_nz; k < ((*C_nz) + nz_counter); k++)\n  {\n    C_i[k] = buffer_i[k - (*C_nz)];\n    C_j[k] = buffer_j[k - (*C_nz)];\n  }\n\n  *C_nz += nz_counter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/12"}
{"code": "for (int deltaI = -1; deltaI < 2; deltaI++)\n{\n  for (int deltaJ = -1; deltaJ < 2; deltaJ++)\n  {\n    p = i + deltaI;\n    q = j + deltaJ;\n    if (p >= (chunkHeight + 2))\n    {\n      p = 0;\n    }\n    else\n      if (p < 0)\n    {\n      p = chunkHeight + 1;\n    }\n\n\n    if (q >= chunkWigth)\n    {\n      q = 0;\n    }\n    else\n      if (q < 0)\n    {\n      q = chunkWigth - 1;\n    }\n\n\n    sum += myPartWithBorders[p][q];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/penguin138/parallel_project/open_mp/src/thread/2"}
{"code": "for (a = id; a <= l; a++)\n{\n  align1.append(1, (char) xans[a]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/1"}
{"code": "for (i = 0; i < dim; i++)\n  for (j = 0; j < dim; j++)\n{\n  mat1[i][j] = 0.0;\n  for (k = 0; k < dim; k++)\n    mat1[i][j] += mat[i][k] * inv[k][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj_inv/bench/2"}
{"code": "for (int neuron = 0; neuron < (layers[layer] - 1); neuron += 1)\n{\n  a[layer][neuron] = sigmoid(z[layer][neuron]);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/neural-network/src/forward/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    a[i][j] = u(e);\n    b[i][j] = u(e);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_matrix_parallel/1"}
{"code": "for (i = 0; i < ast_get_num_ambiguities(a); i++)\n{\n  *nodecl_output = nodecl_null();\n  diagnostic_context_push_buffered();\n  bool dummy_is_init_declarator = false;\n  check_omp_initializer(ast_get_ambiguity(a, i), decl_context, nodecl_output, dummy_is_init_declarator);\n  diagnostic_context_pop_and_discard();\n  if (!nodecl_is_err_expr(*nodecl_output))\n  {\n    if (valid < 0)\n    {\n      valid = i;\n    }\n    else\n    {\n      internal_error(\"More than one ambiguity is valid\", 0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/core/tl-omp-reduction/0"}
{"code": "for (int i = 62; i < 86; ++i)\n{\n  w[i] *= C1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/10"}
{"code": "for (int i = 0; i < b.size(); ++i)\n{\n  (cout << x[i]) << ' ';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/19"}
{"code": "for (int i = 0; i < 10000000; ++i)\n  rand();\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BloodyRainRage/OpenMP/OpenMP/OpenMP/0"}
{"code": "for (i = 0; i < 9; i++)\n{\n  ssquares += pow(arr[i], 2);\n  scubes += pow(arr[i], 3);\n}\n\n", "pragma": "omp parallel for schedule(dynamic) shared(ssquares, scubes)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Arrays/array_squares_cubes_sum/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, X[i][j]);\n  if ((((i * N) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/adi/adi/7"}
{"code": "for (i = 0; i < num_processes; i++)\n{\n  num_thread = i;\n  if (num_thread != 0)\n  {\n    if (send_initial_message(total_num_houses, total_num_plugs, lines_left, num_thread, num_thread) < 1)\n    {\n      printf(\"ERROR\\tCannot send initial message\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (dizi[i] < minimum)\n    minimum = dizi[i];\n\n}\n\n", "pragma": "omp for reduction(min:minimum) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ienesaydogdu/Parallel-Programming-with-OpenMP/openmp_min/0"}
{"code": "for (long int i = 0; i < ((samples / 2) - 1); i++)\n{\n  ff[i] = (Fs * i) / samples;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PascalRomb/fftparallelanalysis/FFTPARALLEL/resources/FFTOpenMP/7"}
{"code": "for (col = 0; col < M; col += 8)\n{\n  for (row = 0; row < N; row += 8)\n  {\n    for (n = row; (n < (row + 8)) && (n < N); ++n)\n    {\n      for (m = col; (m < (col + 8)) && (m < M); ++m)\n      {\n        if (n != m)\n        {\n          *((B + (m * N)) + n) = *((A + (n * M)) + m);\n        }\n        else\n        {\n          diag = n;\n          d_val = *((A + (n * M)) + m);\n        }\n\n      }\n\n      if (row == col)\n      {\n        *((B + (diag * N)) + diag) = d_val;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunth2001/Software-Programming-for-Performance/Assignment2/Submission/q1/0"}
{"code": "for (int i = 1; i < 4194304; i++)\n{\n  res += fabsl(0.00000476837158203125 * ((((Y[i + 1] - (2 * Y[i])) + Y[i - 1]) / (0.00000476837158203125 * 0.00000476837158203125)) - (a_const * (((Y[i] * Y[i]) * Y[i]) - Y[i]))));\n}\n\n", "pragma": "omp parallel for num_threads(T_NUM) shared(Y,a_const) reduction(+: res) default(none)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task10/main/7"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int u;\n  int v;\n  (cin >> u) >> v;\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/par1/3"}
{"code": "for (int k = 0; k < np; k++)\n{\n  amp_right[k] += ((fac * exp(I * volkov_phase[k])) * exp(((-I) * p[k]) * wf.x1[i_right])) * (((-0.5) * right_2nd) + ((I * Afield) * right_1st));\n  amp_left[k] += ((fac * exp(I * volkov_phase[k])) * exp(((-I) * p[k]) * wf.x1[i_left])) * (((-0.5) * left_2nd) + ((I * Afield) * left_1st));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/46"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp9hy0i2jf.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmp9hy0i2jf.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/16"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = b[i] + c[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/clang/test/CodeGen/opt-record-1/0"}
{"code": "for (long long int t = 0; t < (MESH_SIZE * MESH_SIZE); ++t)\n{\n  size_t x = t / MESH_SIZE;\n  size_t y = t % MESH_SIZE;\n  float t_l = getTemperature(x - 1, y);\n  float t_r = getTemperature(x + 1, y);\n  float t_t = getTemperature(x, y - 1);\n  float t_b = getTemperature(x, y + 1);\n  const float k = 1.f;\n  const float d_x = 1.f;\n  float q = 0.f;\n  float newTemperature = ((((t_l + t_r) + t_b) + t_t) + (((q * d_x) * d_x) / k)) / 4;\n  nodes[y][x] = newTemperature;\n}\n\n", "pragma": "#pragma omp parallel for shared(nodes)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomix86/cuda-hybrid-heat-distrib/OptymalizacjaCUDA/main/0"}
{"code": "for (i = 0; i < TableSize; i++)\n{\n  Table[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/5"}
{"code": "for (i = 0; i < total_communities; i++)\n  temporary_community_edge_init(tce + i);\n\n", "pragma": "omp parallel for schedule(dynamic,50) default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/community-computation-weighted/2"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  bs += to_string(b[i]) + \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gerrytty/parallel-programming-course/openMP/task7/2"}
{"code": "for (int i = 0; i < n; ++i)\n  print();\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xi-liu-cs/mpi-openmp-cuda-project/openmp/omp/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  betaNumerator += newG[i] * (newG[i] - g[i]);\n  betaDenominator += pow(g[i], 2);\n  d[i] = ((-1) * newG[i]) + (beta * d[i]);\n  norm += pow(newG[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mazury/Parallel-Programming-C-Project/conjugate-gradient-openmp/9"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"--steps\") == 0)\n  {\n    steps = atoi(argv[i + 1]);\n  }\n  else\n    if (strcmp(argv[i], \"--num-threads\") == 0)\n  {\n    num_threads = atoi(argv[i + 1]);\n  }\n  else\n    if (strcmp(argv[i], \"--write-to-file\") == 0)\n  {\n    write_to_file = 1;\n  }\n  else\n    if (strcmp(argv[i], \"--investigate-threading\") == 0)\n  {\n    printf(\"Not using OpenMP\\n\");\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eddireeder/heat-transfer-simulation/hte/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  graph[i] = (GraphNode **) malloc((sizeof(GraphNode *)) * size);\n  for (j = 0; j < size; j++)\n  {\n    graph[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/5"}
{"code": "for (int i = 0; i <= sN; i++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (sN / mpi_size)\n    bi = i / (sN / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = bi - bj;\n  if (st < 0)\n    st += mpi_size;\n\n  st = (st + mpi_rank) % mpi_size;\n  s->rb = st * (_M / mpi_size);\n  s->re = s->rb + (_M / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = _M + 1;\n\n  if (s->re != (_M + 1))\n    x[idx(i, s->re, k)] = rbp[1][0];\n\n  if (s->rb != 0)\n    x[idx(i, s->rb - 1, k)] = rbp[0][0];\n\n  rbp[1]++;\n  rbp[0]++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/141"}
{"code": "for (int x = 0; x < MAP_SIZE; x++)\n{\n  for (int y = 0; y < MAP_SIZE; y++)\n  {\n    target[x][y][0] = image[((x * MAP_SIZE) + y) * 4];\n    target[x][y][1] = image[(((x * MAP_SIZE) + y) * 4) + 1];\n    target[x][y][2] = image[(((x * MAP_SIZE) + y) * 4) + 2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/VideoOutput/2"}
{"code": "for (my_current_person_id = 0; my_current_person_id <= (our_number_of_people - 1); my_current_person_id++)\n{\n  if (our_states[my_current_person_id] == SUSCEPTIBLE)\n  {\n    my_num_infected_nearby = 0;\n    for (my_person2 = 0; (my_person2 <= (total_num_infected - 1)) && (my_num_infected_nearby < 1); my_person2++)\n    {\n      if ((((our_x_locations[my_current_person_id] > (their_infected_x_locations[my_person2] - infection_radius)) && (our_x_locations[my_current_person_id] < (their_infected_x_locations[my_person2] + infection_radius))) && (our_y_locations[my_current_person_id] > (their_infected_y_locations[my_person2] - infection_radius))) && (our_y_locations[my_current_person_id] < (their_infected_y_locations[my_person2] + infection_radius)))\n      {\n        my_num_infected_nearby++;\n      }\n\n    }\n\n    if ((my_num_infected_nearby >= 1) && ((random() % 100) <= contagiousness_factor))\n    {\n      our_states[my_current_person_id] = INFECTED;\n      our_num_infected++;\n      our_num_susceptible--;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(my_current_person_id, my_num_infected_nearby, my_person2) reduction(+:our_num_infection_attempts) reduction(+:our_num_infected) reduction(+:our_num_susceptible) reduction(+:our_num_infections)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/pandemic/pandemic/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    A[i][j] = rand() % 5;\n    B[i][j] = rand() % 5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/0"}
{"code": "for (int i = 0; i <= NUM_FOLDS; i++)\n{\n  timer[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/L1FE0FJ4Y/Parallel_Ensemble_Classifier/ensemble/1"}
{"code": "for (i = 0; i < h; i++)\n{\n  y = (i * yinc) + ymin;\n  x = xmin;\n  for (j = 0; j < w; j++)\n  {\n    pgrid[(i * w) + j] = xy2color(x, y, prof);\n    x += xinc;\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, j, y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/mandel/0"}
{"code": "for (k = 0; k < m; k++)\n{\n  for (h = 0; h < n; h++)\n  {\n    count = 0;\n    for (l = 0; l < strlen(setB[h]); l++)\n    {\n      if (setA[k][l] != setB[h][l])\n      {\n        count++;\n      }\n\n    }\n\n    HamDist[k][h] = count;\n    TotalHammingDistance += HamDist[k][h];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tassosblackg/HammingDistance/HD_openmpA/5"}
{"code": "for (j = 1; j < (Ny - 1); j++)\n{\n  for (i = 1; i < (Nx - 1); i++)\n  {\n    Unplus1[i][j] = ((((-I[i][j]) + (2 * Un[i][j])) + ((((Un[i + 1][j] - (2 * Un[i][j])) + Un[i - 1][j]) * cx) * cx)) + ((((Un[i][j + 1] - (2 * Un[i][j])) + Un[i][j - 1]) * cy) * cy)) + ((((((dt * dt) * 2) * c) * c) * (1. + (t[k] / 2.))) * ((Y[j] * (Ly - Y[j])) + (X[i] * (Lx - X[i]))));\n    Uanal[i][j] = (((X[i] * (Lx - X[i])) * Y[j]) * (Ly - Y[j])) * (1. + (t[k] / 2.));\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saggelit/OpenMp/project2020parallel/5"}
{"code": "for (unsigned short l_po = 0; l_po < l_nPtrsSend; l_po++)\n  m_sendPtrs[l_po] = l_sendPtrs + ((l_po * i_nEls) * i_nElFas);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/parallel/Distributed/1"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  atot += cell(ci).area();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/21"}
{"code": "for (z = 0; z < OMP_zMax; z++)\n{\n  for (x = 0; x < OMP_xMax; x += 8)\n  {\n    int ind = OMP_Index(x, yval, z);\n    u[ind] *= boundryScale;\n    u[ind + 1] *= boundryScale;\n    u[ind + 2] *= boundryScale;\n    u[ind + 3] *= boundryScale;\n    u[ind + 4] *= boundryScale;\n    u[ind + 5] *= boundryScale;\n    u[ind + 6] *= boundryScale;\n    u[ind + 7] *= boundryScale;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/loopunroll16/4ompDeblur/1"}
{"code": "for (n = 0; n < Nopt; n++)\n{\n  m = maturities[n] - 1;\n  swapval = (B[m] + (swaprates[n] * S[m])) - 1.f;\n  if (swapval < 0)\n  {\n    v += (-100.f) * swapval;\n    S_b[m] += (-100.f) * swaprates[n];\n    B_b[m] += -100.f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/6"}
{"code": "for (off = 0L, one_write = max_write; len < J->GetMatrixSize(); off += max_write)\n{\n  len += pwrite64(fd_g, TmpPtr + off, one_write, off);\n  if ((J->GetMatrixSize() - len) < max_write)\n    one_write = J->GetMatrixSize() - len;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/7"}
{"code": "for (size_t i = 0; i < grid_size; i++)\n{\n  size_t num_neighbors = get_num_neighbors(grid, i, world_size, grid_size);\n  if (grid[i])\n  {\n    grid_next[i] = ((num_neighbors <= 1) || (num_neighbors > 3)) ? (DEAD) : (ALIVE);\n  }\n  else\n  {\n    grid_next[i] = (num_neighbors == 3) ? (ALIVE) : (DEAD);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jonahb13/conways-game-of-life/game_of_life_shared/0"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = ((double) (i + 0.5)) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yehia67/OpenMP-Examples/piParallel/0"}
{"code": "for (int i = 0; i < no_points; i++)\n{\n  gene1[i] = gene2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/6"}
{"code": "for (int i = 1; i < array_length; i++)\n{\n  int tid = omp_get_thread_num();\n  if (debug)\n  {\n    printf(\"Iter \u2116%d:\\n\\t   tid: %d\\n\\t   arr element: %d\\n\\t   max_el: %d\\n\", i, tid, array[i], max_el);\n  }\n\n  if (array[i] >= max_el)\n  {\n    max_el = array[i];\n    if (debug)\n    {\n      printf(\"Iter \u2116%d:\\n\\t   tid: %d\\n\\t   new max_el: %d\\n\", i, tid, max_el);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(array, max_el, array_length, debug) default(none) num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail11235/openmp/max/0"}
{"code": "for (i = 0; i < nu; i++)\n{\n  aleft[i] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/2"}
{"code": "for (k = 0; k < other_mat->n_rows; ++k)\n{\n  sum += a[(i * this->n_cols) + k] * b[(k * other_mat->n_cols) + j];\n}\n\n", "pragma": "          #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishig25/2017Block2/project/openmp/2"}
{"code": "for (int i = 3 * (10000 / 4); i < 10000; i++)\n{\n  task1(gl_taskData.execTasks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p2/task/5"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  tmp_qsSub[CVT_INT(m_subbsnID[i])] += m_cellFlow[i][0];\n  m_OL_Flow[i] = m_cellFlow[i][0];\n  m_OL_Flow[i] = ((m_OL_Flow[i] * m_TimeStep) * 1000.f) / m_cellArea;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IUH_OL/IUH_OL/4"}
{"code": "for (i = 0; i < arraySize; i++)\n{\n  threads = omp_get_num_threads();\n  count = 0;\n  for (j = 0; j < arraySize; j++)\n  {\n    if ((array[j] < array[i]) || ((array[j] == array[i]) && (j < i)))\n    {\n      count++;\n    }\n\n  }\n\n  temp[count] = array[i];\n}\n\n", "pragma": "omp parallel for shared(array, arraySize, temp) private(i, j, count)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcpablo/cefet-openmp/counting-sort/openmp/parallel/0"}
{"code": "for (int i = 1, j = size - 2; i < size; i++, j--)\n{\n  partial_result1[i] += partial_result1[i - 1];\n  partial_result2[j] += partial_result2[j + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/1"}
{"code": "for (int i = 1; i <= nVer; i++)\n{\n  offset = graphCRSIdx[i - 1].size();\n  verPtr[i] = verPtr[i - 1] + offset;\n  count = verPtr[i - 1];\n  for (int j = 0; j < offset; j++)\n  {\n    verInd[count].id = graphCRSIdx[i - 1][j];\n    verInd[count].weight = graphCRSVal[i - 1][j];\n    count++;\n  }\n\n  if (offset > max)\n    max = offset;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/mtxReader/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double ni = pndi[i];\n  if (((particleType[i] == fluid) && (particleNearWall[i] == true)) && (ni > 1.0e-8))\n  {\n    double DivV = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double Rref_i[9];\n    double normaliw[3];\n    double normalMod2;\n    normaliw[0] = 0.5 * (posXi - posMirrorXi);\n    normaliw[1] = 0.5 * (posYi - posMirrorYi);\n    normaliw[2] = 0.5 * (posZi - posMirrorZi);\n    normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n    if (normalMod2 > 1.0e-8)\n    {\n      double normalMod = sqrt(normalMod2);\n      normaliw[0] = normaliw[0] / normalMod;\n      normaliw[1] = normaliw[1] / normalMod;\n      normaliw[2] = normaliw[2] / normalMod;\n    }\n    else\n    {\n      normaliw[0] = 0;\n      normaliw[1] = 0;\n      normaliw[2] = 0;\n    }\n\n    Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n    Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n    Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n    Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n    Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n    Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n    Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n    Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n    Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n    double velMirrorXi = ((Rref_i[0] * velXi) + (Rref_i[1] * velYi)) + (Rref_i[2] * velZi);\n    double velMirrorYi = ((Rref_i[3] * velXi) + (Rref_i[4] * velYi)) + (Rref_i[5] * velZi);\n    double velMirrorZi = ((Rref_i[6] * velXi) + (Rref_i[7] * velYi)) + (Rref_i[8] * velZi);\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if (((dstij2 < reS2) && (dstimj2 < reS2)) && (dstij2 < dstimj2))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstimj2);\n                double wS = weight(dst, reS, weightType);\n                double vijx = vel[j * 3] - velMirrorXi;\n                double vijy = vel[(j * 3) + 1] - velMirrorYi;\n                double vijz = vel[(j * 3) + 2] - velMirrorZi;\n                DivV += ((((dim / pndSmallZero) * (pndi[j] / ni)) * (((vijx * v0imj) + (vijy * v1imj)) + (vijz * v2imj))) * wS) / dstimj2;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    double v0imi;\n    double v1imi;\n    double v2imi;\n    double dstimi2;\n    sqrDistBetweenParticles(i, posMirrorXi, posMirrorYi, posMirrorZi, v0imi, v1imi, v2imi, dstimi2);\n    if (dstimi2 < reS2)\n    {\n      double dst = sqrt(dstimi2);\n      double wS = weight(dst, reS, weightType);\n      double vijx = velXi - velMirrorXi;\n      double vijy = velYi - velMirrorYi;\n      double vijz = velZi - velMirrorZi;\n      DivV += ((((dim / pndSmallZero) * (pndi[i] / ni)) * (((vijx * v0imi) + (vijy * v1imi)) + (vijz * v2imi))) * wS) / dstimi2;\n    }\n\n    velDivergence[i] += DivV;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/54"}
{"code": "for (i = 0; i < (resultSize * resultSize); i++)\n{\n  int y = i % resultSize;\n  int x = i / resultSize;\n  int sum = 0;\n  int k;\n  for (k = 0; k < (featureSize * featureSize); k++)\n  {\n    int a = k / featureSize;\n    int b = k % featureSize;\n    int imageIdx = ((x + a) * imageSize) + (y + b);\n    int featureIdx = (featureSize * a) + b;\n    sum += flipedMatrix[imageIdx] * featureMatrix[featureIdx];\n  }\n\n  resultMatrix[i] = sum;\n}\n\n", "pragma": "#pragma omp for schedule(dynamic, threadSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JerryHu1994/CS-759-High-Performance-Computing/HW04/problem2/0"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n  key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/3"}
{"code": "for (int i = 0; i < matrix_size; i++)\n{\n  for (int j = 0; j < matrix_size; j++)\n  {\n    printf(\"%d\\t\", b[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilisDev/parallel_programming_openMP/project_1/diagonal/0"}
{"code": "for (int i = 0; i < N; i++)\n  maxError = fmax(maxError, fabs(y[i] - 3.0f));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stephanmg/cuda-playground/vecadd_cpu/2"}
{"code": "for (int py = 0; py < nDetXMap; py++)\n{\n  for (int px = 0; px < nDetYMap; px++)\n  {\n    const int pos = (py * nDetYMap) + px;\n    pXmapp[pos] = ((((pXcoord[py] - tubeX) * (pZSlicecoord[nz] - pZcoord[px])) - (pXcoord[py] * tubeZ)) + (pXcoord[py] * pZcoord[px])) / ((-tubeZ) + pZcoord[px]);\n    if (py == 0)\n      pYmapp[px] = ((((pYcoord[px] - tubeY) * (pZSlicecoord[nz] - pZcoord[px])) - (pYcoord[px] * tubeZ)) + (pYcoord[px] * pZcoord[px])) / ((-tubeZ) + pZcoord[px]);\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/3"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = row_ptr[i]; j < row_ptr[i + 1]; j++)\n  {\n    if (i == col_ind[j])\n      ret.data()[i] = val[j];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/matrix/matrix_sys/6"}
{"code": "for (j = 0; j < npxyz; j++)\n{\n  part[3 + (idimp * j)] -= sum1;\n  part[4 + (idimp * j)] -= sum2;\n  part[5 + (idimp * j)] -= sum3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/36"}
{"code": "for (int i = 0; i < size; i++)\n{\n  x[i] = min;\n  y[i] = (((((((da * pow(min, 7)) + (db * pow(min, 6))) + (dc * pow(min, 5))) + (dd * pow(min, 4))) + (de * pow(min, 3))) + (df * pow(min, 2))) + (dg * min)) + dh;\n  min += (xRangeMax - xRangeMin) / 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/80"}
{"code": "for (i = 0; i < N; i++)\n{\n  A = a[i] + b[i];\n  B = (4 * a[i]) - b[i];\n  C = max(A, B);\n  if (C > 1)\n    sum += C;\n\n}\n\n", "pragma": "#pragma omp parallel for shared(a, b) private(i, A, B, C) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wolfram18/OpenMP-Practice/OpenMP-Project/Project345/Synchronization/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = ((rand() % 3) + 1) / 0.3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gemarela/fft_openmp/openmp_fft/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    (matrixFile << matrixToWrite[(i * size) + j]) << \" \";\n  }\n\n  matrixFile << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raulviana/FEUP-CPAR/Assigment2/LU_Decomp/LU_omp/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == fluid)\n  {\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double duXi = 0.0;\n    double duYi = 0.0;\n    double duZi = 0.0;\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstij2);\n                double dw = delWeight(dst, reS, weightType);\n                duXi += dw * (vel[j * 3] - velXi);\n                duYi += dw * (vel[(j * 3) + 1] - velYi);\n                duZi += dw * (vel[(j * 3) + 2] - velZi);\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    if (particleBC[i] == inner)\n    {\n      vel[i * 3] -= coeffShifting1 * duXi;\n      vel[(i * 3) + 1] -= coeffShifting1 * duYi;\n      vel[(i * 3) + 2] -= coeffShifting1 * duZi;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/85"}
{"code": "for (unsigned long long i_counter = 7; i_counter <= pnHalfed; i_counter = i_counter + 2)\n{\n  if (((*pn) % i_counter) == 0)\n  {\n    primIndicator = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/1"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = ky - 1;\n  if (kl < 0)\n    kl += my1;\n\n  kl = kl * mx1;\n  kr = ky + 1;\n  if (kr >= my1)\n    kr -= my1;\n\n  kr = kr * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = kxr + kk;\n  ks[1] = kxl + kk;\n  ks[2] = kx + kr;\n  ks[3] = kxr + kr;\n  ks[4] = kxl + kr;\n  ks[5] = kx + kl;\n  ks[6] = kxr + kl;\n  ks[7] = kxl + kl;\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 8; ii++)\n  {\n    if (ii > 0)\n      ncoff = ncl[(ii - 1) + (8 * ks[ii])];\n\n    ip = ncl[ii + (8 * ks[ii])] - ncoff;\n    for (j = 0; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        j1 = npp;\n        npp += 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[i + (idimp * (j1 + (nppmx * k)))] = ppbuff[i + (idimp * ((j + ncoff) + (npbmx * ks[ii])))];\n        }\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    for (j = 0; j < ip; j++)\n    {\n      j1 = (npp - j) - 1;\n      j2 = ihole[2 * ((nh - j) + ((ntmax + 1) * k))] - 1;\n      if (j1 > j2)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[i + (idimp * (j2 + (nppmx * k)))] = ppart[i + (idimp * (j1 + (nppmx * k)))];\n        }\n\n      }\n\n    }\n\n    npp -= ip;\n  }\n\n  kpic[k] = npp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,ii,kk,npp,kx,ky,kl,kr,kxl,kxr,ih,nh,ncoff,ist,j1,j2,ip,ks)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/7"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  grid[i] = &gridData[i * ncolumns];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_mpi_openmp/4"}
{"code": "for (i = 0; i < paddedN; i++)\n{\n  int ij = i ^ j;\n  if (ij > i)\n  {\n    if (((i & k) == 0) && (a[i] > a[ij]))\n      exchange(i, ij);\n\n    if (((i & k) != 0) && (a[i] < a[ij]))\n      exchange(i, ij);\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dzarrr/Tugas-Sister-OpenMP/src/bitonic_sort/0"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/98"}
{"code": "for (int i = 0; i < 8; i++)\n  getline(fin, str);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_3/many-body-sim-program/3"}
{"code": "for (idx_t i = 0; i < rank; ++i)\n{\n  for (idx_t j = i; j < rank; ++j)\n  {\n    av[j + (i * rank)] = 1.;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/cpd/5"}
{"code": "for (unsigned long long int i = 0; i < 76; i++)\n{\n  printf(\"%06d \", p.path[i]);\n  if (((i + 1) % 10) == 0)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebaMederos/TSP-OpenMP/sim-ann/SA/4"}
{"code": "for (j = 0, k = (i * strp_rows) * ncols; k < (nrows * ncols); j++, k++)\n{\n  strp_buffer[j] = aa[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/2"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (stats->parents[v] < 0)\n  {\n    Nodes = graph->vertices[v].inNodes;\n    degree = graph->vertices[v].in_degree;\n    for (j = 0; j < degree; j++)\n    {\n      u = Nodes->dest;\n      Nodes = Nodes->next;\n      if (getBit(bitmapCurr, u))\n      {\n        stats->parents[v] = u;\n        setBitAtomic(bitmapNext, v);\n        stats->distances[v] = stats->distances[u] + 1;\n        nf++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(Nodes,j,u,v,degree) shared(stats,bitmapCurr,bitmapNext,graph) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/20"}
{"code": "for (int i = 0; i < ((r - rk) + 1); i++)\n{\n  for (int j = 0; j < ((c - ck) + 1); j++)\n  {\n    pC[i][j] = (2 * pC[i][j]) - 48;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) num_threads(NUM_OF_THREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCONVbench2/1"}
{"code": "for (int i = 0; i < (MAX_LENGTH - 1); i++)\n{\n  b[i] = sin(i + 1);\n  a[i + 1] = b[i];\n  totalA += a[i + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/meismyles/pearson-cc/openmp/PearsonCC/2"}
{"code": "for (int I = 0; I <= R; I++)\n{\n  strcat(bar, \"-\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/10"}
{"code": "for (int row = block.beginCoord.y; row <= block.endCoord.y; row++)\n{\n  int col = 0;\n  if (block.beginCoord.y == row)\n    col = block.beginCoord.x;\n\n  int endx = mRaw->dim.x;\n  if (block.endCoord.y == row)\n    endx = block.endCoord.x;\n\n  assert((col % dsc.pixelsPerPacket) == 0);\n  assert((endx % dsc.pixelsPerPacket) == 0);\n  for (; col < endx; col += dsc.pixelsPerPacket)\n    (processPixelPacket < dsc) > ((bs, row, col));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/PanasonicV5Decompressor/1"}
{"code": "for (int i = 0; i < argc; i++)\n{\n  if (strcmp(argv[i], stringA) == 0)\n  {\n    thesis = i;\n    if (argv[thesis + 1] == 0)\n    {\n      printf(\"Exit EXIT_FAILURE\\n\");\n      exit(1);\n    }\n\n    return atoi(argv[thesis + 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z1skgr/OpenMP-pthreads-parallelComputing/OMPa/1"}
{"code": "for (int i = OMPC_SCHEDULE_unknown + 1; i < NUM_OPENMP_SCHEDULE_KINDS; ++i)\n{\n  Values += \"'\";\n  Values += getOpenMPSimpleClauseTypeName(OMPC_schedule, i);\n  Values += \"'\";\n  switch (i)\n  {\n    case NUM_OPENMP_SCHEDULE_KINDS - 2:\n      Values += \" or \";\n      break;\n\n    case NUM_OPENMP_SCHEDULE_KINDS - 1:\n      break;\n\n    default:\n      Values += Sep;\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/9"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n    {\n      rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] - (dssp * (((((-4.0) * u[i][j][k - 1][m_imopVar18]) + (6.0 * u[i][j][k][m_imopVar18])) - (4.0 * u[i][j][k + 1][m_imopVar18])) + u[i][j][k + 2][m_imopVar18]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/26"}
{"code": "for (int i = 0; i < n; i++)\n{\n  ((((cout << \"parent: \") << ufind[i].parent) << \", rank:  \") << ufind[i].rank) << \" | \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_init/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int binIndex = find_binIndex(particles[i].x, particles[i].y, binWidth, gridSize);\n  particles[i].ax = (particles[i].ay = 0);\n  omp_set_lock(locks + binIndex);\n  bins[binIndex].particles.push_back(i);\n  omp_unset_lock(locks + binIndex);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jkaugust/Comparison-of-serial-OpenMP-and-MPI-programming-paradigms/openmp/1"}
{"code": "for (int i = 1; i < ((rowsNumber / sqrt_comm_sz) - 1); i++)\n{\n  for (int j = 1; j < ((colsNumber / sqrt_comm_sz) - 1); j++)\n  {\n    myFinalArray[i][j] = ((((((((myArray[i - 1][j - 1] * (((double) 1) / 16)) + (myArray[i][j - 1] * (((double) 2) / 16))) + (myArray[i + 1][j - 1] * (((double) 1) / 16))) + (myArray[i - 1][j] * (((double) 2) / 16))) + (myArray[i][j] * (((double) 4) / 16))) + (myArray[i + 1][j] * (((double) 2) / 16))) + (myArray[i - 1][j + 1] * (((double) 1) / 16))) + (myArray[i][j + 1] * (((double) 2) / 16))) + (myArray[i + 1][j + 1] * (((double) 1) / 16));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/gray/0"}
{"code": "for (idx_t m = 0; m < ft->nmodes; ++m)\n{\n  hg->nhedges += ft->dims[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/13"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%d\\n\", m_pParticleData->m_vLPFOrderUp[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/50"}
{"code": "for (j = 0; j < (sizeof(vectorMAPESRealizados)); j++)\n{\n  fprintf(fichero2, \"%s%d%s\", \"\\nMape de la fila\", j + 1, \":\");\n  fprintf(fichero2, \"%f\", vectorMAPESRealizados[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quiquemachado5/Prediccion-series-temporales-OpenMP-MPI/AlgoritmoProyectoSDFicherosMPIfin/8"}
{"code": "for (x = 2; x < (maxXCount - 2); x++)\n{\n  fX = xLeft + ((x - 1) * deltaX);\n  updateVal = (((((u_old[(1 * maxXCount) + (x - 1)] + u_old[(1 * maxXCount) + (x + 1)]) * cx) + ((north_v[x - 1] + u_old[(2 * maxXCount) + x]) * cy)) + (u_old[(1 * maxXCount) + x] * cc)) - (((((-alpha) * (1.0 - (fX * fX))) * (1.0 - (fY * fY))) - (2.0 * (1.0 - (fX * fX)))) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  cur_error += updateVal * updateVal;\n  u[maxXCount + x] = u_old[maxXCount + x] - (relax * updateVal);\n}\n\n", "pragma": "omp for reduction(+: cur_error) schedule(static,1000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksakkas/Parallel-Systems-Project/HybridMPI/hybrid/1"}
{"code": "for (k = 0; k < MATRIX_SIZE; k += BLOCK_SIZE)\n{\n  for (j = 0; j < MATRIX_SIZE; j += BLOCK_SIZE)\n  {\n    for (i = 0; i < MATRIX_SIZE; ++i)\n    {\n      for (jj = j; jj < min(j + BLOCK_SIZE, MATRIX_SIZE); ++jj)\n      {\n        for (kk = k; kk < min(k + BLOCK_SIZE, MATRIX_SIZE); ++kk)\n        {\n          C[i][jj] += A[i][kk] * B[kk][jj];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/magiciiboy/openmp-matmul/Block matrix multiplication/Nested/block_mm/0"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (m - 1); j++)\n  {\n    resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n    u[i][j] = uold[i][j] - (omega * resid);\n    error = error + (resid * resid);\n  }\n\n}\n\n", "pragma": "omp parallel for private(resid) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB058-jacobikernel-orig-no/1"}
{"code": "for (int k = 0; k < buckets.size(); k++)\n{\n  for (int j = 0; j < buckets[k].size(); j++)\n  {\n    for (int p = 0; p < buckets[k][j].size(); p++)\n    {\n      data_new[index_of_data_new] = buckets[k][j][p];\n      index_of_data_new++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashwinikumar2/Parallel-Merge-Quick-and-Radix-Sort-using-OpenMP/sort/7"}
{"code": "for (i = 0; i < 50; i++)\n  foo(a);\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr39591-3/0"}
{"code": "for (i = 0; i < 2; i++)\n{\n  {\n    var++;\n  }\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) shared(var) schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/tools/archer/tests/races/task-two/0"}
{"code": "for (int i = x - 1; i <= (x + 1); i++)\n{\n  for (int j = y - 1; j <= (y + 1); j++)\n  {\n    if (((i != x) || (j != y)) && cur_img(i, j))\n    {\n      alive += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pravez/VitaeLabilis/src/compute/5"}
{"code": "for (k = lb + 1; k <= (lt - 1); k++)\n{\n  j = k - 1;\n  zero3(u[k], m1[k], m2[k], m3[k]);\n  interp(u[j], m1[j], m2[j], m3[j], u[k], m1[k], m2[k], m3[k], k);\n  resid(u[k], r[k], r[k], m1[k], m2[k], m3[k], a, k);\n  psinv(r[k], u[k], m1[k], m2[k], m3[k], c, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/20"}
{"code": "for (int i = 0; i < rows; i++)\n  for (int j = 0; j < cols; j++)\n{\n  if (mapa[i][j] > maximo)\n  {\n    maximo = mapa[i][j];\n    numHilo = omp_get_thread_num();\n    registros[numHilo].x = i;\n    registros[numHilo].y = j;\n    registros[numHilo].valor = mapa[i][j];\n  }\n\n}\n\n\n", "pragma": "omp parallel for shared(mapa,registros) firstprivate(maximo) private(numHilo)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas5.0/0"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j += 1)\n{\n  for (k = 0; k <= (grid_points[2] - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      for (n = 0; n <= 4; n += 1)\n      {\n        lhs[i][j][k][0][m][n] = 0.0;\n        lhs[i][j][k][1][m][n] = 0.0;\n        lhs[i][j][k][2][m][n] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/44"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n{\n  printf(\"Enter a Number for 'A' Matrix for the Row and Column : \");\n  scanf(\"%d\", &A[i][j]);\n  printf(\"Enter a Number for 'B' Matrix for the Row and Column : \");\n  scanf(\"%d\", &B[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/mat_vec_mult/1"}
{"code": "for (int i = 0; i < MAT_ROWS; i++)\n{\n  for (int j = 0; j < MAT_COLS; j++)\n  {\n    int valA = (rand() % 20) + 1;\n    int valB = (rand() % 20) + 1;\n    matA[(i * MAT_COLS) + j] = valA;\n    matB[(i * MAT_COLS) + j] = valB;\n    matBTrans[(j * MAT_COLS) + i] = valB;\n    matC[(i * MAT_COLS) + j] = 0;\n    matA2d[i][j] = valA;\n    matB2d[i][j] = valB;\n    matC2d[i][j] = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/psattiza/matrixMult/main/10"}
{"code": "for (int i = 0; i < SIZE; i++)\n  if (data[i] != (-1))\n{\n  max_idx[i] = i;\n}\n\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle1/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 0; i <= isize; i++)\n    {\n      tmp1 = rho_i[k][j][i];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i][0][0] = 0.0;\n      fjac[i][1][0] = 1.0;\n      fjac[i][2][0] = 0.0;\n      fjac[i][3][0] = 0.0;\n      fjac[i][4][0] = 0.0;\n      fjac[i][0][1] = (-((u[k][j][i][1] * tmp2) * u[k][j][i][1])) + (c2 * qs[k][j][i]);\n      fjac[i][1][1] = (2.0 - c2) * (u[k][j][i][1] / u[k][j][i][0]);\n      fjac[i][2][1] = (-c2) * (u[k][j][i][2] * tmp1);\n      fjac[i][3][1] = (-c2) * (u[k][j][i][3] * tmp1);\n      fjac[i][4][1] = c2;\n      fjac[i][0][2] = (-(u[k][j][i][1] * u[k][j][i][2])) * tmp2;\n      fjac[i][1][2] = u[k][j][i][2] * tmp1;\n      fjac[i][2][2] = u[k][j][i][1] * tmp1;\n      fjac[i][3][2] = 0.0;\n      fjac[i][4][2] = 0.0;\n      fjac[i][0][3] = (-(u[k][j][i][1] * u[k][j][i][3])) * tmp2;\n      fjac[i][1][3] = u[k][j][i][3] * tmp1;\n      fjac[i][2][3] = 0.0;\n      fjac[i][3][3] = u[k][j][i][1] * tmp1;\n      fjac[i][4][3] = 0.0;\n      fjac[i][0][4] = (((c2 * 2.0) * square[k][j][i]) - (c1 * u[k][j][i][4])) * (u[k][j][i][1] * tmp2);\n      fjac[i][1][4] = ((c1 * u[k][j][i][4]) * tmp1) - (c2 * (((u[k][j][i][1] * u[k][j][i][1]) * tmp2) + qs[k][j][i]));\n      fjac[i][2][4] = ((-c2) * (u[k][j][i][2] * u[k][j][i][1])) * tmp2;\n      fjac[i][3][4] = ((-c2) * (u[k][j][i][3] * u[k][j][i][1])) * tmp2;\n      fjac[i][4][4] = c1 * (u[k][j][i][1] * tmp1);\n      njac[i][0][0] = 0.0;\n      njac[i][1][0] = 0.0;\n      njac[i][2][0] = 0.0;\n      njac[i][3][0] = 0.0;\n      njac[i][4][0] = 0.0;\n      njac[i][0][1] = (((-con43) * c3c4) * tmp2) * u[k][j][i][1];\n      njac[i][1][1] = (con43 * c3c4) * tmp1;\n      njac[i][2][1] = 0.0;\n      njac[i][3][1] = 0.0;\n      njac[i][4][1] = 0.0;\n      njac[i][0][2] = ((-c3c4) * tmp2) * u[k][j][i][2];\n      njac[i][1][2] = 0.0;\n      njac[i][2][2] = c3c4 * tmp1;\n      njac[i][3][2] = 0.0;\n      njac[i][4][2] = 0.0;\n      njac[i][0][3] = ((-c3c4) * tmp2) * u[k][j][i][3];\n      njac[i][1][3] = 0.0;\n      njac[i][2][3] = 0.0;\n      njac[i][3][3] = c3c4 * tmp1;\n      njac[i][4][3] = 0.0;\n      njac[i][0][4] = (((((-((con43 * c3c4) - c1345)) * tmp3) * (u[k][j][i][1] * u[k][j][i][1])) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][2] * u[k][j][i][2]))) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][3] * u[k][j][i][3]))) - ((c1345 * tmp2) * u[k][j][i][4]);\n      njac[i][1][4] = (((con43 * c3c4) - c1345) * tmp2) * u[k][j][i][1];\n      njac[i][2][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][2];\n      njac[i][3][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][3];\n      njac[i][4][4] = c1345 * tmp1;\n    }\n\n    lhsinit(lhs, isize);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      tmp1 = dt * tx1;\n      tmp2 = dt * tx2;\n      lhs[i][AA][0][0] = (((-tmp2) * fjac[i - 1][0][0]) - (tmp1 * njac[i - 1][0][0])) - (tmp1 * dx1);\n      lhs[i][AA][1][0] = ((-tmp2) * fjac[i - 1][1][0]) - (tmp1 * njac[i - 1][1][0]);\n      lhs[i][AA][2][0] = ((-tmp2) * fjac[i - 1][2][0]) - (tmp1 * njac[i - 1][2][0]);\n      lhs[i][AA][3][0] = ((-tmp2) * fjac[i - 1][3][0]) - (tmp1 * njac[i - 1][3][0]);\n      lhs[i][AA][4][0] = ((-tmp2) * fjac[i - 1][4][0]) - (tmp1 * njac[i - 1][4][0]);\n      lhs[i][AA][0][1] = ((-tmp2) * fjac[i - 1][0][1]) - (tmp1 * njac[i - 1][0][1]);\n      lhs[i][AA][1][1] = (((-tmp2) * fjac[i - 1][1][1]) - (tmp1 * njac[i - 1][1][1])) - (tmp1 * dx2);\n      lhs[i][AA][2][1] = ((-tmp2) * fjac[i - 1][2][1]) - (tmp1 * njac[i - 1][2][1]);\n      lhs[i][AA][3][1] = ((-tmp2) * fjac[i - 1][3][1]) - (tmp1 * njac[i - 1][3][1]);\n      lhs[i][AA][4][1] = ((-tmp2) * fjac[i - 1][4][1]) - (tmp1 * njac[i - 1][4][1]);\n      lhs[i][AA][0][2] = ((-tmp2) * fjac[i - 1][0][2]) - (tmp1 * njac[i - 1][0][2]);\n      lhs[i][AA][1][2] = ((-tmp2) * fjac[i - 1][1][2]) - (tmp1 * njac[i - 1][1][2]);\n      lhs[i][AA][2][2] = (((-tmp2) * fjac[i - 1][2][2]) - (tmp1 * njac[i - 1][2][2])) - (tmp1 * dx3);\n      lhs[i][AA][3][2] = ((-tmp2) * fjac[i - 1][3][2]) - (tmp1 * njac[i - 1][3][2]);\n      lhs[i][AA][4][2] = ((-tmp2) * fjac[i - 1][4][2]) - (tmp1 * njac[i - 1][4][2]);\n      lhs[i][AA][0][3] = ((-tmp2) * fjac[i - 1][0][3]) - (tmp1 * njac[i - 1][0][3]);\n      lhs[i][AA][1][3] = ((-tmp2) * fjac[i - 1][1][3]) - (tmp1 * njac[i - 1][1][3]);\n      lhs[i][AA][2][3] = ((-tmp2) * fjac[i - 1][2][3]) - (tmp1 * njac[i - 1][2][3]);\n      lhs[i][AA][3][3] = (((-tmp2) * fjac[i - 1][3][3]) - (tmp1 * njac[i - 1][3][3])) - (tmp1 * dx4);\n      lhs[i][AA][4][3] = ((-tmp2) * fjac[i - 1][4][3]) - (tmp1 * njac[i - 1][4][3]);\n      lhs[i][AA][0][4] = ((-tmp2) * fjac[i - 1][0][4]) - (tmp1 * njac[i - 1][0][4]);\n      lhs[i][AA][1][4] = ((-tmp2) * fjac[i - 1][1][4]) - (tmp1 * njac[i - 1][1][4]);\n      lhs[i][AA][2][4] = ((-tmp2) * fjac[i - 1][2][4]) - (tmp1 * njac[i - 1][2][4]);\n      lhs[i][AA][3][4] = ((-tmp2) * fjac[i - 1][3][4]) - (tmp1 * njac[i - 1][3][4]);\n      lhs[i][AA][4][4] = (((-tmp2) * fjac[i - 1][4][4]) - (tmp1 * njac[i - 1][4][4])) - (tmp1 * dx5);\n      lhs[i][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][0][0])) + ((tmp1 * 2.0) * dx1);\n      lhs[i][BB][1][0] = (tmp1 * 2.0) * njac[i][1][0];\n      lhs[i][BB][2][0] = (tmp1 * 2.0) * njac[i][2][0];\n      lhs[i][BB][3][0] = (tmp1 * 2.0) * njac[i][3][0];\n      lhs[i][BB][4][0] = (tmp1 * 2.0) * njac[i][4][0];\n      lhs[i][BB][0][1] = (tmp1 * 2.0) * njac[i][0][1];\n      lhs[i][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][1][1])) + ((tmp1 * 2.0) * dx2);\n      lhs[i][BB][2][1] = (tmp1 * 2.0) * njac[i][2][1];\n      lhs[i][BB][3][1] = (tmp1 * 2.0) * njac[i][3][1];\n      lhs[i][BB][4][1] = (tmp1 * 2.0) * njac[i][4][1];\n      lhs[i][BB][0][2] = (tmp1 * 2.0) * njac[i][0][2];\n      lhs[i][BB][1][2] = (tmp1 * 2.0) * njac[i][1][2];\n      lhs[i][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][2][2])) + ((tmp1 * 2.0) * dx3);\n      lhs[i][BB][3][2] = (tmp1 * 2.0) * njac[i][3][2];\n      lhs[i][BB][4][2] = (tmp1 * 2.0) * njac[i][4][2];\n      lhs[i][BB][0][3] = (tmp1 * 2.0) * njac[i][0][3];\n      lhs[i][BB][1][3] = (tmp1 * 2.0) * njac[i][1][3];\n      lhs[i][BB][2][3] = (tmp1 * 2.0) * njac[i][2][3];\n      lhs[i][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][3][3])) + ((tmp1 * 2.0) * dx4);\n      lhs[i][BB][4][3] = (tmp1 * 2.0) * njac[i][4][3];\n      lhs[i][BB][0][4] = (tmp1 * 2.0) * njac[i][0][4];\n      lhs[i][BB][1][4] = (tmp1 * 2.0) * njac[i][1][4];\n      lhs[i][BB][2][4] = (tmp1 * 2.0) * njac[i][2][4];\n      lhs[i][BB][3][4] = (tmp1 * 2.0) * njac[i][3][4];\n      lhs[i][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][4][4])) + ((tmp1 * 2.0) * dx5);\n      lhs[i][CC][0][0] = ((tmp2 * fjac[i + 1][0][0]) - (tmp1 * njac[i + 1][0][0])) - (tmp1 * dx1);\n      lhs[i][CC][1][0] = (tmp2 * fjac[i + 1][1][0]) - (tmp1 * njac[i + 1][1][0]);\n      lhs[i][CC][2][0] = (tmp2 * fjac[i + 1][2][0]) - (tmp1 * njac[i + 1][2][0]);\n      lhs[i][CC][3][0] = (tmp2 * fjac[i + 1][3][0]) - (tmp1 * njac[i + 1][3][0]);\n      lhs[i][CC][4][0] = (tmp2 * fjac[i + 1][4][0]) - (tmp1 * njac[i + 1][4][0]);\n      lhs[i][CC][0][1] = (tmp2 * fjac[i + 1][0][1]) - (tmp1 * njac[i + 1][0][1]);\n      lhs[i][CC][1][1] = ((tmp2 * fjac[i + 1][1][1]) - (tmp1 * njac[i + 1][1][1])) - (tmp1 * dx2);\n      lhs[i][CC][2][1] = (tmp2 * fjac[i + 1][2][1]) - (tmp1 * njac[i + 1][2][1]);\n      lhs[i][CC][3][1] = (tmp2 * fjac[i + 1][3][1]) - (tmp1 * njac[i + 1][3][1]);\n      lhs[i][CC][4][1] = (tmp2 * fjac[i + 1][4][1]) - (tmp1 * njac[i + 1][4][1]);\n      lhs[i][CC][0][2] = (tmp2 * fjac[i + 1][0][2]) - (tmp1 * njac[i + 1][0][2]);\n      lhs[i][CC][1][2] = (tmp2 * fjac[i + 1][1][2]) - (tmp1 * njac[i + 1][1][2]);\n      lhs[i][CC][2][2] = ((tmp2 * fjac[i + 1][2][2]) - (tmp1 * njac[i + 1][2][2])) - (tmp1 * dx3);\n      lhs[i][CC][3][2] = (tmp2 * fjac[i + 1][3][2]) - (tmp1 * njac[i + 1][3][2]);\n      lhs[i][CC][4][2] = (tmp2 * fjac[i + 1][4][2]) - (tmp1 * njac[i + 1][4][2]);\n      lhs[i][CC][0][3] = (tmp2 * fjac[i + 1][0][3]) - (tmp1 * njac[i + 1][0][3]);\n      lhs[i][CC][1][3] = (tmp2 * fjac[i + 1][1][3]) - (tmp1 * njac[i + 1][1][3]);\n      lhs[i][CC][2][3] = (tmp2 * fjac[i + 1][2][3]) - (tmp1 * njac[i + 1][2][3]);\n      lhs[i][CC][3][3] = ((tmp2 * fjac[i + 1][3][3]) - (tmp1 * njac[i + 1][3][3])) - (tmp1 * dx4);\n      lhs[i][CC][4][3] = (tmp2 * fjac[i + 1][4][3]) - (tmp1 * njac[i + 1][4][3]);\n      lhs[i][CC][0][4] = (tmp2 * fjac[i + 1][0][4]) - (tmp1 * njac[i + 1][0][4]);\n      lhs[i][CC][1][4] = (tmp2 * fjac[i + 1][1][4]) - (tmp1 * njac[i + 1][1][4]);\n      lhs[i][CC][2][4] = (tmp2 * fjac[i + 1][2][4]) - (tmp1 * njac[i + 1][2][4]);\n      lhs[i][CC][3][4] = (tmp2 * fjac[i + 1][3][4]) - (tmp1 * njac[i + 1][3][4]);\n      lhs[i][CC][4][4] = ((tmp2 * fjac[i + 1][4][4]) - (tmp1 * njac[i + 1][4][4])) - (tmp1 * dx5);\n    }\n\n    binvcrhs(lhs[0][BB], lhs[0][CC], rhs[k][j][0]);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      matvec_sub(lhs[i][AA], rhs[k][j][i - 1], rhs[k][j][i]);\n      matmul_sub(lhs[i][AA], lhs[i - 1][CC], lhs[i][BB]);\n      binvcrhs(lhs[i][BB], lhs[i][CC], rhs[k][j][i]);\n    }\n\n    matvec_sub(lhs[isize][AA], rhs[k][j][isize - 1], rhs[k][j][isize]);\n    matmul_sub(lhs[isize][AA], lhs[isize - 1][CC], lhs[isize][BB]);\n    binvrhs(lhs[isize][BB], rhs[k][j][isize]);\n    for (i = isize - 1; i >= 0; i--)\n    {\n      for (m = 0; m < BLOCK_SIZE; m++)\n      {\n        for (n = 0; n < BLOCK_SIZE; n++)\n        {\n          rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[i][CC][n][m] * rhs[k][j][i + 1][n]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) shared(isize) private(i,j,k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/x_solve/0"}
{"code": "for (int jj = internal_ystart; jj <= internal_ystop; jj++)\n{\n  for (int ji = internal_xstart; ji <= (internal_xstop - 1); ji++)\n  {\n    next_sshu_code(ji, jj, width, sshn_u, sshn_t, tmask, area_t, area_u);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/9"}
{"code": "for (int i = 0; i < height_local; i++)\n{\n  for (int j = 0; j < width_local; j++)\n  {\n    local[i + 1][j + 1] = local_input[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/v-pap/Game-of-Life-in-parallel-MPI-OpenMP-CUDA/src/game_openmp/6"}
{"code": "for (int codeIndex = 0; codeIndex < data->count; codeIndex++)\n{\n  free(data->dailys[codeIndex].start);\n  free(data->dailys[codeIndex].end);\n  free(data->dailys[codeIndex].max);\n  free(data->dailys[codeIndex].min);\n  free(data->dailys[codeIndex].volume);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pgostation/pstock/pstock/strMdata/6"}
{"code": "for (int k = 0; k < n; k++)\n{\n  R[k] = (double *) malloc(n * (sizeof(double)));\n  D[k] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/2"}
{"code": "for (i = 0; i < my_num_people; i++)\n{\n  days_infected[i] = 0;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/3"}
{"code": "for (int i = 0; i < subLength; ++i)\n  subString[i] = 'a' + (rand() % 26);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task5/0"}
{"code": "for (int i = 0; i < dimSize; ++i)\n{\n  arrayInitializer->append_expression(deepCopy(v_size[i]));\n  v_dimSize.push_back(deepCopy(v_size[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/passlab/rexompiler/src/midend/programTransformation/ompLowering/omp_lowering/4"}
{"code": "for (i = 0; i < (w * h); i++)\n{\n  if ((i % w) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\"%u \", imageArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrchowmein/Cuda_Comparison/openMPBlur/3"}
{"code": "for (int test = 0; test < nTests; test++)\n{\n  initWH(W, Htras, N, M, K);\n  niters = 2000 / NITER_TEST_CONV;\n  stop = 0;\n  iter = 0;\n  inc = 0;\n  while ((iter < niters) && (!stop))\n  {\n    iter++;\n    cpu_nmf(NITER_TEST_CONV, V, WH, W, Htras, Waux, Haux, acumm_W, acumm_H, N, M, K);\n    adjust_WH(W, Htras, N, M, K);\n    get_classification(Htras, classification, M, K);\n    diff = get_difference(classification, last_classification, M);\n    matrix_copy1D_uchar(classification, last_classification, M);\n    if (diff > 0)\n      inc = 0;\n    else\n      inc++;\n\n    if (verbose)\n      printf(\"iter=%i inc=%i number_changes=%i\\n\", iter * NITER_TEST_CONV, inc, 2 * diff);\n\n    if (inc > stop_threshold)\n      stop = 1;\n\n  }\n\n  get_consensus(classification, consensus, M);\n  error = get_Error(V, W, Htras, N, M, K);\n  if (error < error_old)\n  {\n    printf(\"Better W and H, Error %e Test=%i, Iter=%i\\n\", error, test, iter);\n    matrix_copy2D(W, W_best, N, K);\n    matrix_copy2D(Htras, Htras_best, M, K);\n    error_old = error;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artecs-group/nmf-openmp/src/main/20"}
{"code": "for (j = 1; j < (procCoords.y_cells_num - 1); j++)\n{\n  for (i = 1; i < (procCoords.x_cells_num - 1); i++)\n  {\n    delta_f[(j * procCoords.x_cells_num) + i] = (((f[(j * procCoords.x_cells_num) + i] - f[((j * procCoords.x_cells_num) + i) - 1]) - (f[((j * procCoords.x_cells_num) + i) + 1] - f[(j * procCoords.x_cells_num) + i])) / hx2) + (((f[(j * procCoords.x_cells_num) + i] - f[((j - 1) * procCoords.x_cells_num) + i]) - (f[((j + 1) * procCoords.x_cells_num) + i] - f[(j * procCoords.x_cells_num) + i])) / hy2);\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule (static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phonexicum/DHP-PE-RA-FDM/DHP_PE_RA_FDM/2"}
{"code": "for (int i = 0, e = IndentLevel + Delta; i < e; ++i)\n  OS << \"  \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/AST/StmtPrinter/0"}
{"code": "for (i = 0; i < letterData.attributesAmount; ++i)\n{\n  scalers.standarize(letterData.attributes.at(i));\n}\n\n", "pragma": "    #pragma omp parallel for shared(letterData) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/madadr/parallel-knn/OpenMP/Main/0"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/2"}
{"code": "for (i = 0; i < 16; i = j + i)\n  for (j = 0; j < 16; j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/33"}
{"code": "for (int ii = 0; ii < n; ii += block)\n{\n  for (int jj = 0; jj < n; jj += block)\n  {\n    for (int kk = 0; kk < n; kk += block)\n    {\n      do_block(n, a, b, c, unroll, block, ii, jj, kk);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(3) default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_simd_block/0"}
{"code": "for (size_t i = 0; i < ants.size(); ++i)\n{\n  ants[i].advance(phen, land, pos_food, pos_nest, cpteur);\n  new_pos[i] = ants[i].get_position();\n}\n\n", "pragma": "#pragma omp parallel for num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kai-zhang-er/maze_solver/project/ant_simu/0"}
{"code": "for (y = 0; y < buckets; y++)\n{\n  bins[y].B = malloc(bins[y].count * (sizeof(double)));\n  bins[y].place = y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hkominos/OpenMp_Lab/Bin_Packing/5"}
{"code": "for (int z = 0; z < 5; z++)\n{\n  int i = getRandomNumber() % chromo_length;\n  int j = getRandomNumber() % chromo_length;\n  int k = getRandomNumber() % (popl_size - ((20 * popl_size) / 100));\n  int temp = pop[((20 * popl_size) / 100) + k].genes[j];\n  pop[((20 * popl_size) / 100) + k].genes[j] = pop[((20 * popl_size) / 100) + k].genes[i];\n  pop[((20 * popl_size) / 100) + k].genes[i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/18"}
{"code": "for (int i = 0; i < a.nrow(); ++i)\n{\n  for (int j = 0; j < b.ncol(); ++j)\n  {\n    for (int ii = 0; ii < a.ncol(); ++ii)\n      ans.add(i, j, at(ii, i) * b(ii, j));\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/USCbiostats/r-parallel-benchmark/matrix/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    c[i] = a[i] + b[i];\n    if (c[i] > 10)\n    {\n      if (c[i] < 20)\n      {\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/51"}
{"code": "for (i = 0; i < Entries_N; i++)\n{\n  int j;\n  int pre_val = i * order;\n  double ans = 0;\n  int *cach1 = (int *) malloc((sizeof(int)) * order);\n  for (j = 0; j < order; j++)\n    cach1[j] = Indices[pre_val++];\n\n  for (j = 0; j < Core_N; j++)\n  {\n    double temp = CoreTensor[j];\n    int k;\n    int pos = j * order;\n    int val = 0;\n    for (k = 0; k < order; k++)\n    {\n      int mulrow = cach1[k];\n      int mulcol = CorePermu[pos++];\n      temp *= FactorM[(val + (mulrow * Core_dim)) + mulcol];\n      val += mult;\n    }\n\n    ans += temp;\n  }\n\n  free(cach1);\n  Error_T[i] -= ans;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/11"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  n = seqlen_array[si + 1];\n  for (i = 1, len1 = 0; i <= n; i++)\n  {\n    char c = seq_array[si + 1][i];\n    if ((c != gap_pos1) && (c != gap_pos2))\n      len1++;\n\n  }\n\n  for (sj = si + 1; sj < nseqs; sj++)\n  {\n    m = seqlen_array[sj + 1];\n    if ((n == 0) || (m == 0))\n    {\n      bench_output[(si * nseqs) + sj] = (int) 1.0;\n    }\n    else\n    {\n      _taskFunc0_((void *) 0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/alignment/src/alignment_ompi_trim/0"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    fprintf(result_file, \"%6.4f \", matrix_r[i][j]);\n  }\n\n  fprintf(result_file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritaly/OWS/Projekt2_MPI/matrix_gr4/2"}
{"code": "for (int i = 1; i < n; i++)\n{\n  double m = a[i] / b[i - 1];\n  b[i] = b[i] - (m * c[i - 1]);\n  v[i] = v[i] - (m * v[i - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/7"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/79"}
{"code": "for (i = 0; i < N; i++)\n{\n  arr[i] = rand() % N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iamAbhi-916/High-Performance-Computing-in-C/Bubble_Sort_using_openMp/1"}
{"code": "for (size_t i = l; i < r; i++)\n  sumx += arr[i];\n\n", "pragma": "             #pragma omp for simd reduction(+:sumx)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sand47/ME759-CUDA-Assignments/HW10/reduce/0"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  x[j] = norm_temp2 * z[j];\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/5"}
{"code": "for (int m = 0; m < dimensions; m++)\n{\n  for (int n = 0; n < dimensions; n++)\n  {\n    fscanf(f, \"%d\", &matrix[m][n]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sarabonardi/OpenMPCellGame/ompgame/4"}
{"code": "for (i = 0; i < reDim; i++)\n{\n  fwrite(matrix[i], sizeof(float), imDim, fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FrancoLeal/hpcLab2_OpenMP/funciones/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"Thread num = %d, i = %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/for_schedule/0"}
{"code": "for (unsigned int i = 1; i <= n; i++)\n{\n  for (unsigned int j = 1 + (i % 2); j <= n; j += 2)\n  {\n    x[j + ((n + 2) * i)] = (x0[j + ((n + 2) * i)] + (a * (((x[(j - 1) + ((n + 2) * i)] + x[(j + 1) + ((n + 2) * i)]) + x[j + ((n + 2) * (i - 1))]) + x[j + ((n + 2) * (i + 1))]))) / c;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo2a/solver/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; (j < l) && (search[j] == str[i + j]); j++)\n    ;\n\n  if (j == l)\n    return i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carmi94/ProgettoPP/period/4"}
{"code": "for (i = 0; i < totalIteraciones; i++)\n{\n  sum1 = sum1 + i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum1)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pabarcgar/pruebasOmp/sumaEnteros/sumaEnterosConParallelFor/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  work(i);\n  work(i + 1);\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.21.2/0"}
{"code": "for (i = ((-0x7fffffff) - 1) + 6; i > ((-0x7fffffff) - 1); i -= 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/14"}
{"code": "for (int i = 0; i < qsteps; i++)\n{\n  b[i] = Arg->B[q];\n  q++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ypatiapd/Parallel-and-distributed-systems/project1/sparse_openMP/5"}
{"code": "for (int i = 0; i < weights.size(); i++)\n{\n  for (int j = 0; j < weights[0].size(); j++)\n  {\n    backValues[i][j] = ((weights[i][j] * errors[i][j]) * max((double) 0, layerOutput[i][j])) * (1 - max((double) 0, layerOutput[i][j]));\n  }\n\n}\n\n", "pragma": "    #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/6"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1.0 / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i1][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i1][j][k] = fac2 * rhs[m][i1][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/47"}
{"code": "for (size_t i = 0; i < natoms; ++i)\n{\n  frame_com += atom_positions[i] * mass_list[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/22"}
{"code": "for (i = 0; i < a->size; i++)\n{\n  c += a->data[i] * b->data[i];\n}\n\n", "pragma": "omp parallel for schedule(static, 64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Helga-Helga/DataScience/lab5/main/0"}
{"code": "for (i = 0; i < N; i += 1)\n{\n  incx = i * incX;\n  incy = i * incY;\n  save = Y[incy];\n  Y[incy] = X[incx];\n  X[incx] = save;\n}\n\n", "pragma": "omp for schedule(static) private(save, incx, incy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/swap/1"}
{"code": "for (int i = 0; i < L; i++)\n{\n  for (int j = 0; j < L; j++)\n  {\n    if (uniform(rand) < p)\n    {\n      forest[i][j] = Green;\n    }\n    else\n    {\n      forest[i][j] = Empty;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kkaess/ForestFire/src/ForestFire/0"}
{"code": "for (currentColumn = 1; currentColumn < (subProblemSize[1] + 1); ++currentColumn)\n{\n  splitter[0][tempCounter] = 1;\n  splitter[1][tempCounter++] = currentColumn;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/7"}
{"code": "for (i = 0; (i < 4) && (i < N); i++)\n{\n  (((((((((((((cout << fixed) << \"A[\") << i) << \"] = \") << A[i]) << \"   B[\") << i) << \"] = \") << B[i]) << \"   C[\") << i) << \"] = \") << C[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/efti-nile/concurrent_computing/pc_lab1_omp/src/pc_lab_1_omp/2"}
{"code": "for (i = 0; i < counts.size(); i++)\n{\n  if (counts[i] == 0)\n  {\n    return 0;\n  }\n\n  total += counts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hafeezali/Parallel-Decision-Tree-Classifier/dtc_openmp/0"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    hist[rgb_image[(i * width) + j]]++;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) default(none) private (i,j) shared(height,width,rgb_image,hist) schedule(guided,1000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Xerewulf/Paralel_Programing/Project2/main/0"}
{"code": "for (j = 0; j <= 99; j += 1)\n{\n  temp = u[i][j];\n  error = error + (temp * temp);\n}\n\n", "pragma": "omp parallel for private (temp,j) reduction (+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_reduction_2/1"}
{"code": "for (int i = 0; i < (height * width); ++i)\n{\n  if (pixel_sizeof == 1)\n  {\n    data[i] = calc_norm(data[i], min_grey, max_grey);\n  }\n  else\n  {\n    data[i * pixel_sizeof] = calc_norm(data[i * pixel_sizeof], min_r, max_r);\n    data[(i * pixel_sizeof) + 1] = calc_norm(data[(i * pixel_sizeof) + 1], min_g, max_g);\n    data[(i * pixel_sizeof) + 2] = calc_norm(data[(i * pixel_sizeof) + 2], min_b, max_b);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(data, pixel_sizeof, max_grey, max_r, max_g, max_b, min_r, min_g, min_b) schedule(static) num_threads(threads_c)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FeggieBoss/OpenMP/src/main/1"}
{"code": "for (int i = 0; i < NB; i++)\n{\n  calc_v(i, F, BVK, Z, 1);\n  for (int j = 0; j < BS; j++)\n  {\n    if (equation == 0)\n      BVK[j] *= inv_dw_dh((1 + (i * BS)) + j);\n\n    Om[(1 + (i * BS)) + j] += Dg * BVK[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/87"}
{"code": "for (int i = 0; i < 100; i++)\n  sum = sum + i;\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/V6429/openmp_present/presentation/6.Loop_reduction/1"}
{"code": "for (i = 0; i < MAXDIM; i++)\n{\n  for (j = 0; j <= i; j++)\n  {\n    PTUpdateEntry(arr, i, j, (((j == 0) || (i == 0)) || (i == j)) ? (1) : (arr[i - 1][j] + arr[i - 1][j - 1]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sendevour/openmp-samples/fpt/0"}
{"code": "for (register int jj = 0; jj <= (count - 1); jj += 1)\n{\n  int idx = list[jj];\n  sum += tmp[list[jj]];\n}\n\n", "pragma": "omp parallel for reduction (+:sum) firstprivate (count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_accumulateForce/1"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  for (j = 0; j < Ny; j++)\n  {\n    fprintf(f5, \"%f %f %f %f \\n\\n \", x[i], y[j], u[i][j], r[i][j]);\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/9"}
{"code": "for (num_iter; num_iter < max_iter; num_iter++)\n{\n  X = ((x * x) - (y * y)) + a;\n  Y = ((2 * x) * y) + b;\n  z = sqrtf((x * x) + (y * y));\n  x = X;\n  y = Y;\n  if (z >= 2)\n  {\n    num_iter--;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/tp2_sujet/0"}
{"code": "for (int i = 0; i < 50; i++)\n  nums[i] = i;\n\n", "pragma": "#pragma omp parallel for private(i) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/woshildh/OpenMPLearning/parallel/parallel/2"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (cj = ci + 1; cj < NCELLS; cj++)\n  {\n    contactDistance = (lenscales.at(ci) + lenscales.at(cj)) + ((cell(ci).getl0() + cell(cj).getl0()) / 2);\n    centerDistance = 0.0;\n    for (d = 0; d < NDIM; d++)\n    {\n      distanceVec.at(d) = cell(ci).cellDistance(cell(cj), d);\n      centerDistance += pow(distanceVec.at(d), 2);\n    }\n\n    if ((contactDistance * contactDistance) > centerDistance)\n    {\n      addContact(ci, cj);\n      centerDistance = sqrt(centerDistance);\n      overlap = centerDistance / contactDistance;\n      ftmp = 1 - overlap;\n      utmp = (0.5 * contactDistance) * pow(1 - overlap, 2);\n      for (vi = 0; vi < cell(ci).getNV(); vi++)\n        cell(ci).setUInt(vi, cell(ci).uInt(vi) + (utmp / cell(ci).getNV()));\n\n      for (vi = 0; vi < cell(cj).getNV(); vi++)\n        cell(cj).setUInt(vi, cell(cj).uInt(vi) + (utmp / cell(cj).getNV()));\n\n      for (d = 0; d < NDIM; d++)\n      {\n        uv = distanceVec.at(d) / centerDistance;\n        cell(ci).setCForce(d, cell(ci).cforce(d) - (ftmp * uv));\n        cell(cj).setCForce(d, cell(cj).cforce(d) + (ftmp * uv));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/76"}
{"code": "for (int i = 1; i < k; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    n_cells[task_id] = ((long) genes_length[i]) * genes_length[j];\n    total_cells += n_cells[task_id];\n    task_id++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing5/test/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++r;\n}\n\n", "pragma": "#pragma omp for reduction(+ : r)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/task_messages/2"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  Cut_off_Ellipsoid.nM[i][i] = aux;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/6"}
{"code": "for (k = 0; k < d3; k++)\n{\n  for (j = 0; j < d2; j++)\n  {\n    for (i = 0; i < d1; i++)\n    {\n      u0[k][j][i] = dcomplex_mul2(u0[k][j][i], twiddle[k][j][i]);\n      u1[k][j][i] = u0[k][j][i];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/8"}
{"code": "for (int j = 0; j < n; j++)\n{\n  result2[i][j] = 0;\n  for (int k = 0; k < m; k++)\n  {\n    result2[i][j] += matrix1[i][k] * matrix2[k][j];\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_4/4/2"}
{"code": "for (k = 0; k < MINIBATCH; k++)\n{\n  for (i = 0; i < hN; i++)\n  {\n    errtemp = 0.0;\n    for (j = 0; j < outN; j++)\n      errtemp += out_delta[k][j] * wout[i][j];\n\n    h_delta[k][i] = (errtemp * hidden[k][i]) * (1.0 - hidden[k][i]);\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchParallel/13"}
{"code": "for (i = 0; i < num_buckets; i++)\n{\n  threadCounts[thread_num][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sort/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    C[(i * N) + j] = 0;\n    for (int k = 0; k < N; k++)\n      C[(i * N) + j] += A[(i * N) + k] * B[(k * N) + j];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RahimACM/matrix-multiplication-optimization/matrix_multiplication/2"}
{"code": "for (j = 1 << (l - 1); j <= ((1 << l) - 1); j++)\n{\n  if ((j % 2) == 0)\n  {\n    b->tab[j] = b->tab[j / 2];\n  }\n  else\n  {\n    b->tab[j] = b->tab[j / 2] + a->tab[j - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/3"}
{"code": "for (long i = 0; i < 6; i++)\n{\n  for (int u = 0; u < 100000000; u++)\n  {\n    result++;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,3) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/a/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"%f\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/openmp/2"}
{"code": "for (i = 0; i < (N / 2); i++)\n{\n  column[i + ((s * N) / 2)] = merge2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/11"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  for (size_t j = 0; j < n; j++)\n  {\n    fscanf(fileA, \"%lf\", &A[i][j]);\n    L[i][j] = 0;\n    U[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JaiJaveria/Parallel_Crout_Decomposition/crout/5"}
{"code": "for (i = 0; i < (DIM - 1); i++)\n{\n  tmp += super[i] * simple[i];\n  moving_average = 0;\n  for (ton = i; ton < ((DIM - 1) - WINDOW_SIZE); ton++)\n  {\n    moving_average += simple[ton];\n  }\n\n}\n\n", "pragma": "omp for lastprivate(i, moving_average)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/exojosh/OpenMP-Parallel-Threading-Practice/parallel/1"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    printf(\"%d\\t\", b[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/MatricesCREW/9"}
{"code": "for (i = 0; i < size; ++i)\n{\n  ((cout << array[i]) << \" \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_quicksort/run/1"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  randA[i] = rand() % 1000;\n  randB[i] = rand() % 100;\n  randC[i] = (rand() % 10) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/loop_optimizations/0"}
{"code": "for (int ii = 0; ii < (BLOCKROWS * BLOCKCOLS); ii++)\n  b1[ii] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Cannon's Algorithm/MPI_OpenMp/5"}
{"code": "for (i = 0; i < 128; i++)\n{\n  x[(i / 64) - 1][i % 3][(i / 4) & 1].t += i;\n  if ((i & 15) == 1)\n    y[1].t *= 3;\n\n  if ((i & 31) == 2)\n    y[2].t *= 7;\n\n  if ((i & 63) == 3)\n    y[3].t *= 17;\n\n  z[(i / 32) + 2].t += i & 3;\n  if (i < 4)\n    z[i + 2].t += i;\n\n  a[(i / 32) + 2].t |= 1ULL << (i & 30);\n  w[0][i & 1].t &= ~(1L << ((i / 17) * 3));\n  if ((i % 23) > b[2])\n    b[2] = i % 23;\n\n  if ((i % 85) > b[3])\n    b[3] = i % 85;\n\n  if ((i % 192) > b[4])\n    b[4] = i % 192;\n\n}\n\n", "pragma": "omp parallel for reduction(+:x[-1:2][:][0:2], z[t + 2:4]) reduction(*:y[-s:3]) reduction(|:a[s + 3:4]) reduction(&:w[s + 1:1][t:2]) reduction(maxb:b[2:])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-12/0"}
{"code": "for (int i = 0; i < n1; i++)\n{\n  L[i] = arr[l + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akarsh3007/Parallel-Computing/Assignment-4/openmp/mergesort/0"}
{"code": "for (j = data->iRowFirst + 1; j <= (data->iRowLast - 1); j++)\n{\n  for (i = data->iColFirst + 1; i <= (data->iColLast - 1); i++)\n  {\n    fLRes = ((((ax * (uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + ((i - 1) - data->iColFirst)] + uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + ((i + 1) - data->iColFirst)])) + (ay * (uold[(((j - 1) - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] + uold[(((j + 1) - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)]))) + (b * uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)])) - afF[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)]) / b;\n    afU[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] = uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] - (data->fRelax * fLRes);\n    residual += fLRes * fLRes;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, i, fLRes) reduction(+:residual)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KevinMTO/Helmholtz-ACC/cart/advanced/0"}
{"code": "for (int j = 0; j < NUMHID; j++)\n{\n  for (int k = 0; k < NUMOUT; k++)\n  {\n    SumDOW += WeightHO[k][j] * DeltaO[k];\n  }\n\n  DeltaH[j] = (SumDOW * Hidden[j]) * (1.0 - Hidden[j]);\n  for (int i = 0; i < NUMIN; i++)\n    DeltaWeightIH[j][i] = ((eta * tSet[p][i]) * DeltaH[j]) + (alpha * DeltaWeightIH[j][i]);\n\n  SumDOW = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Raptorino/NeuralNetworkMIMD/Code_OpenMP/nn-main/3"}
{"code": "for (i = 1; i < (51 - 1); ++i)\n{\n  ch = ciphertext[i];\n  if (((!isalnum(ch)) && (ch != '+')) && (ch != '/'))\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/13"}
{"code": "for (int i = 0; i < grid_size; i++)\n{\n  for (int j = 0; j < grid_size; j++)\n  {\n    cell_t *cell = &cells[i][j];\n    for (int k = 1; k < num_threads; k++)\n    {\n      cell_t *thread_cell = &cells_threads[k][i][j];\n      cell->mass_sum += thread_cell->mass_sum;\n      cell->center_of_mass.x += thread_cell->center_of_mass.x;\n      cell->center_of_mass.y += thread_cell->center_of_mass.y;\n    }\n\n    if (cell->mass_sum != 0)\n    {\n      cell->center_of_mass.x /= cell->mass_sum;\n      cell->center_of_mass.y /= cell->mass_sum;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/openmp/simpar-omp/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    int sum = 0;\n    for (k = 0; k < 1000; k++)\n    {\n      sum += matrizA[i][k] * matrizB[k][j];\n    }\n\n    matrizC[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Felcks/matriz_openmp/MainP/0"}
{"code": "for (i = 0; i < townsNo; i++)\n{\n  swap(child1->townsOrder[i], townsOrder[i]);\n  swap(child2->townsOrder[i], parent->townsOrder[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/8"}
{"code": "for (j = 1; j <= ndelta; j++)\n{\n  for (k = 0; k <= nly; k++)\n  {\n    w_gpu[(k * ndelta) + j] = w[k][j];\n    oldw_gpu[(k * ndelta) + j] = oldw[k][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/backprop/src/backprop/4"}
{"code": "for (int j = 0; j < dim; j++)\n{\n  tmpd = *((X + (a * dim)) + j);\n  *((X + (a * dim)) + j) = *((X + (b * dim)) + j);\n  *((X + (b * dim)) + j) = tmpd;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/angrammenos97/VP_Tree/vptree/2"}
{"code": "for (j = 0; j < limit; j++)\n{\n  nMis = 0;\n  for (i = 0; i < n; i++)\n  {\n    afterSign = sign(f(o.w, pointsArr[i]));\n    error = pointsArr[i].groupIdentifier - afterSign;\n    if (!(error == 0))\n    {\n      nMis += 1;\n      algorithmTraining(k, pointsArr[i], o.w, *alpha, pointsArr[i].groupIdentifier, t);\n    }\n\n  }\n\n  q = ((double) nMis) / ((double) n);\n  if ((q < (*qc)) && (q < o.q))\n  {\n    o.q = q;\n    o.t = t;\n    return o;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/PerceptronAlgorithm/3"}
{"code": "for (long v = 0; v < NV; v++)\n{\n  long adj1 = vtxPtr[v];\n  long adj2 = vtxPtr[v + 1];\n  for (long j = adj1; j < adj2; j++)\n  {\n    long w = vtxInd[j].tail;\n    if ((Volts[v] == myVolt) && (Volts[w] == myVolt))\n    {\n      printf(\"%ld %ld %ld\\n\", v + 1, w + 1, Volts[v]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/15"}
{"code": "for (int i = 0; i < Nt; ++i)\n  test(0, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_openmp/7"}
{"code": "for (int x = 0; x < BOID_SEGMENTS_PER_DIM; x++)\n{\n  for (int y = 0; y < BOID_SEGMENTS_PER_DIM; y++)\n  {\n    for (int z = 0; z < BOID_SEGMENTS_PER_DIM; z++)\n    {\n      ComputeBoidsSteering(ivec3(x, y, z));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(3) schedule(nonmonotonic:dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/4"}
{"code": "for (i = 0; i < (series->count - window); i++)\n{\n  MA_data[i + window] = var_mean(series->data, i, i + window);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/9"}
{"code": "for (int i = 0; i < matr_A.row; i++)\n{\n  for (int j = 0; j < matr_Bt.row; j++)\n  {\n    for (int k = 0; k < matr_A.col; k++)\n    {\n      matr_C.tab[i][j] += matr_A.tab[i][k] * matr_Bt.tab[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/0"}
{"code": "for (long p = 0; p < passos; p++)\n{\n  jogo();\n  antigoTabuleiro = tabuleiro;\n  tabuleiro = novoTabuleiro;\n  novoTabuleiro = antigoTabuleiro;\n  printTabuleiro(tabuleiro);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/novo_jogo_da_vida/jogo/7"}
{"code": "for (int i = 0; i < k; i++)\n{\n  copy_point(points[i], medoids[i]);\n  copy_point(points[i], best_medoids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/treyvian/Kmeans-with-OpenMP/src/kmedoids/kmedoids/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    m[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joeladams/patternlets/patternlets/openMP/11.private/private/0"}
{"code": "for (i = j; i < 1; ++i)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr25996/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  sum = sum + A[i];\n  printf(\"A[%d]: %d\\n\", i, A[i]);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gapgag55/OpenMP-Excercise/2.SumReductionClause/openmp/0"}
{"code": "for (i = 0, th_id = 0; i < num_thd; i++, th_id++)\n{\n  for (i = 1; i <= (num_step / num_thd); i++)\n  {\n    x = (i - .5) * step;\n    sum += 4 / (1.0 + (x * x));\n    printf(\"\\n sum %d:%lf\\tID:%d\", i, sum, th_id);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(sum,x) private(i,th_id) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/parallel_pi_org/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * ((u[i][j][k - 2][m_imopVar133] - (4.0 * u[i][j][k - 1][m_imopVar133])) + (5.0 * u[i][j][k][m_imopVar133])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/74"}
{"code": "for (int i = 0; i < 15; ++i)\n{\n  for (int i = 0; i < 15; ++i)\n  {\n    printf(\"%d  \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mayraju/openmp/mat/0"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  a[i][j] += 1;\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB096-doall2-taskloop-collapse-orig-no/0"}
{"code": "for (i = 2; i < xcell; i++)\n  for (j = 2; j < ycell; j++)\n  u[1 - iz][i][j] = (u[iz][i][j] + (0.1 * ((u[iz][i + 1][j] + u[iz][i - 1][j]) - (2.0 * u[iz][i][j])))) + (0.1 * ((u[iz][i][j + 1] + u[iz][i][j - 1]) - (2.0 * u[iz][i][j])));\n\n\n", "pragma": "omp parallel for schedule(static,1) collapse(2) default(none) private(i,j) shared (u, iz, xcell, ycell)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/7"}
{"code": "for (int i = 2; i < 2000000; i++)\n{\n  if (isprime(i))\n  {\n    sum += i;\n  }\n\n  if ((i % 50000) == 0)\n  {\n    printf(\"we are at this point %d\\n\", i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex10projecteuler/2"}
{"code": "for (j = nxs; j < nx; j++)\n{\n  fxy[(2 * j) + ((2 * nxe) * ny)] = fxy[2 * j];\n  fxy[(1 + (2 * j)) + ((2 * nxe) * ny)] = fxy[1 + (2 * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/ssempush2/8"}
{"code": "for (i = 0; i < N; i++)\n  tab[i] = ((double) rand()) / ((double) 32767);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrycz/c-parallel-programming/openmp/openmp_bucket_sort/3"}
{"code": "for (i = 0; i < n; i++)\n  rank[index[i]] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/7"}
{"code": "for (int f = 0; f < feat1; f++)\n{\n  for (int i = 0; i < 3; i++)\n  {\n    for (int j = 0; j < 11; j++)\n    {\n      for (int k = 0; k < 11; k++)\n      {\n        kernel11[f][i][j][k] = distr(gen);\n        kernel12[f][i][j][k] = distr(gen);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/4"}
{"code": "for (int i = 1; i <= 10; i++)\n{\n  printf(\"Hola %d - %li\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eisten1996/OpenMP/semana02/eje02/eje02/0"}
{"code": "for (int i = 0; i < w; ++i)\n{\n  for (int j = 0; j < h; ++j)\n  {\n    printf(\"%f \", mat[(i * w) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/korgan00/openmpi-and-openmp-project/main/0"}
{"code": "for (unsigned int gen = 0; gen < times; gen++)\n  next_gen(nodes, (((PSO_MAX_W - PSO_MIN_W) * (times - gen)) / times) + PSO_MIN_W);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/imhele/pso-openmp/main/0"}
{"code": "for (int j = 0; j < d; j++)\n{\n  float sum = 0;\n  for (int i = 0; i < n; i++)\n    sum += score[i] * value[(i * d) + j];\n\n  output[j] = sum;\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/attention-omp/main/1"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  OMPVV_TEST_AND_SET(errors, a[i] != 10);\n  OMPVV_TEST_AND_SET(errors, b[i] != 11);\n  OMPVV_TEST_AND_SET(errors, c[i] != 12);\n  OMPVV_TEST_AND_SET(errors, d[i] != ((((1 + i) + 50) * 2) * i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_map_tofrom/0"}
{"code": "for (int tt = 0; tt < params.maxIters; tt += 2)\n{\n  accelerate_flow_1(params, cells, obstacles, accelerating_row);\n  timestep_1(params, tot_cells, cells, obstacles, av_vels, tt, neighbours, sendbuf, recvbuf);\n  accelerate_flow_2(params, cells, obstacles, accelerating_row);\n  timestep_2(params, tot_cells, cells, obstacles, av_vels, tt + 1, neighbours, sendbuf, recvbuf);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/1"}
{"code": "for (int i = 0; i < ((stringExample.length() - substringExample.length()) + 1); i++)\n{\n  int count = 0;\n  for (int j = 0; j < substringExample.length(); j++)\n  {\n    if (stringExample[i + j] != substringExample[j])\n    {\n      break;\n    }\n\n    count++;\n  }\n\n  if (count == substringExample.length())\n  {\n    result1 = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_7/7/0"}
{"code": "for (itr = 100; itr <= 10000000; itr *= 10)\n{\n  int tm = 0;\n  while (tm < 2)\n  {\n    if (itr != 1)\n      itr /= 2;\n\n    printf(\"ITR EQUALS TO %d\\n\", itr);\n    wisomp3();\n    wisomp2();\n    wisomp1();\n    wisomp();\n    if (itr != 1)\n      itr *= 2;\n\n    printf(\"ITR EQUALS TO %d\\n\", itr);\n    wisomp3();\n    wisomp2();\n    wisomp1();\n    wisomp();\n    tm++;\n  }\n\n  cnt++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wang-shihao/openMP/helloSPI/0"}
{"code": "for (int j = 0; j < n; j++)\n{\n  temp[i] = (A[(i * n) + j] * p[j]) + temp[i];\n}\n\n", "pragma": "omp parallel for reduction(+ : temp[i])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/5"}
{"code": "for (uint32_t i = 0; i < vertex_num; i++)\n{\n  Poly_Rect_begin.push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/8"}
{"code": "for (i = 0; i < dim_cpu.boxes1d_arg; i++)\n{\n  for (j = 0; j < dim_cpu.boxes1d_arg; j++)\n  {\n    for (k = 0; k < dim_cpu.boxes1d_arg; k++)\n    {\n      box_cpu[nh].x = k;\n      box_cpu[nh].y = j;\n      box_cpu[nh].z = i;\n      box_cpu[nh].number = nh;\n      box_cpu[nh].offset = nh * 100;\n      box_cpu[nh].nn = 0;\n      for (l = -1; l < 2; l++)\n      {\n        for (m = -1; m < 2; m++)\n        {\n          for (n = -1; n < 2; n++)\n          {\n            if (((((((i + l) >= 0) && ((j + m) >= 0)) && ((k + n) >= 0)) == 1) && (((((i + l) < dim_cpu.boxes1d_arg) && ((j + m) < dim_cpu.boxes1d_arg)) && ((k + n) < dim_cpu.boxes1d_arg)) == 1)) && ((((l == 0) && (m == 0)) && (n == 0)) == 0))\n            {\n              box_cpu[nh].nei[box_cpu[nh].nn].x = k + n;\n              box_cpu[nh].nei[box_cpu[nh].nn].y = j + m;\n              box_cpu[nh].nei[box_cpu[nh].nn].z = i + l;\n              box_cpu[nh].nei[box_cpu[nh].nn].number = (((box_cpu[nh].nei[box_cpu[nh].nn].z * dim_cpu.boxes1d_arg) * dim_cpu.boxes1d_arg) + (box_cpu[nh].nei[box_cpu[nh].nn].y * dim_cpu.boxes1d_arg)) + box_cpu[nh].nei[box_cpu[nh].nn].x;\n              box_cpu[nh].nei[box_cpu[nh].nn].offset = box_cpu[nh].nei[box_cpu[nh].nn].number * 100;\n              box_cpu[nh].nn = box_cpu[nh].nn + 1;\n            }\n\n          }\n\n        }\n\n      }\n\n      nh = nh + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lavaMD/OneFile/3"}
{"code": "for (int i = 0; i < N; i++)\n  short_dis[i] = (int *) malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/1"}
{"code": "for (size_t i = 0; i < (arguments.buffer_size_kb * 128); i++)\n{\n  float_buffer[i] = 1.1f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-programming-hwr/benchmark-openMP/main/2"}
{"code": "for (int j = 0; j < nCols; ++j)\n{\n  t[j] = (saturate_cast < uchar) > (p[j] + (weight * q[j]));\n}\n\n", "pragma": "\t\t#pragma omp parallel for shared(inputImage1, inputImage2, outputImage, weight) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/batuhanhangun/MSc-Thesis/CPU Implementation/OpenCV + OpenMP Implementation/main/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    zeta = ((double) k) * dnzm1;\n    for (j = 0; j < grid_points[1]; j++)\n    {\n      eta = ((double) j) * dnym1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[j][m] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m <= 4; m++)\n      {\n        buf[j][m] = dtpp * dtemp[m];\n      }\n\n      cuf[j] = buf[j][2] * buf[j][2];\n      buf[j][0] = (cuf[j] + (buf[j][1] * buf[j][1])) + (buf[j][3] * buf[j][3]);\n      q[j] = 0.5 * (((buf[j][1] * ue[j][1]) + (buf[j][2] * ue[j][2])) + (buf[j][3] * ue[j][3]));\n    }\n\n    for (j = 1; j < (grid_points[1] - 1); j++)\n    {\n      jm1 = j - 1;\n      jp1 = j + 1;\n      forcing[i][j][k][0] = (forcing[i][j][k][0] - (ty2 * (ue[jp1][2] - ue[jm1][2]))) + (dy1ty1 * ((ue[jp1][0] - (2.0 * ue[j][0])) + ue[jm1][0]));\n      forcing[i][j][k][1] = ((forcing[i][j][k][1] - (ty2 * ((ue[jp1][1] * buf[jp1][2]) - (ue[jm1][1] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][1] - (2.0 * buf[j][1])) + buf[jm1][1]))) + (dy2ty1 * ((ue[jp1][1] - (2.0 * ue[j][1])) + ue[jm1][1]));\n      forcing[i][j][k][2] = ((forcing[i][j][k][2] - (ty2 * (((ue[jp1][2] * buf[jp1][2]) + (c2 * (ue[jp1][4] - q[jp1]))) - ((ue[jm1][2] * buf[jm1][2]) + (c2 * (ue[jm1][4] - q[jm1])))))) + (yycon1 * ((buf[jp1][2] - (2.0 * buf[j][2])) + buf[jm1][2]))) + (dy3ty1 * ((ue[jp1][2] - (2.0 * ue[j][2])) + ue[jm1][2]));\n      forcing[i][j][k][3] = ((forcing[i][j][k][3] - (ty2 * ((ue[jp1][3] * buf[jp1][2]) - (ue[jm1][3] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][3] - (2.0 * buf[j][3])) + buf[jm1][3]))) + (dy4ty1 * ((ue[jp1][3] - (2.0 * ue[j][3])) + ue[jm1][3]));\n      forcing[i][j][k][4] = ((((forcing[i][j][k][4] - (ty2 * ((buf[jp1][2] * ((c1 * ue[jp1][4]) - (c2 * q[jp1]))) - (buf[jm1][2] * ((c1 * ue[jm1][4]) - (c2 * q[jm1])))))) + ((0.5 * yycon3) * ((buf[jp1][0] - (2.0 * buf[j][0])) + buf[jm1][0]))) + (yycon4 * ((cuf[jp1] - (2.0 * cuf[j])) + cuf[jm1]))) + (yycon5 * ((buf[jp1][4] - (2.0 * buf[j][4])) + buf[jm1][4]))) + (dy5ty1 * ((ue[jp1][4] - (2.0 * ue[j][4])) + ue[jm1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = 1;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[j][m]) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n      j = 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[j - 1][m]) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      for (j = 1 * 3; j <= ((grid_points[1] - (3 * 1)) - 1); j++)\n      {\n        forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      j = grid_points[1] - 3;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])));\n      j = grid_points[1] - 2;\n      forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (5.0 * ue[j][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(m, j, k, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/20"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  int value = 1;\n  for (int j = 0; j < power; ++j)\n  {\n    value *= this->vec_[i];\n  }\n\n  this->vec_[i] = value;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/46"}
{"code": "for (i = 0; i < n; i++)\n{\n  part_sum += A[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  tester[i] = rand() % K;\n  serial_ans[i] = 0;\n  omp_ans[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/7"}
{"code": "for (j = 0; j < total_num_to_restart; j++)\n{\n  {\n    printf(\"Global ID: %d\\n\", *(all_cont_process_idPtr + j));\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/5"}
{"code": "for (int i = 0; i < (20 / 4); i++)\n{\n  printf(\"%d\\n\", hist_array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulwankhede/OpenMP/parallel_histogram/4"}
{"code": "for (i = 0; i < constraint_num; i++)\n{\n  if (standard_simplex_tableau[i][max.index] > 0.0)\n  {\n    simplex_pivot1 = standard_simplex_tableau[i][column_num] / standard_simplex_tableau[i][max.index];\n    if (min.value > simplex_pivot1)\n    {\n      min.value = simplex_pivot1;\n      min.index = i;\n    }\n\n  }\n  else\n    count++;\n\n}\n\n", "pragma": "#pragma omp for reduction(+         \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arkaprabha10/Simplex-Algorithm/Algorithm/openmp_final/1"}
{"code": "for (i = 0; i < s; i++)\n{\n  x[i] = rand() / 32768.0;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/cg/7"}
{"code": "for (int i = 1; i <= m_nSubbsns; i++)\n{\n  m_sedtoCh[i] += tmp_sed2ch[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/IUH_SED_OL/IUH_SED_OL/5"}
{"code": "for (int i = 0; i < count; i++)\n{\n  if (arr1[i][0] != arr2[i][0])\n  {\n    errorFound = true;\n    errorsCount++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brelok-the-pok/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/BruteForceMatcherWithOpenMP/1"}
{"code": "for (x = 0; x < block_height; x++)\n{\n  for (y = 0; y < block_width; y++)\n  {\n    block[(((next_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] = ((((((alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + (x * (block_width + 2))) + (y + 1)]) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 2) * (block_width + 2))) + (y + 1)])) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + y])) + (alpha * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 2)])) + ((1.0 - (4.0 * alpha)) * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)])) * (1 - block_border[(((next_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)])) + (block_border[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] * block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)]);\n    local_converged = local_converged && (fabs(block[(((prev_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)] - block[(((current_buffer * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + (y + 1)]) > epsilon);\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, y) collapse(2) reduction(&&: local_converged)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MehdiHALA/Mpi-x-project/src/stencil_all/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])) + ue[m][j + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,dssp ,m ,i ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/26"}
{"code": "for (i = 0; i < 50; i++)\n{\n  findMax(arr);\n  findMin(arr);\n  multiply(arr);\n  findDesviacion(arr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio8/ejercicio8Paralelo2/0"}
{"code": "for (int i = 0; i < iYmaxG; i++)\n  for (int j = 0; j < iXmaxG; j++)\n  fwrite(colors[i][j], 1, 3, fp);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/3/fractal/1"}
{"code": "for (unsigned long int i = 0; i < 1024; ++i)\n  newArray[i] = arr[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivaneduardomv/OpenMPTest/ompArrayCopy/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n    printf(\"%f \", A[(i * n) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaoziyu/Parallel-Programming/OpenMP/omp_mat_vect_mult/1"}
{"code": "for (l = 0; l < 144; ++l)\n  if (((a[l] != l) || (b[l] != l)) || (c[l] != l))\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/27"}
{"code": "for (i = 1 + ((((id + 1) * m_size) / p) - 1); i >= (1 + ((id * m_size) / p)); i--)\n{\n  hyp.num = i;\n  insert_head(work, hyp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/4"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    temp[i][j].rgbRed = image[i][j].rgbRed;\n    temp[i][j].rgbGreen = image[i][j].rgbGreen;\n    temp[i][j].rgbBlue = image[i][j].rgbBlue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/0"}
{"code": "for (c1 = (((ni > nj) ? (ni) : (nj)) > nm) ? ((ni > nj) ? (ni) : (nj)) : (nm); c1 <= (nk + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/23"}
{"code": "for (int i = 0; i < n; i += 1)\n{\n  x = a + (i * dx);\n  integral += 4 * sqrt(1 - (x * x));\n}\n\n", "pragma": "#pragma omp parallel for reduction (+:integral)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/Integral/Integral/Integral/0"}
{"code": "for (int i = 0; i < (rows * columns); i++)\n{\n  h_assignments[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/caste9612/kmeans/src/ompKmeans/3"}
{"code": "for (size_t i = 0; i < 100; i++)\n  d[i] = a[i] + c[i];\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CHOUAKIsalim/Exemples-OpenMP/schedule-static-nowait/1"}
{"code": "for (i = 1; i < (512 + 1); i++)\n{\n  for (j = 1; j < (512 + 1); j++)\n  {\n    data[(i * (512 + 1)) + j] = (((DATA_TYPE) i) * j) / 512;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/COVAR/covariance/7"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n  }\n\n  lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(m ,k ,fac1 ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/175"}
{"code": "for (i__ = 1; i__ <= i__1; ++i__)\n{\n  y[iy] = (*beta) * y[iy];\n  iy += *incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/37"}
{"code": "for (i = 0; i < nvtxs; i++)\n{\n  if ((v = gk_i32pqGetTop(queue)) == (-1))\n    gk_errexit(SIGERR, \"The priority queue got empty ahead of time [i=%d].\\n\", i);\n\n  if (perm[v] != (-1))\n    gk_errexit(SIGERR, \"The perm[%d] has already been set.\\n\", v);\n\n  perm[v] = i;\n  for (j = xadj[v]; j < xadj[v + 1]; j++)\n  {\n    u = adjncy[j];\n    if (perm[u] == (-1))\n    {\n      degrees[u]++;\n      minIDs[u] = (i < minIDs[u]) ? (i) : (minIDs[u]);\n      switch (type)\n      {\n        case 1:\n          gk_i32pqUpdate(queue, u, 1);\n          break;\n\n        case 2:\n          gk_i32pqUpdate(queue, u, degrees[u]);\n          break;\n\n        case 3:\n          for (k = 0, jj = xadj[u]; jj < xadj[u + 1]; jj++)\n        {\n          if (perm[adjncy[jj]] != (-1))\n            k += perm[adjncy[jj]];\n\n        }\n\n          gk_i32pqUpdate(queue, u, k);\n          break;\n\n        case 4:\n          for (k = 0, jj = xadj[u]; jj < xadj[u + 1]; jj++)\n        {\n          if (perm[adjncy[jj]] != (-1))\n            k += i - perm[adjncy[jj]];\n\n        }\n\n          gk_i32pqUpdate(queue, u, k);\n          break;\n\n        default:\n          ;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/8"}
{"code": "for (i = iend; i >= ist; i--)\n{\n  if (i != iend)\n  {\n    while (flag[i + 1] == 0)\n    {\n      ;\n    }\n\n  }\n\n  if (i != ist)\n  {\n    while (flag[i] == 1)\n    {\n      ;\n    }\n\n  }\n\n  for (j = jend; j >= jst; j--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[i][j][m] = tv[i][j][m] + (omega * ((((((((((udy[i][j][m][0] * v[i][j + 1][k][0]) + (udx[i][j][m][0] * v[i + 1][j][k][0])) + (udy[i][j][m][1] * v[i][j + 1][k][1])) + (udx[i][j][m][1] * v[i + 1][j][k][1])) + (udy[i][j][m][2] * v[i][j + 1][k][2])) + (udx[i][j][m][2] * v[i + 1][j][k][2])) + (udy[i][j][m][3] * v[i][j + 1][k][3])) + (udx[i][j][m][3] * v[i + 1][j][k][3])) + (udy[i][j][m][4] * v[i][j + 1][k][4])) + (udx[i][j][m][4] * v[i + 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    tv[i][j][1] = tv[i][j][1] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][3] * tmp);\n    tv[i][j][4] = tv[i][j][4] / tmat[4][4];\n    tv[i][j][3] = tv[i][j][3] - (tmat[3][4] * tv[i][j][4]);\n    tv[i][j][3] = tv[i][j][3] / tmat[3][3];\n    tv[i][j][2] = (tv[i][j][2] - (tmat[2][3] * tv[i][j][3])) - (tmat[2][4] * tv[i][j][4]);\n    tv[i][j][2] = tv[i][j][2] / tmat[2][2];\n    tv[i][j][1] = ((tv[i][j][1] - (tmat[1][2] * tv[i][j][2])) - (tmat[1][3] * tv[i][j][3])) - (tmat[1][4] * tv[i][j][4]);\n    tv[i][j][1] = tv[i][j][1] / tmat[1][1];\n    tv[i][j][0] = (((tv[i][j][0] - (tmat[0][1] * tv[i][j][1])) - (tmat[0][2] * tv[i][j][2])) - (tmat[0][3] * tv[i][j][3])) - (tmat[0][4] * tv[i][j][4]);\n    tv[i][j][0] = tv[i][j][0] / tmat[0][0];\n    v[i][j][k][0] = v[i][j][k][0] - tv[i][j][0];\n    v[i][j][k][1] = v[i][j][k][1] - tv[i][j][1];\n    v[i][j][k][2] = v[i][j][k][2] - tv[i][j][2];\n    v[i][j][k][3] = v[i][j][k][3] - tv[i][j][3];\n    v[i][j][k][4] = v[i][j][k][4] - tv[i][j][4];\n  }\n\n  if (i != iend)\n    flag[i + 1] = 0;\n\n  if (i != ist)\n    flag[i] = 1;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/7"}
{"code": "for (k = 0; delta > eps; n *= 2, k ^= 1)\n{\n  double h = (b - a) / n;\n  double s = 0.0;\n  for (int i = 0; i < n; i++)\n    s += func(a + (h * (i + 0.5)));\n\n  sq[k] = s * h;\n  if (n > n0)\n    delta = fabs(sq[k] - sq[k ^ 1]) / 3.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NievinEvgeny/Average-rectangles-integration/Integration/0"}
{"code": "for (size_t i = 0; i < num_of_organisms; i++)\n{\n  organism_update(&env.grid[i]);\n}\n\n", "pragma": "omp parallel for num_threads(num_threads) schedule(static, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/1"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  x_n[i] = x_n1[i];\n}\n\n", "pragma": "#pragma omp parallel for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/9"}
{"code": "for (i = 0; i < 512; i++)\n  dot += X[i] * Y[i];\n\n", "pragma": "omp parallel for schedule(static) reduction (+:dot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  z.arr[i] = arr[i] * k.arr[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector0/2"}
{"code": "for (int i = 0; i < nAsteroides; ++i)\n{\n  listaAsteroides[i].aceleracion[0] = fuerzasAcX[i] / listaAsteroides[i].masa;\n  listaAsteroides[i].aceleracion[1] = fuerzasAcY[i] / listaAsteroides[i].masa;\n  listaAsteroides[i].velocidad[0] = listaAsteroides[i].velocidad[0] + (listaAsteroides[i].aceleracion[0] * TIMEINTERVAL);\n  listaAsteroides[i].velocidad[1] = listaAsteroides[i].velocidad[1] + (listaAsteroides[i].aceleracion[1] * TIMEINTERVAL);\n  listaAsteroides[i].x = listaAsteroides[i].x + (listaAsteroides[i].velocidad[0] * TIMEINTERVAL);\n  listaAsteroides[i].y = listaAsteroides[i].y + (listaAsteroides[i].velocidad[1] * TIMEINTERVAL);\n  if (listaAsteroides[i].x <= 0)\n  {\n    listaAsteroides[i].x = 2;\n    listaAsteroides[i].velocidad[0] = -listaAsteroides[i].velocidad[0];\n  }\n\n  if (listaAsteroides[i].y <= 0)\n  {\n    listaAsteroides[i].y = 2;\n    listaAsteroides[i].velocidad[1] = -listaAsteroides[i].velocidad[1];\n  }\n\n  if (listaAsteroides[i].x >= WIDTH)\n  {\n    listaAsteroides[i].x = WIDTH - 2;\n    listaAsteroides[i].velocidad[0] = -listaAsteroides[i].velocidad[0];\n  }\n\n  if (listaAsteroides[i].y >= HEIGHT)\n  {\n    listaAsteroides[i].y = HEIGHT - 2;\n    listaAsteroides[i].velocidad[1] = -listaAsteroides[i].velocidad[1];\n  }\n\n  int parar = 0;\n  for (int j = i + 1; j < nAsteroides; ++j)\n  {\n    if ((parar == 0) && (distanciasAsteroides[i][j] <= DMIN))\n    {\n      double swap = listaAsteroides[i].velocidad[0];\n      listaAsteroides[i].velocidad[0] = listaAsteroides[j].velocidad[0];\n      listaAsteroides[j].velocidad[0] = swap;\n      swap = listaAsteroides[i].velocidad[1];\n      listaAsteroides[i].velocidad[1] = listaAsteroides[j].velocidad[1];\n      listaAsteroides[j].velocidad[1] = swap;\n      parar = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mariabg/openMP2018/par/nasteroids-par/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  A[i] = (double) drand48();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/axpy_ompacc/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Hello World #%d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-par-for/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  wprintw(shipWindow, \"%c \", letters[i]);\n  for (int j = 0; j < 10; j++)\n  {\n    if (npcShootMap[i][j] != 0)\n      wprintw(shipWindow, \" x\");\n    else\n      if (playerShips[i][j] != 0)\n      wprintw(shipWindow, \" +\");\n    else\n      if (((!shipFinal) && isValueInArray(i, shipNodes, num_nodes)) && (j == active_col))\n      wprintw(shipWindow, \" |\");\n    else\n      wprintw(shipWindow, \" .\");\n\n\n\n  }\n\n  wprintw(shipWindow, \"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/3"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n    cin >> a[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rohankurekar/HPC/OpenMP/matrix_matrix_multiplication/0"}
{"code": "for (int i = 0; i < a.size(); i++)\n{\n  first = true;\n  for (int j = 0; j < a[0].size(); j++)\n  {\n    if (!first)\n    {\n      cout << \", \";\n    }\n\n    first = false;\n    printf(\"%8.20f\", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/Instrumental/0"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n{\n  if ((Cs[(i * 1000) + j] - Cp[(i * 1000) + j]) < 0.000001)\n    continue;\n  else\n  {\n    printf(\"ERRORS DETECTED!!!!!!!!!!!!!\\n\");\n    return -1;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liuruogu/CS160_openmp/matmul/2"}
{"code": "for (j = 0; j < length; j++)\n  asum += a[j];\n\n", "pragma": "omp parallel for simd reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Nstream/nstream/2"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    for (k = 0; k < 5; k++)\n    {\n      if (m[i][j][k] != ((i + j) + k))\n      {\n        fprintf(stderr, \"Invalid m[%d][%d][%d] = %d != %d\\n\", i, j, k, m[i][j][k], (i + j) + k);\n        abort();\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_collapse_01/1"}
{"code": "for (unsigned long long int j = i * i; j <= n; j += i)\n{\n  a[j] = 0;\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(a,i) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Parply/prime-sieve/sieve/0"}
{"code": "for (int i = 1; i < num_nodes; i++)\n  printf(\"Node %d: \\t%d\\n\", i, min_distance[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zickat/ProjetPR/pr/4"}
{"code": "for (t = s; (*t) != '\\0'; t++)\n{\n  size++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/1"}
{"code": "for (long i = 0; i < (text.length() - n); i++)\n{\n  num++;\n  for (long j = i; j < ((i + n) + 1); j++)\n  {\n    if (isspace(text[j]))\n      num--;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Storn5/genetic-parallelization/GeneticAlgorithms/ParallelOpenMP/ParallelOpenMP/2"}
{"code": "for (int i = 0; i < columnsMaxValues.size(); i++)\n{\n  ((((cout << \"max of column <\") << i) << \">: \") << columnsMaxValues[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelaziz321/hybrid-mpi-openmp-example/main/2"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n  for (int k = 0; k < nzn; k++)\n{\n  const double xM = grid->getXN(i, j, k) - (0.5 * Lx);\n  const double yB = grid->getYN(i, j, k) - (0.25 * Ly);\n  const double yT = grid->getYN(i, j, k) - (0.75 * Ly);\n  const double yBd = yB / delta;\n  const double yTd = yT / delta;\n  for (int is = 0; is < ns; is++)\n  {\n    if (DriftSpecies[is])\n    {\n      const double sech_yBd = (1. / cosh(yBd)) + 1e-5;\n      const double sech_yTd = (1. / cosh(yTd)) + 1e-5;\n      rhons[is][i][j][k] = ((rhoINIT[is] * sech_yBd) * sech_yBd) / FourPI;\n      rhons[is][i][j][k] += ((rhoINIT[is] * sech_yTd) * sech_yTd) / FourPI;\n    }\n    else\n      rhons[is][i][j][k] = rhoINIT[is] / FourPI;\n\n  }\n\n  Ex[i][j][k] = 0.0;\n  Ey[i][j][k] = 0.0;\n  Ez[i][j][k] = 0.0;\n  Bxn[i][j][k] = B0x * (((-1.0) + tanh(yBd)) - tanh(yTd));\n  Byn[i][j][k] = B0y;\n  Bzn[i][j][k] = B0z;\n  xpert = grid->getXN(i, j, k) - (Lx / 2);\n  ypert = yB;\n  exp_pert = exp(((-(xpert / delta)) * (xpert / delta)) - ((ypert / delta) * (ypert / delta)));\n  Bxn[i][j][k] += ((B0x * pertX) * exp_pert) * ((((((-cos(((M_PI * xpert) / 10.0) / delta)) * cos(((M_PI * ypert) / 10.0) / delta)) * 2.0) * ypert) / delta) - (((cos(((M_PI * xpert) / 10.0) / delta) * sin(((M_PI * ypert) / 10.0) / delta)) * M_PI) / 10.0));\n  Byn[i][j][k] += ((B0x * pertX) * exp_pert) * (((((cos(((M_PI * xpert) / 10.0) / delta) * cos(((M_PI * ypert) / 10.0) / delta)) * 2.0) * xpert) / delta) + (((sin(((M_PI * xpert) / 10.0) / delta) * cos(((M_PI * ypert) / 10.0) / delta)) * M_PI) / 10.0));\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/69"}
{"code": "for (int i = 0; i < (m + 1); i++)\n  Ap[i] = h_Ap[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/spmv/omp_simd/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = (double *) malloc((sizeof(double)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aman-1701/Tiled_Matrix_Multiplication_OpenMP/TiledMatrixMultiplication/1"}
{"code": "for (k = 1; k < 2048; k++)\n{\n  symmat[(k * (2048 + 1)) + k] = 1.0;\n  for (j = k + 1; j < (2048 + 1); j++)\n  {\n    symmat[(k * (2048 + 1)) + j] = 0.0;\n    for (i = 1; i < (2048 + 1); i++)\n    {\n      symmat[(k * (2048 + 1)) + j] += data[(i * (2048 + 1)) + k] * data[(i * (2048 + 1)) + j];\n    }\n\n    symmat[(j * (2048 + 1)) + k] = symmat[(k * (2048 + 1)) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation/0"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Recv(&quantmaior, 5, (MPI_Datatype) 0x4c000405, i, 4, (MPI_Comm) 0x44000000, &status);\n  int y;\n  for (y = 0; y < 5; y++)\n  {\n    int f = 0;\n    f = *(((int *) quantmaior) + y);\n    qntmaior[y] = f + qntmaior[y];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarceloMilbradt/Analizador-genoma-paralelo/dna/6"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i += incX + 2, j += incY + 2)\n{\n  save.REEL = YP[j];\n  save.IMAG = YP[j + 1];\n  YP[j] = XP[j];\n  YP[j + 1] = XP[j];\n  XP[i] = save.REEL;\n  XP[i + 1] = save.IMAG;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/swap/5"}
{"code": "for (int i = 0; i < ((signed) mask.size()); i++)\n{\n  if ((((mask[i][0] < ((signed) img->getHeight())) && (mask[i][0] >= 0)) && (mask[i][1] < ((signed) img->getWidth()))) && (mask[i][1] >= 0))\n    (*f)(img, mask[i][0], mask[i][1]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serrearthur/Fauxtoshop/source/src/base/mask/0"}
{"code": "for (int y = 1; y <= height_local; y++)\n{\n  for (int x = 1; x <= width_local; x++)\n  {\n    int neighbors = 0;\n    neighbors = ((((((local[y - 1][x - 1] + local[y - 1][x]) + local[y - 1][x + 1]) + local[y][x - 1]) + local[y][x + 1]) + local[y + 1][x - 1]) + local[y + 1][x]) + local[y + 1][x + 1];\n    if ((neighbors == 387) || ((neighbors == 386) && (local[y][x] == '1')))\n      new[y][x] = '1';\n    else\n      new[y][x] = '0';\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(THREADS) firstprivate(local, height_local, width_local)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/v-pap/Game-of-Life-in-parallel-MPI-OpenMP-CUDA/src/game_openmp/0"}
{"code": "for (miel = 0; miel < nelt; miel++)\n{\n  ifcoa[miel] = 0;\n  front[miel] = 0;\n  iel = mt_to_id_old[miel];\n  if (ich[iel] == 2)\n  {\n    ic = tree[iel];\n    if (((!btest(ic, 0)) && (!btest(ic, 1))) && (!btest(ic, 2)))\n    {\n      ntp[0] = iel;\n      ntp[1] = sje[iel][0][0][0];\n      ntp[2] = sje[iel][2][0][0];\n      ntp[3] = sje[ntp[2]][0][0][0];\n      ntp[4] = sje[iel][4][0][0];\n      ntp[5] = sje[ntp[4]][0][0][0];\n      ntp[6] = sje[ntp[4]][2][0][0];\n      ntp[7] = sje[ntp[6]][0][0][0];\n      parent = tree[iel] >> 3;\n      test = 0;\n      test1 = 1;\n      for (i = 0; i < 8; i++)\n      {\n        if ((tree[ntp[i]] >> 3) != parent)\n          test1 = 0;\n\n      }\n\n      if (test1)\n      {\n        test2 = 1;\n        for (i = 0; i < 8; i++)\n        {\n          if (ich[ntp[i]] != 2)\n            test2 = 0;\n\n        }\n\n        if (test2)\n        {\n          test3 = 1;\n          for (i = 0; i < 8; i++)\n          {\n            if (!icheck(ntp[i], i))\n              test3 = 0;\n\n          }\n\n          if (test3)\n            test = 1;\n\n        }\n\n      }\n\n      if (test)\n      {\n        ifcoa[miel] = 1;\n        for (i = 0; i < 8; i++)\n        {\n          ifcoa_id[ntp[i]] = 1;\n        }\n\n        front[miel] = 1;\n        for (i = 0; i < 7; i++)\n        {\n          skip[ntp[i + 1]] = 1;\n        }\n\n        if (!(*if_coarsen))\n          *if_coarsen = 1;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(miel,iel,ic, ntp,parent,test,test1,i,test2,test3) shared(if_coarsen)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/4"}
{"code": "for (int i = 0; i < m->row; i++)\n{\n  for (int j = 0; j < m->col; j++)\n  {\n    printf(\"matr[%d][%d] = %lf\\n\", i, j, m->tab[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  suma += numeros[i];\n  int id = omp_get_thread_num();\n  printf(\"Hilo %d = [%d]\\n\", id, i);\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:suma) if (n > 100)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_suma_opt/main/0"}
{"code": "for (i = 0; i < (*ksize); i++)\n{\n  sum += kernel[i] * ringbuf[i0++];\n  if (i0 == (*ksize))\n    i0 = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/8"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  dky = dny * ((float) k);\n  afdt = adt * cimagf(ffc[k]);\n  zt1 = (-cimagf(exy[2 + (3 * k)])) + (crealf(exy[2 + (3 * k)]) * _Complex_I);\n  zt3 = (-cimagf(exy[3 * k])) + (crealf(exy[3 * k]) * _Complex_I);\n  zt4 = bxy[3 * k] - (dth * (dky * zt1));\n  zt6 = bxy[2 + (3 * k)] + (dth * (dky * zt3));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exy[3 * k] + (cdt * (dky * zt1))) - (afdt * cu[3 * k]);\n  zt9 = (exy[2 + (3 * k)] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * k)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exy[3 * k] = zt7;\n  exy[1 + (3 * k)] = zero;\n  exy[2 + (3 * k)] = zt9;\n  ws += anorm * ((zt7 * conjf(zt7)) + (zt9 * conjf(zt9)));\n  zt4 -= dth * (dky * zt1);\n  zt6 += dth * (dky * zt3);\n  bxy[3 * k] = zt4;\n  bxy[1 + (3 * k)] = zero;\n  bxy[2 + (3 * k)] = zt6;\n  wp += anorm * ((zt4 * conjf(zt4)) + (zt6 * conjf(zt6)));\n  bxy[3 * k1] = zero;\n  bxy[1 + (3 * k1)] = zero;\n  bxy[2 + (3 * k1)] = zero;\n  exy[3 * k1] = zero;\n  exy[1 + (3 * k1)] = zero;\n  exy[2 + (3 * k1)] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/39"}
{"code": "for (i = 0; i < k; i++)\n{\n  if (num_tasks > 1)\n  {\n    memcpy(row_ghost_bot, grid_current + (m * (m_p - 1)), (sizeof(int)) * m);\n    memcpy(row_ghost_top, grid_current, (sizeof(int)) * m);\n    MPI_Sendrecv(row_ghost_bot, m, MPI_INT, rankBelow, i, tempBuf, m, MPI_INT, rankAbove, i, 1, &Stat);\n    MPI_Sendrecv(row_ghost_top, m, MPI_INT, rankAbove, i, row_ghost_bot, m, MPI_INT, rankBelow, i, 1, &Stat);\n    memcpy(row_ghost_top, tempBuf, (sizeof(int)) * m);\n  }\n\n  for (j = 0; j < m_p; j++)\n  {\n    for (l = 0; l < m; l++)\n    {\n      int nsum = 0;\n      t = ((j - 1) * m) + l;\n      ur = (((j - 1) * m) + l) + 1;\n      r = ((j * m) + l) + 1;\n      br = (((j + 1) * m) + l) + 1;\n      b = ((j + 1) * m) + l;\n      bl = (((j + 1) * m) + l) - 1;\n      left = ((j * m) + l) - 1;\n      ul = (((j - 1) * m) + l) - 1;\n      if (l == 0)\n      {\n        left = ((j * m) + m) - 1;\n        nsum += grid_current[r] + grid_current[left];\n        if (j == 0)\n        {\n          bl = (((j + 1) * m) + m) - 1;\n          nsum += (grid_current[br] + grid_current[b]) + grid_current[bl];\n          if (num_tasks > 1)\n          {\n            t = l;\n            ur = l + 1;\n            ul = m - 1;\n            nsum += (row_ghost_top[t] + row_ghost_top[ur]) + row_ghost_top[ul];\n          }\n          else\n          {\n            t = m * (m_p - 1);\n            ur = (m * (m_p - 1)) + 1;\n            ul = (m * m_p) - 1;\n            nsum += (grid_current[t] + grid_current[ur]) + grid_current[ul];\n          }\n\n        }\n        else\n          if (j == (m_p - 1))\n        {\n          ul = (((j - 1) * m) + m) - 1;\n          nsum += (grid_current[ur] + grid_current[t]) + grid_current[ul];\n          if (num_tasks > 1)\n          {\n            b = l;\n            br = l + 1;\n            bl = m - 1;\n            nsum += (row_ghost_bot[b] + row_ghost_bot[br]) + row_ghost_bot[bl];\n          }\n          else\n          {\n            b = l;\n            br = l + 1;\n            bl = m - 1;\n            nsum += (grid_current[b] + grid_current[br]) + grid_current[bl];\n          }\n\n        }\n        else\n        {\n          ul = (((j - 1) * m) + m) - 1;\n          bl = (((j + 1) * m) + m) - 1;\n          nsum += ((((grid_current[ur] + grid_current[t]) + grid_current[ul]) + grid_current[bl]) + grid_current[b]) + grid_current[br];\n        }\n\n\n      }\n      else\n        if (l == (m - 1))\n      {\n        r = j * m;\n        nsum += grid_current[r] + grid_current[left];\n        if (j == 0)\n        {\n          br = (j + 1) * m;\n          nsum += (grid_current[br] + grid_current[b]) + grid_current[bl];\n          if (num_tasks > 1)\n          {\n            t = l;\n            ur = 0;\n            ul = l - 1;\n            nsum += (row_ghost_top[t] + row_ghost_top[ur]) + row_ghost_top[ul];\n          }\n          else\n          {\n            t = (m * (m_p - 1)) + l;\n            ur = m * (m_p - 1);\n            ul = ((m * (m_p - 1)) + l) - 1;\n            nsum += (grid_current[t] + grid_current[ur]) + grid_current[ul];\n          }\n\n        }\n        else\n          if (j == (m_p - 1))\n        {\n          ur = (j - 1) * m;\n          nsum += (grid_current[ur] + grid_current[t]) + grid_current[ul];\n          if (num_tasks > 1)\n          {\n            b = l;\n            br = 0;\n            bl = l - 1;\n            nsum += (row_ghost_bot[b] + row_ghost_bot[br]) + row_ghost_bot[bl];\n          }\n          else\n          {\n            b = l;\n            br = l + 1;\n            bl = l - 1;\n            nsum += (grid_current[b] + grid_current[br]) + grid_current[bl];\n          }\n\n        }\n        else\n        {\n          ur = (j - 1) * m;\n          br = (j + 1) * m;\n          nsum += ((((grid_current[ur] + grid_current[t]) + grid_current[ul]) + grid_current[bl]) + grid_current[b]) + grid_current[br];\n        }\n\n\n      }\n      else\n      {\n        if (j == 0)\n        {\n          if (num_tasks > 1)\n          {\n            t = l;\n            ur = l + 1;\n            ul = l - 1;\n            nsum = ((((((row_ghost_top[t] + row_ghost_top[ur]) + grid_current[r]) + grid_current[br]) + grid_current[b]) + grid_current[bl]) + grid_current[left]) + row_ghost_top[ul];\n          }\n          else\n          {\n            t = (m * (m_p - 1)) + l;\n            ur = ((m * (m_p - 1)) + l) + 1;\n            ul = ((m * (m_p - 1)) + l) - 1;\n            nsum = ((((((grid_current[t] + grid_current[ur]) + grid_current[r]) + grid_current[br]) + grid_current[b]) + grid_current[bl]) + grid_current[left]) + grid_current[ul];\n          }\n\n        }\n        else\n          if (j == (m_p - 1))\n        {\n          if (num_tasks > 1)\n          {\n            b = l;\n            br = l + 1;\n            bl = l - 1;\n            nsum = ((((((grid_current[t] + grid_current[ur]) + grid_current[r]) + row_ghost_bot[br]) + row_ghost_bot[b]) + row_ghost_bot[bl]) + grid_current[left]) + grid_current[ul];\n          }\n          else\n          {\n            b = l;\n            br = l + 1;\n            bl = l - 1;\n            nsum = ((((((grid_current[t] + grid_current[ur]) + grid_current[r]) + grid_current[br]) + grid_current[b]) + grid_current[bl]) + grid_current[left]) + grid_current[ul];\n          }\n\n        }\n        else\n        {\n          nsum = ((((((grid_current[t] + grid_current[ur]) + grid_current[r]) + grid_current[br]) + grid_current[b]) + grid_current[bl]) + grid_current[left]) + grid_current[ul];\n        }\n\n\n      }\n\n\n      switch (nsum)\n      {\n        case 3:\n          grid_next[(j * m) + l] = 1;\n          break;\n\n        case 2:\n          grid_next[(j * m) + l] = grid_current[(j * m) + l];\n          break;\n\n        default:\n          grid_next[(j * m) + l] = 0;\n\n      }\n\n    }\n\n  }\n\n  int *grid_tmp = grid_next;\n  grid_next = grid_current;\n  grid_current = grid_tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW3/gameoflife/3"}
{"code": "for (k = y_min - 2; k <= (y_max + 2); k++)\n{\n  celldy[FTNREF1D(k, y_min - 2)] = d_y;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/initialise_chunk_kernel_c/7"}
{"code": "for (i = 0; i < 50; i++)\n{\n  sum += 1;\n}\n\n", "pragma": "omp parallel for private(i), reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmotel/zjp-labs/lab6/test/main/0"}
{"code": "for (int i = 0; i <= numcells; i++)\n{\n  R[i] = (R[i] + R2[i]) / 2;\n  RU[i] = (RU[i] + RU2[i]) / 2;\n  RE[i] = (RE[i] + RE2[i]) / 2;\n  U[i] = RU[i] / R[i];\n  P[i] = (GAMMA - 1.0) * (RE[i] - ((0.5 * RU[i]) * U[i]));\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/9"}
{"code": "for (int i = 0; i < ((r - rk) + 1); i++)\n{\n  for (int j = 0; j < ((c - ck) + 1); j++)\n  {\n    accumulator = 0;\n    for (int ii = 0; ii < rk; ii++)\n    {\n      for (int jj = 0; jj < ck; jj++)\n      {\n        accumulator += pA[i + ii][j + jj] * kerA[ii][jj];\n      }\n\n    }\n\n    pC[i][j] = accumulator;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, ii, jj, accumulator) num_threads(NUM_OF_THREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCONV/0"}
{"code": "for (int i = 0; i < mTrianglesCount; i++)\n{\n  IndexType > nodes;\n  for (int j = 0; j < 3; j++)\n  {\n    pmTriangles[(3 * i) + j] = faces.at(i).nodes[j];\n    nodes.push_back(idTranslator.getKratosId(faces.at(i).nodes[j]));\n    rSkinModelPart.AddNode(mModelPart.pGetNode(idTranslator.getKratosId(faces.at(i).nodes[j])));\n  }\n\n  lastId++;\n  rSkinModelPart.CreateNewCondition(\"SurfaceCondition3D3N\", lastId, nodes, mModelPart.pGetProperties(0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/CSharpWrapperApplication/custom_sources/model_part_wrapper/0"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n{\n  C[i][j] = 0;\n  for (k = 0; k < p; k++)\n    C[i][j] += A[i][k] * B[k][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Matmul/Solutions/matmul_recur_par/0"}
{"code": "for (int j = 0; j < negative; j++)\n{\n  data[j] = data_new[negative + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashwinikumar2/Parallel-Merge-Quick-and-Radix-Sort-using-OpenMP/sort/9"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"  A[%d]= \", i);\n  for (j = 0; j < 10; j++)\n    printf(\"%.1f \", A[i][j]);\n\n  printf(\"  b[%d]= %.1f\\n\", i, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp_matvec/1"}
{"code": "for (;;)\n{\n  read_fd = master;\n  fflush(stdout);\n  scaduto = select(maxfd + 1, &read_fd, 0, 0, 0);\n  if (scaduto == (-1))\n  {\n    printf(\"errrore select\\n\");\n    exit(1);\n  }\n\n  printf(\"evento\");\n  for (i = 0; i <= maxfd; i++)\n  {\n    if (FD_ISSET(i, &read_fd))\n    {\n      if (i == 0)\n      {\n        tastiera();\n      }\n      else\n        if (i == sk)\n        mexserver();\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/clientcrush/5"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  for (j = 0; j < numClusters; j++)\n  {\n    local_newClusters[i][j] = (float *) calloc(numCoords, sizeof(float));\n    assert(local_newClusters[i][j] != 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/7"}
{"code": "for (int i = (2 * n) / 16; i < ((3 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    C[i][j] = A[i][j] + B[i][j];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdh266/OpenMP_Practice/sectionExp/0"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((0.75 - 0.7) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * SAMPLES), stat[i].e2 / ((((double) (L * L)) * (L * L)) * SAMPLES), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/51"}
{"code": "for (int i = 0; i < n2; ++i)\n{\n  for (int j = 0; j < n3; j++)\n  {\n    global_w2[i][j] /= NUM_THREADS;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oke-aditya/parallel_neural_networks/openmp_mnist/training_private_nn/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  move(particles[i]);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yuchaoran2011/particles-OpenMP-simulation/openmp/4"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  aHelp[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AshkanGoharfar/Openmp_prefix_sum_Hillis_Steele_algorithm/inclusive_exclusive/inclusive_exclusive/3"}
{"code": "for (int i = 0; i < x.size(); i++)\n  y[i] += a * x[i];\n\n", "pragma": "#pragma omp parallel for shared(x, y, a) default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gjbex/training-material/Accelerators/Thrust/vectors_omp/0"}
{"code": "for (i = 0; i < numOfPoints; i++)\n{\n  allPoints[i].x = allPoints[i].x + (interval * allPoints[i].vX);\n  allPoints[i].y = allPoints[i].y + (interval * allPoints[i].vY);\n  allPoints[i].z = allPoints[i].z + (interval * allPoints[i].vZ);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/3"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    F[(i * 512) + j] = 0;\n    for (k = 0; k < 512; ++k)\n    {\n      F[(i * 512) + j] += C[(i * 512) + k] * D[(k * 512) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3MM/src/3mm/6"}
{"code": "for (row = 0; row < (*height); row += *width)\n{\n  position = row;\n  tmp = src[row];\n  fixedy = position + 1;\n  for (column = 0; column < halfkColumnPlus1; column++)\n  {\n    sum = 0.f;\n    for (x = 0; x < (halfkColumnPlus1 - column); x++)\n      sum += kernel[x];\n\n    sum *= tmp;\n    for (y = fixedy; x < ksizeLimit; x++, y++)\n      sum += kernel[x] * src[y];\n\n    dst[position++] = sum + (kernel[x] * src[y]);\n  }\n\n  for (; column < xmax; column++)\n  {\n    sum = 0.f;\n    for (x = 0; x < (halfkColumnPlus1 - column); x++)\n      sum += kernel[x] * tmp;\n\n    y = fixedy;\n    fixedy++;\n    for (; x < ksizeLimit; x++, y++)\n      sum += kernel[x] * src[y];\n\n    dst[position++] = sum + (kernel[x] * src[y]);\n  }\n\n  tmp = src[row + maxColumnLimit];\n  temp = ksizeMinus2;\n  for (fixedy = position - halfkColumn; column < (*width); column++, temp--)\n  {\n    y = fixedy;\n    fixedy++;\n    sum = 0.f;\n    for (x = 0; x < temp; x++, y++)\n      sum += kernel[x] * src[y];\n\n    for (sum2 = 0.f; x < ksizePlus1; x++)\n      sum2 += kernel[x];\n\n    sum += sum2 * tmp;\n    dst[position++] = sum;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/1"}
{"code": "for (j = first; j < ((size - i) - 1); j += 2)\n{\n  if (T[j + 1] < T[j])\n  {\n    tmp = T[j + 1];\n    T[j + 1] = T[j];\n    T[j] = tmp;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), private(i, tmp), shared(T, first, size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/0"}
{"code": "for (int chunksize = 1; chunksize < 50; chunksize = chunksize + 2)\n{\n  printf(\"Chunksize = %d\\n\", chunksize);\n  double t0 = omp_get_wtime();\n  cmbpremier_s(parameter, chunksize);\n  double t1 = omp_get_wtime();\n  double time_static = t1 - t0;\n  double t2 = omp_get_wtime();\n  cmbpremier_d(parameter, chunksize);\n  double t3 = omp_get_wtime();\n  double time_dynamic = t3 - t2;\n  fprintf(fo2, \"%d %f %f\\n\", chunksize, time_static, time_dynamic);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/premier/premier_v2/1"}
{"code": "for (c3 = 0; c3 <= (((N - c1) - 3) / 16); c3 += 1)\n  for (c5 = 0; c5 <= ((c1 - 1) / 16); c5 += 1)\n  for (c7 = 0; c7 <= ((-c3) + (((N - c1) - 3) / 16)); c7 += 1)\n  for (c11 = (c1 + (16 * c3)) + 1; c11 <= ((((c1 + (16 * c3)) + 16) < ((N - (16 * c7)) - 2)) ? ((c1 + (16 * c3)) + 16) : ((N - (16 * c7)) - 2)); c11 += 1)\n{\n  if (N >= (((16 * c7) + c11) + 18))\n  {\n    for (c15 = ((16 * c7) + c11) + 1; c15 <= (((16 * c7) + c11) + 16); c15 += 1)\n      Pbp[c1][c11] += ((((Pbp[16 * c5][c15] * ERT) * Q[(16 * c5) + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[16 * c5][c15] == 0) ? (1) : (Qbp[16 * c5][c15]));\n\n  }\n  else\n  {\n    for (c13 = 16 * c5; c13 <= (((c1 - 1) < ((16 * c5) + 15)) ? (c1 - 1) : ((16 * c5) + 15)); c13 += 1)\n    {\n      if (c13 >= ((16 * c5) + 1))\n        for (c15 = c11 + 1; c15 <= ((16 * c7) + c11); c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n\n      for (c15 = ((16 * c7) + c11) + 1; c15 < N; c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n    }\n\n  }\n\n}\n\n\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_pb_traco/2"}
{"code": "for (int i = 0; i < xelem; i++)\n{\n  xc[i].resize(yelem, 0.0);\n  yc[i].resize(yelem, 0.0);\n  vol[i].resize(yelem, 0.0);\n  area[i].resize(yelem);\n  for (int j = 0; j < yelem; j++)\n  {\n    area[i][j].resize(2);\n    for (int k = 0; k < 2; k++)\n    {\n      area[i][j][k].resize(2, 0.0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jichenglee/INS_LevelSet/NE577/main/1"}
{"code": "for (int t = 0; t < (((heightA / blockHeight) + 1) * ((lengthB / blockWidth) + 1)); ++t)\n{\n  int rowIndex = t / ((heightA / blockHeight) + 1);\n  int colIndex = t % ((heightA / blockHeight) + 1);\n  for (int i = 0; (i < blockHeight) && (((rowIndex * blockHeight) + i) < heightA); ++i)\n  {\n    for (int j = 0; (j < blockWidth) && (((colIndex * blockWidth) + j) < lengthB); ++j)\n    {\n      C[(rowIndex * blockHeight) + i][(colIndex * blockWidth) + j] = 0;\n      for (int k = 0; k < size; k++)\n      {\n        C[(rowIndex * blockHeight) + i][(colIndex * blockWidth) + j] += A[(rowIndex * blockHeight) + i][k] * B[k][(colIndex * blockWidth) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task4/1"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 224; j++)\n  {\n    for (int k = 0; k < 224; k++)\n    {\n      input[i][j][k] = rand() % 255;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/3"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    if (obstacles[(ii * params.nx) + jj])\n    {\n      cells[(ii * params.nx) + jj].speeds[1] = tmp_cells[(ii * params.nx) + jj].speeds[3];\n      cells[(ii * params.nx) + jj].speeds[2] = tmp_cells[(ii * params.nx) + jj].speeds[4];\n      cells[(ii * params.nx) + jj].speeds[3] = tmp_cells[(ii * params.nx) + jj].speeds[1];\n      cells[(ii * params.nx) + jj].speeds[4] = tmp_cells[(ii * params.nx) + jj].speeds[2];\n      cells[(ii * params.nx) + jj].speeds[5] = tmp_cells[(ii * params.nx) + jj].speeds[7];\n      cells[(ii * params.nx) + jj].speeds[6] = tmp_cells[(ii * params.nx) + jj].speeds[8];\n      cells[(ii * params.nx) + jj].speeds[7] = tmp_cells[(ii * params.nx) + jj].speeds[5];\n      cells[(ii * params.nx) + jj].speeds[8] = tmp_cells[(ii * params.nx) + jj].speeds[6];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/borektsioglou/OpenMP/d2q9-bgk/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, sizeof(float), (cols * (nendmembers - 1)) * 4, fpca4);\n  fread(buffer2, sizeof(float), cols * bands, fin);\n  for (j = 0; j < (nendmembers - 1); j++)\n  {\n    for (k = 0; k < cols; k++)\n    {\n      if (buffer2[((j * cols) * 4) + k] != nvalue)\n      {\n        if (buffer[((j * cols) * 4) + k] < hmin[j])\n        {\n          hmin[j] = buffer[((j * cols) * 4) + k];\n          coordsr[j] = i;\n          coordsc[j] = k;\n        }\n\n        if (buffer[((j * cols) * 4) + k] > hmax[j])\n        {\n          hmax[j] = buffer[((j * cols) * 4) + k];\n          coordsr[(nendmembers - 1) + j] = i;\n          coordsc[(nendmembers - 1) + j] = k;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/8"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/34"}
{"code": "for (i = 1; i < (4096 + 1); i++)\n{\n  for (j = 1; j < (4096 + 1); j++)\n  {\n    if (percentDiff(symmat[(i * (4096 + 1)) + j], symmat_outputFromGpu[(i * (4096 + 1)) + j]) > 1.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation_cpu/10"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (array[i] > SerialMax)\n  {\n    SerialMax = array[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/test/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n  }\n\n  lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,k,m) firstprivate (n,j1,j2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/184"}
{"code": "for (int i = 0; i < n; i++)\n{\n  cin >> vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/prgm1/1"}
{"code": "for (int i = 0; i < num_edges; ++i)\n{\n  fin >> edges[i][0];\n  fin >> edges[i][1];\n  fflush(stdin);\n  fflush(stdout);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Edge-Coloring/parallel-omp/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    tmp = 0.0;\n    for (int k = 0; k < n; k++)\n    {\n      tmp = (tmp + (p[i][k] * a[k][j])) - (l[i][k] * u[k][j]);\n    }\n\n    result[i][j] = tmp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/2"}
{"code": "for (int i = rank * len; i < ((rank + 1) * len); i++)\n{\n  ((((cout << \"Thread id = \") << omp_get_thread_num()) << \" Itr = \") << i) << endl;\n  x[i] = i;\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdh266/OpenMP_Practice/array/0"}
{"code": "for (int i = 0; i < size_n; i++)\n{\n  dataLeft[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TollisK/Jacobi-Method-Parallel-Programming/parallelJacobi_mp/3"}
{"code": "for (row = 0; row < MAXROW; row++)\n{\n  for (col = 0; col < MAXCOL; col++)\n  {\n    switch (neighbors(row, col))\n    {\n      case 0:\n\n      case 1:\n\n      case 4:\n\n      case 5:\n\n      case 6:\n\n      case 7:\n\n      case 8:\n        newmap[row][col] = DEAD;\n        break;\n\n      case 2:\n        newmap[row][col] = map[row][col];\n        break;\n\n      case 3:\n        newmap[row][col] = ALIVE;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(P) private(row)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"Game of Life\" with OpenMP/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int k = 0; k < N; k++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      C[(i * N) + j] += A[(i * N) + k] * B[(k * N) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daedgomez/CE-4302-TallerOpenMP/matrix/0"}
{"code": "for (int jj = HALO_PAD; jj < (HALO_PAD + depth); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (xMax - HALO_PAD); ++kk)\n  {\n    int bufIndex = (kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    c[i] += a[i][j] * b[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aygulmardanova/openMP-tasks/task9/3"}
{"code": "for (i = 1; i < (N - 1); i++)\n  for (j = 1; j < (M - 1); j++)\n  uold[i][j] = unew[i][j];\n\n\n", "pragma": "omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/9"}
{"code": "for (int i = 0; i < Value; i++)\n{\n  Sum += i + 1;\n}\n\n", "pragma": "omp parallel for default(none) firstprivate(Value) reduction(+: Sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 3/Parallel/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  tmp(i) = ((apriori_data(i) + intrinsic_coded(2 * i)) >= 0) ^ (extrinsic_data(i) == 1.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/10"}
{"code": "for (int64_t i = 0; i < n; ++i)\n  ++start[level[i] + 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/13"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_32 * SIMD_PARA_SHA256)\n{\n  SHA256_CTX ctx;\n  if (dirty)\n  {\n    SHA256_Init(&prep_ctx[index]);\n    SHA256_Update(&prep_ctx[index], prep_key[index], 510);\n  }\n\n  memcpy(&ctx, &prep_ctx[index], sizeof(ctx));\n  SHA256_Update(&ctx, prep_key[index] + (510 / 2), 8);\n  SHA256_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(dirty, prep_ctx, count, crypt_out, prep_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/SybaseASE_fmt_plug/5"}
{"code": "for (i = 0; i < dim; i++)\n{\n  int k;\n  float sum = 0.0f;\n  int bound = h_nzcnt[i];\n  for (k = 0; k < bound; k++)\n  {\n    int j = h_ptr[k] + i;\n    int in = h_indices[j];\n    float d = h_data[j];\n    float t = h_x_vector[in];\n    sum += d * t;\n  }\n\n  h_Ax_vector[h_perm[i]] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Parboil/spmv/src/main/0"}
{"code": "for (int k = ipnt + 1; k < ipntp; k = k + 2)\n{\n  i++;\n  x[i] = (x[k] - (v[k] * x[k - 1])) - (v[k + 1] * x[k + 1]);\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/6"}
{"code": "for (i = 0; i < layerSize[currentLayer]; i++)\n{\n  layer->value_prev[i] = 0.0;\n}\n\n", "pragma": "omp for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/5"}
{"code": "for (box = 0; box < level->num_my_boxes; box++)\n{\n  int i;\n  int j;\n  int k;\n  double *phi = level->my_boxes[box].vectors[phi_id] + (ghosts * ((1 + jStride) + kStride));\n  const double *rhs = level->my_boxes[box].vectors[rhs_id] + (ghosts * ((1 + jStride) + kStride));\n  const double *alpha = level->my_boxes[box].vectors[VECTOR_ALPHA] + (ghosts * ((1 + jStride) + kStride));\n  const double *beta_i = level->my_boxes[box].vectors[VECTOR_BETA_I] + (ghosts * ((1 + jStride) + kStride));\n  const double *beta_j = level->my_boxes[box].vectors[VECTOR_BETA_J] + (ghosts * ((1 + jStride) + kStride));\n  const double *beta_k = level->my_boxes[box].vectors[VECTOR_BETA_K] + (ghosts * ((1 + jStride) + kStride));\n  const double *Dinv = level->my_boxes[box].vectors[VECTOR_DINV] + (ghosts * ((1 + jStride) + kStride));\n  if ((s & 0x1) == 0)\n  {\n    for (k = 0; k < dim; k++)\n    {\n      for (j = 0; j < dim; j++)\n      {\n        for (i = 0; i < dim; i++)\n        {\n          int ijk = (i + (j * jStride)) + (k * kStride);\n          double Ax = apply_op_ijk(phi);\n          phi[ijk] = phi[ijk] + (Dinv[ijk] * (rhs[ijk] - Ax));\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    for (k = dim - 1; k >= 0; k--)\n    {\n      for (j = dim - 1; j >= 0; j--)\n      {\n        for (i = dim - 1; i >= 0; i--)\n        {\n          int ijk = (i + (j * jStride)) + (k * kStride);\n          double Ax = apply_op_ijk(phi);\n          phi[ijk] = phi[ijk] + (Dinv[ijk] * (rhs[ijk] - Ax));\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators.old/symgs/0"}
{"code": "for (j = 0; j < VERYBIG; j++)\n{\n  sum += 1;\n  sumx = 0.0;\n  for (k = 0; k < j; k++)\n    sumx = sumx + ((double) k);\n\n  sumy = 0.0;\n  for (k = j; k > 0; k--)\n    sumy = sumy + ((double) k);\n\n  if (sumx > 0.0)\n    total = total + (1.0 / sqrt(sumx));\n\n  if (sumy > 0.0)\n    total = total + (1.0 / sqrt(sumy));\n\n}\n\n", "pragma": "omp parallel for private(k, sumx, sumy) reduction(+:sum, total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smohammadhejazi/multicore-programming-lab/1/code/1/0"}
{"code": "for (i = 0; i < 102400; i++)\n{\n  psum += vecA[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/hybrid-openmp-mpi/reduction/solution/sum/0"}
{"code": "for (i = 0; i < 1; i++)\n{\n  map_cost[inicio_y][inicio_x] = 0;\n  count = movimientos_init(inicio_x, inicio_y, 0, fricc, m, n, array);\n  raster_cost(array, map_cost, count);\n}\n\n", "pragma": "#pragma omp parallel for private(i,count)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/cost_dist/1"}
{"code": "for (unsigned int i = smaller; i < bigger; ++i)\n{\n  daughter[i] = parents.at(1).at(i);\n  mother_data.push_back(parents.at(1).at(i));\n  son[i] = parents.at(0).at(i);\n  father_data.push_back(parents.at(0).at(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/6"}
{"code": "for (int d = 0; d < 1; d++)\n{\n  ((double *) arg2.data)[d] = arg2h[d];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/sycl/compute_step_factor_kernel_kernel/0"}
{"code": "for (int row = 0; row < n; row++)\n{\n  int deg = 0;\n  for (int col = 0; col < n; col++)\n    deg += matrix[row][col];\n\n  degree[row] = deg;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manolismih/sparseMatPerm/parallel/0"}
{"code": "for (i = 0; i < N; i++)\n  sum += B[i] * C[i];\n\n", "pragma": "omp distribute parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/distribute_parallel_for/0"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (4 * nxhd) * i;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 + (4 * j)) + joff]);\n    at2 = crealf(f[(2 + (4 * j)) + joff]);\n    f[(2 + (4 * j)) + joff] = crealf(f[(1 + (4 * j)) + joff]) + (crealf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n    f[(1 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (at1 * _Complex_I);\n    f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(4 * j1) + joff];\n      t2 = f[(1 + (4 * j1)) + joff];\n      t3 = f[(2 + (4 * j1)) + joff];\n      f[(4 * j1) + joff] = f[(4 * j) + joff];\n      f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n      f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n      f[(4 * j) + joff] = t1;\n      f[(1 + (4 * j)) + joff] = t2;\n      f[(2 + (4 * j)) + joff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = sct[kmr * j];\n        t2 = t1 * f[((4 * j) + k2) + joff];\n        t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n        t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n        f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n        f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n        f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n        f[((4 * j) + k1) + joff] += t2;\n        f[((1 + (4 * j)) + k1) + joff] += t3;\n        f[((2 + (4 * j)) + k1) + joff] += t4;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxy / nx;\n  ani = 0.5 / (((float) nx) * ((float) ny));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 3; jj++)\n    {\n      t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n      t1 = f[(jj + (4 * j)) + joff] + t2;\n      t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n      f[(jj + (4 * j)) + joff] = ani * (t1 + t2);\n      f[(jj + (4 * (nxh - j))) + joff] = ani * conjf(t1 - t2);\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (jj = 0; jj < 3; jj++)\n  {\n    f[(jj + (4 * nxhh)) + joff] = ani * conjf(f[(jj + (4 * nxhh)) + joff]);\n    f[jj + joff] = ani * ((crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,at1,at2,ani,t1,t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/23"}
{"code": "for (int vid = batch_start; vid < batch_end; vid++)\n{\n  double Li_curr[K_count];\n  double Rj_curr[K_count];\n  double Li_update[K_count];\n  double Rj_update[K_count];\n  int row_index = x_row_array[vid];\n  int column_index = x_col_array[vid];\n  double Xij = x_val_array[vid];\n  for (int k = 0; k < K_count; ++k)\n  {\n    Li_curr[k] = L_table[(row_index * K_count) + k];\n    if (stale_mode == 0)\n    {\n      Rj_curr[k] = R_table[(column_index * K_count) + k];\n    }\n    else\n    {\n      Rj_curr[k] = R_table_ind[(vid * K_count) + k];\n    }\n\n  }\n\n  double LiRj = 0.0;\n  for (int k = 0; k < K_count; ++k)\n  {\n    LiRj = LiRj + (Li_curr[k] * Rj_curr[k]);\n  }\n\n  for (int k = 0; k < K_count; ++k)\n  {\n    double gradient = 0.0;\n    double Li_value = Li_curr[k];\n    double Rj_value = Rj_curr[k];\n    gradient = (((-2) * Xij) * Rj_value) + ((2 * LiRj) * Rj_value);\n    Li_update[k] = (-gradient) * step_size;\n    gradient = (((-2) * Xij) * Li_value) + ((2 * LiRj) * Li_value);\n    Rj_update[k] = (-gradient) * step_size;\n  }\n\n  for (int k = 0; k < K_count; ++k)\n  {\n    atomicAdd(&L_table[(row_index * K_count) + k], Li_update[k]);\n    atomicAdd(&R_table[(column_index * K_count) + k], Rj_update[k]);\n  }\n\n  atomicAdd(&loss_sum, (double) pow(Xij - LiRj, 2));\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/MAT_FACT/kernel/1"}
{"code": "for (i = 0; i < Q; i++)\n{\n  *M_max = ((*M_max) > M[i]) ? (*M_max) : (M[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/50"}
{"code": "for (i = 0; i < n; i++)\n{\n  part_sums[16 * tid] += A[i];\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/3"}
{"code": "for (j = 0; j < sz; j++)\n{\n  int temp = klabels[j];\n  _ASSERT(klabels[j] >= 0);\n  sigmal[klabels[j]] += m_lvec[j];\n  sigmaa[klabels[j]] += m_avec[j];\n  sigmab[klabels[j]] += m_bvec[j];\n  sigmax[klabels[j]] += j % m_width;\n  sigmay[klabels[j]] += j / m_width;\n  clustersize[klabels[j]]++;\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/9"}
{"code": "for (int i = 0; i < RUN_COUNT; i++)\n{\n  fillDataset(&dataset);\n  starttime = omp_get_wtime();\n  compute(dataset);\n  elapsedtime = omp_get_wtime() - starttime;\n  closeDataset(dataset);\n  printf(\"[-] Time Elapsed: %f Secs\\n\", elapsedtime);\n  times_sum += elapsedtime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q1/0"}
{"code": "for (int j = 0; j < row; j++)\n{\n  for (int i = half_length + 1; i < (col - (half_length + 1)); i++)\n  {\n    float acc = 0.0f;\n    for (int k = 0; k < filter_length; k++)\n    {\n      acc += local_mem[(j * col) + ((i + k) - half_length)] * local_filter[k];\n    }\n\n    local_temp[(j * col) + i] = acc;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(local_mem, local_temp) firstprivate(local_filter) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akgunduz/benchpar/src/app/conv/convfuncs/2"}
{"code": "for (int i = 0; i < cantidad_intervalos; i++)\n{\n  x = (i + 0.5) * base_intervalo;\n  fdx = 4 / (1 + (x * x));\n  acum += fdx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Roberto09/Multiprocessors-Course/openmp_for/main/0"}
{"code": "for (j = 0; j < 10; ++j)\n{\n  S[i][j] = A[i][j] + B[i][j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcubells/ejemplos_openmp/omp_multi_matrices/suma_tradicional/3"}
{"code": "for (j = 0; j <= 99; j += 1)\n{\n  a[i][j] = i;\n  b[i][j] = i;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB113-default-orig-no/1"}
{"code": "for (int i = 0; i < 16; i++)\n  if (a[i] != b[i])\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gaengj/MD5BruteforceCracker/2-bruteforce-md5-openmp/bruteforce-md5-openmp/1"}
{"code": "for (i = 2; i <= temp; i++)\n  if ((n % i) == 0)\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/OpenMP/noOfPrimes/1"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n  for (j = 1; j < (_PB_N - 1); j++)\n  B[i][j] = 0.2 * ((((A[i][j] + A[i][j - 1]) + A[i][1 + j]) + A[1 + i][j]) + A[i - 1][j]);\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/jacobi-2d-imper/jacobi-2d-imper/0"}
{"code": "for (i = 0; i < nlines; i++)\n{\n  mat[i] = (double *) malloc((sizeof(double)) * ncols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/obernardocosta/High-Performance-Computing-HPC/OPEN_MP/2/linalg_par/7"}
{"code": "for (m = 0; m < nkernels; m++)\n{\n  for (w = 0; w < width; w++)\n  {\n    for (h = 0; h < height; h++)\n    {\n      double sum = 0.0;\n      for (c = 0; c < nchannels; c++)\n      {\n        for (x = 0; x < kernel_order; x++)\n        {\n          for (y = 0; y < kernel_order; y++)\n          {\n            sum += ((double) image[w + x][h + y][c]) * ((double) kernels[m][c][x][y]);\n          }\n\n        }\n\n        output[m][w][h] = (float) sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/4"}
{"code": "for (i = 0; i < tablesize; i++)\n  Table[i] = (u64Int) i;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Random/random/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i + 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tx1) * dx1;\n    a[i][j][0][1] = dt * tx2;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = 0.0;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = ((dt * tx2) * (((-(u[i + 1][j][k][1] * tmp1)) * (u[i + 1][j][k][1] * tmp1)) + (((C2 * 0.50) * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i + 1][j][k][1]));\n    a[i][j][1][1] = (((dt * tx2) * ((2.0 - C2) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    a[i][j][1][2] = (dt * tx2) * ((-C2) * (u[i + 1][j][k][2] * tmp1));\n    a[i][j][1][3] = (dt * tx2) * ((-C2) * (u[i + 1][j][k][3] * tmp1));\n    a[i][j][1][4] = (dt * tx2) * C2;\n    a[i][j][2][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][2]));\n    a[i][j][2][1] = (dt * tx2) * (u[i + 1][j][k][2] * tmp1);\n    a[i][j][2][2] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    a[i][j][2][3] = 0.0;\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][3]));\n    a[i][j][3][1] = (dt * tx2) * (u[i + 1][j][k][3] * tmp1);\n    a[i][j][3][2] = 0.0;\n    a[i][j][3][3] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    a[i][j][3][4] = 0.0;\n    a[i][j][4][0] = ((dt * tx2) * ((((C2 * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2) - (C1 * (u[i + 1][j][k][4] * tmp1))) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i + 1][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i + 1][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i + 1][j][k][3]))) - ((c1345 * tmp2) * u[i + 1][j][k][4])));\n    a[i][j][4][1] = ((dt * tx2) * ((C1 * (u[i + 1][j][k][4] * tmp1)) - ((0.50 * C2) * (((((3.0 * u[i + 1][j][k][1]) * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i + 1][j][k][1]);\n    a[i][j][4][2] = ((dt * tx2) * (((-C2) * (u[i + 1][j][k][2] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][2]);\n    a[i][j][4][3] = ((dt * tx2) * (((-C2) * (u[i + 1][j][k][3] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][3]);\n    a[i][j][4][4] = (((dt * tx2) * (C1 * (u[i + 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n    tmp1 = 1.0 / u[i][j + 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = dt * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = ((dt * ty2) * ((-(u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][1]));\n    b[i][j][1][1] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = (dt * ty2) * (u[i][j + 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = ((dt * ty2) * (((-(u[i][j + 1][k][2] * tmp1)) * (u[i][j + 1][k][2] * tmp1)) + ((0.50 * C2) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j + 1][k][2]));\n    b[i][j][2][1] = (dt * ty2) * ((-C2) * (u[i][j + 1][k][1] * tmp1));\n    b[i][j][2][2] = (((dt * ty2) * ((2.0 - C2) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = (dt * ty2) * ((-C2) * (u[i][j + 1][k][3] * tmp1));\n    b[i][j][2][4] = (dt * ty2) * C2;\n    b[i][j][3][0] = ((dt * ty2) * ((-(u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = (dt * ty2) * (u[i][j + 1][k][3] * tmp1);\n    b[i][j][3][3] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = ((dt * ty2) * ((((C2 * (((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) * tmp2) - (C1 * (u[i][j + 1][k][4] * tmp1))) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j + 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j + 1][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j + 1][k][3]))) - ((c1345 * tmp2) * u[i][j + 1][k][4])));\n    b[i][j][4][1] = ((dt * ty2) * (((-C2) * (u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][1]);\n    b[i][j][4][2] = ((dt * ty2) * ((C1 * (u[i][j + 1][k][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + ((3.0 * u[i][j + 1][k][2]) * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j + 1][k][2]);\n    b[i][j][4][3] = ((dt * ty2) * (((-C2) * (u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][3]);\n    b[i][j][4][4] = (((dt * ty2) * (C1 * (u[i][j + 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i][j][k + 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tz1) * dz1;\n    c[i][j][0][1] = 0.0;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = dt * tz2;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = ((dt * tz2) * ((-(u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][1]));\n    c[i][j][1][1] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    c[i][j][1][2] = 0.0;\n    c[i][j][1][3] = (dt * tz2) * (u[i][j][k + 1][1] * tmp1);\n    c[i][j][1][4] = 0.0;\n    c[i][j][2][0] = ((dt * tz2) * ((-(u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][2]));\n    c[i][j][2][1] = 0.0;\n    c[i][j][2][2] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    c[i][j][2][3] = (dt * tz2) * (u[i][j][k + 1][2] * tmp1);\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = ((dt * tz2) * (((-(u[i][j][k + 1][3] * tmp1)) * (u[i][j][k + 1][3] * tmp1)) + ((0.50 * C2) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k + 1][3]));\n    c[i][j][3][1] = (dt * tz2) * ((-C2) * (u[i][j][k + 1][1] * tmp1));\n    c[i][j][3][2] = (dt * tz2) * ((-C2) * (u[i][j][k + 1][2] * tmp1));\n    c[i][j][3][3] = ((((dt * tz2) * (2.0 - C2)) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    c[i][j][3][4] = (dt * tz2) * C2;\n    c[i][j][4][0] = ((dt * tz2) * ((((C2 * (((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) * tmp2) - (C1 * (u[i][j][k + 1][4] * tmp1))) * (u[i][j][k + 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k + 1][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k + 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k + 1][3]))) - ((c1345 * tmp2) * u[i][j][k + 1][4])));\n    c[i][j][4][1] = ((dt * tz2) * (((-C2) * (u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][1]);\n    c[i][j][4][2] = ((dt * tz2) * (((-C2) * (u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][2]);\n    c[i][j][4][3] = ((dt * tz2) * ((C1 * (u[i][j][k + 1][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + ((3.0 * u[i][j][k + 1][3]) * u[i][j][k + 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k + 1][3]);\n    c[i][j][4][4] = (((dt * tz2) * (C1 * (u[i][j][k + 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n  }\n\n}\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/46"}
{"code": "for (i = (*num_ph) - ((total_bins - count_c_ph) + (*num_null_ph)); i < (*num_ph); i++)\n{\n  if ((*ph_orig)[i].type == CS_POOL_PHOTON)\n  {\n    (*ph_orig)[i].type = COMPTONIZED_PHOTON;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/11"}
{"code": "for (bz = 1; bz <= ((iteracoes < 1024) ? (iteracoes) : (1024)); bz++)\n{\n  for (by = 1; by <= (((iteracoes / bz) < 1024) ? (iteracoes / bz) : (1024)); by++)\n  {\n    for (bx = 1; bx < ((((iteracoes / bz) / by) < 1024) ? ((iteracoes / bz) / by) : (1024)); bx++)\n    {\n      for (gx = 1; gx <= (((((iteracoes / bz) / by) / bx) < 2147483647) ? (((iteracoes / bz) / by) / bx) : (2147483647)); gx++)\n      {\n        for (gy = 1; gy <= ((((((iteracoes / bz) / by) / bx) / gx) < 65535) ? ((((iteracoes / bz) / by) / bx) / gx) : (65535)); gy++)\n        {\n          for (gz = 1; gz <= (((((((iteracoes / bz) / by) / bx) / gx) / gy) < 65535) ? (((((iteracoes / bz) / by) / bx) / gx) / gy) : (65535)); gz++)\n          {\n            confBlock = (bx * by) * bz;\n            confGrid = (gx * gy) * gz;\n            config = confBlock * confGrid;\n            if (((confBlock <= 1024) && (config == iteracoes)) && ((confBlock % 32) == 0))\n            {\n              countConfig++;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(bz, by, bx, gx, gy, gz) schedule(guided,32) reduction(+:countConfig)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/runc/tam-grids-blocks-omp-for/0"}
{"code": "for (i = 0; i < 500000; i++)\n{\n  num_t = omp_get_num_threads();\n  t_id = omp_get_thread_num();\n  result += (sin(data[i]) - cos(data[i])) / sin(data[i] + cos(data[i]));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mister2Tone/lab-3SA03-openMP/loopParallel/0"}
{"code": "for (int i = 0; i < count; i++)\n  omp_target_free(maps[i], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/2"}
{"code": "for (int i = 0; i < level; i++)\n  buffer[i + 1] = options[task][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/27"}
{"code": "for (i = 1; i < _PB_NX; i++)\n  for (j = 0; j < _PB_NY; j++)\n  ey[i][j] = ey[i][j] - (SCALAR_VAL(0.5) * (hz[i][j] - hz[i - 1][j]));\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/fdtd-2d/fdtd-2d/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < n; j++)\n  {\n    b[i][j] = (double) (i * j);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB054-inneronly2-orig-no/0"}
{"code": "for (int i = 0; i < K; i++)\n  while (true)\n{\n  int randIndex = rand() % dataset.size();\n  if (find(clusterIndices.begin(), clusterIndices.end(), randIndex) == clusterIndices.end())\n  {\n    clusterIndices.push_back(randIndex);\n    clusters.push_back(dataset[clusterIndices[i]]);\n    break;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/7"}
{"code": "for (size_t i = 0; i < 4; i++)\n{\n  outBlock[i] = encodingString[indexes[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phoenixEkb/OpenMP-base64-encoder-decoder/OpenMPTest/OpenMPTest/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    printf(\"id = %d, b[%d][%d]=%d \\n\", omp_get_thread_num(), i, j, b[i][j] = getRand());\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic,1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/1"}
{"code": "for (int i = 0; i < Reps; i++)\n{\n  assignew = DoptBCDOne(data.rows(0, cov_num - 1), n, cov_num);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  diff(i) = ((-sum(data.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/33"}
{"code": "for (int i = 0; i < mpi_size; i++)\n{\n  omp_destroy_lock(&proc_locks[i]);\n  omp_destroy_lock(&proc_send_locks[i]);\n  omp_destroy_lock(&recv_locks[i]);\n  omp_destroy_lock(&send_locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/177"}
{"code": "for (i = 1; i < n; i++)\n{\n  if (minPoints[thread_num]->x > pointsIn[i].x)\n  {\n    minPoints[thread_num] = &pointsIn[i];\n  }\n\n  if (maxPoints[thread_num]->x < pointsIn[i].x)\n  {\n    maxPoints[thread_num] = &pointsIn[i];\n  }\n\n}\n\n", "pragma": "  #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/hull/0"}
{"code": "for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n{\n  this_diff = RefOut[i][j] - C[i][j];\n  if (this_diff < 0)\n    this_diff = (-1.0) * this_diff;\n\n  if (this_diff > 0.000000001)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n      maxdiff = this_diff;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/4"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  for (int j = 1; j < (m - 1); j++)\n  {\n    const int pos = (i * m) + j;\n    const float temp = (*mat)[pos];\n    (*mat)[pos] = 0.2f * (((((*mat)[pos] + (*mat)[pos - 1]) + (*mat)[pos - n]) + (*mat)[pos + 1]) + (*mat)[pos + n]);\n    diff += abs((*mat)[pos] - temp);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(num_ths) schedule(static, max_cells_per_th) collapse(2) reduction(+:diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sinclert/CAP-OpenMP/gs_openmp/0"}
{"code": "for (i = 0, pi = 0.0; i < 4; i++)\n  pi += sum[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ququwork/MPI-pi/3for/1"}
{"code": "for (int i = 2; i <= n; i++)\n{\n  primes[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dizys/nyu-multicore-lab-2/genprime/1"}
{"code": "for (uint32_t px = 0; px < (pMat->width * pMat->height); px++)\n{\n  pImg->data[px] = (unsigned char) ((pMat->data[px] * 255) / maxGrad);\n}\n\n", "pragma": "omp parallel for shared(pImg)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ricordel/parallel-sobel/sobel/implem_omp/3"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  ++(*size_colors)[color[i] - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/30"}
{"code": "for (i = 0; i < N; i++)\n{\n  M_inverse[i] = 1.0 / sparse_A[i][i];\n  JM[i] = i;\n  IM[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/5"}
{"code": "for (unsigned c2 = 0; c2 < Size; c2++)\n  res[c2] = data[Index[c2]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/14"}
{"code": "for (i = a; i < b; ++i)\n{\n  jp = out + i;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/11"}
{"code": "for (double i = 0; i < A.size(); i++)\n{\n  A[i] = range1(e);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tonyz0x0/parallel-computing/matrix-multiplication-openmp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  *(dest + i) = (double) rand();\n}\n\n", "pragma": "omp parallel for shared(dest,size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisbaldissera/openmp-learning/matGen/0"}
{"code": "for (iy = 0; iy < Ydots; iy++)\n{\n  for (ix = 0; ix < Xdots; ix++)\n  {\n    ca = (Xinc * ix) + Ir;\n    cb = (Yinc * iy) + Ii;\n    rad = sqrt((ca * ca) * (((double) 1.0) + ((cb / ca) * (cb / ca))));\n    zan = 0.0;\n    zbn = 0.0;\n    for (iz = 1; iz <= MaxIt; iz++)\n    {\n      if (rad > ((double) 2.0))\n        break;\n\n      za = zan;\n      zb = zbn;\n      zan = ca + ((za - zb) * (za + zb));\n      zbn = 2.0 * ((za * zb) + (cb / 2.0));\n      rad = sqrt((zan * zan) * (((double) 1.0) + ((zbn / zan) * (zbn / zan))));\n    }\n\n    if (izmn > iz)\n      izmn = iz;\n\n    if (izmx < iz)\n      izmx = iz;\n\n    if (iz >= MaxIt)\n      iz = 0;\n\n    grid->Values[ix + (iy * Xdots)] = iz;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/3"}
{"code": "for (int j = num_elements; j < ((cols_per_block - 1) * num_elements); j++)\n{\n  if ((!halo_convolution(Table, Final, 0, j, h, num_elements, halo_p->North, 0)) && (!lchanges))\n  {\n    lchanges++;\n    changes += lchanges;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(lchanges) reduction(+:changes)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisKarampas/Image_Convolution/src/main/1"}
{"code": "for (j = jst1; j <= jend1; j += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m) firstprivate (jend1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/110"}
{"code": "for (int i = 1; i < 4; ++i)\n{\n  if (mutants[i].score > max.score)\n  {\n    max = mutants[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saloelia/Parallel-Sequence-Aligment/calculation/3"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    CUTOFF = atoi(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE] -c CUTOFF\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Iteration [%d], executed by thread: %d \\n\", i, iterations[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miguelrochajr/ParallelProgramming/BookExercises/Chapter5/Question9/q9/1"}
{"code": "for (j = 1; j < (1024 - 1); ++j)\n{\n  for (i = 1; i < (1024 - 1); ++i)\n  {\n    for (k = 1; k < (1024 - 1); ++k)\n    {\n      B[((i * (1024 * 1024)) + (j * 1024)) + k] = ((((((((((((((c11 * A[(((i - 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)]) + (c13 * A[(((i + 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)])) + (c21 * A[(((i - 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)])) + (c23 * A[(((i + 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)])) + (c31 * A[(((i - 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)])) + (c33 * A[(((i + 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k - 1)])) + (c12 * A[(((i + 0) * (1024 * 1024)) + ((j - 1) * 1024)) + (k + 0)])) + (c22 * A[(((i + 0) * (1024 * 1024)) + ((j + 0) * 1024)) + (k + 0)])) + (c32 * A[(((i + 0) * (1024 * 1024)) + ((j + 1) * 1024)) + (k + 0)])) + (c11 * A[(((i - 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k + 1)])) + (c13 * A[(((i + 1) * (1024 * 1024)) + ((j - 1) * 1024)) + (k + 1)])) + (c21 * A[(((i - 1) * (1024 * 1024)) + ((j + 0) * 1024)) + (k + 1)])) + (c23 * A[(((i + 1) * (1024 * 1024)) + ((j + 0) * 1024)) + (k + 1)])) + (c31 * A[(((i - 1) * (1024 * 1024)) + ((j + 1) * 1024)) + (k + 1)])) + (c33 * A[(((i + 1) * (1024 * 1024)) + ((j + 1) * 1024)) + (k + 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3DCONV/3DConvolution_cpu/2"}
{"code": "for (int i = 0; i < num_procs; i++)\n{\n  countsA[i] = numberOfLine;\n  displsA[i] = dispA;\n  countsB[i] = numberOfLine;\n  displsB[i] = dispB;\n  if (i >= startingIndice)\n  {\n    countsA[i] += 1;\n    countsB[i] += 1;\n  }\n\n  dispB += countsA[i];\n  countsA[i] *= N;\n  dispA += countsA[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aurelienspnll/matrix-mult-ring-rotation/matrix-mult-ring-rotation/3"}
{"code": "for (i = curr->row; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    if (curr->Grid->assigned[i][j] == 0)\n    {\n      curr->row = i;\n      curr->col = j;\n      cond = 1;\n      i = SIZE;\n      j = SIZE;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/18"}
{"code": "for (i = 0; i < V; i += step)\n{\n  for (j = 0; j < V; j++)\n  {\n    unsigned short distKJ = graph[k][j];\n    if (distKJ == infinity)\n      continue;\n\n    for (ii = i; ii < (i + step); ii++)\n    {\n      if (ii == V)\n        break;\n\n      if (graph[ii][j] > (graph[ii][k] + distKJ))\n      {\n        graph[ii][j] = graph[ii][k] + distKJ;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/4"}
{"code": "for (; (i + 3) < n; i += 4)\n{\n  xv[0] = _mm256_loadu_pd(&x[i + 0]);\n  _mm256_storeu_pd(&y[i + 0], xv[0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/23"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    int k;\n    for (k = 0; k < 1024; k++)\n    {\n      D[(i * 1024) + j] += (12435 * A[(i * 1024) + k]) * A[(j * 1024) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/SYRK/src/syrk/5"}
{"code": "for (k = 1; k < 10; k++)\n  if (puc_posar(i, j, k, thread))\n{\n  taules[thread].taula[i][j] = k;\n  if (j < 8)\n    s += recorrer(i, j + 1, thread);\n  else\n    if (i < 8)\n    s += recorrer(i + 1, 0, thread);\n  else\n    s++;\n\n\n  taules[thread].taula[i][j] = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/5"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Thread=%d performing row=%d\\n\", tid, i);\n  for (j = 0; j < 10; j++)\n    for (k = 0; k < 10; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Dynamic/main/3"}
{"code": "for (i = 0; i <= (10 - 1); i++)\n{\n  gc = gc + q[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/EP/ep/7"}
{"code": "for (int i = 1; i < (m + 1); i++)\n{\n  for (int j = 1; j < (n + 1); j++)\n  {\n    if (A[i - 1] == B[j - 1])\n    {\n      DP[j] = prev_row[j - 1] + 1;\n    }\n    else\n    {\n      DP[j] = (prev_row[j] > DP[j - 1]) ? (prev_row[j]) : (DP[j - 1]);\n    }\n\n  }\n\n  for (int j = 0; j < (n + 1); j++)\n  {\n    prev_row[j] = DP[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Tool/find_lcs/1"}
{"code": "for (int xy = 0; xy < (WIDTH * HEIGHT); xy++)\n{\n  const int x = xy % WIDTH;\n  const int y = xy / WIDTH;\n  bool edge;\n  pixel_t pixel;\n  edge = detect_edge(sketch, &pixel, x, y);\n  pixel = (edge) ? (white) : (pixel);\n  pixmap_put_pixel(image, pixel, x, y);\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/02.edge/00.cpu/mandelbrot/0"}
{"code": "for (i = 0; i < 11; i++)\n{\n  size = strlen(semiConservative_str[i]);\n  for (x = 0; x < (size - 1); x++)\n  {\n    for (y = x + 1; y < size; y++)\n    {\n      scoringMatrix[semiConservative_str[i][x] - 'A'][semiConservative_str[i][y] - 'A'] = -weights[2];\n      scoringMatrix[semiConservative_str[i][y] - 'A'][semiConservative_str[i][x] - 'A'] = -weights[2];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarinDev/Parallel-Sequence-Alignment/src/main/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpwve4swpg.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francesc0rtu/Parallel-kd-tree/test/04-for/4"}
{"code": "for (i = 0; i < 73; i++)\n  a[i]++;\n\n", "pragma": "omp parallel for schedule(nonmonotonic: dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/nonmonotonic-1/0"}
{"code": "for (vertex = 0; vertex < num_vertices; vertex++)\n{\n  if ((node_dist[vertex] < min_dist_thread) && (visited_node[vertex] == 0))\n  {\n    min_dist_thread = node_dist[vertex];\n    min_node_thread = vertex;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/0"}
{"code": "for (int i = 0; i < pcinfo.x_cells_num; i++)\n{\n  f[(0 * pcinfo.x_cells_num) + i] = 0;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/14"}
{"code": "for (i = 0; i < (*myPointsSize); i++)\n  MPI_Recv(&(*myPoints)[i], 1, MPI_POINT_TYPE, MASTER, 0, MPI_COMM_WORLD, &status);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/2"}
{"code": "for (unsigned int i = 0; i < N; ++i)\n{\n  sum_omp += (sqrt(array_omp[i]) + pow(array_omp[i], 1.5)) / ((i * i) + 1);\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum_omp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bbercovici/openMP_demo/source/main/5"}
{"code": "for (int i = 0; i < y.size(); i++)\n  result += y[i];\n\n", "pragma": "#pragma omp parallel for reduction(+:result) shared(y) default(none)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gjbex/training-material/Accelerators/Thrust/vectors_omp/1"}
{"code": "for (i = 0; i < array_size; i++)\n  printf(\"Array[%d]=%f\\n\", i, Array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ksheeraj1161/OpenMP-MPI/OpenMP/program5/1"}
{"code": "for (i = 1; i < 1000; i++)\n{\n  b[i] = a[i] - a[i - 1];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/simoatze/archer_race_examples/data-race02/1"}
{"code": "for (int i = 0; i < this->fields.size(); ++i)\n{\n  int x = i % this->width;\n  int y = floor(((double) i) / ((double) this->height));\n  int sum = 0;\n  for (int row = -horizon; row <= horizon; row++)\n    for (int col = -horizon; col <= horizon; col++)\n  {\n    if ((row == 0) && (col == 0))\n      continue;\n\n    int neiX = x + row;\n    int neiY = y + col;\n    if (neiX < 0)\n      neiX = width - 1;\n    else\n      if (neiX >= width)\n      neiX = 0;\n\n\n    if (neiY < 0)\n      neiY = height - 1;\n    else\n      if (neiY >= height)\n      neiY = 0;\n\n\n    if (fields[(neiX * width) + neiY].prev)\n      sum++;\n\n  }\n\n\n  Classic(i, sum);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/1/console/GameOfLife/1"}
{"code": "for (buffer_i = 0; buffer_i < cellH; buffer_i++)\n{\n  for (buffer_j = 0; buffer_j < cellW; buffer_j++)\n  {\n    bufferRed[(buffer_i * cellW) + buffer_j] /= (float) counter[(buffer_i * cellW) + buffer_j];\n    bufferGreen[(buffer_i * cellW) + buffer_j] /= (float) counter[(buffer_i * cellW) + buffer_j];\n    bufferBlue[(buffer_i * cellW) + buffer_j] /= (float) counter[(buffer_i * cellW) + buffer_j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wutaosamuel/mosaic_OpenMP-CUDA/src/mosaic/2"}
{"code": "for (int i = 1; i < k; i++)\n{\n  ret -= (((double) nCk(k - 1, i - 1)) * cumulant(hist, b, i)) * moment(hist, b, k - i, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/16"}
{"code": "for (int j = 0; j < cols; j++)\n  result[j] = wall[0][j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_pathfinder/pathfinder/2"}
{"code": "for (step = 0; step < num_subintervals; ++step)\n{\n  const double x = a + (width * step);\n  riemann_integral_parallel += f(x) * width;\n}\n\n", "pragma": "\t\t#pragma omp for private(step) reduction(+:riemann_integral_parallel)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kr0nverk/Hello_Parallel_OpenMP/Integration/Integration/1"}
{"code": "for (int n = 2; n <= 25; ++n)\n  fac *= n;\n\n", "pragma": "omp parallel for reduction(*:fac)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JCisneros77/AdvancedProgrammingTask5/omp_reduction/0"}
{"code": "for (int j = data.iRowFirst; j <= data.iRowLast; j++)\n{\n  for (int i = 0; i < data.iCols; i++)\n  {\n    int xx = (int) ((-1.0) + (data.fDx * i));\n    int yy = (int) ((-1.0) + (data.fDy * j));\n    int xx2 = xx * xx;\n    int yy2 = yy * yy;\n    U(j, i) = 0.0;\n    F(j, i) = (((-data.fAlpha) * (1.0 - xx2)) * (1.0 - yy2)) + (2.0 * (((-2.0) + xx2) + yy2));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenCMISS-Dependencies/opari2/test/data/jacobi/C++/main/0"}
{"code": "for (int k = 1; k < num_threads; ++k)\n{\n  global_startingPosition[k] = global_startingPosition[k - 1] + global_elementsInBucket[k - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/main/4"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  u[i][0] = 100.0;\n  u[i][n - 1] = 100.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/InitGrid/0"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1418[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/75"}
{"code": "for (int i = 0; i < msz; ++i)\n  for (int j = 0; j < msz; ++j)\n  PA[IDX(i, j)] = A[IDX(P[i], j)];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zooltd/LU-decomposition/lu/10"}
{"code": "for (int32_t i = 0; i < 10; i++)\n  sum[i] += i;\n\n", "pragma": "omp for reduction(my_add : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_08/0"}
{"code": "for (i = 0; i < _Q; i++)\n{\n  iter_2 = i * _K;\n  for (k = 0; k < _K; k++)\n  {\n    sumWl1 += (_W[iter_2 + k] < 0) ? (-_W[iter_2 + k]) : (_W[iter_2 + k]);\n    sumWl2 += _W[iter_2 + k] * _W[iter_2 + k];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(_Q,_K) private(i,k) reduction(+:sumWl1,sumWl2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afarasat/ParallelSparseMatrixFactorization_OpenMP/solution/3"}
{"code": "for (i = 0; i < nclusters; i++)\n{\n  for (j = 0; j < ncolumns; j++)\n  {\n    if (cmask[i][j] > 0)\n    {\n      cdata[i][j] /= cmask[i][j];\n      cmask[i][j] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/53"}
{"code": "for (c1 = 0; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/39"}
{"code": "for (i = 0; i <= (bottom - top); i++)\n  for (j = 0; j <= (right - left); j++)\n  m_set_val(result, i, j, ((double) image[(((height - 1) - (i + top)) * width) + (j + left)]) * scale);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/2"}
{"code": "for (int i = 0; i < count; i++)\n{\n  count_characters(input[i], occurrences_map[i]);\n  qsort(occurrences_map[i], 256, sizeof(element_t), compare);\n}\n\n", "pragma": "omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par2/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 20) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    int failed = 0;\n    switch ('S')\n    {\n      case 'S':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'W':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 2)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'D':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n    }\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/34"}
{"code": "for (thread = 0; thread < thread_count; thread++)\n{\n  pthread_join(thread_handles[thread], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/7"}
{"code": "for (int i = 0; i < width; i++)\n  temp.push_back(0.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/2/Matrix/0"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/14"}
{"code": "for (i = 0; i < quantidadePiorCasoB; i++)\n{\n  printf(\"%d \", vetor_recB[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/6"}
{"code": "for (int i = 0; i < urls.size(); i++)\n{\n  this->cv_conduit(urls[i]);\n}\n\n", "pragma": "    #pragma omp parallel for if(urls.size() >= threshold)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barbracunningham/Donne/donne/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = ((x[i] - xmin) / (xmax - xmin)) * (xsize - 1);\n  y[i] = ((y[i] - ymin) / (ymax - ymin)) * (ysize - 1);\n  hsml[i] = (hsml[i] / (xmax - xmin)) * (xsize - 1);\n}\n\n", "pragma": "omp parallel for firstprivate(n,xmin,xmax,ymin,ymax,xsize,ysize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/scenemodule/3"}
{"code": "for (my_current_person_id = 0; my_current_person_id <= (our_number_of_people - 1); my_current_person_id++)\n{\n  if (our_states[my_current_person_id] == INFECTED)\n  {\n    our_num_days_infected[my_current_person_id]++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(my_current_person_id)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/pandemic/pandemic/7"}
{"code": "for (int j = jb * 8; j < ((jb + 1) * 8); j++)\n{\n  for (int k = kb * 8; k < ((kb + 1) * 8); k++)\n  {\n    Bwrk[((k % 8) * 8) + (j % 8)] = B[(k * Mdim) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/mm_gpu_block_allocate_directive/1"}
{"code": "for (size_t q = 0; q < Nqd; q++)\n{\n  PolPol.setZero();\n  PolPol = (quadss(q, 2) * Polt.block(q, 0, 1, k + 1).transpose()) * Poltau.block(q, 0, 1, k + 1);\n  for (size_t i = 0; i < Nelt; i++)\n  {\n    Kdq(i, i) = Kdiag(q, i);\n  }\n\n  K += kron(Kdq, PolPol);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/9"}
{"code": "for (int x = (-row) / 2; x <= (row / 2); x++)\n{\n  for (int y = (-column) / 2; y <= (column / 2); y++)\n  {\n    coordSum = (x * x) + (y * y);\n    filter[x + (row / 2)][y + (column / 2)] = exp((-coordSum) / constant) / (M_PI * constant);\n    sum += filter[x + (row / 2)][y + (column / 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Driblinho/video-filter-openmp/Filter/OpenMP/edge_detection_omp/0"}
{"code": "for (int j = 0; j < size_u[0]; j++)\n{\n  for (int k = 0; k < size_u[1]; k++)\n  {\n    fprintf(arquivo, \"%.20f \", ut0[(j * size_u[0]) + k]);\n  }\n\n  fprintf(arquivo, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation_cpu/1"}
{"code": "for (i = 0; i < 12; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/krb5pa-sha1_fmt_plug/2"}
{"code": "for (i = 0; i < img_size; i++)\n{\n  hist_buff[id][img_in[i]]++;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/delafuente28/Parallel-Computing-Contrast-Enhancement/OpenMP/histogram-equalization/1"}
{"code": "for (int i = 0; i < ncon; i++)\n{\n  data.push_back(ind->constr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/16"}
{"code": "for (i = 0; i < m; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    printf(\"%02d \", *((*(matrix + i)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/haalon-old/mpi-openmp/omp/3"}
{"code": "for (i = 0; i < 16; i++)\n  a[i + 80] = i + 80;\n\n", "pragma": "omp for schedule (nonmonotonic: runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/5"}
{"code": "for (ii = 0; ii < 200; ii++)\n{\n  if (XCheckTypedEvent(disp, ClientMessage, &event))\n  {\n    break;\n  }\n\n  draw_world(disp, back_buf, gc, world);\n  XCopyArea(disp, back_buf, win, gc, 0, 0, 1024, 768, 0, 0);\n  step_world(world, delta_t);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuanshengHu/Parallel-and-Distributed-Programming/2/nbody_openMP/4"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  x[i] = dist(gen);\n  y[i] = 0;\n  y_true[i] = (a * x[i]) + b;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elyaishere/sk_high_performance_computing/openmp/LeastSquares/0"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if (m_rchID[i] <= 0.f)\n    continue;\n\n  float qiAllLayers = 0.f;\n  for (int j = 0; j < CVT_INT(m_nSoilLyrs[i]); j++)\n  {\n    if (m_subSurfRfVol[i][j] > UTIL_ZERO)\n    {\n      qiAllLayers += m_subSurfRfVol[i][j] / m_dt;\n    }\n\n  }\n\n  tmp_qiSubbsn[CVT_INT(m_rchID[i])] += qiAllLayers;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SSR_DA/SSR_DA/5"}
{"code": "for (int count = 0; count < (V - 1); count++)\n{\n  int u = minDistance(dist, sptSet);\n  sptSet[u] = true;\n  for (int v = 0; v < V; v++)\n    if ((((!sptSet[v]) && graph[u][v]) && (dist[u] != INT_MAX)) && ((dist[u] + graph[u][v]) < dist[v]))\n    dist[v] = dist[u] + graph[u][v];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zsims92/All-Shortest-Paths-Optimized/allShortestPathsParallel/openmpDS/2"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    (cout << ts[(i * 3) + j]) << \"   \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCTools/getSupercell/6"}
{"code": "for (int ig = 0; ig < nspecies; ++ig)\n  mySpecies(membersize, ig) = ng[ig];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/11"}
{"code": "for (i = 0; i < numOfSamples; i++)\n{\n  output[i] = 0;\n  for (j = 0; j < numOfCoef; j++)\n  {\n    if ((i - j) >= 0)\n    {\n      output[i] += input[i - j] * coef[j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/immanuelsavio/Parallel-Processing-Using-OpenMP/fir/0"}
{"code": "for (col = 0; col < public.conv_cols; col++)\n{\n  #pragma loop name kernel#15#0\n  for (row = 0; row < public.conv_rows; row++)\n  {\n    ori_row = (row + public.in2_sub_cumh_sel_rowlow) - 1;\n    ori_col = (col + public.in2_sub_cumh_sel_collow) - 1;\n    temp = private.d_in2_sub[(ori_col * public.in2_sub_rows) + ori_row];\n    ori_row = (row + public.in2_sub_cumh_sel2_rowlow) - 1;\n    ori_col = (col + public.in2_sub_cumh_sel2_collow) - 1;\n    temp2 = private.d_in2_sub[(ori_col * public.in2_sub_rows) + ori_row];\n    temp2 = temp - temp2;\n    temp2 = temp2 - (private.d_in2_sub2_sqr[(col * public.conv_rows) + row] / public.in_mod_elem);\n    if (temp2 < 0)\n    {\n      temp2 = 0;\n    }\n\n    temp2 = sqrt(temp2);\n    temp2 = denomT * temp2;\n    private.d_conv[(col * public.conv_rows) + row] = private.d_conv[(col * public.conv_rows) + row] / temp2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/16"}
{"code": "for (int i = 0; i < size; i++)\n{\n  to[i] = from[i] * 2;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/copy/0"}
{"code": "for (int i = 0; i < MatrixSize; i++)\n{\n  (*m_pMatrix)[i]->clear();\n  delete(*m_pMatrix)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomdaniek/FloydWarshall/ProcedureControl/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"loop: %d, thread: %lu, iteration: %d\\n\", loop_index, 0, i);\n  loop_0[i] = 0;\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/11"}
{"code": "for (ind[2] = start[2]; ind[2] < end[2]; ind[2]++)\n{\n  double z = h[2] * ind[2];\n  for (ind[1] = start[1]; ind[1] < end[1]; ind[1]++)\n  {\n    double y = h[1] * ind[1];\n    for (ind[0] = start[0]; ind[0] < end[0]; ind[0]++)\n    {\n      double x = h[0] * ind[0];\n      omega0[2][ind] = (mag * gaussian(x, y, M_PI - dist, M_PI, width)) + (mag * gaussian(x, y, M_PI + dist, M_PI, width));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/exec/ns2/0"}
{"code": "for (int i = 2; i < ncx; ++i)\n{\n  for (int j = 2; j < ncy; ++j)\n  {\n    kBC = 2;\n    for (int k = 0; k <= 1; ++k)\n    {\n      s = columnMajorLinearIndex(i, j, k, ncx, ncy);\n      sBC = columnMajorLinearIndex(i, j, kBC, ncx, ncy);\n      setGhostCellVars(q, e, p, u, s, sBC);\n    }\n\n    kBC = nz + 1;\n    for (int k = nz + 2; k <= (nz + 3); ++k)\n    {\n      s = columnMajorLinearIndex(i, j, k, ncx, ncy);\n      sBC = columnMajorLinearIndex(i, j, kBC, ncx, ncy);\n      setGhostCellVars(q, e, p, u, s, sBC);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/rhic/jail/rhic-trunk/src/main/cpp/edu/osu/rhic/trunk/hydro/DynamicalVariables/2"}
{"code": "for (rowcount = 1, magrowptr = (mag + ncols) + 1, gxrowptr = (gradx + ncols) + 1, gyrowptr = (grady + ncols) + 1, resultrowptr = (result + ncols) + 1; rowcount <= (nrows - 2); rowcount++, magrowptr += ncols, gyrowptr += ncols, gxrowptr += ncols, resultrowptr += ncols)\n{\n  for (colcount = 1, magptr = magrowptr, gxptr = gxrowptr, gyptr = gyrowptr, resultptr = resultrowptr; colcount <= (ncols - 2); colcount++, magptr++, gxptr++, gyptr++, resultptr++)\n  {\n    m00 = *magptr;\n    if (m00 == 0)\n    {\n      *resultptr = (unsigned char) 255;\n    }\n    else\n    {\n      xperp = (-(gx = *gxptr)) / ((float) m00);\n      yperp = (gy = *gyptr) / ((float) m00);\n    }\n\n    if (gx >= 0)\n    {\n      if (gy >= 0)\n      {\n        if (gx >= gy)\n        {\n          z1 = *(magptr - 1);\n          z2 = *((magptr - ncols) - 1);\n          mag1 = ((m00 - z1) * xperp) + ((z2 - z1) * yperp);\n          z1 = *(magptr + 1);\n          z2 = *((magptr + ncols) + 1);\n          mag2 = ((m00 - z1) * xperp) + ((z2 - z1) * yperp);\n        }\n        else\n        {\n          z1 = *(magptr - ncols);\n          z2 = *((magptr - ncols) - 1);\n          mag1 = ((z1 - z2) * xperp) + ((z1 - m00) * yperp);\n          z1 = *(magptr + ncols);\n          z2 = *((magptr + ncols) + 1);\n          mag2 = ((z1 - z2) * xperp) + ((z1 - m00) * yperp);\n        }\n\n      }\n      else\n      {\n        if (gx >= (-gy))\n        {\n          z1 = *(magptr - 1);\n          z2 = *((magptr + ncols) - 1);\n          mag1 = ((m00 - z1) * xperp) + ((z1 - z2) * yperp);\n          z1 = *(magptr + 1);\n          z2 = *((magptr - ncols) + 1);\n          mag2 = ((m00 - z1) * xperp) + ((z1 - z2) * yperp);\n        }\n        else\n        {\n          z1 = *(magptr + ncols);\n          z2 = *((magptr + ncols) - 1);\n          mag1 = ((z1 - z2) * xperp) + ((m00 - z1) * yperp);\n          z1 = *(magptr - ncols);\n          z2 = *((magptr - ncols) + 1);\n          mag2 = ((z1 - z2) * xperp) + ((m00 - z1) * yperp);\n        }\n\n      }\n\n    }\n    else\n    {\n      if ((gy = *gyptr) >= 0)\n      {\n        if ((-gx) >= gy)\n        {\n          z1 = *(magptr + 1);\n          z2 = *((magptr - ncols) + 1);\n          mag1 = ((z1 - m00) * xperp) + ((z2 - z1) * yperp);\n          z1 = *(magptr - 1);\n          z2 = *((magptr + ncols) - 1);\n          mag2 = ((z1 - m00) * xperp) + ((z2 - z1) * yperp);\n        }\n        else\n        {\n          z1 = *(magptr - ncols);\n          z2 = *((magptr - ncols) + 1);\n          mag1 = ((z2 - z1) * xperp) + ((z1 - m00) * yperp);\n          z1 = *(magptr + ncols);\n          z2 = *((magptr + ncols) - 1);\n          mag2 = ((z2 - z1) * xperp) + ((z1 - m00) * yperp);\n        }\n\n      }\n      else\n      {\n        if ((-gx) > (-gy))\n        {\n          z1 = *(magptr + 1);\n          z2 = *((magptr + ncols) + 1);\n          mag1 = ((z1 - m00) * xperp) + ((z1 - z2) * yperp);\n          z1 = *(magptr - 1);\n          z2 = *((magptr - ncols) - 1);\n          mag2 = ((z1 - m00) * xperp) + ((z1 - z2) * yperp);\n        }\n        else\n        {\n          z1 = *(magptr + ncols);\n          z2 = *((magptr + ncols) + 1);\n          mag1 = ((z2 - z1) * xperp) + ((m00 - z1) * yperp);\n          z1 = *(magptr - ncols);\n          z2 = *((magptr - ncols) - 1);\n          mag2 = ((z2 - z1) * xperp) + ((m00 - z1) * yperp);\n        }\n\n      }\n\n    }\n\n    if ((mag1 > 0.0) || (mag2 > 0.0))\n    {\n      *resultptr = (unsigned char) 255;\n    }\n    else\n    {\n      if (mag2 == 0.0)\n        *resultptr = (unsigned char) 255;\n      else\n        *resultptr = (unsigned char) 128;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/20"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    arrayX[x] = xe;\n    arrayY[x] = ye;\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(arrayX, arrayY, xe, ye) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/1"}
{"code": "for (int i = 0; i <= sen.length(); i++)\n{\n  if (endword > finLength)\n  {\n    break;\n  }\n\n  senWord = substring(start, endword, sen);\n  if (senWord.compare(word) == 0)\n  {\n    count++;\n    if (endword > finLength)\n    {\n      break;\n    }\n\n  }\n\n  start += 1;\n  endword += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Francis-Alex-Kuzhippallil/Parallel-Word-Search-Using-OpenMP/Optimized Parallel Execution/1"}
{"code": "for (thread = 0; thread < thread_count; thread++)\n  pthread_join(thread_handles[thread], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Stankevix/Parallel-Computing/String Matching/Paralelo/substring/1"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    printf(\"%d %d\\n\", a[i][j], b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB113-default-orig-no/4"}
{"code": "for (int id = 0; id < (((sN + 2) * (_M + 2)) * (K + 2)); id++)\n{\n  Htmp[id].resize(sum_param);\n  for (int j = 0; j < sum_param; j++)\n    Htmp[id][j] = 0.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/80"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  n = ((m - 3) + 1) * 5;\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,j1 ,j ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/183"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  while (!is_ql_queue_empty(tmp_msgs, u->label))\n  {\n    message *m = dequeue(tmp_msgs, u->label);\n    if (!u_data->received_first_message)\n      enqueue(msgs, u->label, m);\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/3"}
{"code": "for (i = 0; i < DIM; i++)\n  mins_parall_red[i] = m[i][0];\n\n", "pragma": "#pragma omp parallel for shared(mins_parall_red, m) private(i) num_threads(num_threads) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/min_max_matrix_element/1"}
{"code": "for (int p = 0; p < sqrt(size); p++)\n{\n  sendCoords[0] = coords[0];\n  sendCoords[1] = p;\n  MPI_Cart_rank(comm, sendCoords, &sendRank);\n  timeCommStart = MPI_Wtime();\n  MPI_Irsend(localA, localMatrixSize, (MPI_Datatype) 0x4c00040a, sendRank, tagA, comm, &request1);\n  sendCoords[0] = p;\n  sendCoords[1] = coords[1];\n  MPI_Cart_rank(comm, sendCoords, &sendRank);\n  MPI_Irsend(localB, localMatrixSize, (MPI_Datatype) 0x4c00040a, sendRank, tagB, comm, &request2);\n  timeCommEnd = MPI_Wtime();\n  totalCommTime += timeCommEnd - timeCommStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eneskarali/mpi-openmp-matrix-multiplying/main/7"}
{"code": "for (int i = 1; i <= SIZE; i++)\n{\n  if ((i != twin1) && (i != twin2))\n  {\n    possiblevalues[row][col][i] = 0;\n    possiblevalues[row][uniquecol][i] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double ax = force_x[i] / mass[i];\n  double ay = force_y[i] / mass[i];\n  u[i] += ax * dt;\n  v[i] += ay * dt;\n  x[i] += u[i] * dt;\n  y[i] += v[i] * dt;\n  bounce(&x[i], &y[i], &u[i], &v[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/0"}
{"code": "for (i = 0; i < Noofelements; i++)\n  printf(\"\\t%d\", array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/prgm6/2"}
{"code": "for (int i = 0; i < (width * height); i++)\n{\n  island.push_back(0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/190"}
{"code": "for (int frame = 0; frame < frames; frame++)\n{\n  char name[32];\n  sprintf(name, \"fractal%d.bmp\", frame + 10000);\n  writeBMP(width, width, &big_array[(frame * width) * width], name);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/diegoloya/Hybrid_OMP_CUDA_MPI/fractal_hyb2/1"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  float line_start_x = value_x + ((1 + i) * 50);\n  float line_start_y = value_y - (thread_speedup[2][i] * 50);\n  float line_end_x = value_x + ((2 + i) * 50);\n  float line_end_y = value_y - (thread_speedup[2][i + 1] * 50);\n  line(line_start_x, line_start_y, line_end_x, line_end_y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nanyuu/Matrix-multiplication-OpenMP/OpenMP/4"}
{"code": "for (int i = gap; i < n; i += 1)\n{\n  int temp = arr[i];\n  int j;\n  for (j = i; (j >= gap) && (arr[j - gap] > temp); j -= gap)\n    arr[j] = arr[j - gap];\n\n  arr[j] = temp;\n}\n\n", "pragma": "omp parallel for default(private)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/sorting/shellsort/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\"Run %d \\n\", i);\n  updateMultipleArrayPerIteration(G, i);\n  sleep(2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/train/2"}
{"code": "for (int run = 0; run < nruns; ++run)\n{\n  for (int i = 0; i < N; ++i)\n    a[i] = cos(((i + (2.0 * run)) * 1.0) / 200);\n\n  for (int i = 0; i < N; ++i)\n    b[i] = cos(((i + (3.0 * run)) * 1.0) / 200);\n\n  sec = implementation8(a, b, N);\n  delta = sec - average_time;\n  average_time += delta / (run + 1);\n  standard_deviation += delta * (sec - average_time);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDX-Math-HSAP/openmp_intro/example codes/impls/4"}
{"code": "for (i = 0; i < dwg->size; i++)\n{\n  neighbors = dwg->edges + i;\n  if ((neighbors->count == 1) && (neighbors->addr->dest > i))\n  {\n    exchange.dest = neighbors->addr->dest;\n    exchange.k_i_in_dest = neighbors->addr->weight;\n    exchange.k_i_in_src = 0;\n    exchange.node = i;\n    apply_transfer_weighted(dwg, &cd, &exchange);\n    reduced_nodes++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, neighbors, exchange) reduction(+:reduced_nodes)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/vertex-following/0"}
{"code": "for (j = 0; j < pr_part_no; j++)\n{\n  move_particle(grid_sz, &par[j], grid, j);\n}\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/simpar/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    A[(i * N) + j] = A_next[(i * N) + j];\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(dynamic, 100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mtyutyulnikov/supercomputers_course/Task_2/example15/2"}
{"code": "for (t = 0; t < NT; t++)\n{\n  for (i = 0; i < NX; i++)\n  {\n    f << solution[((2 * t) * NX) + i];\n    if (i != (NX - 1))\n    {\n      f << \",\";\n    }\n\n  }\n\n  endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omi14098/Parallel-PDE-solvers/1D/omp1DPDE/2"}
{"code": "for (j = 0; j < y; j++)\n{\n  if (dom[i][j][k] == 0)\n  {\n    velocity_x += rho[i][j][k] * vx[i][j][k];\n    velocity_y += rho[i][j][k] * vy[i][j][k];\n    velocity_z += rho[i][j][k] * vz[i][j][k];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/data_explorer/1"}
{"code": "for (i = 0; i < n_p; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (C[(i * n) + j] != ((rank + 1) * n))\n      verify_failed = 1;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW3/matmul1d/4"}
{"code": "for (int i = numRounds - 1; i > 0; --i)\n{\n  invShiftRows(state);\n  invSubBytes(state);\n  addRoundKey(state, key, i);\n  invMixCols(state);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/2"}
{"code": "for (j = 0; j < 150; j++)\n{\n  v_scores[j] = 0.0;\n  for (i = 0; i < 150; i++)\n  {\n    v_scores[j] += matrix[i][j] / rowsums[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/48"}
{"code": "for (int i = 0; i < m_threads; ++i)\n{\n  media = media + best_sol[i];\n  if (i == 0)\n  {\n    best = best_sol[i];\n  }\n  else\n    if (best_sol[i] < best)\n  {\n    best = best_sol[i];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leandrosfj/OpenMP_CSA/C\u00f3digos/OMP_CSA/3"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  sum += h_c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-multiple-omp-parallel-for-combined-schedule-runtime/3"}
{"code": "for (int i = 0; i < vector.size(); i++)\n{\n  (cout << vector[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/7"}
{"code": "for (i = a; i < b; ++i)\n{\n  jp = out + i;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n  jp += 2 * m;\n  jp[0] = ip[0];\n  jp[m] = ip[1];\n  ip += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/7"}
{"code": "for (ii = 0; ii < (params.ny * params.nx); ii++)\n{\n  if (!obstacles[ii])\n  {\n    double *current_speed = cells[ii].speeds;\n    double u_x = (((current_speed[1] + current_speed[5]) + current_speed[8]) - ((current_speed[3] + current_speed[6]) + current_speed[7])) / ((((((((current_speed[0] + current_speed[1]) + current_speed[2]) + current_speed[3]) + current_speed[4]) + current_speed[5]) + current_speed[6]) + current_speed[7]) + current_speed[8]);\n    double u_y = (((current_speed[2] + current_speed[5]) + current_speed[6]) - ((current_speed[4] + current_speed[7]) + current_speed[8])) / ((((((((current_speed[0] + current_speed[1]) + current_speed[2]) + current_speed[3]) + current_speed[4]) + current_speed[5]) + current_speed[6]) + current_speed[7]) + current_speed[8]);\n    double u = (u_x * u_x) + (u_y * u_y);\n    local_u += sqrt(u);\n  }\n  else\n    ++local_cells;\n\n}\n\n", "pragma": "omp for private(ii, jj) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk/2"}
{"code": "for (i = 0; i < 15; i++)\n  for (j = 0; j < 7; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sugiartocokrowibowo/openmp-exercises/omp_mm/1"}
{"code": "for (size_t whichDim = 0; whichDim < DIM_value; whichDim++)\n{\n  for (size_t i = 0; i < K_value; i++)\n  {\n    tolerance_sum += pow(data.oldCentroids[i + (whichDim * data.K)] - data.currentCentroids[i + (whichDim * data.K)], 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jimmy3769tw/K-meansClusteringAlgorithm_OpenCLandOpenMP/src/kmeansAOSp/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 0.0;\n  for (j = 0; j < n; j++)\n    b[i] += A[i][j] * x[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/3"}
{"code": "for (i = 4; i < 846; i++)\n{\n  largeIndex = indexOfLargestElement(buffer_values, 4);\n  largeValue = buffer_values[largeIndex];\n  if (v_scores[i] < largeValue)\n  {\n    buffer[largeIndex] = i;\n    buffer_values[largeIndex] = v_scores[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/36"}
{"code": "for (i = 0; i < 10; i++)\n{\n  temp = loop_optimized_parallel_dynamic(l, m, n, num_t, i);\n  average_dt += temp[0];\n  average_rate += temp[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/6"}
{"code": "for (int k = 0; k < 12; ++k)\n{\n  for (int i = 0; i < 10; ++i)\n  {\n    int t = 0;\n    for (int j = 0; j < 5; ++j)\n    {\n      t += a[k][j] * b[j][i];\n    }\n\n    c[k][i] = t;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/khaledbendia/matrice_openmp/khaled_bendia_matrice_openmp/0"}
{"code": "for (i = 1; i < LX1; i++)\n{\n  idmo[iel][face][0][1][LX1 - 1][i] = mor_s_v[0][i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/22"}
{"code": "for (int i = 0; i < n1; ++i)\n{\n  for (int j = 0; j < n2; ++j)\n  {\n    (file << global_w1[i][j]) << \" \";\n  }\n\n  file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/4"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  vector_A[i] = i % 50;\n  vector_B[i] = i % 50;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task2/OpenMPtask2/0"}
{"code": "for (size_t i = 0; n != 0; n >>= 1, ++i)\n{\n  if (n & 1)\n    r = crc64_multiply_(r, crc64_x_pow_2n[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/crc64-omp/CRC64/6"}
{"code": "for (i = 0; i <= 500; i++)\n{\n  MPI_Start(&north_send[new_old]);\n  MPI_Start(&south_send[new_old]);\n  MPI_Start(&west_send[new_old]);\n  MPI_Start(&east_send[new_old]);\n  MPI_Start(&north_receive[new_old]);\n  MPI_Start(&south_receive[new_old]);\n  MPI_Start(&west_receive[new_old]);\n  MPI_Start(&east_receive[new_old]);\n  update(2, x - 3, 2, y - 3, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  MPI_Wait(&east_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&west_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&north_receive[new_old], (MPI_Status *) 1);\n  MPI_Wait(&south_receive[new_old], (MPI_Status *) 1);\n  update(1, x - 2, 1, 1, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(1, x - 2, y - 2, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(1, 1, 1, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  update(x - 2, x - 2, 1, y - 2, x, &data[new_old][0][0], &data[1 - new_old][0][0]);\n  MPI_Wait(&east_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&west_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&north_send[new_old], (MPI_Status *) 1);\n  MPI_Wait(&south_send[new_old], (MPI_Status *) 1);\n  new_old = 1 - new_old;\n  if ((i % 5) == 0)\n  {\n    send_convergence = diff_between_elements(x - 2, y - 2, data);\n    MPI_Allreduce(&send_convergence, &receive_convergence, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000005, cartesian);\n    if (receive_convergence == 1)\n    {\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MikeAndroulakis/MPI-simulation-program/mpi_openmp_convergence/1"}
{"code": "for (int curr_offset = first_offset; curr_offset < last_offset; curr_offset++)\n{\n  _curr_score = find_best_mutant_offset(data, curr_offset, &_temp_mutant);\n  if (is_swapable(&_best_mutant, &_temp_mutant, _best_score, _curr_score, data->is_max))\n  {\n    _best_mutant = _temp_mutant;\n    _best_mutant.offset = curr_offset;\n    _best_score = _curr_score;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/1"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  sequential_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/8"}
{"code": "for (int i = -1; i <= 1; i++)\n  for (int j = -1; j <= 1; j++)\n  if ((i != 0) || (j != 0))\n{\n  ix = ((i + ii) + imax) % imax;\n  jx = ((j + jj) + jmax) % jmax;\n  if (grid[ix][jx])\n    cnt++;\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/acse-hz6818/OpenMP_ConwaysGame/ConwaysGame_OpenMP/0"}
{"code": "for (int i = 0; i < size; i++)\n  b[i] = 1.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < n; j++)\n    sum += this->val[(i * n) + j] * other.val[j];\n\n  y[i] = sum;\n}\n\n", "pragma": "#pragma omp parallel for private(i, j, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/Matrix/4"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    energy1[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = energy1[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/14"}
{"code": "for (int i = 0; i < (size * size); i++)\n{\n  if (fprintf(file, \"%d\", arr[i]) != 1)\n  {\n    printf(\"Error failed to create the txt file\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/7"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n{\n  C[i][j] = 0;\n  D[i][j] = 0;\n  A[i][j] = drand48();\n  B[i][j] = drand48();\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab3_OpenMP/Test3_MultiplicacionMatrices/matrixMult/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  u[k][j][i][m] = temp[m];\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_uniformIndirectIndexedArrayRefs/0"}
{"code": "for (i = 0; i < r; ++i)\n{\n  for (j = 0; j < c; ++j)\n  {\n    fprintf(fptr, \"%f \", sum[i][j]);\n  }\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_2/6"}
{"code": "for (int idx = 0; idx < DATAXSIZE; idx++)\n{\n  for (int idy = 0; idy < DATAYSIZE; idy++)\n  {\n    for (int idz = 0; idz < DATAZSIZE; idz++)\n    {\n      double r = sqrt((SQ(idx - (0.5 * DATAXSIZE)) + SQ(idy - (0.5 * DATAYSIZE))) + SQ(idz - (0.5 * DATAZSIZE)));\n      if (r < r0)\n      {\n        u[idx][idy][idz] = 0.0;\n      }\n      else\n      {\n        u[idx][idy][idz] = (-delta) * (1.0 - exp(-(r - r0)));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-sycl/main/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  r = a[i][k];\n  for (j = 0; j < n; j++)\n    c[i][j] += r * b[k][j];\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * ((u[i][j - 2][k][m_imopVar133] - (4. * u[i][j - 1][k][m_imopVar133])) + (5. * u[i][j][k][m_imopVar133])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/69"}
{"code": "for (size_t y = 0; y < height; y++)\n{\n  for (size_t x = 0; x < width; x++)\n  {\n    data[get_index(x, y, width)] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bart1259/ConwayOpenMP/gameOfLife/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  P_mat[i] = (int *) malloc(size * (sizeof(int)));\n  result[i] = (double *) malloc(size * (sizeof(double)));\n  for (int j = 0; j < size; j++)\n  {\n    if (j == pi[i])\n      P_mat[i][j] = 1;\n    else\n      P_mat[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/3"}
{"code": "for (i = 0; i < 4000;)\n{\n  for (j = 0; j < 4000;)\n  {\n    A[i][j] = (((double) i) * j) / 4000;\n    j++;\n  }\n\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdruix/OMP2MPI/trans/test/1"}
{"code": "for (j = 0; j < (seq_num - 1); j++)\n{\n  data[(tid * seq_num) + j] += data[(tid * seq_num) - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle0/2"}
{"code": "for (int j = 0; j < threads_cnt; ++j)\n{\n  ret[j] = transform_function(test_input, N);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/gtests/transforms_test/5"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  Ncirc += cir[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/pi/pi_randomMethod/2"}
{"code": "for (k = 0; k < Nt; k++)\n  t[k] = 0 + (k * dt);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/7"}
{"code": "for (i = 0; i < V; i++)\n{\n  graphAdjArrayList->vertices[i].outNodes = 0;\n  graphAdjArrayList->vertices[i].out_degree = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjArrayList/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  A = a[i] + b[i];\n  B = (4 * a[i]) - b[i];\n  if ((A >= B) && (A > 1))\n    sum1 += A;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wolfram18/OpenMP-Practice/OpenMP-Project/Project345/Synchronization/2"}
{"code": "for (int i = 0; i < sze; ++i)\n{\n  Arr[i] += 1.0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for map(tofrom:Arr[0:sze])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kotsaloscv/target_offload_snippets/openmp_shared_lib/test_compute/0"}
{"code": "for (int i = 0; i < (walkers - 1); i++)\n{\n  int j = i + (rand() / ((32767 / (walkers - i)) + 1));\n  int t = index[j];\n  index[j] = index[i];\n  index[i] = t;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/sample_posterior_c_omp/3"}
{"code": "for (int j = 0; j < N; j++)\n{\n  for (int i = 0; i < N; i++)\n  {\n    if (P[i] == j)\n      A[N + i][j] = 1.0;\n    else\n      A[N + i][j] = 0.0;\n\n    for (int k = 0; k < i; k++)\n      A[N + i][j] -= A[i][k] * A[N + k][j];\n\n  }\n\n  for (int i = N - 1; i >= 0; i--)\n  {\n    for (int k = i + 1; k < N; k++)\n      A[N + i][j] -= A[i][k] * A[N + k][j];\n\n    A[N + i][j] = A[N + i][j] / A[i][i];\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/LU_Parallel_for/0"}
{"code": "for (int i = 0; i < MAX_TASK_QUEUE_CHUNKS; ++i)\n  taskInfo[i] = NULL;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/1"}
{"code": "for (buffer_i = 0; buffer_i < cellH; buffer_i++)\n{\n  for (buffer_j = 0; buffer_j < cellW; buffer_j++)\n  {\n    bufferRed[(buffer_i * cellW) + buffer_j] = 0;\n    bufferGreen[(buffer_i * cellW) + buffer_j] = 0;\n    bufferBlue[(buffer_i * cellW) + buffer_j] = 0;\n    counter[(buffer_i * cellW) + buffer_j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wutaosamuel/mosaic_OpenMP-CUDA/src/mosaic/0"}
{"code": "for (int i = 0; i < n1; i++)\n{\n  res[i] = (int *) malloc((sizeof(int)) * m2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/matrix/matrix/4"}
{"code": "for (int src = 0; src < m; src++)\n{\n  if (depth[src] < 0)\n  {\n    int row_begin = row_offsets[src];\n    int row_end = row_offsets[src + 1];\n    for (int offset = row_begin; offset < row_end; offset++)\n    {\n      int dst = column_indices[offset];\n      if (front.get_bit(dst))\n      {\n        depth[src] = depth[dst] + 1;\n        awake_count++;\n        next.set_bit(src);\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : awake_count) schedule(dynamic, 1024)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bfs/omp_target/0"}
{"code": "for (unsigned int id = 0; id < ITEMS; id += 4)\n{\n  A[id + 0] = id;\n  A[id + 1] = id + 1;\n  A[id + 2] = id + 2;\n  A[id + 3] = id + 3;\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hmazhar/ompeak/src/main/1"}
{"code": "for (int j = 0; j < rank; j++)\n{\n  for (int i = 0; i < rank; i++)\n    printf(\"%.2f \", A[(i * rank) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/5"}
{"code": "for (g6 = 0; g6 < 1; ++g6)\n{\n  int zk;\n  for (zk = 0; zk < 1; ++zk)\n  {\n    oh += zk / (zk + 1);\n    for (;;)\n    {\n    }\n\n  }\n\n  a6 = &zk;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/monellz/libgomp-aid/gcc/testsuite/gcc.dg/gomp/pr88105/0"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    if ((i == 0) || (j == 0))\n      K[i][j] = 0;\n    else\n      if (X[i - 1] == Y[j - 1])\n      K[i][j] = K[i - 1][j - 1] + 1;\n    else\n      K[i][j] = max(K[i - 1][j], K[i][j - 1]);\n\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarichandanaParimi/OPENMP_Advanced/lcs/lcs/0"}
{"code": "for (unsigned int i = 0; i < M.mesh.x_coordinates.size(); i++)\n{\n  int n = M.voxel_index(i, 0, 0);\n  (*M.p_density_vectors)[n] /= M.thomas_denomy[0];\n  n += M.thomas_j_jump;\n  for (unsigned int j = 1; j < M.mesh.y_coordinates.size(); j++)\n  {\n    axpy(&(*M.p_density_vectors)[n], M.thomas_constant1, (*M.p_density_vectors)[n - M.thomas_j_jump]);\n    (*M.p_density_vectors)[n] /= M.thomas_denomy[j];\n    n += M.thomas_j_jump;\n  }\n\n  n = M.voxel_index(i, M.mesh.y_coordinates.size() - 2, 0);\n  for (int j = M.mesh.y_coordinates.size() - 2; j >= 0; j--)\n  {\n    naxpy(&(*M.p_density_vectors)[n], M.thomas_cy[j], (*M.p_density_vectors)[n + M.thomas_j_jump]);\n    n -= M.thomas_j_jump;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_solvers/7"}
{"code": "for (int i = 1; i < (length - 1); i++)\n{\n  for (int j = 1; j < (length - 1); j++)\n  {\n    if (((i == ((length / 2) - 1)) || (i == (length / 2))) && ((j == ((length / 2) - 1)) || (j == (length / 2))))\n      continue;\n\n    output[(i * length) + j] = ((((((((input[((i - 1) * length) + (j - 1)] + input[((i - 1) * length) + j]) + input[((i - 1) * length) + (j + 1)]) + input[(i * length) + (j - 1)]) + input[(i * length) + j]) + input[(i * length) + (j + 1)]) + input[((i + 1) * length) + (j - 1)]) + input[((i + 1) * length) + j]) + input[((i + 1) * length) + (j + 1)]) / 9;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jonasblanc/CS-307-Assignments/Lab2/algorithm/0"}
{"code": "for (unsigned int i = 0; i < alliances.size(); i++)\n{\n  ((cout << \"Alliance \") << i) << \" : \";\n  for (unsigned int j = 0; j < alliances[i].size(); j++)\n  {\n    ((cout << \"**\") << alliances[i][j]) << \"**; \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoLR548/CPguacamole/Tarefa12/main/4"}
{"code": "for (part = 0; part < (n - 1); part++)\n  Compute_force_par(part, forces, curr, n);\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) schedule(dynamic, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/n_body/0"}
{"code": "for (i = 0; i < histogram_size; i++)\n{\n  histogram[i] = 0;\n  hist_temp[current_thread][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-Histogram/histogram/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][ny - 3][k][m] = rsd[i][ny - 3][k][m] - (dssp * (((u[i][ny - 5][k][m] - (4.0 * u[i][ny - 4][k][m])) + (6.0 * u[i][ny - 3][k][m])) - (4.0 * u[i][ny - 2][k][m])));\n  rsd[i][ny - 2][k][m] = rsd[i][ny - 2][k][m] - (dssp * ((u[i][ny - 4][k][m] - (4.0 * u[i][ny - 3][k][m])) + (5.0 * u[i][ny - 2][k][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/112"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 0; i <= (grid_points[0] - 1); i++)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      for (k = 0; k <= (grid_points[2] - 1); k++)\n      {\n        rhs[m][i][j][k] = forcing[m][i][j][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/5"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  arg[i] = i;\n  pthread_create(&p[i], &attr, t_pool, (void *) (arg + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souravmohapatra/parallel_bfs/bfs_parallel/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (m = 0; m < k; m++)\n  {\n    if (euc_distance[m][j] < mn)\n    {\n      mn = euc_distance[m][j];\n      kc[j] = m;\n    }\n\n  }\n\n  mn = 999999;\n  cenx[j] = (ceny[j] = 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/kMeans/4"}
{"code": "for (i = n - r; i < n; i++)\n{\n  for (j = 0; j < (((i - n) + r) + 1); j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n  for (j = i - r; j < n; j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonisstou/Optimization-of-C-program-by-rearrange-computations-and-parallelization-with-openmp/i_lif1d_omp/4"}
{"code": "for (i = 0; i < numOfProcesses; i++)\n{\n  index[i] = 8 * (i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petros-ioannidis/parallel_CGOL/OPENMP_CGOL/graph_main_openmp/6"}
{"code": "for (int i = 0; i < numVertices; i++)\n{\n  for (int j = 0; j < numVertices; j++)\n  {\n    randomValue = rand() % 20;\n    if (randomValue == 0)\n    {\n      randomValue = 9999;\n    }\n\n    randomGraph[i][j] = randomValue;\n    randomGraph[j][i] = randomValue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JFcoZC/PrimMSTParallelOpenMP/PrimSTPOpenMP/3"}
{"code": "for (int i = 0; i < col_numbers; i++)\n{\n  if (i < vertex_numbers)\n  {\n    col_group[i] = (-1) - i;\n  }\n  else\n  {\n    col_group[i] = ((i - vertex_numbers) / m_db->color_num()) + 1;\n  }\n\n  (cout << col_group[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/21"}
{"code": "for (int globalID = 0; globalID < globalWorkSize; globalID++)\n{\n  int iState;\n  int iState1;\n  int iStateM;\n  int iOut;\n  unsigned int mti;\n  unsigned int mti1;\n  unsigned int mtiM;\n  unsigned int x;\n  unsigned int mt[MT_NN];\n  unsigned int matrix_a;\n  unsigned int mask_b;\n  unsigned int mask_c;\n  matrix_a = h_MT[globalID].matrix_a;\n  mask_b = h_MT[globalID].mask_b;\n  mask_c = h_MT[globalID].mask_c;\n  mt[0] = h_MT[globalID].seed;\n  for (iState = 1; iState < MT_NN; iState++)\n    mt[iState] = ((1812433253U * (mt[iState - 1] ^ (mt[iState - 1] >> 30))) + iState) & MT_WMASK;\n\n  iState = 0;\n  mti1 = mt[0];\n  for (iOut = 0; iOut < nPerRng; iOut++)\n  {\n    iState1 = iState + 1;\n    iStateM = iState + MT_MM;\n    if (iState1 >= MT_NN)\n      iState1 -= MT_NN;\n\n    if (iStateM >= MT_NN)\n      iStateM -= MT_NN;\n\n    mti = mti1;\n    mti1 = mt[iState1];\n    mtiM = mt[iStateM];\n    x = (mti & MT_UMASK) | (mti1 & MT_LMASK);\n    x = (mtiM ^ (x >> 1)) ^ ((x & 1) ? (matrix_a) : (0));\n    mt[iState] = x;\n    iState = iState1;\n    x ^= x >> MT_SHIFT0;\n    x ^= (x << MT_SHIFTB) & mask_b;\n    x ^= (x << MT_SHIFTC) & mask_c;\n    x ^= x >> MT_SHIFT1;\n    h_RandGPU[globalID + (iOut * MT_RNG_COUNT)] = (((float) x) + 1.0f) / 4294967296.0f;\n  }\n\n}\n\n", "pragma": "        #pragma omp target teams distribute parallel for thread_limit(localWorkSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mt-omp/MT/2"}
{"code": "for (int x = 0; x < MAP_SIZE; ++x)\n{\n  for (int y = 0; y < MAP_SIZE; ++y)\n  {\n    currentShipPositions[x][y] = false;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(4) schedule(static, 256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stanley-chang/Parallel-Computing/OpenMP_Captain_Sparrow's_Return_to_Port_Royal/1"}
{"code": "for (int k = 0; k < HALO.z; k++)\n{\n  for (int j = 0; j < SDMGeom->L_NodeY(); j++)\n  {\n    for (int i = 0; i < SDMGeom->L_NodeX(); i++)\n    {\n      indx1 = (i + (j * NodLoc.x)) + ((k * NodLoc.y) * NodLoc.x);\n      indx2 = ((HALO.x + i) + ((j + HALO.y) * SDMGeom->HALO_NodeX())) + ((((k + SDMGeom->HALO_NodeZ()) - (2 * HALO.z)) * SDMGeom->HALO_NodeX()) * SDMGeom->HALO_NodeY());\n      BN[indx1] = DomLoc[indx2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_omp)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/9"}
{"code": "for (int i = dataSourceSize - howMuch, count = 2; i < dataSourceSize; i++, count++)\n{\n  setElementAt(count, col, to_string(data[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/inirion/MpiIndexowanie/Source/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    int k = (rank * stripe) + i;\n    int s = (((rank * stripe) + stripe) - 1) - i;\n    calculate(z, size, t, k, j);\n    calculate(z, size, t, s, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shirley1988/Wave-Simulation/mpdWave/0"}
{"code": "for (int i = 0; i < piv; i++)\n{\n  s = ((double) M[i][piv]) / M[piv][piv];\n  for (int j = 0; j < dim; j++)\n  {\n    D[i][j] -= ((float) s) * D[piv][j];\n    if (j <= piv)\n      M[i][j] -= s * M[piv][j];\n\n  }\n\n}\n\n", "pragma": "      #pragma omp parallel for private(i,j,s)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tecnarca/CPU-GPU-speed-comparison/src/openmp/1"}
{"code": "for (int n = 0; n < num_nodes; n++)\n{\n  triangle_sum += triangle_count_given_node(G, G.nodeFromId(n), look_up, degree_list, &extra_node_list);\n}\n\n", "pragma": "    #pragma omp for reduction(+:triangle_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhaofeng-shu33/triangle_counting/lemontc/counting/1"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int nodes_start_pos_i = (num_nodes / size) * i;\n  int nodes_local_num_i = num_nodes / size;\n  if (i == (size - 1))\n  {\n    nodes_local_num_i += num_nodes % size;\n  }\n\n  MPI_Send(x_buffer + (nodes_start_pos_i * read_size), nodes_local_num_i * read_size, MPI_CHAR, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyuejohn/Parallel-Programming-for-Graph-Convolutional-Neural-Networks/gcn_hybrid/2"}
{"code": "for (j = 0; j <= (m - 1); j += 1)\n{\n  b[i][j] = i + j;\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB037-truedepseconddimension-orig-yes/1"}
{"code": "for (i = 0; i < n; i++)\n  M1[i + 1] += M1[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Gauss_Seidal/1"}
{"code": "for (int i = 1; i < (a->num_strings - 1); i += 2)\n{\n  double alf = (-a->a(i)) / a->c(i - 1);\n  double beta = (-a->b(i)) / a->c(i + 1);\n  double aa = alf * a->a(i - 1);\n  double bb = ((alf * a->b(i - 1)) + a->c(i)) + (beta * a->a(i + 1));\n  double cc = beta * a->b(i + 1);\n  double dd = ((alf * f[i - 1]) + f[i]) + (beta * f[i + 1]);\n  b->content[(i - 1) / 2].push_back(aa);\n  b->content[(i - 1) / 2].push_back(bb);\n  b->content[(i - 1) / 2].push_back(cc);\n  g[(i - 1) / 2] = dd;\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonshting/mipt-openmp-mpi/openmp-mpi/06/main_omp/4"}
{"code": "for (long int idxLoop = 0; idxLoop < NbLoops; ++idxLoop)\n{\n  ompFibonnaci += FibonacciOmp(TestSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/fibonnaci/1"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].set_graph_ptr(full_graph);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/11"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    scanf(\"%d\", &a[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kundan-walunj/OpenMP-Projects/matrix_mul_openmp/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  cast_out->vec_[i] = cast_in->vec_[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/7"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    (*res)[i][j] = (P[i][j] + P[j][i]) * 0.5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/12"}
{"code": "for (int i = 0; i < result1.size(); i++)\n  (cout << result1[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task5/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  squared_sum += pow(q[i] - p[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/1"}
{"code": "for (i = s; i <= e; i++)\n{\n  if ((!connected[i]) && (mind[i] < (*d)))\n  {\n    *d = mind[i];\n    *v = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/2"}
{"code": "for (jj = 0; jj < size; jj += block_size)\n{\n  for (kk = 0; kk < size; kk += block_size)\n  {\n    for (i = 0; i < size; i++)\n    {\n      for (j = jj; j < (((jj + block_size) > size) ? (size) : (jj + block_size)); j++)\n      {\n        tmp = 0.0f;\n        for (k = kk; k < (((kk + block_size) > size) ? (size) : (kk + block_size)); k++)\n        {\n          tmp += matrixA[i][k] * matrixB[k][j];\n        }\n\n        matrixC[i][j] += tmp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iarchanaa/Large_Matrix_Multiplication_Using_openMP/LargeMatrixMultiplication/1"}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  mat_c[i] = malloc((sizeof(float)) * matrix_size);\n  for (j = 0; j < matrix_size; j++)\n  {\n    mat_c[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hgn/openmp-benchmark/para-bench/4"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/137"}
{"code": "for (int i = 0; i < NUM_POINTS_0; i++)\n{\n  Results[IndexT][i] = eta_phi[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/4"}
{"code": "for (i = len - 2; i >= 0; --i)\n{\n  float val = arr[i];\n  for (j = i; (j < maxJ) && (arr[j + 1] < val); ++j)\n  {\n    arr[j] = arr[j + 1];\n  }\n\n  arr[j] = val;\n  swapCount += j - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/6"}
{"code": "for (i = 1; i <= (N - 2); i++)\n{\n  double local_eps = eps;\n  for (j = 1; j <= (N - 2); j++)\n  {\n    double e;\n    e = fabs(A[i][j] - B[i][j]);\n    A[i][j] = B[i][j];\n    local_eps = (eps > e) ? (eps) : (e);\n  }\n\n  eps = (eps > local_eps) ? (eps) : (local_eps);\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dzhidzhoev/skpod-openmp/jacobi_2d/1"}
{"code": "for (int i = 1; i < max_rows; i++)\n{\n  input_itemsets_cpu[i * max_cols] = (-i) * penalty;\n  input_itemsets_gpu[i * max_cols] = (-i) * penalty;\n  for (int j = 1; j < max_cols; j++)\n  {\n    input_itemsets_cpu[j] = (-j) * penalty;\n    input_itemsets_gpu[j] = (-j) * penalty;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/nw/src/needle/5"}
{"code": "for (int i = low, j; i <= high; i++)\n{\n  int temp = array[i];\n  for (j = i - 1; (j >= low) && (array[j] > temp); j--)\n  {\n    array[j + 1] = array[j];\n  }\n\n  array[j + 1] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Mergesort_Serial_Parallel/2"}
{"code": "for (i = 90; i < 100; i++)\n  is = is + i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lastprivate0/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  col_1[i] = C_n[i][0];\n  col_n[i] = C_n[i][N - 1];\n}\n\n", "pragma": "        #pragma omp parallel for default(none) private(i) shared(col_1, col_n, C_n, N) schedule(guided)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/final-version/advection_simulation/5"}
{"code": "for (int i = 0; i < N; i++)\n  printf(\"%*d \", 2, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/forestdan/OpenMPLearn/src/09_scan/3"}
{"code": "for (int i = 0; i < ((N + 2) * (N + 2)); ++i)\n{\n  err = (err > fabs(u[i] - (f[i] / ((((h * h) * 2.0) * 3.14159265359) * 3.14159265359)))) ? (err) : (fabs(u[i] - (f[i] / ((((h * h) * 2.0) * 3.14159265359) * 3.14159265359))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/hwk3/hw03/3"}
{"code": "for (int k = 0; k < n; k++)\n  d += (((origin[f[k].p0] + origin[f[k].p3]) - origin[f[k].p1]) - origin[f[k].p2]) * f[k].w;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvsurf/0"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  a[i] = a[i] + a[0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB040-truedepsingleelement-var-yes/0"}
{"code": "for (long i = 0; i < (MaxDegree * NVer); i++)\n  Mark[i] = -1;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringDistanceOne/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (long j = 0; j < n; j++)\n  {\n    ResM[i][j] = M1[i][j] - M2[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/strassen_mul_2d_omp/2"}
{"code": "for (int jj = HALO_PAD; jj < (yMax - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD - depth; kk < HALO_PAD; ++kk)\n  {\n    int bufIndex = (kk - (HALO_PAD - depth)) + ((jj - HALO_PAD) * depth);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel/4"}
{"code": "for (i = 0; i < (MAX_KEY - 1); i++)\n  prv_buff1[i + 1] += prv_buff1[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/9"}
{"code": "for (i = 0; i <= 1000000000; i++)\n  v[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/getmiranda/sieve_eratosthenes_openmp/SieveOpenMP/1"}
{"code": "for (i = 0; i < n; i++)\n  stddiv += pow(input[i] - avg, 2);\n\n", "pragma": "omp parallel for schedule(static) private(i) reduction(+:stddiv)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Terminus-IMRC/stddev_openmp/stddev/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  d -= i + 1;\n  e -= i + 1.0f;\n}\n\n", "pragma": "omp simd for reduction(-:d, e)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/success_simd_07_reduction_parallel/1"}
{"code": "for (size_t j = 0; j < chunkNum; ++j)\n{\n  size_t listLen = quantile.buffers[1][j] - quantile.buffers[0][j];\n  if (listLen)\n  {\n    size_t uLen = listLen & factornot;\n    if (uLen < listLen)\n      unalignVec.insert(unalignVec.end(), (data.Current() + quantile.buffers[0][j]) + uLen, data.Current() + quantile.buffers[1][j]);\n\n    if (uLen)\n    {\n      start[cLen] = data.Current() + quantile.buffers[0][j];\n      end[cLen] = (data.Current() + quantile.buffers[0][j]) + uLen;\n      ++cLen;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/20"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/13"}
{"code": "for (size_t i = 0; i < pixVol; i++)\n  checkSum += h_pVolume[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/19"}
{"code": "for (i = 0; i < neighbor_nodes->count; i++)\n{\n  if ((*(cd->vertex_community + (neighbor_nodes->addr + i)->dest)) == current_community)\n    *current_community_k_i_in += (neighbor_nodes->addr + i)->weight;\n  else\n    if (!sorted_linked_list_insert(sll, *(cd->vertex_community + (neighbor_nodes->addr + i)->dest), (neighbor_nodes->addr + i)->weight))\n  {\n    ;\n    sorted_linked_list_free(sll);\n    free(sll);\n    return 0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/community-computation-weighted/11"}
{"code": "for (i = 0; i <= h; ++i)\n{\n  glVertex3f(ox, oy, oz + (i * sz));\n  glVertex3f(ox + (w * sz), oy, oz + (i * sz));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/4"}
{"code": "for (int mat = (cc.Nmats / 2) + 1; mat < cc.Nmats; mat++)\n{\n  for (int j = (sizey / 2) - 3; j < ((sizey / 2) - 1); j++)\n    for (int i = 2; i < 5; i++)\n  {\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n  for (int j = sizey / 2; j < ((sizey / 2) + 2); j++)\n    for (int i = 2; i < 4; i++)\n  {\n    if ((i < 3) && (only_8 < 6))\n    {\n      cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    }\n\n    if ((i == 2) && (only_8 == 0))\n    {\n      cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.rho[((((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    }\n\n    if (((mat >= (cc.Nmats - 8)) && (j == ((sizey / 2) + 1))) && (i == 3))\n      if ((only_8++) >= 4)\n    {\n      break;\n    }\n\n\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/6"}
{"code": "for (int j = k; (j < (k + slot)) && (j < n); ++j)\n{\n  pr[j] = pr[j] + diff;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ManjunathBirajdar/OpenMP-Parallelism/openmp-looping-parallelism/prefixsum/prefixsum/1"}
{"code": "for (size_t y = 0; y < height; y++)\n{\n  for (size_t x = 0; x < width; x++)\n  {\n    int neighbors = get_neighbors(x, y);\n    if (neighbors <= 1)\n    {\n      buffer[get_index(x, y, width)] = 0;\n    }\n    else\n      if (neighbors >= 4)\n    {\n      buffer[get_index(x, y, width)] = 0;\n    }\n    else\n      if (neighbors == 3)\n    {\n      buffer[get_index(x, y, width)] = 1;\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bart1259/ConwayOpenMP/gameOfLife/3"}
{"code": "for (numt = 1; numt <= size; numt++)\n{\n  omp_set_num_threads(numt);\n  setZero(C);\n  double r1 = mulStatic(A, B, C, (int) floor(((float) size) / numt));\n  setZero(C);\n  double r2 = mulDynamic(A, B, C, (int) floor(((float) size) / numt));\n  setZero(C);\n  double r3 = mulGuided(A, B, C, (int) floor(((float) size) / numt));\n  (((((((res << numt) << \",\") << r1) << \",\") << r2) << \",\") << r3) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part1/Asgn1/0"}
{"code": "for (i = 0; i < ng; i++)\n  for (j = 0; j < ng; j++)\n  for (k = 0; k < ng; k++)\n{\n  pfft(p_delta, i, j, k)->Re = 0.0;\n  pfft(p_delta, i, j, k)->Im = 0.0;\n}\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/mass_assign/0"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  double x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "  #pragma omp parallel for shared(sum)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hachreak/parallel_computing-demo/openmp/04_pgreek/0"}
{"code": "for (int i = 0; i < numPts; i++)\n{\n  points[i].x = rand() % width;\n  points[i].y = rand() % height;\n  points[i].z = rand() % 256;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ne-omp/main/0"}
{"code": "for (i = 0; i < Ndim; i++)\n  for (j = 0; j < Mdim; j++)\n  *(C + ((i * Ndim) + j)) = 0.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/MatrixMultiplication/mmmult_for/3"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i - 1][j][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/27"}
{"code": "for (int i = 0; i < nt; i++)\n{\n  sum[nt] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/pi/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  m1[i] = (double *) malloc(n * (sizeof(double)));\n  m2[i] = (double *) malloc(n * (sizeof(double)));\n  resultado[i] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp3/ejer9/pmm-OpenMP/2"}
{"code": "for (i = 0; i < 3; i++)\n{\n  logd[i] = ilog2(d[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/FT/ft/12"}
{"code": "for (int i = 0; i < points_size; i++)\n{\n  points[i].x = GenerateRandomDouble(0, 10);\n  points[i].y = GenerateRandomDouble(0, 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stavBodik/Parallel-K-Means-implementation/Parallel_implementation_K_Means_15_sequentional/Parallel_implementation_K_Means_15/Main/4"}
{"code": "for (int i = 0; i < n; i++)\n  dp[(i * n) + i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/MatrixChainMultiplication/main/2"}
{"code": "for (int i = 0; i < E; i++)\n{\n  int u = graph->edge[i].src;\n  int v = graph->edge[i].dest;\n  int weight = graph->edge[i].weight;\n  if ((dist[u] != INT_MAX) && ((dist[u] + weight) < dist[v]))\n  {\n    printf(\"Graph contains negative weight cycle\");\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/varun2011/openmp/bell/3"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  for (k = 0; k < n; k++)\n  c[i][j] += a[i][k] * b[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/mat_mul/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET_VERBOSE(default_errors, a[i] != i);\n  OMPVV_TEST_AND_SET_VERBOSE(p_errors, b[i] != (i + 1));\n  OMPVV_TEST_AND_SET_VERBOSE(t_errors, c[i] != (i + 2));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_variant/test_declare_variant/4"}
{"code": "for (ii = 0; ii < nlocalverts; ii += ulong_bits)\n{\n  size_t i;\n  size_t i_end = ii + ulong_bits;\n  if (i_end > nlocalverts)\n    i_end = nlocalverts;\n\n  for (i = ii; i < i_end; ++i)\n  {\n    if (!((visited[i / ulong_bits] & (1UL << (i % ulong_bits))) != 0))\n    {\n      size_t j;\n      size_t j_end = rowstarts[i + 1];\n      for (j = rowstarts[i]; j < j_end; ++j)\n      {\n        int64_t v1 = column[j];\n        int64_t v1_swizzled = ((VERTEX_OWNER(v1) << lg_local_queue_size) * ulong_bits) | VERTEX_LOCAL(v1);\n        if (((in_queue_summary[(v1_swizzled / ulong_bits) / ulong_bits] & (1UL << ((v1_swizzled / ulong_bits) % ulong_bits))) != 0) && ((in_queue[v1_swizzled / ulong_bits] & (1UL << (v1_swizzled % ulong_bits))) != 0))\n        {\n          pred[i] = (v1 & INT64_C(0xFFFFFFFFFFFF)) | (((int64_t) cur_level) << 48);\n          not_done |= 1;\n          do\n          {\n            size_t word_idx = i / ulong_bits;\n            int bit_idx = i % ulong_bits;\n            unsigned long mask = 1UL << bit_idx;\n            visited[word_idx] |= mask;\n            out_queue[word_idx] |= mask;\n          }\n          while (0);\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(|:not_done)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_replicated/1"}
{"code": "for (i = 0; i < comm->num_recvs; i++)\n  printf(\"%2d \", comm->recv_sizes[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/7"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = (-2.0) + ((2.5 * ((double) i)) / ((double) (1000 + eps)));\n    c.i = (1.125 * ((double) j)) / ((double) (1000 + eps));\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) firstprivate(eps) private(c,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlMikFox3/OpenMP-Codes/mandel/0"}
{"code": "for (j = 2; j < (n - 2); j++)\n  for (i = 2; i < (n - 2); i++)\n  out[i + (j * n)] = (float) 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/Stencil/stencil/0"}
{"code": "for (int i = 0; i < N; i++)\n  kvals[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/11"}
{"code": "for (i = 3; i < ((2 * pages) - 1); i++)\n{\n  A[i] = 0.5;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mithradatha/parallel-pagerank/sparse_omp/2"}
{"code": "for (j = 0; j < n; j++)\n  for (i = 0; i < m; i++)\n  fprintf(fp, \"%e\\n\", Q[j + (n * (i + (m * 0)))]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/10"}
{"code": "for (int i = 0; i < n; i++)\n  for (int k = 0; k < n; k++)\n{\n  int j = rand() % 10;\n  int g = rand() % 10;\n  a[i][k] = j;\n  b[i][k] = g;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shemetovElisey/OpenMP_PZ3/MPAA_PZ3/MPAA_PZ3/9"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  c[i] = malloc(num_particles_per_process * (sizeof(Point)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jankopanski/Three-Body-Problem/body3_mpi_omp/6"}
{"code": "for (j = 0; j < n; j++)\n{\n  if (j >= k)\n  {\n    R[((k - 1) * n) + j] = 0;\n    for (i = 0; i < n; i++)\n    {\n      R[(j * n) + (k - 1)] += Q[((k - 1) * n) + i] * A[(j * n) + i];\n    }\n\n    for (i = 0; i < n; i++)\n    {\n      A[(j * n) + i] = A[(j * n) + i] - (R[(j * n) + (k - 1)] * Q[((k - 1) * n) + i]);\n    }\n\n    if (j == k)\n    {\n      thrid = omp_get_thread_num();\n      r_sum = 0;\n      for (i = 0; i < n; i++)\n      {\n        r_sum = r_sum + (A[(k * n) + i] * A[(k * n) + i]);\n      }\n\n      R[(k * n) + k] = sqrt(r_sum);\n      for (i = 0; i < n; i++)\n      {\n        Q[(k * n) + i] = A[(k * n) + i] / R[(k * n) + k];\n      }\n\n      omp_unset_lock(&lock[k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geziogas/ParallelProgramming-Project/qr_par2/1"}
{"code": "for (int i = 0; i < HEIGHT; ++i)\n{\n  free(field_backup[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/11"}
{"code": "for (size_t i = 0; i < n; ++i)\n  (ss << \" \") << v[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/0"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n{\n  a1 = angle[previous[i]][j];\n  a2 = angle[next[i]][j];\n  a3 = angle[i][previous[j]];\n  a4 = angle[i][next[j]];\n  double resultRand;\n  drand48_r(&randBuffer, &resultRand);\n  aNew = angle[i][j] + (resultRand - 0.5);\n  if (useNew(ph->getProbability(a1, a2, a3, a4, angle[i][j], aNew), resultRand))\n  {\n    angleNew[i][j] = aNew;\n  }\n  else\n  {\n    angleNew[i][j] = angle[i][j];\n  }\n\n}\n\n\n", "pragma": "\t\t\t#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/Simulation/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((flowdir_matrix_[i] != dir_nodata_) && (flow_out_num_[i] == 0))\n  {\n    last_layer[num_last_layer++] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/9"}
{"code": "for (i = 0; i < l; i++)\n  x[i] = prob->x[perm[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/54"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  for (int j = 0; j < ny; j++)\n  {\n    f_t[i][j] = arr_t[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mircuz/travelling_wave/travelling_wave/support/4"}
{"code": "for (i = 0; i < c->nrows; ++i)\n  for (j = r->rowPtr[i]; j < r->rowPtr[i + 1]; ++j)\n  c->rowInd[j] = i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/6"}
{"code": "for (index = 0; index < count; index += 1 * SIMD_COEF_32)\n{\n  unsigned char buffer[16];\n  MD5_CTX ctx;\n  int n = 49999;\n  unsigned char hex_buffer[16 * 2];\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  MD5_Final(buffer, &ctx);\n  hex_encode_uppercase(buffer, hex_buffer);\n  do\n  {\n    MD5_Init(&ctx);\n    MD5_Update(&ctx, hex_buffer, 16 * 2);\n    MD5_Final(buffer, &ctx);\n    hex_encode_uppercase(buffer, hex_buffer);\n    --n;\n  }\n  while (n);\n  memcpy((unsigned char *) crypt_out[index], buffer, 16);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/zipmonster_fmt_plug/4"}
{"code": "for (i = 0; i < l; i++)\n  for (k = 0; k < n; k++)\n{\n  result = 0;\n  for (j = 0; j < m; j++)\n  {\n    result += A[(i * m) + j] * B[(j * n) + k];\n  }\n\n  C[(i * n) + k] = result;\n}\n\n\n", "pragma": "omp parallel for private(j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 1/matmul/0"}
{"code": "for (int i = 0; i < h; i++)\n{\n  for (int j = 0; j < w; j++)\n  {\n    pixels[i][j] = f(pixels[i][j]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(kind, chunk_size) shared(pixels)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MONICgh/OpenMP/lab04/4"}
{"code": "for (int i = 0; i < ROWS; i++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    float sum = 0.0;\n    for (int k = 0; k < COLUMNS; k++)\n    {\n      sum = sum + (matrix_a[i][k] * matrix_b[k][j]);\n    }\n\n    matrix_r[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/2"}
{"code": "for (i = 0; i < height; i++)\n{\n  int row = row_pointers[i];\n  for (j = 0; j < width; j++)\n  {\n    int px = &row[j * 4];\n    if (px[0] < minRed)\n      minRed = px[0];\n\n    if (px[0] > maxRed)\n      maxRed = px[0];\n\n    if (px[1] < minGreen)\n      minGreen = px[1];\n\n    if (px[1] > maxGreen)\n      maxGreen = px[1];\n\n    if (px[2] < minBlue)\n      minBlue = px[2];\n\n    if (px[2] > maxBlue)\n      maxBlue = px[2];\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/ContrastStretchingParallel/0"}
{"code": "for (i = 1; i <= (n - 2); i++)\n  for (j = 1; j <= i; j++)\n{\n  {\n    j_update += 1;\n  }\n  for (k = 1; k <= m; k++)\n  {\n    xk = (double) k;\n    xk2 = xk * xk;\n    b[i][j] += ((((a[i - 1][j] + a[i + 1][j]) + a[i][j + 1]) + a[i][j - 1]) / xk) + ((((a[i - 1][j + 1] + a[i - 1][j - 1]) + a[i + 1][j + 1]) + a[i + 1][j - 1]) / xk2);\n  }\n\n}\n\n\n", "pragma": "omp for schedule(...)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manoj1511/OpenMP/exercise_4/c_neighbor/0"}
{"code": "for (i = 0; i < n_size; i++)\n{\n  for (j = 0; j < n_size; j++)\n  {\n    {\n      for (r = 0; r < n_size; r++)\n      {\n        C[i][j] += A[i][r] * B[r][j];\n      }\n\n    }\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leandrosfj/OpenMP_Matrix/C\u00f3digos/paralelo_matriz_omp2/0"}
{"code": "for (int i = 2; i <= 13; i++)\n{\n  count++;\n  n = i;\n  double stime = serial();\n  double ptime = parallel();\n  printf(\"OpenMP is %lf times faster for n=%d\\n\", stime / ptime, n);\n  average += stime / ptime;\n  puts(\"===============\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shafaet/OpenMP-Examples/Parallel N-Queen problem/4"}
{"code": "for (int i = i; i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/41"}
{"code": "for (int i = 0; i < N; i++)\n{\n  s->Bt = s->sBt;\n  s->Bt[i] = s->Mcoefs_3d[1][1][i] * x[i];\n  if ((i - (sN + 2)) >= 0)\n    s->Bt[i] += s->Mcoefs_3d[1][0][i] * x[i - (sN + 2)];\n\n  if ((i + (sN + 2)) < N)\n    s->Bt[i] += s->Mcoefs_3d[1][2][i] * x[i + (sN + 2)];\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/151"}
{"code": "for (int i = 0; i < 4; i++)\n  pi += partial_sums[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/Q5-Calculation-of-pi/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/69"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (fabs(output[i] - expected_output[i]) > error_rate)\n  {\n    error_rate = fabs(output[i] - expected_output[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/geodesic-omp/main/1"}
{"code": "for (int i = 0; i < numTests; ++i)\n{\n  test[i] = (double *) malloc(((sizeof(double)) * numInputs) + 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/1"}
{"code": "for (numOfThreads = 1; numOfThreads <= 16; ++numOfThreads)\n{\n  max = MaxSearch(arr, height, length, true);\n  printf(\"%f\\n\", runtime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task1test/0"}
{"code": "for (i = 0; i < 100; i += step)\n  A[i]--;\n\n", "pragma": "omp for schedule(ompss_dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_ompss.dg/c/success_for_slicer_01/1"}
{"code": "for (int i = 0; i < num_edges; ++i)\n  out_array[temp_counts[srcs[i]]++] = dsts[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/6"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  printf(\"%d, \", vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaltyPretzel303/ps/openmp/src/ex_1/2"}
{"code": "for (i = 0; i < numOfClusters; i++)\n  clusters[i].numOfPointsInProc = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/KmeansParallel/8"}
{"code": "for (int i = 0; i < Nsprinklers_rows; i++)\n  for (int j = 0; j < Nsprinklers; j++)\n{\n  double x;\n  double y;\n  double A = 0;\n  x = Spr_offs + (i * betw_spr_rows);\n  y = Spr_spr_offs + (j * betw_spr);\n  for (int ix = 0; ix < (_M + 2); ix++)\n    for (int iy = 0; iy < (K + 2); iy++)\n  {\n    double x0;\n    double y0;\n    double r;\n    double max_mult = 0.0;\n    x0 = X[ix];\n    y0 = Y[iy];\n    double cr = dLx[ix];\n    if (dLy[iy] > cr)\n      cr = dLy[iy];\n\n    cr *= 0.5;\n    r = sqrt(((x - x0) * (x - x0)) + ((y - y0) * (y - y0)));\n    if (r <= (sprinklerR + cr))\n      A += dLx[ix] * dLy[iy];\n\n  }\n\n\n  if (A != 0)\n    for (int ix = 0; ix < (_M + 2); ix++)\n    for (int iy = 0; iy < (K + 2); iy++)\n  {\n    double x0;\n    double y0;\n    double r;\n    double max_mult = 0.0;\n    x0 = X[ix];\n    y0 = Y[iy];\n    double cr = dLx[ix];\n    if (dLy[iy] > cr)\n      cr = dLy[iy];\n\n    cr *= 0.5;\n    r = sqrt(((x - x0) * (x - x0)) + ((y - y0) * (y - y0)));\n    if (r <= (sprinklerR + cr))\n      spr[ix][iy] += 1.0 / A;\n\n  }\n\n\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/69"}
{"code": "for (c1 = 0; c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/90"}
{"code": "for (i = 0; i < n; i++)\n{\n  err = err + fabs(x[i] - b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  temp = loop_optimized_parallel_guided(l, m, n, num_t, i);\n  average_dt += temp[0];\n  average_rate += temp[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/7"}
{"code": "for (i = 0; i < num_of_clusters; counts[i++] = 0)\n{\n  memset(c1[i], 0, (sizeof(double)) * dimension);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/14"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  max_idx[i] = max_idx1[i];\n  prev[i] = prev_old[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle0/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Clark0/NSCC_OpenMP/dotProd/0"}
{"code": "for (int i = (12 * n) / 16; i < ((13 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/20"}
{"code": "for (i = 0; i < (n / 4); i++)\n{\n  v_b = _mm256_loadu_pd((const double *) (b + (i * 4)));\n  v_a = _mm256_loadu_pd((const double *) (a + (i * 4)));\n  v_a = _mm256_add_pd(v_a, _mm256_mul_pd(v_alpha, v_b));\n  _mm256_storeu_pd(a, v_a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu_simd_avx/0"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n{\n  if ((key_buff2[i] >= k1) && (key_buff2[i] < k2))\n  {\n    k = --key_buff_ptr_global[key_buff2[i]];\n    key_array[k] = key_buff2[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/5"}
{"code": "for (int i = 1; i <= _M; i++)\n  if (A != 0.0)\n  Tm[1][i] = Dg2 * fabs(pow(fabs(X[1] - X[i]), A) - pow(fabs(X[1] - X[i + 1]), A));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/77"}
{"code": "for (int i = 0; i < vec.size(); ++i)\n{\n  max_num = max(max_num, vec[i]);\n}\n\n", "pragma": "#pragma omp parallel for reduction(max:max_num)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mangosroom/learn-openmp/reduction/main/1"}
{"code": "for (int i = 0; i < num_rows; i++)\n{\n  for (int j = 0; j < num_cols; j++)\n  {\n    output_img[i][j] = ((int) img[i][j]) / normalize_amount;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hanzallah/parallel-convolution/convolution_omp/0"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  temp2 = 0;\n  for (k = 0; k < N; k++)\n    temp2 += L[(i * N) + k] * U[(k * N) + j];\n\n  if ((((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) > 0.1) || (((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) < (-0.1)))\n    temp++;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/hpx/bench/lu/hpx-lu/4"}
{"code": "for (int j = i + 1; j < n; ++j)\n{\n  double t = A(j, i);\n  for (int k = 0; k < n; ++k)\n  {\n    A(j, k) -= A(i, k) * t;\n    I(j, k) -= I(i, k) * t;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/15"}
{"code": "for (int j = 0, jn = counts_per.size(); j < jn; j++)\n{\n  cc_we_want[j] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/4"}
{"code": "for (int pos = lid; pos < N; pos += gsz)\n{\n  s_data[pos] = d_Src[pos];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fwt-omp/kernels/1"}
{"code": "for (int i = 0; i < (n_points / world_size); i++)\n{\n  double min_distance = -1;\n  int closest_centroid = -1;\n  for (int j = 0; j < n_centroids; j++)\n  {\n    double distance = calc_distance(point_x[i], point_y[i], centroid_x[j], centroid_y[j]);\n    if ((distance < min_distance) || (min_distance == (-1)))\n    {\n      min_distance = distance;\n      closest_centroid = j;\n    }\n\n  }\n\n  new_centroid_x[closest_centroid] += point_x[i];\n  new_centroid_y[closest_centroid] += point_y[i];\n  new_centroids_n_points[closest_centroid]++;\n}\n\n", "pragma": "omp parallel for reduction(+: new_centroid_x[:n_centroids],new_centroid_y[:n_centroids], new_centroids_n_points[:n_centroids])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Luca-Ferrera/k-means/app_mp_mpi_4/0"}
{"code": "for (int row = 0; row < howmany; row++)\n{\n  for (int column = 0; column < howmany; column++)\n  {\n    int row_start = lowerb(row, howmany, sizex);\n    int column_start = lowerb(column, howmany, sizey);\n    int row_end = upperb(row, howmany, sizex);\n    int column_end = upperb(column, howmany, sizey);\n    for (int i = max(1, row_start); i <= min(sizex - 2, row_end); i++)\n    {\n      for (int j = max(1, column_start); j <= min(sizey - 2, column_end); j++)\n      {\n        unew = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n        diff = unew - u[(i * sizey) + j];\n        sum += diff * diff;\n        u[(i * sizey) + j] = unew;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for ordered(2) private(unew,diff) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BlackMooth/OpenMP---Heat-diffusion-Equation-Solvers/solver-omp/0"}
{"code": "for (i = istart; i < iend; i++)\n{\n  if (list[i] == key)\n  {\n    printf(\"Key found. Position = %d by thread %d \\n\", i + 1, id);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/neasatang/concurrent-systems/linearsearch_parallel/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  if (a[i] < resa_seq)\n    resa_seq = a[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/reduce-omp-test/reduce-omp/2"}
{"code": "for (int i = 0; i < matSize; i++)\n{\n  (cout << m[i]) << \" \";\n  if (i > 10)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raulviana/FEUP-CPAR/Assigment2/matrixMul/openMP_multiplication/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  (((cout << \"Num_threads: \") << omp_get_num_threads()) << \" Thread: \") << omp_get_thread_num();\n  ((cout << \" Iteration: \") << i) << endl;\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/12"}
{"code": "for (unsigned int i = 0; i < rows; i++)\n  for (unsigned int j = 0; j < cols; j++)\n{\n  data[i][j] = (rand() % 10000) + 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dane-johnson/CS-312/Program 1/matAverager/0"}
{"code": "for (int i = 0; i < count; i++)\n{\n  if (((localTuples[i].day != (-1)) && (localTuples[i].month != (-1))) && (localTuples[i].year != (-1)))\n  {\n    int index = weekInYears(localTuples[i].day, localTuples[i].month, localTuples[i].year);\n    localLethalAccidentsData[index] += killed(localTuples[i], 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/5"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < numDims; j++)\n  {\n    clusters[i][j] = points[j + (i * numDims)];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amitlevy21/kMeans_200055986/kMeans_200055986/kMeans/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  nP[i] = nR[i] + (betta * P[i]);\n  nbiP[i] = nbiR[i] + (betta * biP[i]);\n}\n\n", "pragma": "#pragma omp parallel for shared(nP, nR, betta, P, nbiP, nbiR, biP, n) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/12"}
{"code": "for (j = 0; j < 115; j++)\n{\n  actual_centroids_array[i].coordinate[j] = points_array[centroid_index].coordinate[j];\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/attempts/5_kmeans_parallel/0"}
{"code": "for (int i = start; i < end; i++)\n{\n  for (int j = 0; j < 200; j++)\n  {\n    P[i][j] = 0;\n    for (int k = 0; k < 200; k++)\n    {\n      P[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/CAB401-OpenMP/matMult-comparison/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 24; j++)\n  {\n    diaActual[j] = dias[i][j];\n  }\n\n  MAPEActual = calculaMAPE(diaActual, ultDia);\n  vectorMAPESRealizados[i] = MAPEActual;\n  printf(\"PID: [%d]/[%d] calculandoo el d\u00eda [%d]  con mape:%f\\n\", pid, omp_get_thread_num(), i, MAPEActual);\n  if (MAPEActual < MAPEGeneral)\n  {\n    MAPEGeneral = MAPEActual;\n    indiceDiaMAPEMasBajo = i;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quiquemachado5/Prediccion-series-temporales-OpenMP-MPI/AlgoritmoProyectoSDFicherosMPIfin/0"}
{"code": "for (i = 0; i < collective_size; i++)\n{\n  printf(\"%d \", collective[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/6"}
{"code": "for (long i = 0; i < numColor; i++)\n{\n  colorPtr[i] = 0;\n  colorAdded[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/parallelLouvainWithColoring/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  printf(\"\\r> Progress: %.2f%%\", (100 * (i + 1)) / ((float) 10000));\n  for (int j = i + 1; j < 10000; j++)\n  {\n    double temp = Distance(i, j);\n    double temp_to_mBETA = pow(temp, -2.00);\n    CalculatedDistances_to_mBETA[i][j] = temp_to_mBETA;\n    CalculatedDistances_to_mBETA[j][i] = temp_to_mBETA;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant05/8"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp4o6d3m9s.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RWTH-HPC/openmp/runtime/test/affinity/format/affinity_values/1"}
{"code": "for (int i = 0; i < v.size(); i++)\n{\n  for (int j = 0; j < buckets; j++)\n  {\n    if ((v[i] >= (j * bucket_interval)) && (v[i] <= ((j + 1) * bucket_interval)))\n    {\n      bs[omp_get_thread_num()][j].push_back(v[i]);\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(bs, v, bucket_interval) schedule(static, v.size()/threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort3/0"}
{"code": "for (int i = 0; i < rowA; ++i)\n{\n  for (int j = 0; j < colA; ++j)\n  {\n    int sum = 0;\n    for (int k = 0; k < colB; ++k)\n      sum += (*((matA + (i * colA)) + k)) * (*((matB + (k * colB)) + j));\n\n    *((matC + (i * colB)) + j) = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/0"}
{"code": "for (int node = g->num_nodes - 1; node >= 0; node--)\n{\n  if (distances[node] == NOT_VISITED_MARKER)\n  {\n    int start_edge = g->incoming_starts[node];\n    int end_edge = (node == (g->num_nodes - 1)) ? (g->num_edges) : (g->incoming_starts[node + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      if (distances[g->incoming_edges[neighbor]] == current_value)\n      {\n        distances[node] = distances[g->incoming_edges[neighbor]] + 1;\n        int index = 0;\n        index = __sync_fetch_and_add(&new_frontier->count, 1);\n        new_frontier->vertices[index] = node;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, g->num_nodes/1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/bfs/bfs/4"}
{"code": "for (int i = 2; i < threshold; i++)\n{\n  if ((n % i) == 0)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dimanaux/itis-omp/15/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n}\n\n", "pragma": "omp for ordered (1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/doacross-1/4"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"Final result=%f\\ta[%d]=%d\\tb[%d]=%d\\ttid=%d\\n\", result, i, a[i], i, b[i], omp_get_thread_num());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/default/0"}
{"code": "for (int j = 0; j < (n + 1); j++)\n{\n  if (A[i - 1] == B[j - 1])\n  {\n    DP[i][j] = DP[i - 1][j - 1] + 1;\n  }\n  else\n    if (P[c_i][j] == 0)\n  {\n    DP[i][j] = (DP[i - 1][j] > 0) ? (DP[i - 1][j]) : (0);\n  }\n  else\n  {\n    DP[i][j] = (DP[i - 1][j] > (DP[i - 1][P[c_i][j] - 1] + 1)) ? (DP[i - 1][j]) : (DP[i - 1][P[c_i][j] - 1] + 1);\n  }\n\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v1/row_wise_v1/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = (i + 0.5) * h;\n  integral += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "        #pragma omp for reduction(+:integral) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Homagn/openmp_cpp_course/Homagni_assn5/Task1/OMP_PI/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    fprintf(stderr, DATA_PRINTF_MODIFIER, C[i][j]);\n    if ((i % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/utilities/template-for-new-benchmark/1"}
{"code": "for (int i = 0; i < _xCoordinates.size(); i += 3)\n{\n  ((cout << _xCoordinates[i]) << _yCoordinates[i]) << _zCoordinates[i];\n  ((cout << _xCoordinates[i + 1]) << _yCoordinates[i + 1]) << _zCoordinates[i + 1];\n  ((cout << _xCoordinates[i + 2]) << _yCoordinates[i + 2]) << _zCoordinates[i + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/structure/Mesh/3"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  result = result && a[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_and/1"}
{"code": "for (i = 0; i < iters; i++)\n  mandelbrot_simd(x0, y0, x1, y1, width, height, maxIterations, buf_simd);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_40_mandel/3"}
{"code": "for (int i = 0; i < num_edges; ++i)\n{\n  if ((colors[edges[i][0]] < 0) || (colors[edges[i][0]] > maxd))\n  {\n    passed = false;\n  }\n\n  if ((colors[edges[i][1]] < 0) || (colors[edges[i][1]] > maxd))\n  {\n    passed = false;\n  }\n\n  if (colors[edges[i][0]] == colors[edges[i][1]])\n  {\n    passed = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Edge-Coloring/parallel-omp/6"}
{"code": "for (int x = 0; x < (*rows); x++)\n{\n  for (int y = 0; y < (*columns); y++)\n  {\n    int neighbours = 0;\n    if (x > 0)\n    {\n      neighbours += matrix[x - 1][y];\n      if (y > 0)\n        neighbours += matrix[x - 1][y - 1];\n\n      if (y < ((*rows) - 1))\n        neighbours += matrix[x - 1][y + 1];\n\n    }\n\n    if (y > 0)\n      neighbours += matrix[x][y - 1];\n\n    if (x < ((*rows) - 1))\n    {\n      neighbours += matrix[x + 1][y];\n      if (y < ((*rows) - 1))\n        neighbours += matrix[x + 1][y + 1];\n\n      if (y > 0)\n        neighbours += matrix[x + 1][y - 1];\n\n    }\n\n    if (y < ((*rows) - 1))\n      neighbours += matrix[x][y + 1];\n\n    if (neighbours < 2)\n      temp_matrix[x][y] = 0;\n\n    if (((matrix[x][y] == 1) && (neighbours == 2)) || ((matrix[x][y] == 1) && (neighbours == 3)))\n      temp_matrix[x][y] = 1;\n\n    if (neighbours > 3)\n      temp_matrix[x][y] = 0;\n\n    if (neighbours == 3)\n      temp_matrix[x][y] = 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) shared(temp_matrix,matrix)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cesargdm/game-of-life/main/0"}
{"code": "for (r = 1; r < (rows + cols); r++)\n{\n  Antena arriba = {antena.y - r, antena.x};\n  Antena abajo = {antena.y + r, antena.x};\n  Antena izquierda = {antena.y, antena.x - r};\n  Antena derecha = {antena.y, antena.x + r};\n  int distancia = manhattan(antena, arriba.y, arriba.x);\n  int flag = 0;\n  for (int delta = 0; delta < r; delta++)\n  {\n    if (((((arriba.y + delta) >= 0) && ((arriba.y + delta) < rows)) && ((arriba.x + delta) >= 0)) && ((arriba.x + delta) < cols))\n    {\n      mapa[arriba.y + delta][arriba.x + delta] = distancia;\n      flag = 1;\n    }\n\n    if (((((abajo.y - delta) >= 0) && ((abajo.y - delta) < rows)) && ((abajo.x - delta) >= 0)) && ((abajo.x - delta) < cols))\n    {\n      mapa[abajo.y - delta][abajo.x - delta] = distancia;\n      flag = 1;\n    }\n\n    if (((((izquierda.y - delta) >= 0) && ((izquierda.y - delta) < rows)) && ((izquierda.x + delta) >= 0)) && ((izquierda.x + delta) < cols))\n    {\n      mapa[izquierda.y - delta][izquierda.x + delta] = distancia;\n      flag = 1;\n    }\n\n    if (((((derecha.y + delta) >= 0) && ((derecha.y + delta) < rows)) && ((derecha.x - delta) >= 0)) && ((derecha.x - delta) < cols))\n    {\n      mapa[derecha.y + delta][derecha.x - delta] = distancia;\n      flag = 1;\n    }\n\n  }\n\n  if (flag == 0)\n  {\n    r = rows + cols;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(mapa,rows,cols,miAntena,miAntena,r) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas5.0b/1"}
{"code": "for (i = 0; i < num; i++)\n  a[i] = (num * num) % 100;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/VectorDotProduct/1"}
{"code": "for (int ki = 0; ki < mask_size; ki++)\n{\n  for (int kj = 0; kj < mask_size; kj++)\n  {\n    pixel_x += img.getPixel((i - 1) + ki, (j - 1) + kj) * sobel_x[ki][kj];\n    pixel_y += img.getPixel((i - 1) + ki, (j - 1) + kj) * sobel_y[ki][kj];\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for collapse(2) reduction(+:pixel_x,pixel_y)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/beliosien/ParallelProgramming-/filterSystem/source/filter/4"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  blurImage[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/llama95/Parallel_Programming/Patterns/stencil/openmp/6"}
{"code": "for (int i = 0; i < type_seqs.size(); ++i)\n{\n  rseqs[i] = type_seqs[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/14"}
{"code": "for (int cout = 0; cout < Cout; ++cout)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    ATM[((cout * 12) + (0 * 4)) + j] = (M[((cout * 16) + (0 * 4)) + j] + M[((cout * 16) + (1 * 4)) + j]) + M[((cout * 16) + (2 * 4)) + j];\n    ATM[((cout * 12) + (2 * 4)) + j] = (M[((cout * 16) + (1 * 4)) + j] - M[((cout * 16) + (2 * 4)) + j]) - M[((cout * 16) + (3 * 4)) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/winograd_transform/4"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = grid_points[2] - 3; k >= 0; k += -1)\n  {\n    k1 = k + 1;\n    k2 = k + 2;\n    rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j][k1])) - (lhs[n + 4][i][j][k] * rhs[m][i][j][k2]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (k1,k2,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/221"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,j ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/127"}
{"code": "for (int i = 0; i < Nloc; ++i)\n{\n  for (int j = 0; j < Nloc; ++j)\n  {\n    const int rowA = r_A + i;\n    const int colB = c_B + j;\n    double cij = C[rowA + (colB * N)];\n    for (int k = 0; k < Nloc; ++k)\n    {\n      const int colA = c_A + k;\n      const int rowB = r_B + k;\n      cij += A[colA + (rowA * N)] * Bt[rowB + (colB * N)];\n    }\n\n    C[rowA + (colB * N)] = cij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/openmp/matmat_recur/0"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i = (i + incX) + 4, j = (j + incY) + 4)\n{\n  _mm_store_ps(YP + j, _mm_load_ps(XP + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/7"}
{"code": "for (unsigned int i = 0; i < nb_body; i += 1)\n{\n  if (i != it)\n  {\n    dx = g_bodies[it].x_pos - g_bodies[i].x_pos;\n    dy = g_bodies[it].y_pos - g_bodies[i].y_pos;\n    tmp = (G_CONST * g_bodies[i].mass) / pow(sqrt((dx * dx) + (dy * dy)), 3);\n    g_bodies[it].x_accel += tmp * (g_bodies[i].x_pos - g_bodies[it].x_pos);\n    g_bodies[it].y_accel += tmp * (g_bodies[i].y_pos - g_bodies[it].y_pos);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/mpi+openmp/src/nbody_mpi+openmp/2"}
{"code": "for (int i = 0; i < snpCount; i++)\n  rank[i] = items[i].index1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/17"}
{"code": "for (i = 0; i < 256; i++)\n{\n  for (j = 0; j < 256; j++)\n  {\n    C[(i * 256) + j] = ((((DATA_TYPE) i) * j) + 2) / 256;\n    C_GPU[(i * 256) + j] = C[(i * 256) + j];\n  }\n\n  for (j = 0; j < 256; j++)\n  {\n    A[(i * 256) + j] = (((DATA_TYPE) i) * j) / 256;\n    B[(i * 256) + j] = ((((DATA_TYPE) i) * j) + 1) / 256;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/16"}
{"code": "for (i = 0; i < matrix_size; i++)\n  for (j = 0; j < matrix_size; j++)\n  for (k = 0; k < matrix_size; k++)\n  result[i][j] += data[i][k] * multiplier[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nrvru/parallel-lab1/SquareMatrix/0"}
{"code": "for (i = 0; i < k; i++)\n{\n  MPI_Allreduce(&arrClusters[i].x, &x, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n  MPI_Allreduce(&arrClusters[i].y, &y, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);\n  MPI_Allreduce(&arrClusters[i].numOfGroupPoints, &totalPointInGroup, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);\n  arrClusters[i].x = x / totalPointInGroup;\n  arrClusters[i].y = y / totalPointInGroup;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/11"}
{"code": "for (i = 0; i < maxIter; i++)\n{\n  stop = gauss(a, localI, localJ);\n  should_continue = 0;\n  MPI_Gather(&stop, 1, (MPI_Datatype) 0x4c000405, stop_buff, 1, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  for (j = 0; j < nsize; j++)\n  {\n    if (stop_buff[j] == 0)\n    {\n      should_continue = 1;\n      break;\n    }\n\n  }\n\n  if (has_south(my_rank))\n  {\n    int neighbor = my_rank + ichunk;\n    double *send_buff = &a[((localI - 2) * localJ) + 0];\n    MPI_Sendrecv(send_buff, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, south_buff, localJ, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    for (j = 0; j < localJ; j++)\n    {\n      a[((localI - 1) * localJ) + j] = south_buff[j];\n    }\n\n  }\n\n  if (has_east(my_rank))\n  {\n    int neighbor = my_rank + 1;\n    double *send_buff = malloc((sizeof(double)) * localI);\n    for (j = 0; j < localI; j++)\n    {\n      send_buff[j] = a[(j * localJ) + (localJ - 2)];\n    }\n\n    MPI_Sendrecv(send_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, east_buff, localI, (MPI_Datatype) 0x4c00080b, neighbor, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    free(send_buff);\n    for (j = 0; j < localI; j++)\n    {\n      a[(j * localJ) + (localJ - 1)] = east_buff[j];\n    }\n\n  }\n\n  MPI_Bcast(&should_continue, 1, (MPI_Datatype) 0x4c000405, 0, (MPI_Comm) 0x44000000);\n  if (should_continue == 0)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/5"}
{"code": "for (i = 0; i < size; i++)\n{\n  int sum = 0;\n  int *ARow = &A[i * size];\n  for (j = 0; j < size; j++)\n  {\n    sum += *(ARow + j);\n  }\n\n  D[i] = sum;\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/1"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  vect[i] = rand() % x;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OUMAYMABERRAADI/OpenMP_Programmation_parallel/TP2EX2/0"}
{"code": "for (layer3_index = 0; layer3_index < Layer_CH_Num; layer3_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (layer2_index = 0; layer2_index < Layer_CH_Num; layer2_index++)\n  {\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        temp_data3[(((layer2_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n      }\n\n    }\n\n    for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n    {\n      for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n      {\n        for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n        {\n          for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n          {\n            temp_data3[(((layer2_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data3[(((layer2_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv2_data[(((layer2_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv3[(((((layer3_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer2_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data3[(((layer2_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv3[layer3_index];\n      if (conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n        conv3_data[(((layer3_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/21"}
{"code": "for (int i = 0; i < clusters.size(); i++)\n{\n  conv = clusters[i].update_coords();\n  clusters[i].free_point();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SestoAle/Parallel-K-Means/main_parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  j = (n - 1) - i;\n  partial_max1 = (i == 0) ? (ss[i]) : ((ss[i] > partial_max1) ? (ss[i]) : (partial_max1));\n  pmax[i] = partial_max1;\n  partial_max2 = (j == (n - 1)) ? (ps[j]) : ((ps[j] > partial_max2) ? (ps[j]) : (partial_max2));\n  smax[j] = partial_max2;\n}\n\n", "pragma": "\t\t#pragma omp for private(j) schedule(static,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  x[i] = ((i % 2) == 0) ? (2) : (-2);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adeel1234/Capstone/src/OpenMP/jacobi/2"}
{"code": "for (i = 0; i < (Np - 1); i++)\n{\n  double diff_x = v_get_val(x, i + 1) - v_get_val(x, i);\n  double diff_y = v_get_val(y, i + 1) - v_get_val(y, i);\n  L += sqrt((diff_x * diff_x) + (diff_y * diff_y));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/17"}
{"code": "for (i = 0; i < size; i++)\n{\n  a[i] = (double *) malloc(size * (sizeof(double)));\n  b[i] = (double *) malloc(size * (sizeof(double)));\n  c[i] = (double *) malloc(size * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/matmul/3"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float tempA = 2.0;\n  float tempB = (-2.0) * (xc + yc);\n  float tempC = ((xc * xc) + (yc * yc)) - (r * r);\n  float tempD = (tempB * tempB) - ((4.0 * tempA) * tempC);\n  if (tempD < 0)\n  {\n    continue;\n  }\n\n  float t_min = calculateInterSectionTime(tempD, tempA, tempB);\n  if (t_min < 0)\n  {\n    continue;\n  }\n\n  float tt = calculateIntersection(t_min, xc, yc);\n  if (tt < 0)\n  {\n    continue;\n  }\n\n  numHits++;\n}\n\n", "pragma": "        #pragma omp parallel for default(none) shared(xcs,ycs,rs) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/salazjos/openMP_1/openMPproject1/0"}
{"code": "for (int i = 0; i < table_size; i++)\n{\n  int ixj = i ^ j;\n  if (i < ixj)\n  {\n    bool f = (i & k) == 0;\n    int t1 = table[i];\n    int t2 = table[ixj];\n    if (compare_rotations((f) ? (t2) : (t1), (f) ? (t1) : (t2), genome, n))\n    {\n      table[i] = t2;\n      table[ixj] = t1;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(blockSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bwt-omp/bwt/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, y[i]);\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gesummv/gesummv/2"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = a[i] + a[0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB040-truedepsingleelement-var-yes/0"}
{"code": "for (int i = 0; i < nprocs; i++)\n  (*buffer)[i] = (char *) malloc(50);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/threads_affinity/03_where_I_am_nested/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"Minimal distance from Node 0 to Node %i: %i, via: %i\\n\", i, nodes[i].total_distance, nodes[i].via);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/dijkstra_openmp/7"}
{"code": "for (; i < (endIndex - 1); ++i)\n  moveBaseQuantile(data, quantile, bound, upperBound, sortedBlockNum, mergeStride, &ptrOut);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/10"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      forcing[m][i][j][k] = (-1.0) * forcing[m][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/11"}
{"code": "for (int i = 0; i < 44800; i++)\n{\n  xpos = ((double) i) * 0.0002;\n  for (int j = i + 1; j < 44800; j++)\n  {\n    ypos = ((double) j) * 0.0002;\n    double xvecSquare = (xpos * xpos) + (ypos * ypos);\n    local_int += (exp(-xvecSquare) * 0.0002) * 0.0002;\n  }\n\n}\n\n", "pragma": "omp for schedule(static,250)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc2n/OpenMP-Collaboration/Templates/Day_2/WorkshareSchedule/SampleSolution/C/gauss2d_omp_atomic/0"}
{"code": "for (long v = 0; v < NVer; v++)\n{\n  vtxColor[v] = maxColor;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringMultiHashMaxMin/2"}
{"code": "for (i = 0; i != n; i++)\n{\n  x[i] = i;\n  y[i] = 2 * i;\n  z[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/saxpy/1"}
{"code": "for (long int i = 0; i < n; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for schedule(dynamic, 10000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maxis42/Parallel-computing-Coursera/1 OpenMP/Week 3/3.1_add_2vector/3.1_add_2vector/main/1"}
{"code": "for (int i = 0; i < sort_length; i++)\n{\n  if ((y + i) >= image->height)\n  {\n    break;\n  }\n\n  image->set_pixel(x, y + i, sorted[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MenesesGHZ/glitch/lib/glitch/4"}
{"code": "for (i = 0; i < 50; i++)\n{\n  for (j = 0; j < 50; j++)\n  {\n    mat[i][j] = do_crazy_computation(i, j);\n    fprintf(stderr, \".\");\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) shared(mat) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sam-the-Unwise/Parallel-Programming/OpenMP Programming/crazy_scientist_v1/0"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  count += table[v[i]];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  C[(i * n) + j] = C[(i * n) + j] + (A[(i * n) + k] * B[(k * n) + j]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP2.2/Shashank_CP2.2_11110094_Report+Codes/Shashank_CP2.2_11110094_Report+Codes/Codes for OpenMP_Shashank/Q1/serial_mat_mult/2"}
{"code": "for (int i = 1; i <= m_nSubbsns; i++)\n{\n  m_ifluQ2Rch[i] += tmp_qiSubbsn[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SSR_DA/SSR_DA/6"}
{"code": "for (int k = 0; k < N; k++)\n  for (int i = k + 1; i < N; i++)\n  for (int j = 0; j < N; j++)\n  A[i][j] += A[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/9"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nl; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, D[i][j]);\n  if ((((i * ni) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/2mm/2mm/6"}
{"code": "for (j = 0; j < 80000000; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KonstantinosKr/delta/meta/benchmark/ham7/stream/stream/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  colors[i] = -1;\n  temp_colors[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Edge-Coloring/parallel-omp/2"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  if (allClusters[i].virutalCenter.coordinates != NULL)\n    free(allClusters[i].virutalCenter.coordinates);\n\n  allClusters[i].virutalCenter = allProducts[i];\n  allClusters[i].virutalCenter.coordinates = (double *) malloc((sizeof(double)) * allProducts->dimensions);\n  memcpy(allClusters[i].virutalCenter.coordinates, allProducts[i].coordinates, (sizeof(double)) * allProducts[i].dimensions);\n  allClusters[i].virutalCenter.clusterId = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/11"}
{"code": "for (i = 1; i <= (n - 1); i++)\n{\n  x = (delta * i) + a;\n  resultado += 2 * f(x);\n}\n\n", "pragma": "omp for schedule(dynamic,chunk) reduction(+:resultado)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felipeBozzano/PC/OpenMP_V2/OpenMP_V2/2"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  const float scale = augmented_matrix[i][i];\n  for (size_t j = 0; j != (2 * n); ++j)\n  {\n    augmented_matrix[i][j] /= scale;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Depyden/OpenMP/Lab7_2/calculations/4"}
{"code": "for (int x = -3; x <= 3; x++)\n{\n  for (int y = -3; y <= 3; y++)\n  {\n    r = sqrt((x * x) + (y * y));\n    kernel[x + 3][y + 3] = exp((-(r * r)) / s) / (M_PI * s);\n    sum += kernel[x + 3][y + 3];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/gaussianFilterOpenMP/1"}
{"code": "for (int u = 0; u < ((M * M) * 2); u++)\n{\n  printf(\"%f \", *(BP + u));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/10"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    sum = 0;\n    for (k = 0; k < n; k++)\n      sum = sum + (a[i][k] * b[k][j]);\n\n    c[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/201312333/openmp/mul_omp_q8/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  vec_a[i] = i;\n  vec_b[i] = 1;\n  vec_c[i] = 1;\n  vec_d[i] = 0;\n  res_vec[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaltyPretzel303/ps/openmp/src/ex_1/3"}
{"code": "for (inner = primeBase; inner < num; inner++)\n{\n  if (primeBase == 2)\n  {\n    if (((inner + 1) % primeBase) == 0)\n      numList[inner] = 0;\n    else\n      numList[inner] = inner + 1;\n\n  }\n  else\n  {\n    if ((numList[inner] != 0) && ((numList[inner] % primeBase) == 0))\n      numList[inner] = 0;\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theminigundude/CSCI-UA.0480-003-Parallel-Computing-Lab-2/genprime/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    lhs[n + 1][i][j2][k] = lhs[n + 1][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 2][i][j2][k] = lhs[n + 2][i][j2][k] - (lhs[n + 0][i][j2][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/56"}
{"code": "for (i = 0; i < state->nMoves; ++i)\n{\n  values[i] = MiniMax_Recursive(state, state->moves + i, -2147483648, 2147483647, depth);\n  GUI_ManageEvents(gui);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luigifusco/CChess/minimax/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  counters[i] = 0;\n  omp_set_lock(&cond_m[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/numeric/shared/openMP/gauss-omp/1"}
{"code": "for (i = 0; i < l; i++)\n  for (j = 0; j < t; j++)\n{\n  xx = (-((double) 1.0)) + ((*dx) * ((double) (i - 1)));\n  yy = (-((double) 1.0)) + ((*dy) * ((double) (j - 1)));\n  temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n  error = error + (temp * temp);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/jacobi/3"}
{"code": "for (i = 0; i < dim_cpu.space_elem; i = i + 1)\n{\n  qv_cpu[i] = ((rand() % 10) + 1) / 10.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lavaMD/OneFile/5"}
{"code": "for (i = 0; i < (len * tNum); i++)\n{\n  if ((i % 2) == 0)\n  {\n    x[i] = 2;\n  }\n  else\n  {\n    x[i] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) shared(x) if(len*tNum>1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AleX77NP/ML-Openmp-Spark-projekti/openmp/array/0"}
{"code": "for (int i = 0; i < m; i++)\n  val += arr1[row][i] * arr2[i][col];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t2/4"}
{"code": "for (int i = 0; i < target_cells_.size(); i++)\n{\n  target_cells_[i].numberPoints = 0;\n  target_cells_[i].mean[0] = 0;\n  target_cells_[i].mean[1] = 0;\n  target_cells_[i].mean[2] = 0;\n  memset(target_cells_[i].invCovariance.data, 0, ((sizeof(double)) * 3) * 3);\n  target_cells_[i].invCovariance.data[2][0] = 1.0;\n  target_cells_[i].invCovariance.data[1][1] = 1.0;\n  target_cells_[i].invCovariance.data[0][2] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP/ndt_mapping/kernel/1"}
{"code": "for (i = 0; i < 1024; i++)\n  printf(\" %3.2f\", X[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/triangular_matrix/3"}
{"code": "for (k = 0; k < n; k++)\n  for (j = 0; j < N; j++)\n{\n  for (i = 0; i < N; i++)\n    loc_C[(k * N) + j] += loc_A[(k * N) + i] * recv_buff[i];\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/MPIandOpenmp/Mmul_hybrid/0"}
{"code": "for (k = (*arr_start)[2] + 1; k < (*arr_end)[2]; k++)\n{\n  for (j = (*arr_start)[1] + 1; j < (*arr_end)[1]; j++)\n  {\n    #pragma ivdep\n    #pragma vector nontemporal(outdata)\n    for (i = (*arr_start)[0] + 1; i < (*arr_end)[0]; i++)\n    {\n      outdata[(i + (j * ni)) + ((k * ni) * nj)] = ((((((indata[(i + (j * ni)) + (((k - 1) * ni) * nj)] + indata[((i - 1) + (j * ni)) + ((k * ni) * nj)]) + indata[(i + ((j - 1) * ni)) + ((k * ni) * nj)]) + indata[(i + (j * ni)) + ((k * ni) * nj)]) + indata[(i + ((j + 1) * ni)) + ((k * ni) * nj)]) + indata[((i + 1) + (j * ni)) + ((k * ni) * nj)]) + indata[(i + (j * ni)) + (((k + 1) * ni) * nj)]) / ((unsigned long) 7);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(static, 1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/8"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  total = total + (((float) i) * 1);\n}\n\n", "pragma": "omp for schedule(dynamic, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task9/bugged2/0"}
{"code": "for (int neighbor_ind = row_ptr[vertex]; (neighbor_ind < row_ptr[vertex + 1]) && colorValid; neighbor_ind++)\n{\n  const uint neighbor = col_ind[neighbor_ind];\n  if (colors[neighbor] == minColor)\n  {\n    colorValid = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AyushBhandariNITK/Parallel_Graph_Coloring_Using_Openmp/coloring/11"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  for (j = 1; j < (nx - 1); j++)\n  {\n    volAvg = volAvg + heatgrid[new_index][i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juliennelachance/apc524_hw4/heat_omp/4"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,k ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/126"}
{"code": "for (int k = 0; k < 16; k++)\n  entropy -= d_logTable[sd_count[k][idx]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/entropy-omp/main/3"}
{"code": "for (j = 0; j < 1000000; j++)\n{\n  R[j] = R[j] - (alpha * AP[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/CG/C/cg/4"}
{"code": "for (i = 0; i < world_size; i++)\n  errorsCounter += errorArray[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/7"}
{"code": "for (i = 0; i <= 7; i++)\n{\n  result = fscanf(fp, \"%d\", &debug_vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/7"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float tx = txs[n];\n  float ty = tys[n];\n  float txv = txvs[n];\n  float sv = svs[n];\n  float sthd = sths[n];\n  float sthr = Radians(sthd);\n  float svx = sv * cos(sthr);\n  float svy = sv * sin(sthr);\n  float t = ty / svy;\n  float truckx = tx + (txv * t);\n  float sbx = svx * t;\n  if (fabs(sbx) < truckx)\n  {\n    numHits++;\n    if (DEBUG)\n      fprintf(stderr, \"Hits the truck at time = %8.3f\\n\", t);\n\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for default(none) shared(txs, tys, txvs, svs, sths, stderr) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/j4c0b094/MonteCarloSim_Parallelism/openmp/src/montecarlo/1"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14u \", pageRankCorrelationStats_array[x].intersection);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/30"}
{"code": "for (unsigned int i = 0; i < prtls->number; i++)\n{\n  unsigned int r_i = CELL_NUMBER(prtls->pos[i][0], geom->dr);\n  unsigned int z_k = CELL_NUMBER(prtls->pos[i][2], geom->dz);\n  vel_r = prtls->vel[i][0];\n  vel_phi = prtls->vel[i][1];\n  vel_z = prtls->vel[i][2];\n  vel = sq_rt(((vel_r * vel_r) + (vel_phi * vel_phi)) + (vel_z * vel_z));\n  if (prtls->pos[i][0] > dr)\n  {\n    r1 = prtls->pos[i][0] - (0.5 * dr);\n    r2 = (r_i + 0.5) * dr;\n    r3 = prtls->pos[i][0] + (0.5 * dr);\n    v_0 = (((2. * PI) * dz) * dr) * prtls->pos[i][0];\n    ro_p = (prtls->mass_array[i] / EL_MASS) / v_0;\n    v_1 = CELL_VOLUME(r_i, dr, dz);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    dz1 = ((z_k + 0.5) * dz) - (prtls->pos[i][2] - (0.5 * dz));\n    dz2 = (prtls->pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    value = CYL_RNG_VOL(dz1, r1, r2) / v_1;\n    inc_count(r_i, z_k, ro_p * value);\n    value = CYL_RNG_VOL(dz1, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k, ro_p * value);\n    value = CYL_RNG_VOL(dz2, r1, r2) / v_1;\n    inc_count(r_i, z_k + 1, ro_p * value);\n    value = CYL_RNG_VOL(dz2, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k + 1, ro_p * value);\n  }\n  else\n    if (prtls->pos[i][0] <= (dr / 2.))\n  {\n    r_i = 0;\n    r1 = 0.;\n    r2 = (r_i + 0.5) * dr;\n    r3 = prtls->pos[i][0] + (0.5 * dr);\n    dz1 = ((z_k + 0.5) * dz) - (prtls->pos[i][2] - (0.5 * dz));\n    dz2 = (prtls->pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    v_0 = (PI * dz) * (((2. * prtls->pos[i][0]) * prtls->pos[i][0]) + ((dr * dr) / 2.));\n    ro_p = (prtls->mass_array[i] / EL_MASS) / v_0;\n    v_1 = CYL_VOL(dz, dr);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    value = ((PI * dz1) * ((((dr * dr) / 2.) - (prtls->pos[i][0] * dr)) + (prtls->pos[i][0] * prtls->pos[i][0]))) / v_1;\n    inc_count(r_i, z_k, ro_p * value);\n    value = CYL_RNG_VOL(dz1, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k, ro_p * value);\n    value = ((PI * dz2) * ((((dr * dr) / 2.) - (prtls->pos[i][0] * dr)) + (prtls->pos[i][0] * prtls->pos[i][0]))) / v_1;\n    inc_count(r_i, z_k + 1, ro_p * value);\n    value = CYL_RNG_VOL(dz2, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k + 1, ro_p * value);\n  }\n  else\n  {\n    r1 = prtls->pos[i][0] - (0.5 * dr);\n    r2 = (r_i + 0.5) * dr;\n    r3 = prtls->pos[i][0] + (0.5 * dr);\n    dz1 = ((z_k + 0.5) * dz) - (prtls->pos[i][2] - (0.5 * dz));\n    dz2 = (prtls->pos[i][2] + (0.5 * dz)) - ((z_k + 0.5) * dz);\n    v_0 = (((2. * PI) * dz) * dr) * prtls->pos[i][0];\n    ro_p = (prtls->mass_array[i] / EL_MASS) / v_0;\n    v_1 = CYL_VOL(dz, dr);\n    v_2 = CELL_VOLUME(r_i + 1, dr, dz);\n    value = CYL_RNG_VOL(dz1, r1, r2) / v_1;\n    inc_count(r_i, z_k, ro_p * value);\n    value = CYL_RNG_VOL(dz1, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k, ro_p * value);\n    value = CYL_RNG_VOL(dz2, r1, r2) / v_1;\n    inc_count(r_i, z_k + 1, ro_p * value);\n    value = CYL_RNG_VOL(dz2, r2, r3) / v_2;\n    inc_count(r_i + 1, z_k + 1, ro_p * value);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particlesDensity/1"}
{"code": "for (i = 1; i < (ncols + 2); i++)\n{\n  life->grid[i] = &life->grid[0][i * (ncols + 2)];\n  life->next_grid[i] = &life->next_grid[0][i * (ncols + 2)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iliasmentz/Game-of-Life/GoF-openmp/LifeFunctions/5"}
{"code": "for (long i = 0; i < size; i++)\n{\n  for (long j = 0; j < size; j++)\n  {\n    first_matrix[i][j] = (second_matrix[i][j] = 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Matrix_Multiplication_Serial_Parallel/4"}
{"code": "for (int i = 0; i < n; i = i + (2 * size))\n{\n  merge(arr, i, min(i + size, n), min(i + (2 * size), n), arr1);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ManjunathBirajdar/OpenMP-Parallelism/openmp-looping-parallelism/mergesort/mergesort/1"}
{"code": "for (unsigned i = 0; i < x.size(); ++i)\n{\n  int nz;\n  int ierr;\n  zbesj_(&x[i], &y[i], &r_1, &c_1, &c_1, &re[i], &im[i], &nz, &ierr);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int x = INT_MAX;\n  for (int j = 0; j < m; j++)\n  {\n    if (A[(i * n) + j] < x)\n    {\n      x = A[(i * n) + j];\n    }\n\n  }\n\n  B[i] = x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OmarAlaaeldein/OpenMP_demos/min_matrx_rowwise/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = 5 + i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Oidlichtnwoada/ParallelMergesort/parmerge_tester/0"}
{"code": "for (i = 0; i < cs.length_o; i++)\n  cs.o[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pdf_fmt_plug/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  tmp = a[i] + b[i];\n  sum += tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/simd/4"}
{"code": "for (int j = 0; j < input->d; j++)\n  input->xh[j] = input->x[(k * input->d) + j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/4"}
{"code": "for (i = 0; i < 64; i++)\n{\n  c[9] += i;\n  c[10] += 2 * i;\n  c[11] += 3 * i;\n  c[12] += 4 * i;\n}\n\n", "pragma": "omp for schedule (static) reduction (+:c[x:4])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-15/2"}
{"code": "for (i = 0; i <= (NQ - 1); i++)\n{\n  q[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/EP/ep/3"}
{"code": "for (int i = 0; i < num_elements; i++)\n{\n  (cout << \"Parallel \") << out_parallel_vect2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/projectile-omp/Projectile/2"}
{"code": "for (i = 0; i < 16; i++)\n  c[i + 16] = i + 16;\n\n", "pragma": "omp parallel for schedule (monotonic: guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/19"}
{"code": "for (int i = 0; i < s.length(); i++)\n{\n  n = ((n * 10) + s[i]) - '0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DimaUtyuz/parallel-determinant/main/0"}
{"code": "for (int i = 1; i < points->num; i++)\n{\n  accumweight[i] = accumweight[i - 1] + points->p[i].weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/19"}
{"code": "for (size_t i = 0; i < a.r; ++i)\n{\n  for (size_t k = 0; k < a.c; ++k)\n  {\n    int32_t r_elem = a(i, k);\n    if (r_elem != 0)\n    {\n      for (size_t j = 0; j < b.c; ++j)\n      {\n        int32_t c_elem = b(k, j);\n        if (c_elem != 0)\n        {\n          c(i, j) += r_elem * c_elem;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(c) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zambonin/lovelace/matrix-mult/smm/1"}
{"code": "for (j = 0; j < ny; j++)\n{\n  jglob = j;\n  for (k = 0; k < nz; k++)\n  {\n    double *_imopVarPre254;\n    int _imopVarPre255;\n    _imopVarPre254 = &u[nx - 1][j][k][0];\n    _imopVarPre255 = nx0 - 1;\n    exact(_imopVarPre255, jglob, k, _imopVarPre254);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/4"}
{"code": "for (i = lo; i < hi; i++)\n{\n  for (j = N - 1; j > i; j--)\n  {\n    a[i][j] += cos(b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cstyl/omp-scheduling/src/loops/workload/3"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  ind = tt->ind[m];\n  ind[start] = ind[i];\n  ind[i] = imid[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/10"}
{"code": "for (int i = 0; i < len; i++)\n{\n  acc += input[i];\n}\n\n", "pragma": "    #pragma omp for schedule(dynamic,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/1"}
{"code": "for (unsigned I = 0, E = MapTypeModifiers.size(); I < E; ++I)\n{\n  if ((MapTypeModifiers[I] != OMPC_MAP_MODIFIER_unknown) && (find(Modifiers, MapTypeModifiers[I]) != end(Modifiers)))\n  {\n    Diag(MapTypeModifiersLoc[I], err_omp_duplicate_map_type_modifier);\n    continue;\n  }\n\n  assert((Count < NumberOfOMPMapClauseModifiers) && \"Modifiers exceed the allowed number of map type modifiers\");\n  Modifiers[Count] = MapTypeModifiers[I];\n  ModifiersLoc[Count] = MapTypeModifiersLoc[I];\n  ++Count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/lib/Sema/SemaOpenMP/4"}
{"code": "for (uint32_t i = 0; i < numKeys; i++)\n{\n  MurmurHash3_x64_128(d_keys + d_length[i], length[i], i, d_out + (i * 2));\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/6"}
{"code": "for (j = 2; j <= N; j++)\n{\n  if (array[j] == 0)\n  {\n    fprintf(f, \"%d%s %d%s %d\\n\", counter, \",\", j, \",\", j - previousPrime);\n    previousPrime = j;\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adithepnarula/Parallel-computing/OpenMP/genprime/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  sums[i] = gk_fsum(ptr[i + 1] - ptr[i], val + ptr[i], 1);\n}\n\n", "pragma": "omp parallel for if (ptr[n] > OMPMINOPS) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/16"}
{"code": "for (unsigned int i = 0; i < 3; ++i)\n{\n  mHighPoint[i] = infinity;\n  mLowPoint[i] = -infinity;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/create_and_destroy/0"}
{"code": "for (int i = 1; i <= m_nSubbasins; i++)\n{\n  m_surfqToCh[i] += tmp_surfq2ch[i] * m_cellArea;\n  m_sedToCh[i] += tmp_sed2ch[i];\n  m_surNO3ToCh[i] += tmp_sno32ch[i] * m_cellArea;\n  m_surNH4ToCh[i] += tmp_snh42ch[i] * m_cellArea;\n  m_surSolPToCh[i] += tmp_solp2ch[i] * m_cellArea;\n  m_surCodToCh[i] += tmp_cod2ch[i] * m_cellArea;\n  m_sedOrgNToCh[i] += tmp_orgn2ch[i] * m_cellArea;\n  m_sedOrgPToCh[i] += tmp_orgp2ch[i] * m_cellArea;\n  m_sedMinPAToCh[i] += tmp_minpa2ch[i] * m_cellArea;\n  m_sedMinPSToCh[i] += tmp_minps2ch[i] * m_cellArea;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IMP_SWAT/pothole_SWAT/4"}
{"code": "for (i = 0; i < n; i += 1)\n  for (j = 0; j < n; j += 1)\n  fscanf(in, \"%d\", &year[0].P[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elf11/Parallel-Processing/OpenMP/paralel/3"}
{"code": "for (i = 3; i <= n; i += 2)\n{\n  if (primo(i) == 1)\n    total++;\n\n}\n\n", "pragma": "omp parallel for reduction(+:total) schedule(guided,10)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q13/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = i * 1.0;\n  printf(\"Thread %d: a[%d]= %f\\n\", tid, i, a[i]);\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/OpenMP---Examples/openmp/example3/schedule/0"}
{"code": "for (int i = 0; i < NRA; i++)\n{\n  for (int j = 0; j < NCB; j++)\n    for (int k = 0; k < NCA; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPMatrixMult/Ex5MM_Multiply/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 0; j <= jsize; j++)\n    {\n      tmp1 = rho_i[k][j][i];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[j][0][0] = 0.0;\n      fjac[j][1][0] = 0.0;\n      fjac[j][2][0] = 1.0;\n      fjac[j][3][0] = 0.0;\n      fjac[j][4][0] = 0.0;\n      fjac[j][0][1] = (-(u[k][j][i][1] * u[k][j][i][2])) * tmp2;\n      fjac[j][1][1] = u[k][j][i][2] * tmp1;\n      fjac[j][2][1] = u[k][j][i][1] * tmp1;\n      fjac[j][3][1] = 0.0;\n      fjac[j][4][1] = 0.0;\n      fjac[j][0][2] = (-((u[k][j][i][2] * u[k][j][i][2]) * tmp2)) + (c2 * qs[k][j][i]);\n      fjac[j][1][2] = ((-c2) * u[k][j][i][1]) * tmp1;\n      fjac[j][2][2] = ((2.0 - c2) * u[k][j][i][2]) * tmp1;\n      fjac[j][3][2] = ((-c2) * u[k][j][i][3]) * tmp1;\n      fjac[j][4][2] = c2;\n      fjac[j][0][3] = (-(u[k][j][i][2] * u[k][j][i][3])) * tmp2;\n      fjac[j][1][3] = 0.0;\n      fjac[j][2][3] = u[k][j][i][3] * tmp1;\n      fjac[j][3][3] = u[k][j][i][2] * tmp1;\n      fjac[j][4][3] = 0.0;\n      fjac[j][0][4] = ((((c2 * 2.0) * square[k][j][i]) - (c1 * u[k][j][i][4])) * u[k][j][i][2]) * tmp2;\n      fjac[j][1][4] = (((-c2) * u[k][j][i][1]) * u[k][j][i][2]) * tmp2;\n      fjac[j][2][4] = ((c1 * u[k][j][i][4]) * tmp1) - (c2 * (qs[k][j][i] + ((u[k][j][i][2] * u[k][j][i][2]) * tmp2)));\n      fjac[j][3][4] = ((-c2) * (u[k][j][i][2] * u[k][j][i][3])) * tmp2;\n      fjac[j][4][4] = (c1 * u[k][j][i][2]) * tmp1;\n      njac[j][0][0] = 0.0;\n      njac[j][1][0] = 0.0;\n      njac[j][2][0] = 0.0;\n      njac[j][3][0] = 0.0;\n      njac[j][4][0] = 0.0;\n      njac[j][0][1] = ((-c3c4) * tmp2) * u[k][j][i][1];\n      njac[j][1][1] = c3c4 * tmp1;\n      njac[j][2][1] = 0.0;\n      njac[j][3][1] = 0.0;\n      njac[j][4][1] = 0.0;\n      njac[j][0][2] = (((-con43) * c3c4) * tmp2) * u[k][j][i][2];\n      njac[j][1][2] = 0.0;\n      njac[j][2][2] = (con43 * c3c4) * tmp1;\n      njac[j][3][2] = 0.0;\n      njac[j][4][2] = 0.0;\n      njac[j][0][3] = ((-c3c4) * tmp2) * u[k][j][i][3];\n      njac[j][1][3] = 0.0;\n      njac[j][2][3] = 0.0;\n      njac[j][3][3] = c3c4 * tmp1;\n      njac[j][4][3] = 0.0;\n      njac[j][0][4] = (((((-(c3c4 - c1345)) * tmp3) * (u[k][j][i][1] * u[k][j][i][1])) - ((((con43 * c3c4) - c1345) * tmp3) * (u[k][j][i][2] * u[k][j][i][2]))) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][3] * u[k][j][i][3]))) - ((c1345 * tmp2) * u[k][j][i][4]);\n      njac[j][1][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][1];\n      njac[j][2][4] = (((con43 * c3c4) - c1345) * tmp2) * u[k][j][i][2];\n      njac[j][3][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][3];\n      njac[j][4][4] = c1345 * tmp1;\n    }\n\n    lhsinit(lhs, jsize);\n    for (j = 1; j <= (jsize - 1); j++)\n    {\n      tmp1 = dt * ty1;\n      tmp2 = dt * ty2;\n      lhs[j][AA][0][0] = (((-tmp2) * fjac[j - 1][0][0]) - (tmp1 * njac[j - 1][0][0])) - (tmp1 * dy1);\n      lhs[j][AA][1][0] = ((-tmp2) * fjac[j - 1][1][0]) - (tmp1 * njac[j - 1][1][0]);\n      lhs[j][AA][2][0] = ((-tmp2) * fjac[j - 1][2][0]) - (tmp1 * njac[j - 1][2][0]);\n      lhs[j][AA][3][0] = ((-tmp2) * fjac[j - 1][3][0]) - (tmp1 * njac[j - 1][3][0]);\n      lhs[j][AA][4][0] = ((-tmp2) * fjac[j - 1][4][0]) - (tmp1 * njac[j - 1][4][0]);\n      lhs[j][AA][0][1] = ((-tmp2) * fjac[j - 1][0][1]) - (tmp1 * njac[j - 1][0][1]);\n      lhs[j][AA][1][1] = (((-tmp2) * fjac[j - 1][1][1]) - (tmp1 * njac[j - 1][1][1])) - (tmp1 * dy2);\n      lhs[j][AA][2][1] = ((-tmp2) * fjac[j - 1][2][1]) - (tmp1 * njac[j - 1][2][1]);\n      lhs[j][AA][3][1] = ((-tmp2) * fjac[j - 1][3][1]) - (tmp1 * njac[j - 1][3][1]);\n      lhs[j][AA][4][1] = ((-tmp2) * fjac[j - 1][4][1]) - (tmp1 * njac[j - 1][4][1]);\n      lhs[j][AA][0][2] = ((-tmp2) * fjac[j - 1][0][2]) - (tmp1 * njac[j - 1][0][2]);\n      lhs[j][AA][1][2] = ((-tmp2) * fjac[j - 1][1][2]) - (tmp1 * njac[j - 1][1][2]);\n      lhs[j][AA][2][2] = (((-tmp2) * fjac[j - 1][2][2]) - (tmp1 * njac[j - 1][2][2])) - (tmp1 * dy3);\n      lhs[j][AA][3][2] = ((-tmp2) * fjac[j - 1][3][2]) - (tmp1 * njac[j - 1][3][2]);\n      lhs[j][AA][4][2] = ((-tmp2) * fjac[j - 1][4][2]) - (tmp1 * njac[j - 1][4][2]);\n      lhs[j][AA][0][3] = ((-tmp2) * fjac[j - 1][0][3]) - (tmp1 * njac[j - 1][0][3]);\n      lhs[j][AA][1][3] = ((-tmp2) * fjac[j - 1][1][3]) - (tmp1 * njac[j - 1][1][3]);\n      lhs[j][AA][2][3] = ((-tmp2) * fjac[j - 1][2][3]) - (tmp1 * njac[j - 1][2][3]);\n      lhs[j][AA][3][3] = (((-tmp2) * fjac[j - 1][3][3]) - (tmp1 * njac[j - 1][3][3])) - (tmp1 * dy4);\n      lhs[j][AA][4][3] = ((-tmp2) * fjac[j - 1][4][3]) - (tmp1 * njac[j - 1][4][3]);\n      lhs[j][AA][0][4] = ((-tmp2) * fjac[j - 1][0][4]) - (tmp1 * njac[j - 1][0][4]);\n      lhs[j][AA][1][4] = ((-tmp2) * fjac[j - 1][1][4]) - (tmp1 * njac[j - 1][1][4]);\n      lhs[j][AA][2][4] = ((-tmp2) * fjac[j - 1][2][4]) - (tmp1 * njac[j - 1][2][4]);\n      lhs[j][AA][3][4] = ((-tmp2) * fjac[j - 1][3][4]) - (tmp1 * njac[j - 1][3][4]);\n      lhs[j][AA][4][4] = (((-tmp2) * fjac[j - 1][4][4]) - (tmp1 * njac[j - 1][4][4])) - (tmp1 * dy5);\n      lhs[j][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[j][0][0])) + ((tmp1 * 2.0) * dy1);\n      lhs[j][BB][1][0] = (tmp1 * 2.0) * njac[j][1][0];\n      lhs[j][BB][2][0] = (tmp1 * 2.0) * njac[j][2][0];\n      lhs[j][BB][3][0] = (tmp1 * 2.0) * njac[j][3][0];\n      lhs[j][BB][4][0] = (tmp1 * 2.0) * njac[j][4][0];\n      lhs[j][BB][0][1] = (tmp1 * 2.0) * njac[j][0][1];\n      lhs[j][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[j][1][1])) + ((tmp1 * 2.0) * dy2);\n      lhs[j][BB][2][1] = (tmp1 * 2.0) * njac[j][2][1];\n      lhs[j][BB][3][1] = (tmp1 * 2.0) * njac[j][3][1];\n      lhs[j][BB][4][1] = (tmp1 * 2.0) * njac[j][4][1];\n      lhs[j][BB][0][2] = (tmp1 * 2.0) * njac[j][0][2];\n      lhs[j][BB][1][2] = (tmp1 * 2.0) * njac[j][1][2];\n      lhs[j][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[j][2][2])) + ((tmp1 * 2.0) * dy3);\n      lhs[j][BB][3][2] = (tmp1 * 2.0) * njac[j][3][2];\n      lhs[j][BB][4][2] = (tmp1 * 2.0) * njac[j][4][2];\n      lhs[j][BB][0][3] = (tmp1 * 2.0) * njac[j][0][3];\n      lhs[j][BB][1][3] = (tmp1 * 2.0) * njac[j][1][3];\n      lhs[j][BB][2][3] = (tmp1 * 2.0) * njac[j][2][3];\n      lhs[j][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[j][3][3])) + ((tmp1 * 2.0) * dy4);\n      lhs[j][BB][4][3] = (tmp1 * 2.0) * njac[j][4][3];\n      lhs[j][BB][0][4] = (tmp1 * 2.0) * njac[j][0][4];\n      lhs[j][BB][1][4] = (tmp1 * 2.0) * njac[j][1][4];\n      lhs[j][BB][2][4] = (tmp1 * 2.0) * njac[j][2][4];\n      lhs[j][BB][3][4] = (tmp1 * 2.0) * njac[j][3][4];\n      lhs[j][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[j][4][4])) + ((tmp1 * 2.0) * dy5);\n      lhs[j][CC][0][0] = ((tmp2 * fjac[j + 1][0][0]) - (tmp1 * njac[j + 1][0][0])) - (tmp1 * dy1);\n      lhs[j][CC][1][0] = (tmp2 * fjac[j + 1][1][0]) - (tmp1 * njac[j + 1][1][0]);\n      lhs[j][CC][2][0] = (tmp2 * fjac[j + 1][2][0]) - (tmp1 * njac[j + 1][2][0]);\n      lhs[j][CC][3][0] = (tmp2 * fjac[j + 1][3][0]) - (tmp1 * njac[j + 1][3][0]);\n      lhs[j][CC][4][0] = (tmp2 * fjac[j + 1][4][0]) - (tmp1 * njac[j + 1][4][0]);\n      lhs[j][CC][0][1] = (tmp2 * fjac[j + 1][0][1]) - (tmp1 * njac[j + 1][0][1]);\n      lhs[j][CC][1][1] = ((tmp2 * fjac[j + 1][1][1]) - (tmp1 * njac[j + 1][1][1])) - (tmp1 * dy2);\n      lhs[j][CC][2][1] = (tmp2 * fjac[j + 1][2][1]) - (tmp1 * njac[j + 1][2][1]);\n      lhs[j][CC][3][1] = (tmp2 * fjac[j + 1][3][1]) - (tmp1 * njac[j + 1][3][1]);\n      lhs[j][CC][4][1] = (tmp2 * fjac[j + 1][4][1]) - (tmp1 * njac[j + 1][4][1]);\n      lhs[j][CC][0][2] = (tmp2 * fjac[j + 1][0][2]) - (tmp1 * njac[j + 1][0][2]);\n      lhs[j][CC][1][2] = (tmp2 * fjac[j + 1][1][2]) - (tmp1 * njac[j + 1][1][2]);\n      lhs[j][CC][2][2] = ((tmp2 * fjac[j + 1][2][2]) - (tmp1 * njac[j + 1][2][2])) - (tmp1 * dy3);\n      lhs[j][CC][3][2] = (tmp2 * fjac[j + 1][3][2]) - (tmp1 * njac[j + 1][3][2]);\n      lhs[j][CC][4][2] = (tmp2 * fjac[j + 1][4][2]) - (tmp1 * njac[j + 1][4][2]);\n      lhs[j][CC][0][3] = (tmp2 * fjac[j + 1][0][3]) - (tmp1 * njac[j + 1][0][3]);\n      lhs[j][CC][1][3] = (tmp2 * fjac[j + 1][1][3]) - (tmp1 * njac[j + 1][1][3]);\n      lhs[j][CC][2][3] = (tmp2 * fjac[j + 1][2][3]) - (tmp1 * njac[j + 1][2][3]);\n      lhs[j][CC][3][3] = ((tmp2 * fjac[j + 1][3][3]) - (tmp1 * njac[j + 1][3][3])) - (tmp1 * dy4);\n      lhs[j][CC][4][3] = (tmp2 * fjac[j + 1][4][3]) - (tmp1 * njac[j + 1][4][3]);\n      lhs[j][CC][0][4] = (tmp2 * fjac[j + 1][0][4]) - (tmp1 * njac[j + 1][0][4]);\n      lhs[j][CC][1][4] = (tmp2 * fjac[j + 1][1][4]) - (tmp1 * njac[j + 1][1][4]);\n      lhs[j][CC][2][4] = (tmp2 * fjac[j + 1][2][4]) - (tmp1 * njac[j + 1][2][4]);\n      lhs[j][CC][3][4] = (tmp2 * fjac[j + 1][3][4]) - (tmp1 * njac[j + 1][3][4]);\n      lhs[j][CC][4][4] = ((tmp2 * fjac[j + 1][4][4]) - (tmp1 * njac[j + 1][4][4])) - (tmp1 * dy5);\n    }\n\n    binvcrhs(lhs[0][BB], lhs[0][CC], rhs[k][0][i]);\n    for (j = 1; j <= (jsize - 1); j++)\n    {\n      matvec_sub(lhs[j][AA], rhs[k][j - 1][i], rhs[k][j][i]);\n      matmul_sub(lhs[j][AA], lhs[j - 1][CC], lhs[j][BB]);\n      binvcrhs(lhs[j][BB], lhs[j][CC], rhs[k][j][i]);\n    }\n\n    matvec_sub(lhs[jsize][AA], rhs[k][jsize - 1][i], rhs[k][jsize][i]);\n    matmul_sub(lhs[jsize][AA], lhs[jsize - 1][CC], lhs[jsize][BB]);\n    binvrhs(lhs[jsize][BB], rhs[k][jsize][i]);\n    for (j = jsize - 1; j >= 0; j--)\n    {\n      for (m = 0; m < BLOCK_SIZE; m++)\n      {\n        for (n = 0; n < BLOCK_SIZE; n++)\n        {\n          rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[j][CC][n][m] * rhs[k][j + 1][i][n]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) shared(jsize) private(i,j,k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/y_solve/0"}
{"code": "for (int i = 0; i < src_size; i++)\n  h_src[i] = rand() % 256;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/surfel-omp/main/0"}
{"code": "for (int y = 0; y < Ly; y++)\n  for (int x = 1; x < ((Lx / 4) - 1); x++)\n{\n  int lx = Lx / 4;\n  int v00 = x + (y * lx);\n  int v0p = v00 + 1;\n  int v0m = v00 - 1;\n  int vp0 = x + (((y + 1) % Ly) * lx);\n  int vm0 = x + (((Ly + (y - 1)) % Ly) * lx);\n  register int in00 = _mm_load_ps(&in[v00].site4[0]);\n  register int in0p = _mm_load_ps(&in[v0p].site4[0]);\n  register int in0m = _mm_load_ps(&in[v0m].site4[0]);\n  register int inp0 = _mm_load_ps(&in[vp0].site4[0]);\n  register int inm0 = _mm_load_ps(&in[vm0].site4[0]);\n  register int hop = _mm_add_ps(inm0, inp0);\n  hop = _mm_add_ps(hop, in0p);\n  hop = _mm_add_ps(hop, in0m);\n  hop = _mm_mul_ps(hop, vdelta);\n  register int dia = _mm_mul_ps(vnorm, in00);\n  hop = _mm_add_ps(dia, hop);\n  _mm_store_ps(&out[v00].site4[0], hop);\n}\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/heat2d-cuda/lapl_ss/0"}
{"code": "for (int index = (width * height) - 1; index >= 0; --index)\n{\n  if (segmentation_map[index] > 0)\n  {\n    uint32_t indexHistoryBuffer = index * numberOfTests;\n    uint8_t currentValue = image_data[index];\n    for (int i = numberOfTests; i > 0; --i, ++indexHistoryBuffer)\n    {\n      if (abs_uint(currentValue - historyBuffer[indexHistoryBuffer]) <= matchingThreshold)\n      {\n        --segmentation_map[index];\n        uint8_t temp = swappingImageBuffer[index];\n        swappingImageBuffer[index] = historyBuffer[indexHistoryBuffer];\n        historyBuffer[indexHistoryBuffer] = temp;\n        if (segmentation_map[index] <= 0)\n          break;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/6"}
{"code": "for (i = 0; i < DIM; i++)\n  if (mins_parall_red[i] > max_of_mins_parall_red)\n{\n  max_of_mins_parall_red = mins_parall_red[i];\n}\n\n\n", "pragma": "#pragma omp parallel for shared(mins_parall_red) reduction(max: max_of_mins_parall_red)  private(i) num_threads(num_threads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/min_max_matrix_element/3"}
{"code": "for (i = 0; i < num_its; i++)\n  cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, n, n, n, alpha, A, n, B, n, beta, C_itlmkl_cpumic, n);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/7"}
{"code": "for (size_t i = 0; i < z.size(); i++)\n  act_val[i + version] = 1 / (1 + exp(-z[i]));\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatheusNBDG/Neural-Network/neuron/0"}
{"code": "for (int ax = 0; ax < 3; ax++)\n{\n  if (cpuInv[ax].size() != gpuInv[ax].size())\n  {\n    axErr[ax] = 1;\n    continue;\n  }\n\n  if (memcmp(&cpuInv[ax][0], &gpuInv[ax][0], cpuInv[ax].size() * (sizeof(Vector2i))) != 0)\n    axErr[ax] = 2;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/OpenCLCollider/4"}
{"code": "for (int i = j; i < (j + blockSize); i++)\n{\n  A[i] += B[i] + C[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute/test/0"}
{"code": "for (j = 0; j < m; j++)\n  b[i][j] = i * j;\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB014-outofbounds-orig-yes/1"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float v = vs[n];\n  float thr = Radians(ths[n]);\n  float vx = v * cos(thr);\n  float vy = v * sin(thr);\n  float g = gs[n];\n  float h = hs[n];\n  float d = ds[n];\n  float t = (-(2 * vy)) / GRAVITY;\n  float x = 0. + (vx * t);\n  if (x <= g)\n  {\n    if (DEBUG)\n      fprintf(stderr, \"Ball doesn't even reach the cliff\\n\");\n\n  }\n  else\n  {\n    t = g / vx;\n    float y = (0. + (vy * t)) + ((0.5 * GRAVITY) * (t * t));\n    if (y <= h)\n    {\n      if (DEBUG)\n        fprintf(stderr, \"Ball hits the cliff face\\n\");\n\n    }\n    else\n    {\n      float a = GRAVITY / 2.;\n      float b = vy;\n      float c = -h;\n      float disc = (b * b) - ((4.f * a) * c);\n      if (disc < 0.)\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Ball doesn't reach the upper deck.\\n\");\n\n        exit(1);\n      }\n\n      disc = sqrtf(disc);\n      float t1 = ((-b) + disc) / (2.f * a);\n      float t2 = ((-b) - disc) / (2.f * a);\n      float tmax = t1;\n      if (t2 > t1)\n        tmax = t2;\n\n      float upperDist = (vx * tmax) - g;\n      if (fabs(upperDist - d) > TOL)\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Misses the castle at upperDist = %8.3f\\n\", upperDist);\n\n      }\n      else\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Hits the castle at upperDist = %8.3f\\n\", upperDist);\n\n        numHits += 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(vs, ths, gs, hs, ds, stderr) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Abhi-Balijepalli/monte-carlo-simulation/monte_carlo/0"}
{"code": "for (i = 0; i < (strlen(seq) + 1); i++)\n{\n  if (i == index)\n  {\n    strncat(mutant, &ch, 1);\n  }\n\n  strncat(mutant, &seq[i], 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yonatanblum/Parallel-implementation-of-Sequence-Allignment-MPI-openMP/MPI_OpenMP_functions/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = i + 1; j < N; j++)\n  {\n    Pbp[i][j] = ((Q[0][i] * Q[j][N - 1]) * Qbp[i][j]) / Q[0][N - 1];\n    for (p = 0; p < i; p++)\n    {\n      for (q = j + 1; q < N; q++)\n      {\n        Pbp[i][j] += ((((Pbp[p][q] * ERT) * Q[p + 1][i]) * Qbp[i][j]) * Q[j + 1][q - 1]) / ((Qbp[p][q] == 0) ? (1) : (Qbp[p][q]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mcc_traco/6"}
{"code": "for (uint bucket = 1; bucket < numBuckets; ++bucket)\n{\n  globalHistoExScan[bucket] = globalHistoExScan[bucket - 1] + globalHisto[bucket - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/solution/radixsort_solution/4"}
{"code": "for (int i = 0; i < noOfElements; i++)\n{\n  arrWrite[i] = rand() % 100;\n  a3[i] = arrWrite[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AniMahajan20/Parallel-Computing/HyperQuickSort using OpenMP/hyperquicksort_openmp/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < (m - 1); j++)\n  b[i][j] = b[i][j + 1];\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/outeronly1-orig-no/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Iteration %d done by thread %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JulianArmour/openmp_test/openmptest/0"}
{"code": "for (j = strlen(MaxB) - 1; j > (-1); --j)\n{\n  OptB[k] = MaxB[j];\n  ++k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/12"}
{"code": "for (size_t i = 0; i < (row - 1); i++)\n{\n  for (size_t j = 0; j < (row - 1); j++)\n  {\n    if (atof(content[(j * column) + 3].c_str()) < atof(content[((j + 1) * column) + 3].c_str()))\n    {\n      temp[0] = content[j * column];\n      temp[1] = content[(j * column) + 1];\n      temp[2] = content[(j * column) + 2];\n      temp[3] = content[(j * column) + 3];\n      content[j * column] = content[(j + 1) * column];\n      content[(j * column) + 1] = content[((j + 1) * column) + 1];\n      content[(j * column) + 2] = content[((j + 1) * column) + 2];\n      content[(j * column) + 3] = content[((j + 1) * column) + 3];\n      content[(j + 1) * column] = temp[0];\n      content[((j + 1) * column) + 1] = temp[1];\n      content[((j + 1) * column) + 2] = temp[2];\n      content[((j + 1) * column) + 3] = temp[3];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/2"}
{"code": "for (int i = 1; i < (N - 1); ++i)\n{\n  for (int j = 1; j < (N - 1); ++j)\n  {\n    psi[i][j] = psi[i][j] / c(sqrt(sum));\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruifm/gross-pitaevskii/g25s6c3b/6"}
{"code": "for (i = 1; i <= tamA; i++)\n{\n  if (n > temp[i])\n  {\n    n = temp[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/BusquedaEREW/4"}
{"code": "for (int i = 1; i < N; i++)\n{\n  X[i] = X[i - 1] + dx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stu314159/lax_openmp/lax_wave/0"}
{"code": "for (long i = 0; i < num_trials; i++)\n{\n  x = random();\n  y = random();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    circ_count++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/alg_pi_calculate/0"}
{"code": "for (int i = 0; i < deviceCount; i++)\n  cudaGetDeviceProperties(&prop[i], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erictang000/GPU-BSW-Work-Stealing/driver/7"}
{"code": "for (i = c + 1; i < 150; i++)\n{\n  e[2][i] = a1[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/6"}
{"code": "for (i = 0; i < grid_sz; i++)\n{\n  for (j = 0; j < grid_sz; j++)\n  {\n    if (l == (GRIDBUFFER / 2))\n    {\n      curr_buffer++;\n      l = 0;\n    }\n\n    for (d = 0; d < n_pr; d++)\n    {\n      new_x += buffers[d][curr_buffer][2 * l];\n      new_y += buffers[d][curr_buffer][(2 * l) + 1];\n    }\n\n    grid[i][j].center.x = new_x;\n    grid[i][j].center.y = new_y;\n    grid[i][j].Mnext = 0;\n    new_x = 0;\n    new_y = 0;\n    l++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/grid/7"}
{"code": "for (int j = 0; j < (r - m); j++)\n{\n  arr1[((j + m) - l) + 1] = arr[(m + 1) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashwinikumar2/Parallel-Merge-Quick-and-Radix-Sort-using-OpenMP/sort/1"}
{"code": "for (int i = 0; i < rainhas; i++)\n{\n  id = omp_get_thread_num();\n  tabuleiro[id][0] = i;\n  solucao(rainhas, 1, tabuleiro[id], id, &count);\n}\n\n", "pragma": "omp parallel for schedule(dynamic) default(shared) num_threads(threads) reduction (+:count) private(id)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brendonhps/parallel-nqueens/codigos_c/recursivo_paralelo/0"}
{"code": "for (node_t c; c < noofComm; c++)\n{\n  assert(clusterPositions[cd[c].id] == c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/14"}
{"code": "for (nb = 0; nb < 10; nb++)\n{\n  matmul_openmp(n, A, B, C);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/matmul/3"}
{"code": "for (int j = 0; j < 9; j++)\n  for (int i = 0; i < nprocs_mpi; i++)\n  S[j] += TT[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/22"}
{"code": "for (j = 0; j < num_snakes; j++)\n{\n  if (collision == 1)\n  {\n    world[snakes[j].head.line][snakes[j].head.col] = 0;\n    world[tail[j].line][tail[j].col] = snakes[j].encoding;\n    if ((snakes[j].head.line != 0) && (world[snakes[j].head.line - 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line -= 1;\n    }\n    else\n      if ((snakes[j].head.line == 0) && (world[num_lines - 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line = num_lines - 1;\n    }\n    else\n      if ((snakes[j].head.col != 0) && (world[snakes[j].head.line][snakes[j].head.col - 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col -= 1;\n    }\n    else\n      if ((snakes[j].head.col == 0) && (world[snakes[j].head.line][num_cols - 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col = num_cols - 1;\n    }\n    else\n      if ((snakes[j].head.line != (num_lines - 1)) && (world[snakes[j].head.line + 1][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line += 1;\n    }\n    else\n      if ((snakes[j].head.line == (num_lines - 1)) && (world[0][snakes[j].head.col] == snakes[j].encoding))\n    {\n      snakes[j].head.line = 0;\n    }\n    else\n      if ((snakes[j].head.col != (num_cols - 1)) && (world[snakes[j].head.line][snakes[j].head.col + 1] == snakes[j].encoding))\n    {\n      snakes[j].head.col += 1;\n    }\n    else\n      if ((snakes[j].head.col == (num_cols - 1)) && (world[snakes[j].head.line][0] == snakes[j].encoding))\n    {\n      snakes[j].head.col = 0;\n    }\n\n\n\n\n\n\n\n\n  }\n  else\n    if (collision == 0)\n  {\n    if ((tail[j].line != 0) && (world[tail[j].line - 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line -= 1;\n    }\n    else\n      if ((tail[j].line == 0) && (world[num_lines - 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line = num_lines - 1;\n    }\n    else\n      if ((tail[j].col != 0) && (world[tail[j].line][tail[j].col - 1] == snakes[j].encoding))\n    {\n      tail[j].col -= 1;\n    }\n    else\n      if ((tail[j].col == 0) && (world[tail[j].line][num_cols - 1] == snakes[j].encoding))\n    {\n      tail[j].col = num_cols - 1;\n    }\n    else\n      if ((tail[j].line != (num_lines - 1)) && (world[tail[j].line + 1][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line += 1;\n    }\n    else\n      if ((tail[j].line == (num_lines - 1)) && (world[0][tail[j].col] == snakes[j].encoding))\n    {\n      tail[j].line = 0;\n    }\n    else\n      if ((tail[j].col != (num_cols - 1)) && (world[tail[j].line][tail[j].col + 1] == snakes[j].encoding))\n    {\n      tail[j].col += 1;\n    }\n    else\n      if ((tail[j].col == (num_cols - 1)) && (world[tail[j].line][0] == snakes[j].encoding))\n    {\n      tail[j].col = 0;\n    }\n\n\n\n\n\n\n\n\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yanxiaojing16/Parallel-Snake---OpenMP/parallel_snake/1"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    calculate_dt_kernel(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[1 * n], &((double *) arg2.data)[1 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[6].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/calculate_dt_kernel_kernel/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 100; j++)\n  {\n    C[i][j] = 0;\n    for (int k = 0; k < 100; k++)\n    {\n      C[i][j] += mat[i][k] * mat[i][k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dani1900/Homee/Unrolled/0"}
{"code": "for (i = 0; i < len; i++)\n  sum += powf(priceArr[i] - mean_price, 2.0f);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RajdeepKonwar/stockast/stockast/1"}
{"code": "for (uint64_t i = 0; i < bins; i++)\n  arrs[begin][i] += arrs[pivot][i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/4"}
{"code": "for (int i = s + 1; i < e; i++)\n  input[i] = input[i - 1] + input[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/prefixsum/3"}
{"code": "for (i = 0; i < ((ic * jc) + icoff); i++)\n  C[i] = 1.0 - (2.0 * drand48());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/2"}
{"code": "for (j = 0; j < walkers; j++)\n{\n  xpos[j] += dr * cos(thet[(i * walkers) + j]);\n  ypos[j] += dr * sin(thet[(i * walkers) + j]);\n  xij = xpos[j];\n  yij = ypos[j];\n  msd += (xij * xij) + (yij * yij);\n}\n\n", "pragma": "omp for reduction(+:msd)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/random_walk_c_omp/0"}
{"code": "for (int i = 0; i < 360; ++i)\n  histsum += histogram_DD[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mabutko/CosmicDarkMatter/galaxy_openmp/3"}
{"code": "for (int i = 0; i < (((ancho * 3) + pivot) * alto); i += 3)\n{\n  *(arr_out + i) = arr_flip[index].b;\n  *((arr_out + i) + 1) = arr_flip[index].g;\n  *((arr_out + i) + 2) = arr_flip[index].r;\n  index++;\n  count += 3;\n  if (count == (ancho * 3))\n  {\n    i += pivot;\n    count = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A01021190/IoTTutorialIan/schedule/6"}
{"code": "for (size_t ci = 0U; ci < ncolors; ci++)\n  if (freq[ci] > 1088)\n  overSize[ci] = true;\n\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/bColoring/mBase/0"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int k = 0; k < K; k += r)\n  {\n    for (int j = 0; j < N; j += r)\n    {\n      for (int kb = k; kb < (k + r); kb++)\n      {\n        for (int jb = j; jb < (j + r); jb++)\n        {\n          C[(i * N) + jb] += A[(i * K) + kb] * B[(kb * N) + jb];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ajs7270/snu_shpc21/hw3/mat_mul/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  int my_rank = omp_get_thread_num();\n  int thread_count = omp_get_num_threads();\n  j = my_rank;\n  printf(\"hello from thread %d of %d\\n\", my_rank, thread_count);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(thread_count) lastprivate(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orange2xiaoyu/learning_openmp/firstprivate_lastprivate/0"}
{"code": "for (int m = 0; m < num_threads; m++)\n{\n  {\n    if (me == 0)\n      fp = fopen(\"finally_sorted.txt\", \"w\");\n    else\n    {\n      fp = fopen(\"finally_sorted.txt\", \"a\");\n    }\n\n    for (i = 0; i < N; i++)\n    {\n      fprintf(fp, \"%lf %lf\\n\", b_pr[i], c_pr[i]);\n    }\n\n    fclose(fp);\n  }\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Insertion-Sort-Using-OpenMP/insertion_sort_parallel/0"}
{"code": "for (k = 0; k < N; k++)\n{\n  Xr_o[k] += (xr[n] * cos(((n * k) * 6.28318530718) / N)) + ((idft * xi[n]) * sin(((n * k) * 6.28318530718) / N));\n  Xi_o[k] += (((-idft) * xr[n]) * sin(((n * k) * 6.28318530718) / N)) + (xi[n] * cos(((n * k) * 6.28318530718) / N));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/dftw/0"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n{\n  A[i][j] = rand();\n  B[i][j] = rand();\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshan14/matrix-multiplication-openMP/MatrixMultiplication/3"}
{"code": "for (i = 0; i < myProductsSize; i++)\n{\n  sendProduct(&myProducts[i], 0, MPI_Product);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/10"}
{"code": "for (int row = 0; row < nel; row++)\n{\n  for (int col = 0; col < nel; col++)\n  {\n    if (row >= col)\n    {\n      continue;\n    }\n\n    int map_row;\n    int map_col;\n    int rank;\n    matrix_to_map_index(row, col, nel, &map_row, &map_col, np);\n    rank = get_map(map, np, map_row, map_col);\n    if (rank == myrank)\n    {\n      int index_part;\n      if (map_row == map_col)\n      {\n        index_part = 0;\n      }\n      else\n        if ((map_row == rank) && (map_col > rank))\n      {\n        index_part = map_col - rank;\n      }\n      else\n        if ((map_col == rank) && (map_row < rank))\n      {\n        index_part = (np - map_col) + map_row;\n      }\n      else\n      {\n        index_part = -1;\n        ((cerr << \"Errore slave_print_global_matrix: \") << \"indici mappa errati\") << endl;\n      }\n\n\n\n      int local_row;\n      int local_col;\n      sim_metric val;\n      if (r == 0)\n      {\n        local_col = col - (q * map_col);\n        local_row = row - (q * map_row);\n        if (index_part == 0)\n        {\n          val = get((*matrix_parts)[index_part], q, local_row, local_col);\n        }\n        else\n        {\n          val = (*matrix_parts)[index_part][(local_row * q) + local_col];\n        }\n\n      }\n      else\n      {\n        local_col = col - (((q + 1) * map_col) - MIN(map_col, np - r));\n        local_row = row - (((q + 1) * map_row) - MIN(map_row, np - r));\n        if (index_part == 0)\n        {\n          val = get((*matrix_parts)[index_part], (map_col < (np - r)) ? (q) : (q + 1), local_row, local_col);\n        }\n        else\n        {\n          val = (*matrix_parts)[index_part][(local_row * ((map_col < (np - r)) ? (q) : (q + 1))) + local_col];\n        }\n\n      }\n\n      MPI_Send(&val, sizeof(sim_metric), MPI_BYTE, 0, TAG_PRINT, MPI_COMM_WORLD);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/22"}
{"code": "for (long int idxLoop = 0; idxLoop < NbLoops; ++idxLoop)\n{\n  ompFibonnaciDy += FibonacciOmpDy(TestSize, fiboMap);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/fibonnaci/2"}
{"code": "for (i = 0; i < N; i++)\n  free(u[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe1/Tsouros_exe1/8"}
{"code": "for (c2 = 0; c2 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/55"}
{"code": "for (int i = 0; i < n1; ++i)\n  que0[num0++] = I[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziqi-zhang/Parallel-DAG-Traversal/openmp/3"}
{"code": "for (int i = 0; i < 2; ++i)\n  for (k = 0; k < argc; k++)\n  ;\n\n\n", "pragma": "#pragma omp for lastprivate(k) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/loops_explicit_clauses_codegen/1"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int rank_task_size;\n  MPI_Recv(&rank_task_size, 1, MPI_INT, MPI_ANY_SOURCE, collect_results_tag, comm, &status);\n  int task_penalties[rank_task_size];\n  MPI_Recv(task_penalties, rank_task_size, MPI_INT, status.MPI_SOURCE, collect_results_tag2, comm, &status);\n  char buffer[sha512_strlen];\n  for (int j = 0; j < rank_task_size; j++)\n  {\n    int task_id = tasks[status.MPI_SOURCE].at(j).z;\n    penalties[task_id] = task_penalties[j];\n    MPI_Recv(buffer, 128, MPI_CHAR, status.MPI_SOURCE, collect_results_tag3, comm, &status);\n    answers_hash[task_id] = string(buffer, 128);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing10/test/3"}
{"code": "for (i = 1; i <= n; i++)\n{\n  for (j = i + 1; j <= n; j++)\n  {\n    if (L[i] > L[j])\n    {\n      win[i] = win[i] + 1;\n    }\n    else\n    {\n      win[j] = win[j] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoCRCW/1"}
{"code": "for (i = 0; i < bands; i++)\n{\n  printf(\"Calcul. Noise using Mul. Regression at band %d of %d\", i + 1, bands);\n  for (j = 0; j < i; j++)\n  {\n    fseek(fin, (j * cols) * (sizeof(float)), 0);\n    for (k = 0; k < rows; k++)\n    {\n      fread(buffer, sizeof(float), cols, fin);\n      for (l = 0; l < cols; l++)\n      {\n        Z[(k * cols) + l][j] = buffer[l];\n      }\n\n      fseek(fin, ((bands - 1) * cols) * (sizeof(float)), 1);\n    }\n\n  }\n\n  for (j = i; j < (bands - 1); j++)\n  {\n    fseek(fin, ((j + 1) * cols) * (sizeof(float)), 0);\n    for (k = 0; k < rows; k++)\n    {\n      fread(buffer, sizeof(float), cols, fin);\n      for (l = 0; l < cols; l++)\n      {\n        Z[(k * cols) + l][j] = buffer[l];\n      }\n\n      fseek(fin, ((bands - 1) * cols) * (sizeof(float)), 1);\n    }\n\n  }\n\n  fseek(fin, (i * cols) * (sizeof(float)), 0);\n  for (j = 0; j < rows; j++)\n  {\n    fread(buffer, sizeof(float), cols, fin);\n    for (k = 0; k < cols; k++)\n    {\n      z[(j * cols) + k] = buffer[k];\n    }\n\n    fseek(fin, ((bands - 1) * cols) * (sizeof(float)), 1);\n  }\n\n  for (j = 0; j < (bands - 1); j++)\n  {\n    for (k = 0; k < (bands - 1); k++)\n    {\n      zTz[j][k] = 0.0;\n    }\n\n  }\n\n  for (j = 0; j < (bands - 1); j++)\n  {\n    for (k = 0; k < (bands - 1); k++)\n    {\n      tmp = 0.0;\n      for (l = 0; l < (rows * cols); l++)\n      {\n        tmp += Z[l][k] * Z[l][j];\n      }\n\n      zTz[j][k] = tmp;\n    }\n\n  }\n\n  for (j = 0; j < (bands - 1); j++)\n  {\n    for (k = 0; k < (bands - 1); k++)\n    {\n      zTzl[(j * (bands - 1)) + k] = zTz[j][k];\n    }\n\n  }\n\n  Matrix_inversion(zTzl, zTzl_inv, bands - 1);\n  for (j = 0; j < (bands - 1); j++)\n  {\n    for (k = 0; k < (bands - 1); k++)\n    {\n      zTz_inv[j][k] = zTzl_inv[(j * (bands - 1)) + k];\n    }\n\n  }\n\n  for (j = 0; j < (bands - 1); j++)\n  {\n    for (k = 0; k < (rows * cols); k++)\n    {\n      tmp = 0.0;\n      for (l = 0; l < (bands - 1); l++)\n      {\n        tmp += zTz_inv[j][l] * Z[k][l];\n      }\n\n      R[j][k] = tmp;\n    }\n\n  }\n\n  for (j = 0; j < (bands - 1); j++)\n  {\n    tmp = 0.0;\n    for (k = 0; k < (rows * cols); k++)\n    {\n      tmp += R[j][k] * z[k];\n    }\n\n    b[j] = tmp;\n  }\n\n  for (j = 0; j < (rows * cols); j++)\n  {\n    tmp = 0.0;\n    for (k = 0; k < (bands - 1); k++)\n    {\n      tmp += Z[j][k] * b[k];\n    }\n\n    c[j] = tmp;\n  }\n\n  for (j = 0; j < (rows * cols); j++)\n  {\n    if (z[j] != nvalue)\n    {\n      noise2[j] = (float) (z[j] - c[j]);\n    }\n    else\n    {\n      noise2[j] = nvalue;\n    }\n\n  }\n\n  fprintf(report, \"\\nnoise=\\n\");\n  for (j = 0; j < 400; j++)\n  {\n    fprintf(report, \"%f \", noise2[j]);\n  }\n\n  fprintf(report, \"\\n\");\n  if (fseek(fnoise, (i * cols) * (sizeof(float)), 0) != 0)\n  {\n    puts(\"Bad File Rewind\");\n  }\n\n  for (j = 0; j < rows; j++)\n  {\n    fwrite(noise2 + (j * cols), sizeof(float), cols, fnoise);\n    if (fseek(fnoise, (cols * (bands - 1)) * (sizeof(float)), 1) != 0)\n    {\n      puts(\"Bad File Control\");\n    }\n\n    fflush(0);\n  }\n\n  tend = omp_get_wtime();\n  printf(\" Duration: %2.2lf min\\r\", (tend - tstart) / 60.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/24"}
{"code": "for (i = 0; i < result->rows; i++)\n{\n  float *rrow = (float *) (result->data.ptr + (i * result->step));\n  idx = i * sum_step;\n  idx2 = i * sqsum_step;\n  for (j = 0; j < result->cols; j++, idx += cn, idx2 += cn)\n  {\n    double num = rrow[j];\n    double t;\n    double wnd_mean2 = 0;\n    double wnd_sum2 = 0;\n    if (num_type == 1)\n    {\n      for (k = 0; k < cn; k++)\n      {\n        t = ((p0[idx + k] - p1[idx + k]) - p2[idx + k]) + p3[idx + k];\n        wnd_mean2 += CV_SQR(t);\n        num -= t * templ_mean.val[k];\n      }\n\n      wnd_mean2 *= inv_area;\n    }\n\n    if (is_normed || (num_type == 2))\n    {\n      for (k = 0; k < cn; k++)\n      {\n        t = ((q0[idx2 + k] - q1[idx2 + k]) - q2[idx2 + k]) + q3[idx2 + k];\n        wnd_sum2 += t;\n      }\n\n      if (num_type == 2)\n        num = (wnd_sum2 - (2 * num)) + templ_sum2;\n\n    }\n\n    if (is_normed)\n    {\n      t = sqrt(MAX(wnd_sum2 - wnd_mean2, 0)) * templ_norm;\n      if (t > DBL_EPSILON)\n      {\n        num /= t;\n        if (fabs(num) > 1.)\n          num = (num > 0) ? (1) : (-1);\n\n      }\n      else\n        num = ((method != CV_TM_SQDIFF_NORMED) || (num < DBL_EPSILON)) ? (0) : (1);\n\n    }\n\n    rrow[j] = (float) num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvtemplmatch/1"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i)\n{\n  pred_vtx[i - i_start] = get_pred_from_pred_entry(pred[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/validate/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  int dis = distLine(p1, p2, points[i]);\n  if (dis > max_dis)\n  {\n    dis = max_dis;\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/quickhull/0"}
{"code": "for (i = sharedFrontierQueue->head; i < sharedFrontierQueue->tail; i++)\n{\n  v = sharedFrontierQueue->queue[i];\n  graphGridSetActivePartitionsMap(graph->grid, v);\n}\n\n", "pragma": "omp parallel for default(none) shared(graph,sharedFrontierQueue) private(i,v) schedule(dynamic,1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/10"}
{"code": "for (INT i = 0; i < ite; i++)\n{\n  Avx2_Madd(Csr2_mid_val, Csr2_mtx_val, col_idx, vec_val, par_set);\n  Avx2_SegSum(Csr2_row_ptr, Csr2_mid_val, mtx_ans, par_set);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/CSR2/CSR2_SPMV/7"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  array[i] = value;\n}\n\n", "pragma": "omp parallel for num_threads(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/h4koo/Arquitectura-taller2/src/saxpy_par/1"}
{"code": "for (size_t j = 0; j < gridDimY; ++j)\n{\n  for (size_t k = 0; k < gridDimX; ++k)\n  {\n    if (gridXY(k, j) > 0)\n      continue;\n\n    ++numEmpty;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/9"}
{"code": "for (k = 0; k < myp1; k++)\n{\n  kk = (ndim * nxe) * k;\n  for (i = 0; i < ndim; i++)\n  {\n    fxy[(i + (ndim * nx)) + kk] = fxy[i + kk];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/32"}
{"code": "for (i = 0; i <= m; i++)\n{\n  w[i] = ((float) rand()) / 32767;\n  w[i] = 0.1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/backprop/src/backprop-AI/1"}
{"code": "for (; i < count; i++)\n  if (d == output1x[(i * 4) + 3])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash1_fmt_plug/4"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  D.zeros();\n  assignew = Assign(data_proc, D, P, n, cov_num, strt_num, level_num, omega, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Up;\n  TU = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (Up - diff_data);\n  mupdate = ((Up - diff_data) > (2 * (Um - diff_data))) || ((Up - diff_data) < ((Um - diff_data) * 0.5));\n  Up = (TU > (diff_data - ((Up * n1c) / n))) ? (Up - ((c * alpha) / m)) : (Up + ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Um = (mupdate) ? (Up) : (Um);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/14"}
{"code": "for (i = 0; i < series->count; i++)\n{\n  sum += var[i];\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = x[i];\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/8"}
{"code": "for (x = 1; x < (STENCIL_SIZE_X - 1); x++)\n{\n  for (y = 1; y < (STENCIL_SIZE_Y - 1); y++)\n  {\n    values[next_buffer][x][y] = ((((alpha * values[prev_buffer][x - 1][y]) + (alpha * values[prev_buffer][x + 1][y])) + (alpha * values[prev_buffer][x][y - 1])) + (alpha * values[prev_buffer][x][y + 1])) + ((1.0 - (4.0 * alpha)) * values[prev_buffer][x][y]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(static) shared(values) firstprivate(prev_buffer, next_buffer)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MehdiHALA/Mpi-x-project/src/stencil_omp/0"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NJ; j++)\n  {\n    E[(i * NJ) + j] = 0;\n    for (k = 0; k < NK; ++k)\n    {\n      E[(i * NJ) + j] += A[(i * NK) + k] * B[(k * NJ) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/3MM/3mm_omp_out/5"}
{"code": "for (int i = 0; i < HEIGHT; ++i)\n{\n  field_backup[i] = malloc(WIDTH * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/6"}
{"code": "for (unsigned int j = 0; j < M.mesh.y_coordinates.size(); j++)\n{\n  for (unsigned int i = 0; i < M.mesh.x_coordinates.size(); i++)\n  {\n    int n = M.voxel_index(i, j, 0);\n    (*M.p_density_vectors)[n] /= M.thomas_denomz[0];\n    for (unsigned int k = 1; k < M.mesh.z_coordinates.size(); k++)\n    {\n      n = M.voxel_index(i, j, k);\n      axpy(&(*M.p_density_vectors)[n], M.thomas_constant1, (*M.p_density_vectors)[n - M.thomas_k_jump]);\n      (*M.p_density_vectors)[n] /= M.thomas_denomz[k];\n    }\n\n    for (int k = M.mesh.z_coordinates.size() - 2; k >= 0; k--)\n    {\n      n = M.voxel_index(i, j, k);\n      naxpy(&(*M.p_density_vectors)[n], M.thomas_cz[k], (*M.p_density_vectors)[n + M.thomas_k_jump]);\n    }\n\n  }\n\n}\n\n", "pragma": " #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_solvers/5"}
{"code": "for (i = 0; i <= N; i++)\n{\n  fibbonaci[i].n = 38 + i;\n  fibbonaci[i].result = fib(38 + i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcinbogiel/OpenMP_examples/My solutions/exercise_6/3"}
{"code": "for (int _i = 1; _i < sN; _i++)\n  for (int _k = 1; _k < K; _k++)\n{\n  int aux_size[3] = {0, 0, 0};\n  int aux_size2[3] = {0, 0, 0};\n  s->m3d_x = _i;\n  s->m3d_y = _k;\n  s->Bt = s->sBt;\n  vmul_T_3d_set_tmp(N, tmp, tmp_n, tmp2, tmp_n2);\n  if (toeplitz_mult_alg == 0)\n  {\n    for (int i = 1; i < _M; i++)\n    {\n      double v = 0.0;\n      for (int j = 1; j <= i; j++)\n        v += s->Bt[idx(_i, j, _k)] * s->Tm[1][(i - j) + 1];\n\n      if (space_der == 1)\n        for (int j = i + 1; j < _M; j++)\n        v -= s->Bt[idx(_i, j, _k)] * s->Tm[1][(j - i) + 1];\n\n\n      if (implicit_row_scaling == 1)\n        v /= s->RS[idx(_i, i, _k)];\n\n      r[idx(_i, i, _k)] += v * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n      ;\n    }\n\n  }\n\n  if (toeplitz_mult_alg == 1)\n  {\n    for (int i = 1; i < _M; i++)\n      tmp[1][i] = s->Bt[idx(_i, i, _k)];\n\n    Toeplitz_mult(s->Tm[1] + 1, tmp[1] + 1, tmp[0], _M - 1, 1);\n    for (int i = 1; i < _M; i++)\n    {\n      if (implicit_row_scaling == 1)\n        tmp[0][i - 1] /= s->RS[idx(_i, i, _k)];\n\n      r[idx(_i, i, _k)] += tmp[0][i - 1] * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n      ;\n    }\n\n  }\n\n  if (toeplitz_mult_alg == 2)\n  {\n    aux_size[1] = (aux_size2[1] = 0);\n    Tm_diags_mul_left(_M, s, tmp[1], tmp_n[1], aux_size[1], r, 1, 1, _i, _k);\n    if (space_der == 1)\n      Tm_diags_mul_right(_M, s, tmp2[1], tmp_n2[1], aux_size2[1], r, 1, _i, _k);\n\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2)\t\t\t\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/160"}
{"code": "for (i = 0; i < (nodes.size() - 1); ++i)\n{\n  double partial_sum = find_calculated_data(nodes.at(i), nodes.at(i + 1));\n  if (partial_sum != (-1))\n  {\n    sum += partial_sum;\n  }\n  else\n  {\n    partial_sum = get_distance(nodes.at(i), nodes.at(i + 1), mapa);\n    add_to_calculated_data(nodes.at(i), nodes.at(i + 1), partial_sum);\n    sum += partial_sum;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/20"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = 1;\n  b[i] = 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zsxoff/course-parallel-programming/task-3/src/omp/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = alpha * (l[i] - r[i]);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/5"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (5.0 * u[i][j][k][m])));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,k ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/130"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/128"}
{"code": "for (u = 0; u < graph->num_vertices; u++)\n{\n  uint32_t j;\n  uint32_t v;\n  uint32_t degree_out;\n  uint32_t edge_idx_out;\n  if (stats->components[u] == sampleComp)\n    continue;\n\n  degree_out = graph->vertices->out_degree[u];\n  edge_idx_out = graph->vertices->edges_idx[u];\n  for (j = edge_idx_out + stats->neighbor_rounds; j < (edge_idx_out + degree_out); j++)\n  {\n    v = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n    linkNodes(u, v, stats->components);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2048)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/3"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    B[i][j] = A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab6_OpenMP/macropipelinev2/3"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    for (int k = 0; k < n; k++)\n    {\n      product[calc_index(l, m, i, j)] += a[calc_index(l, m, i, k)] * b[calc_index(m, n, k, l)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/bench/bench_zzz/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  b[i] = 5;\n  printf(\"%d\\n\", b[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Vector/main/0"}
{"code": "for (long i = start; i <= bound; i++)\n{\n  if (isprime(i))\n  {\n    tab[indice] = i;\n    indice++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/macluczak/Primes-OpenMP/sito-domen/1"}
{"code": "formula = argv[1]\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PascalRomb/fftparallelanalysis/FFTPARALLEL/resources/FFTOpenMP/5"}
{"code": "for (i = 0; i < 2; i++)\n  cs.hash_data[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/tacacs_plus_fmt_plug/2"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    MC[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayoubmundia/ProduitMatricielle/omp/1"}
{"code": "for (int i = 1; i <= cities_cnt; ++i)\n{\n  dist += graph[route.cities[i % cities_cnt]][route.cities[i - 1]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/0"}
{"code": "for (i = 0; i < (num - 1); ++i)\n{\n  p_latent_minutia_1 = &latent_template.m_minutiae[(get < 1) > corr[i]];\n  p_rolled_minutia_1 = &rolled_template.m_minutiae[(get < 2) > corr[i]];\n  for (j = i + 1; j < num; ++j)\n  {\n    p_latent_minutia_2 = &latent_template.m_minutiae[(get < 1) > corr[j]];\n    p_rolled_minutia_2 = &rolled_template.m_minutiae[(get < 2) > corr[j]];\n    angle_1 = p_latent_minutia_1->ori - p_latent_minutia_2->ori;\n    angle_1 = adjust_angle(angle_1);\n    angle_2 = p_rolled_minutia_1->ori - p_rolled_minutia_2->ori;\n    angle_2 = adjust_angle(angle_2);\n    angle_diff = fabs(angle_1 - angle_2);\n    if (angle_diff > PI)\n      angle_diff = (2 * PI) - angle_diff;\n\n    if (angle_diff > (PI / 4.))\n      continue;\n\n    dx_1 = p_latent_minutia_1->x - p_latent_minutia_2->x;\n    dy_1 = p_latent_minutia_1->y - p_latent_minutia_2->y;\n    line_angle_1 = -atan2(dy_1, dx_1);\n    angle_1 = p_latent_minutia_1->ori - line_angle_1;\n    angle_1 = adjust_angle(angle_1);\n    dx_2 = p_rolled_minutia_1->x - p_rolled_minutia_2->x;\n    dy_2 = p_rolled_minutia_1->y - p_rolled_minutia_2->y;\n    line_angle_2 = -atan2(dy_2, dx_2);\n    angle_2 = p_rolled_minutia_1->ori - line_angle_2;\n    angle_2 = adjust_angle(angle_2);\n    angle_diff = fabs(angle_1 - angle_2);\n    if (angle_diff > PI)\n      angle_diff = (2 * PI) - angle_diff;\n\n    if (angle_diff > (PI / 6.))\n      continue;\n\n    angle_1 = p_latent_minutia_2->ori - line_angle_1;\n    angle_1 = adjust_angle(angle_1);\n    angle_2 = p_rolled_minutia_2->ori - line_angle_2;\n    angle_2 = adjust_angle(angle_2);\n    angle_diff = fabs(angle_1 - angle_2);\n    if (angle_diff > PI)\n      angle_diff = (2 * PI) - angle_diff;\n\n    if (angle_diff > (PI / 6.))\n      continue;\n\n    H[(i * num) + j] = true;\n    H[(j * num) + i] = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/26"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = 0; kk < depth; ++kk)\n  {\n    int base = jj * _chunk.x;\n    buffer[base + ((_chunk.x - HALO_PAD) + kk)] = buffer[base + (((_chunk.x - HALO_PAD) - 1) - kk)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/1"}
{"code": "for (i = m; i < n; i = i + 5)\n{\n  x[i] = sa * x[i];\n  x[i + 1] = sa * x[i + 1];\n  x[i + 2] = sa * x[i + 2];\n  x[i + 3] = sa * x[i + 3];\n  x[i + 4] = sa * x[i + 4];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/27"}
{"code": "for (int i = 0; i < NBFS; i++)\n{\n  sum_of_value += value[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/21"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  cb = cbc[iel][5];\n  cb1 = cbc[iel][3];\n  cb2 = cbc[iel][1];\n  sumcb = 0;\n  if ((cb == 2) || (cb == 3))\n  {\n    sumcb = sumcb + 1;\n  }\n  else\n    if (cb == 0)\n  {\n    sumcb = sumcb + 2;\n  }\n  else\n    if (cb == 1)\n  {\n    sumcb = sumcb + 5;\n  }\n\n\n\n  if ((cb1 == 2) || (cb1 == 3))\n  {\n    sumcb = sumcb + 1;\n  }\n  else\n    if (cb1 == 0)\n  {\n    sumcb = sumcb + 2;\n  }\n  else\n    if (cb1 == 1)\n  {\n    sumcb = sumcb + 5;\n  }\n\n\n\n  if ((cb2 == 2) || (cb2 == 3))\n  {\n    sumcb = sumcb + 1;\n  }\n  else\n    if (cb2 == 0)\n  {\n    sumcb = sumcb + 2;\n  }\n  else\n    if (cb2 == 1)\n  {\n    sumcb = sumcb + 5;\n  }\n\n\n\n  if (sumcb == 3)\n  {\n    newc[iel] = 1;\n    vassign[iel][0] = 7;\n  }\n  else\n    if (sumcb == 4)\n  {\n    newc[iel] = 2;\n    if (cb == 0)\n    {\n      vassign[iel][0] = 3;\n    }\n    else\n      if (cb1 == 0)\n    {\n      vassign[iel][0] = 5;\n    }\n    else\n      if (cb2 == 0)\n    {\n      vassign[iel][0] = 6;\n    }\n\n\n\n    vassign[iel][1] = 7;\n  }\n  else\n    if (sumcb == 7)\n  {\n    if (cb == 1)\n    {\n      ij1 = ijel[iel][5][0];\n      ij2 = ijel[iel][5][1];\n      if ((ij1 == 0) && (ij2 == 0))\n      {\n        newc[iel] = 2;\n        vassign[iel][0] = 3;\n        vassign[iel][1] = 7;\n      }\n      else\n        if ((ij1 == 0) && (ij2 == 1))\n      {\n        ntemp = sje[iel][5][0][0];\n        if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n        if ((ij1 == 1) && (ij2 == 0))\n      {\n        ntemp = sje[iel][5][0][0];\n        if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n      {\n        newc[iel] = 1;\n        vassign[iel][0] = 7;\n      }\n\n\n\n    }\n    else\n      if (cb1 == 1)\n    {\n      ij1 = ijel[iel][3][0];\n      ij2 = ijel[iel][3][1];\n      if ((ij1 == 0) && (ij2 == 0))\n      {\n        newc[iel] = 2;\n        vassign[iel][0] = 5;\n        vassign[iel][1] = 7;\n      }\n      else\n        if ((ij1 == 0) && (ij2 == 1))\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 5;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n        if ((ij1 == 1) && (ij2 == 0))\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 5;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n      {\n        newc[iel] = 1;\n        vassign[iel][0] = 7;\n      }\n\n\n\n    }\n    else\n      if (cb2 == 1)\n    {\n      ij1 = ijel[iel][1][0];\n      ij2 = ijel[iel][1][1];\n      if ((ij1 == 0) && (ij2 == 0))\n      {\n        newc[iel] = 2;\n        vassign[iel][0] = 6;\n        vassign[iel][1] = 7;\n      }\n      else\n        if ((ij1 == 0) && (ij2 == 1))\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 6;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n        if ((ij1 == 1) && (ij2 == 0))\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n        {\n          newc[iel] = 1;\n          vassign[iel][0] = 7;\n        }\n        else\n        {\n          newc[iel] = 2;\n          vassign[iel][0] = 6;\n          vassign[iel][1] = 7;\n        }\n\n      }\n      else\n      {\n        newc[iel] = 1;\n        vassign[iel][0] = 7;\n      }\n\n\n\n    }\n\n\n\n  }\n  else\n    if (sumcb == 5)\n  {\n    newc[iel] = 4;\n    if ((cb == 2) || (cb == 3))\n    {\n      vassign[iel][0] = 4;\n      vassign[iel][1] = 5;\n      vassign[iel][2] = 6;\n      vassign[iel][3] = 7;\n    }\n    else\n      if ((cb1 == 2) || (cb1 == 3))\n    {\n      vassign[iel][0] = 2;\n      vassign[iel][1] = 3;\n      vassign[iel][2] = 6;\n      vassign[iel][3] = 7;\n    }\n    else\n      if ((cb2 == 2) || (cb2 == 3))\n    {\n      vassign[iel][0] = 1;\n      vassign[iel][1] = 3;\n      vassign[iel][2] = 5;\n      vassign[iel][3] = 7;\n    }\n\n\n\n  }\n  else\n    if (sumcb == 8)\n  {\n    if (cb == 1)\n    {\n      if ((cb1 == 2) || (cb1 == 3))\n      {\n        ij1 = ijel[iel][5][0];\n        if (ij1 == 0)\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 2;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          ntemp = sje[iel][5][0][0];\n          if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 6;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n      else\n        if ((cb2 == 2) || (cb2 == 3))\n      {\n        if (ijel[iel][5][1] == 0)\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          ntemp = sje[iel][5][0][0];\n          if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 5;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n\n    }\n    else\n      if (cb1 == 1)\n    {\n      if ((cb == 2) || (cb == 3))\n      {\n        ij1 = ijel[iel][3][0];\n        ij2 = ijel[iel][3][1];\n        if ((ij1 == 0) && (ij2 == 0))\n        {\n          ntemp = sje[iel][3][0][0];\n          if ((cbc[ntemp][1] == 3) && (sje[ntemp][1][0][0] < iel))\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n          else\n          {\n            newc[iel] = 4;\n            vassign[iel][0] = 4;\n            vassign[iel][1] = 5;\n            vassign[iel][2] = 6;\n            vassign[iel][3] = 7;\n          }\n\n        }\n        else\n          if ((ij1 == 0) && (ij2 == 1))\n        {\n          ntemp = sje[iel][3][0][0];\n          if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 4;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n          else\n          {\n            newc[iel] = 4;\n            vassign[iel][0] = 4;\n            vassign[iel][1] = 5;\n            vassign[iel][2] = 6;\n            vassign[iel][3] = 7;\n          }\n\n        }\n        else\n          if ((ij1 == 1) && (ij2 == 0))\n        {\n          ntemp = sje[iel][3][0][0];\n          if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 6;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n        else\n          if ((ij1 == 1) && (ij2 == 1))\n        {\n          ntemp = sje[iel][3][0][0];\n          if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 6;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 4;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n\n\n\n      }\n      else\n      {\n        if (ijel[iel][3][1] == 0)\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          ntemp = sje[iel][3][0][0];\n          if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 5;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (cb2 == 1)\n    {\n      if ((cb == 2) || (cb == 3))\n      {\n        if (ijel[iel][1][0] == 0)\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 4;\n          vassign[iel][1] = 5;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          ntemp = sje[iel][1][0][0];\n          if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n      else\n      {\n        if (ijel[iel][1][1] == 0)\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 2;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          ntemp = sje[iel][1][0][0];\n          if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n    }\n\n\n\n  }\n  else\n    if (sumcb == 11)\n  {\n    if ((cb == 2) || (cb == 3))\n    {\n      if (ijel[iel][3][0] == 0)\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][1] == 3) && (sje[ntemp][1][0][0] < iel))\n        {\n          newc[iel] = 3;\n          vassign[iel][0] = 5;\n          vassign[iel][1] = 6;\n          vassign[iel][2] = 7;\n        }\n        else\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 4;\n          vassign[iel][1] = 5;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n\n      }\n      else\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] < iel))\n        {\n          ntemp1 = sje[iel][3][0][0];\n          if ((cbc[ntemp1][4] == 3) && (sje[ntemp1][4][0][0] < iel))\n          {\n            newc[iel] = 1;\n            vassign[iel][0] = 7;\n          }\n          else\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 7;\n          }\n\n        }\n        else\n        {\n          ntemp1 = sje[iel][3][0][0];\n          if ((cbc[ntemp1][4] == 3) && (sje[ntemp1][4][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 6;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if ((cb1 == 2) || (cb1 == 3))\n    {\n      if (ijel[iel][1][1] == 0)\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] < iel))\n        {\n          newc[iel] = 3;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 6;\n          vassign[iel][2] = 7;\n        }\n        else\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 2;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n\n      }\n      else\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] < iel))\n        {\n          ntemp1 = sje[iel][5][0][0];\n          if ((cbc[ntemp1][2] == 3) && (sje[ntemp1][2][0][0] < iel))\n          {\n            newc[iel] = 1;\n            vassign[iel][0] = 7;\n          }\n          else\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 7;\n          }\n\n        }\n        else\n        {\n          ntemp1 = sje[iel][5][0][0];\n          if ((cbc[ntemp1][2] == 3) && (sje[ntemp1][2][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 6;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 6;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if ((cb2 == 2) || (cb2 == 3))\n    {\n      if (ijel[iel][5][1] == 0)\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] < iel))\n        {\n          newc[iel] = 3;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 5;\n          vassign[iel][2] = 7;\n        }\n        else\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 7;\n        }\n\n      }\n      else\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] < iel))\n        {\n          ntemp1 = sje[iel][5][0][0];\n          if ((cbc[ntemp1][0] == 3) && (sje[ntemp1][0][0][0] < iel))\n          {\n            newc[iel] = 1;\n            vassign[iel][0] = 7;\n          }\n          else\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 7;\n          }\n\n        }\n        else\n        {\n          ntemp1 = sje[iel][5][0][0];\n          if ((cbc[ntemp1][0] == 3) && (sje[ntemp1][0][0][0] < iel))\n          {\n            newc[iel] = 2;\n            vassign[iel][0] = 5;\n            vassign[iel][1] = 7;\n          }\n          else\n          {\n            newc[iel] = 3;\n            vassign[iel][0] = 3;\n            vassign[iel][1] = 5;\n            vassign[iel][2] = 7;\n          }\n\n        }\n\n      }\n\n    }\n\n\n\n  }\n  else\n    if (sumcb == 6)\n  {\n    newc[iel] = 8;\n    vassign[iel][0] = 0;\n    vassign[iel][1] = 1;\n    vassign[iel][2] = 2;\n    vassign[iel][3] = 3;\n    vassign[iel][4] = 4;\n    vassign[iel][5] = 5;\n    vassign[iel][6] = 6;\n    vassign[iel][7] = 7;\n  }\n  else\n    if (sumcb == 9)\n  {\n    newc[iel] = 7;\n    vassign[iel][0] = 1;\n    vassign[iel][1] = 2;\n    vassign[iel][2] = 3;\n    vassign[iel][3] = 4;\n    vassign[iel][4] = 5;\n    vassign[iel][5] = 6;\n    vassign[iel][6] = 7;\n  }\n  else\n    if (sumcb == 12)\n  {\n    if (cb == 0)\n    {\n      ntemp = sje[iel][1][0][0];\n      if ((cbc[ntemp][3] == 3) && (sje[ntemp][3][0][0] < iel))\n      {\n        newc[iel] = 6;\n        vassign[iel][0] = 1;\n        vassign[iel][1] = 2;\n        vassign[iel][2] = 3;\n        vassign[iel][3] = 5;\n        vassign[iel][4] = 6;\n        vassign[iel][5] = 7;\n      }\n      else\n      {\n        newc[iel] = 7;\n        vassign[iel][0] = 1;\n        vassign[iel][1] = 2;\n        vassign[iel][2] = 3;\n        vassign[iel][3] = 4;\n        vassign[iel][4] = 5;\n        vassign[iel][5] = 6;\n        vassign[iel][6] = 7;\n      }\n\n    }\n    else\n      if (cb1 == 0)\n    {\n      newc[iel] = 7;\n      vassign[iel][0] = 1;\n      vassign[iel][1] = 2;\n      vassign[iel][2] = 3;\n      vassign[iel][3] = 4;\n      vassign[iel][4] = 5;\n      vassign[iel][5] = 6;\n      vassign[iel][6] = 7;\n    }\n    else\n      if (cb2 == 0)\n    {\n      ntemp = sje[iel][3][0][0];\n      if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] < iel))\n      {\n        newc[iel] = 6;\n        vassign[iel][0] = 2;\n        vassign[iel][1] = 3;\n        vassign[iel][2] = 4;\n        vassign[iel][3] = 5;\n        vassign[iel][4] = 6;\n        vassign[iel][5] = 7;\n      }\n      else\n      {\n        newc[iel] = 7;\n        vassign[iel][0] = 1;\n        vassign[iel][1] = 2;\n        vassign[iel][2] = 3;\n        vassign[iel][3] = 4;\n        vassign[iel][4] = 5;\n        vassign[iel][5] = 6;\n        vassign[iel][6] = 7;\n      }\n\n    }\n\n\n\n  }\n  else\n    if (sumcb == 15)\n  {\n    ntemp = sje[iel][3][0][0];\n    ntemp1 = sje[iel][1][0][0];\n    if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] < iel))\n    {\n      if ((cbc[ntemp][1] == 3) && (sje[ntemp][1][0][0] < iel))\n      {\n        if ((cbc[ntemp1][5] == 3) && (sje[ntemp1][5][0][0] < iel))\n        {\n          newc[iel] = 4;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 5;\n          vassign[iel][2] = 6;\n          vassign[iel][3] = 7;\n        }\n        else\n        {\n          newc[iel] = 5;\n          vassign[iel][0] = 2;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 6;\n          vassign[iel][4] = 7;\n        }\n\n      }\n      else\n      {\n        if ((cbc[ntemp1][5] == 3) && (sje[ntemp1][5][0][0] < iel))\n        {\n          newc[iel] = 5;\n          vassign[iel][0] = 3;\n          vassign[iel][1] = 4;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 6;\n          vassign[iel][4] = 7;\n        }\n        else\n        {\n          newc[iel] = 6;\n          vassign[iel][0] = 2;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 4;\n          vassign[iel][3] = 5;\n          vassign[iel][4] = 6;\n          vassign[iel][5] = 7;\n        }\n\n      }\n\n    }\n    else\n    {\n      if ((cbc[ntemp][1] == 3) && (sje[ntemp][1][0][0] < iel))\n      {\n        if ((cbc[ntemp1][5] == 3) && (sje[ntemp1][5][0][0] < iel))\n        {\n          newc[iel] = 5;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 5;\n          vassign[iel][3] = 6;\n          vassign[iel][4] = 7;\n        }\n        else\n        {\n          newc[iel] = 6;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 2;\n          vassign[iel][2] = 3;\n          vassign[iel][3] = 5;\n          vassign[iel][4] = 6;\n          vassign[iel][5] = 7;\n        }\n\n      }\n      else\n      {\n        if ((cbc[ntemp1][5] == 3) && (sje[ntemp1][5][0][0] < iel))\n        {\n          newc[iel] = 6;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 3;\n          vassign[iel][2] = 4;\n          vassign[iel][3] = 5;\n          vassign[iel][4] = 6;\n          vassign[iel][5] = 7;\n        }\n        else\n        {\n          newc[iel] = 7;\n          vassign[iel][0] = 1;\n          vassign[iel][1] = 2;\n          vassign[iel][2] = 3;\n          vassign[iel][3] = 4;\n          vassign[iel][4] = 5;\n          vassign[iel][5] = 6;\n          vassign[iel][6] = 7;\n        }\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n\n\n\n\n\n}\n\n", "pragma": "omp parallel for default(shared) private(iel,sumcb,ij1,ij2, cb,cb1,cb2,ntemp,ntemp1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double local_result = 0;\n  for (int j = sp.pointerB[i]; j < sp.pointerB[i + 1]; j++)\n  {\n    local_result += sp.values[j] * vect[sp.columns[j]];\n  }\n\n  result[i] = local_result;\n}\n\n", "pragma": "    #pragma omp parallel for if (ENABLE_PARALLEL)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/suicide-squad/heat-equation/modules/Sergey/MPI/src/SparseMatrix/0"}
{"code": "for (ic = 0; ic < cur_salt->iterations; ic++)\n{\n  SHA256_Init(&ctx);\n  pkd.iteration_count = JOHNSWAP64(ic);\n  SHA256_Update(&ctx, &pkd, sizeof(struct libbde_password_key_data));\n  SHA256_Final(pkd.last_sha256_hash, &ctx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/bitlocker_fmt_plug/1"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  for (k = 0; k < N; k++)\n    C[i][j] += A[i][k] * B[k][j];\n\n  if (C[i][j] != control[i][j])\n    flag++;\n\n}\n\n\n", "pragma": "omp for schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw4/matrix/0"}
{"code": "for (int i = 0; i < localN; i++)\n{\n  fgets(buf, 19, stdin);\n  for (int j = 0; j < localN; j++)\n  {\n    int index = (localN * i) + j;\n    if (buf[j] == '*')\n    {\n      obstacle[caseNum][index >> 6] |= 1ULL << (index & 63);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10202/fast_n_queens/2"}
{"code": "for (i = 0; i < controlLength; i++)\n{\n  if (patternLength[controlData[2][i]] > textLength[controlData[1][i]])\n  {\n    writeToResultString(controlData[1][i], controlData[2][i], -1);\n  }\n  else\n  {\n    if (textLength[controlData[1][i]] == patternLength[controlData[2][i]])\n      worstcaseComparisons = (long long) textLength[controlData[1][i]];\n    else\n      if (textLength[controlData[1][i]] < patternLength[controlData[2][i]])\n      worstcaseComparisons = 0ULL;\n    else\n      worstcaseComparisons = ((long long) patternLength[controlData[2][i]]) * (((long long) textLength[controlData[1][i]]) - ((long long) patternLength[controlData[2][i]]));\n\n\n    if (worstcaseComparisons > 100000000ULL)\n    {\n      NUMTHREADS = 20;\n    }\n    else\n      if (worstcaseComparisons <= 1000ULL)\n    {\n      NUMTHREADS = 1;\n    }\n    else\n      if (worstcaseComparisons <= 10000ULL)\n    {\n      NUMTHREADS = 3;\n    }\n    else\n      if (worstcaseComparisons <= 100000000ULL)\n    {\n      NUMTHREADS = 18;\n    }\n    else\n    {\n      NUMTHREADS = 20;\n    }\n\n\n\n\n    processData(controlData[0][i], controlData[1][i], controlData[2][i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/paullewisjohnston/hpc-pattern-searching/project_OMP/3"}
{"code": "for (i = 0; i < (N / comm_size); i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    Board(i, j) = (((float) rand()) / ((float) 32767)) < threshold;\n    counter += Board(i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikaltipar/Game-of-Life/src/init/1"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, B[i][j]);\n  if ((((i * NJ) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/convolution-2d/convolution-2d/2"}
{"code": "for (j = 0; j <= (2048 + 1); j++)\n{\n  T[0][j] = 0.0;\n  T[2048 + 1][j] = (128.0 / 2048) * j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/4"}
{"code": "for (int i = 0; i < (source->size / 2); i++)\n{\n  reversesource->tab[i] = source->tab[((source->size / 2) - i) - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/5"}
{"code": "for (unsigned int i = 0; i < corrs.size(); ++i)\n{\n  for (int j = 0; j < corrs[i]->get_Np(); ++j)\n  {\n    gsl_vector_set(p, p_idx, fc.p0[i][j]);\n    gsl_vector_set(ss, p_idx, 0.1 * fc.p0[i][j]);\n    ++p_idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/10"}
{"code": "for (int k = 0; k < n; k++)\n{\n  if (k == 0)\n  {\n    for (int i = 0; i < thread_count; i++)\n    {\n      pthread_create(&threadID[i], NULL, dealwithbycol_AVX, (void *) (&id[i]));\n    }\n\n  }\n\n  for (int i = 0; i < thread_count; i++)\n  {\n    sem_wait(&sem_parent);\n  }\n\n  pthread_barrier_wait(&childbarrier_col);\n  A[k][k] = 1;\n  for (int i = k + 1; i < n; i++)\n    A[i][k] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/15"}
{"code": "for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n  for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/2"}
{"code": "for (j = 1; j < (((2048 / NODESY) + 2) - 1); j++)\n{\n  i = 0;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = grn[j];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = grn[j];\n\n  i = ((2048 / 1) + 2) - 1;\n  ii = ((((i + j) % 2) * ((2048 / 1) + 2)) + i) / 2;\n  if (ii < (((2048 / 1) + 2) / 2))\n    whites[ii][j].data = grs[j];\n  else\n    blacks[ii - (((2048 / 1) + 2) / 2)][j].data = grs[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/80"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpn_gp7_8n.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbrukman/llvm-openmp/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (int i = 0; i < updates; i++)\n{\n  random = (random << 1) ^ ((((ssize_t) random) < 0) ? (7) : (0));\n  addr = random >> (64 - gups_n);\n  mem[addr] = mem[addr] ^ random;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/plavin/gups/main/1"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  if (((((c[j] / cj) - 1.0) >= 0) ? ((c[j] / cj) - 1.0) : (-((c[j] / cj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/25"}
{"code": "for (int i = 0; i < 54; i++)\n{\n  imgHeader[i] = getc(fIn);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saurabhkakade21/Parallel-Programming-2020/CS599_project_sk2354/0"}
{"code": "for (k = 0; k < numOfPoints; k++)\n{\n  int l;\n  min[k] = distances[k][0];\n  assign[k] = 0;\n  for (l = 0; l < threads_num; l++)\n  {\n    if (distances[k][l] < min[k])\n    {\n      assigncentroid = l;\n      assign[k] = l;\n      min[k] = distances[k][l];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oshaesam1/K-means-Clustering-using-openMp-FCAI-/main/4"}
{"code": "for (int i = 0; i < bin_count; i++)\n{\n  int bin = 0;\n  for (int j = 0; j < num_count; j++)\n  {\n    int bin_index = (int) ((nums[j] * bin_count) / 100.0);\n    if (bin_index == i)\n    {\n      bin++;\n    }\n\n  }\n\n  bin_counter[i] = bin;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) shared(bin_counter)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dizys/nyu-multicore-lab-1/zz2960ver1/0"}
{"code": "for (i = 0; i < NumPart; i++)\n{\n  for (k = 0, r2 = 0; k < 3; k++)\n    r2 += P[i].Pos[k] * P[i].Pos[k];\n\n  P[i].Potential += fac * r2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/potential/5"}
{"code": "for (k = 0; k < dims[2]; k++)\n{\n  x0 = starts[k];\n  for (j = 0; j < dims[1]; j++)\n  {\n    vranlc(2 * NX, &x0, A, (double *) (&u0[k][j][0]));\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(k,j,x0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/2"}
{"code": "for (i = 0; i < (3 * np); i++)\n{\n  j_vel[i] *= vfactor;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/load_jing/1"}
{"code": "for (i = 0; i < (dataset->getN() - 1); i++)\n{\n  det *= swapMax(i, dataset, indices);\n  det *= dataset->getU(indices[i], i);\n  columnElimination(dataset, i, indices);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/URAmiRBin/cuda-determinant/Source Codes/PARALLEL 1/OPENMP Project/Source/3"}
{"code": "for (i = 0; i < maxgrid; i++)\n  for (j = 0; j < maxgrid; j++)\n{\n  sum_tang[i][j] = (DATA_TYPE) ((i + 1) * (j + 1));\n  mean[i][j] = (((DATA_TYPE) i) - j) / maxgrid;\n  path[i][j] = (((DATA_TYPE) i) * (j - 1)) / maxgrid;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/medley/reg_detect/reg_detect/4"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  int tid = omp_get_thread_num();\n  if (data_old[i] != (-1))\n  {\n    for (int j = 0; j < cnt; j++)\n    {\n      if (data_old[i] == rep[j])\n      {\n        res[tid][j]++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/6"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n{\n  double num = 0;\n  double dem = 0;\n  for (int j = 0; j < k; ++j)\n  {\n    if (iter->second.find(rMovieIDMap[maxKIndex[i][j]]) != iter->second.end())\n    {\n      num += maxKWeight[i][j] * (iter->second[rMovieIDMap[maxKIndex[i][j]]] - aveItem[i]);\n      dem += abs(maxKWeight[i][j]);\n    }\n\n  }\n\n  preference[iter->first][i] = aveItem[i] + (num / dem);\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-rating-based/2"}
{"code": "for (i = 1; i < observRows; i++)\n{\n  if (observation[i] == 0)\n  {\n    zeroVector[counter] = i;\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/4"}
{"code": "for (i = 0; i < 700; i++)\n{\n  for (j = 0; j < 700; j++)\n  {\n    u[i][j] = w[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/hated_plate_local/7"}
{"code": "for (i = 0; i < NoofCols; i = i + 1)\n{\n  for (j = 0; j < NoofRows; j = j + 1)\n    printf(\"%d \\t\", Trans[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PavlyukVadim/software-engineering/Parallel/OpenMP/main/2"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/28"}
{"code": "for (i = 0; i < size; i++)\n  if (scanf(\"%d\", &b[i]) != 1)\n{\n  printf(\"Fail to scan vector b\\n\");\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcksber/CMU_15-418_hw3/examples/loop/2"}
{"code": "for (int j = 0; j < LEN; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sergioge99/vectorization_and_parallelism/practicas_paralelizacion/p6_iaca_valgrind_aps/triad/7"}
{"code": "for (int j = 0; j < size; ++j)\n{\n  ans[j] = a[j] * b;\n}\n\n", "pragma": "    #pragma omp parallel for private(ans, a, b) shared(size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vibhatha/OpenMP/code/exp1/OpenMPExamples/17"}
{"code": "for (int i = 0; i < N; i++)\n{\n  s += hit();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/test/omp/1"}
{"code": "for (j = 0; j < N; j++)\n  M[j] = 0.5 + (((double) rand()) / 32767);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoecheverria/openmp-lab/masterOMP/4"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 27) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    int failed = 0;\n    switch (CLASS)\n    {\n      case 'S':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'W':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 2)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'D':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n    }\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/47"}
{"code": "for (int64_t i = 0; i < size; ++i)\n{\n  sum += dx * table[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kovdan01/parallel-computing/src/openmp/src/main/0"}
{"code": "for (int i = 0; i < MAXN; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_orphan/1"}
{"code": "for (layer4_index = 0; layer4_index < Layer_CH_Num; layer4_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv4_data[(((layer4_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv5[(((((layer5_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer4_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data5[(((layer4_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/28"}
{"code": "for (s = 0; s < n; s++)\n{\n  seed[0] = (unsigned int) (s + time(0));\n  seed[1] = (unsigned int) ((s + time(0)) + 1);\n  seed[2] = (unsigned int) ((s + time(0)) + 2);\n  seed[3] = (unsigned int) ((s + time(0)) + 3);\n  for (l = 0; l < mcs; l++)\n  {\n    for (i = 0; i < L; i++)\n    {\n      for (j = 0; j < L; j++)\n      {\n        P = exp((((-2.0) * spin[i][j]) * (((spin[f(i + 1, L)][j] + spin[f(i - 1, L)][j]) + spin[i][f(j + 1, L)]) + spin[i][f(j - 1, L)])) / T);\n        randomNum = ur(seed);\n        if (randomNum <= P)\n        {\n          if (spin[i][j] == (-1))\n          {\n            sum_s += 2;\n          }\n          else\n          {\n            sum_s -= 2;\n          }\n\n          spin[i][j] = (-1) * spin[i][j];\n        }\n\n      }\n\n    }\n\n    if (l >= 1000)\n    {\n      m += ((double) abs(sum_s)) / ((L * L) * (mcs - 1000));\n    }\n\n  }\n\n  mean_m[s] = m;\n}\n\n", "pragma": "omp parallel for private(l,i,j,P,randomNum,seed) firstprivate(sum_s,spin,m) num_threads(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtchaos/C-Python_class_exercise/numerical_calculation/2D_Ising_model/parallel_metropolice_montecarlo/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    binvcrhs(lhs[0][j][k][1], lhs[0][j][k][2], rhs[0][j][k]);\n  }\n\n}\n\n", "pragma": "omp for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/7"}
{"code": "for (i = 0; i < 600; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/sum_array_barrier_openmp/0"}
{"code": "for (i = 0; i < no_in_proc; i++)\n  put_0_in_jth_pos(rowj, j, &matrix[i * (matrixsize + 1)], row_nos[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/10"}
{"code": "for (i = 1; i < (nx - 1); i++)\n  for (j = 1; j < (ny - 1); j++)\n{\n  const int c = i + (nx * j);\n  G[c] = (pixel_t) hypot(after_Gx[c], after_Gy[c]);\n}\n\n\n", "pragma": "omp parallel for shared(i, G) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\" thread %d suma a[%d]=%d suma=%d \\n\", 0, i, a[i], suma);\n  dyn = omp_get_dynamic();\n  max = omp_get_max_threads();\n  limit = omp_get_thread_limit();\n  omp_get_schedule(&kind, &modifier);\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma,dyn,max,limit)schedule(dynamic,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica3/src/scheduled-clauseModificado/1"}
{"code": "for (c = 0; c < len; c++)\n{\n  if (((data[c] == 0x0a) || (data[c] == 0x0d)) || ((data[c] >= 32) && (data[c] < 127)))\n    nascii++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/openssl_enc_fmt_plug/3"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < p; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code7777/MatrixMultiplierParallelProcessing/hw1/3"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/23"}
{"code": "for (irow = 0; irow < scatter_sz; irow++)\n  MyFinalVector[irow] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/hybrid_matrix_multiply/4"}
{"code": "for (i = 0; i < matrix.count; i++)\n{\n  matrix.elements[i].value.f *= scalar;\n}\n\n", "pragma": "omp parallel for shared(matrix,scalar) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/1"}
{"code": "for (c = 0; c < buffer; c++)\n{\n  if (x == img.largura)\n  {\n    y++;\n    x = 0;\n  }\n\n  matriz[x][y] = img.data[c];\n  x++;\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francisneibl/processamento_paralelo_imagens/fitroMedia/0"}
{"code": "for (int row = 0; row < 16; row++)\n  for (int col = 0; col < 16; col++)\n{\n  for (int e = 0; e < 16; ++e)\n    Cs[row][col] += As[row][e] * Bs[e][col];\n\n}\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/gridify-3/1"}
{"code": "for (i = _scoplibIterators.begin(); i != _scoplibIterators.end(); ++i)\n  if (ptr == (*i))\n  return true;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/PolyOpt/polyopt/ClastToSage/0"}
{"code": "for (l = 1; l < nzh; l++)\n{\n  dkz = dnz * ((float) l);\n  ll = nxyhd * l;\n  lj = nxvyh * l;\n  l1 = (nxvyh * nz) - lj;\n  wp = 0.0;\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    for (j = 1; j < nxh; j++)\n    {\n      at1 = ci2 * crealf(ffc[(j + kk) + ll]);\n      at2 = (at1 * dnx) * ((float) j);\n      at3 = dky * at1;\n      at4 = dkz * at1;\n      at1 = at1 * cimagf(ffc[(j + kk) + ll]);\n      zt1 = (-cimagf(cu[2 + (3 * ((j + kj) + lj))])) + (crealf(cu[2 + (3 * ((j + kj) + lj))]) * _Complex_I);\n      zt2 = (-cimagf(cu[1 + (3 * ((j + kj) + lj))])) + (crealf(cu[1 + (3 * ((j + kj) + lj))]) * _Complex_I);\n      zt3 = (-cimagf(cu[3 * ((j + kj) + lj)])) + (crealf(cu[3 * ((j + kj) + lj)]) * _Complex_I);\n      bxyz[3 * ((j + kj) + lj)] = (at3 * zt1) - (at4 * zt2);\n      bxyz[1 + (3 * ((j + kj) + lj))] = (at4 * zt3) - (at2 * zt1);\n      bxyz[2 + (3 * ((j + kj) + lj))] = (at2 * zt2) - (at3 * zt3);\n      zt1 = (-cimagf(cu[2 + (3 * ((j + k1) + lj))])) + (crealf(cu[2 + (3 * ((j + k1) + lj))]) * _Complex_I);\n      zt2 = (-cimagf(cu[1 + (3 * ((j + k1) + lj))])) + (crealf(cu[1 + (3 * ((j + k1) + lj))]) * _Complex_I);\n      zt3 = (-cimagf(cu[3 * ((j + k1) + lj)])) + (crealf(cu[3 * ((j + k1) + lj)]) * _Complex_I);\n      bxyz[3 * ((j + k1) + lj)] = ((-at3) * zt1) - (at4 * zt2);\n      bxyz[1 + (3 * ((j + k1) + lj))] = (at4 * zt3) - (at2 * zt1);\n      bxyz[2 + (3 * ((j + k1) + lj))] = (at2 * zt2) + (at3 * zt3);\n      zt1 = (-cimagf(cu[2 + (3 * ((j + kj) + l1))])) + (crealf(cu[2 + (3 * ((j + kj) + l1))]) * _Complex_I);\n      zt2 = (-cimagf(cu[1 + (3 * ((j + kj) + l1))])) + (crealf(cu[1 + (3 * ((j + kj) + l1))]) * _Complex_I);\n      zt3 = (-cimagf(cu[3 * ((j + kj) + l1)])) + (crealf(cu[3 * ((j + kj) + l1)]) * _Complex_I);\n      bxyz[3 * ((j + kj) + l1)] = (at3 * zt1) + (at4 * zt2);\n      bxyz[1 + (3 * ((j + kj) + l1))] = ((-at4) * zt3) - (at2 * zt1);\n      bxyz[2 + (3 * ((j + kj) + l1))] = (at2 * zt2) - (at3 * zt3);\n      zt1 = (-cimagf(cu[2 + (3 * ((j + k1) + l1))])) + (crealf(cu[2 + (3 * ((j + k1) + l1))]) * _Complex_I);\n      zt2 = (-cimagf(cu[1 + (3 * ((j + k1) + l1))])) + (crealf(cu[1 + (3 * ((j + k1) + l1))]) * _Complex_I);\n      zt3 = (-cimagf(cu[3 * ((j + k1) + l1)])) + (crealf(cu[3 * ((j + k1) + l1)]) * _Complex_I);\n      bxyz[3 * ((j + k1) + l1)] = ((-at3) * zt1) + (at4 * zt2);\n      bxyz[1 + (3 * ((j + k1) + l1))] = ((-at4) * zt3) - (at2 * zt1);\n      bxyz[2 + (3 * ((j + k1) + l1))] = (at2 * zt2) + (at3 * zt3);\n      wp += at1 * ((((((((((((cu[3 * ((j + kj) + lj)] * conjf(cu[3 * ((j + kj) + lj)])) + (cu[1 + (3 * ((j + kj) + lj))] * conjf(cu[1 + (3 * ((j + kj) + lj))]))) + (cu[2 + (3 * ((j + kj) + lj))] * conjf(cu[2 + (3 * ((j + kj) + lj))]))) + (cu[3 * ((j + k1) + lj)] * conjf(cu[3 * ((j + k1) + lj)]))) + (cu[1 + (3 * ((j + k1) + lj))] * conjf(cu[1 + (3 * ((j + k1) + lj))]))) + (cu[2 + (3 * ((j + k1) + lj))] * conjf(cu[2 + (3 * ((j + k1) + lj))]))) + (cu[3 * ((j + kj) + l1)] * conjf(cu[3 * ((j + kj) + l1)]))) + (cu[1 + (3 * ((j + kj) + l1))] * conjf(cu[1 + (3 * ((j + kj) + l1))]))) + (cu[2 + (3 * ((j + kj) + l1))] * conjf(cu[2 + (3 * ((j + kj) + l1))]))) + (cu[3 * ((j + k1) + l1)] * conjf(cu[3 * ((j + k1) + l1)]))) + (cu[1 + (3 * ((j + k1) + l1))] * conjf(cu[1 + (3 * ((j + k1) + l1))]))) + (cu[2 + (3 * ((j + k1) + l1))] * conjf(cu[2 + (3 * ((j + k1) + l1))])));\n    }\n\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    at1 = ci2 * crealf(ffc[kk + ll]);\n    at3 = (at1 * dny) * ((float) k);\n    at4 = dkz * at1;\n    at1 = at1 * cimagf(ffc[kk + ll]);\n    zt1 = (-cimagf(cu[2 + (3 * (kj + lj))])) + (crealf(cu[2 + (3 * (kj + lj))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (kj + lj))])) + (crealf(cu[1 + (3 * (kj + lj))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (kj + lj)])) + (crealf(cu[3 * (kj + lj)]) * _Complex_I);\n    bxyz[3 * (kj + lj)] = (at3 * zt1) - (at4 * zt2);\n    bxyz[1 + (3 * (kj + lj))] = at4 * zt3;\n    bxyz[2 + (3 * (kj + lj))] = (-at3) * zt3;\n    bxyz[3 * (k1 + lj)] = zero;\n    bxyz[1 + (3 * (k1 + lj))] = zero;\n    bxyz[2 + (3 * (k1 + lj))] = zero;\n    zt1 = (-cimagf(cu[2 + (3 * (kj + l1))])) + (crealf(cu[2 + (3 * (kj + l1))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (kj + l1))])) + (crealf(cu[1 + (3 * (kj + l1))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (kj + l1)])) + (crealf(cu[3 * (kj + l1)]) * _Complex_I);\n    bxyz[3 * (kj + l1)] = (at3 * zt1) + (at4 * zt2);\n    bxyz[1 + (3 * (kj + l1))] = (-at4) * zt3;\n    bxyz[2 + (3 * (kj + l1))] = (-at3) * zt3;\n    bxyz[3 * (k1 + l1)] = zero;\n    bxyz[1 + (3 * (k1 + l1))] = zero;\n    bxyz[2 + (3 * (k1 + l1))] = zero;\n    wp += at1 * ((((((cu[3 * (kj + lj)] * conjf(cu[3 * (kj + lj)])) + (cu[1 + (3 * (kj + lj))] * conjf(cu[1 + (3 * (kj + lj))]))) + (cu[2 + (3 * (kj + lj))] * conjf(cu[2 + (3 * (kj + lj))]))) + (cu[3 * (kj + l1)] * conjf(cu[3 * (kj + l1)]))) + (cu[1 + (3 * (kj + l1))] * conjf(cu[1 + (3 * (kj + l1))]))) + (cu[2 + (3 * (kj + l1))] * conjf(cu[2 + (3 * (kj + l1))])));\n  }\n\n  k1 = nxvh * nyh;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = ci2 * crealf(ffc[j + ll]);\n    at2 = (at1 * dnx) * ((float) j);\n    at4 = dkz * at1;\n    at1 = at1 * cimagf(ffc[j + ll]);\n    zt1 = (-cimagf(cu[2 + (3 * (j + lj))])) + (crealf(cu[2 + (3 * (j + lj))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (j + lj))])) + (crealf(cu[1 + (3 * (j + lj))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (j + lj)])) + (crealf(cu[3 * (j + lj)]) * _Complex_I);\n    bxyz[3 * (j + lj)] = (-at4) * zt2;\n    bxyz[1 + (3 * (j + lj))] = (at4 * zt3) - (at2 * zt1);\n    bxyz[2 + (3 * (j + lj))] = at2 * zt2;\n    bxyz[3 * ((j + k1) + lj)] = zero;\n    bxyz[1 + (3 * ((j + k1) + lj))] = zero;\n    bxyz[2 + (3 * ((j + k1) + lj))] = zero;\n    zt1 = (-cimagf(cu[2 + (3 * (j + l1))])) + (crealf(cu[2 + (3 * (j + l1))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (j + l1))])) + (crealf(cu[1 + (3 * (j + l1))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (j + l1)])) + (crealf(cu[3 * (j + l1)]) * _Complex_I);\n    bxyz[3 * (j + l1)] = at4 * zt2;\n    bxyz[1 + (3 * (j + l1))] = ((-at4) * zt3) - (at2 * zt1);\n    bxyz[2 + (3 * (j + l1))] = at2 * zt2;\n    bxyz[3 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    wp += at1 * ((((((cu[3 * (j + lj)] * conjf(cu[3 * (j + lj)])) + (cu[1 + (3 * (j + lj))] * conjf(cu[1 + (3 * (j + lj))]))) + (cu[2 + (3 * (j + lj))] * conjf(cu[2 + (3 * (j + lj))]))) + (cu[3 * (j + l1)] * conjf(cu[3 * (j + l1)]))) + (cu[1 + (3 * (j + l1))] * conjf(cu[1 + (3 * (j + l1))]))) + (cu[2 + (3 * (j + l1))] * conjf(cu[2 + (3 * (j + l1))])));\n  }\n\n  at1 = ci2 * crealf(ffc[ll]);\n  at4 = dkz * at1;\n  at1 = at1 * cimagf(ffc[ll]);\n  zt2 = (-cimagf(cu[1 + (3 * lj)])) + (crealf(cu[1 + (3 * lj)]) * _Complex_I);\n  zt3 = (-cimagf(cu[3 * lj])) + (crealf(cu[3 * lj]) * _Complex_I);\n  bxyz[3 * lj] = (-at4) * zt2;\n  bxyz[1 + (3 * lj)] = at4 * zt3;\n  bxyz[2 + (3 * lj)] = zero;\n  bxyz[3 * (k1 + lj)] = zero;\n  bxyz[1 + (3 * (k1 + lj))] = zero;\n  bxyz[2 + (3 * (k1 + lj))] = zero;\n  bxyz[3 * l1] = zero;\n  bxyz[1 + (3 * l1)] = zero;\n  bxyz[2 + (3 * l1)] = zero;\n  bxyz[3 * (k1 + l1)] = zero;\n  bxyz[1 + (3 * (k1 + l1))] = zero;\n  bxyz[2 + (3 * (k1 + l1))] = zero;\n  wp += at1 * (((cu[3 * lj] * conjf(cu[3 * lj])) + (cu[1 + (3 * lj)] * conjf(cu[1 + (3 * lj)]))) + (cu[2 + (3 * lj)] * conjf(cu[2 + (3 * lj)])));\n  sum1 += wp;\n}\n\n", "pragma": "omp for nowait private(j,k,l,k1,l1,ll,lj,kk,kj,dky,dkz,at1,at2,at3,at4,zt1,zt2,zt3,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/17"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (j == (N - 1))\n    {\n      fprintf(fp, \"%d\\n\", pixels[i][j]);\n    }\n    else\n    {\n      fprintf(fp, \"%d,\", pixels[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cathy272272272/Comparision-among-serial-pthread-and-OpenMP-via-Julia-Set/OpenMp/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    u[m][i][j][k] = u[m][i][j][k] + rhs[m][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  arr[i] = i + x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/assume/test_assume_no_parallelism/0"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  show(u, w, h);\n  if (i == (iter / 2))\n  {\n    time1_local = omp_get_wtime();\n  }\n\n  evolve(u, w, h);\n  if (i == (iter / 2))\n  {\n    time2_local = omp_get_wtime();\n    elapsed_local = time2_local - time1_local;\n    printf(\"Evolve function time > %f \\n\", elapsed_local);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task3_gameoflife/gameoflife_omp/gameoflife/2"}
{"code": "for (j = 4; j <= 10000; j += 2)\n{\n  for (i = 3; i <= (j / 2); i++)\n  {\n    r1 = isprime(i);\n    r2 = isprime(j - i);\n    if ((r1 == 1) && (r2 == 1))\n    {\n      isgold[i][j / 2] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhiy91/Goldbach_conjecture/goldbach_omp/0"}
{"code": "for (int l = 0; l < tmpfortxt.size(); l++)\n{\n  Usedimage[l] = tmpfortxt[l];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/84"}
{"code": "for (i = 0; i < n; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/vec_add/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (stats->parents[v] < 0)\n  {\n    Nodes = graph->vertices[v].outNodes;\n    degree = graph->vertices[v].out_degree;\n    for (j = 0; j < degree; j++)\n    {\n      u = Nodes->dest;\n      Nodes = Nodes->next;\n      if (getBit(bitmapCurr, u))\n      {\n        stats->parents[v] = u;\n        setBitAtomic(bitmapNext, v);\n        stats->distances[v] = stats->distances[u] + 1;\n        nf++;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(Nodes,j,u,v,degree) shared(stats,bitmapCurr,bitmapNext,graph) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/17"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 3; j++)\n  for (k = 0; k < 3; k++)\n{\n  int tid2 = omp_get_thread_num();\n  printf(\"tid=%d, i=%d j=%d k=%d\\n\", omp_get_thread_num(), i, j, k);\n}\n\n\n\n", "pragma": "omp for schedule(static,3) private(i,j,k) collapse(3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab3-Collapse/collapse/0"}
{"code": "for (int i = 0; i < Cols; i++)\n{\n  Res.Vec[i] *= Res.Vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/116"}
{"code": "for (j = 0; j < sheight; j++)\n{\n  err = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *) (img_buf + j));\n  checkError(err, 241);\n  err = clSetKernelArg(kernel, 1, sizeof(cl_mem), (void *) (&cifar_buf));\n  checkError(err, 243);\n  err = clSetKernelArg(kernel, 2, sizeof(cl_mem), (void *) (output + j));\n  checkError(err, 245);\n  err = clEnqueueNDRangeKernel(command_queue[1], kernel, 3, 0, g_wsize, l_wsize, 1, write_event + j, kernel_event + j);\n  checkError(err, 249);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/B/photomosaic/2"}
{"code": "for (i = 0; i < max_size; i++)\n{\n  y[i] = y[i + lag] - y[i];\n}\n\n", "pragma": "\t  #pragma ivdep omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Laurae2/LauraeCpp/src/Rcpp_diffLp_simd_int/0"}
{"code": "for (size_t i = N - 10; i < N; ++i)\n{\n  printf(\"DATA[%zu] = %g\\n\", i, DATA[i]);\n  if (DATA[i] != 0.1)\n  {\n    printf(\"Failed\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/leopold-devicePtr/leopold-devicePtr/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  node[i].length = i;\n  node[i].width = i;\n  result[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/demo/0"}
{"code": "for (j = my_start; j <= my_end; j++)\n{\n  for (i = 0; i < ((int) floor(WIDTH / 1.0)); i++)\n  {\n    sum += pow(next_ptr[global_to_local(rank, j)][i] - current_ptr[global_to_local(rank, j)][i], 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/357r4bd/2d-heat/src/openmp-2dheat/6"}
{"code": "for (i1 = 0; i1 < mm1; i1++)\n{\n  z1[i1] = z[i3][i2 + 1][i1] + z[i3][i2][i1];\n  z2[i1] = z[i3 + 1][i2][i1] + z[i3][i2][i1];\n  z3[i1] = (z[i3 + 1][i2 + 1][i1] + z[i3 + 1][i2][i1]) + z1[i1];\n}\n\n", "pragma": "omp parallel for firstprivate(mm1 ,z ,i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/8"}
{"code": "for (i = 0; i < 480; i++)\n{\n  fgets(tmpLine, 20, handler);\n  bufferInt[i] = atoi(tmpLine);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/radixsort/radix/1"}
{"code": "for (c2 = 0; c2 <= 499; c2++)\n{\n  for (c8 = 1; c8 <= 499; c8++)\n  {\n    B[c2][c8] = B[c2][c8] - ((A[c2][c8] * A[c2][c8]) / B[c2][c8 - 1]);\n  }\n\n  for (c8 = 1; c8 <= 499; c8++)\n  {\n    X[c2][c8] = X[c2][c8] - ((X[c2][c8 - 1] * A[c2][c8]) / B[c2][c8 - 1]);\n  }\n\n  for (c8 = 0; c8 <= 497; c8++)\n  {\n    X[c2][(500 - c8) - 2] = (X[c2][(500 - 2) - c8] - (X[c2][((500 - 2) - c8) - 1] * A[c2][(500 - c8) - 3])) / B[c2][(500 - 3) - c8];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c8)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-parallel-no/1"}
{"code": "for (i = 1; i <= 1000; i += 1)\n{\n  foo(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB084-threadprivatemissing-orig-yes/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  sum = sum + in[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction (+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JerryHu1994/CS-759-High-Performance-Computing/HW12/problem1/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  ru1 = rho_i[i][j][k];\n  uu = us[i][j][k];\n  vv = vs[i][j][k];\n  ww = ws[i][j][k];\n  ac = speed[i][j][k];\n  ac2inv = ainv[i][j][k] * ainv[i][j][k];\n  r1 = rhs[0][i][j][k];\n  r2 = rhs[1][i][j][k];\n  r3 = rhs[2][i][j][k];\n  r4 = rhs[3][i][j][k];\n  r5 = rhs[4][i][j][k];\n  t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n  t2 = (bt * ru1) * ((uu * r1) - r2);\n  t3 = ((bt * ru1) * ac) * t1;\n  rhs[0][i][j][k] = r1 - t1;\n  rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n  rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n  rhs[3][i][j][k] = (-t2) + t3;\n  rhs[4][i][j][k] = t2 + t3;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,ru1 ,uu ,vv ,ww ,ac ,ac2inv ,r1 ,r2 ,r3 ,r4 ,t1 ,t2 ,t3 ,c2 ,bt ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/156"}
{"code": "for (int i = 0; i < 1024; i++)\n  A[i] = (B[i] + C[i]) + 1;\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/libomptarget/test/unified_shared_memory/api/1"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 1; j < m; j++)\n  printf(\"%lf\\n\", b[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB037-truedepseconddimension-orig-yes/2"}
{"code": "for (struct node *i = head; i != 0; i = i->next)\n  count++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsmankoo/OpenMP/linked/2"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << 20) - 1)))\n    switch ('S')\n  {\n    case 'S':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'W':\n      if (i < 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'A':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'B':\n      if (((i == 1) || (i == 2)) || (i == 4))\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'C':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/48"}
{"code": "for (i = 0; i < nd; i++)\n{\n  dr[i] = r1[i] - r2[i];\n  d += dr[i] * dr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_MolecularDynamic/c_md/3"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  A[(i * an) + j] = ((double) rand()) / ((double) 2147483647);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/strassen/src/strassen_ompi/5"}
{"code": "for (int i = 0; i < kmer.size(); i++)\n{\n  kstr << kmer[i];\n  if (i < (kmer.size() - 1))\n  {\n    kstr << \" \";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/edawson/rkmh/src/rkmh/4"}
{"code": "for (c = ny - 1; c >= 0; c--)\n{\n  for (b = 0; b <= (nx - 1); b++)\n  {\n    fprintf(fp, \"%6.1f\", *((u1 + (b * ny)) + c));\n    if (b != (nx - 1))\n      fprintf(fp, \" \");\n    else\n      fprintf(fp, \"\\n\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MikeAndroulakis/MPI-simulation-program/mpi_openmp/2"}
{"code": "for (i = 0; i < (2 * N); i += 1)\n{\n  if (((i * (incX + incY)) % 2) == 1)\n  {\n    if (((i * incX) % 2) == 1)\n      dot[0] = dot[0] + (x[i * incX] * y[i * incY]);\n    else\n      dot[0] = dot[0] - (x[i * incX] * y[i * incY]);\n\n  }\n  else\n  {\n    dot[1] = dot[1] + (x[i * incX] * y[incY]);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/dot/3"}
{"code": "for (int i = YlowerLimit; i <= YupperLimit; i++)\n{\n  for (int j = XlowerLimit; j <= XupperLimit; j++)\n  {\n    pixels.push_back((double) rgb_image[i][j][color]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/medianFilterOpenMP/0"}
{"code": "for (i = 2; i < (nx - 2); i++)\n{\n  double r = x[i];\n  temp1 = ((((((s2_np1[i] - s2_n[i]) / dt) - ((2 * ((((1.0 / 4.0) * (s1_np1[i + 1] - s1_np1[i - 1])) / dr) + (((1.0 / 4.0) * (s1_n[i + 1] - s1_n[i - 1])) / dr))) / r)) - (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s1_np1[i + 2]) - ((1.0 / 12.0) * s1_np1[i - 2])) + ((4.0 / 3.0) * s1_np1[i + 1])) + ((4.0 / 3.0) * s1_np1[i - 1])) - ((5.0 / 2.0) * s1_np1[i]))) / (dr * dr))) - (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s1_n[i + 2]) - ((1.0 / 12.0) * s1_n[i - 2])) + ((4.0 / 3.0) * s1_n[i + 1])) + ((4.0 / 3.0) * s1_n[i - 1])) - ((5.0 / 2.0) * s1_n[i]))) / (dr * dr))) + (((1.0 / 2.0) * V_np1[i]) * s1_np1[i])) + (((1.0 / 2.0) * V_n[i]) * s1_n[i]);\n  temp2 = ((((((s1_np1[i] - s1_n[i]) / dt) + ((2 * ((((1.0 / 4.0) * (s2_np1[i + 1] - s2_np1[i - 1])) / dr) + (((1.0 / 4.0) * (s2_n[i + 1] - s2_n[i - 1])) / dr))) / r)) + (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s2_np1[i + 2]) - ((1.0 / 12.0) * s2_np1[i - 2])) + ((4.0 / 3.0) * s2_np1[i + 1])) + ((4.0 / 3.0) * s2_np1[i - 1])) - ((5.0 / 2.0) * s2_np1[i]))) / (dr * dr))) + (((1.0 / 2.0) * ((((((-(1.0 / 12.0)) * s2_n[i + 2]) - ((1.0 / 12.0) * s2_n[i - 2])) + ((4.0 / 3.0) * s2_n[i + 1])) + ((4.0 / 3.0) * s2_n[i - 1])) - ((5.0 / 2.0) * s2_n[i]))) / (dr * dr))) - (((1.0 / 2.0) * V_np1[i]) * s2_np1[i])) - (((1.0 / 2.0) * V_n[i]) * s2_n[i]);\n  temp3 = ((((V_np1[i + 1] - V_np1[i - 1]) / (r * dr)) + (((((((-(1.0 / 12.0)) * V_np1[i + 2]) - ((1.0 / 12.0) * V_np1[i - 2])) + ((4.0 / 3.0) * V_np1[i + 1])) + ((4.0 / 3.0) * V_np1[i - 1])) - ((5.0 / 2.0) * V_np1[i])) / (dr * dr))) - (s1_np1[i] * s1_np1[i])) - (s2_np1[i] * s2_np1[i]);\n  res += ((temp1 * temp1) + (temp2 * temp2)) + (temp3 * temp3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/17"}
{"code": "for (j = 1; j <= npoints; j++)\n{\n  oldval[j] = values[j];\n  values[j] = newval[j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lk-2020/CFiles/concurrent_offload/2"}
{"code": "for (i = 0; i < len; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/target/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_sd[i] = m_depCo * m_depCap[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/DEP_LINSLEY/DepressionLinsley/0"}
{"code": "for (int i = 0; i < (size + 1); i++)\n{\n  if (i >= size)\n  {\n    palette[i] = (Color){.r = 0, .g = 0, .b = 0};\n    continue;\n  }\n\n  double j;\n  if (i == 0)\n  {\n    j = 3.0;\n  }\n  else\n  {\n    j = 3.0 * (log(i) / log(size - 1.0));\n  }\n\n  if (j < 1)\n  {\n    palette[i] = (Color){.r = 255 * j, .g = 0, .b = 255 * j};\n  }\n  else\n    if (j < 2)\n  {\n    palette[i] = (Color){.r = 255, .g = 255 * (j - 1), .b = 255};\n  }\n  else\n  {\n    palette[i] = (Color){.r = 255 * (j - 2), .g = 255, .b = 255 * (j - 2)};\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abagali1/mandelbrot/parallel/mandelbrot_openmp/2"}
{"code": "for (i = 0; i <= (args->N - args->M); i++)\n{\n  for (j = 0; j < args->M; j++)\n  {\n    if (args->txt[i + j] != args->pat[j])\n      break;\n\n    if ((j + 1) == args->M)\n    {\n      printf(\"Found at %d in text '%d'\\n\", i, args->ID);\n      end = 1;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) num_threads(args->OMP)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Stankevix/Parallel-Computing/String Matching/Paralelo/substring/0"}
{"code": "for (size_t p = 1; p < pc.size(); ++p)\n{\n  XS = min(XS, pc[p].location[0]);\n  XL = max(XL, pc[p].location[0]);\n  YS = min(YS, pc[p].location[1]);\n  YL = max(YL, pc[p].location[1]);\n  ZS = min(ZS, pc[p].location[2]);\n  ZL = max(ZL, pc[p].location[2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/crawfordhmc/COSC490-Project/PointCloud/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      continue;\n    }\n\n    float dist = sqrtf((powf(p[i].x - p[j].x, 2) + powf(p[i].y - p[j].y, 2)) + powf(p[i].z - p[j].z, 2));\n    float mag = ((G * m[i]) * m[j]) / powf(dist, 2);\n    struct particle dir = {.x = p[j].x - p[i].x, .y = p[j].y - p[i].y, .z = p[j].z - p[i].z};\n    f[i].x += (mag * dir.x) / dist;\n    f[i].y += (mag * dir.y) / dist;\n    f[i].z += (mag * dir.z) / dist;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, 4) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NievinEvgeny/N-body/parallel-v4/main/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  if (input[i] != (i * i))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_17_epilog_killer_parallel/6"}
{"code": "for (int i = j + 1; i < n; i++)\n{\n  double s = mul_sum(&L_c[j * n], &L_c[i * n], j);\n  L_c[(i * n) + j] = (X[(i * n) + j] - s) / L_c[(j * n) + j];\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/final/bd_omp_myc/2"}
{"code": "for (j = 1; j < num_data; j += 2)\n{\n  if (par_data[j - 1] > par_data[j])\n  {\n    par_tmp = par_data[j - 1];\n    par_data[j - 1] = par_data[j];\n    par_data[j] = par_tmp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_sort/0"}
{"code": "for (int n = 0; n < number_of_elements; n++)\n{\n  g_state_real[n] = 0;\n  g_state_imag[n] = 0;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit (BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lsqt-omp/vector/0"}
{"code": "for (i = 1; i < (block_dim - 1); i++)\n  MPI_File_iread(fh, &a[i][1], block_dim - 2, (MPI_Datatype) 0x4c000101, &requ[i - 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoRouv/game-of-life/GOLOpenMP/golOpenMP/7"}
{"code": "for (int i = 1; i < (arr_size - 1); ++i)\n{\n  b[i] = ((a[i - 1] + a[i]) + a[i + 1]) / 3.0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, chunk_size)              ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task8/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  v_data[i] /= length;\n}\n\n", "pragma": "omp parallel for shared(N,v_data) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uscheedella/Image-Interpolation/labs/lab07/code/vector/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 20) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    INT_TYPE test_rank = test_rank_array[i];\n    int failed = 0;\n    switch ('S')\n    {\n      case 'S':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'W':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n        test_rank += iteration - 1;\n      else\n        test_rank -= iteration - 1;\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'D':\n        if (i < 2)\n        test_rank += iteration;\n      else\n        test_rank -= iteration;\n\n        break;\n\n      case 'E':\n        if (i < 2)\n        test_rank += iteration - 2;\n      else\n        if (i == 2)\n      {\n        test_rank += iteration - 2;\n        if (iteration > 4)\n          test_rank -= 2;\n        else\n          if (iteration > 2)\n          test_rank -= 1;\n\n\n      }\n      else\n        test_rank -= iteration - 2;\n\n\n        break;\n\n    }\n\n    if (key_rank != test_rank)\n      failed = 1;\n    else\n      passed_verification++;\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/11"}
{"code": "for (i = 0; i < N; i++)\n{\n  dot_prod += a[i] * b[i];\n}\n\n", "pragma": "omp for reduction(+:dot_prod)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/dot_prod/0"}
{"code": "for (iteration = 0; iteration < num_iterations; iteration++)\n{\n  bestcase_omp_cycle(startPidx, endPidx, deposit);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp/14"}
{"code": "for (int i = 1; i <= finval; i++)\n{\n  double factor = (double) i;\n  pi_square += 1.0 / (factor * factor);\n}\n\n", "pragma": "omp parallel for default(none) reduction(+:pi_square)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc2n/OpenMP-Collaboration/Templates/Day_3/Reduction/SampleSolution/C/pi_square_omp_reduction/0"}
{"code": "for (int x = 3; x < (N_x + 3); x++)\n{\n  for (int y = 3; y < (N_y + 3); y++)\n  {\n    f[x][y] = ((((-v_x[x][y]) * (((((((1.0 / 60.0) * v_y[x + 3][y]) - ((1.0 / 60.0) * v_y[x - 3][y])) - ((3.0 / 20.0) * v_y[x + 2][y])) + ((3.0 / 20.0) * v_y[x - 2][y])) + ((3.0 / 4.0) * v_y[x + 1][y])) - ((3.0 / 4.0) * v_y[x - 1][y]))) / Delta_x) - ((v_y[x][y] * (((((((1.0 / 60.0) * v_y[x][y + 3]) - ((1.0 / 60.0) * v_y[x][y - 3])) - ((3.0 / 20.0) * v_y[x][y + 2])) + ((3.0 / 20.0) * v_y[x][y - 2])) + ((3.0 / 4.0) * v_y[x][y + 1])) - ((3.0 / 4.0) * v_y[x][y - 1]))) / Delta_y)) - ((g * (((((((1.0 / 60.0) * h[x][y + 3]) - ((1.0 / 60.0) * h[x][y - 3])) - ((3.0 / 20.0) * h[x][y + 2])) + ((3.0 / 20.0) * h[x][y - 2])) + ((3.0 / 4.0) * h[x][y + 1])) - ((3.0 / 4.0) * h[x][y - 1]))) / Delta_y);\n  }\n\n}\n\n", "pragma": "    #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anubhav-cs/Numerical-Methods/Shallow Water Flow/shallow_water_openmp/10"}
{"code": "for (int i = 0; i < howmany; ++i)\n{\n  int ii_start = lowerb(i, howmany, sizex);\n  int ii_end = upperb(i, howmany, sizex);\n  for (int j = 0; j < nBlocs; j++)\n  {\n    int jj_start = lowerb(j, nBlocs, sizey);\n    int jj_end = upperb(j, nBlocs, sizey);\n    if (i > 0)\n    {\n      while (processedBlocks[i - 1] <= j)\n      {\n      }\n\n    }\n\n    for (int ii = max(1, ii_start); ii <= min(sizex - 2, ii_end); ii++)\n    {\n      for (int jj = max(1, jj_start); jj <= min(sizey - 2, jj_end); jj++)\n      {\n        unew = 0.25 * (((u[(ii * sizey) + (jj - 1)] + u[(ii * sizey) + (jj + 1)]) + u[((ii - 1) * sizey) + jj]) + u[((ii + 1) * sizey) + jj]);\n        diff = unew - u[(ii * sizey) + jj];\n        sum += diff * diff;\n        u[(ii * sizey) + jj] = unew;\n      }\n\n    }\n\n    ++processedBlocks[i];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(diff,unew) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab5/solver-omp-for_gauss/2"}
{"code": "for (int i = 0; i < 4; i++)\n  printf(\"a[%d] = %d\\n\", i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture10/ExplicitBarrier_example2/ExplicitBarrier_example2/1"}
{"code": "for (i = 0; i < NJ; i++)\n{\n  for (j = 0; j < NM; j++)\n  {\n    C[(i * NM) + j] = (((DATA_TYPE) i) * (j + 3)) / NL;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3MM/3mm/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mtyutyulnikov/supercomputers_course/Task_2/example12/0"}
{"code": "for (int i = 0; i < iCycles; i++)\n{\n  GPUGaussianFilterRGBA(uiInput, uiTmp, uiOutput, uiImageWidth, uiImageHeight, &GP);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/recursiveGaussian-omp/main/0"}
{"code": "for (ii = 0; ii < params.ny; ii++)\n{\n  for (jj = 0; jj < params.nx; jj++)\n  {\n    if (obstacles[(ii * params.nx) + jj])\n    {\n      cells[(ii * params.nx) + jj].speeds[1] = tmp_cells[(ii * params.nx) + jj].speeds[3];\n      cells[(ii * params.nx) + jj].speeds[2] = tmp_cells[(ii * params.nx) + jj].speeds[4];\n      cells[(ii * params.nx) + jj].speeds[3] = tmp_cells[(ii * params.nx) + jj].speeds[1];\n      cells[(ii * params.nx) + jj].speeds[4] = tmp_cells[(ii * params.nx) + jj].speeds[2];\n      cells[(ii * params.nx) + jj].speeds[5] = tmp_cells[(ii * params.nx) + jj].speeds[7];\n      cells[(ii * params.nx) + jj].speeds[6] = tmp_cells[(ii * params.nx) + jj].speeds[8];\n      cells[(ii * params.nx) + jj].speeds[7] = tmp_cells[(ii * params.nx) + jj].speeds[5];\n      cells[(ii * params.nx) + jj].speeds[8] = tmp_cells[(ii * params.nx) + jj].speeds[6];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ii) private(jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sd12832/High-Performance-Computing-Files/d2q9-bgk-OpenMP/2"}
{"code": "for (n = 0; n < N; n++)\n{\n  Xr_o[n] = 0.0;\n  Xi_o[n] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/dftw/4"}
{"code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  fprintf(fout, \"\\t%d\", simu_opts->DEID[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/13"}
{"code": "for (int i = 0; i < MAX_ROWS; ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    _itoa_s(averages[i][j], numString, 10);\n    int k = 0;\n    char temp = numString[k];\n    while (temp != '\\0')\n    {\n      output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + k] = temp;\n      temp = numString[++k];\n    }\n\n    output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + MAX_CHARS] = '\\t';\n  }\n\n  output[(i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (MAX_COLS * (MAX_CHARS + 1))] = '\\n';\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic, 100) firstprivate(numString) shared(data)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BlurEffect/OpenMP/OpenMPAssignment/02_Sortout_Parallel_For/7"}
{"code": "for (j = 0; j < n; j++)\n  s = s + (a[j][i] * a[j][i]);\n\n", "pragma": "omp parallel for reduction(+:s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_2/QRD/Approach 1/parallel/0"}
{"code": "for (int i = 0; i < input.lookups; i++)\n{\n  uint64_t seed = STARTING_SEED;\n  seed = fast_forward_LCG(seed, 2 * i);\n  double E = LCG_random_double(&seed);\n  int mat = pick_mat(&seed);\n  double macro_xs[4] = {0};\n  calculate_macro_xs(macro_xs, mat, E, input, data);\n  double max = -DBL_MAX;\n  int max_idx = 0;\n  for (int x = 0; x < 4; x++)\n  {\n    if (macro_xs[x] > max)\n    {\n      max = macro_xs[x];\n      max_idx = x;\n    }\n\n  }\n\n  verification += max_idx + 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1000) default(none) shared(input, data) reduction(+:verification)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/0"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  result = fmax(a[x] + b[x], result);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_max/1"}
{"code": "for (i = 0; i < ph_num; i++)\n{\n  sum += (ph + i)->num_scatt;\n  avg_r_sum += pow((((ph + i)->r0 * (ph + i)->r0) + ((ph + i)->r1 * (ph + i)->r1)) + ((ph + i)->r2 * (ph + i)->r2), 0.5);\n  if ((ph + i)->num_scatt > temp_max)\n  {\n    temp_max = (ph + i)->num_scatt;\n  }\n\n  if ((i == 0) || ((ph + i)->num_scatt < temp_min))\n  {\n    temp_min = (ph + i)->num_scatt;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/15"}
{"code": "for (int i = 0; i < pixels; i++)\n{\n  pic[i] = (int) buf[3 * i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kevin1989c/sobel_openmp/Project1/Project1/Source/0"}
{"code": "for (unsigned long i = 0; i < vectorOMP.size(); i++)\n{\n  FuncCurrent.isComplete &= AnalyzeOMPNode(i, FuncCurrent);\n  if (FuncCurrent.isComplete == false)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/src/OAORewriter/9"}
{"code": "for (int i = 0; i < DIM; i++)\n{\n  h[i] = (2. * M_PI) / dims[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/exec/ns/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a[1] = a[2];\n  b[4] = b[5];\n}\n\n", "pragma": "omp parallel for firstprivate(a, b) lastprivate(a, b)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_10/0"}
{"code": "for (int j = 2; j < n; j += 2)\n{\n  if (A[j] < A[j - 1])\n  {\n    int temp = A[j];\n    A[j] = A[j - 1];\n    A[j - 1] = temp;\n  }\n\n}\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/bubblesort/2"}
{"code": "for (j = 0; j < Maze->Sections[i]; ++j)\n{\n  Maze->Edges[k + j].Weight = ((k - j) % 5) + 1;\n  Maze->Edges[k + j].Loc = k + j;\n  Maze->Edges[k + j].A = &Maze->Nodes[i][j];\n  Maze->Edges[k + j].B = &Maze->Nodes[i][(j + 1) % Maze->Sections[i]];\n  Maze->Nodes[i][j].Friends[0] = Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Self;\n  Maze->Nodes[i][(j + 1) % Maze->Sections[i]].Friends[1] = Maze->Nodes[i][j].Self;\n  Maze->Nodes[i][j].Friends[2] = -1;\n  Maze->Nodes[i][j].EdgeTo[0] = k + j;\n  Maze->Nodes[i][(j + 1) % Maze->Sections[i]].EdgeTo[1] = k + j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/17"}
{"code": "for (int j = 0; j < t_width; j++)\n{\n  for (int i = 0; i < t_width; i++)\n  {\n    float delta0 = template[i + (j * t_width)] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[0] += delta0 * delta0;\n    float delta1 = template[(((i * t_width) + t_width) - j) - 1] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[1] += delta1 * delta1;\n    float delta2 = template[((t_width - i) - 1) + (((t_width - j) - 1) * t_width)] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[2] += delta2 * delta2;\n    float delta3 = template[(((t_width - i) - 1) * t_width) + j] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[3] += delta3 * delta3;\n    float delta4 = template[((t_width - i) - 1) + (j * t_width)] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[4] += delta4 * delta4;\n    float delta5 = template[i + (((t_width - j) - 1) * t_width)] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[5] += delta5 * delta5;\n    float delta6 = template[(i * t_width) + j] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[6] += delta6 * delta6;\n    float delta7 = template[(((((t_width - i) - 1) * t_width) + t_width) - j) - 1] - image[(i + x) + ((j + y) * i_width)];\n    min_dist_array[7] += delta7 * delta7;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/howard1217/bit-image-parallel/calc_dist/0"}
{"code": "for (size_t q = 0; q < nmo; q++)\n{\n  for (size_t p = 0; p < nmo; p++)\n  {\n    mat_fock[(q * nmo) + p] = 0;\n    for (size_t l = 0; l < nao; l++)\n    {\n      double temp = 0;\n      for (size_t k = 0; k < nao; k++)\n      {\n        temp += fock_ao[(l * nao) + k] * coeff[(k * nmo) + q];\n      }\n\n      mat_fock[(q * nmo) + p] += coeff[(l * nmo) + p] * temp;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic) default(none)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/loader/loader_qmp2_from_file/0"}
{"code": "for (j = 0; j < 100; j++)\n  a[i][j] = i;\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB073-doall2-orig-yes/1"}
{"code": "for (i = 0; i <= n; i++)\n{\n  sum += f(i);\n}\n\n", "pragma": "omp for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DinosKalog/Example-of-Parallel-Computing/Example_OMP/0"}
{"code": "for (i = 1; i <= 1; i++)\n  TOPO[i][0] = TOPO[i][NODESY];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/72"}
{"code": "for (j = 0; j < nxh; j++)\n{\n  at1 = cimagf(ffc[j]);\n  for (i = 0; i < 3; i++)\n  {\n    fxyz[i + (3 * j)] += exyz[i + (3 * j)] * at1;\n    fxyz[i + (3 * (j + k1))] += exyz[i + (3 * (j + k1))] * at1;\n    fxyz[i + (3 * (j + l1))] += exyz[i + (3 * (j + l1))] * at1;\n    fxyz[i + (3 * ((j + k1) + l1))] += exyz[i + (3 * ((j + k1) + l1))] * at1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/50"}
{"code": "for (i = 0; i < numImg; i++)\n  cluster_id[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/9"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/64"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    xarea[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = celldy[FTNREF1D(k, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/9"}
{"code": "for (my_current_person_id = 0; my_current_person_id <= (our_number_of_people - 1); my_current_person_id++)\n{\n  our_x_locations[my_current_person_id] = random() % environment_width;\n  our_y_locations[my_current_person_id] = random() % environment_height;\n}\n\n", "pragma": "omp parallel for private(my_current_person_id)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/pandemic/pandemic/2"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  boxFilterRow_OpenMP(src.data(), width, dst.data(), width, size, RADIUS, true);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/13"}
{"code": "for (int depth = start_y; depth < end_y; depth++)\n{\n  for (int row = start_z; row < end_z; row++)\n  {\n    for (int column = 0; column < boundary_length; column++)\n    {\n      property_array[(((depth * nz_nx) + (row * nx)) + column) + start_x] = 0;\n      property_array[((depth * nz_nx) + (row * nx)) + ((end_x - 1) - column)] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp  parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/ZeroExtension/1"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  y[i] += a * x[i];\n  y[i + 1] += a * x[i + 1];\n  y[i + 2] += a * x[i + 2];\n  y[i + 3] += a * x[i + 3];\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/axpy/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    B[i][j] = A[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frank11158/PL_Matrix_Multiplication/Strassen/Strassen/6"}
{"code": "for (i = 1; i < N; i++)\n{\n  if ((*(arr + i)) > max)\n    max = *(arr + i);\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(max: max)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/sommaRighe&Max/1"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    int k;\n    for (k = 0; k < 2048; k++)\n    {\n      D[(i * 2048) + j] += (12435 * A[(i * 2048) + k]) * A[(j * 2048) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk_cpu/1"}
{"code": "for (int Row = 0; Row < RowN; Row++)\n{\n  if (RowSpVV[Row].Empty())\n  {\n    continue;\n  }\n\n  if (RowSpVV[Row].Last().Key >= ColN)\n  {\n    ColN = RowSpVV[Row].Last().Key + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/4"}
{"code": "for (j = (c = 0); j < 18; j++)\n{\n  for (i = 0; i < (sizeof(buffer)); i += 6)\n  {\n    buffer[i] ^= ebits_to_num[((c - i) + 48) & 0xFF];\n    buffer[i + 1] ^= ebits_to_num[((buffer[i] - i) + 47) & 0xFF];\n    buffer[i + 2] ^= ebits_to_num[((buffer[i + 1] - i) + 46) & 0xFF];\n    buffer[i + 3] ^= ebits_to_num[((buffer[i + 2] - i) + 45) & 0xFF];\n    buffer[i + 4] ^= ebits_to_num[((buffer[i + 3] - i) + 44) & 0xFF];\n    buffer[i + 5] ^= ebits_to_num[((buffer[i + 4] - i) + 43) & 0xFF];\n    c = buffer[i + 5];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus85_fmt_plug/2"}
{"code": "for (long i = 0; i <= NV; i++)\n{\n  fgets(line, 1024, file);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/reserver/parseInputFiles/4"}
{"code": "for (i = 0; i < nseqs; i++)\n  for (j = 0; j < nseqs; j++)\n  if (bench_output[(i * nseqs) + j] != 0)\n  ;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/alignment/src/alignment_ompi/5"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid->start) + ((1.0 - rx) * x_grid->end);\n  eval_multi_NUBspline_1d_z_vgl(multi_spline, x, multi_vals, multi_grads, multi_lapl);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/23"}
{"code": "for (uint32_t v = 0; v != vertex_num; ++v)\n  mplAssert(m_vCompId[v] != max());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/24"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i == j)\n      K[i][j] = 1.0;\n    else\n    {\n      temp = pow(A[i][0] - A[j][0], 2.0) + pow(A[i][1] - A[j][1], 2.0);\n      K[i][j] = exp((-1.0) * temp);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(K) private(i,j,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sharatchandraj/Gaussian-Process-Regression-OpenMP/GPR/4"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = a[i] + 1;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB071-targetparallelfor-orig-no/0"}
{"code": "for (i = 0; i < a; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    temp = 0;\n    for (k = 0; k < b; k++)\n    {\n      temp += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/17"}
{"code": "for (i = j + 1; i < n; i++)\n{\n  xfac = (double) fabs(a[i][j]);\n  if (xfac > amax)\n  {\n    amax = xfac;\n    m = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-5/2"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 10000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && SPARSE)\n    {\n      B[(i * 10000) + j] = 0;\n    }\n    else\n    {\n      B[(i * 10000) + j] = (((float) i) * (j + 1)) / 10000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanafacion/Paralelas/Exercicio12/code-t12/9"}
{"code": "for (int k = 0; k < n; ++k)\n{\n  if (t_id == 0)\n  {\n    t1 = mat[k][k];\n    for (int j = k + 1; j < n; j++)\n    {\n      mat[k][j] /= t1;\n    }\n\n    mat[k][k] = 1.0;\n  }\n\n  pthread_barrier_wait(&barrier_Divsion);\n  for (int i = (k + 1) + t_id; i < n; i += THREAD_NUM)\n  {\n    t2 = mat[i][k];\n    for (int j = k + 1; j < n; ++j)\n    {\n      mat[i][j] -= t2 * mat[k][j];\n    }\n\n    mat[i][k] = 0.0;\n  }\n\n  pthread_barrier_wait(&barrier_Elimination);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/5"}
{"code": "for (i = 0; i < 4096; ++i)\n{\n  free(a[i]);\n  free(b[i]);\n  free(c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc/matmult-toy/matmult-toy/5"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ih = 0;\n  nh = 0;\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  for (j = 0; j < npp; j++)\n  {\n    dx = ppart[j + npoff];\n    dy = ppart[(j + nppmx) + npoff];\n    ist = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        ppart[j + npoff] = dx - anx;\n\n      ist = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0)\n      {\n        dx += anx;\n        if (dx < anx)\n          ist = 1;\n        else\n          dx = 0.0;\n\n        ppart[j + npoff] = dx;\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        ppart[(j + nppmx) + npoff] = dy - any;\n\n      ist += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          ist += 3;\n        else\n          dy = 0.0;\n\n        ppart[(j + nppmx) + npoff] = dy;\n      }\n      else\n      {\n        ist += 3;\n      }\n\n    }\n\n\n    if (ist > 0)\n    {\n      ncl[(ist + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = ist;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(j,k,noff,moff,npp,npoff,nn,mm,ih,nh,ist,dx,dy,edgelx,edgely, edgerx,edgery)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    (cout << (*(vec[i] + j))) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pradyumnameena/COL380-Parallel-Programming/A1/openmp/0"}
{"code": "for (k = 0; k < N; k++)\n  for (j = 0; j < N; j++)\n{\n  a[j + (k * N)] = 2.0 * (j + k);\n  b[j + (k * N)] = 3.2 * (j - k);\n  c[j + (k * N)] = 1.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/MPP1/algoritmo_1/1"}
{"code": "for (size_t element = 0; element < m_labels.size(); ++element)\n{\n  m_cluster_index[m_labels[element]].insert(element);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/necst/DBSCAN/dbscan/2"}
{"code": "for (int blockid = 0; blockid < howmany; ++blockid)\n{\n  int i_start = lowerb(blockid, howmany, sizex);\n  int i_end = upperb(blockid, howmany, sizex);\n  for (int i = max(1, i_start); i <= min(sizex - 2, i_end); i++)\n  {\n    for (int j = 1; j <= (sizey - 2); j++)\n    {\n      utmp[(i * sizey) + j] = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n      diff = utmp[(i * sizey) + j] - u[(i * sizey) + j];\n      sum += diff * diff;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(diff) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab5/solver-omp-for_gauss/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  mean[i] = sum[i] / count[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjnsteven/wb_openmp/splitc/2"}
{"code": "for (int i = 0; i < temporaryPopulationSize; i++)\n{\n  int random = getRandomInt(0, initialPopulationSize);\n  tempPopulation.push_back(fromPopulation[random]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krris/openmp-evolutionary-algorithm/src/Population/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    printf(\"b[%d][%d] = %d \", i, j, b[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter7/fig7.11-nested-parallel/1"}
{"code": "for (col = 0; col < nX; col++)\n{\n  if ((((l1[col] == (-28768)) || (l3[col] == (-28768))) || ((l3[col] * 0.02) > 200)) || ((l4[col] * 0.001) > 0.001))\n  {\n    albedo = l4[col] * 0.001;\n    t0dem = (l3[col] * 0.02) - (0.00625 * l5[col]);\n    tempk = l3[col] * 0.02;\n    dem = l5[col];\n    e0 = e_0(l1[col] * 0.0001, l2[col] * 0.1);\n    tsw = 0.75 + ((2 * pow(10, -5)) * l5[col]);\n    lin = Lin(tsw, ta);\n    lout = Lout(e0, tempk);\n    lnet = Lnet(lout, lin);\n    kin = Kin(doy, (geomx[3] + (geomx[4] * col)) + (geomx[5] * row), tsw);\n    rnet = Rnet(l4[col] * 0.001, lnet, kin);\n    g_0 = g0(rnet, tempk, l4[col] * 0.001, l1[col] * 0.0001);\n    h0 = rnet - g_0;\n    if ((((((t0dem > 250) && (t0dem < t0dem_min)) && (t0dem > 274.0)) && (h0 > 0.0)) && (h0 < h0_min)) && (g_0 > 0.0))\n    {\n      t0dem_min = t0dem;\n      t0dem_wet = t0dem;\n      tempk_min = tempk;\n      tempk_wet = tempk;\n      rnet_wet = rnet;\n      g0_wet = g_0;\n      h0_min = h0;\n      col_wet = col;\n      row_wet = row;\n    }\n\n    if (((((tempk > 250) && (tempk >= (((double) i_peak1) - 5.0))) && (tempk < (((double) i_peak1) + 1.0))) && (rnet > 0.0)) && (albedo > 0.1))\n    {\n      tempk_min = tempk;\n      tempk_wet = tempk;\n      t0dem_min = t0dem;\n      t0dem_wet = t0dem;\n      rnet_wet = rnet;\n      g0_wet = g_0;\n      h0_min = h0;\n      col_wet = col;\n      row_wet = row;\n    }\n\n    if (((((t0dem > t0dem_max) && (rnet > 0.0)) && (g_0 > 0.0)) && (dem < dem_dry)) && (rnet < rnet_dry))\n    {\n      t0dem_max = t0dem;\n      t0dem_dry = t0dem;\n      tempk_max = tempk;\n      tempk_dry = tempk;\n      rnet_dry = rnet;\n      g0_dry = g_0;\n      dem_dry = dem;\n      col_dry = col;\n      row_dry = row;\n    }\n\n    if (((((((((t0dem >= (((double) i_peak3) - 0.0)) && (t0dem < (((double) i_peak3) + 7.0))) && (h0 > 100.0)) && (h0 > h0_max)) && (g_0 > 10.0)) && (rnet < rnet_dry)) && (albedo > 0.35)) && (dem > 0.0)) && (dem < dem_dry))\n    {\n      tempk_max = tempk;\n      tempk_dry = tempk;\n      t0dem_max = t0dem;\n      t0dem_dry = t0dem;\n      rnet_dry = rnet;\n      g0_dry = g_0;\n      h0_max = h0;\n      dem_dry = dem;\n      col_dry = col;\n      row_dry = row;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(col, albedo, t0dem, tempk, dem, e0, lin, lout, lnet, kin, rnet, g_0, h0) shared(nX, row, geomx, tsw, doy, ta, t0dem_min, t0dem_max, tempk_min, tempk_max, tempk_wet, tempk_dry, t0dem_wet, t0dem_dry, g0_wet, g0_dry, rnet_wet, rnet_dry, dem_dry, row_wet, row_dry, col_wet, col_dry, h0_max, i_peak3, i_peak1, h0_min, l1, l2, l3, l4, l5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/2"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"Thread ID: %d, index: %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/parallel12/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (count[i] == 0)\n  {\n    printf(\"ERROR, category %d has no vectors.\\n\", i);\n  }\n  else\n  {\n    float inv = 1 / count[i];\n    for (int j = 0; j < 1000; j++)\n    {\n      centres[i][j] *= inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(count) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project2/K-Means-OpenMP/1"}
{"code": "for (int i = 0; i < (b + 2); ++i)\n  wt.emplace_back(((float) 1) / ((float) (1 << i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/0"}
{"code": "for (int i = 0; i < nUsers; i++)\n  for (int j = 0; j < nFeatures; j++)\n  L[i][j] = (((double) random()) / ((double) 32767)) / ((double) nFeatures);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matFact-omp/5"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (video[i][j][k] < seuil)\n        videoseuil[i][j][k] = 0;\n      else\n        videoseuil[i][j][k] = 1;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/0"}
{"code": "for (int i = 0; i < 16; i++)\n  printf(\"b[%d] = %d\\n\", i, b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture10/ExplicitBarrier_example2/ExplicitBarrier_example2/2"}
{"code": "for (j = 0; j < 20; j++)\n{\n  ey[(0 * 20) + j] = _fict_[t];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/43"}
{"code": "for (i = 0, j = 0; j < N; i += 4, j += 4)\n{\n  x1 = _mm_load_ps(X + i);\n  y1 = _mm_load_ps(Y + i);\n  x2 = _mm_mul_ps(x1, alpha1);\n  y2 = _mm_add_ps(y1, x2);\n  _mm_store_ps(Y + i, y2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/axpy/5"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    a[i][j] = (10 * i) + j;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/parallel_loops/src/par_3/0"}
{"code": "for (i = 0; i < rowB; i++)\n{\n  for (j = 0; j < colB; j++)\n  {\n    matBt[i + (j * rowB)] = matB[(i * colB) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/lab6-2/3"}
{"code": "for (i = 0; i < simu_opts->numOE; i++)\n{\n  fprintf(fout, \"\\t%f\", simu_opts->OEFD[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/12"}
{"code": "for (int i = 0; i < size; i++)\n{\n  newVec[i] = vec[i] * c;\n}\n\n", "pragma": "#pragma omp parallel for shared(c, vec, size, newVec, chunkSize) BASE_CLAUSE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_1/1"}
{"code": "for (int ix = 0; ix < DATAXSIZE; ix++)\n{\n  for (int iy = 0; iy < DATAYSIZE; iy++)\n  {\n    for (int iz = 0; iz < DATAZSIZE; iz++)\n    {\n      double tmp = cnew[ix][iy][iz];\n      cnew[ix][iy][iz] = cold[ix][iy][iz];\n      cold[ix][iy][iz] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-omp/main/5"}
{"code": "for (size_t i = 0; i < dimensions; ++i)\n{\n  distance_sqr += (point1[i] - point2[i]) * (point1[i] - point2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nl; j++)\n{\n  if ((((i * ni) + j) % 20) == 0)\n    fprintf(POLYBENCH_DUMP_TARGET, \"\\n\");\n\n  fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, G[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/3mm/3mm/7"}
{"code": "for (int i = 0; i < radius._height; i++)\n{\n  for (int j = 0; j < radius._width; j++)\n  {\n    if (radius(i, j) < dummy_var)\n    {\n      imin = i;\n      jmin = j;\n      dummy_var = radius(i, j);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/particulate_contamination_harvey_psf/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmplg2objiv.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbrukman/llvm-openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (i = 0; i < nx; i++)\n{\n  float simd_value = Anext[i];\n  float ref_value = Anext_sc[i];\n  float abs = fabsf(simd_value - ref_value);\n  if (((isnan(simd_value) || isnan(ref_value)) || isnan(abs)) || (abs > 0.001f))\n  {\n    fprintf(stderr, \"Error: abs(Anext[%d]=%f - Anext_sc[%d]=%f) = %f\\n\", i, Anext[i], i, Anext_sc[i], abs);\n    errors = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(k, j, i) firstprivate(Anext, Anext_sc, nx) shared(stderr, errors) schedule(static) num_threads(183) default(none)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_35_parallel_heat_eq/1"}
{"code": "for (i = 0; i <= 10; i += 2)\n{\n  printf(\"Hello world %d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for/1"}
{"code": "for (index = 0; index < (threads * 1); index++)\n  memcpy(saved_key[index], salt, 16 * 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/4"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  tmp[i] = rocalution_double(this->vec_[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/12"}
{"code": "for (int dim = 0; dim < 3; dim++)\n{\n  if ((CELL_COORD(lower_bound, dim) > CELL_COORD(c, dim)) || (CELL_COORD(c, dim) > CELL_COORD(upper_bound, dim)))\n  {\n    return 0;\n  }\n\n  if ((direction[dim] == (-1)) && (CELL_COORD(c, dim) > (CELL_COORD(lower_bound, dim) + boundary_size)))\n  {\n    return 0;\n  }\n\n  if ((direction[dim] == 1) && (CELL_COORD(c, dim) < (CELL_COORD(upper_bound, dim) - boundary_size)))\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogocp/life3d/life3d-mpi/4"}
{"code": "for (j = 0; j < pcinfo.y_cells_num; j++)\n{\n  send_message_rl[j] = f[(j * pcinfo.x_cells_num) + 0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/3"}
{"code": "for (i = 0; i < SHA1_SIZE; i++)\n  buf[i] ^= digest[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/securezip_fmt_plug/2"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  u[i][0] = 0;\n  u[i][39] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/5"}
{"code": "for (i = 0; i <= 6; i += 2)\n{\n  h = (unsigned char) atoi64[ARCH_INDEX(((char *) salt)[i])];\n  h ^= ((unsigned char *) salt)[i + 1];\n  h <<= 6;\n  h ^= (unsigned char) atoi64[ARCH_INDEX(((char *) salt)[i + 1])];\n  h ^= ((unsigned char *) salt)[i];\n  retval += h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/MD5_fmt/1"}
{"code": "for (n = 0; n < MAX_ITER; ++n)\n{\n  double z_r2 = z_r * z_r;\n  double z_i2 = z_i * z_i;\n  if ((z_r2 + z_i2) > 4)\n  {\n    break;\n  }\n\n  z_i = ((2 * z_r) * z_i) + c_i;\n  z_r = (z_r2 - z_i2) + c_r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mareckste/mandelbrot_set/sources/mandelbrot_openmp_mpi_opengl/1"}
{"code": "for (int j = 0; j < sizey; j++)\n{\n  for (int i = 0; i < sizex; i++)\n  {\n    for (int mat = 0; mat < Nmats; mat++)\n    {\n      if (Vf[((i + (sizex * j)) * Nmats) + mat] > 0.0)\n      {\n        double nm = n[mat];\n        p[((i + (sizex * j)) * Nmats) + mat] = ((nm * rho[((i + (sizex * j)) * Nmats) + mat]) * t[((i + (sizex * j)) * Nmats) + mat]) / Vf[((i + (sizex * j)) * Nmats) + mat];\n      }\n      else\n      {\n        p[((i + (sizex * j)) * Nmats) + mat] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/full_assignment/4"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  if (i < 500)\n  {\n    array[i] = 1 + (rand() % 500);\n  }\n  else\n    if (i < 1000)\n  {\n    array[i] = 501 + (rand() % 500);\n  }\n  else\n    if (i < 1500)\n  {\n    array[i] = 1001 + (rand() % 500);\n  }\n  else\n    if (i < 2000)\n  {\n    array[i] = 1501 + (rand() % 500);\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Elusive7733/OpenMP-vs-Pthread-vs-Serial-Sorting/OpenMP/BubbleSort_OpenMP/2"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  beta = ((.5 * qom[is]) * dt) / c;\n  for (int i = 0; i < nxn; i++)\n    for (int k = 0; k < nzn; k++)\n  {\n    omcx = beta * (Bxn[i][nyn - 2][k] + Bx_ext[i][nyn - 2][k]);\n    omcy = beta * (Byn[i][nyn - 2][k] + By_ext[i][nyn - 2][k]);\n    omcz = beta * (Bzn[i][nyn - 2][k] + Bz_ext[i][nyn - 2][k]);\n    denom = ((((((FourPI / 2) * delt) * dt) / c) * qom[is]) * rhons[is][i][nyn - 2][k]) / (((1.0 + (omcx * omcx)) + (omcy * omcy)) + (omcz * omcz));\n    susxy[i][k] += (omcz + (omcx * omcy)) * denom;\n    susyy[i][k] += (1.0 + (omcy * omcy)) * denom;\n    suszy[i][k] += ((-omcx) + (omcy * omcz)) * denom;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/89"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (5.0 * u[m][i][j][k])));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/131"}
{"code": "for (int i = 0; i <= n; i += 2)\n{\n  sumP += i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/sum/2"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  a += i;\n}\n\n", "pragma": "omp parallel for reduction(+:a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_par3/nested_par3/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 4; j++)\n    bucket[i] += omp_bucket[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/radixsort/4"}
{"code": "for (i = 0; i < varNumF1; i++)\n{\n  f1_layer[o][i].W = 0.0;\n  f1_layer[o][i].X = 0.0;\n  f1_layer[o][i].V = 0.0;\n  f1_layer[o][i].U = 0.0;\n  f1_layer[o][i].P = 0.0;\n  f1_layer[o][i].Q = 0.0;\n  f1_layer[o][i].R = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/12"}
{"code": "for (int col = OFFSET; col < (width - OFFSET); col++)\n{\n  for (int row = OFFSET; row < (height - OFFSET); row++)\n  {\n    int pixel_index = col + (row * width);\n    if (output_image[pixel_index] == 100)\n    {\n      if ((((((((output_image[pixel_index - 1] == 255) || (output_image[pixel_index + 1] == 255)) || (output_image[pixel_index - width] == 255)) || (output_image[pixel_index + width] == 255)) || (output_image[(pixel_index - width) - 1] == 255)) || (output_image[(pixel_index - width) + 1] == 255)) || (output_image[(pixel_index + width) - 1] == 255)) || (output_image[(pixel_index + width) + 1] == 255))\n        output_image[pixel_index] = 255;\n      else\n        output_image[pixel_index] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashsm79/parallel-canny-edge-detector/src/canny/4"}
{"code": "for (long i = 0; i < I->ntracks_2D; i++)\n{\n  if ((i % 50) == 0)\n    if (I->mype == 0)\n    printf(\"%s%ld%s%ld\\n\", \"2D Tracks Completed = \", i, \" / \", I->ntracks_2D);\n\n\n  double **seg_dist = malloc(I->z_stacked * (sizeof(double *)));\n  Source ***seg_src = malloc(I->z_stacked * (sizeof(Source **)));\n  int *seg_idx = malloc(I->z_stacked * (sizeof(int)));\n  int *seg_size = malloc(I->z_stacked * (sizeof(int)));\n  for (int k = 0; k < I->z_stacked; k++)\n  {\n    seg_size[k] = 2 * I->segments_per_track;\n    seg_dist[k] = malloc(seg_size[k] * (sizeof(double)));\n    seg_src[k] = malloc(seg_size[k] * (sizeof(Source *)));\n    seg_idx[k] = 0;\n  }\n\n  bool pos_z_dir = 1;\n  for (int j = 0; j < I->n_polar_angles; j++)\n  {\n    if (j == (I->n_polar_angles / 2))\n      pos_z_dir = 0;\n\n    float p_angle = params->polar_angles[j];\n    float mu = cos(p_angle);\n    int begin_stacked = 0;\n    int end_stacked = I->z_stacked;\n    for (int k = 0; k < I->z_stacked; k++)\n      seg_idx[k] = 0;\n\n    for (int n = 0; n < params->tracks_2D[i].n_segments; n++)\n    {\n      float s_full = params->tracks_2D[i].segments[n].length / sin(p_angle);\n      float ds = 0;\n      int tracks_completed = 0;\n      for (int k = begin_stacked; k < end_stacked; k++)\n      {\n        Track *track = &params->tracks[i][j][k];\n        int interval = ((int) track->z_height) / fine_delta_z;\n        float bound_dist;\n        if (pos_z_dir)\n          bound_dist = (node_delta_z - track->z_height) / mu;\n        else\n          bound_dist = (-track->z_height) / mu;\n\n        float s;\n        if (s_full < bound_dist)\n          s = s_full;\n        else\n        {\n          s = bound_dist;\n          tracks_completed++;\n        }\n\n        bool seg_complete = 0;\n        while (!seg_complete)\n        {\n          long QSR_id = interval + (num_intervals * n);\n          float ds;\n          float z;\n          float fai_z_height;\n          if (pos_z_dir)\n            fai_z_height = (interval + 1) * fine_delta_z;\n          else\n            fai_z_height = interval * fine_delta_z;\n\n          float z_dist_to_fai = fai_z_height - track->z_height;\n          float s_dist_to_fai = z_dist_to_fai / mu;\n          if (s_dist_to_fai < s)\n          {\n            if (pos_z_dir)\n              interval++;\n            else\n              interval--;\n\n            ds = s_dist_to_fai;\n            z = track->z_height + z_dist_to_fai;\n          }\n          else\n          {\n            ds = s;\n            z = track->z_height + (s * mu);\n          }\n\n          s -= ds;\n          if (((s <= 0) || (interval < 0)) || (interval >= num_intervals))\n            seg_complete = 1;\n\n          QSR_id = rand() % I->n_source_regions_per_node;\n          if (I->axial_exp == 2)\n          {\n            attenuate_fluxes(track, 1, &params->sources[QSR_id], I, params, ds, mu, params->tracks_2D[i].az_weight, &A);\n            segments_processed++;\n          }\n          else\n            if (I->axial_exp == 0)\n            attenuate_FSR_fluxes(track, 1, &params->sources[QSR_id], I, params, ds, mu, params->tracks_2D[i].az_weight, &A);\n          else\n          {\n            printf(\"Error: invalid axial expansion order\");\n            printf(\"\\n Please input 0 or 2\\n\");\n            exit(1);\n          }\n\n\n          track->z_height = z;\n          seg_dist[k][seg_idx[k]] = ds;\n          seg_src[k][seg_idx[k]] = &params->sources[QSR_id];\n          seg_idx[k]++;\n          if (seg_idx[k] >= seg_size[k])\n          {\n            seg_size[k] *= 2;\n            seg_dist[k] = (double *) realloc(seg_dist[k], seg_size[k] * (sizeof(double)));\n            seg_src[k] = (Source **) realloc(seg_src[k], seg_size[k] * (sizeof(Source *)));\n          }\n\n        }\n\n      }\n\n      if (pos_z_dir)\n        end_stacked -= tracks_completed;\n      else\n        begin_stacked += tracks_completed;\n\n    }\n\n    for (int k = 0; k < I->z_stacked; k++)\n    {\n      for (int n = seg_idx[k] - 1; n >= 0; n--)\n      {\n        float ds = seg_dist[k][n];\n        Track *track = &params->tracks[i][j][k];\n        if (I->axial_exp == 2)\n        {\n          attenuate_fluxes(track, 0, seg_src[k][n], I, params, ds, -mu, params->tracks_2D[i].az_weight, &A);\n          segments_processed++;\n        }\n        else\n          if (I->axial_exp == 0)\n          attenuate_FSR_fluxes(track, 0, seg_src[k][n], I, params, ds, -mu, params->tracks_2D[i].az_weight, &A);\n\n\n        track->z_height -= ds * mu;\n      }\n\n    }\n\n    for (int k = 0; k < I->z_stacked; k++)\n    {\n      Track *track = &params->tracks[i][j][k];\n      if (pos_z_dir)\n        track->z_height = I->axial_z_sep * k;\n      else\n        track->z_height = I->axial_z_sep * (k + 1);\n\n    }\n\n  }\n\n  for (int k = 0; k < I->z_stacked; k++)\n  {\n    free(seg_dist[k]);\n    free(seg_src[k]);\n  }\n\n  free(seg_dist);\n  free(seg_src);\n  free(seg_idx);\n  free(seg_size);\n}\n\n", "pragma": "omp for schedule( dynamic )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/1"}
{"code": "for (i = 0; i < ((int) n_rows_a); i += TILE_ORDER)\n{\n  for (k = 0; k < ((int) n_cols_b); k += TILE_ORDER)\n  {\n    for (j = 0; j < ((int) n_cols_a); j += TILE_ORDER)\n    {\n      for (it = i; it < MIN((int) n_rows_a, i + TILE_ORDER); it++)\n      {\n        for (kt = k; kt < MIN((int) n_cols_b, k + TILE_ORDER); kt++)\n        {\n          data_t sum = 0.0;\n          for (jt = j; jt < MIN((int) n_cols_a, j + TILE_ORDER); jt++)\n          {\n            sum += a[(it * n_cols_a) + jt] * b[(jt * n_cols_b) + kt];\n          }\n\n          c[(it * n_cols_b) + kt] += sum;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i, j, k, it, jt, kt) shared(a, n_rows_a, n_cols_a, b, n_rows_b, n_cols_b, c) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/9"}
{"code": "for (size_t i = 0; i < 4; ++i)\n{\n  indx[i] = mandelbrot_scalar(mandel_test[i], mandel_test1[i], max_iter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/9"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i - 1][j][k][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/82"}
{"code": "for (int i = 1; i <= nodesCount; ++i)\n{\n  if (distance[i][k] != (-1))\n  {\n    for (int j = 1; j <= nodesCount; ++j)\n    {\n      if ((distance[k][j] != (-1)) && ((distance[i][j] == (-1)) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n      {\n        distance[i][j] = distance[i][k] + distance[k][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Serena-Chenzz/openmp_project1A/1for_static/0"}
{"code": "for (int j = mat * width; j < ((sizey / 2) + overlap_j); j++)\n{\n  for (int i = ((mat * width) - (mat > 0)) - ((mat > 0) * overlap_i); i < ((mat + 1) * width); i++)\n  {\n    cc.rho[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n  for (int i = ((sizex - (mat * width)) - 1) + ((mat > 0) * overlap_i); i >= ((sizex - ((mat + 1) * width)) - 1); i--)\n  {\n    cc.rho[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((i + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/1"}
{"code": "for (int i = 1; i < (num_snp * num_snp); i++)\n{\n  if (score > dev_scores[i])\n  {\n    score = dev_scores[i];\n    solution = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/epistatis-omp/main/12"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/scan_messages/0"}
{"code": "for (unsigned int i = 0; i < (TDim + 1); ++i)\n{\n  p_elem->GetGeometry()[i].FastGetSolutionStepValue(FLUID_FRACTION) += N[i] * particle_volume;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/10"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  cities[i][0] = (((float) rand()) / 32767) * 1e3;\n  cities[i][1] = (((float) rand()) / 32767) * 1e3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project3/Ant-Colony/3"}
{"code": "for (int x = 1; x <= iters; x++)\n  i.smoothenTest(x);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/16"}
{"code": "for (i = 0; i < ngrid; i++)\n{\n  gx[i] = ((float) rand()) / ((float) RAND_MAX);\n  gy[i] = ((float) rand()) / ((float) RAND_MAX);\n  gz[i] = ((float) rand()) / ((float) RAND_MAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mdh-omp/main/1"}
{"code": "for (i = 0; i < ncommpartner; i++)\n{\n  const int dest = commpartner[i];\n  const int sendcount = comap->sendcount[dest];\n  if (sendcount > 0)\n  {\n    int *sendindex = comap->sendindex[dest];\n    for (j = 0; j < sendcount; j++)\n      for (col = 0; col < ncols; col++)\n      sendbuf[i][(j * ncols) + col] = mat[sendindex[j]][col];\n\n\n    MPI_Isend(sendbuf[i], ncols * sendcount, (MPI_Datatype) 0x4c00080b, dest, tag, comm, (request + nrequest) + i);\n  }\n\n}\n\n", "pragma": "omp for COMM_SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/exchange_matrix/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  fprintf(f, \"%lf %lf %lf\\n\", allClusters[i].x, allClusters[i].y, allClusters[i].z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/11"}
{"code": "for (size_t i = 0; i < internalDOF.rows(); i++)\n{\n  for (size_t j = 0; j < K.rows(); j++)\n  {\n    K(j, Nnod + i) = Kprime(j, internalDOF(i));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/29"}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (a[i] * b[i]);\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonlota/Taller-OpenMP/openmp/parallelfor_00/0"}
{"code": "for (i = 0; i < n; i++)\n  T[i].val = estim(T[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/22"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = (i % 2) + 1; j < (N - 1); j += 2)\n  {\n    unew[i][j] = ((((uold[i - 1][j] + uold[i + 1][j]) + uold[i][j - 1]) + uold[i][j + 1]) + ((1.0 * h) * h)) / 4.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jzuhusky/HPC_Homework2/gs2D-omp/0"}
{"code": "for (int j = 0; j < num_of_elements; j++)\n{\n  if (y[j] > max)\n    max = y[j];\n\n  maxlocation = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/parallel_with_critical/0"}
{"code": "for (unsigned int i = 0; i < size_of_floats; ++i)\n{\n  src[i] = i;\n  dst[i] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/13"}
{"code": "for (myrow = 0; myrow < MINIGRIDSIZE; myrow++)\n  for (mycol = 0; mycol < MINIGRIDSIZE; mycol++)\n  if (grid[myrow + boxStartRow][mycol + boxStartCol] == num)\n{\n  alreadyinbox = 1;\n  myrow = MINIGRIDSIZE;\n  mycol = MINIGRIDSIZE;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/17"}
{"code": "for (long vy = y - 1; vy <= (y + 1); vy++)\n{\n  for (long vx = x - 1; vx <= (x + 1); vx++)\n  {\n    soma += tabuleiro[vy][vx];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/novo_jogo_da_vida/jogo/1"}
{"code": "for (i = 0; i < 1200; i++)\n{\n  for (j = 0; j < 1200; j++)\n  {\n    C[(i * 1200) + j] *= 4546;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/12"}
{"code": "for (int i = 0; i < k; i++)\n{\n  centroids[i] = (float *) calloc(m, sizeof(float));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/9"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n    sum += j;\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49898-2/0"}
{"code": "for (int i = 0; i < space; i += 3)\n{\n  b = *(arr_in + i);\n  g = *((arr_in + i) + 1);\n  r = *((arr_in + i) + 2);\n  unsigned char pixel = ((0.21 * r) + (0.72 * g)) + (0.07 * b);\n  my_arr[index].b = pixel;\n  my_arr[index].g = pixel;\n  my_arr[index].r = pixel;\n  index++;\n  count += 3;\n  if (count == (ancho * 3))\n  {\n    i += extra;\n    count = 0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/0"}
{"code": "for (int i = 0; i < CITIES; i++)\n{\n  if (getCharPosition(offspringItinerary, CITIES, parent.itinerary[i]) < 0)\n  {\n    offspringItinerary[indexInOffspring] = parent.itinerary[i];\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sanjusha-sujan/TravellingSalesmanOpenMP/Tsp/3"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  changement = 0;\n  changement = do_tile_vect512_long(1, 1, DIM - 2, DIM - 2, 0);\n  swap_tab();\n  if (changement == 0)\n    return it;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/33"}
{"code": "for (j = 0; j < F->nodes[i]->degree; j++)\n{\n  for (k = 0; k < R->size; k++)\n  {\n    if (G->nodes[R->nodeIdx[i]]->neighbours[j]->idx == R->nodeIdx[k])\n    {\n      index = k;\n    }\n\n  }\n\n  F->nodes[i]->neighbours[j] = F->nodes[index];\n}\n\n", "pragma": "omp parallel for num_threads(4) private(k, index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/1"}
{"code": "for (size_t y = 1; y < (h - 1); ++y)\n{\n  #pragma acc loop worker independent\n  for (size_t x = 1; x < (w - 1); ++x)\n  {\n    double w_local = c[(y * w) + x];\n    double restw = 1.0 - w_local;\n    dst[(y * w) + x] = ((w_local * src[(y * w) + x]) + ((((src[((y + 1) * w) + x] + src[((y - 1) * w) + x]) + src[((y * w) + x) + 1]) + src[((y * w) + x) - 1]) * (restw * c_cdir))) + ((((src[(((y - 1) * w) + x) - 1] + src[(((y - 1) * w) + x) + 1]) + src[(((y + 1) * w) + x) - 1]) + src[(((y + 1) * w) + x) + 1]) * (restw * c_cdiag));\n  }\n\n  dst[((y * w) + w) - 1] = dst[(y * w) + 1];\n  dst[(y * w) + 0] = dst[((y * w) + w) - 2];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/compute/0"}
{"code": "for (i = 5; i <= i; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/11"}
{"code": "for (jj = 1; jj < (ny - 1); jj += ty)\n{\n  for (ii = 1; ii < (nx - 1); ii += tx)\n  {\n    for (k = 1; k < (nz - 1); k++)\n    {\n      for (j = jj; j < (((jj + ty) < (ny - 1)) ? (jj + ty) : (ny - 1)); j++)\n      {\n        for (i = ii; i < (((ii + tx) < (nx - 1)) ? (ii + tx) : (nx - 1)); i++)\n        {\n          Anext[Index3D(nx, ny, i, j, k)] = (((((A0[Index3D(nx, ny, i, j, k + 1)] + A0[Index3D(nx, ny, i, j, k - 1)]) + A0[Index3D(nx, ny, i, j + 1, k)]) + A0[Index3D(nx, ny, i, j - 1, k)]) + A0[Index3D(nx, ny, i + 1, j, k)]) + A0[Index3D(nx, ny, i - 1, j, k)]) - ((6.0 * A0[Index3D(nx, ny, i, j, k)]) / (fac * fac));\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/stencil/3dHeat/Variations/heat-blocked_omp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/easy_mapper/main/0"}
{"code": "for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  for (i = 0; i < 128; i += 4)\n  for (j = 0; j < 128; j++)\n{\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n  C[k][l] += 0.5 * ((A[l][i + 1][j] * B[k][i + 1][j]) + (A[k][i + 1][j] * B[l][i + 1][j]));\n  C[k][l] += 0.5 * ((A[l][i + 2][j] * B[k][i + 2][j]) + (A[k][i + 2][j] * B[l][i + 2][j]));\n  C[k][l] += 0.5 * ((A[l][i + 3][j] * B[k][i + 3][j]) + (A[k][i + 3][j] * B[l][i + 3][j]));\n}\n\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/pa2/PP2/PA2-Prob2-unr/0"}
{"code": "for (int j = index; j < ((index + block_size) - 1); j++)\n{\n  a[j] = a[j] + last_element_current_block_value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /PrefixSum/hillis_steele/3"}
{"code": "for (i = 0; i <= (w * h); i++)\n{\n  imageArray[i] = (unsigned char) ((rand() % 255) + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrchowmein/Cuda_Comparison/openMPBlur/2"}
{"code": "for (int i = 0; i < desc.size(); i++)\n{\n  stdev_nom += pow(desc[i] - mean, 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zon5566/SIFT-on-OpenMP/sift/7"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    matrix[i][j] = rand();\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KManolov3/parallel-matrix-mult/parallel-matrix-multiply/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = thread_id;\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/Parallel_progr/Day2/ex2/loop_schedule/0"}
{"code": "for (int i = 0; i < N; i++)\n  tmp_mid[tester[i]]++;\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/0"}
{"code": "for (i = 0; i < N; i++)\n  *(A + i) = Avector + (i * M);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Hybrid/mxvnm_OMPI/1"}
{"code": "for (i = jz; i >= 0; i--)\n{\n  q[i] = fw * ((double) iq[i]);\n  fw *= twon24;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/15"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += T[i];\n}\n\n", "pragma": "omp parallel for shared(T) reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/martamorg/PPAR_openmp/aggregation-openmp/3"}
{"code": "for (i = 0; i < 160; i++)\n  for (j = 0; j < 90; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "omp for ordered schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_8/Ejercicio_2/matrixMulti_openmp/2"}
{"code": "for (int i = 0; i < tmpMatrix.size(); i++)\n{\n  aelem.push_back((get < 2) > tmpMatrix[i]);\n  jptr.push_back((get < 1) > tmpMatrix[i]);\n  if (((get < 0) > tmpMatrix[i]) != prev_row)\n  {\n    iptr.push_back(i + 1);\n    prev_row = (get < 0) > tmpMatrix[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/godblessedkid/lu-decomp/LU_Master/5"}
{"code": "for (unsigned int i = 0; i < density_names.size(); i++)\n{\n  if (density_names[i] == name)\n  {\n    return i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/7"}
{"code": "for (unsigned long long int i = 0; i < n; i++)\n{\n  objects.at(i).set_number(value);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gtrabes/Heterogeneous-OpenMP/main/3"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    double cij = C[(j * lda) + i];\n    for (k = 0; k < K; ++k)\n    {\n      cij += A[(k * lda) + i] * B[(j * lda) + k];\n    }\n\n    C[(j * lda) + i] = cij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/matmul/blocked/1"}
{"code": "for (i = 0; i < (n * n_p); i++)\n{\n  fprintf(stderr, \"%.0f \", B[i]);\n  if (((i + 1) % n) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW3/matmul1d/2"}
{"code": "for (int i = 0; i < NBUCKETS; i++)\n{\n  hist[i] = 0;\n  omp_init_lock(&locks[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/omp9/0"}
{"code": "for (size_t i = 0; i < 4; i++)\n{\n  outVector[i + outVecIndex] = outBlock[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/phoenixEkb/OpenMP-base64-encoder-decoder/OpenMPTest/OpenMPTest/6"}
{"code": "for (int i = 0; i < (numOfProcs - 1); ++i)\n{\n  int proc = 0;\n  unsigned long tmp_size = 0;\n  rComm.receiveDataFromAnySource(tmp_size, &proc, tag);\n  if (tmp_size > 0)\n  {\n    MatrixElement > tmp_elements(tmp_size);\n    rComm.receiveDataX(&tmp_elements[0], tmp_size, proc, tag + 1);\n    const_iterator itEnd = tmp_elements.end();\n    for (const_iterator it = tmp_elements.begin(); it != itEnd; ++it)\n    {\n      colVectorMatrix.set(it->row, it->col, it->value);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD_Parallel/8"}
{"code": "for (int i = 1; i < num_procs; i++)\n{\n  MPI_Send(NULL, 0, MPI_INT, i, TagType_Exit, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hi2p-perim/smallpt-mpi/src/main/3"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (L * L))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/73"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Entrez un element du tableau---------- \\n\");\n  scanf(\"%f\", &tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hermannwilfried694/OpenMP1/max1/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  A[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gapgag55/OpenMP-Excercise/2.SumReductionClause/openmp/1"}
{"code": "for (i = 0; i < lin; i++)\n{\n  matriz[i] = (int *) calloc(col, sizeof(int));\n  for (j = 0; j < col; j++)\n  {\n    matriz[i][j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoborgesdeoliveira/Matrix-Multiplication-and-Sum-with-OpenMP-and-PThreads/Matrizes OpenMP/matriz2d/6"}
{"code": "for (int i = 0; i < nOctaves; i++)\n{\n  w = gpyr[i * nGpyrLayers].w;\n  h = gpyr[i * nGpyrLayers].h;\n  for (int j = 1; j <= nLayers; j++)\n  {\n    int layer_index = (i * nGpyrLayers) + j;\n    grdPyr[layer_index].init(w, h);\n    rotPyr[layer_index].init(w, h);\n    srcData = gpyr[layer_index].data;\n    grdData = grdPyr[layer_index].data;\n    rotData = rotPyr[layer_index].data;\n    for (int r = 0; r < h; r++)\n    {\n      for (int c = 0; c < w; c++)\n      {\n        dr = get_pixel_f(srcData, w, h, r + 1, c) - get_pixel_f(srcData, w, h, r - 1, c);\n        dc = get_pixel_f(srcData, w, h, r, c + 1) - get_pixel_f(srcData, w, h, r, c - 1);\n        grdData[(r * w) + c] = sqrtf((dr * dr) + (dc * dc));\n        angle = atan2f(dr, dc + FLT_MIN);\n        angle = (angle < 0) ? (angle + _2PI) : (angle);\n        rotData[(r * w) + c] = angle;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/6"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  nv = cell(ci).getNV();\n  for (vi = 0; vi < nv; vi++)\n  {\n    for (d = 0; d < NDIM; d++)\n    {\n      ftmp = cell(ci).vforce(vi, d) * cell(ci).vforce(vi, d);\n      if (ftmp > maxForce)\n        maxForce = ftmp;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/27"}
{"code": "for (i = 0; i < nc; i += 4)\n{\n  tempnrm[pr] += x[i] * x[i];\n  tempnrm[pr] += x[i + 1] * x[i + 1];\n  tempnrm[pr] += x[i + 2] * x[i + 2];\n  tempnrm[pr] += x[i + 3] * x[i + 3];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/mathsub/0"}
{"code": "for (int i = size - 1; i >= 0; i--)\n{\n  res += x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task5/main/2"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  assignew = DoptBCDOne(data_proc.rows(0, cov_num - 1), n, cov_num);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Up;\n  TU = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (Up - diff_data);\n  mupdate = ((Up - diff_data) > (2 * (Um - diff_data))) || ((Up - diff_data) < ((Um - diff_data) * 0.5));\n  Up = (TU > (diff_data - ((Up * n1c) / n))) ? (Up - ((c * alpha) / m)) : (Up + ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Um = (mupdate) ? (Up) : (Um);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/30"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  printf(\"%i, \", A[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/main/2"}
{"code": "for (int i = 0; (i < height) && (freaderror >= 0); i++)\n{\n  freaderror = fread(&data[(i * width) * 3], sizeof(unsigned char), width * 3, photo);\n  fseek(photo, width % 4, SEEK_CUR);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xVenve/POpenMP/image-par/0"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n    printf(\"%d \", matB[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/9"}
{"code": "for (i = 0; i < 16; i++)\n{\n  f(i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rescurib/Notas_Computo_Paralelo/MemoriaCompartida/Sec_05/Ejemplo_5_2_OpenMP/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    tmp[j + (i * k)] = (*kernel)[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcogualtieri/kernel_image_processing/openmp_kernel_image_processing/1"}
{"code": "for (i = 0; i < 100; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pooyagolchian/OpenMpSampleCode/6-core-concept/hello/0"}
{"code": "for (i = 1; i < (rows + 1); i++)\n{\n  for (j = 1; j < (columns + 1); j++)\n  {\n    (output_file << b_matrix_curr_iter[i][j]) << ' ';\n  }\n\n  if (i < rows)\n    output_file << \"\\n\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JohnBogdan1/Distributed-Programming/Game of Life/g_omp/2"}
{"code": "for (i = 0; i < (n + 1); i++)\n{\n  temp = matrix[(r1 * (n + 1)) + i];\n  matrix[(r1 * (n + 1)) + i] = matrix[(r2 * (n + 1)) + i];\n  matrix[(r2 * (n + 1)) + i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/9"}
{"code": "for (i = 1; i <= (n - 1); i++)\n{\n  approx += f(a + (i * h));\n  iters[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: approx) schedule(dynamic )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pouyarz/Parallel--Estimate-Integral-using-the-Trapezoidal-Rule-OpenMP/omp_trap3_dynamic/0"}
{"code": "for (int i = 0; i < my_num_particles; i++)\n{\n  c[i].x += (v[i].x + ((0.5 * a[i].x) * deltatime)) * deltatime;\n  c[i].y += (v[i].y + ((0.5 * a[i].y) * deltatime)) * deltatime;\n  c[i].z += (v[i].z + ((0.5 * a[i].z) * deltatime)) * deltatime;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jankopanski/Three-Body-Problem/body3_mpi_omp/2"}
{"code": "for (int i = max_cols - 4; i >= 0; i--)\n{\n  for (int idx = 0; idx <= i; idx++)\n  {\n    int index = ((((((max_cols - idx) - 2) * max_cols) + idx) + max_cols) - i) - 2;\n    input_itemsets[index] = maximum(input_itemsets[(index - 1) - max_cols] + referrence[index], input_itemsets[index - 1] - penalty, input_itemsets[index - max_cols] - penalty);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/10"}
{"code": "for (int i = 0; i < maskDimensions; i++)\n{\n  for (int j = 0; j < maskDimensions; j++)\n    maskMatrix[i][j] = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/BlurImageParallel/3"}
{"code": "for (i = 0; i < nodes; i++)\n{\n  Anext = Aindex[i];\n  Alast = Aindex[i + 1];\n  sum0 = ((A[Anext][0][0] * v[i][0]) + (A[Anext][0][1] * v[i][1])) + (A[Anext][0][2] * v[i][2]);\n  sum1 = ((A[Anext][1][0] * v[i][0]) + (A[Anext][1][1] * v[i][1])) + (A[Anext][1][2] * v[i][2]);\n  sum2 = ((A[Anext][2][0] * v[i][0]) + (A[Anext][2][1] * v[i][1])) + (A[Anext][2][2] * v[i][2]);\n  Anext++;\n  while (Anext < Alast)\n  {\n    col = Acol[Anext];\n    sum0 += ((A[Anext][0][0] * v[col][0]) + (A[Anext][0][1] * v[col][1])) + (A[Anext][0][2] * v[col][2]);\n    sum1 += ((A[Anext][1][0] * v[col][0]) + (A[Anext][1][1] * v[col][1])) + (A[Anext][1][2] * v[col][2]);\n    sum2 += ((A[Anext][2][0] * v[col][0]) + (A[Anext][2][1] * v[col][1])) + (A[Anext][2][2] * v[col][2]);\n    if (w2[my_cpu_id][col] == 0)\n    {\n      w2[my_cpu_id][col] = 1;\n      w1[my_cpu_id][col].first = 0.0;\n      w1[my_cpu_id][col].second = 0.0;\n      w1[my_cpu_id][col].third = 0.0;\n    }\n\n    w1[my_cpu_id][col].first += ((A[Anext][0][0] * v[i][0]) + (A[Anext][1][0] * v[i][1])) + (A[Anext][2][0] * v[i][2]);\n    w1[my_cpu_id][col].second += ((A[Anext][0][1] * v[i][0]) + (A[Anext][1][1] * v[i][1])) + (A[Anext][2][1] * v[i][2]);\n    w1[my_cpu_id][col].third += ((A[Anext][0][2] * v[i][0]) + (A[Anext][1][2] * v[i][1])) + (A[Anext][2][2] * v[i][2]);\n    Anext++;\n  }\n\n  if (w2[my_cpu_id][i] == 0)\n  {\n    w2[my_cpu_id][i] = 1;\n    w1[my_cpu_id][i].first = 0.0;\n    w1[my_cpu_id][i].second = 0.0;\n    w1[my_cpu_id][i].third = 0.0;\n  }\n\n  w1[my_cpu_id][i].first += sum0;\n  w1[my_cpu_id][i].second += sum1;\n  w1[my_cpu_id][i].third += sum2;\n}\n\n", "pragma": "omp for private(i,Anext,Alast,col,sum0,sum1,sum2) firstprivate(nodes)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/5"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  int ID = omp_get_thread_num();\n  x[i] = (i + 0.5) * step;\n  sum[ID] += 4.0 / (1.0 + (x[i] * x[i]));\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johanna-codes/Learning/OpenMP/exer_2_omp/1"}
{"code": "for (j = 0; j < c; j++)\n{\n  if ((j < weight[i]) || (total[i - 1][j] >= (total[i - 1][j - weight[i]] + profit[i])))\n  {\n    total[i][j] = total[i - 1][j];\n    use[i][j] = 0;\n  }\n  else\n  {\n    total[i][j] = total[i - 1][j - weight[i]] + profit[i];\n    use[i][j] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pengjuntc/knapsack-openmp/knap_para/0"}
{"code": "for (c1 = 0; c1 <= 127; c1++)\n{\n  for (c2 = 0; c2 <= 127; c2++)\n  {\n    G[c1][c2] = 0;\n    F[c1][c2] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/96"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/55"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      const int index = (((ii * _chunk.x) * _chunk.y) + (jj * _chunk.x)) + kk;\n      u[index] = (((u0[index] + ((kx[index + 1] * r[index + 1]) + (kx[index] * r[index - 1]))) + ((ky[index + _chunk.x] * r[index + _chunk.x]) + (ky[index] * r[index - _chunk.x]))) + ((kz[index + _chunk.page] * r[index + _chunk.page]) + (kz[index] * r[index - _chunk.page]))) / (((1.0 + (kx[index] + kx[index + 1])) + (ky[index] + ky[index + _chunk.x])) + (kz[index] + kz[index + _chunk.page]));\n      err += fabs(u[index] - r[index]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_jacobi_kernel/3"}
{"code": "for (int i = 0; i <= (n - 2); i++)\n{\n  if ((prime[i] > k) && (prime[i] != (-1)))\n  {\n    k = prime[i];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac1/SeiveOfEratosthenesBoth/2"}
{"code": "for (int i = 1; i <= max; i++)\n{\n  for (int j = 1; j <= max; j++)\n    printf(\"%d -> (%d, %d)\\n\", omp_get_thread_num(), i, j);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/irajeshegde/OMP-Programs/4.nestedparallelfor/0"}
{"code": "for (i = 0; i < (s + 2); i++)\n  for (j = 0; j < (s + 2); j++)\n  filter->array[i][j] /= filter->sum;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/filter_OMP/6"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    aMatr3[wI][wJ] = 0;\n    for (wK = 0; wK < SMALLN_MATR; wK += 2)\n    {\n      wTemp[0] = aMatr2[wK][wJ];\n      wTemp[1] = aMatr2[wK + 1][wJ];\n      wTemp[2] = aMatr2[wK + 2][wJ];\n      wTemp[3] = aMatr2[wK + 3][wJ];\n      wV1 = _mm_load_pd(&aMatr1[wI][wK]);\n      wV2 = _mm_load_pd(wTemp);\n      wV3 = _mm_dp_pd(wV1, wV2, 0xFF);\n      _mm_store_pd(wTemp, wV3);\n      aMatr3[wI][wJ] += wTemp[0];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/6"}
{"code": "for (i = 0; i < o; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrixB[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekaryaREPO/Concurrent-Programming-with-Java-and-OpenMP/ASSIGNMENT 2-OpenMP/SOURCE CODE AND EXECUTABLES/MatrixMultiplicationUsingThreads/2"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_updating_graph_mask[tid] == 1)\n  {\n    h_graph_mask[tid] = 1;\n    h_graph_visited[tid] = 1;\n    stop = 1;\n    h_updating_graph_mask[tid] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bfs-omp/bfs/1"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = forcing[i][j][k][m];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/72"}
{"code": "for (int i = z; i < (z + 8); i++)\n{\n  x += a[i];\n  *b += a[i] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/task-reduction-8/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  scanf(\"%d\", &q[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/10"}
{"code": "for (i = 0; i < num_particles; i++)\n{\n  particle_t *particle = &particles[i];\n  particle->x_pos = (((rand() % max_resolution) - (max_resolution / 2)) * 2.0) / max_resolution;\n  particle->y_pos = (((rand() % max_resolution) - (max_resolution / 2)) * 2.0) / max_resolution;\n  particle->x_vel = particle->y_pos;\n  particle->y_vel = particle->x_pos;\n  particle->mass = 1.0 + ((num_particles + i) / total_particle);\n  particle->node = 0;\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kawtar921/nbody/nbody_omp/nbody_tools/4"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  printf(\"[%d] \", pos->_Cases[1][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/3"}
{"code": "for (index = 0; index < count; index += inc)\n{\n  SHA_CTX ctx;\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  SHA1_Update(&ctx, (unsigned char *) saved_salt->data.c, saved_salt->len);\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/salted_sha1_fmt_plug/0"}
{"code": "for (index = 0; index < 100; ++index)\n{\n  sub(a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chivier/ompfuns/bottom/collapse/1"}
{"code": "for (int i = 0; i < nb_inter_sol; i++)\n{\n  if (s->schedule[i].nb < 1)\n  {\n    fprintf(stderr, \"intersection has no light (%d)\\n\", i);\n  }\n\n  for (int feu = 0; feu < s->schedule[i].nb; feu++)\n  {\n    const int rue = s->schedule[i].t[feu].rue;\n    const char * const name = street_table_find_name(p->table, rue);\n    if (rue >= nb_streets)\n    {\n      fprintf(stderr, \"invalid street number (%d -> \\\"%s\\\")\\n\", rue, name);\n      errors++;\n    }\n\n    int rid;\n    for (rid = 0; rid < nb_streets; rid++)\n    {\n      if (p->r[rid].street_id == rue)\n        break;\n\n    }\n\n    if (p->r[rid].end != i)\n    {\n      fprintf(stderr, \"invalid street number (%d -> \\\"%s\\\"): not arriving to the intersection %d\\n\", rue, name, i);\n      errors++;\n    }\n\n    if (s->schedule[i].t[feu].duree <= 0)\n    {\n      fprintf(stderr, \"invalid schedule length (intersection %d light %d -> %d)\\n\", i, feu, s->schedule[i].t[feu].duree);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chalearm/OpenMPApp/TrafficSignaling/solution_check/2"}
{"code": "for_epilog = make(omp_for_environment.shallow_copy(), loop_context.shallow_copy(), omp_for.get_locus())\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/simd/tl-omp-simd-visitor/6"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    A[(i * 512) + j] = (((DATA_TYPE) i) * j) / 512;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/3MM/src/3mm/0"}
{"code": "for (int j = 0; j < 256; j++)\n  fftwf_execute_dft(p1d, (fftwf_complex *) in_fftw[k][j][0], (fftwf_complex *) in_fftw[k][j][0]);\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adriacabeza/PAR/LAB1/Codes/3dfft_omp/2"}
{"code": "for (int step = 0; step < conf.nsteps; step++)\n{\n  for (int src = 0; src < conf.nsrcs; src++)\n  {\n    if (conf.srcs[src].t > step)\n      continue;\n\n    int src_offset = POINT_OFFSET(conf.srcs[src].x, conf.srcs[src].y, 0, dimy, dimx, conf.radius);\n    curr[src_offset] = srcs[src][step];\n  }\n\n  fwd(next, curr, vsq, c_coeff, conf.nx, conf.ny, conf.nz, dimx, dimy, dimz, conf.radius);\n  TYPE *tmp = next;\n  next = curr;\n  curr = tmp;\n  update_progress(step + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ijpq/15418/utils/opencv/CodeSamples/lectures_code/iso/src/iso3d/1"}
{"code": "for (iterator iter = parents.begin(); iter != parents.end(); ++iter)\n{\n  if (parentName.compare(*iter) == 0)\n  {\n    parents.erase(iter);\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alacroix/distributed-makefile/src/Rule/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  a = omp_get_thread_num();\n  (rand() % 11) + 10;\n  printf(\"Thread %d a=%d\\n\", omp_get_thread_num(), a);\n}\n\n", "pragma": "omp parallel for lastprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7/2"}
{"code": "for (i = 0; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    switch (world_indexer[i][j].type)\n    {\n      case 1:\n        printf(\"%d %d %c\\n\", i, j, 's');\n        break;\n\n      case 2:\n        printf(\"%d %d %c\\n\", i, j, 'w');\n        break;\n\n      case 3:\n        printf(\"%d %d %c\\n\", i, j, 't');\n        break;\n\n      case 4:\n        printf(\"%d %d %c\\n\", i, j, 'i');\n        break;\n\n      case 5:\n        printf(\"%d %d %c\\n\", i, j, '$');\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfcorreia/squirrels/src/wolves-squirrels-omp/3"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    double suma_parcial = 0;\n    for (k = 0; k < N; k++)\n    {\n      suma_parcial += AB[(i * N) + k] * C[(j * N) + k];\n    }\n\n    D[(i * N) + j] = suma_parcial;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/pruebas/5-for/4"}
{"code": "for (int i = 0; i < no_points; i++)\n{\n  points[i][0] = rand() % max;\n  points[i][1] = rand() % max;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/0"}
{"code": "for (int i = 0; i < (height + 2); i++)\n{\n  if ((i == 0) || (i == (width + 1)))\n  {\n    for (int j = 0; j < (width + 2); j++)\n      results[(i * (width + 2)) + j] = 0;\n\n  }\n  else\n  {\n    results[i * (width + 2)] = 0;\n    results[(i * (width + 2)) + (width + 1)] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeorgeMitrakis/raw_image_blur/project_hybrid/1"}
{"code": "for (i = 0; i < g->nvertices; i++)\n  mH->array[i] = newMHN(i, 10000000);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cathy272272272/Dijkstra/OpenMP/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  cout << i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiuwenhui/openmp_examples/example1/for/openmpfor/0"}
{"code": "for (unsigned i = 0; i <= MAX; i++)\n{\n  factorialTable[i] = factorial(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joeladams/patternlets/patternlets/openMP/10.parallelLoop-dynamicSchedule/dynamicScheduling/1"}
{"code": "for (i3 = 1; i3 < e3; i3++)\n{\n  x1 = starts[i3];\n  for (i2 = 1; i2 < e2; i2++)\n  {\n    xx = x1;\n    vranlc(d1, &xx, a, &z[i3][i2][1]);\n    rdummy = randlc(&x1, a1);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i2,i3,x1,xx,rdummy) shared(e2,e3,d1,a1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/3"}
{"code": "for (int i = 0; i < NUM_OF_TASKS; i++)\n{\n  min_elem_in_task[i] = min;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalgoyall/ParallelMatrixMult/Competition/main/0"}
{"code": "for (m = 0; m < 4; m++)\n{\n  for (i = 0; i < 3; i++)\n  {\n    sum[i] = 0.0;\n    for (j = 0; j < 3; j++)\n      sum[i] = sum[i] + (jacobian[j][i] * ds[j][m]);\n\n  }\n\n  for (i = 0; i < 3; i++)\n    ds[i][m] = sum[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/13"}
{"code": "for (int z = 0; z < ((sizeof(lines)) / (sizeof(*lines))); z++)\n{\n  int ln = 0;\n  taksir = lines[z];\n  while (m != taksir.size())\n  {\n    r = taksir.substr(y, 1);\n    y++;\n    m++;\n    if (((((r == \"a\") || (r == \"c\")) || (r == \"t\")) || (r == \"g\")) || (r == \"u\"))\n    {\n      if (ln < 3)\n      {\n        codon += r;\n        if (ln == 2)\n        {\n          codons[k] = codon;\n          k++;\n          ln = -1;\n          codon = \"\";\n        }\n\n        ln++;\n      }\n\n    }\n\n  }\n\n  m = 0;\n  y = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ayman1231/translate-a-gene-into-codons-using-OpenMP/Lab1q2/2.main/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i][j + 1][k] = lhs[0][i][j + 1][k] + comz1;\n    lhs[1][i][j + 1][k] = lhs[1][i][j + 1][k] - comz4;\n    lhs[2][i][j + 1][k] = lhs[2][i][j + 1][k] + comz5;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/30"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  tmp[i * 2] = (*pI2PQ)[i].index1();\n  tmp[(i * 2) + 1] = (*pI2PQ)[i].index2();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD_Parallel/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  float x = a[i];\n  float value = x;\n  float num = (x * x) * x;\n  float denom = 6;\n  int sign = -1;\n  for (int j = 1; j <= terms; ++j)\n  {\n    value += (sign * num) / denom;\n    num *= x * x;\n    denom *= ((2 * j) + 2) * ((2 * j) + 3);\n    sign *= -1;\n  }\n\n  b[i] = value;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/openmp/1"}
{"code": "for (long i = 0; i < (512 * 5000); i++)\n{\n  int rank = omp_get_thread_num();\n  data[i] = rank;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/big/0"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  for (j = 0; j < 2000; j++)\n  {\n    A[i][j] = rand() % 10;\n    B[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tantatorn-dev/OpenMP-playground/main/1"}
{"code": "for (unsigned int idx = 0; idx < 1024; idx++)\n  ap[idx] = bp[idx];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr68640/0"}
{"code": "for (i = 0; i <= lenA; ++i)\n{\n  SWArray[0][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/8"}
{"code": "for (i = 0; i < 102400; i++)\n{\n  sum += vecC[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/hybrid-openmp-mpi/work-sharing/solution/vector-addition/2"}
{"code": "for (unsigned int i = 0; i < ((2048 / 5) + 2); i++)\n  grn[i] = gst[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/13"}
{"code": "for (i = 0; i < (input->d - 1); i++)\n  printf(\"%f,\", input->xh[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/14"}
{"code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  fscanf(fcfg, \"%lf\", &simu_opts->DEFD[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/45"}
{"code": "for (int i = 1; i < THREADS; i++)\n{\n  rgb_table[i][0] = (rand() % 254) + 100;\n  rgb_table[i][1] = (rand() % 254) + 100;\n  rgb_table[i][2] = (rand() % 254) + 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cheshie/ParallelComputing/mandelbrot_omp/1"}
{"code": "for (int a = 0; a < r; a++)\n{\n  for (int b = 0; b < c; b++)\n  {\n    image.read(&temp, 1);\n    mat[a][b] = temp;\n  }\n\n  image.read(&temp, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a[j] += b[j];\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for reduction(+:a[0:N]) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_array/reduction_array/2"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (j_imopVar111 = 1; j_imopVar111 < (grid_points[1] - 1); j_imopVar111++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * (((u[i_imopVar110][j_imopVar111][k_imopVar112 - 2][m_imopVar113] - (4.0 * u[i_imopVar110][j_imopVar111][k_imopVar112 - 1][m_imopVar113])) + (6.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113])) - (4.0 * u[i_imopVar110][j_imopVar111][k_imopVar112 + 1][m_imopVar113])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/25"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  double **sample_outputs = layer_outputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = sample_outputs[l - 1];\n    double *output = sample_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU1/0"}
{"code": "for (int i = 0; i < V; i++)\n{\n  for (int j = 0; j < V; j++)\n  {\n    if (dist[i][j] == 9999)\n      printf(\"%s   \", \"INF\");\n    else\n      printf(\"%d     \", dist[i][j]);\n\n    if (j == (V - 1))\n    {\n      printf(\"\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic,chunk) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sneha711/OpenMP/floyd_parallel/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  cast_perm->vec_[i] = (this->nrow_ - tmp_perm.vec_[i]) - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/80"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NL; j++)\n  {\n    if (percentDiff(G[(i * NL) + j], G_outputFromGpu[(i * NL) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3MM/3mm/7"}
{"code": "for (i = k + 1; i < N; i++)\n{\n  for (j = k + 1; j < N; j++)\n    A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n\n}\n\n", "pragma": "omp parallel for num_threads(NUMB_CORES) schedule(dynamic, chunksize) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/gaussian_openmp/1"}
{"code": "for (int k = 0; k < 2; k++)\n{\n  for (int j = 0; j < processes; j++)\n  {\n    dataType > v;\n    buckets[k].push_back(v);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashwinikumar2/Parallel-Merge-Quick-and-Radix-Sort-using-OpenMP/sort/6"}
{"code": "for (int sample = 1; sample <= nTraining; ++sample)\n{\n  input();\n  int nIterations = learning_process();\n  ((((((report << \"Sample \") << sample) << \": No. iterations = \") << nIterations) << \", Error = \") << square_error()) << endl;\n  if ((sample % 100) == 0)\n  {\n    (((cout << \"Saving the network to \") << model_fn) << \" file.\") << endl;\n    write_matrix(model_fn);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/23"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n    printf(\"%6.2f   \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Dynamic/main/4"}
{"code": "for (int i = 0; i < max_card; i++)\n{\n  (((debug_out << pnts[2 * result[i]]) << \" \") << pnts[(2 * result[i]) + 1]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qtclustering-omp/QTC/8"}
{"code": "for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  for (i = 0; i < 128; i += 2)\n  for (j = 0; j < 128; j++)\n{\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n  C[k][l] += 0.5 * ((A[l][i + 1][j] * B[k][i + 1][j]) + (A[k][i + 1][j] * B[l][i + 1][j]));\n}\n\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-unr-2i/0"}
{"code": "for (int i = 1; i < n; i++)\n  if (min_of_lines[i] > mx)\n  mx = min_of_lines[i];\n\n\n", "pragma": "        #pragma omp parallel for reduction(max:mx)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/maxmin/2"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  Normal = rGeometry[i].FastGetSolutionStepValue(NORMAL);\n  double NormNormal = norm_2(Normal);\n  if (NormNormal != 0)\n    Normal /= NormNormal;\n\n  Shrink = rGeometry[i].FastGetSolutionStepValue(SHRINK_FACTOR);\n  Normal *= Shrink * rOffsetFactor;\n  Vertex = rGeometry[i].Coordinates() - Normal;\n  Vertices.push_back(Vertex);\n  Center += Vertex;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/7"}
{"code": "for (int i = 0; i < 16384; i++)\n{\n  tmp[i] = 0;\n  for (int j = 0; j < 16384; j++)\n  {\n    tmp[i] += A[(i * 16384) + j] * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/ATAX/atax/0"}
{"code": "for (int i = 0; i < outputMembers.size(); ++i)\n{\n  const double res = outputMembers[i](vIn);\n  value += res * singletonValues[i];\n  members += res;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kuszki/PI-Parallel-Fuzzy-Example/fuzzyalgorithm/3"}
{"code": "for (int32_t u = 3; u < (D_width - 3); u++)\n{\n  for (int32_t v = 0; v < 3; v++)\n    val[v] = *((D_tmp + (v * D_width)) + u);\n\n  for (int32_t v = 3; v < D_height; v++)\n  {\n    float val_curr = *((D_tmp + ((v - 1) * D_width)) + u);\n    val[v % 4] = *((D_tmp + (v * D_width)) + u);\n    xval = _mm_load_ps(val);\n    xweight1 = _mm_sub_ps(xval, _mm_set1_ps(val_curr));\n    xweight1 = _mm_and_ps(xweight1, xabsmask);\n    xweight1 = _mm_sub_ps(xconst4, xweight1);\n    xweight1 = _mm_max_ps(xconst0, xweight1);\n    xfactor1 = _mm_mul_ps(xval, xweight1);\n    _mm_store_ps(weight, xweight1);\n    _mm_store_ps(factor, xfactor1);\n    float weight_sum = ((weight[0] + weight[1]) + weight[2]) + weight[3];\n    float factor_sum = ((factor[0] + factor[1]) + factor[2]) + factor[3];\n    if (weight_sum > 0)\n    {\n      float d = factor_sum / weight_sum;\n      if (d >= 0)\n        *((D + ((v - 1) * D_width)) + u) = d;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/27"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/27"}
{"code": "for (i = 0; i < source->size; i++)\n{\n  destination->tab[(destination->size - i) - 1] = source->tab[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/5"}
{"code": "for (int i = 0; i < cant; i++)\n{\n  random = rand();\n  arreglo[i] = random;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dess96/Paralela-openmp/Labs cortos/Ejercicio 3/Source/0"}
{"code": "for (unsigned int i = DIMEN; i--; ret += powf64(coord.ref[i], 2.0) - cos((M_PI * 2.0) * coord.ref[i]))\n  for (unsigned int j = 1000; j--; ret += 0.01)\n  ;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/imhele/pso-openmp/main/2"}
{"code": "for (int i = mpiBegin; i < mpiEnd; i++)\n{\n  lIA[i - mpiBegin] = 0;\n  lIA[(i + 1) - mpiBegin] = 0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maqayum/Hybrid/main/0"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  for (size_t j = 0; j < row; j++)\n  {\n    offspring[i].benefit += atof(content[(j * column) + 3].c_str()) * (offspring[i].binaryValue[j] - '0');\n    offspring[i].cost += (atof(content[(j * column) + 1].c_str()) * 586.0) * (offspring[i].binaryValue[j] - '0');\n  }\n\n  offspring[i].fitnessValue = offspring[i].benefit;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/11"}
{"code": "for (int i = 0; i < 1000; i++)\n  Centers[indexOfCenterToChange][i] = Vectors[currentVec][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/2. K-means with OpenMP/kmeans12/5"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < M; j++)\n  ref[i][j] += a[i] + b[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/8"}
{"code": "for (int y = 0; y < new_mat.get_height(); ++y)\n{\n  for (int x = 0; x < new_mat.get_width(); ++x)\n  {\n    const int val = ((((((((mat.get(y - 2, x - 2, repeat) << 8) | (mat.get(y - 2, x - 1, repeat) << 7)) | (mat.get(y - 2, x - 0, repeat) << 6)) | (mat.get(y - 1, x - 2, repeat) << 5)) | (mat.get(y - 1, x - 1, repeat) << 4)) | (mat.get(y - 1, x - 0, repeat) << 3)) | (mat.get(y - 0, x - 2, repeat) << 2)) | (mat.get(y - 0, x - 1, repeat) << 1)) | (mat.get(y - 0, x - 0, repeat) << 0);\n    new_mat.set(y, x, data.alg[val]);\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/willkill07/AdventOfCode2021/days/Day20/0"}
{"code": "for (j = *n; j >= 1; --j)\n{\n  if ((*alpha) != 1.f)\n  {\n    i__1 = *m;\n    for (i__ = 1; i__ <= i__1; ++i__)\n    {\n      b[i__ + (j * b_dim1)] = (*alpha) * b[i__ + (j * b_dim1)];\n    }\n\n  }\n\n  i__1 = *n;\n  for (k = j + 1; k <= i__1; ++k)\n  {\n    if (a[k + (j * a_dim1)] != 0.f)\n    {\n      i__2 = *m;\n      for (i__ = 1; i__ <= i__2; ++i__)\n      {\n        b[i__ + (j * b_dim1)] -= a[k + (j * a_dim1)] * b[i__ + (k * b_dim1)];\n      }\n\n    }\n\n  }\n\n  if (nounit)\n  {\n    temp = 1.f / a[j + (j * a_dim1)];\n    i__1 = *m;\n    for (i__ = 1; i__ <= i__1; ++i__)\n    {\n      b[i__ + (j * b_dim1)] = temp * b[i__ + (j * b_dim1)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/25"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  for (j = 0; j < 8192; j++)\n  {\n    hz[(i * 8192) + j] = hz[(i * 8192) + j] - (0.7 * (((ex[(i * (8192 + 1)) + (j + 1)] - ex[(i * (8192 + 1)) + j]) + ey[((i + 1) * 8192) + j]) - ey[(i * 8192) + j]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/FDTD-2D/fdtd2d_cpu/12"}
{"code": "for (unsigned int i = 0; i < basic_agent_list.size(); i++)\n{\n  basic_agent_list[i]->simulate_secretion_and_uptake(this, dt);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/11"}
{"code": "for (int j = 0; j < k; j++)\n  supCentroids[j] = (float *) calloc(m, sizeof(float));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/10"}
{"code": "for (i = 1; i < n_subprobs; i++)\n{\n  res_offset = ((((int) (i / ((int) sqrt(n_subprobs)))) * subprob_size) * subprob_size) * ((int) sqrt(n_subprobs));\n  res_offset += (i % ((int) sqrt(n_subprobs))) * subprob_size;\n  MPI_Recv(res[0] + res_offset, 1, double_strided_vect, i, generic_tag, 1, (MPI_Status *) 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/14"}
{"code": "for (int i = 0; i < ((nPixX * nPixY) * nSlices); i++)\n  d_pVolume[i] = 0.0;\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/11"}
{"code": "for (int i = 0; i < k; i++)\n{\n  S[i] = Norm(V, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/77"}
{"code": "for (i = 0; i < size; i = i + 7)\n{\n  fscanf(fp, \"%f %f %f %f %f %f %f\", &data[i], &data[i + 1], &data[i + 2], &data[i + 3], &data[i + 4], &data[i + 5], &data[i + 6]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/0"}
{"code": "for (size_t i = 0; i < N; ++i)\n  D[i] = A[i] * B[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shuibitianantian/Arbitrary-FFT/openmp/fft/14"}
{"code": "for (i = 0; i < lines; i++)\n{\n  realCoord = positiveReal;\n  for (j = 0; j < columns; j++)\n  {\n    iterations = 0;\n    realTemp = realCoord;\n    imagTemp = imagCoord;\n    arg = (realCoord * realCoord) + (imagCoord * imagCoord);\n    while ((arg < 4) && (iterations < 40))\n    {\n      realTemp2 = ((realTemp * realTemp) - (imagTemp * imagTemp)) - realCoord;\n      imagTemp = ((2 * realTemp) * imagTemp) - imagCoord;\n      realTemp = realTemp2;\n      arg = (realTemp * realTemp) + (imagTemp * imagTemp);\n      iterations += 1;\n    }\n\n    if (drawToConsole)\n    {\n      switch (iterations % 4)\n      {\n        case 0:\n          image[(i * columns) + j] = '.';\n          break;\n\n        case 1:\n          image[(i * columns) + j] = 'o';\n          break;\n\n        case 2:\n          image[(i * columns) + j] = '0';\n          break;\n\n        case 3:\n          image[(i * columns) + j] = '@';\n          break;\n\n      }\n\n    }\n\n    realCoord = positiveReal - ((j + 1) * realStep);\n  }\n\n  imagCoord = positiveImaginary - ((i + 1) * imaginaryStep);\n}\n\n", "pragma": "        #pragma omp parallel for private(i,j,realCoord,imagCoord,realTemp,imagTemp,realTemp2,arg,iterations) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pterolex/MandelbrotConsole/mandelbrot_openmp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  (cout << result[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_multiplication/Q4/3"}
{"code": "for (int ii = 1; ii < (params.ny - 1); ++ii)\n{\n  cells[(ii * params.nx) + line].speeds[5] = recvbuf[(ii - 1) * 3];\n  cells[(ii * params.nx) + line].speeds[1] = recvbuf[((ii - 1) * 3) + 1];\n  cells[(ii * params.nx) + line].speeds[8] = recvbuf[((ii - 1) * 3) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/17"}
{"code": "for (i = 1; i <= nodesCount; ++i)\n{\n  for (j = 1; j <= nodesCount; ++j)\n  {\n    if (((distance[i][k] != NOT_CONNECTED) && (distance[k][j] != NOT_CONNECTED)) && ((distance[i][j] == NOT_CONNECTED) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n    {\n      distance[i][j] = distance[i][k] + distance[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) private(i, j) num_threads(numthreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harisrkhan7/FloydWarshallAlgorithmParallelisation/notdynamic_fw_in/0"}
{"code": "for (int i = 0; i < image_buffer_size; i++)\n{\n  fwrite(image_buffer[i], 1, 3, file);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP1/src/mandelbrot_omp/2"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      lhs[(5 * n) + 2][i][j][k] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,n )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/50"}
{"code": "for (class_i = 0; class_i < class_n; class_i++)\n{\n  centroids[class_i].x /= count[class_i];\n  centroids[class_i].y /= count[class_i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/7ogic/K-means/kmeans_mpi_openmp/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 1; j < m; j++)\n    b[i][j] = (i * m) + j;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB037-truedepseconddimension-orig-yes/0"}
{"code": "for (intptr_t i = 0; i < size; i++)\n{\n  scalar_product += ((long long int) vector1[i]) * vector2[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:scalar_product) num_threads(t_value)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alamart1683/openmp-scalar-product/pp_lr2/pp_lr2/pp_lr2/3"}
{"code": "for (int i = 0; i < 992; i++)\n  for (int j = 0; j < 992; j++)\n  S[(i * 992) + j] += T[(i * 992) + j] + U[(i * 992) + j];\n\n\n", "pragma": "omp distribute parallel for simd collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-dpfs-dist-clauses/test/4"}
{"code": "for (int i = 0; i < num_threads; i++)\n{\n  long long window_value = 0;\n  long long msd = 1;\n  for (int j = 0; j < k; j++)\n  {\n    window_value *= 4;\n    window_value += value(line[(i * read) + j]);\n    msd *= 4;\n  }\n\n  msd /= 4;\n  while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n  {\n    ;\n  }\n\n  for (int j = (i * read) + 1; j < min((i + 1) * read, (len_line - k) + 1); j++)\n  {\n    window_value -= value(line[j - 1]) * msd;\n    window_value *= 4;\n    window_value += value(line[(j + k) - 1]);\n    while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n    {\n      ;\n    }\n\n  }\n\n  if (i == (num_threads - 1))\n  {\n    for (int j = min((i + 1) * read, (len_line - k) + 1); j < ((len_line - k) + 1); j++)\n    {\n      window_value -= value(line[j - 1]) * msd;\n      window_value *= 4;\n      window_value += value(line[(j + k) - 1]);\n      while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n      {\n        ;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atharva1707/K-mer-counting-using-Bloom-filter/main/1"}
{"code": "for (j = 0; j < 4; j++)\n{\n  id = omp_get_thread_num();\n  printf(\"[Thread_%d] (i,j)=(%d,%d)\\n\", id, i, j);\n}\n\n", "pragma": "            #pragma omp for        ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AdityaNG/OpenMP_Notes/src/ex4/0"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/CombinedParallelLoopReduction/0"}
{"code": "for (int i = 0; i < TOP_X; i++)\n{\n  int randIndex;\n  randIndex = rand() % 100;\n  if (randIndex < MUTATE_RATE)\n  {\n    int temp;\n    int randIndexGene1;\n    randIndexGene1 = rand() % CITIES;\n    int randIndexGene2;\n    randIndexGene2 = rand() % CITIES;\n    while (randIndexGene1 == randIndexGene2)\n      randIndexGene2 = rand() % CITIES;\n\n    temp = offsprings[i].itinerary[randIndexGene1];\n    offsprings[i].itinerary[randIndexGene1] = offsprings[i].itinerary[randIndexGene2];\n    offsprings[i].itinerary[randIndexGene2] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stahtews/TravellingSalesman-GeneticAlgorithm-OpenMp/tsp/0"}
{"code": "for (i = 0; i < 30; i++)\n{\n  a[i] = randomInt(i + 2, ((i + 3) * i) * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task10/0"}
{"code": "for (int i = 0; i < 2; ++i)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int i = 0; i < 2; ++i)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  for (int j = 0; j < 2; ++j)\n  foo();\n\n\n\n\n\n\n\n\n\n\n", "pragma": "#pragma omp for private(argc, b), firstprivate(c, d), lastprivate(d, f) collapse(N) schedule(static, N) ordered(N) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_ast_print/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = malloc(N * (sizeof(double)));\n  b[i] = malloc(N * (sizeof(double)));\n  c[i] = malloc(N * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/matrix_mulitply/omp_mm/1"}
{"code": "for (i = 0; i < Size; i++)\n{\n  for (j = 0; j < Size; j++)\n    printf(\"%7.4f \", pMatrix[(i * Size) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savinaDaria/Cramer_rule_OpenMP/lab2OpenMP/lab2OpenMP/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/14"}
{"code": "for (i = 0; i < ((3 * topoinfo->numR) + (2 * topoinfo->numG)); i++)\n{\n  fprintf(f_p, \"\\t%f\", tmprlt->paras[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/56"}
{"code": "for (int i = 0; i < m->nrows; ++i)\n  for (int j = 0; j < m->ncols; ++j)\n  TERRAIN(m, i, j) = 0;\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/main/0"}
{"code": "for (int p = 0; p < total_points_cluster; p++)\n  sum += clusters[i].getPoint(p).getValue(j);\n\n", "pragma": "\t\t\t\t\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gstangel/IT388_k_means/kmeans_parallel/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    D[(i * 1024) + j] = (((DATA_TYPE) i) * (j + 2)) / 1024;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/2MM/src/2mm/3"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/15"}
{"code": "for (idx = 0; idx < count; idx += 1)\n{\n  SHA512_CTX ctx;\n  uint32_t i;\n  uint32_t len = strlen(saved_plain[idx]);\n  unsigned char tmp[23 + 48];\n  unsigned char *cp = &tmp[len];\n  SHA384_Init(&ctx);\n  SHA384_Update(&ctx, saved_plain[idx], len);\n  SHA384_Update(&ctx, sapH_cur_salt->s, sapH_cur_salt->slen);\n  strcpy((char *) tmp, saved_plain[idx]);\n  len += 48;\n  SHA384_Final(cp, &ctx);\n  for (i = 1; i < sapH_cur_salt->iter; ++i)\n  {\n    SHA384_Init(&ctx);\n    SHA384_Update(&ctx, tmp, len);\n    SHA384_Final(cp, &ctx);\n  }\n\n  memcpy(crypt_key[idx], cp, 16);\n}\n\n", "pragma": "omp parallel for default(none) private(idx) shared(count, sapH_cur_salt, saved_plain, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/8"}
{"code": "for (int i = 2; i <= n; i++)\n{\n  if (primes[i] == 0)\n  {\n    printf(\"%d\\n\", i);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/prime/prime/2"}
{"code": "for (register int i = 0; i < m; i += 4)\n{\n  for (register int j = 0; j < n; ++j)\n  {\n    register float *a0p = &a[(i * lda) + 0];\n    register float *a1p = &a[((i + 1) * lda) + 0];\n    register float *a2p = &a[((i + 2) * lda) + 0];\n    register float *a3p = &a[((i + 3) * lda) + 0];\n    register float bp0 = b[(0 * ldb) + j];\n    for (register int p = 0; p < k; ++p)\n    {\n      c[(i * ldc) + j] += (*a0p) * bp0;\n      c[((i + 1) * ldc) + j] += (*a1p) * bp0;\n      c[((i + 2) * ldc) + j] += (*a2p) * bp0;\n      c[((i + 3) * ldc) + j] += (*a3p) * bp0;\n      ++a0p;\n      ++a1p;\n      ++a2p;\n      ++a3p;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/mat_mult/mat_mult/0"}
{"code": "for (i = 0; i < l; i++)\n  b[i] = (double *) calloc(m, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vandy225/matrix_matrix_parallel/threading/12"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    ptrmatrixB[i][j] = ptrarrayB[(i * N) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/OMPmultMatrices/OMPmultMatrices/OMPmultMatrices/3"}
{"code": "for (it = 0; (timePOI[it] != (-1)) && (it < NtPOI); it++)\n{\n  fprintf(fp, \"%6.2f\", ((double) timePOI[it]) / 60);\n  for (n = 0; n < NPOIs; n++)\n    fprintf(fp, \" %7.3f\", sshPOI[n][it]);\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/20"}
{"code": "for (currentRow = 2; currentRow < subProblemSize[0]; ++currentRow)\n{\n  splitter[0][tempCounter] = currentRow;\n  splitter[1][tempCounter++] = subProblemSize[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/10"}
{"code": "for (i = 0; i < nr_centroids; i++)\n{\n  for (j = 0; j < (dimensions - 1); j++)\n  {\n    fprintf(f_out, \"%lf, \", centroids[(i * dimensions) + j]);\n  }\n\n  fprintf(f_out, \"%lf\\n\", centroids[((i * dimensions) + dimensions) - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/12"}
{"code": "for (unsigned int i = 0; i != vector_size; ++i)\n{\n  neighbours[i]->GetSolutionStepValue(FLUID_FRACTION) += weights[i] * solid_volume;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/13"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/82"}
{"code": "for (unsigned long i = 0; i < tiles.size(); ++i)\n{\n  RenderTile(tiles[i], cam, world, ns);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adamleighfish/c3po/src/c3p0/1"}
{"code": "for (i = 0; i < dataSet.m; i++)\n{\n  for (j = 0; j < dataSet.n; j++)\n  {\n    dataSet.C[(i * dataSet.m) + j] = dataSet.A[(i * dataSet.m) + j] + dataSet.B[(i * dataSet.m) + j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) shared(dataSet) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZahraY10/Parallel-Programming-OpenMP/Lab 2/lab2/codes/parallel/matadd(column) /0"}
{"code": "for (i = 0; i < leaf_counter; i++)\n{\n  leaf[i].start = B_counter;\n  for (j = 0; j < leaf[i].n; j++)\n  {\n    B[B_counter][0] = A[leaf[i].points[j]][0];\n    B[B_counter][1] = A[leaf[i].points[j]][1];\n    B[B_counter][2] = A[leaf[i].points[j]][2];\n    B_counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikos912000/octree-partitioning/octree_openmp/octree_openmp/5"}
{"code": "for (i = 0; i < nlmo; i++)\n{\n  (*observations)[i][0] += rand() * sqrt(R[0][0]);\n  (*observations)[i][1] += rand() * sqrt(R[1][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/6"}
{"code": "for (i = ib * Bsize; i < ((ib + 1) * Bsize); i++)\n{\n  for (j = jb * Bsize; j < ((jb + 1) * Bsize); j++)\n  {\n    for (k = kb * Bsize; k < ((kb + 1) * Bsize); k++)\n    {\n      *(C + ((i * Mdim) + j)) += Awrk[((i % Bsize) * Bsize) + (k % Bsize)] * Bwrk[((k % Bsize) * Bsize) + (j % Bsize)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/mm_gpu_block/2"}
{"code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 250; j++)\n  {\n    hz[(i * 250) + j] = hz[(i * 250) + j] - (0.7 * (((ex[(i * (250 + 1)) + (j + 1)] - ex[(i * (250 + 1)) + j]) + ey[((i + 1) * 250) + j]) - ey[(i * 250) + j]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/28"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  omp_init_lock(&hist_locks[i]);\n  hist[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram_omp/0"}
{"code": "for (I = Cap->capture_begin(), J = Cap->capture_init_begin(); (I != Cap->capture_end()) && (J != Cap->capture_init_end()); ++I, ++J)\n{\n  Captures.push_back(*I);\n  CaptureInits.push_back(*J);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/6"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c8 = 0; c8 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c8++)\n  {\n    for (c9 = (1 > (16 * c8)) ? (1) : (16 * c8); c9 <= ((((16 * c8) + 15) < (n + (-1))) ? ((16 * c8) + 15) : (n + (-1))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        B[c9][c15] = B[c9][c15] - ((A[c9][c15] * A[c9][c15]) / B[c9 - 1][c15]);\n      }\n\n    }\n\n  }\n\n  for (c8 = 0; c8 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c8++)\n  {\n    for (c9 = (1 > (16 * c8)) ? (1) : (16 * c8); c9 <= ((((16 * c8) + 15) < (n + (-1))) ? ((16 * c8) + 15) : (n + (-1))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        X[c9][c15] = X[c9][c15] - ((X[c9 - 1][c15] * A[c9][c15]) / B[c9 - 1][c15]);\n      }\n\n    }\n\n  }\n\n  for (c8 = 0; c8 <= ((((n + (-3)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-3))) + 16) + 1) / 16)) : (-((((-(n + (-3))) + 16) - 1) / 16))) : ((n + (-3)) / 16)); c8++)\n  {\n    for (c9 = 16 * c8; c9 <= ((((16 * c8) + 15) < (n + (-3))) ? ((16 * c8) + 15) : (n + (-3))); c9++)\n    {\n      for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n      {\n        X[(n - 2) - c9][c15] = (X[(n - 2) - c9][c15] - (X[(n - c9) - 3][c15] * A[(n - 3) - c9][c15])) / B[(n - 2) - c9][c15];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2 ,c15 ,c9 ,c8 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/7"}
{"code": "for (i = 1; i <= j; i++)\n  n = i;\n\n", "pragma": "omp parallel for private(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/part1/2"}
{"code": "for (i = 0; i < NUM_PARTICLES; i++)\n{\n  float radius = 0.05f;\n  float initialElevation = -0.5f;\n  myParticleSystem[i].pInitial[0] = radius * cos(i * 0.5f);\n  myParticleSystem[i].pInitial[1] = initialElevation;\n  myParticleSystem[i].pInitial[2] = radius * sin(i * 0.5f);\n  myParticleSystem[i].alive = 0;\n  myParticleSystem[i].tInitial = RANDOM_RANGE(0, 10);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/biswajitcsecu/-Simulating-Particle-Effects-using-NVIDIA-Cg-Tool-Kits-and-OpenMP/main/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i * 1.0;\n  b[i] = i * 2.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/architkarandikar/OpenMP-Tutorial/Intro/Reduction/reduction_clause/1"}
{"code": "for (j = 0; j < filterSize; j++)\n{\n  blurArray[i][j] = ((double) (1 / (((M_PI * 2) * r) * r))) * exp(((fabs((filterSize / 2) - i) * fabs((filterSize / 2) - i)) * (-1.0)) / ((2 * r) * r));\n  div += blurArray[i][j];\n}\n\n", "pragma": "#pragma omp parallel for shared(blurArray)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/4"}
{"code": "for (i = 1; i <= (n - 1); i++)\n{\n  x = a + (i * h);\n  integral += f(x);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(a, h, n) private(i, x) reduction(+: integral) num_threads(thread_count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adamrotal/OpenMP/omp_trap/0"}
{"code": "for (i = 0; i < 25; i++)\n{\n  for (j = 0; j < 25; j++)\n  {\n    A[(i * 25) + j] = (((DATA_TYPE) i) * j) / 25;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GEMM/gemm/20"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    aMatr3[wI][wJ] = aMatr1[wI][wJ] + aMatr2[wI][wJ];\n  }\n\n}\n\n", "pragma": "omp parallel for private(wI, wJ)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/0"}
{"code": "for (j = 0; j < 50000000; j++)\n{\n  x[j] = j / 1003.01;\n  y[j] = setY(x[j]);\n}\n\n", "pragma": "omp parallel for default(none) shared(x, y) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/todemudia/OpenMPBestFit/data-bestFit/0"}
{"code": "for (int i = start; i < end; i++)\n  pivot = (abs(data[i].data[dim] - median) < abs(data[pivot].data[dim] - median)) ? (i) : (pivot);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erikalena/hpc_assignment2/src/sorting_data/3"}
{"code": "for (size_t whichPt = 0; whichPt < N_value; whichPt++)\n{\n  for (size_t count_k = 0; count_k < K_value; count_k++)\n  {\n    distance_sum_DIM = 0;\n    for (size_t whichDim = 0; whichDim < DIM_value; whichDim++)\n    {\n      distance_sum_DIM += pow(data.currentCentroids[count_k + (whichDim * data.K)] - data.pts[(whichPt * data.DIM) + whichDim], 2);\n    }\n\n    dis[whichPt][count_k] = distance_sum_DIM;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) default(none) firstprivate(distance_sum_DIM,DIM_value,K_value,N_value) shared(data,dis)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jimmy3769tw/K-meansClusteringAlgorithm_OpenCLandOpenMP/src/kmeansAOSp/2"}
{"code": "for (y = 1; y < IMG_H; y++)\n{\n  index = y * IMG_W;\n  for (x = 1; x < IMG_W; x++)\n  {\n    sum = (round(cdf_R[IObj->sR[index]] - minCdfValue_R) / ((2048 * 2048) - minCdfValue_R)) * 255;\n    sum = (sum > 255) ? (255) : ((sum < 0) ? (0) : (sum));\n    IObj->sR[index] = (unsigned) sum;\n    sum = (round(cdf_G[IObj->sG[index]] - minCdfValue_G) / ((2048 * 2048) - minCdfValue_G)) * 255;\n    sum = (sum > 255) ? (255) : ((sum < 0) ? (0) : (sum));\n    IObj->sG[index] = (unsigned) sum;\n    sum = (round(cdf_B[IObj->sB[index]] - minCdfValue_B) / ((2048 * 2048) - minCdfValue_B)) * 255;\n    sum = (sum > 255) ? (255) : ((sum < 0) ? (0) : (sum));\n    IObj->sB[index] = (unsigned) sum;\n    index++;\n  }\n\n}\n\n", "pragma": "    \t#pragma omp for schedule(dynamic,20) private(y,x,index,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/minyaho/Histogram-Equalization-by-OpenMP-and-OpenCL/code_files/code_file/5"}
{"code": "for (j = 0; j < MaxY; j++)\n{\n  for (i = 0; i < MaxX; i++)\n  {\n    if (!pJ->GetValue(i, j).isCond2D(CT_SOLID_2D))\n    {\n      num_active_nodes++;\n      pJ->GetValue(i, j).SetCond2D(CT_NODE_IS_SET_2D);\n      if (pJ->GetValue(i, j).isCond2D(CT_WALL_LAW_2D) || pJ->GetValue(i, j).isCond2D(CT_WALL_NO_SLIP_2D))\n      {\n        ij.SetXY(i, j);\n        pWallNodes->AddElement(&ij);\n      }\n\n    }\n\n  }\n\n  if (isPrint == 1)\n  {\n    ((((*f_str) << \"Scan \") << ((100 * j) / MaxY)) << \"% nodes\\r\") << flush;\n  }\n  else\n    if (isPrint == 2)\n  {\n    ((((*f_str) << \"Scan \") << ((100 * j) / MaxY)) << \"% nodes\\n\") << flush;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/9"}
{"code": "for (int i = 0; i < 2; ++i)\n{\n  vec[i] = t_var;\n  s_arr[i] = var;\n  sivar += i;\n}\n\n", "pragma": "#pragma omp for firstprivate(t_var, vec, s_arr, var, sivar)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_firstprivate_codegen/1"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float AB = 0.0;\n    for (int k = 0; k < K; k++)\n    {\n      AB += A[(i * K) + k] * B[(k * N) + j];\n    }\n\n    C[(i * M) + j] = (alpha * AB) + (beta * C[(i * M) + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elegaanz/MN-TP2/src/gemm/0"}
{"code": "for (i = 0; i < local_B->n_bar; i++)\n{\n  for (j = 0; j < local_B->n_bar; j++)\n    printf(\"%20.15E \", *((local_B->entries + (local_B->n_bar * j)) + i));\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/18"}
{"code": "for (i = 0; i < NGLOB; i++)\n{\n  var[i].accelx *= rmass_inverse[i];\n  var[i].accely *= rmass_inverse[i];\n  var[i].accelz *= rmass_inverse[i];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/specfem3d/aos-omp-for/specfem3D-omp-for/10"}
{"code": "for (i = 1; i < m; i++)\n  X[i] = (*X) + (n * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/1"}
{"code": "for (v = 0; v < G->numNodes; v++)\n{\n  edge_t u_idx;\n  edgeDistances[v] = 0;\n  for (u_idx = G->begin[v]; u_idx < G->begin[v + 1]; u_idx++)\n  {\n    node_t u = G->node_idx[u_idx];\n    edgeDistances[v] += abs(u - v);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/util/graphprop/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp25xpyhw0.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (j = 0; j < cache->assoc; j++)\n{\n  if (!getPLRU(&cache->cacheLines[i][j]))\n  {\n    victim = j;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/29"}
{"code": "for (int i = ProcessId * (size / 4); i < size; i++)\n{\n  result[i] = 0;\n  for (int j = i * size; j < ((i + 1) * size); j++)\n  {\n    result[i] += mat[j] * vector[j - (i * size)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmpi_calculate_matrix/src/Dong_ziqi/1"}
{"code": "for (int i = 0; i < number_of_data_entries; i++)\n{\n  fwrite((char *) (&mesh.voxels[i].center[0]), sizeof(double), 1, fp);\n  fwrite((char *) (&mesh.voxels[i].center[1]), sizeof(double), 1, fp);\n  fwrite((char *) (&mesh.voxels[i].center[2]), sizeof(double), 1, fp);\n  fwrite((char *) (&mesh.voxels[i].volume), sizeof(double), 1, fp);\n  for (unsigned int j = 0; j < (*p_density_vectors)[i].size(); j++)\n  {\n    fwrite((char *) (&(*p_density_vectors)[i][j]), sizeof(double), 1, fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/9"}
{"code": "for (long pidx_darts_counter_temp1014 = *pidx; (pidx_darts_counter_temp1014 < endRange) && (pidx_darts_counter_temp1014 < this->inputsTPParent->lastIteration1014); pidx_darts_counter_temp1014++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1014], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/36"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  vet[i] = matrix[(i * (dimension + 1)) + line];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giovaniortolani/Projeto2-ProgConc/src/gauss/7"}
{"code": "for (int j = 0; j < COLUMNS; j++)\n{\n  for (int i = 0; i < ROWS; i++)\n  {\n    float sum = 0.0;\n    for (int k = 0; k < COLUMNS; k++)\n    {\n      sum = sum + (matrix_a[i][k] * matrix_b[k][j]);\n    }\n\n    matrix_r[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/4"}
{"code": "for (a = 2; a <= (3 * N); a = next_prime(a))\n{\n  vmax = (int) (log(3.0f * N) / log(a * 1.0f));\n  if (a == 2)\n  {\n    vmax = vmax + (N - n);\n    if (vmax <= 0)\n      continue;\n\n  }\n\n  av = 1;\n  for (i = 0; i < vmax; i++)\n    av = av * a;\n\n  s = 0;\n  den = 1;\n  kq1 = 0;\n  kq2 = -1;\n  kq3 = -3;\n  kq4 = -2;\n  if (a == 2)\n  {\n    num = 1;\n    v = -n;\n  }\n  else\n  {\n    num = pow_mod(2, n, av);\n    v = 0;\n  }\n\n  for (k = 1; k <= N; k++)\n  {\n    t = 2 * k;\n    DIVN(t, a, v, -1, kq1, 2);\n    num = mul_mod(num, t, av);\n    t = (2 * k) - 1;\n    DIVN(t, a, v, -1, kq2, 2);\n    num = mul_mod(num, t, av);\n    t = 3 * ((3 * k) - 1);\n    DIVN(t, a, v, 1, kq3, 9);\n    den = mul_mod(den, t, av);\n    t = (3 * k) - 2;\n    DIVN(t, a, v, 1, kq4, 3);\n    if (a != 2)\n      t = t * 2;\n    else\n      v++;\n\n    den = mul_mod(den, t, av);\n    if (v > 0)\n    {\n      t = inv_mod(den, av);\n      t = mul_mod(t, num, av);\n      for (i = v; i < vmax; i++)\n        t = mul_mod(t, a, av);\n\n      t1 = (25 * k) - 3;\n      t = mul_mod(t, t1, av);\n      s += t;\n      if (s >= av)\n        s -= av;\n\n    }\n\n  }\n\n  t = pow_mod(5, n - 1, av);\n  s = mul_mod(s, t, av);\n  sum = fmod(sum + (((double) s) / ((double) av)), 1.0);\n  {\n    printf(\"%8d\\r\", a);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/an31146/source_code/pi/parallel_pi/1"}
{"code": "for (int g = 0; g < num_generaciones; g++)\n{\n  if (rank == 0)\n    fitness_anterior = poblacion[0].fitness;\n\n  int cruzarChunkSize = chunkSize / 2;\n  int cruzarLeftover = leftover / 2;\n  if (rank == 0)\n  {\n    for (int i = 0; i < cruzarLeftover; i += 2)\n    {\n      cruzar(&poblacion[i], &poblacion[i + 1], &poblacion[(cruzarLeftover / 2) + i], &poblacion[((cruzarLeftover / 2) + i) + 1], num_pixels);\n    }\n\n  }\n\n  for (int i = 0; i < cruzarChunkSize; i += 2)\n  {\n    cruzar(&poblacionLocal[i], &poblacionLocal[i + 1], &poblacionLocal[(cruzarChunkSize / 2) + i], &poblacionLocal[((cruzarChunkSize / 2) + i) + 1], num_pixels);\n  }\n\n  int mutation_start = (tam_poblacion / 4) / world_size;\n  if (rank == 0)\n  {\n    for (int i = leftover / 4; i < leftover; i++)\n    {\n      mutar(&poblacion[i], max, num_pixels);\n    }\n\n  }\n\n  for (int i = mutation_start; i < chunkSize; i++)\n  {\n    mutar(&poblacionLocal[i], max, num_pixels);\n  }\n\n  if (rank == 0)\n  {\n    initial_time_fitness = MPI_Wtime();\n    for (int i = 0; i < leftover; i++)\n    {\n      fitness(imagen_objetivo, &poblacion[i], num_pixels);\n    }\n\n  }\n\n  for (int i = 0; i < chunkSize; i++)\n  {\n    fitness(imagen_objetivo, &poblacionLocal[i], num_pixels);\n  }\n\n  if ((((g % 10) == 0) && g) || (g == (num_generaciones - 1)))\n  {\n    MPI_Gather(poblacionLocal, chunkSize, individuo_type, &poblacion[leftover], chunkSize, individuo_type, 0, (MPI_Comm) 0x44000000);\n    if (rank == 0)\n    {\n      qsort(poblacion, tam_poblacion, sizeof(Individuo), comp_fitness);\n      final_time_fitness = MPI_Wtime();\n      total_time_fitness += final_time_fitness - initial_time_fitness;\n      fitness_actual = poblacion[0].fitness;\n      diferencia_fitness = ((-(fitness_actual - fitness_anterior)) / fitness_actual) * 100;\n      if (1)\n      {\n        printf(\"Generacion %d - \", g);\n        printf(\"Fitness = %e - \", fitness_actual);\n        printf(\"Diferencia con Fitness Anterior = %.2e%c\\n\", diferencia_fitness, 37);\n      }\n\n    }\n\n    MPI_Scatter(&poblacion[leftover], chunkSize, individuo_type, poblacionLocal, chunkSize, individuo_type, 0, (MPI_Comm) 0x44000000);\n  }\n\n  qsort(poblacionLocal, chunkSize, sizeof(Individuo), comp_fitness);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/6"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 0; k <= (nz - 1); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][3];\n      u41 = rsd[i][j][k][3] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = rsd[i][j][k][1] * u41;\n      flux[i][j][k][2] = rsd[i][j][k][2] * u41;\n      flux[i][j][k][3] = (rsd[i][j][k][3] * u41) + (C2 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u41;\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n      }\n\n    }\n\n    for (k = 1; k <= (nz - 1); k++)\n    {\n      tmp = 1.0 / rsd[i][j][k][0];\n      u21k = tmp * rsd[i][j][k][1];\n      u31k = tmp * rsd[i][j][k][2];\n      u41k = tmp * rsd[i][j][k][3];\n      u51k = tmp * rsd[i][j][k][4];\n      tmp = 1.0 / rsd[i][j][k - 1][0];\n      u21km1 = tmp * rsd[i][j][k - 1][1];\n      u31km1 = tmp * rsd[i][j][k - 1][2];\n      u41km1 = tmp * rsd[i][j][k - 1][3];\n      u51km1 = tmp * rsd[i][j][k - 1][4];\n      flux[i][j][k][1] = tz3 * (u21k - u21km1);\n      flux[i][j][k][2] = tz3 * (u31k - u31km1);\n      flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      frct[i][j][k][0] = frct[i][j][k][0] + ((dz1 * tz1) * ((rsd[i][j][k + 1][0] - (2.0 * rsd[i][j][k][0])) + rsd[i][j][k - 1][0]));\n      frct[i][j][k][1] = (frct[i][j][k][1] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][1] - flux[i][j][k][1]))) + ((dz2 * tz1) * ((rsd[i][j][k + 1][1] - (2.0 * rsd[i][j][k][1])) + rsd[i][j][k - 1][1]));\n      frct[i][j][k][2] = (frct[i][j][k][2] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][2] - flux[i][j][k][2]))) + ((dz3 * tz1) * ((rsd[i][j][k + 1][2] - (2.0 * rsd[i][j][k][2])) + rsd[i][j][k - 1][2]));\n      frct[i][j][k][3] = (frct[i][j][k][3] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][3] - flux[i][j][k][3]))) + ((dz4 * tz1) * ((rsd[i][j][k + 1][3] - (2.0 * rsd[i][j][k][3])) + rsd[i][j][k - 1][3]));\n      frct[i][j][k][4] = (frct[i][j][k][4] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][4] - flux[i][j][k][4]))) + ((dz5 * tz1) * ((rsd[i][j][k + 1][4] - (2.0 * rsd[i][j][k][4])) + rsd[i][j][k - 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][1][m] = frct[i][j][1][m] - (dsspm * ((((+5.0) * rsd[i][j][1][m]) - (4.0 * rsd[i][j][2][m])) + rsd[i][j][3][m]));\n      frct[i][j][2][m] = frct[i][j][2][m] - (dsspm * (((((-4.0) * rsd[i][j][1][m]) + (6.0 * rsd[i][j][2][m])) - (4.0 * rsd[i][j][3][m])) + rsd[i][j][4][m]));\n    }\n\n    for (k = 3; k <= (nz - 4); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = frct[i][j][k][m] - (dsspm * ((((rsd[i][j][k - 2][m] - (4.0 * rsd[i][j][k - 1][m])) + (6.0 * rsd[i][j][k][m])) - (4.0 * rsd[i][j][k + 1][m])) + rsd[i][j][k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][nz - 3][m] = frct[i][j][nz - 3][m] - (dsspm * (((rsd[i][j][nz - 5][m] - (4.0 * rsd[i][j][nz - 4][m])) + (6.0 * rsd[i][j][nz - 3][m])) - (4.0 * rsd[i][j][nz - 2][m])));\n      frct[i][j][nz - 2][m] = frct[i][j][nz - 2][m] - (dsspm * ((rsd[i][j][nz - 4][m] - (4.0 * rsd[i][j][nz - 3][m])) + (5.0 * rsd[i][j][nz - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(u41, q)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/19"}
{"code": "for (i = 0; i < N; i++)\n{\n  if ((fabs(pageRankVec[i] - ((double) testVec[i])) / fabs((double) testVec[i])) > 0.1)\n    failed++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/savvpais/omp-pagerank/pageRankGSOMP/9"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  A[i] += A[i + 2] + sin(B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_10/zaleznosci/openmp_zaleznosci/4"}
{"code": "for (int ii = HALO_PAD - depth; ii < HALO_PAD; ++ii)\n{\n  for (int jj = HALO_PAD; jj < (y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX)) + (((ii - (HALO_PAD - depth)) * _chunk.innerX) * _chunk.innerY);\n      field[(((ii * y) * x) + (jj * x)) + kk] = buffer[bufIndex];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/11"}
{"code": "for (int i = 0; i < E; i++)\n{\n  int u = g[i].src;\n  int v = g[i].dest;\n  if ((offset2[u] >= 0) && (offset2[u] <= 2))\n  {\n  }\n\n  edges[offset2[u]] = v;\n  offset2[u]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspTopologyDriven/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrix2[i][j] = rand() % 1000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pyhro36/TD-1-OpenMP/matrice-matrice/main_mat/1"}
{"code": "for (unsigned int i = 0; i < size; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NDaghboudj/Learn-OpenMP/01-Basics/omp_ex_24/0"}
{"code": "for (int i = 0; i < nl; i++)\n{\n  tab[i] = (double *) malloc(nc * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.3/2"}
{"code": "for (i = 0; i < buckets_count; i++)\n{\n  results[i].values = (double *) malloc((sizeof(double)) * size);\n  results[i].count = 0;\n  for (j = 0; j < buckets_count; j++)\n  {\n    memcpy(&results[i].values[results[i].count], buckets[j][i].values, buckets[j][i].count * (sizeof(double)));\n    results[i].count += buckets[j][i].count;\n  }\n\n  free(buckets[j]);\n  qsort(results[i].values, results[i].count, sizeof(double), &doubles_comparator);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc2/bsort/2"}
{"code": "for (i = start; i < end; i++)\n{\n  for (j = 1; j < (columns + 1); j++)\n  {\n    int k = (i * (columns + 2)) + j;\n    int count = countNeighbours(old_partial_Universe, i, j, columns);\n    if ((old_partial_Universe[k] == 0) && (count == 3))\n      new_partial_Universe[k] = 1;\n    else\n      if ((old_partial_Universe[k] == 1) && ((count < 2) || (count > 3)))\n      new_partial_Universe[k] = 0;\n    else\n      new_partial_Universe[k] = old_partial_Universe[k];\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajdangwal/Game-of-Life/GameOfLife/1"}
{"code": "for (i = 0; i < NE; i++)\n{\n  printf(\"Value of C[0] at %d is %f: correct value: %f\\n\", i, c[i][0], d[i][0]);\n  printf(\"Value of C[1] at %d is %f: correct value: %f\\n\", i, c[i][1], d[i][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nompelis/typedef_gpu_map/test/2"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < N; j++)\n    out[j] += in[(i * N) + j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philorfa/Parallel-OpenMP-CUDA-FPGAs/CPU-GPU/linalg/4"}
{"code": "for (int i = 0; i < lookups; i++)\n{\n  rands[2 * i] = ((double) rand()) / ((double) 32767);\n  rands[(2 * i) + 1] = ((double) rand()) / ((double) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/xsbench-mp4/src/Main/1"}
{"code": "for (i = startBlock; i < end; i++)\n{\n  currentOutput = 0;\n  for (j = 0; j < 16384; j++)\n    currentOutput += matrix[i][j] * vec[j];\n\n  if (!id)\n    outputVector[i] = currentOutput;\n  else\n    sendBuffer[k++] = currentOutput;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 4/Pgm4/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  frct[i][j][k][0] = frct[i][j][k][0] + ((dy1 * ty1) * ((rsd[i][j - 1][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i][j + 1][k][0]));\n  frct[i][j][k][1] = (frct[i][j][k][1] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][1] - flux[i][j][k][1]))) + ((dy2 * ty1) * ((rsd[i][j - 1][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i][j + 1][k][1]));\n  frct[i][j][k][2] = (frct[i][j][k][2] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][2] - flux[i][j][k][2]))) + ((dy3 * ty1) * ((rsd[i][j - 1][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i][j + 1][k][2]));\n  frct[i][j][k][3] = (frct[i][j][k][3] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][3] - flux[i][j][k][3]))) + ((dy4 * ty1) * ((rsd[i][j - 1][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i][j + 1][k][3]));\n  frct[i][j][k][4] = (frct[i][j][k][4] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][4] - flux[i][j][k][4]))) + ((dy5 * ty1) * ((rsd[i][j - 1][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i][j + 1][k][4]));\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,m ,j ,ist ,k ,u21j ,u31j ,u41j ,u51j ,tmp ,u21jm1 ,u31jm1 ,u41jm1 ,u51jm1 ,ty2 ,jst ,jend ,ty3 ,L2 ,ty1 ,dy1 ,dy2 ,dy3 ,dy4 ,dy5 ,dssp ,jend1 ,ny ,nz ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/32"}
{"code": "for (i = 0; i < 1024; i++)\n  u = p[i];\n\n", "pragma": "omp for simd lastprivate(u) schedule (static, 32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr72781/0"}
{"code": "for (int i = 0; i < this->fields.size(); ++i)\n  omp_destroy_lock(&fields[i].lock);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/2/gameOfLife/GameOfLife/4"}
{"code": "for (int c = c1; c < c2; c++)\n{\n  int r = (int) ((k * (c - c1)) + r1);\n  data[((r * w) * 3) + (3 * c)] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 1] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 2] = 255;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/image_utility/9"}
{"code": "for (int j = 16; j < 64; j++)\n{\n  a[i] = j;\n  i += 4;\n}\n\n", "pragma": "omp parallel for linear (i: 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/linear-1/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  index[i] = (i * size) / n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mantri/parallel_algorithms/sample_sort/6"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    normvec1D[count] = abs(u_new[i][j] - xvel[i][j]);\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/Backward-Facing-Step/C++/src/main/8"}
{"code": "for (int i = 0; i < midterm; i++)\n  first_half[i] = arr[begin + i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/mergesort/mergesort/0"}
{"code": "for (unsigned short l_tg = 0; l_tg < i_nGroups; l_tg++)\n  o_nGroupEls[l_tg] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/time/Groups/0"}
{"code": "for (; i < halfsize; i++)\n{\n  tmp[i] = hist[i];\n  hist[i] = hist[i + halfsize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/9"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  for (i = iend - 1; i >= ist; i--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[j][i][m] = omega * (((((udz[j][i][0][m] * v[k + 1][j][i][0]) + (udz[j][i][1][m] * v[k + 1][j][i][1])) + (udz[j][i][2][m] * v[k + 1][j][i][2])) + (udz[j][i][3][m] * v[k + 1][j][i][3])) + (udz[j][i][4][m] * v[k + 1][j][i][4]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/buts/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);\n  startTime = omp_get_wtime();\n  convertToYCbCr_omp(image, 4);\n  duration = omp_get_wtime() - startTime;\n  (logs << duration) << \"\\n\";\n  (((cout << \"FINISHED. Conversion WITH OpenMP, simple and 4 threads took \") << duration) << \" seconds.\") << endl;\n  if (i == 9)\n    imwrite(\"converted_omp_4.png\", image);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/3"}
{"code": "for (ei_new = 0; ei_new < public.in2_pad_cols; ei_new++)\n{\n  pos_ori = ei_new * public.in2_pad_rows;\n  sum = 0;\n  #pragma loop name kernel#12#0\n  for (position = pos_ori; position < (pos_ori + public.in2_pad_rows); position = position + 1)\n  {\n    private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n    sum = private.d_in2_pad[position];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/13"}
{"code": "for (i = 0; i < cimgheight; i += height)\n{\n  for (j = 0; j < cimgwidth; j += width)\n  {\n    for (r = 0; r < height; r++)\n    {\n      for (c = 0; c < width; c++)\n      {\n        cimage[i + r][j + c] = superbuffer[(r * width) + c];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/36"}
{"code": "for (int i = 0; i < vx.size(); i++)\n{\n  x += vx[i];\n  x2 += pow(vx[i], 2);\n  x3 += pow(vx[i], 3);\n  x4 += pow(vx[i], 4);\n  x5 += pow(vx[i], 5);\n  x6 += pow(vx[i], 6);\n  x7 += pow(vx[i], 7);\n  x8 += pow(vx[i], 8);\n  x9 += pow(vx[i], 9);\n  x10 += pow(vx[i], 10);\n  x11 += pow(vx[i], 11);\n  x12 += pow(vx[i], 12);\n  x13 += pow(vx[i], 13);\n  x14 += pow(vx[i], 14);\n  x7y += pow(vx[i], 7) * vy[i];\n  x6y += pow(vx[i], 6) * vy[i];\n  x5y += pow(vx[i], 5) * vy[i];\n  x4y += pow(vx[i], 4) * vy[i];\n  x3y += pow(vx[i], 3) * vy[i];\n  x2y += pow(vx[i], 2) * vy[i];\n  xy += vx[i] * vy[i];\n  y += vy[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/40"}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%d \", arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/sorting/odd-even/2"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * (((5.0 * u[i][j][k][m_imopVar133]) - (4.0 * u[i][j + 1][k][m_imopVar133])) + u[i][j + 2][k][m_imopVar133]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/65"}
{"code": "for (int r = 0; r < 100; r++)\n{\n  loop2();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/3"}
{"code": "for (int i = 0; i < kernel_size; i++)\n  for (int j = 0; j < kernel_size; j++)\n  filter[i][j] = -1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OluwaseunOjeleye/OpenMP-based-Image-Processing-/image_processing/IP/11"}
{"code": "for (int j = 1; j < (ny + 1); ++j)\n{\n  for (int i = 1; i < (nx + 1); ++i)\n  {\n    if (image[j + (i * height)] > maximum)\n      maximum = image[j + (i * height)];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/MPI/stencilSerial/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i][j1][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/55"}
{"code": "for (int i = 0; i < 7; i++)\n{\n  (cout << eigenValues[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/18"}
{"code": "for (int i = 0; i < reps; i++)\n{\n  MPI_Isend(&initial_buffer[0], 3, MPI_CHAR, array_ranks[NORTHWEST], NORTHWEST, cart, &send_request[NORTHWEST]);\n  MPI_Isend(&initial_buffer[0], block_img_width, MPI_CHAR, array_ranks[NORTH], NORTH, cart, &send_request[NORTH]);\n  MPI_Isend(&initial_buffer[0], 1, type_column_rgb, array_ranks[WEST], WEST, cart, &send_request[WEST]);\n  MPI_Isend(&initial_buffer[block_img_width - 3], 3, MPI_CHAR, array_ranks[NORTHEAST], NORTHEAST, cart, &send_request[NORTHEAST]);\n  MPI_Isend(&initial_buffer[block_img_width - 3], 1, type_column_rgb, array_ranks[EAST], EAST, cart, &send_request[EAST]);\n  MPI_Isend(&initial_buffer[(block_img_height - 1) * block_img_width], 3, MPI_CHAR, array_ranks[SOUTHWEST], SOUTHWEST, cart, &send_request[SOUTHWEST]);\n  MPI_Isend(&initial_buffer[(block_img_height - 1) * block_img_width], block_img_width, MPI_CHAR, array_ranks[SOUTH], SOUTH, cart, &send_request[SOUTH]);\n  MPI_Isend(&initial_buffer[(block_img_height * block_img_width) - 3], 3, MPI_CHAR, array_ranks[SOUTHEAST], SOUTHEAST, cart, &send_request[SOUTHEAST]);\n  send_request[CENTER] = MPI_REQUEST_NULL;\n  MPI_Irecv(&northwest_corner, 3, MPI_CHAR, array_ranks[NORTHWEST], SOUTHEAST, cart, &receive_request[NORTHWEST]);\n  MPI_Irecv(north_row, block_img_width, MPI_CHAR, array_ranks[NORTH], SOUTH, cart, &receive_request[NORTH]);\n  MPI_Irecv(west_column, block_img_height * 3, MPI_CHAR, array_ranks[WEST], EAST, cart, &receive_request[WEST]);\n  MPI_Irecv(&northeast_corner, 3, MPI_CHAR, array_ranks[NORTHEAST], SOUTHWEST, cart, &receive_request[NORTHEAST]);\n  MPI_Irecv(east_column, block_img_height * 3, MPI_CHAR, array_ranks[EAST], WEST, cart, &receive_request[EAST]);\n  MPI_Irecv(&southwest_corner, 3, MPI_CHAR, array_ranks[SOUTHWEST], NORTHEAST, cart, &receive_request[SOUTHWEST]);\n  MPI_Irecv(south_row, block_img_width, MPI_CHAR, array_ranks[SOUTH], NORTH, cart, &receive_request[SOUTH]);\n  MPI_Irecv(&southeast_corner, 3, MPI_CHAR, array_ranks[SOUTHEAST], NORTHWEST, cart, &receive_request[SOUTHEAST]);\n  receive_request[CENTER] = MPI_REQUEST_NULL;\n  for (int i = 1; i < (block_img_height - 1); i++)\n  {\n    for (int l = 3; l < (block_img_width - 3); l++)\n    {\n      unsigned int offset_current_pixel = (i * block_img_width) + l;\n      unsigned int pixels_sum = northern_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += center_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += southern_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum /= final_filter;\n      final_buffer[offset_current_pixel] = ((char) pixels_sum) & 0xFF;\n    }\n\n  }\n\n  MPI_Waitall(8, receive_request, MPI_STATUSES_IGNORE);\n  for (int i = 3; i < (block_img_width - 3); i++)\n  {\n    unsigned int pixels_sum = center_row(i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += southern_row(i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += north_row[i - 3] * filter[SOUTHEAST];\n    pixels_sum += north_row[i] * filter[SOUTH];\n    pixels_sum += north_row[i + 3] * filter[SOUTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[i] = ((char) pixels_sum) & 0xFF;\n  }\n\n  unsigned int last_line = (block_img_height - 1) * block_img_width;\n  for (int i = 3; i < (block_img_width - 3); i++)\n  {\n    unsigned int pixels_sum = northern_row(last_line + i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += center_row(last_line + i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += south_row[i - 3] * filter[NORTHEAST];\n    pixels_sum += south_row[i] * filter[NORTH];\n    pixels_sum += south_row[i + 3] * filter[NORTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[last_line + i] = ((char) pixels_sum) & 0xFF;\n  }\n\n  unsigned int cursor = 0;\n  unsigned int pixels_sum = 0;\n  for (unsigned char rgb_current_color = 0; rgb_current_color < 3; rgb_current_color++)\n  {\n    for (unsigned int i = 1; i < (block_img_height - 1); i++)\n    {\n      cursor = (i * block_img_width) + rgb_current_color;\n      pixels_sum = center_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += eastern_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += west_column[((i - 1) * 3) + rgb_current_color] * filter[SOUTHEAST];\n      pixels_sum += west_column[(i * 3) + rgb_current_color] * filter[EAST];\n      pixels_sum += west_column[((i + 1) * 3) + rgb_current_color] * filter[NORTHEAST];\n      pixels_sum /= final_filter;\n      final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    }\n\n    for (unsigned int i = 1; i < (block_img_height - 1); i++)\n    {\n      cursor = (((i + 1) * block_img_width) - 3) + rgb_current_color;\n      pixels_sum = center_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += western_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      ;\n      pixels_sum += east_column[((i - 1) * 3) + rgb_current_color] * filter[SOUTHWEST];\n      pixels_sum += east_column[(i * 3) + rgb_current_color] * filter[WEST];\n      pixels_sum += east_column[((i + 1) * 3) + rgb_current_color] * filter[NORTHWEST];\n      pixels_sum /= final_filter;\n      final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    }\n\n    pixels_sum = initial_buffer[rgb_current_color] * filter[CENTER];\n    pixels_sum += initial_buffer[rgb_current_color + 3] * filter[WEST];\n    pixels_sum += initial_buffer[rgb_current_color + block_img_width] * filter[NORTH];\n    pixels_sum += initial_buffer[(rgb_current_color + block_img_width) + 3] * filter[NORTHWEST];\n    pixels_sum += north_row[rgb_current_color] * filter[SOUTH];\n    pixels_sum += north_row[rgb_current_color + 3] * filter[SOUTHWEST];\n    pixels_sum += west_column[rgb_current_color] * filter[EAST];\n    pixels_sum += west_column[rgb_current_color + 3] * filter[NORTHEAST];\n    pixels_sum += northwest_corner[rgb_current_color] * filter[SOUTHEAST];\n    pixels_sum /= final_filter;\n    final_buffer[rgb_current_color] = ((char) pixels_sum) & 0xFF;\n    cursor = (block_img_width + rgb_current_color) - 3;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor - 3] * filter[EAST];\n    pixels_sum += initial_buffer[cursor + block_img_width] * filter[NORTH];\n    pixels_sum += initial_buffer[(cursor + block_img_width) - 3] * filter[NORTHEAST];\n    pixels_sum += north_row[cursor] * filter[SOUTH];\n    pixels_sum += north_row[cursor - 3] * filter[SOUTHEAST];\n    pixels_sum += east_column[rgb_current_color] * filter[WEST];\n    pixels_sum += east_column[rgb_current_color + 3] * filter[NORTHWEST];\n    pixels_sum += northeast_corner[rgb_current_color] * filter[SOUTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    cursor = ((block_img_height - 1) * block_img_width) + rgb_current_color;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor + 3] * filter[WEST];\n    pixels_sum += initial_buffer[cursor - block_img_width] * filter[SOUTH];\n    pixels_sum += initial_buffer[(cursor - block_img_width) + 3] * filter[SOUTHWEST];\n    pixels_sum += south_row[rgb_current_color] * filter[NORTH];\n    pixels_sum += south_row[rgb_current_color + 3] * filter[NORTHWEST];\n    pixels_sum += west_column[(block_img_height + rgb_current_color) - 3] * filter[EAST];\n    pixels_sum += west_column[(block_img_height + rgb_current_color) - 6] * filter[SOUTHEAST];\n    pixels_sum += southwest_corner[rgb_current_color] * filter[NORTHEAST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    cursor = ((block_img_height * block_img_width) + rgb_current_color) - 3;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor - 3] * filter[EAST];\n    pixels_sum += initial_buffer[cursor - block_img_width] * filter[SOUTH];\n    pixels_sum += initial_buffer[(cursor - block_img_width) - 3] * filter[SOUTHEAST];\n    pixels_sum += south_row[(block_img_width + rgb_current_color) - 3] * filter[NORTH];\n    pixels_sum += south_row[(block_img_width + rgb_current_color) - 6] * filter[NORTHEAST];\n    pixels_sum += east_column[(block_img_height + rgb_current_color) - 3] * filter[WEST];\n    pixels_sum += east_column[(block_img_height + rgb_current_color) - 6] * filter[SOUTHWEST];\n    pixels_sum += southeast_corner[rgb_current_color] * filter[NORTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n  }\n\n  MPI_Waitall(8, send_request, MPI_STATUSES_IGNORE);\n  unsigned char *temp_buffer = final_buffer;\n  final_buffer = initial_buffer;\n  initial_buffer = temp_buffer;\n  if (((i + 1) % 20) == 0)\n  {\n    unsigned char rank_contrast;\n    unsigned char pixel_contrast = 0;\n    for (int i = 0; i < (block_img_width * block_img_height); i++)\n    {\n      if (initial_buffer[i] != final_buffer[i])\n      {\n        pixel_contrast = 1;\n        break;\n      }\n\n    }\n\n    MPI_Reduce(&pixel_contrast, &rank_contrast, 1, MPI_CHAR, MPI_MAX, 0, cart);\n    MPI_Bcast(&rank_contrast, 1, MPI_CHAR, 0, cart);\n    if (rank_contrast == 0)\n    {\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ApChris/Image-Convolution/convolution/3"}
{"code": "for (n = N - 2; n >= 0; n--)\n{\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    index = rsctrellis.nextStates[k];\n    B0[k + (rsctrellis.numStates * n)] = log_add(B0[index + ((n + 1) * rsctrellis.numStates)] + (Lc2I[n + 1] * rsctrellis.PARout[index]), ((B1[index + ((n + 1) * rsctrellis.numStates)] + Lc1I[n + 1]) + apriori_data[n + 1]) + (Lc2I[n + 1] * rsctrellis.PARout[index + rsctrellis.numStates]));\n    index = rsctrellis.nextStates[k + rsctrellis.numStates];\n    B1[k + (rsctrellis.numStates * n)] = log_add(B0[index + ((n + 1) * rsctrellis.numStates)] + (Lc2I[n + 1] * rsctrellis.PARout[index]), ((B1[index + ((n + 1) * rsctrellis.numStates)] + Lc1I[n + 1]) + apriori_data[n + 1]) + (Lc2I[n + 1] * rsctrellis.PARout[index + rsctrellis.numStates]));\n  }\n\n  if (isinf(A_mid[n + 1]))\n  {\n    continue;\n  }\n\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    B0[k + (rsctrellis.numStates * n)] -= A_mid[n + 1];\n    B1[k + (rsctrellis.numStates * n)] -= A_mid[n + 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/3"}
{"code": "for (int i = 0; i < length; i++)\n{\n  sum += n[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RizkyAnggita/openmp/loops/12"}
{"code": "for (int k = y_min - 2; k <= (y_max + 3); k++)\n{\n  vertexdy[FTNREF1D(k, y_min - 2)] = d_y;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/3"}
{"code": "for (int k = 0; k < nthreads; ++k)\n{\n  resultLongestIndex[k] = 0;\n  resultMaxLength[k] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/robert-preissl/palindrome-substring-omp/src/omp/PalindromeSubstring_omp/0"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  perm[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/12"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    X[i][j] = (float) (rand() % 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/2"}
{"code": "for (int j = jb; j < je; j++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    if (betaz[IDX(i, j, ke - 3)] < 0.0)\n    {\n      Dzu[IDX(i, j, ke - 3)] = ((((-3.0) * u[IDX(i, j, ke - 3)]) + (4.0 * u[IDX(i, j, ke - 2)])) - u[IDX(i, j, ke - 1)]) * idz_by_2;\n    }\n    else\n    {\n      Dzu[IDX(i, j, ke - 3)] = (((((-u[IDX(i, j, ke - 6)]) + (6.0 * u[IDX(i, j, ke - 5)])) - (18.0 * u[IDX(i, j, ke - 4)])) + (10.0 * u[IDX(i, j, ke - 3)])) + (3.0 * u[IDX(i, j, ke - 2)])) * idz_by_12;\n    }\n\n    if (betaz[IDX(i, j, ke - 2)] > 0.0)\n    {\n      Dzu[IDX(i, j, ke - 2)] = ((-u[IDX(i, j, ke - 3)]) + u[IDX(i, j, ke - 1)]) * idz_by_2;\n    }\n    else\n    {\n      Dzu[IDX(i, j, ke - 2)] = ((u[IDX(i, j, ke - 4)] - (4.0 * u[IDX(i, j, ke - 3)])) + (3.0 * u[IDX(i, j, ke - 2)])) * idz_by_2;\n    }\n\n    Dzu[IDX(i, j, ke - 1)] = ((u[IDX(i, j, ke - 3)] - (4.0 * u[IDX(i, j, ke - 2)])) + (3.0 * u[IDX(i, j, ke - 1)])) * idz_by_2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/35"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  unsigned char output[4096] = {0};\n  int i;\n  unsigned char *tag = (cur_salt->ct + cur_salt->ctlen) - cur_salt->tag_len;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    memset(output, 0, 4096);\n    aes_ccm_auth_decrypt(master[i], 256, cur_salt->ctlen - cur_salt->tag_len, cur_salt->iv, 13, cur_salt->add, cur_salt->addlen, cur_salt->ct, output, tag, cur_salt->tag_len);\n    if ((cur_salt->ctlen - cur_salt->tag_len) == 2)\n    {\n      if (strncmp((const char *) output, \"[]\", 2) == 0)\n        cracked[index + i] = 1;\n\n    }\n    else\n    {\n      if (output[0] != '[')\n        cracked[index + i] = 0;\n      else\n        if (strstr((const char *) output, \"\\\"updated\\\"\"))\n        cracked[index + i] = 1;\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/padlock_fmt_plug/0"}
{"code": "for (k = ki1; k < (ki2 - 1); k++)\n{\n  for (i = ibeg; i < ifin1; i++)\n  {\n    frc2 = frc2 + (((((((phi1[k][i] + phi1[k][i + 1]) + phi1[k + 1][i]) + phi1[k + 1][i + 1]) + phi2[k][i]) + phi2[k][i + 1]) + phi2[k + 1][i]) + phi2[k + 1][i + 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/24"}
{"code": "for (size_t i = 0; i < row; i++)\n{\n  BestOne.binaryValue += '0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/5"}
{"code": "for (int depth = start_y; depth < end_y; depth++)\n{\n  for (int row = start_z; row < end_z; row++)\n  {\n    for (int column = 0; column < boundary_length; column++)\n    {\n      property_array[(((depth * nz_nx) + (row * nx)) + column) + start_x] = property_array[(((depth * nz_nx) + (row * nx)) + boundary_length) + start_x];\n      property_array[((depth * nz_nx) + (row * nx)) + ((end_x - 1) - column)] = property_array[((depth * nz_nx) + (row * nx)) + ((end_x - 1) - boundary_length)];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp  parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/HomogenousExtension/1"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n      fprintf(logFile, \"OK\\n\");\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(logFile, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(logFile, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(logFile, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(logFile, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_static/7"}
{"code": "for (int i = 0; i < n; i++)\n  fprintf(f, \"%g %g\\n\", p[i].x, p[i].y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/urmilas239/Openmp/common/14"}
{"code": "for (int i = 0; i < min(num_tiles, (int) data.size()); ++i)\n{\n  k_tiles.push_back((data.size() * i) / num_tiles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (k = 0; k < size; k++)\n  {\n    for (j = 0; j < size; j++)\n    {\n      C[(size * i) + j] += A[(size * i) + k] * B[(size * k) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for simd private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dc-fukuoka/gpumm/cpu/mm/0"}
{"code": "for (i = 0; i < (dim * dim); i++)\n  A[i] = i * 2.;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/Openmp/FastTr_omp/2"}
{"code": "for (c2 = nm; c2 <= (nj + (-1)); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/71"}
{"code": "for (i = 0; i <= ((int) (interval / deltaInterval)); i++)\n{\n  moments[i] = i * deltaInterval;\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Functions/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  printf(\"Thread nb %d executes index=%d \\n\", tid, i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/faxmishok/Parallel-Prog-OpenMP-pw2/warmup2/0"}
{"code": "for (i = 0; i < numdims; i++)\n  ans += (coord1[i] - coord2[i]) * (coord1[i] - coord2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/1"}
{"code": "for (int j = 0; j < trees; ++j)\n{\n  intialize_seeds();\n  for (int i = 0; i < xdim; i++)\n  {\n    ProjColX[j].pb(getHash(i, projDimx, seedIndexX));\n    ProjSignX[j].pb((2 * getHash(i, 2, seedSignX)) - 1);\n  }\n\n  for (int i = 0; i < ydim; i++)\n  {\n    ProjColY[j].pb(getHash(i, projDimy, seedIndexY));\n    ProjSignY[j].pb((2 * getHash(i, 2, seedSignY)) - 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_parallel_large/3"}
{"code": "for (int32_t i = 0; i < argc; i++)\n  sum[i] += i;\n\n", "pragma": "omp for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_05/0"}
{"code": "for (i = 0; i < ng; i++)\n  for (j = 0; j < ng; j++)\n  for (k = 0; k < ng; k++)\n{\n  m = (i + j) + k;\n  if ((m % 2) == 1)\n  {\n    pfft(p, i, j, k)->Re *= -1.0;\n    pfft(p, i, j, k)->Im *= -1.0;\n  }\n\n}\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/fft_basic/0"}
{"code": "for (p = 0; p < M; p++)\n{\n  temp[(0 * M) + p] = buff3[p];\n}\n\n", "pragma": "omp parallel for private(p) shared(temp) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/5"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  data[i] = dist(generator);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/qureshizawar/CUDA-quartic-solver/src/utils/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  somme = somme + tab[i];\n  printf(\"%d, par le thread : %d\\n\", somme, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for reduction (+:somme)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_6/TD_OPENMP_06/0"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  matrix[i][i] = 1 - matrix[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/9"}
{"code": "for (i = 0; i < 10; i++)\n{\n  psum += A[i];\n  pprod *= A[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/01_critical_sections/0"}
{"code": "for (int i = 0; i < WIDTH; ++i)\n{\n  field[HEIGHT - 1][i] = 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/7"}
{"code": "for (int ck = 1; ck <= k; ++ck)\n{\n  cC[ck] = pC[ck - 1] + pC[ck];\n  cC[ck] %= modref;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/nCk/nCk2_par1/1"}
{"code": "for (int i = 0; i < board.getCols(); i++)\n{\n  if (board.isColumnEmpty(i))\n  {\n    board.makeMove(i, player);\n    int score = alphabetapruning(depth + 1, maxDepth, alpha, beta, false, nextPlayer);\n    bestScore = max(bestScore, score);\n    alpha = max(alpha, score);\n    board.undoMove();\n    if (beta <= alpha)\n      break;\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) if(isMaximizingPlayer)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/GameAlphaBeta/1"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  x = (i + .001) * step;\n  sum = sum + (1.0 / (1. + (x * x)));\n}\n\n", "pragma": "    #pragma omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Xinghom/OpenMP_workout/pi_calculator/pi_calculator/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/5"}
{"code": "for (i = 0; i < mat2_1d; i++)\n{\n  matr2[i] = malloc(mat2_2d * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/3"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"Thread %d, x=%d, address %p\\n\", omp_get_thread_num(), x, &x);\n  x = i;\n}\n\n", "pragma": "omp parallel for reduction(+:x)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/learn_openmp/OpenMP ECP ESP Workshop/examples/parallel_for_reduction/0"}
{"code": "for (int i = 2; i < (nx + 2); ++i)\n{\n  double x = ((i - 2) - ((nx - 1) / 2.)) * dx;\n  for (int j = 2; j < (ny + 2); ++j)\n  {\n    double y = ((j - 2) - ((ny - 1) / 2.)) * dy;\n    for (int k = 2; k < (nz + 2); ++k)\n    {\n      int s = columnMajorLinearIndex(i, j, k, nx + 4, ny + 4, nz + 4);\n      double gasGamma = 1.4;\n      double gravity = 0.1;\n      double rhoTop = 2.0;\n      double rhoBot = 1.0;\n      double pr0 = 0.01;\n      double pert = 0.01;\n      double yloc = 0.5 + (pert * cos(M_PI * x));\n      double pr;\n      if (y > yloc)\n        pr = (rhoTop * gravity) * (1 - y);\n      else\n        pr = ((rhoTop * gravity) * (1 - yloc)) + ((rhoBot * gravity) * (yloc - y));\n\n      e[s] = pr;\n      p[s] = e[s] / 3.;\n      u->ux[s] = 0.;\n      u->uy[s] = 0.;\n      u->un[s] = 0.;\n      u->ut[s] = 1.;\n      up->ux[s] = 0.;\n      up->uy[s] = 0.;\n      up->un[s] = 0.;\n      up->ut[s] = 1.;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/rhic/src/InitialConditions/8"}
{"code": "for (l = 0; l < nz; l++)\n{\n  ll = nnxye * l;\n  for (k = 0; k < ny; k++)\n  {\n    for (i = 0; i < ndim; i++)\n    {\n      amu[(i + ((ndim * nxe) * k)) + ll] += amu[(i + (ndim * (nx + (nxe * k)))) + ll];\n      amu[(i + (ndim * (nx + (nxe * k)))) + ll] = 0.0;\n    }\n\n  }\n\n  for (j = 0; j < nx; j++)\n  {\n    for (i = 0; i < ndim; i++)\n    {\n      amu[(i + (ndim * j)) + ll] += amu[(i + (ndim * (j + (nxe * ny)))) + ll];\n      amu[(i + (ndim * (j + (nxe * ny)))) + ll] = 0.0;\n    }\n\n  }\n\n  for (i = 0; i < ndim; i++)\n  {\n    amu[i + ll] += amu[(i + (ndim * (nx + (nxe * ny)))) + ll];\n    amu[(i + (ndim * (nx + (nxe * ny)))) + ll] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/0"}
{"code": "for (int i = 0; i < _quentityElement; i++)\n{\n  _vecOne[i].x = (rand() % _quentityElement) + 0;\n  _vecOne[i].y = (rand() % _quentityElement) + 0;\n  _vecSecond[i].x = (rand() % _quentityElement) + 0;\n  _vecSecond[i].y = (rand() % _quentityElement) + 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgavrisyuk/OpenMP/main/0"}
{"code": "for (int i = 0; i < num_inner_loop_instructions; ++i)\n{\n  vmovntdq(ptr[rdi + (i * 16)], xmm0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/5"}
{"code": "for (i = 0; i < 10; i++)\n{\n  d = d + ((a[i] - avg) * (a[i] - avg));\n}\n\n", "pragma": "omp parallel for reduction(+ : d)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/avg min max SD of  numbers/3"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    u[i3][i2][n1 - 1] = u[i3][i2][1];\n    u[i3][i2][0] = u[i3][i2][n1 - 2];\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/17"}
{"code": "for (i = 0; i < length; i++)\n{\n  randy = ((1366 * randy) + 150889) % 714025;\n  *(a + i) = ((double) randy) / ((double) 714025);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MetalRain/learn-openmp/prod_cons/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%d\\n\", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lephin/C-parallel-programming.-OpenMP/Hello/2"}
{"code": "for (i = 0; i < 64; i++)\n  if (buf[i] != ((-7) * ((((i & 3) == 2) && (i >= 18)) && (i <= 42))))\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-11/11"}
{"code": "for (int i = 0; i < 10; ++i)\n  for (int j = 0; j < 10; ++j)\n{\n  foo();\n  k1 += 8;\n  k2 += 8;\n}\n\n\n", "pragma": "#pragma omp distribute parallel for private(argc,b),lastprivate(d,f),reduction(+:e) reduction(min : g),  collapse(2) dist_schedule(static, 3)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_parallel_for_ast_print/3"}
{"code": "for (i = 0; i < 256; i++)\n  if (a[i] != (3 * (i >= 1)))\n  abort();\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/3"}
{"code": "for (i = 2; i <= p; i++)\n{\n  f = 1;\n  for (j = 2; j <= (i / 2); j++)\n    if ((i % j) == 0)\n    flag = 0;\n\n\n  if (flag)\n    printf(\"Thread no: %d\\t%d is a prime number\\n\", omp_get_thread_num(), i);\n\n}\n\n", "pragma": "omp parallel for firstprivate(flag)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/prime/0"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets1285Ptr = _checkInCodelets1285(1, 1, this, codeletCounter);\n  (*checkInCodelets1285Ptr).decDep();\n  checkInCodelets1285Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/53"}
{"code": "for (i = 0; i < NI; i++)\n{\n  for (j = 0; j < NL; j++)\n  {\n    D[(i * NL) + j] = (((DATA_TYPE) i) * (j + 2)) / NK;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/5"}
{"code": "for (int i = 0; i < nbthreads; i++)\n{\n  for (int j = k_arr[i]; j < k_arr[i + 1]; j++)\n  {\n    pr[j] = pr[j] + temp[i];\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayuri34/parallel-computing/assignment-openmp-loop/prefixsum/prefixsum/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  free(array1[i]);\n  free(array2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/almazhankapan/game-of-life/game_of_life/7"}
{"code": "for (int i = 0; i < s->A; i++)\n{\n  simulation_update_intersection_lights(s, i, T);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chalearm/OpenMPApp/TrafficSignaling/solution_check/1"}
{"code": "for (e = 1; e < 5; e++)\n{\n  table_expf_temp[e] = exp(((float) (-((float) e))) / temp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/19"}
{"code": "for (i = 0; i < 1000; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/architkarandikar/OpenMP-Tutorial/Intro/ParallelFor/parallel_for_directive/1"}
{"code": "for (int i = 0; i < NUM_OF_SECTORS; i++)\n{\n  for (int j = 0; j < NUM_OF_SPEED; j++)\n  {\n    outData[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/WindRosePOC/src_OpenMP/Parallel01_01/0"}
{"code": "for (i = 0; i < nz; i++)\n{\n  matA.val[i] = (rand() % MAX_RAND_DOUBLE) + START_DOUBLE;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/0"}
{"code": "for (int i = iradius; i < (input.rows - iradius); ++i)\n{\n  for (int j = iradius; j < (input.cols - iradius); ++j)\n  {\n    for (int kernel_i = -iradius; kernel_i <= iradius; ++kernel_i)\n    {\n      for (int kernel_j = -iradius; kernel_j <= iradius; ++kernel_j)\n      {\n        size_t x = i + kernel_i;\n        size_t y = j + kernel_j;\n        if (input(x, y) != 0)\n        {\n          output(i, j) = 255;\n          goto outtahere;\n        }\n\n      }\n\n    }\n\n    outtahere:\n    (void) 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/minijackson/INF4710-TP3/src/dilation/0"}
{"code": "for (inner = 0; inner < k; inner++)\n{\n  {\n    sum = sum + (Mas1[row][inner] * Mas2[inner][col]);\n  }\n}\n\n", "pragma": "#pragma omp parallel for ordered private(inner) \\", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/Matr/13"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (k = 0, j = ptr[i]; j < ptr[i + 1]; j++)\n  {\n    if ((j > ptr[i]) && (ind[j] < ind[j - 1]))\n    {\n      k = 1;\n    }\n\n    cand[j - ptr[i]].val = j - ptr[i];\n    cand[j - ptr[i]].key = ind[j];\n    tval[j - ptr[i]] = val[j];\n  }\n\n  if (k)\n  {\n    gk_ikvsorti(ptr[i + 1] - ptr[i], cand);\n    for (j = ptr[i]; j < ptr[i + 1]; j++)\n    {\n      ind[j] = cand[j - ptr[i]].key;\n      val[j] = tval[cand[j - ptr[i]].val];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int tid = omp_get_thread_num();\n  sum[tid] += x[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dd2356/OpenMP/OpenMP/exercise_2/src/sum/1"}
{"code": "for (i = 0; i < partitionSize; i++)\n{\n  currentElement = array[initialLeft + i];\n  if (currentElement < pivot)\n  {\n    lessThanPivot[ltPivotCounter++] = currentElement;\n  }\n  else\n  {\n    greaterThanPivot[gtPivotCounter++] = currentElement;\n  }\n\n}\n\n", "pragma": "omp parallel for private(currentElement)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/axell-brendow/seminars-ii/Trabalho Paralelismo/Quicksort/0"}
{"code": "for (int j = 0; j < 5; ++j)\n{\n  sleep(1);\n  printf(\"wake %d, %d\\n\", j, omp_get_thread_num());\n}\n\n", "pragma": "         #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPToolsInterface/ompt-test-suite/examples/parallelsections/1"}
{"code": "for (j = i + 1; j < tam; j++)\n{\n  if (vetor[j] < vetor[min])\n  {\n    min = j;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) num_threads(numThreads) shared(vetor, i, min) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tiaagosr/parallel-sorting-algorithms/selection/0"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  C[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/runDirectedMultiPhaseBasic/0"}
{"code": "for (size = 3; size < matSize; size += stride)\n{\n  (invoke < Stencil) > ((this, oldA, newA, size, 0, 12, &resu));\n  for (j = 0; j < repets; j++)\n  {\n    (invoke < Stencil) > ((this, oldA, newA, size, 0, 12, &resu));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/Stencil/Lines/CDParallelism/utils/0"}
{"code": "for (i = 0; i < l; i++)\n{\n  int j;\n  for (j = 0; j < SIZE; j++)\n  {\n    if (forward_map[empty_cells_list[idx].x][empty_cells_list[idx].y][j] == 0)\n    {\n      int a;\n      int b;\n      int c;\n      struct queue_element *temp = malloc(sizeof(struct queue_element));\n      for (a = 0; a < SIZE; a++)\n        for (b = 0; b < SIZE; b++)\n        temp->board[a][b] = q->list[i]->board[a][b];\n\n\n      for (a = 0; a < SIZE; a++)\n        for (b = 0; b < SIZE; b++)\n        for (c = 0; c < SIZE; c++)\n        temp->forward_map[a][b][c] = q->list[i]->forward_map[a][b][c];\n\n\n\n      temp->board[empty_cells_list[idx].x][empty_cells_list[idx].y] = j + 1;\n      populate_f(empty_cells_list[idx].x, empty_cells_list[idx].y, j + 1, temp->forward_map);\n      push(tmp, temp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/22"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  result = expression(x1 + (i * dx));\n  final_result += result;\n}\n\n", "pragma": "    #pragma omp parallel for private (result) reduction (+:final_result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aoun-Hussain/OpenMP-Multi-Threading-Integration/main/0"}
{"code": "for (int t = 0; t < nt; t++)\n{\n  rtm8_cpu(vsq, current_s, next_s, current_r, next_r, image_cpu, a, ArraySize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/rtm8-omp/rtm8/3"}
{"code": "for (int i = 1; i < npes; i++)\n{\n  MPI_Send(&row, 1, MPI_INT, i, DATA_TAG, MPI_COMM_WORLD);\n  row++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ricaidito/MandelbrotSet/Parallel/MandelbrotSetParallel/0"}
{"code": "for (long i = 0; i < nC1; i++)\n{\n  commPtr1[i + 1] += commPtr1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/7"}
{"code": "for (int i = 0; i < dnum; i++)\n{\n  dx[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  dy[i] = (rand() / ((float) RAND_MAX)) * 1000;\n  dz[i] = (rand() / ((float) RAND_MAX)) * 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aidw-omp/main/1"}
{"code": "for (ri = 0; ri < bcount; ri++)\n{\n  int rid = ri + bstart;\n  buffer[ri] = s->rat_position[rid];\n  s->rat_position[rid] = fast_next_random_move(s, rid);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WeijiaGao49/Shared-Memory-Parallelism-with-OpenMP/code/sim/4"}
{"code": "for (int i = 0; i < NUM_CLUSTERS; i++)\n{\n  if ((old_centroids[i] - clusters[i]) > 0.001)\n    threshold = false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hima-Megahed/Kmeans-Parallized-OpenMP/Kmeans-Parallized-OpenMP/Kmeans-Parallized-OpenMP/KmeansParallizedOpenMP/3"}
{"code": "for (n = 1; n <= npl; n++)\n{\n  j = jndxp[l][n];\n  i = indxp[l][n];\n  k = (l - i) - j;\n  for (m = 0; m < 5; m++)\n  {\n    tv[m][n] = omega * (((((c[0][m][n] * rsd[0][k + 1][j][i]) + (c[1][m][n] * rsd[1][k + 1][j][i])) + (c[2][m][n] * rsd[2][k + 1][j][i])) + (c[3][m][n] * rsd[3][k + 1][j][i])) + (c[4][m][n] * rsd[4][k + 1][j][i]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/buts/0"}
{"code": "for (int i = 0; i < graph->size; i++)\n{\n  graph->nodes[i] = (Node *) malloc(sizeof(Node));\n  graph->nodes[i]->neighbours = (Node **) malloc(size * (sizeof(Node)));\n  graph->nodes[i]->degree = 0;\n  graph->nodes[i]->idx = i;\n  graph->nodes[i]->inQ = 0;\n  graph->nodes[i]->inR = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/9"}
{"code": "for (int ax = 0; ax < 3; ax++)\n{\n  for (size_t i = 0; i < (gpuBounds[ax].size() - 1); i++)\n  {\n    if (gpuBounds[ax][i].coord > gpuBounds[ax][i + 1].coord)\n    {\n      ok = false;\n      LOG_ERROR(\"gpuBounds[{}][{}].coord=>gpuBounds[{}][{}].coord: {}>{}\", ax, i, ax, i + 1, gpuBounds[ax][i].coord, gpuBounds[ax][i + 1].coord);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/woodem/woo/src/dem/OpenCLCollider/2"}
{"code": "for (j = 0; j < 31; j++)\n{\n  k = d_hash(toHash[j], i);\n  for (l = 0; l < j; l++)\n  {\n    if (hashed[l] == k)\n      return false;\n\n  }\n\n  hashed[l] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_3/z3/0"}
{"code": "for (j = 1; j <= i__1; ++j)\n{\n  if (x[jx] != 0.f)\n  {\n    temp = (*alpha) * x[jx];\n    i__2 = *m;\n    for (i__ = 1; i__ <= i__2; ++i__)\n    {\n      y[i__] += temp * a[i__ + (j * a_dim1)];\n    }\n\n  }\n\n  jx += *incx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/38"}
{"code": "for_each(v.begin(), v.end(), display)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hanneshoettinger/openMP-virtual-test/Virtual/0"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (j = 0; j < ny; j++)\n    {\n      flux[j][0] = u[k][j][i][2];\n      u31 = u[k][j][i][2] * rho_i[k][j][i];\n      q = qs[k][j][i];\n      flux[j][1] = u[k][j][i][1] * u31;\n      flux[j][2] = (u[k][j][i][2] * u31) + (C2 * (u[k][j][i][4] - q));\n      flux[j][3] = u[k][j][i][3] * u31;\n      flux[j][4] = ((C1 * u[k][j][i][4]) - (C2 * q)) * u31;\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (ty2 * (flux[j + 1][m] - flux[j - 1][m]));\n      }\n\n    }\n\n    for (j = jst; j < ny; j++)\n    {\n      tmp = rho_i[k][j][i];\n      u21j = tmp * u[k][j][i][1];\n      u31j = tmp * u[k][j][i][2];\n      u41j = tmp * u[k][j][i][3];\n      u51j = tmp * u[k][j][i][4];\n      tmp = rho_i[k][j - 1][i];\n      u21jm1 = tmp * u[k][j - 1][i][1];\n      u31jm1 = tmp * u[k][j - 1][i][2];\n      u41jm1 = tmp * u[k][j - 1][i][3];\n      u51jm1 = tmp * u[k][j - 1][i][4];\n      flux[j][1] = ty3 * (u21j - u21jm1);\n      flux[j][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[j][3] = ty3 * (u41j - u41jm1);\n      flux[j][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      rsd[k][j][i][0] = rsd[k][j][i][0] + ((dy1 * ty1) * ((u[k][j - 1][i][0] - (2.0 * u[k][j][i][0])) + u[k][j + 1][i][0]));\n      rsd[k][j][i][1] = (rsd[k][j][i][1] + (((ty3 * C3) * C4) * (flux[j + 1][1] - flux[j][1]))) + ((dy2 * ty1) * ((u[k][j - 1][i][1] - (2.0 * u[k][j][i][1])) + u[k][j + 1][i][1]));\n      rsd[k][j][i][2] = (rsd[k][j][i][2] + (((ty3 * C3) * C4) * (flux[j + 1][2] - flux[j][2]))) + ((dy3 * ty1) * ((u[k][j - 1][i][2] - (2.0 * u[k][j][i][2])) + u[k][j + 1][i][2]));\n      rsd[k][j][i][3] = (rsd[k][j][i][3] + (((ty3 * C3) * C4) * (flux[j + 1][3] - flux[j][3]))) + ((dy4 * ty1) * ((u[k][j - 1][i][3] - (2.0 * u[k][j][i][3])) + u[k][j + 1][i][3]));\n      rsd[k][j][i][4] = (rsd[k][j][i][4] + (((ty3 * C3) * C4) * (flux[j + 1][4] - flux[j][4]))) + ((dy5 * ty1) * ((u[k][j - 1][i][4] - (2.0 * u[k][j][i][4])) + u[k][j + 1][i][4]));\n    }\n\n  }\n\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][1][i][m] = rsd[k][1][i][m] - (dssp * ((((+5.0) * u[k][1][i][m]) - (4.0 * u[k][2][i][m])) + u[k][3][i][m]));\n      rsd[k][2][i][m] = rsd[k][2][i][m] - (dssp * (((((-4.0) * u[k][1][i][m]) + (6.0 * u[k][2][i][m])) - (4.0 * u[k][3][i][m])) + u[k][4][i][m]));\n    }\n\n  }\n\n  for (j = 3; j < (ny - 3); j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (dssp * ((((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n      }\n\n    }\n\n  }\n\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][ny - 3][i][m] = rsd[k][ny - 3][i][m] - (dssp * (((u[k][ny - 5][i][m] - (4.0 * u[k][ny - 4][i][m])) + (6.0 * u[k][ny - 3][i][m])) - (4.0 * u[k][ny - 2][i][m])));\n      rsd[k][ny - 2][i][m] = rsd[k][ny - 2][i][m] - (dssp * ((u[k][ny - 4][i][m] - (4.0 * u[k][ny - 3][i][m])) + (5.0 * u[k][ny - 2][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/30"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].print_layer_info();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/5"}
{"code": "for (y = 0; y < OMP_yMax; y++)\n{\n  for (x = 0; x < OMP_xMax; x++)\n  {\n    u[OMP_Index(x, y, 0)] *= boundryScale;\n    u[OMP_Index(x, y, OMP_zMax - 1)] *= boundryScale;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(xMax, yMax, zMax) private(x,y) num_threads(16)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maeneka/Gaussian-Deblur-OpenMP/ompDeblur/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  gevm(matrix, vector, result);\n  swap(&vector, &result);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ric0rdanza/HPC_Openmp_GEMV/gemv/6"}
{"code": "for (int i = 0; i < numHidden2Nodes; ++i)\n{\n  free(layer2_weights[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/19"}
{"code": "for (int j = 0; j < layers[nOfLayers - 1].nOfNeurons; j++)\n{\n  layers[nOfLayers - 1].neurons[j].out = exp(layers[nOfLayers - 1].neurons[j].net) / (1 + sumNet);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/8"}
{"code": "for (int i = 0; i < NUMBER_OF_EXPERIMENT; i++)\n{\n  timeSum += times[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smohammadhejazi/multicore-programming-lab/2/code/2/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n  printf(\"%d \", arr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VladislavSmekhnov/OpenMP_tasks/openmp_7/0"}
{"code": "for (int j = 124; j < 125; j++)\n  a = 1;\n\n", "pragma": "\t#pragma omp parallel for shared(b, a, d) period(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/Test/omp_test/0"}
{"code": "for (pixel = 0; pixel < n_pixels; pixel++)\n{\n  min_cluster = labels[pixel];\n  for (channel = 0; channel < n_channels; channel++)\n  {\n    data[(pixel * n_channels) + channel] = (byte_t) round(centers[(min_cluster * n_channels) + channel]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(pixel, channel, min_cluster)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blarc/image-compression-k-means/src/compression_omp/3"}
{"code": "for (int i = 0; i < _row_size; i++)\n{\n  x[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSROpenMP/2"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, Q, (MPI_Datatype) 0x4c000406, T, Q, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((Q * M_max) / (1.0 * (L * L))) - 1) / ((double) (Q - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/62"}
{"code": "for (unsigned int i = 0; i < (sizeof(__m256i)); i++)\n{\n  (sstr << ((int) values[i])) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-neumann/versalignLib/src/Kernels/AVX-SSE/AVXKernel/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  int plen = strlen(saved_key[index]);\n  unsigned char key[64];\n  unsigned char out[64];\n  if (cur_salt->type == 1)\n  {\n    SHA_CTX ctx;\n    if (plen < 20)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 20 - plen);\n    }\n    else\n      if (plen == 20)\n    {\n      memcpy(key, saved_key[index], 20);\n    }\n    else\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, saved_key[index], plen);\n      SHA1_Final(key, &ctx);\n    }\n\n\n    hmac_sha1(key, 20, cur_salt->salt, cur_salt->salt_length + 20, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    SHA256_CTX ctx;\n    if (plen < SHA256_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, SHA256_DIGEST_LENGTH - plen);\n    }\n    else\n      if (plen == SHA256_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], SHA256_DIGEST_LENGTH);\n    }\n    else\n    {\n      SHA256_Init(&ctx);\n      SHA256_Update(&ctx, saved_key[index], plen);\n      SHA256_Final(key, &ctx);\n    }\n\n\n    hmac_sha256(key, 32, cur_salt->salt, cur_salt->salt_length + SHA256_DIGEST_LENGTH, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    SHA512_CTX ctx;\n    if (plen < 48)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 48 - plen);\n    }\n    else\n      if (plen == 48)\n    {\n      memcpy(key, saved_key[index], 48);\n    }\n    else\n    {\n      SHA384_Init(&ctx);\n      SHA384_Update(&ctx, saved_key[index], plen);\n      SHA384_Final(key, &ctx);\n    }\n\n\n    hmac_sha384(key, 48, cur_salt->salt, cur_salt->salt_length + 48, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 4)\n  {\n    SHA512_CTX ctx;\n    if (plen < 64)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 64 - plen);\n    }\n    else\n      if (plen == 64)\n    {\n      memcpy(key, saved_key[index], 64);\n    }\n    else\n    {\n      SHA512_Init(&ctx);\n      SHA512_Update(&ctx, saved_key[index], plen);\n      SHA512_Final(key, &ctx);\n    }\n\n\n    hmac_sha512(key, 64, cur_salt->salt, cur_salt->salt_length + 64, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ospf_fmt_plug/2"}
{"code": "for (int z = 0; z < n; z++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    A_[z][i] = (rand() % ((b - a) + 1)) - a;\n    L_[z][i] = 0;\n    U_[z][i] = 0;\n    if (z == i)\n      U_[z][i] = 1;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bernishik/University_parallelProgramming/lab4/main/1"}
{"code": "for (i = 1; i < height; i++)\n  (*img)[i] = (*img)[i - 1] + width;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical1/imagenes/1"}
{"code": "for (i = 0; i <= (m + 1); i++)\n{\n  for (j = 0; j <= (n + 1); j++)\n  {\n    s[i][j] = 30.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ashish10alex/openmp-jacobi/jacobi_parallel_validation/2"}
{"code": "for (i = 0; i < graphAdjLinkedList->num_vertices; i++)\n{\n  omp_destroy_lock(&vertex_lock[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjLinkedList/3"}
{"code": "for (i = 0; i < nd; i++)\n{\n  dr[(i * nppadded) + p2] = pos[(i * nppadded) + p1] - pos[(i * nppadded) + p2];\n  d = d + (dr[(i * nppadded) + p2] * dr[(i * nppadded) + p2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MD/md_openmp/3"}
{"code": "for (int j = 1; j <= n; ++j)\n{\n  sleep_for(milliseconds(100 * j));\n}\n\n", "pragma": "#pragma omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/6openmp/6openmp/0"}
{"code": "for (int m = 0; m < Nlda; m++)\n{\n  dd = kernel_matrix_X + (lambda(m) * Ident);\n  k1 = (Ident - (kernel_matrix_X.t() * inv(dd))) * Hat_Dose;\n  upper = norm(k1, \"fro\") * norm(k1, \"fro\");\n  k2 = Ident - (kernel_matrix_X.t() * inv(dd));\n  lower = trace(k2);\n  GCV(m) = (N * upper) / (lower * lower);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/direct_pt_solver/4"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 1; j < s[i]; ++j)\n  for (k = 1; k < j; ++k)\n  a[i] += (log(j + k) * pow(b[i], 4.0)) / (n * n);\n\n\n\n", "pragma": "omp parallel for schedule(runtime) default(none) shared(n,b,s,a) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex7-imbalance-openmp/0"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (j = jst; j < ny; j++)\n    {\n      tmp = 1.0 / rsd[0][k][j][i];\n      u21j = tmp * rsd[1][k][j][i];\n      u31j = tmp * rsd[2][k][j][i];\n      u41j = tmp * rsd[3][k][j][i];\n      u51j = tmp * rsd[4][k][j][i];\n      tmp = 1.0 / rsd[0][k][j - 1][i];\n      u21jm1 = tmp * rsd[1][k][j - 1][i];\n      u31jm1 = tmp * rsd[2][k][j - 1][i];\n      u41jm1 = tmp * rsd[3][k][j - 1][i];\n      u51jm1 = tmp * rsd[4][k][j - 1][i];\n      flux_G[1][k][i][j] = ty3 * (u21j - u21jm1);\n      flux_G[2][k][i][j] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux_G[3][k][i][j] = ty3 * (u41j - u41jm1);\n      flux_G[4][k][i][j] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/11"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  hg->nhedges += tt->dims[m];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/9"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    X[i][j] = val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/6"}
{"code": "for (j = x_min - 2; j <= (x_max + 3); j++)\n{\n  vertexdx[FTNREF1D(j, x_min - 2)] = d_x;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/initialise_chunk_kernel_c/1"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  if (u_data->received_first_message)\n    continue;\n\n  while (!is_ql_queue_empty(msgs, u->label))\n  {\n    u_data->received_first_message = 1;\n    message *m = dequeue(msgs, u->label);\n    for (int j = 0; j < u->degree; j++)\n    {\n      node *v = *((node **) elem_at(&u->neighbors, j));\n      payload *v_data = v->data;\n      if (v->label == m->from)\n        continue;\n\n      if (v_data->fragment_id != u_data->fragment_id)\n      {\n        edge b = {u->label, v->label, g->adj_mat[u->label][v->label]};\n        enqueue(blues, u_data->fragment_id, &b);\n      }\n      else\n      {\n        message mx = {u->label};\n        enqueue(tmp_msgs, v->label, &mx);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/2"}
{"code": "for (thread = 0; thread < thread_count; thread++)\n{\n  pistr[thread].rank = thread;\n  pistr[thread].size = n;\n  pistr[thread].pi = pi;\n  pthread_create(&thread_handles[thread], 0, Init_pi, (void *) (&pistr[thread]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/6"}
{"code": "for (it = classCount.begin(); it != classCount.end(); it++)\n{\n  counts.push_back((double) it->second);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hafeezali/Parallel-Decision-Tree-Classifier/dtc_openmp/2"}
{"code": "for (int i = 0; i < N; i++)\n  y[i] = sin(i * h);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialFull/Difference/parallel/difference/0"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n  if (rGeometry[i].IsNot(BOUNDARY))\n  return NonContact;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %i at itr %i \\n\", omp_get_thread_num(), i);\n  x[i] = (double) i;\n}\n\n", "pragma": "omp for schedule(dynamic,8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdh266/OpenMP_Practice/array3/0"}
{"code": "for (int i = 0; i < n_variable; i++)\n{\n  (cout << val[i]) << \"\\t\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/workout3/workout3/5"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  for (int j = 0; j < size; ++j)\n  {\n    fscanf(f, \"%d\", &currentWeek[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/3"}
{"code": "for (int i = 0; i < vec.size(); i++)\n{\n  local_sum += vec[i];\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LuckThemAll/parallel-programming/OpenMP/task2/3"}
{"code": "for (i = 0; i < ilength; i += 2)\n{\n  corr += ((mixingPos[i] * compare[i]) + (mixingPos[i + 1] * compare[i + 1])) >> overlapDividerBitsNorm;\n  lnorm += ((mixingPos[i] * mixingPos[i]) + (mixingPos[i + 1] * mixingPos[i + 1])) >> overlapDividerBitsNorm;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/TDStretch/6"}
{"code": "for (col = 0; col < LX1; col++)\n{\n  temp[0][col] = tx[0][col];\n  j = 0;\n  bottom[col] = 0.0;\n  for (i = 1; i < (LX1 - 1); i++)\n  {\n    bottom[col] = bottom[col] + (qbnew[0][j][i - 1] * tx[i][col]);\n  }\n\n  for (j = 1; j < LX1; j++)\n  {\n    for (i = 1; i < (LX1 - 1); i++)\n    {\n      temp[j][col] = temp[j][col] + (qbnew[0][j][i - 1] * tx[i][col]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/21"}
{"code": "for (int row = 0; row < Max; row++)\n{\n  for (int col = 0; col < Max; col++)\n  {\n    srand(row + col);\n    A[row][col] = rand() % 1000;\n    B[row][col] = rand() % 1000;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JanetLau0310/Parallel_computing/OpenMP/SGEMM/w4/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      ru1 = rho_i[i][j][k];\n      uu = us[i][j][k];\n      vv = vs[i][j][k];\n      ww = ws[i][j][k];\n      ac = speed[i][j][k];\n      ac2inv = ainv[i][j][k] * ainv[i][j][k];\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n      t2 = (bt * ru1) * ((uu * r1) - r2);\n      t3 = ((bt * ru1) * ac) * t1;\n      rhs[0][i][j][k] = r1 - t1;\n      rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n      rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n      rhs[3][i][j][k] = (-t2) + t3;\n      rhs[4][i][j][k] = t2 + t3;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/44"}
{"code": "for (i = 0; i < 100; i++)\n{\n  v[i] = rand() % 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-zanetti/Openmp-foundmax-reduction-C/ompmaxred/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  xstart[i] = 1;\n  xend[i] = 256;\n  ystart[i] = 1;\n  yend[i] = 256;\n  zstart[i] = 1;\n  zend[i] = 128;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/27"}
{"code": "for_handler_pre(directive)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/base/tl-omp-base/0"}
{"code": "for (u_int64_t pixel = 0; pixel < image_size; pixel += 4LL)\n{\n  if (!(*images)[i][pixel + 3])\n    continue;\n\n  u_int16_t pixel_storage[3];\n  pixel_storage[0] = (*images)[i][pixel] * factor;\n  pixel_storage[1] = (*images)[i][pixel + 1] * factor;\n  pixel_storage[2] = (*images)[i][pixel + 2] * factor;\n  (*images)[i][pixel] = (pixel_storage[0] > 255) ? (255) : (pixel_storage[0]);\n  (*images)[i][pixel + 1] = (pixel_storage[1] > 255) ? (255) : (pixel_storage[1]);\n  (*images)[i][pixel + 2] = (pixel_storage[2] > 255) ? (255) : (pixel_storage[2]);\n}\n\n", "pragma": "omp parallel for shared(images)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_filtering_mpi/0"}
{"code": "for (int i = 0; i < buckets; i++)\n{\n  for (int j = 0; j < v.size(); j++)\n  {\n    if ((v[j] >= (i * bucket_interval)) && (v[j] <= ((i + 1) * bucket_interval)))\n    {\n      bs[0][i].push_back(v[j]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(bs, v, bucket_interval) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort2/0"}
{"code": "for (int i = 0; i < nel; i++)\n  (file2 << variables[i + (VAR_DENSITY_ENERGY * nelr)]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/cfd/euler3d_cpu/1"}
{"code": "for (i = 1; i < (100 + 1); i++)\n{\n  if (((i + icolor) % 2) == 0)\n  {\n    jstart = 2;\n  }\n  else\n  {\n    jstart = 1;\n  }\n\n  for (j = jstart; j < (100 + 1); j += 2)\n  {\n    U_rhs[i][j] = 0.25 * (((((h_pow * sin(((double) i) * ((double) j))) + U_rhs[i][j - 1]) + U_rhs[i - 1][j]) + U_rhs[i + 1][j]) + U_rhs[i][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, jstart)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/1"}
{"code": "for (int i = 0; i < (20 / hist_interval); i++)\n{\n  printf(\"%lu\\n\", hist_array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulwankhede/OpenMP/parallel/3"}
{"code": "for (i = 1; i < (n - 1); i += 2)\n{\n  if (a2[i] > a2[i + 1])\n  {\n    temp = a2[i + 1];\n    a2[i + 1] = a2[i];\n    a2[i] = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/17"}
{"code": "for (int z = 0; z < size; z++)\n  x[z] = 1.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adamorucu/conjugate-gradient/main/5"}
{"code": "for (int j = 0; j <= _M; j++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (_M / mpi_size)\n    bi = j / (_M / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = (bj + bi) % mpi_size;\n  st = ((mpi_size + st) - mpi_rank) % mpi_size;\n  s->rb = st * (sN / mpi_size);\n  s->re = s->rb + (sN / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = sN + 1;\n\n  for (int i = s->rb; i < s->re; i++)\n  {\n    if (i != 0)\n      r[idx(i, j, k)] += s->Mat_3d[5][idx(i, j, k)] * x[idx(i - 1, j, k)];\n\n    if (i != sN)\n      r[idx(i, j, k)] += s->Mat_3d[6][idx(i, j, k)] * x[idx(i + 1, j, k)];\n\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/146"}
{"code": "for (i = 1; i < (1 << TOTAL_KEYS_LOG_2); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/52"}
{"code": "for (int i = 0; i < (m - 1); i++)\n{\n  if ((tcap[i + 1] - tcap[i]) < Tmin)\n  {\n    Tmin = tcap[i + 1] - tcap[i];\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/RmES_omp_alt/0"}
{"code": "for (i = 1; i < (block_height - 1); i++)\n{\n  for (j = 1; j < (block_width - 1); j++)\n  {\n    r_laplass(i, j) = DiffScheme(rk, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/20"}
{"code": "for (int ix = 1; ix < (nx - 1); ix++)\n{\n  vector[ix][0][0] = vector[ix][0][nz - 2];\n  vector[ix][0][nz - 1] = vector[ix][0][1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/13"}
{"code": "for (int i = 0; i < size; i += 2)\n{\n  _mm_storeu_pd(&newVec[i], _mm_loadu_pd(&vec1[i]) - _mm_loadu_pd(&vec2[i]));\n}\n\n", "pragma": "#pragma omp parallel for shared(vec1, vec2, size, newVec, chunkSize) BASE_CLAUSE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borodun/opp/Lab2/SLAE_OpenMP_1_SSE/1"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 1; j < 20; j++)\n  for (int k = 1; k < 20; k++)\n  A[i][j][k] = A[i][j][k];\n\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/3.norace1/0"}
{"code": "for (index = 0; index < BF_N; index++)\n{\n  BF_current.P[0] ^= BF_exp_key[index][0];\n  BF_current.P[1] ^= BF_exp_key[index][1];\n  BF_current.P[2] ^= BF_exp_key[index][2];\n  BF_current.P[3] ^= BF_exp_key[index][3];\n  BF_current.P[4] ^= BF_exp_key[index][4];\n  BF_current.P[5] ^= BF_exp_key[index][5];\n  BF_current.P[6] ^= BF_exp_key[index][6];\n  BF_current.P[7] ^= BF_exp_key[index][7];\n  BF_current.P[8] ^= BF_exp_key[index][8];\n  BF_current.P[9] ^= BF_exp_key[index][9];\n  BF_current.P[10] ^= BF_exp_key[index][10];\n  BF_current.P[11] ^= BF_exp_key[index][11];\n  BF_current.P[12] ^= BF_exp_key[index][12];\n  BF_current.P[13] ^= BF_exp_key[index][13];\n  BF_current.P[14] ^= BF_exp_key[index][14];\n  BF_current.P[15] ^= BF_exp_key[index][15];\n  BF_current.P[16] ^= BF_exp_key[index][16];\n  BF_current.P[17] ^= BF_exp_key[index][17];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/19"}
{"code": "for (int i = 0; i < shared_size; i++)\n{\n  clusters[i % num_of_clusters].num_of_points += shared_clusters[i].num_of_points;\n  clusters[i % num_of_clusters].sum_of_points.x += shared_clusters[i].sum_of_points.x;\n  clusters[i % num_of_clusters].sum_of_points.y += shared_clusters[i].sum_of_points.y;\n  clusters[i % num_of_clusters].sum_of_points.z += shared_clusters[i].sum_of_points.z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/10"}
{"code": "for (j = 0; j < nx; j++)\n{\n  v_cu = _mm_add_ps(_mm_load_ps(&cu[4 * j]), _mm_load_ps(&cu[(4 * j) + kk]));\n  _mm_store_ps(&cu[4 * j], v_cu);\n  _mm_store_ps(&cu[(4 * j) + kk], _mm_setzero_ps());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/24"}
{"code": "for (i = 0; i < 100000; i++)\n  fscanf(fptr, \"%d\", &ex[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/4"}
{"code": "for (i = 0; i < 4; i++)\n{\n  y[i]++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/ompt/synchronization/barrier/for_loop/0"}
{"code": "for (int i = 0; i < length; ++i)\n{\n  avg += data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/10"}
{"code": "for (i = 1; i <= m; i++)\n{\n  y[i] = sqrt_func(z[i]);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny04/ocl_tiny04/tiny04/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpa06rhb5g.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/unibas-dmi-hpc/LB4OMP/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv18_data[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv18_data[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv18[layer18_index];\n    if (conv18_data[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv18_data[(((layer18_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/68"}
{"code": "for (k = 0; k < num_possible_vaules; k++)\n{\n  copy_table(taules[k].taula, taula);\n  taules[k].taula[i][j] = possible_vaules[k];\n  taules[k].i = i;\n  taules[k].j = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/13"}
{"code": "for (i = 0; i < pages; i++)\n{\n  y[i] *= 1 - factor;\n  y[i] += factor * (1.0 / pages);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mithradatha/parallel-pagerank/sparse_omp/1"}
{"code": "for (unsigned int i = 0; i < size; i++)\n  fwrite(&scan.intensities[i], sizeof(float), 1, laserfile);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/slam_gmapping/8"}
{"code": "for (iside = 0; iside <= 2; ++iside)\n{\n  if ((*triVerts)[iside] == ivert)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/SurfMeshSmooth/Mesh/0"}
{"code": "for (i = 0; i < n2; i++)\n{\n  k = index2[i];\n  for (j = 0; j < ncolumns; j++)\n    if (mask[k][j] != 0)\n  {\n    cdata[1][j] = cdata[1][j] + data[k][j];\n    count[1][j] = count[1][j] + 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/115"}
{"code": "for (*pos = myNode->count; (val < myNode->val[*pos]) && ((*pos) > 1); (*pos)--)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Bigtable-in-C/B-tree/5"}
{"code": "for (it = 0; it < num_its; it++)\n{\n  if ((devtype == OMP_DEVICE_THSIM) || (devtype == OMP_DEVICE_HOSTCPU))\n  {\n    int ix;\n    int iy;\n    int iz;\n    int ir;\n    for (ix = start; ix < (start + len); ix++)\n    {\n      REAL *temp_u = &u[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n      REAL *temp_uold = &uold[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n      for (iy = 0; iy < m; iy++)\n      {\n        for (iz = 0; iz < k; iz++)\n        {\n          REAL result = temp_uold[0] * coeff[0];\n          for (ir = 1; ir <= radius; ir++)\n          {\n            result += coeff[ir] * temp_uold[ir];\n            result += coeff[-ir] * temp_uold[-ir];\n            result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n            result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n            result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimZ];\n            result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimZ];\n          }\n\n          *temp_u = result / count;\n          temp_u++;\n          temp_uold++;\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"device type is not supported for this call\\n\");\n  }\n\n  pthread_barrier_wait(&off->off_info->inter_dev_barrier);\n  if ((it % 2) == 0)\n    omp_halo_region_pull(map_u, 0, OMP_DATA_MAP_EXCHANGE_FROM_LEFT_RIGHT);\n  else\n    omp_halo_region_pull(map_uold, 0, OMP_DATA_MAP_EXCHANGE_FROM_LEFT_RIGHT);\n\n  REAL *tmp = uold;\n  uold = u;\n  u = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/stencil3d/kernel_launcher/0"}
{"code": "for (i = 0; i < 32; i++)\n{\n  for (j = 0; j < 32; j++)\n  {\n    C[(i * 32) + j] = (((DATA_TYPE) i) * (j + 3)) / 32;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/30"}
{"code": "for (j = 0; j < stream_size; j++)\n{\n  num_error += MAX(ABS(a[j] - aj) > epsilon, num_error);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Refcount/refcount/4"}
{"code": "for (size_t i = 0; i < arguments.reps_per_iteration; i++)\n{\n  f1 = f2 * 1.1f;\n}\n\n", "pragma": "omp parallel for private(f1,f2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-programming-hwr/benchmark-openMP/main/0"}
{"code": "for (i = 0; i < r_count; i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/szorbasc/OpenMP-CSR-matrix-vector-multiplication/mat_mult/0"}
{"code": "for (i = 1; i < 23; i++)\n{\n  allocMem[i] = allocMem[i - 1] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmemspd/memSpeedOMP/9"}
{"code": "for (i = 0; i < inLen; ++i)\n  input[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/plusplus-orig-yes/1"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  tmp_res += (f(start + (i * dx)) + f(start + ((i + 1) * dx))) / 2;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail189/MPI_OpenMP/openmp_3/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  {\n    m[i] = rand() % 1000;\n    printf(\"%d \", m[i]);\n  }\n  if (k == 10)\n  {\n    printf(\"\\n\");\n    k = 0;\n  }\n  else\n    k++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Karantir73/OpenMP-lab/task12/0"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    mass_flux_y[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = -mass_flux_y[FTNREF2D(j, 1 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/56"}
{"code": "for (int i = 0; i < n; i++)\n{\n  m[i] = (float *) aligned_alloc((32 * n) * (sizeof(float *)), 32);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/22"}
{"code": "for (i = 0; i < contIndex; i++)\n{\n  printf(\"%d\\n\", matrixIndex[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ismtabo/cp-2017-scan-sky/omp/ScanSky/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  (((((((((cout << \"a[\") << i) << \"] = \") << a[i]) << \",  \") << \"b[\") << i) << \"] = \") << b[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gabarnettjr/learningOpenmp/basicExample/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  orden[i] = omp_get_thread_num();\n  suma = suma + a[i];\n  printf(\" thread %d suma a[%d]=%d suma=%d \\n\", omp_get_thread_num(), i, a[i], suma);\n}\n\n", "pragma": "omp parallel for num_threads(3) firstprivate(suma) lastprivate(suma) schedule(runtime)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer2/scheduler-clauseModificado/0"}
{"code": "for (i = 0; i < _PB_N; i++)\n  for (j = 0; j < _PB_N; j++)\n  x[i] = x[i] + ((beta * A[j][i]) * y[j]);\n\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gemver/gemver/1"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < baz(&i); j++)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/30"}
{"code": "for (size_t i = 0; i < constant_size; ++i)\n  send_reqs[i] = MPI_REQUEST_NULL;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/30"}
{"code": "for (int i = 0; i < sectionSize; ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    bucket1[(iArray[i][j] / iExp) % 10]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/16"}
{"code": "for (i = 0; i < N; i++)\n{\n  b[i] = cos(i * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/12"}
{"code": "for (i = length + 1; i < argc; i++)\n{\n  j = (i - length) - 1;\n  out = argv[i];\n  hDOut[j] = GDALCreateCopy(hDr, out, hD[0], FALSE, options, 0, 0);\n  hBOut[j] = GDALGetRasterBand(hDOut[j], 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_filling/main/2"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  xold[i] = (TYPE) 0.0;\n  for (int j = 0; j < Ndim; j++)\n    xold[i] += A[(i * Ndim) + j] * xnew[j];\n\n  TYPE tmp = xold[i] - b[i];\n  chksum += xnew[i];\n  err += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_nobr/1"}
{"code": "for (j = 0; j < N; ++j)\n{\n  suma += m[i][j] * v1[j];\n}\n\n", "pragma": "omp parallel for reduction(+:suma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/10/pvm-OpenMP-reduction/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float temp = 0.0;\n    for (int k = 0; k < N; k++)\n    {\n      temp += A[(i * N) + k] * B[(k * N) + j];\n    }\n\n    C[(i * N) + j] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Masa-731/OpenMP-vs-OpenACC/matrixmul/openmp-cpu/0"}
{"code": "for (i = populationPhi - 1; i >= elitePhi; --i)\n{\n  comparisionResultsPhi[i] = Comparison(comparisionResultsPhi[i].index, CalculateValueOfImage(imagesRectanglesPhi + (comparisionResultsPhi[i].index * MAX_NUMBER_OF_RECTANGLES), width, height, outputImagesPhi + th_id, nativeImagePhi));\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/9"}
{"code": "for (i = Low_h / 2; i < (Low_h - 2); i++)\n{\n  for (j = (Low_w / 4) * 3; j < Low_w; j++)\n  {\n    bicubic_Y_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Y[(i * Low_w) + j])) + (bicubic2[1][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Y_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Y[(i * Low_w) + j])) + (bicubic2[0][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (percentDiff(x1[i], x1_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n  if (percentDiff(x2[i], x2_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/MVT/mvt/5"}
{"code": "for (row = 1; row <= bheight; row++)\n{\n  for (col = 1; col <= bwidth; col++)\n  {\n    boardArr2[(row * (bwidth + 2)) + col] = boardArr[((row - 1) * bwidth) + (col - 1)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hanneshoettinger/GameOfLife-Sequential-OpenMP-OpenCL/GameOfLife/GameOfLife/0"}
{"code": "for (i = N - 2; i >= 1; i--)\n{\n  for (j = i + 2; j <= N; j++)\n  {\n    for (k = i; k <= (j - l); k++)\n    {\n      ck[i][j] += (ck[i][j - 1] + paired(k, j)) ? (ck[i][k - 1] + ck[k + 1][j - 1]) : (0);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/counting/counting/6"}
{"code": "for (int i = n - 1; i >= 0; i--)\n{\n  x[i] = A[i][n] / A[i][i];\n  for (int k = i - 1; k >= 0; k--)\n  {\n    A[k][n] -= A[k][i] * x[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/17"}
{"code": "for (j = 0; j < _PB_N; j++)\n  y[j] = y[j] + (A[i][j] * tmp[i]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/atax/atax/2"}
{"code": "for (i = 0; i < hour_iteration; i++)\n{\n  day = i / 24;\n  hour = i % 24;\n  if ((day > 0) && (hour == 0))\n  {\n    my_meas = my_meas->next;\n    if (my_meas == 0)\n    {\n      printf(\"ERROR\\tThere is no measurement for:\\n\\tDay %d - Hour %d - House %d\\n\", day, hour, my_house->id);\n    }\n\n  }\n\n  printf(\"House: %d - Day: %d - Hour: %d -  Over mean: %.2f%%\\n\", my_house->id, day + 1, hour, my_meas->over_mean[hour] * 100);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/24"}
{"code": "for (i = 0; i < P; i++)\n{\n  localFrontierQueues[i] = newArrayQueue(graph->num_vertices);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shreyas097/Parallel-BFS-with-Push-Pull-operation-using-queue-bitmap-using-OpenMP/code/src/bfs/2"}
{"code": "for (i = 1; i < size; ++i)\n{\n  if (a[i - 1] > a[i])\n  {\n    (cout << \"FAILED: Numbers are not sorted!!!\") << endl;\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_quicksort/run/2"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/31"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  a1[i] = s;\n  a2[i] = i;\n  s = -s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.50.1/1"}
{"code": "for (m = 0; m < ki; m = m + inc)\n{\n  xi[m] = xi[m] + yi[m];\n  xi[m + 1] = xi[m + 1] + yi[m + 1];\n  xi[m + 2] = xi[m + 2] + yi[m + 2];\n  xi[m + 3] = xi[m + 3] + yi[m + 3];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmemspd/memSpeedOMP/5"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    C[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atanu151/Matrix-Multiplication/main/11"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int j = 0; j < DIM; j++)\n    for (int i = 0; i < (DIM - 1); i++)\n    next_img(i, j) = cur_img(i + 1, j);\n\n\n  for (int j = 0; j < DIM; j++)\n    next_img(DIM - 1, j) = cur_img(0, j);\n\n  swap_images();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/scrollup/2"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < M; j++)\n  c[i] += a[(i * N) + j] * b[j];\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubhams167/intro-to-OpenMP/OMP - MatrixVectorProduct/0"}
{"code": "for (i = 0; i < _PB_NI; i++)\n  for (j = 0; j < _PB_NJ; j++)\n{\n  E[i][j] = 0;\n  for (k = 0; k < _PB_NK; ++k)\n    E[i][j] += A[i][k] * B[k][j];\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/3mm/3mm/0"}
{"code": "for (k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    xvel1[FTNREF2D((x_max + 1) + j, k, x_max + 5, x_min - 2, y_min - 2)] = -xvel1[FTNREF2D((x_max + 1) - j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/35"}
{"code": "for (int k = 0; k < 1000000; ++k)\n{\n  sum += arr[k];\n}\n\n", "pragma": "omp parallel for num_threads(3) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/lab6ex2/0"}
{"code": "for (int Ti = -1; Ti <= (R / 32); Ti = Ti + 1)\n{\n  float Iy[34][258];\n  float Ix[34][258];\n  for (int Tj = -1; Tj <= (C / 256); Tj = Tj + 1)\n  {\n    int _ct0 = (R < ((32 * Ti) + 33)) ? (R) : ((32 * Ti) + 33);\n    int _ct1 = (1 > (32 * Ti)) ? (1) : (32 * Ti);\n    int _ct2 = (C < ((256 * Tj) + 257)) ? (C) : ((256 * Tj) + 257);\n    int _ct3 = (1 > (256 * Tj)) ? (1) : (256 * Tj);\n    for (int _i0 = _ct1; _i0 <= _ct0; _i0 = _i0 + 1)\n    {\n      #pragma ivdep\n      for (int _i1 = _ct3; _i1 <= _ct2; _i1 = _i1 + 1)\n      {\n        Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] = (((((img[(((-1) + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f)) + (img[(((-1) + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f)) + (img[(_i0 * (C + 2)) + ((-1) + _i1)] * (-0.166666666667f))) + (img[(_i0 * (C + 2)) + (1 + _i1)] * 0.166666666667f)) + (img[((1 + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f))) + (img[((1 + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f);\n      }\n\n    }\n\n    for (int _i0 = _ct1; _i0 <= _ct0; _i0 = _i0 + 1)\n    {\n      #pragma ivdep\n      for (int _i1 = _ct3; _i1 <= _ct2; _i1 = _i1 + 1)\n      {\n        Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] = (((((img[(((-1) + _i0) * (C + 2)) + ((-1) + _i1)] * (-0.0833333333333f)) + (img[((1 + _i0) * (C + 2)) + ((-1) + _i1)] * 0.0833333333333f)) + (img[(((-1) + _i0) * (C + 2)) + _i1] * (-0.166666666667f))) + (img[((1 + _i0) * (C + 2)) + _i1] * 0.166666666667f)) + (img[(((-1) + _i0) * (C + 2)) + (1 + _i1)] * (-0.0833333333333f))) + (img[((1 + _i0) * (C + 2)) + (1 + _i1)] * 0.0833333333333f);\n      }\n\n    }\n\n    int _ct8 = ((R - 1) < ((32 * Ti) + 32)) ? (R - 1) : ((32 * Ti) + 32);\n    int _ct9 = (2 > ((32 * Ti) + 1)) ? (2) : ((32 * Ti) + 1);\n    for (int _i0 = _ct9; _i0 <= _ct8; _i0 = _i0 + 1)\n    {\n      int _ct10 = ((C - 1) < ((256 * Tj) + 256)) ? (C - 1) : ((256 * Tj) + 256);\n      int _ct11 = (2 > ((256 * Tj) + 1)) ? (2) : ((256 * Tj) + 1);\n      #pragma ivdep\n      for (int _i1 = _ct11; _i1 <= _ct10; _i1 = _i1 + 1)\n      {\n        harris[(_i0 * (2 + C)) + _i1] = (((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) * (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)]))) - ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) * (((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])))) - ((0.04f * ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])))) * ((((((((((Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Ix[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Ix[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Ix[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Ix[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (((((((((Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)]) + (Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[(-1) + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[(-1) + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][(-1) + (((-256) * Tj) + _i1)])) + (Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1] * Iy[((-32) * Ti) + _i0][((-256) * Tj) + _i1])) + (Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)] * Iy[((-32) * Ti) + _i0][1 + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][(-1) + (((-256) * Tj) + _i1)])) + (Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1] * Iy[1 + (((-32) * Ti) + _i0)][((-256) * Tj) + _i1])) + (Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)] * Iy[1 + (((-32) * Ti) + _i0)][1 + (((-256) * Tj) + _i1)]))));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage/0"}
{"code": "for (idx_t j = jbegin; j < jend; ++j)\n{\n  idx_t idx = tt->ind[m][j];\n  ++histogram[idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/12"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  newc[iel] = 0;\n  newe[iel] = 0;\n  newi[iel] = 0;\n  cb1 = cbc[iel][0];\n  cb2 = cbc[iel][1];\n  cb3 = cbc[iel][2];\n  cb4 = cbc[iel][3];\n  cb5 = cbc[iel][4];\n  cb6 = cbc[iel][5];\n  if (cb6 == 0)\n  {\n    if ((cb4 == 0) || (cb4 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][10] = 1;\n    }\n\n    if (cb1 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][0] = 1;\n    }\n\n    if (cb3 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][8] = 1;\n    }\n\n    if ((cb2 == 0) || (cb2 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][4] = 1;\n    }\n\n  }\n  else\n    if (cb6 == 1)\n  {\n    if (cb4 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][10] = 1;\n    }\n    else\n      if (cb4 == 1)\n    {\n      ntemp = sje[iel][3][0][0];\n      if ((cbc[ntemp][5] != 3) || (sje[ntemp][5][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][10] = 1;\n        if (cbc[ntemp][5] == 2)\n        {\n          diagn[iel][10][0] = sje[ntemp][5][0][0];\n          diagn[iel][10][1] = ijel[iel][5][1];\n          ncon_edge[sje[ntemp][5][0][0]][9] = 1;\n          if_1_edge[iel][10] = 1;\n        }\n\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] > iel))\n        {\n          diagn[iel][10][0] = sje[ntemp][5][ijel[iel][5][1]][1];\n        }\n\n      }\n\n    }\n\n\n    if (cb1 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][0] = 1;\n    }\n    else\n      if (cb1 == 1)\n    {\n      ntemp = sje[iel][0][0][0];\n      if ((cbc[ntemp][5] != 3) || (sje[ntemp][5][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][0] = 1;\n        if (cbc[ntemp][5] == 2)\n        {\n          diagn[iel][0][0] = sje[ntemp][5][0][0];\n          diagn[iel][0][1] = ijel[iel][5][0];\n          ncon_edge[sje[ntemp][5][0][0]][6] = 1;\n          if_1_edge[iel][0] = 1;\n        }\n\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] > iel))\n        {\n          diagn[iel][0][0] = sje[ntemp][5][0][ijel[iel][5][0]];\n        }\n\n      }\n\n    }\n    else\n      if (cb1 == 2)\n    {\n      if (ijel[iel][5][1] == 1)\n      {\n        ntemp = sje[iel][0][0][0];\n        if (cbc[ntemp][5] == 1)\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][0] = 1;\n        }\n        else\n        {\n          if (sje[ntemp][5][0][0] > iel)\n          {\n            newe[iel] = newe[iel] + 1;\n            eassign[iel][0] = 1;\n            diagn[iel][0][0] = sje[ntemp][5][0][0];\n          }\n\n        }\n\n      }\n      else\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][0] = 1;\n      }\n\n    }\n\n\n\n    if (cb3 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][8] = 1;\n    }\n    else\n      if (cb3 == 1)\n    {\n      ntemp = sje[iel][2][0][0];\n      if ((cbc[ntemp][5] != 3) || (sje[ntemp][5][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][8] = 1;\n        if (cbc[ntemp][5] == 2)\n        {\n          diagn[iel][8][0] = sje[ntemp][5][0][0];\n          diagn[iel][8][1] = ijel[iel][5][1];\n          ncon_edge[sje[ntemp][5][0][0]][11] = 1;\n          if_1_edge[iel][8] = 1;\n        }\n\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] > iel))\n        {\n          diagn[iel][8][0] = sje[ntemp][5][ijel[iel][5][1]][1];\n        }\n\n      }\n\n    }\n    else\n      if (cb3 == 2)\n    {\n      if (ijel[iel][5][0] == 1)\n      {\n        ntemp = sje[iel][2][0][0];\n        if (cbc[ntemp][5] == 1)\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][8] = 1;\n        }\n        else\n        {\n          if (sje[ntemp][5][0][0] > iel)\n          {\n            newe[iel] = newe[iel] + 1;\n            eassign[iel][8] = 1;\n            diagn[iel][8][0] = sje[ntemp][5][0][0];\n          }\n\n        }\n\n      }\n      else\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][8] = 1;\n      }\n\n    }\n\n\n\n    if (cb2 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][4] = 1;\n    }\n    else\n      if (cb2 == 1)\n    {\n      ntemp = sje[iel][1][0][0];\n      if ((cbc[ntemp][5] != 3) || (sje[ntemp][5][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][4] = 1;\n        if (cbc[ntemp][5] == 2)\n        {\n          diagn[iel][4][0] = sje[ntemp][5][0][0];\n          diagn[iel][4][1] = ijel[iel][5][0];\n          ncon_edge[sje[ntemp][5][0][0]][2] = 1;\n          if_1_edge[iel][4] = 1;\n        }\n\n        if ((cbc[ntemp][5] == 3) && (sje[ntemp][5][0][0] > iel))\n        {\n          diagn[iel][8][0] = sje[ntemp][5][ijel[iel][5][1]][1];\n        }\n\n      }\n\n    }\n\n\n  }\n\n\n  if (cb4 == 0)\n  {\n    if (cb1 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][3] = 1;\n    }\n\n    if (cb5 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][11] = 1;\n    }\n\n    if ((cb2 == 0) || (cb2 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][7] = 1;\n    }\n\n  }\n  else\n    if (cb4 == 1)\n  {\n    if (cb1 == 2)\n    {\n      if (ijel[iel][3][1] == 0)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][3] = 1;\n      }\n      else\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][0] != 3) || (sje[ntemp][0][0][0] > iel))\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][3] = 1;\n          if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] > iel))\n          {\n            diagn[iel][3][0] = sje[ntemp][0][1][ijel[iel][3][0]];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (cb1 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][3] = 1;\n    }\n    else\n      if (cb1 == 1)\n    {\n      ntemp = sje[iel][3][0][0];\n      if ((cbc[ntemp][0] != 3) || (sje[ntemp][0][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][3] = 1;\n        if (cbc[ntemp][0] == 2)\n        {\n          diagn[iel][3][0] = sje[ntemp][0][0][0];\n          diagn[iel][3][1] = ijel[iel][3][0];\n          ncon_edge[sje[ntemp][0][0][0]][5] = 1;\n          if_1_edge[iel][3] = 1;\n        }\n\n        if ((cbc[ntemp][0] == 3) && (sje[ntemp][0][0][0] > iel))\n        {\n          diagn[iel][3][0] = sje[ntemp][0][1][ijel[iel][3][0]];\n        }\n\n      }\n\n    }\n\n\n\n    if (cb5 == 2)\n    {\n      if (ijel[iel][3][0] == 0)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][11] = 1;\n      }\n      else\n      {\n        ntemp = sje[iel][3][0][0];\n        if ((cbc[ntemp][4] != 3) || (sje[ntemp][4][0][0] > iel))\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][11] = 1;\n          if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] > iel))\n          {\n            diagn[iel][11][0] = sje[ntemp][4][ijel[iel][3][1]][1];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (cb5 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][11] = 1;\n    }\n    else\n      if (cb5 == 1)\n    {\n      ntemp = sje[iel][3][0][0];\n      if ((cbc[ntemp][4] != 3) || (sje[ntemp][4][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][11] = 1;\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][11][0] = sje[ntemp][4][0][0];\n          diagn[iel][11][1] = ijel[iel][3][1];\n          ncon_edge[sje[ntemp][4][0][0]][8] = 1;\n          if_1_edge[iel][11] = 1;\n        }\n\n        if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] > iel))\n        {\n          diagn[iel][11][0] = sje[ntemp][4][ijel[iel][3][1]][1];\n        }\n\n      }\n\n    }\n\n\n\n    if (cb2 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][7] = 1;\n    }\n    else\n      if (cb2 == 1)\n    {\n      ntemp = sje[iel][3][0][0];\n      if ((cbc[ntemp][1] != 3) || (sje[ntemp][1][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][7] = 1;\n        if (cbc[ntemp][1] == 2)\n        {\n          diagn[iel][7][0] = sje[ntemp][1][0][0];\n          diagn[iel][7][1] = ijel[iel][3][0];\n          ncon_edge[sje[ntemp][1][0][0]][1] = 1;\n          if_1_edge[iel][7] = 1;\n        }\n\n        if ((cbc[ntemp][1] == 3) && (sje[ntemp][1][0][0] > iel))\n        {\n          diagn[iel][7][0] = sje[ntemp][2][1][ijel[iel][3][0]];\n        }\n\n      }\n\n    }\n\n\n  }\n\n\n  if (cb2 == 0)\n  {\n    if (cb3 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][5] = 1;\n    }\n\n    if (cb5 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][6] = 1;\n    }\n\n  }\n  else\n    if (cb2 == 1)\n  {\n    if (cb3 == 2)\n    {\n      if (ijel[iel][1][1] == 0)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][5] = 1;\n      }\n      else\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][2] != 3) || (sje[ntemp][2][0][0] > iel))\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][5] = 1;\n          if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] > iel))\n          {\n            diagn[iel][5][0] = sje[ntemp][2][1][ijel[iel][1][0]];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (cb3 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][5] = 1;\n    }\n    else\n      if (cb3 == 1)\n    {\n      ntemp = sje[iel][1][0][0];\n      if ((cbc[ntemp][2] != 3) || (sje[ntemp][2][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][5] = 1;\n        if (cbc[ntemp][2] == 2)\n        {\n          diagn[iel][5][0] = sje[ntemp][2][0][0];\n          diagn[iel][5][1] = ijel[iel][1][0];\n          ncon_edge[sje[ntemp][2][0][0]][3] = 1;\n          if_1_edge[iel][5] = 1;\n        }\n\n        if ((cbc[ntemp][2] == 3) && (sje[ntemp][2][0][0] > iel))\n        {\n          diagn[iel][5][0] = sje[ntemp][2][1][ijel[iel][3][0]];\n        }\n\n      }\n\n    }\n\n\n\n    if (cb5 == 2)\n    {\n      if (ijel[iel][1][0] == 0)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][6] = 1;\n      }\n      else\n      {\n        ntemp = sje[iel][1][0][0];\n        if ((cbc[ntemp][4] != 3) || (sje[ntemp][4][0][0] > iel))\n        {\n          newe[iel] = newe[iel] + 1;\n          eassign[iel][6] = 1;\n          if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] > iel))\n          {\n            diagn[iel][6][0] = sje[ntemp][4][1][ijel[iel][1][1]];\n          }\n\n        }\n\n      }\n\n    }\n    else\n      if (cb5 == 0)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][6] = 1;\n    }\n    else\n      if (cb5 == 1)\n    {\n      ntemp = sje[iel][1][0][0];\n      if ((cbc[ntemp][4] != 3) || (sje[ntemp][4][0][0] > iel))\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][6] = 1;\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][6][0] = sje[ntemp][4][0][0];\n          diagn[iel][6][1] = ijel[iel][1][1];\n          ncon_edge[sje[ntemp][4][0][0]][0] = 1;\n          if_1_edge[iel][6] = 1;\n        }\n\n        if ((cbc[ntemp][4] == 3) && (sje[ntemp][4][0][0] > iel))\n        {\n          diagn[iel][6][0] = sje[ntemp][4][ijel[iel][3][1]][1];\n        }\n\n      }\n\n    }\n\n\n\n  }\n\n\n  if (cb1 == 1)\n  {\n    newe[iel] = newe[iel] + 2;\n    eassign[iel][1] = 1;\n    if (cb3 == 1)\n    {\n      ntemp = sje[iel][0][0][0];\n      if (cbc[ntemp][2] == 2)\n      {\n        diagn[iel][1][0] = sje[ntemp][2][0][0];\n        diagn[iel][1][1] = ijel[iel][0][0];\n        ncon_edge[sje[ntemp][2][0][0]][7] = 1;\n        if_1_edge[iel][1] = 1;\n      }\n      else\n        if (cbc[ntemp][2] == 3)\n      {\n        diagn[iel][1][0] = sje[ntemp][2][0][ijel[iel][0][0]];\n      }\n\n\n    }\n    else\n      if (cb3 == 2)\n    {\n      ntemp = sje[iel][2][0][0];\n      if (ijel[iel][0][1] == 1)\n      {\n        if (cbc[ntemp][0] == 2)\n        {\n          diagn[iel][1][0] = sje[ntemp][0][0][0];\n        }\n\n      }\n\n    }\n\n\n    eassign[iel][2] = 1;\n    if (cb5 == 1)\n    {\n      ntemp = sje[iel][0][0][0];\n      if (cbc[ntemp][4] == 2)\n      {\n        diagn[iel][2][0] = sje[ntemp][4][0][0];\n        diagn[iel][2][1] = ijel[iel][0][1];\n        ncon_edge[sje[ntemp][4][0][0]][4] = 1;\n        if_1_edge[iel][2] = 1;\n      }\n      else\n        if (cbc[ntemp][4] == 3)\n      {\n        diagn[iel][2][0] = sje[ntemp][4][0][ijel[iel][0][1]];\n      }\n\n\n    }\n    else\n      if (cb5 == 2)\n    {\n      ntemp = sje[iel][4][0][0];\n      if (ijel[iel][0][0] == 1)\n      {\n        if (cbc[ntemp][0] == 2)\n        {\n          diagn[iel][2][0] = sje[ntemp][0][0][0];\n        }\n\n      }\n\n    }\n\n\n  }\n  else\n    if (cb1 == 2)\n  {\n    if (cb3 == 2)\n    {\n      ntemp = sje[iel][0][0][0];\n      if (cbc[ntemp][2] != 3)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][1] = 1;\n        if (cbc[ntemp][2] == 2)\n        {\n          diagn[iel][1][0] = sje[ntemp][2][0][0];\n        }\n\n      }\n\n    }\n    else\n      if ((cb3 == 0) || (cb3 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][1] = 1;\n      if (cb3 == 1)\n      {\n        ntemp = sje[iel][0][0][0];\n        if (cbc[ntemp][2] == 2)\n        {\n          diagn[iel][1][0] = sje[ntemp][2][0][0];\n        }\n\n      }\n\n    }\n\n\n    if (cb5 == 2)\n    {\n      ntemp = sje[iel][0][0][0];\n      if (cbc[ntemp][4] != 3)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][2] = 1;\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][2][0] = sje[ntemp][4][0][0];\n        }\n\n      }\n\n    }\n    else\n      if ((cb5 == 0) || (cb5 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][2] = 1;\n      if (cb5 == 1)\n      {\n        ntemp = sje[iel][0][0][0];\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][2][0] = sje[ntemp][4][0][0];\n        }\n\n      }\n\n    }\n\n\n  }\n  else\n    if (cb1 == 0)\n  {\n    if (cb3 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][1] = 1;\n    }\n\n    if (cb5 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][2] = 1;\n    }\n\n  }\n\n\n\n  if (cb3 == 1)\n  {\n    newe[iel] = newe[iel] + 1;\n    eassign[iel][9] = 1;\n    if (cb5 == 1)\n    {\n      ntemp = sje[iel][2][0][0];\n      if (cbc[ntemp][4] == 2)\n      {\n        diagn[iel][9][0] = sje[ntemp][4][0][0];\n        diagn[iel][9][1] = ijel[iel][2][1];\n        ncon_edge[sje[ntemp][4][0][0]][10] = 1;\n        if_1_edge[iel][9] = 1;\n      }\n\n    }\n\n    if (ijel[iel][2][0] == 1)\n    {\n      ntemp = sje[iel][2][0][0];\n      if (cbc[ntemp][4] == 3)\n      {\n        diagn[iel][9][0] = sje[ntemp][4][ijel[iel][2][1]][0];\n      }\n\n    }\n\n  }\n  else\n    if (cb3 == 2)\n  {\n    if (cb5 == 2)\n    {\n      ntemp = sje[iel][2][0][0];\n      if (cbc[ntemp][4] != 3)\n      {\n        newe[iel] = newe[iel] + 1;\n        eassign[iel][9] = 1;\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][9][0] = sje[ntemp][4][0][0];\n        }\n\n      }\n\n    }\n    else\n      if ((cb5 == 0) || (cb5 == 1))\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][9] = 1;\n      if (cb5 == 1)\n      {\n        ntemp = sje[iel][2][0][0];\n        if (cbc[ntemp][4] == 2)\n        {\n          diagn[iel][9][0] = sje[ntemp][4][0][0];\n        }\n\n      }\n\n    }\n\n\n  }\n  else\n    if (cb3 == 0)\n  {\n    if (cb5 != 3)\n    {\n      newe[iel] = newe[iel] + 1;\n      eassign[iel][9] = 1;\n    }\n\n  }\n\n\n\n  if ((cb6 == 1) || (cb6 == 0))\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][5] = 1;\n  }\n\n  if ((cb4 == 1) || (cb4 == 0))\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][3] = 1;\n  }\n\n  if ((cb2 == 1) || (cb2 == 0))\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][1] = 1;\n  }\n\n  if (cb1 != 3)\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][0] = 1;\n  }\n\n  if (cb3 != 3)\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][2] = 1;\n  }\n\n  if (cb5 != 3)\n  {\n    newi[iel] = newi[iel] + 9;\n    fassign[iel][4] = 1;\n  }\n\n  newc[iel] = (newe[iel] * 3) + newi[iel];\n}\n\n", "pragma": "omp parallel for default(shared) private(iel,cb1,cb2,cb3,cb4,cb5 ,cb6,ntemp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/3"}
{"code": "for (int i = 1; i < 256; i++)\n{\n  sum += histogram[i];\n  cdf[i] = sum;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlessandroLemmo/Histogram-Equalization-OpenMP/HistogramEqualizationOpenMP/main/1"}
{"code": "for (i = 1; i < n; i++)\n{\n  if (b[i] != (2 * i))\n  {\n    errors += 1;\n    if (errors == 1)\n      printf(\"parallel for - VALUES IN B ARE NOT AS EXPECTED\\n\");\n\n    printf(\"EXPECTED B[%d] = %d OBSERVED %d\\n\", i, 2 * i, b[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny01/ocl_tiny01/tiny01/2"}
{"code": "for (i = 1; i <= 46; i += 1)\n{\n  R46 = 0.50 * R46;\n  T46 = 2.0 * T46;\n}\n\n", "pragma": "omp parallel for private (i) reduction (*:R46,T46)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  count = 0;\n  for (j = 0; j < n; ++j)\n    if (a[j] < a[i])\n    count++;\n  else\n    if ((a[j] == a[i]) && (j < i))\n    count++;\n\n\n\n  temp[count] = a[i];\n}\n\n", "pragma": "omp parallel for private(count,i,j) shared(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/count_sort/count_sort_parallel/0"}
{"code": "for (int i = 0; i < 20; ++i)\n{\n  {\n    if ((i % 2) == 0)\n      sleep(2);\n\n    printf(\"Thread Id: [%d] - i: [%d]\\n\", omp_get_thread_num(), i);\n  }\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a2gs/OMP_studies/sample_ordered/0"}
{"code": "for (i = 0; i < iter; i++)\n{\n  x = i % numfeasible;\n  change += pgain(feasible[x], points, z, k, pid, barrier);\n  c++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/17"}
{"code": "for (i = 0; i < tot_hour; i++)\n{\n  day = i / 24;\n  hour = i % 24;\n  if ((hour == 0) && (day > 0))\n  {\n    temp = (Measurement *) malloc(sizeof(Measurement));\n    if (temp == 0)\n    {\n      printf(\"ERROR\\tCannot allocate enough space - Terminate execution\\n\");\n      return;\n    }\n\n    ML_house->next = temp;\n    ML_house = temp;\n    ML_house->next = 0;\n  }\n\n  ML_house->hour[hour] = median_load_house(my_house, hour, day);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/20"}
{"code": "for (size_t i = 0, j = 0; i < N; ++i)\n{\n  if (i < j)\n    I.emplace_back(i, j);\n\n  for (size_t k = N >> 1; (j ^= k) < k; k >>= 1)\n    ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shuibitianantian/Arbitrary-FFT/openmp/fft/2"}
{"code": "for (i = 0; i < numprocs; ++i)\n{\n  recvNumUpdatedPoints[i] = recvNum[i] * DIMS;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/2"}
{"code": "for (j_imopVar115 = 1; j_imopVar115 < (grid_points[1] - 1); j_imopVar115++)\n{\n  for (k_imopVar116 = 1; k_imopVar116 < (grid_points[2] - 1); k_imopVar116++)\n  {\n    double *_imopVarPre338;\n    double (*_imopVarPre339)[5];\n    double (*_imopVarPre340)[5];\n    _imopVarPre338 = rhs[0][j_imopVar115][k_imopVar116];\n    _imopVarPre339 = lhs[0][j_imopVar115][k_imopVar116][2];\n    _imopVarPre340 = lhs[0][j_imopVar115][k_imopVar116][1];\n    binvcrhs(_imopVarPre340, _imopVarPre339, _imopVarPre338);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/29"}
{"code": "for (r = 0; r < dim_n; r++)\n{\n  for (c = 0; c < dim_n; c++)\n  {\n    for (p = 0; p < dim_n; p++)\n    {\n      RR[(r * dim_n) + c] += A_test[(r * dim_n) + p] * result[(p * dim_n) + c];\n    }\n\n    RR[(r * dim_n) + c] -= B_test[(r * dim_n) + c];\n    nR += pow(RR[(r * dim_n) + c], 2);\n    nX += pow(result[(r * dim_n) + c], 2);\n    nA += pow(A_test[(r * dim_n) + c], 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZhixinLai/Parallel-Computing/Gaussian elimination with partial pivoting by OpenMP/gaussian/7"}
{"code": "for (i = 0; i < 5; i++)\n{\n  sequential_result[i] = 0;\n  for (j = 0; j < 2; j++)\n  {\n    sequential_result[i] += (*((array + (i * 2)) + j)) * (*(vector + j));\n  }\n\n  if ((*(sequential_result + i)) != (*(result + i)))\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1b_MatrixVectorMult_OpenMP_approach2/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total += data[(i * n) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/5"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int startIndex = i * bsize;\n  if (startIndex != 0)\n    --startIndex;\n\n  for (int j = 0; j < bsize; j++)\n  {\n    finallist[startIndex++] = bucket[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/BucketSort/3"}
{"code": "for (int i = 0; i < len; ++i)\n  out->append(((QString(IMG_PATH) + \"img_\") + IdToString(idx[i])) + \".jpg\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xaviml/openmp-project/P1_FolchMoreno/src/controller/1"}
{"code": "for (e = 1; e < sv.num_edicts; e++, check = NEXT_EDICT(check))\n{\n  if (check->free)\n    continue;\n\n  if (((check->v.movetype == MOVETYPE_PUSH) || (check->v.movetype == MOVETYPE_NONE)) || (check->v.movetype == MOVETYPE_NOCLIP))\n    continue;\n\n  pusher->v.solid = SOLID_NOT;\n  block = SV_TestEntityPosition(check);\n  pusher->v.solid = SOLID_BSP;\n  if (block)\n    continue;\n\n  if (!((((int) check->v.flags) & FL_ONGROUND) && (PROG_TO_EDICT(check->v.groundentity) == pusher)))\n  {\n    if ((((((check->v.absmin[0] >= maxs[0]) || (check->v.absmin[1] >= maxs[1])) || (check->v.absmin[2] >= maxs[2])) || (check->v.absmax[0] <= mins[0])) || (check->v.absmax[1] <= mins[1])) || (check->v.absmax[2] <= mins[2]))\n      continue;\n\n    if (!SV_TestEntityPosition(check))\n      continue;\n\n  }\n\n  VectorCopy(check->v.origin, moved_from[num_moved]);\n  moved_edict[num_moved] = check;\n  num_moved++;\n  VectorAdd(check->v.origin, move, check->v.origin);\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  VectorSubtract(check->v.origin, move, check->v.origin);\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    num_moved--;\n    continue;\n  }\n\n  if (check->v.mins[0] == check->v.maxs[0])\n  {\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  if ((check->v.solid == SOLID_NOT) || (check->v.solid == SOLID_TRIGGER))\n  {\n    check->v.mins[0] = (check->v.mins[1] = 0);\n    VectorCopy(check->v.mins, check->v.maxs);\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  VectorCopy(pushorig, pusher->v.origin);\n  SV_LinkEdict(pusher, 0);\n  if (pusher->v.blocked)\n  {\n    pr_global_struct->self = EDICT_TO_PROG(pusher);\n    pr_global_struct->other = EDICT_TO_PROG(check);\n    PR_ExecuteProgram(pusher->v.blocked);\n  }\n\n  for (i = 0; i < num_moved; i++)\n  {\n    VectorCopy(moved_from[i], moved_edict[i]->v.origin);\n    SV_LinkEdict(moved_edict[i], 0);\n  }\n\n  return 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jrk/QuakeTM/server/sv_phys/4"}
{"code": "for (int i = 1; i <= CITIES; i++)\n  catalog[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/22"}
{"code": "for (i = 0; i < k; i++)\n  scanf(\"%lf %lf %lf\", mean + (i * 3), (mean + (i * 3)) + 1, (mean + (i * 3)) + 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lineu96/relatorio_openmp/arquivos/02_kmeans/kmeans_paralelo/2"}
{"code": "for (int i = 0; i < (5 + 1); i++)\n{\n  ptr_list[i] = p;\n  p = p->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mahikgot/openmp_practice/exercise 6/linked/1"}
{"code": "for (i = 1; (i < iter_max) && (((z_r *= z_r) + (z_i *= z_i)) < 4.0); i++)\n{\n  z_r += p_r - z_i;\n  z_i = p_i + work;\n  work = (2.0 * z_r) * z_i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/00.base/00.cpu/mandelbrot/2"}
{"code": "for (int chunk = 0; chunk < actual_num_workers; chunk++)\n{\n  for (uint64_t i = 0; i < BUCKET_WIDTH; ++i)\n  {\n    bucket_size_test += my_local_key_counts[chunk][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/17"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/3"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (random() % n) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysimonov/C-concurrent/OpenMP/lab3part4/0"}
{"code": "for (long i = 0; i < n; i++)\n{\n  arr[i] = (int) rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/turfaa/bitonic-sort-openmp/src/bitonic_sort/2"}
{"code": "for (k = 0; k < i; k++)\n{\n  sum_u += getValueAtIJ(u, n, k + 1, i + 1) * getValueAtIJ(l, n, i + 1, k + 1);\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum_u) firstprivate(val, n, i) private(k)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ktzsh/lu_decomposition/openmp/LUDecomp/4"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < 2048; j++)\n  {\n    weight711[i][j] = distr(gen);\n    weight712[i][j] = distr(gen);\n    weight721[i][j] = distr(gen);\n    weight722[i][j] = distr(gen);\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  v[i][0] /= tempSum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/7"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  {\n    scanf(\"%s\", tc);\n    for (tsz = 0; tc[tsz] != '\\0'; ++tsz)\n      ;\n\n    sz[i] = tsz;\n    fl[i] = (int) (tc[0] - 'a');\n    ll[i] = (int) (tc[tsz - 1] - 'a');\n  }\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic,chunk) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/DynastyPuzzles/dp_par1/0"}
{"code": "for (int z = 1; z < (nz - 1); z++)\n{\n  memcpy(vec + ((0 + (0 * nx)) + ((z * ny) * nx)), vec + ((0 + (1 * nx)) + ((z * ny) * nx)), nx * (sizeof(TYPE)));\n  for (int y = 1; y < (ny - 1); y++)\n  {\n    vec[(0 + (y * nx)) + ((z * ny) * nx)] = vec[(1 + (y * nx)) + ((z * ny) * nx)];\n    vec[((nx - 1) + (y * nx)) + ((z * ny) * nx)] = vec[((nx - 2) + (y * nx)) + ((z * ny) * nx)];\n  }\n\n  memcpy(vec + ((0 + ((ny - 1) * nx)) + ((z * ny) * nx)), vec + ((0 + ((ny - 2) * nx)) + ((z * ny) * nx)), nx * (sizeof(TYPE)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/suicide-squad/heat-equation/modules/Kirill/src/multMV/2"}
{"code": "for (int x = 0; x < GRAIN; x++)\n{\n  for (int y = 0; y < GRAIN; y++)\n  {\n    if (current_array[(x * GRAIN) + y] == 1)\n    {\n      current_array[(x * GRAIN) + y] = 0;\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          compute_new_state(i, j);\n          if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n          {\n            next_array[(x * GRAIN) + y] = 1;\n            if (((i % TILEX) == 0) && (x > 0))\n            {\n              next_array[((x - 1) * GRAIN) + y] = 1;\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[((x - 1) * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[((x - 1) * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n            if (((i % TILEX) == (TILEX - 1)) && (x < (GRAIN - 1)))\n            {\n              next_array[((x + 1) * GRAIN) + y] = 1;\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[((x + 1) * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[((x + 1) * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n            if (((j % TILEY) == 0) && (y > 0))\n            {\n              next_array[(x * GRAIN) + (y - 1)] = 1;\n            }\n\n            if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n            {\n              next_array[(x * GRAIN) + (y + 1)] = 1;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/3"}
{"code": "for (i = 0; i <= 7; i++)\n{\n  debug_vec[i] = DEBUG_DEFAULT;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/12"}
{"code": "for (int i = 2; i < (GRAIN + 1); i += 2)\n  for (int j = 2; j < (GRAIN + 1); j += 2)\n{\n  if (!tab_unstable[(i * (GRAIN + 2)) + j])\n  {\n    if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n  }\n  else\n  {\n    tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n    changement += tab_unstable[(i * (GRAIN + 2)) + j];\n  }\n\n}\n\n\n", "pragma": "omp for collapse(2) reduction(+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/9"}
{"code": "for (int x = x_m; x <= (x_M / balance_factor); x++)\n{\n  for (int y = y_m; y < y_M; y++)\n  {\n    if (t1)\n      ut1[(x * size_u[0]) + y] = ut0[(x * size_u[0]) + y] + 1;\n    else\n      if (t0)\n      ut0[(x * size_u[0]) + y] = ut1[(x * size_u[0]) + y] + 1;\n\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(2) firstprivate(t0, t1) shared(ut0, ut1, x_m, x_M, y_m, y_M, balance_factor, size_u) default(none)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/time_marching_cpu_gpu/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  arr[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rnikhori/OpenMP/array_para/1"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    u[i3][i2][n1 - 1] = u[i3][i2][1];\n    u[i3][i2][0] = u[i3][i2][n1 - 2];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/7"}
{"code": "for (unsigned int idx = 0; idx < parameter.size(); idx++)\n  if (((((a == parameter[idx].a) && (b == parameter[idx].b)) && (c == parameter[idx].c)) && (d == parameter[idx].d)) && (ffclass == parameter[idx]._ipar[0]))\n{\n  par = &parameter[idx];\n  return par;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/37"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"\\n\\t x(%d) = %.1f \", i + 1, b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CaillaRose/OpenMP/threadGauss/4"}
{"code": "for (int i = k + 1; i < N; i++)\n{\n  l[i][k] = a[i][k] / u[k][k];\n  u[k][i] = a[k][i];\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anandcse2018/LU-Decomposition/OMP/4"}
{"code": "for (int i = 0; i < size_matrix; i++)\n{\n  int adder = 0;\n  for (int j = 0; j < size_matrix; j++)\n  {\n    adder += matrix_A[i][j] * matrix_B[j][a];\n  }\n\n  matrix_Out[i][a] = adder;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/8"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  Q[i] = -1;\n  Qtmp[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/reverseCuthillMcKee/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/dotp/0"}
{"code": "for (j = 0; j < Block_order; j += Tile_order)\n  for (i = 0; i < order; i += Tile_order)\n  for (jt = j; jt < MIN(Block_order, j + Tile_order); jt++)\n  for (it = i; it < MIN(order, i + Tile_order); it++)\n{\n  A_p[(it + istart) + (order * jt)] = (double) ((order * (jt + colstart)) + it);\n  B_p[(it + istart) + (order * jt)] = 0.0;\n}\n\n\n\n\n", "pragma": "omp parallel for private (i,it,jt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Transpose/transpose/0"}
{"code": "for (i = 1; i < 10; i++)\n{\n  fprintf(outfile, \"%s \\n\", configdata[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NiramayVaidya/Linux_OpenMP_Benchmark_Results/code_and_results_files/32_bit/memspeed/code/memory_speed/1"}
{"code": "for (i = 0; i < width; ++i)\n{\n  float x = x0 + (i * dx);\n  float y = y0 + (j * dy);\n  int index = (j * width) + i;\n  output[index] = mandel(x, y, maxIterations);\n}\n\n", "pragma": "#pragma omp parallel for private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artalukd/toRustOrNot/C++/mandelbrot/main/3"}
{"code": "for (int i = 0; i < l; i++)\n  active_set[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/5"}
{"code": "for (i = 0; i < bool_classifications.size(); ++i)\n{\n  if (bool_classifications[i])\n    count_true++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jim-Shaddix/Parallelized-Decision-Tree/DecisionTree1p/1"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  r[i] = find_min(A + (i * H), A + ((i + 1) * H), B, h, f);\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:s) num_threads(1)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/3_openmp(test)/1"}
{"code": "for (p = 0; p < size; p++)\n{\n  fputc(image_red[p], fp);\n  fputc(image_grn[p], fp);\n  fputc(image_blu[p], fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/22"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n    {\n      rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] - (dssp * (((5.0 * u[i][j][k][m_imopVar18]) - (4.0 * u[i][j][k + 1][m_imopVar18])) + u[i][j][k + 2][m_imopVar18]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/25"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  tmp[i] = 0;\n  for (j = 0; j < 4096; j++)\n  {\n    tmp[i] = tmp[i] + (A[(i * 4096) + j] * x[j]);\n  }\n\n  for (j = 0; j < 4096; j++)\n  {\n    y[j] = y[j] + (A[(i * 4096) + j] * tmp[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/12"}
{"code": "for (m = 0; m < 5; m++)\n{\n  k = 1;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[k][m]) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n  k = 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[k - 1][m]) + (6.0 * ue[k][m])) - (4.0 * ue[k + 1][m])) + ue[k + 2][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(dssp ,m ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/32"}
{"code": "for (j = 0; j < 10000; j++)\n{\n  for (i = 0; i < 10000; i++)\n    x[j] += A[i + (10000 * j)] * b[i];\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DhavalNiphade/Parallel-Matrix-Vector-Products/matrix/0"}
{"code": "for (int k = 0; k < Time_cell; ++k)\n{\n  for (int j = 0; j < Freq_cell; ++j)\n  {\n    for (int i = 0; i < Holo_Freq_cell; ++i)\n    {\n      if ((hhsa_map[k][j][i] > 1000000000000.0) || (hhsa_map[k][j][i] < (-1000000000000.0)))\n        continue;\n\n      if (hhsa_map[k][j][i] > HHSA_threshold)\n      {\n        HHSA_3D_x[index] = k;\n        HHSA_3D_y[index] = j;\n        HHSA_3D_z[index] = i;\n        HHSA_3D_a[index++] = hhsa_map[k][j][i];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/57"}
{"code": "for (int i = 0; i < this->objs; i++)\n{\n  x = ud(gen);\n  y = ud(gen);\n  z = ud(gen);\n  m = nd(gen);\n  points.emplace_back(x, y, z, m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/AosSimulator/2"}
{"code": "for (size_t i = 0; i < vertexNum; i++)\n{\n  outdegree[i] = out_degree(i, g) * FIXED;\n  g[i].fixed_value = stdfixed_value;\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gbossi/Pagerank-DOBFS/fixed_pagerank/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    M_T[(j * m) + i] = M[(i * n) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(1) private(i, j) collapse(2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/0"}
{"code": "for (i = 0; i <= 2; i += 1)\n{\n  dims[i][0] = 256;\n  dims[i][1] = 256;\n  dims[i][2] = 128;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    A_new[i][j] = A[i][j];\n    B_new[i][j] = B[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aqfort/mipt_omp/extra/matrix/2"}
{"code": "for (i = 0; i < 128; i++)\n{\n  tmp[i] = 0;\n  y[i] = 0;\n  for (j = 0; j < 128; j++)\n  {\n    tmp[i] = (A[(i * 128) + j] * x[j]) + tmp[i];\n    y[i] = (B[(i * 128) + j] * x[j]) + y[i];\n  }\n\n  y[i] = (43532.0f * tmp[i]) + (12313.0f * y[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/15"}
{"code": "for (int y = 0; y < (N_y + 6); y++)\n{\n  arr[2][y] = arr[end - 4][y];\n  arr[end - 3][y] = arr[3][y];\n  arr[1][y] = arr[end - 5][y];\n  arr[end - 2][y] = arr[4][y];\n  arr[0][y] = arr[end - 6][y];\n  arr[end - 1][y] = arr[5][y];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anubhav-cs/Numerical-Methods/Shallow Water Flow/shallow_water_openmp/13"}
{"code": "for (size_t i = 0; i < NPOINTS; ++i)\n{\n  for (size_t j = 0; j < NPOINTS; ++j)\n  {\n    c.real(((-2.0) + ((2.5 * i) / NPOINTS)) + eps);\n    c.imag(((1.125 * j) / NPOINTS) + eps);\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattEding/OpenMP-Practice/Exercises/Ex5-Mandelbrot/mandel/0"}
{"code": "for (int i = 0; i < size; i++)\n  isPrime[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe_odd_only_blockwise/0"}
{"code": "for (int i = 0; i < psiClones.size(); ++i)\n  psiClones[i]->resetParameters(OptVariablesForPsi);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/13"}
{"code": "for (int i = 0; i < row_index; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    oneDArrayOfAllCoorindates[(4 * i) + j] = coordinates[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/4"}
{"code": "for (int i = 0; i < row_size; ++i)\n{\n  for (int j = 0; j < col_size; ++j)\n  {\n    if (game_board[i][j] == ALIVE)\n    {\n      ++alive;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment3/game-of-life/openmp/GameOfLife/1"}
{"code": "for (int i = 0; i < NumQs; i++)\n{\n  *(qval + i) = dataParamDLL.Qmin + (i * dataParamDLL.Qstep);\n  fprintf(pfile, \"%lf,\", *(qval + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/44"}
{"code": "for (int i = 0; i < r1; ++i)\n{\n  for (int j = 0; j < c2; ++j)\n  {\n    int temp = 0;\n    for (int k = 0; k < c1; ++k)\n    {\n      temp += a[k + (i * c1)] * b[j + (k * c2)];\n    }\n\n    c[j + (i * c3)] = temp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_matrix_multiplication/c1/matmul/0"}
{"code": "for (int i = sectionSize * 4; i < (sectionSize * 5); ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    bucket5[(iArray[i][j] / iExp) % 10]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/20"}
{"code": "for (int i = 0; i < nFeatures; i++)\n  for (int j = 0; j < nItems; j++)\n  R[i][j] = (((double) random()) / ((double) 32767)) / ((double) nFeatures);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matFact-omp/6"}
{"code": "for (i1; i1 < m; i1++)\n{\n  printf(\"Valor : \");\n  scanf(\"%d\", &h);\n  A[i1] = h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/BusquedaEREW/3"}
{"code": "for (unsigned int i = 0; i < N; i++)\n{\n  d_Data[i] = val;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_teams(globalWorkSize/wgSize) thread_limit(wgSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particles-omp/particles/0"}
{"code": "for (j = 1; j < (((L / 5) + 2) - 1); j++)\n{\n  i = 0;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = grn[j];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = grn[j];\n\n  i = ((L / NODESX) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = grs[j];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = grs[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/119"}
{"code": "for (i = 0; i < 750; i++)\n{\n  for (j = 0; j < 750; j++)\n  {\n    E[(i * 750) + j] = 0.0;\n    for (k = 0; k < 750; ++k)\n    {\n      E[(i * 750) + j] += C[(i * 750) + k] * D[(k * 750) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm_cpu/1"}
{"code": "for (int i = 11; i > 10; i--)\n  c[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/19"}
{"code": "for (long i = 1; i < curr_step_number; i++)\n{\n  double x = a + (step * i);\n  result += f(x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KirovVerst/parallel_programming_course/lab3/implementations/0"}
{"code": "for (i = 0; i < current_dim_x; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    printf(\"%lld \", prev_prod[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alapan-sau/SPP-Assignment2/q1/2"}
{"code": "for (i = 1; i < (num_line - 1); i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    if (counter < 50)\n    {\n      printf(\"RANK %d    resultMatrix[%d][%d] = %d -- send_buf[%d] = %d \\n\", taskid, i, j, resultMatrix[i][j], counter, send_buf[counter]);\n      counter++;\n    }\n    else\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/15"}
{"code": "for (i = 0; i < size_0; i++)\n{\n  str_1[i] = (char *) malloc((sizeof(char)) * 15);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shyeok/Distributed-Programming/OpenMP/p/0"}
{"code": "for (j = n - 1; j <= (n + 1); j += 2)\n{\n  if (matrix[(i * col) + j] == 1)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielevensen/Conways-Game-of-Life/version4/2"}
{"code": "for (int i = 0; i < 4096; i++)\n{\n  globalized[i % 256] += i;\n}\n\n", "pragma": "omp parallel for reduction(+:globalized)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_shared_array/reduction_shared_array/1"}
{"code": "for (j = 0; j < 1; ++j)\n{\n  for (i = 0; i < 10000; ++i)\n  {\n    updatePhysics(i * 100);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MatheusDonizete/n-body-openmp/main/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  for (j = i; j < 16; j++)\n  {\n    for (k = 0; k < i; k++)\n    {\n      a[(((offset * size) + (i * size)) + j) + offset] = a[(((offset * size) + (i * size)) + j) + offset] - (a[(((offset * size) + (i * size)) + k) + offset] * a[(((offset * size) + (k * size)) + j) + offset]);\n    }\n\n  }\n\n  float temp = 1.f / a[(((offset * size) + (i * size)) + i) + offset];\n  for (j = i + 1; j < 16; j++)\n  {\n    for (k = 0; k < i; k++)\n    {\n      a[(((offset * size) + (j * size)) + i) + offset] = a[(((offset * size) + (j * size)) + i) + offset] - (a[(((offset * size) + (j * size)) + k) + offset] * a[(((offset * size) + (k * size)) + i) + offset]);\n    }\n\n    a[(((offset * size) + (j * size)) + i) + offset] = a[(((offset * size) + (j * size)) + i) + offset] * temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/lud/omp/lud_omp/2"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  p[i] = i * 3.14159;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/13"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int i = 0; i < DIM; i++)\n    for (int j = 0; j < DIM; j++)\n    next_img(i, j) = cur_img(j, i);\n\n\n  swap_images();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicvidal/Projet_GPU/TP6/TP6-OpenCL/fichiers/Transpose/src/compute/1"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  for (size_t j = 0; j < i; j++)\n  {\n    temp = matrix[i][j];\n    matrix[i][j] = matrix[j][i];\n    matrix[j][i] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/6"}
{"code": "for (i = 0; i < newState.nMoves; ++i)\n{\n  val = MiniMax_Recursive(&newState, newState.moves + i, alpha, beta, depth - 1);\n  if (val > toRet)\n    toRet = val;\n\n  if (val > alpha)\n    alpha = val;\n\n  if (beta <= alpha)\n    return toRet;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luigifusco/CChess/minimax/3"}
{"code": "for (int i = 0; i < 20; ++i)\n{\n  initialize(array);\n  start = omp_get_wtime();\n  odd_even_sort_parallel(array);\n  end = omp_get_wtime();\n  time += end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohorka/HPCS/openMP/Sort(ex.5)/4"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nk; j++)\n  A[i][j] = (((DATA_TYPE) i) * j) / ni;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/2mm/2mm/2"}
{"code": "for (i = 1; i <= n; i++)\n{\n  partialSum = 0;\n  for (j = 1; j <= n; j++)\n  {\n    partialSum = partialSum + A_Orig[i][j];\n  }\n\n  for (j = i; j <= i; j++)\n  {\n    if (i == j)\n      A_Orig[i][j] = 1 + partialSum;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/17"}
{"code": "for (i = 0; i < n; i += block_size)\n{\n  for (j = 0; j < n; j += block_size)\n  {\n    for (k = 0; k < block_size; ++k)\n    {\n      for (l = 0; l < block_size; ++l)\n      {\n        for (m = 0; m < n; ++m)\n        {\n          c[i + k][j + l] += a[i + k][m] * b[m][j + l];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chahak13/HPC/Lab4/201501005-201501422-matrix_multiplication-block/serial_measurement/0"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    printf(\"%c \", arr[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manaratef570/-OpenMP/Assignment3_ OpenMP/code3/main/4"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double sumReal = 0.0;\n  double sumImaginary = 0.0;\n  for (uint p = 0; p < length; ++p)\n  {\n    unsigned long currentAtom = startAtom + p;\n    if (particleHasNoCharge[currentAtom])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(p + startAtom, kxRef[box][i], kyRef[box][i], kzRef[box][i], currentCoords);\n    sumReal += particleCharge[currentAtom] * cos(dotProduct);\n    sumImaginary += particleCharge[currentAtom] * sin(dotProduct);\n  }\n\n  for (uint s = 0; s < lambdaSize; s++)\n  {\n    double coefDiff = sqrt(lambda_Coul[s]) - sqrt(lambda_Coul[iState]);\n    energyRecip[s] += prefactRef[box][i] * (((sumRref[box][i] + (coefDiff * sumReal)) * (sumRref[box][i] + (coefDiff * sumReal))) + ((sumIref[box][i] + (coefDiff * sumImaginary)) * (sumIref[box][i] + (coefDiff * sumImaginary))));\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for default(none) shared(lambda_Coul, lambdaSize, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/12"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    exact(i, 0, k, temp1);\n    exact(i, ny - 1, k, temp2);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][0][i][m] = temp1[m];\n      u[k][ny - 1][i][m] = temp2[m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/setbv/1"}
{"code": "for (int i = 0; i < ((nr_class * (nr_class - 1)) / 2); i++)\n  fprintf(fp, \" %g\", model->probB[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/89"}
{"code": "for (unsigned long int i = 0; i < 1024; ++i)\n  arr[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivaneduardomv/OpenMPTest/ompArrayCopy/1"}
{"code": "for (int j = 0; j < (arraySize - 1); j++)\n{\n  if (compar(arrayBaseChar + (j * elementSize), pivot) <= 0)\n  {\n    swap(arrayBaseChar + (j * elementSize), arrayBaseChar + (index[j] * elementSize), elementSize);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/allywarner/HPC_OpenMP/Quicksort/main/2"}
{"code": "for (int i = 0; i < iterations; ++i)\n{\n  produce(i);\n  total += consume();\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_prod_cons_v01/c1/prod_cons/0"}
{"code": "for (i = 0; i < k; i++)\n{\n  A[index[i]][size] = A[index[i]][size] - ((A[index[i]][k] / A[index[k]][k]) * A[index[k]][size]);\n  A[index[i]][k] = 0;\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ryanmoro97/ECE_420_Lab_3_OpenMP/main/2"}
{"code": "for (i = 0; i < width; i++)\n{\n  float x = x0 + (i * dx);\n  output[(j * width) + i] = mandel(x, y, maxIterations);\n}\n\n", "pragma": "omp simd for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_40_mandel/0"}
{"code": "for (i = 0; i < n; i++)\n  sum1 += func((from + (h * i)) + (h / 2.0));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Simpson/2"}
{"code": "for (i = 0; i < N; i++)\n  lims[i] = (threads[i] = -1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/Threads1xxx/Threads1xxx/1"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      u[k][j][i][0] = 1.0;\n      u[k][j][i][1] = 0.0;\n      u[k][j][i][2] = 0.0;\n      u[k][j][i][3] = 0.0;\n      u[k][j][i][4] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/initialize/0"}
{"code": "for (int globalID = 0; globalID < globalWorkSize; globalID++)\n{\n  for (int iOut = 0; iOut < nPerRng; iOut += 2)\n  {\n    BoxMullerTrans(&h_RandGPU[globalID + ((iOut + 0) * MT_RNG_COUNT)], &h_RandGPU[globalID + ((iOut + 1) * MT_RNG_COUNT)]);\n  }\n\n}\n\n", "pragma": "        #pragma omp target teams distribute parallel for thread_limit(localWorkSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mt-omp/MT/3"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  lambda.nV[i] = x.nV[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/9"}
{"code": "for (i = 0; i < 16; i++)\n{\n  writeToFile(filename, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for num_threads(4) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luxifeo/openmp/orderedTest/0"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  ret += dist[index(s[i % dim])][index(s[(i + 1) % dim])];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/2"}
{"code": "for (int i = 0; i < 10; i++)\n  exercise_omp9_2();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/main/6"}
{"code": "for (unsigned int k = 0; k < nz; k++)\n{\n  double z = pmin[2] + (k * hz);\n  for (unsigned int j = 0; j < ny; j++)\n  {\n    double y = pmin[1] + (j * hy);\n    for (unsigned int i = 0; i < nx; i++)\n    {\n      double x = pmin[0] + (i * hx);\n      int pp = i + (nx * (j + (k * ny)));\n      fake_initial_data(x, y, z, vars);\n      for (unsigned int m = 0; m < 24; m++)\n      {\n        uZipVars[m][offset + pp] = vars[m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/rhs/0"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      xvel = us[k][j][i];\n      yvel = vs[k][j][i];\n      zvel = ws[k][j][i];\n      ac = speed[k][j][i];\n      ac2u = ac * ac;\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      uzik1 = u[k][j][i][0];\n      btuz = bt * uzik1;\n      t1 = (btuz / ac) * (r4 + r5);\n      t2 = r3 + t1;\n      t3 = btuz * (r4 - r5);\n      rhs[k][j][i][0] = t2;\n      rhs[k][j][i][1] = ((-uzik1) * r2) + (xvel * t2);\n      rhs[k][j][i][2] = (uzik1 * r1) + (yvel * t2);\n      rhs[k][j][i][3] = (zvel * t2) + t3;\n      rhs[k][j][i][4] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[k][j][i] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/22"}
{"code": "for (i = 0; i < 2; i++)\n{\n  current_chance = 0;\n  breeding_chance = rand() / ((double) (RAND_MAX + 1.0));\n  for (j = 0; j < ((int) percent_contrib.size()); j++)\n  {\n    current_chance += percent_contrib[j];\n    if (current_chance > breeding_chance)\n    {\n      current_chance = 0;\n      break;\n    }\n\n  }\n\n  if (i == 0)\n  {\n    prev_ind_index = j;\n    asexual = false;\n  }\n\n  if ((i == 1) && (prev_ind_index == j))\n  {\n    asexual = true;\n  }\n\n  breed_pair.push_back(this->current_individuals[j].Chromosome());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/3"}
{"code": "for (int j = m / 2; j < (dill.cols - (m / 2)); j++)\n{\n  if (((((int) dill.at) < uchar) > ((i, j))) == ONE)\n  {\n    bool shouldBeZero = false;\n    int x = 0;\n    for (int crtX = i - (n / 2); crtX < (i + (n / 2)); crtX++)\n    {\n      int y = 0;\n      for (int crtY = j - (m / 2); crtY <= (j + (m / 2)); crtY++)\n      {\n        if ((((((int) dill.at) < uchar) > ((crtX, crtY))) == ZERO) && (kernel[x][y] == 1))\n        {\n          shouldBeZero = true;\n          break;\n        }\n\n        y++;\n      }\n\n      x++;\n    }\n\n    if (shouldBeZero)\n    {\n      shouldBeZeroImage[i][j] = true;\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lancelof2019/Watershed-OpenMP/Watershed_Algorithm/functionspace/erosion/erosion/1"}
{"code": "for (d = 0; d < NDIM; d++)\n  vmean.at(d) /= NCELLS;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/18"}
{"code": "for (j = xadj[i]; j < xadj[i + 1]; j++)\n{\n  k = adjncy[j];\n  if (pos[k] != (-1))\n  {\n    cind[last++] = k;\n    pos[k] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/6"}
{"code": "for (int i = 0; i < count; ++i)\n  if ((err = sem_post(workerSemaphore)) != 0)\n{\n  fprintf(stderr, \"Error from sem_post: %s\\n\", strerror(err));\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment1/ispc/common/tasksys/6"}
{"code": "for (uint i = 0; i < blockHistograms.size(); ++i)\n{\n  uint ind = i % numBuckets;\n  globalHisto[ind] += blockHistograms[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sahityamantravadi/cme213-sp18/hw1code/main_q2/0"}
{"code": "for (int i = 0; i < r; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    ONEDA[(i * r) + j] = a[i][j];\n    ONEDB[(j * c) + i] = b[i][j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ajit-Kumar/Concurrent_Programming/matrix/3"}
{"code": "for (i = 0; i < block_height; i++)\n{\n  p(i, 0) = phi(x(i, start_i), y(0, start_j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/16"}
{"code": "for (; j < N; j++)\n{\n  if (j != m)\n    res2 += (u[j] * u[j]) / (d[j] - y);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Secular_Equation_Solvers_In_OpenMP/hybride/5"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);\n  startTime = omp_get_wtime();\n  gaussianImage = applyGaussianBlur(image);\n  duration = omp_get_wtime() - startTime;\n  (logs << duration) << \"\\n\";\n  (((cout << \"FINISHED. Blurring without OpenMP took \") << duration) << \" seconds.\") << endl;\n  if (i == 9)\n    imwrite(\"gaussian_normal.png\", gaussianImage);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/7"}
{"code": "for (i = 0; i < nwords; ++i)\n{\n  this_data[i] = b_data[i] & (~this_data[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bitmap/1"}
{"code": "for (int32_t i = 0; i < 10; i++)\n  assert(sum[i].x == i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_09/2"}
{"code": "for (int i = 0; i < 4; i++)\n  sum += funcsum[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/4"}
{"code": "for (stage = 0; stage <= 1; stage++)\n{\n  int neighbor;\n  for (neighbor = 0; neighbor < numRecvRanks; neighbor++)\n  {\n    if (stage == 1)\n    {\n      level->exchange_ghosts[shape].recv_buffers[neighbor] = (double *) malloc(level->exchange_ghosts[shape].recv_sizes[neighbor] * (sizeof(double)));\n      if (level->exchange_ghosts[shape].recv_sizes[neighbor] > 0)\n        if (level->exchange_ghosts[shape].recv_buffers[neighbor] == 0)\n      {\n        fprintf(stderr, \"malloc failed - exchange_ghosts[%d].recv_buffers[neighbor]\\n\", shape);\n        exit(0);\n      }\n\n\n      memset(level->exchange_ghosts[shape].recv_buffers[neighbor], 0, level->exchange_ghosts[shape].recv_sizes[neighbor] * (sizeof(double)));\n    }\n\n    level->exchange_ghosts[shape].recv_ranks[neighbor] = recvRanks[neighbor];\n    level->exchange_ghosts[shape].recv_sizes[neighbor] = 0;\n  }\n\n  for (ghost = 0; ghost < numGhosts; ghost++)\n  {\n    int dim_i = -1;\n    int dim_j = -1;\n    int dim_k = -1;\n    int recv_i = -1;\n    int recv_j = -1;\n    int recv_k = -1;\n    int di = (ghostsToRecv[ghost].sendDir % 3) - 1;\n    int dj = ((ghostsToRecv[ghost].sendDir % 9) / 3) - 1;\n    int dk = (ghostsToRecv[ghost].sendDir / 9) - 1;\n    switch (di)\n    {\n      case -1:\n        dim_i = level->box_ghosts;\n        recv_i = level->box_dim;\n        break;\n\n      case 0:\n        dim_i = level->box_dim;\n        recv_i = 0;\n        break;\n\n      case 1:\n        dim_i = level->box_ghosts;\n        recv_i = 0 - level->box_ghosts;\n        break;\n\n    }\n\n    switch (dj)\n    {\n      case -1:\n        dim_j = level->box_ghosts;\n        recv_j = level->box_dim;\n        break;\n\n      case 0:\n        dim_j = level->box_dim;\n        recv_j = 0;\n        break;\n\n      case 1:\n        dim_j = level->box_ghosts;\n        recv_j = 0 - level->box_ghosts;\n        break;\n\n    }\n\n    switch (dk)\n    {\n      case -1:\n        dim_k = level->box_ghosts;\n        recv_k = level->box_dim;\n        break;\n\n      case 0:\n        dim_k = level->box_dim;\n        recv_k = 0;\n        break;\n\n      case 1:\n        dim_k = level->box_ghosts;\n        recv_k = 0 - level->box_ghosts;\n        break;\n\n    }\n\n    neighbor = 0;\n    while (level->exchange_ghosts[shape].recv_ranks[neighbor] != ghostsToRecv[ghost].sendRank)\n      neighbor++;\n\n    if (stage == 1)\n      append_block_to_list(&level->exchange_ghosts[shape].blocks[2], &level->exchange_ghosts[shape].allocated_blocks[2], &level->exchange_ghosts[shape].num_blocks[2], dim_i, dim_j, dim_k, -1, level->exchange_ghosts[shape].recv_buffers[neighbor], level->exchange_ghosts[shape].recv_sizes[neighbor], 0, 0, dim_i, dim_i * dim_j, 1, ghostsToRecv[ghost].recvBox, 0, recv_i, recv_j, recv_k, level->my_boxes[ghostsToRecv[ghost].recvBox].jStride, level->my_boxes[ghostsToRecv[ghost].recvBox].kStride, 1, BLOCKCOPY_TILE_I, BLOCKCOPY_TILE_J, BLOCKCOPY_TILE_K, 0);\n\n    if (neighbor >= 0)\n      level->exchange_ghosts[shape].recv_sizes[neighbor] += (dim_i * dim_j) * dim_k;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/24"}
{"code": "for (int j = 0; j < wym; j++)\n{\n  sendleft[j] = pizzaslice[j][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aenyewedien/GameOfLife/game/5"}
{"code": "for (i = 0; i < 100; i++)\n  x = i;\n\n", "pragma": "omp parallel for private (i) lastprivate (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/lastprivate-orig-no/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    (cout << G.A[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BineshTharikoppula/Parallel-Tiled-Floyd-Warshall/FinalAPSP/7"}
{"code": "for (int i = 0; i < 200; i++)\n{\n  for (int j = 0; j < 200; j++)\n  {\n    assert(C[i][j] == P[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/CAB401-OpenMP/matMult-comparison/6"}
{"code": "for (int s = 0; s < N; s++)\n{\n  current_y_k3[s] = current_y[s] + ((current_k2[s] * h) / 2.);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example3/main/4"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  a_flat[(i * n) + j] = a[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/illumitata/OpenMPrograms/codes/mat_mul/3"}
{"code": "for (i = 0; i < n; i++)\n  for (s = 0; s < n; s++)\n  a[i][s] = (i * n) + s;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/purvilmehta06/High-Performance-Computing/Lab_2/QRD/Approach 1/parallel/5"}
{"code": "for (i = 0; i < lnum; i++)\n{\n  double ispec;\n  double idiff;\n  struct vec3 ldir;\n  struct ray shadow_ray;\n  struct sphere *iter = obj_list->next;\n  int in_shadow = 0;\n  ldir.x = lights[i].x - sp->pos.x;\n  ldir.y = lights[i].y - sp->pos.y;\n  ldir.z = lights[i].z - sp->pos.z;\n  shadow_ray.orig = sp->pos;\n  shadow_ray.dir = ldir;\n  while (iter)\n  {\n    if (ray_sphere(iter, shadow_ray, 0))\n    {\n      in_shadow = 1;\n      break;\n    }\n\n    iter = iter->next;\n  }\n\n  if (!in_shadow)\n  {\n    do\n    {\n      double len = sqrt(((ldir.x * ldir.x) + (ldir.y * ldir.y)) + (ldir.z * ldir.z));\n      ldir.x /= len;\n      ldir.y /= len;\n      ldir.z /= len;\n    }\n    while (0);\n    ;\n    idiff = ((((sp->normal.x * ldir.x) + (sp->normal.y * ldir.y)) + (sp->normal.z * ldir.z)) > 0.0) ? (((sp->normal.x * ldir.x) + (sp->normal.y * ldir.y)) + (sp->normal.z * ldir.z)) : (0.0);\n    ispec = (obj->mat.spow > 0.0) ? (pow(((((sp->vref.x * ldir.x) + (sp->vref.y * ldir.y)) + (sp->vref.z * ldir.z)) > 0.0) ? (((sp->vref.x * ldir.x) + (sp->vref.y * ldir.y)) + (sp->vref.z * ldir.z)) : (0.0), obj->mat.spow)) : (0.0);\n    col.x += (idiff * obj->mat.col.x) + ispec;\n    col.y += (idiff * obj->mat.col.y) + ispec;\n    col.z += (idiff * obj->mat.col.z) + ispec;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/c-ray/c-ray/6"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 3; j++)\n  if (tabla[pi + i][pj + j] == z)\n  return 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AleixMT/Massive-Parallel-Computing/OpenMP/P1.2/P1.2_CPM_MarineRuiz/3"}
{"code": "for (int i = 1; i <= n2; ++i)\n{\n  for (int j = 1; j <= n3; ++j)\n  {\n    (file << w2[i][j]) << \" \";\n  }\n\n  file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/20"}
{"code": "for (y = 0; y < (*ctx->countOnes_ptr); y++)\n  (*ctx->likelihood_ptr)[x] += (pow((*ctx->I_ptr)[(*ctx->ind_ptr)[(x * (*ctx->countOnes_ptr)) + y]] - 100, 2) - pow((*ctx->I_ptr)[(*ctx->ind_ptr)[(x * (*ctx->countOnes_ptr)) + y]] - 228, 2)) / 50.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq/2"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    ICOL_LIST[j] = -1;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    remake:\n    kk = (int) ((((double) 100000) * rand()) * dc_inv);\n\n    if (kk == 100000)\n      kk = 100000 - 1;\n\n    if (ICOL_LIST[kk] != (-1))\n    {\n      goto remake;\n    }\n    else\n    {\n      ICOL_LIST[kk] = 1;\n    }\n\n  }\n\n  for (j = 0; j < 100000; j++)\n  {\n    if (ICOL_LIST[j] == 1)\n    {\n      ICOL[k] = j;\n      VAL[k] = 1.0;\n      k++;\n    }\n\n  }\n\n  IRP[i + 1] = k;\n  X[i] = 1.0;\n  Y[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/SpMV/C/spmv/0"}
{"code": "for (int dir = 0; dir < 4; dir++)\n{\n  free(fwdsrc[dir]);\n  free(bcksrc[dir]);\n  free(fwd3src[dir]);\n  free(bck3src[dir]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/dslash-omp/dslash/0"}
{"code": "for (long int idxLoop = 0; idxLoop < NbLoops; ++idxLoop)\n{\n  parallelSum += dotOmp(vec0.data(), vec1.data(), TestSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP5/tests/dot/3"}
{"code": "for (int i = 0; i < 500000; i++)\n{\n  z[i] = (a * x[i]) + y[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Daedgomez/CE-4302-TallerOpenMP/saxpy_par/1"}
{"code": "for (k = 0; k < kmax; k++)\n{\n  if ((k % NPRINT) == 0)\n  {\n    ((cout << \"===================================================\") << endl) << endl;\n    (((cout << \" \tFIRE MINIMIZATION, k = \") << k) << endl) << endl;\n    (cout << \"===================================================\") << endl;\n    (cout << \"\t* Run data:\") << endl;\n    ((cout << \"\t* K \t\t= \") << Kcheck) << endl;\n    ((cout << \"\t* Pvirial \t= \") << Pcheck) << endl;\n    ((cout << \"\t* phi \t\t= \") << phi) << endl;\n    ((cout << \"\t* dt \t\t= \") << dt) << endl;\n    ((cout << \"\t* alpha \t= \") << alpha) << endl;\n    ((cout << \"\t* alphat \t= \") << alphat) << endl;\n    ((cout << \"\t* P \t\t= \") << P) << endl;\n    (cout << endl) << endl;\n  }\n\n  P = 0.0;\n  vstarnrm = 0.0;\n  fstarnrm = 0.0;\n  for (ci = 0; ci < NCELLS; ci++)\n  {\n    for (vi = 0; vi < cell(ci).getNV(); vi++)\n    {\n      for (d = 0; d < NDIM; d++)\n      {\n        ftmp = cell(ci).vforce(vi, d);\n        vtmp = cell(ci).vvel(vi, d);\n        P += ftmp * vtmp;\n        vstarnrm += vtmp * vtmp;\n        fstarnrm += ftmp * ftmp;\n      }\n\n    }\n\n  }\n\n  vstarnrm = sqrt(vstarnrm);\n  fstarnrm = sqrt(fstarnrm);\n  if (P > 0)\n  {\n    npPos++;\n    npNeg = 0;\n    alphat = alpha;\n    if (npPos > NMIN)\n    {\n      if ((dt * finc) < dtmax)\n        dt *= finc;\n      else\n        dt = dtmax;\n\n      alpha *= falpha;\n    }\n\n  }\n  else\n  {\n    npPos = 0;\n    npNeg++;\n    if (npNeg > NNEGMAX)\n      break;\n\n    if (k > NMIN)\n    {\n      if ((dt * fdec) > dtmin)\n        dt *= fdec;\n      else\n        dt = dtmin;\n\n      alpha = alpha0;\n      alphat = alpha;\n    }\n\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (vi = 0; vi < cell(ci).getNV(); vi++)\n      {\n        for (d = 0; d < NDIM; d++)\n          cell(ci).setVPos(vi, d, cell(ci).vpos(vi, d) - ((0.5 * dt) * cell(ci).vvel(vi, d)));\n\n      }\n\n    }\n\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (vi = 0; vi < cell(ci).getNV(); vi++)\n      {\n        for (d = 0; d < NDIM; d++)\n          cell(ci).setVVel(vi, d, 0.0);\n\n      }\n\n    }\n\n  }\n\n  if (fstarnrm > 0)\n  {\n    for (ci = 0; ci < NCELLS; ci++)\n    {\n      for (vi = 0; vi < cell(ci).getNV(); vi++)\n      {\n        for (d = 0; d < NDIM; d++)\n        {\n          vtmp = ((1 - alphat) * cell(ci).vvel(vi, d)) + ((alphat * (cell(ci).vforce(vi, d) / fstarnrm)) * vstarnrm);\n          cell(ci).setVVel(vi, d, vtmp);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (ci = 0; ci < NCELLS; ci++)\n  {\n    cell(ci).verletPositionUpdate(dt);\n    cell(ci).updateCPos();\n  }\n\n  resetContacts();\n  calculateForces();\n  for (ci = 0; ci < NCELLS; ci++)\n    cell(ci).verletVelocityUpdate(dt);\n\n  t += dt;\n  Knew = totalKineticEnergy();\n  Pvirial = (0.5 * (sigmaXX + sigmaYY)) / (L.at(0) * L.at(1));\n  Pcheck = Pvirial;\n  Kcheck = Knew / NCELLS;\n  if (abs(Pcheck) < Ptol)\n    npPMIN++;\n  else\n    npPMIN = 0;\n\n  converged = ((abs(Pcheck) < Ptol) && (npPMIN > NMIN)) && (Kcheck < (100 * Ktol));\n  converged = converged || ((abs(Pcheck) > Ptol) && (Kcheck < Ktol));\n  if (converged)\n  {\n    (cout << \"\t** FIRE has converged!\") << endl;\n    ((cout << \"\t** Kcheck = \") << Kcheck) << endl;\n    ((cout << \"\t** Pcheck = \") << Pcheck) << endl;\n    ((((cout << \"\t** k = \") << k) << \", t = \") << t) << endl;\n    (cout << \"\t** Breaking out of FIRE protocol.\") << endl;\n    if (packingPrintObject.is_open())\n    {\n      (cout << \"\t* Printing vetex positions to file\") << endl;\n      printSystemPositions();\n    }\n\n    if (energyPrintObject.is_open())\n    {\n      (cout << \"\t* Printing cell energy to file\") << endl;\n      printSystemEnergy(k);\n    }\n\n    if (statPrintObject.is_open())\n    {\n      (cout << \"\t* Printing cell contacts to file\") << endl;\n      printSystemContacts();\n    }\n\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/47"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        forcing[i][j][k][m] = (-1.0) * forcing[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/36"}
{"code": "for (int node = 0; node < g->num_nodes; node++)\n{\n  if (frontier->vertices[node] == current_frontier)\n  {\n    const int start_edge = g->outgoing_starts[node];\n    const int end_edge = (node == (g->num_nodes - 1)) ? (g->num_edges) : (g->outgoing_starts[node + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      const int outgoing = g->outgoing_edges[neighbor];\n      if (frontier->vertices[outgoing] == NOT_VISITED_VERTEX)\n      {\n        num_of_frontiers++;\n        distances[outgoing] = distances[node] + 1;\n        frontier->vertices[outgoing] = current_frontier + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction (+:num_of_frontiers) schedule (dynamic, DYNAMIC_CHUNK)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/steven112163/Parallel-Programming/HW3/part2/breadth_first_search/bfs/0"}
{"code": "for (int i = 0; i < NUM_ASSETS; i++)\n  free(ticks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgottlob/portfolio-performance-simulator/src/portfolio/1"}
{"code": "for (i = 0; i < dim; i++)\n  result += (p1.coord[i] - p2.coord[i]) * (p1.coord[i] - p2.coord[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/3"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  C[i] = -1;\n  Visited[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/11"}
{"code": "for (j = 0; j < n; ++j)\n  calculated_pi += pi[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/pi/pi_parallel_array/1"}
{"code": "for (j = 0; j < (m_nSizePoint * ELEMENT_COUNT_POINT); j++)\n  m_pIn[j] = 2.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultPoint3D/1"}
{"code": "for (y = 0; y < ((width * height) * 4); ++y)\n{\n  float d;\n  float dd;\n  float sig;\n  float minus;\n  float s = (10.0f * input[y]) + (100.0f * (1.0f - input[y]));\n  float t = (1.0f * input[y]) + (10.0f * (1.0f - input[y]));\n  float r = (0.01f * input[y]) + (0.05f * (1.0f - input[y]));\n  float sig2 = (0.01f * input[y]) + (0.10f * (1.0f - input[y]));\n  sig = sig2 * sqrtf(t);\n  d = (logf(s / s) + ((r + ((sig2 * sig2) / 2.0f)) * t)) / sig;\n  dd = d - sig;\n  minus = s * expf((-r) * t);\n  output1[y] = (s * func(d)) - (minus * func(dd));\n  output2[y] = (minus * func(-dd)) - (s * func(-d));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_12_parallel_blackscholes/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (c[i] != i)\n    abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_02/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  input[i] = fftOmp_randomGen(&seed);\n  input[i] += fftOmp_randomGen(&seed) * I;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qixuxiang/simple-fft-openmp/fft_omp/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  M[i] = malloc(N * (sizeof(*M[i])));\n  E[i] = malloc(N * (sizeof(*E[i])));\n  M_hat[i] = malloc(N * (sizeof(*M_hat[i])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/4"}
{"code": "for (int i = 0; i < (num_verts + 1); ++i)\n  in_degree_list[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/8"}
{"code": "for (int row = 0; row < rowCount; row++)\n{\n  sprintf(s, \"%s\\t\\t\\t\\t\\t\", s);\n  for (int columns = 0; columns < columnCount; columns++)\n  {\n    sprintf(s, \"%s%d\\t\", s, matrix[row][columns]);\n  }\n\n  sprintf(s, \"%s\\n\", s);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Examples/openmp/2"}
{"code": "for (i = 1; i < (500 - 1); i++)\n{\n  mean = (mean + w[i][0]) + w[i][500 - 1];\n}\n\n", "pragma": "omp for reduction ( + : mean )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/4"}
{"code": "for (i = 0; i < 6; i++)\n{\n  printf(\"Thread %d: Adding %d * %d to sum \\n\", tid, nums[i], nums3[i]);\n  sum += nums[i] * nums3[i];\n}\n\n", "pragma": "\t\t#pragma omp for schedule(guided,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wibeck/c-edu/ParallelTest/ForExample/4"}
{"code": "for (i = 1; i < num_threads; i++)\n{\n  rng[i] = gsl_rng_alloc(rng_t);\n  gsl_rng_set(rng[i], gsl_rng_get(rand));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/PARALLELIZE/mclib/6"}
{"code": "for (int i = 3; i <= n_sqrt; i += 2)\n  if (czyPierwsza[i])\n  for (int j = i * i; j <= n; j += 2 * i)\n{\n  czyPierwsza[j] = false;\n}\n\n\n\n", "pragma": "#pragma omp for schedule(dynamic, 1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/7"}
{"code": "for (unsigned i = 0; i < rows; ++i)\n{\n  for (unsigned j = 0; j < cols; ++j)\n  {\n    a[(i * cols) + j] = numb;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/5"}
{"code": "for (int i = k1; i < k2; i++)\n{\n  w = (lrand48() / ((float) INT_MAX)) * totalweight;\n  l = 0;\n  r = points->num - 1;\n  if (accumweight[0] > w)\n  {\n    (*feasible)[i] = 0;\n    continue;\n  }\n\n  while ((l + 1) < r)\n  {\n    k = (l + r) / 2;\n    if (accumweight[k] > w)\n    {\n      r = k;\n    }\n    else\n    {\n      l = k;\n    }\n\n  }\n\n  (*feasible)[i] = r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/20"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  const double sign_q = qom[is] / fabs(qom[is]);\n  for (int i = 1; i < nxn; i++)\n    for (int k = 1; k < nzn; k++)\n  {\n    xd = grid->getXN(i, 1, k) - x_center;\n    zd = grid->getZN(i, 1, k) - z_center;\n    if (((xd * xd) + (zd * zd)) <= (R * R))\n    {\n      rhons[is][i][1][k] = (sign_q * rhoINIT[is]) / FourPI;\n      rhons[is][i][2][k] = (sign_q * rhoINIT[is]) / FourPI;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/43"}
{"code": "for (int x = kern_cent_X; x < (data_size_X - kern_cent_X); x++)\n{\n  for (int y = data_size_Y - kern_cent_Y; y < data_size_Y; y++)\n  {\n    for (int j = -kern_cent_Y; j <= ((data_size_Y - 1) - y); j++)\n    {\n      for (int i = -kern_cent_X; i <= kern_cent_X; i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kt9302/ImageConvolution/part2/5"}
{"code": "for (i = 0; i < ni; i++)\n{\n  for (j = 0; j < nj; j++)\n  {\n    s0 = 0;\n    for (k = 0; k < nk; k++)\n    {\n      s0 += inA[(i * nk) + k] * inB[(k * nj) + j];\n    }\n\n    outC[(i * nj) + j] = (a * s0) + (b * outC[(i * nj) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/holoubekm/BI-EIA/task_1/assignment/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (!(A[i] % 2))\n  {\n    omp_set_lock(&lock);\n    if (!(A[i] % 2))\n      total += B[i] + C[i];\n\n    omp_unset_lock(&lock);\n  }\n  else\n    if (!((A[i] == 1) || (B[i] == 1)))\n  {\n    omp_set_lock(&lock);\n    if (!((A[i] == 1) || (B[i] == 1)))\n      total += B[i] - A[i];\n\n    omp_unset_lock(&lock);\n  }\n\n\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VGol-Git/OpenMP/OpenMP/LAB6_1/1"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < D; j++)\n  data[(i * D) + j] = rand() / ((float) RAND_MAX);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/stddev-omp/main/1"}
{"code": "for (j = 0; j < np; j++)\n{\n  for (i = 0; i < nd; i++)\n  {\n    vel[i + (j * nd)] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/md_open_mp/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (((fabs(C[i] - C_ref[i]) > 1e-3) || (fabs(theta[i] - theta_ref[i]) > 1e-3)) || (fabs(K[i] - K_ref[i]) > 1e-3))\n  {\n    ok = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vanGenuchten-omp/main/3"}
{"code": "for (int j = 0; j < 10000; j++)\n{\n  activateNN(TEST_INPUT[j]);\n  category = classDecision(OL2);\n  desiredCategory = desiredDecision(j, train_flag);\n  categoryTruth = decisionTruth(category, desiredCategory);\n  if (categoryTruth)\n  {\n    trueDecisioncounter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex4/ex4/3"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  for (int ColIdx = 0; ColIdx < NNewCols; ColIdx++)\n  {\n    Mat->PutXY(RowIdx, Cols + ColIdx, ColMat(RowIdx, ColIdx));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/109"}
{"code": "for (unsigned int i = 0; i < ld; i++)\n{\n  pos[i] = posi();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keygenx/N-Vector-Model/Vector Model/11"}
{"code": "for (i = 0; i < 62; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 7; j++)\n    for (k = 0; k < 15; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sugiartocokrowibowo/openmp-exercises/omp_mm/3"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t k;\n  uint32_t src;\n  uint32_t dest;\n  uint64_t weight = DoubleToFixed64(0.0001f);\n  struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n  for (k = 0; k < partition->num_edges; ++k)\n  {\n    src = partition->edgeList->edges_array_src[k];\n    dest = partition->edgeList->edges_array_dest[k];\n    weight = DoubleToFixed64(partition->edgeList->edges_array_weight[k]);\n    vector_output[dest] += MULFixed64V1(weight, vector_input[src]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/20"}
{"code": "for (i = 0; i < file_info->K; i++)\n{\n  fprintf(f, \"[%lf, %lf, %lf]\\n\", k_clusters[i].centroid.x, k_clusters[i].centroid.y, k_clusters[i].centroid.z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/5"}
{"code": "for (int i = 0; i < ncommdom; i++)\n{\n  const int k = comap->commpartner[i];\n  if (k > myid)\n  {\n    MPI_Send(&recv_byteoffset[k], sizeof(gaspi_offset_t), (MPI_Datatype) 0x4c00010d, k, tag, 1);\n    MPI_Recv(&remote_byteoffset[k], sizeof(gaspi_offset_t), (MPI_Datatype) 0x4c00010d, k, tag, 1, (MPI_Status *) 1);\n  }\n  else\n  {\n    MPI_Recv(&remote_byteoffset[k], sizeof(gaspi_offset_t), (MPI_Datatype) 0x4c00010d, k, tag, 1, (MPI_Status *) 1);\n    MPI_Send(&recv_byteoffset[k], sizeof(gaspi_offset_t), (MPI_Datatype) 0x4c00010d, k, tag, 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/GASPI_OpenMP_threads/linsolv/src/exchange_matrix/4"}
{"code": "for (size_t i = 0; i < bodies.size(); i++)\n{\n  serialized[i] = serialize_body(bodies[i]);\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(bodies, serialized)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andreastedile/barnes-hut/src/data_transfer/body_serialization/0"}
{"code": "for (i = ist; i <= L2; i += 1)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21i = tmp * rsd[i][j][k][1];\n  u31i = tmp * rsd[i][j][k][2];\n  u41i = tmp * rsd[i][j][k][3];\n  u51i = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i - 1][j][k][0];\n  u21im1 = tmp * rsd[i - 1][j][k][1];\n  u31im1 = tmp * rsd[i - 1][j][k][2];\n  u41im1 = tmp * rsd[i - 1][j][k][3];\n  u51im1 = tmp * rsd[i - 1][j][k][4];\n  flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n  flux[i][j][k][2] = tx3 * (u31i - u31im1);\n  flux[i][j][k][3] = tx3 * (u41i - u41im1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((1.40e+00 * 1.40e+00) * tx3) * (u51i - u51im1));\n}\n\n", "pragma": "omp parallel for private (u21im1,u31im1,u41im1,u51im1,tmp,u21i,u31i,u41i,u51i,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/24"}
{"code": "for (i = nu - 2; 0 <= i; i--)\n{\n  f[i] = f[i] - (arite[i] * f[i + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/23"}
{"code": "for (j = num_buckets - 1; j >= 0; --j)\n{\n  temp_idx = 0;\n  for (t = 0; t < P; ++t)\n  {\n    start_idx[(t * num_buckets) + j] = temp_idx;\n    temp_idx += vc_vector_count(buckets[(t * num_buckets) + j]);\n  }\n\n  sizeHot[j] = temp_idx;\n  degreesHot[j] = (uint32_t *) my_malloc(sizeHot[j] * (sizeof(uint32_t)));\n  verticesHot[j] = (uint32_t *) my_malloc(sizeHot[j] * (sizeof(uint32_t)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/25"}
{"code": "for (uint i = 2; i <= N; i++)\n  result += isPrime[i];\n\n", "pragma": "    #pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe/2"}
{"code": "for (int j = 0; j < n; ++j)\n{\n  for (int ka = 0; ka < na; ++ka)\n  {\n    for (int kb = 0; kb < nb; ++kb)\n    {\n      int i = (ka * nb) + kb;\n      vd[(na * j) + ka][kb] = (i < n) ? (d_[(n * j) + i]) : (infty);\n      vt[(na * j) + ka][kb] = (i < n) ? (d_[(n * i) + j]) : (infty);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallel-rust-cpp/shortcut-comparison/src/cpp/v3_simd/step/0"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  b[i][j] = (y[i][j] = (x[i][j] = 0));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/13"}
{"code": "for (int i = 0; i < _cachedSDF->Index.TotalSize; i++)\n{\n  CalculateEdge(i);\n}\n\n", "pragma": "#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HeartofTheForce/Isosurface/src/DualContouring/MeshGenerator/1"}
{"code": "for (i = 1; i < (((L / 1) + 2) - 1); i++)\n{\n  j = 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    got[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    got[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n  j = ((L / 5) + 2) - 2;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    get[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    get[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/38"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    for (int k = 0; k < N; ++k)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/2/2/2"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      Du[pp] = pre_factor_6_dz * (((((((-u[pp - (3 * n)]) + (6.0 * u[pp - (2 * n)])) - (15.0 * u[pp - n])) + (20.0 * u[pp])) - (15.0 * u[pp + n])) + (6.0 * u[pp + (2 * n)])) - u[pp + (3 * n)]);\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/23"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (fillByRandom)\n      newElements[i][j] = rand() % 100;\n    else\n      newElements[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeioff/OpenMP-matrix-experiments/main/1"}
{"code": "for (t = 0.0; t < t_end; t += del_t, iters++)\n{\n  set_timestep_interval(&del_t, imax, jmax, delx, dely, u, v, Re, tau);\n  ifluid = (imax * jmax) - ibound;\n  compute_tentative_velocity(u, v, f, g, flag, imax, jmax, del_t, delx, dely, gamma, Re);\n  compute_rhs(f, g, rhs, flag, imax, jmax, del_t, delx, dely);\n  if (ifluid > 0)\n  {\n    itersor = poisson(p, rhs, flag, imax, jmax, delx, dely, eps, itermax, omega, &res, ifluid);\n  }\n  else\n  {\n    itersor = 0;\n  }\n\n  if ((proc == 0) && (verbose > 1))\n  {\n    printf(\"%d t:%g, del_t:%g, SOR iters:%3d, res:%e, bcells:%d\\n\", iters, t + del_t, del_t, itersor, res, ibound);\n  }\n\n  update_velocity(u, v, f, g, p, flag, imax, jmax, del_t, delx, dely);\n  apply_boundary_conditions(u, v, flag, imax, jmax, ui, vi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/karman/1"}
{"code": "for (i = 0; i < grid_sz; i++)\n{\n  for (j = 0; j < grid_sz; j++)\n    freeLinkedList(grid[i][j].par_list);\n\n  free(grid[i]);\n}\n\n", "pragma": "omp for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelV/grid/3"}
{"code": "for (int i = 0; i < 8; i++)\n  for (int j = 0; j < 8; j++)\n{\n  temp[i][j] = data[j][i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testv2/3"}
{"code": "for (uint64_t i = start_chunk; i < end_chunk; i++)\n{\n  const KEY_TYPE key = my_keys[i];\n  const uint32_t bucket_index = key / BUCKET_WIDTH;\n  uint32_t index = tmp[bucket_index]++;\n  assert(index < NUM_KEYS_PER_PE);\n  my_local_bucketed_keys[index] = key;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  eigenvalues[i] = right_boundary;\n  lowerbounds[i] = left_boundary;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/Bisection/8"}
{"code": "for (int i = 0; i <= numcells; i++)\n{\n  UFLUX2[i] = uss[i];\n  FR2[i] = dss[i] * uss[i];\n  FRU2[i] = ((dss[i] * uss[i]) * uss[i]) + pss[i];\n  FRE2[i] = (((pss[i] / (GAMMA - 1.0)) + (((0.5 * dss[i]) * uss[i]) * uss[i])) * uss[i]) + (pss[i] * uss[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/6"}
{"code": "for (int i = 0; i < num_bin; i++)\n{\n  if ((val[0] >= (min + (i * len_bin))) && (val[0] < (min + ((i + 1) * len_bin))))\n  {\n    return i;\n  }\n  else\n    if (max == val[0])\n  {\n    return num_bin - 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/2"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  double x_i = a + (h * i);\n  double x_j = a + (h * (i + 1));\n  double d = (f(x_i) + f(x_j)) / 2.0;\n  sum += d * h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture11/Trapezoidal_critical_atomic/Trapezoidal_critical_atomic/0"}
{"code": "for (int i = 0; i < row1; i++)\n{\n  for (int j = 0; j < col1; j++)\n  {\n    printf(\"%d\\t\", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zeeshanmahar007/Matrix-Matrix-Multiplication-in-Parallel/omp_parallel/7"}
{"code": "for (int octant = 0; octant < NOCTANT; ++octant)\n  for (int im = 0; im < dims.nm; ++im)\n  for (int ia = 0; ia < dims.na; ++ia)\n{\n  m_from_a[M_FROM_A_ADDR(dims.na, im, ia, octant)] /= NOCTANT;\n  m_from_a[M_FROM_A_ADDR(dims.na, im, ia, octant)] /= 1 << (ia & ((1 << 3) - 1));\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/minisweep-omp/main/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = k.arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector/1"}
{"code": "for (unsigned int idz = 0.0; idz < DATAZSIZE; idz++)\n{\n  for (unsigned int idy = 0.0; idy < DATAYSIZE; idy++)\n  {\n    for (unsigned int idx = 0.0; idx < DATAXSIZE; idx++)\n    {\n      double f = ((double) rand()) / RAND_MAX;\n      c[idz][idy][idx] = (-1.0) + (2.0 * f);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/che-omp/main/4"}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  sprnvc(n, nzv, v, iv, &colidx[0], &colidx[n]);\n  vecset(n, v, iv, &nzv, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    if ((jcol >= firstcol) && (jcol <= lastcol))\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        if ((irow >= firstrow) && (irow <= lastrow))\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/19"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/133"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  n = seqlen_array[si + 1];\n  for (i = 1, len1 = 0; i <= n; i++)\n  {\n    char c = seq_array[si + 1][i];\n    if ((c != gap_pos1) && (c != gap_pos2))\n      len1++;\n\n  }\n\n  for (sj = si + 1; sj < nseqs; sj++)\n  {\n    m = seqlen_array[sj + 1];\n    if ((n == 0) || (m == 0))\n    {\n      bench_output[(si * nseqs) + sj] = (int) 1.0;\n    }\n    else\n    {\n      {\n        int se1;\n        int se2;\n        int sb1;\n        int sb2;\n        int maxscore;\n        int seq1;\n        int seq2;\n        int g;\n        int gh;\n        int displ[(2 * 5000) + 1];\n        int print_ptr;\n        int last_print;\n        for (i = 1, len2 = 0; i <= m; i++)\n        {\n          char c = seq_array[sj + 1][i];\n          if ((c != gap_pos1) && (c != gap_pos2))\n            len2++;\n\n        }\n\n        if (dnaFlag == TRUE)\n        {\n          g = (int) (((2 * 100) * pw_go_penalty) * gap_open_scale);\n          gh = (int) ((100 * pw_ge_penalty) * gap_extend_scale);\n        }\n        else\n        {\n          gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n          g = (int) ((mat_avscore <= 0) ? ((2 * 100) * gg) : (((2 * mat_avscore) * gg) * gap_open_scale));\n          gh = (int) (100 * pw_ge_penalty);\n        }\n\n        seq1 = si + 1;\n        seq2 = sj + 1;\n        forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n        reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n        print_ptr = 1;\n        last_print = 0;\n        diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n        mm_score = tracepath(sb1, sb2, &print_ptr, displ, seq1, seq2);\n        if ((len1 == 0) || (len2 == 0))\n          mm_score = 0.0;\n        else\n          mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n\n        bench_output[(si * nseqs) + sj] = (int) mm_score;\n      }\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) private(i, n, si, sj, len1, m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/bots/alignment/alignment_for/alignment/0"}
{"code": "for (size_t l_ch = 0; l_ch < l_nChs; l_ch++)\n{\n  size_t l_raAd = m_commStruct[(1 + (l_ch * 4)) + 1];\n  EDGE_CHECK_NE(g_rank, (int) l_raAd);\n  EDGE_CHECK_GT(g_nRanks, (int) l_raAd);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/mesh/EdgeV/6"}
{"code": "for (ei_new = 0; ei_new <= (public.in2_pad_cols - 1); ei_new += 1)\n{\n  pos_ori = ei_new * public.in2_pad_rows;\n  sum = 0;\n  for (position = pos_ori; position <= ((pos_ori + public.in2_pad_rows) - 1); position = position + 1)\n  {\n    private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n    sum = private.d_in2_pad[position];\n  }\n\n}\n\n", "pragma": "omp parallel for private (sum,pos_ori,ei_new,position)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/4"}
{"code": "for (int i = 0; i < parents.size(); ++i)\n{\n  int index1 = rand() % parents.size();\n  int index2 = rand() % parents.size();\n  swap(parents[index1], parents[index2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaikh-Ubaid/Parallel-Implementation-of-Genetic-Algorithm-using-OpenMP-for-solving-TSP/180001050_Ubaid_main_parallel/5"}
{"code": "for (int k = 0; k < MAX_MATRIX_LENGTH; k++)\n{\n  for (i_iter = 0; i_iter < matrixRows; i_iter++)\n  {\n    for (j_iter = 0; j_iter < MAX_MATRIX_LENGTH; j_iter++)\n      matrix_final[i_iter][k] += matrix_0[i_iter][j_iter] * matrix_1[j_iter][k];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiippu/MSMPI-and-OpenMP/M3.T1P/Source/4"}
{"code": "for (i = 0; i < size; i++)\n{\n  v[i] = 1 + ((int) UNI);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/8"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  list_cities[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lar9482/High-Performance-Computing-Projects/TSP/Ant Colony Attempt/Ant_Colony/8"}
{"code": "for (i = 0; i < 9; i++)\n{\n  if (taules[thread].taula[x][i] == z)\n    return 0;\n\n  if (taules[thread].taula[i][y] == z)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/3"}
{"code": "for (int i = 0; i < columns; i++)\n{\n  mean[i] = calculateMean(dataset, i, rows);\n  std[i] = calculateStandardDeviation(dataset, i, rows, mean[i]);\n}\n\n", "pragma": "    #pragma omp parallel for shared(mean, std, columns, dataset)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-Hybrid-OpenMP-MPI/OpenMP/StandardScaler/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] += offset;\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/prefixsum/3"}
{"code": "for (int y = 1; y < (rows - 1); y++)\n{\n  for (int x = 1; x < (columns - 1); x++)\n  {\n    fprintf(fp, \"%c\", *((grid + (y * columns)) + x));\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp_alt_1dArr/0"}
{"code": "for (int j = 0; j < o; j++)\n{\n  sum += A[i][j] * b[j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum)\t\t\t\t\t\t\t", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task3/4"}
{"code": "for (j = jbeg; j < jfin; j++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    k = ki1;\n    phi1[j][i] = C2 * (u[k][j][i][4] - ((0.50 * (((u[k][j][i][1] * u[k][j][i][1]) + (u[k][j][i][2] * u[k][j][i][2])) + (u[k][j][i][3] * u[k][j][i][3]))) / u[k][j][i][0]));\n    k = ki2 - 1;\n    phi2[j][i] = C2 * (u[k][j][i][4] - ((0.50 * (((u[k][j][i][1] * u[k][j][i][1]) + (u[k][j][i][2] * u[k][j][i][2])) + (u[k][j][i][3] * u[k][j][i][3]))) / u[k][j][i][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/20"}
{"code": "for (i = 0; i < ncols; i++)\n{\n  for (tsum = 0.0, ncand = 0, j = colptr[i]; j < colptr[i + 1]; j++, ncand++)\n  {\n    cand[ncand].val = colind[j];\n    cand[ncand].key = colval[j];\n    tsum += (norm == 1) ? (colval[j]) : (colval[j] * colval[j]);\n  }\n\n  gk_fkvsortd(ncand, cand);\n  for (rsum = 0.0, j = 0; (j < ncand) && (rsum <= (fraction * tsum)); j++)\n  {\n    rsum += (norm == 1) ? (cand[j].key) : (cand[j].key * cand[j].key);\n    nrowind[nrowptr[cand[j].val]] = i;\n    nrowval[nrowptr[cand[j].val]] = cand[j].key;\n    nrowptr[cand[j].val]++;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/0"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  int i;\n  for (i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n  }\n\n  double elt;\n  elt = timer();\n  qsort(B, n, sizeof(float), qs_cmpf);\n  elt = timer() - elt;\n  avg_elt += elt;\n  fprintf(stderr, \"%9.3lf\\n\", elt * 1e3);\n  for (i = 1; i < n; i++)\n  {\n    assert(B[i] >= B[i - 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/5"}
{"code": "for (j = jbeg; j <= jfin1; j++)\n{\n  for (k = ki1; k <= (ki2 - 1); k++)\n  {\n    frc3 = frc3 + (((((((phi1[j][k] + phi1[j + 1][k]) + phi1[j][k + 1]) + phi1[j + 1][k + 1]) + phi2[j][k]) + phi2[j + 1][k]) + phi2[j][k + 1]) + phi2[j + 1][k + 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/43"}
{"code": "for (int j = 0; j < omp_p; j++)\n{\n  unsigned int seed = (j * p) + myrank;\n  size_t start = (j * N) / omp_p;\n  size_t end = ((j + 1) * N) / omp_p;\n  for (unsigned int i = start; i < end; i++)\n  {\n    in[i] = rand_r(&seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hsundar/usort/src/main/1"}
{"code": "for (long k = 0; k < numUniqueClusters; k++)\n{\n  if (sc != clusterLocalMap[sPosition + k].cid)\n  {\n    ay = cInfo[clusterLocalMap[sPosition + k].cid].degree;\n    eiy = clusterLocalMap[sPosition + k].Counter;\n    curGain = (2 * (eiy - eix)) - (((2 * degree) * (ay - ax)) * constant);\n    if ((curGain > maxGain) || (((curGain == maxGain) && (curGain != 0)) && (clusterLocalMap[sPosition + k].cid < maxIndex)))\n    {\n      maxGain = curGain;\n      maxIndex = clusterLocalMap[sPosition + k].cid;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusteringFunctions/6"}
{"code": "for (int i = point_index + 1; i < total_points; i++)\n{\n  if (sqr_distances[(point_index * total_points) + i] && (!processed[i]))\n  {\n    indices.push_back(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload/euclidean_cluster/kernel/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if (sorttype != RADIX)\n    (cout << getkey(data, i)) << \"\\t\";\n  else\n    (cout << getkey(data, i)) << \"\\n\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/test/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n  A[i][j] = (((DATA_TYPE) i) * j) / ni;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/syrk/syrk/1"}
{"code": "for (i = ii; i < (((ii + 100) < 1000) ? (ii + 100) : (1000)); i++)\n{\n  for (j = jj; j < (((jj + 100) < 1000) ? (jj + 100) : (1000)); j++)\n  {\n    for (k = kk; k < (((kk + 100) < 1000) ? (kk + 100) : (1000)); k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/Tiled/tiled_parallel_outer_for_i/0"}
{"code": "for (i = 0; i < 24576; i++)\n{\n  if (percentDiff(x1[i], x1_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n  if (percentDiff(x2[i], x2_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/MVT/mvt_cpu/11"}
{"code": "for (int y = 0; y < height; ++y)\n{\n  for (int x = 0; x < width; ++x)\n  {\n    resultImage.set_pixel(x, y, rgb_pixel(image.Area[(y * width) + x].r, image.Area[(y * width) + x].g, image.Area[(y * width) + x].b));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/12"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  result[i] = dis(gen);\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NasyaS/OpenMP/main/2"}
{"code": "for (j = 0; j < nx; j++)\n{\n  a[j] = b[j] + c[j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/quickstart/smdemo_omp/omplib/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, hydro_data->r0[i] - (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] - (0.5 * hydro_data->r1_size[i]), 0);\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, hydro_data->r0[i] + (0.5 * hydro_data->r0_size[i]), hydro_data->r1[i] + (0.5 * hydro_data->r1_size[i]), 0);\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      if (spect == 'w')\n      {\n        y_dum = 1;\n        yfr_dum = 0;\n        while (y_dum > yfr_dum)\n        {\n          fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * hydro_data->temp[i];\n          y_dum = gsl_rng_uniform_pos(rand);\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / hydro_data->temp[i], 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * hydro_data->temp[i])) - 1);\n        }\n\n      }\n      else\n      {\n        test = 0;\n        test_rand1 = gsl_rng_uniform_pos(rand);\n        test_rand2 = gsl_rng_uniform_pos(rand);\n        test_rand3 = gsl_rng_uniform_pos(rand);\n        test_rand4 = gsl_rng_uniform_pos(rand);\n        test_rand5 = gsl_rng_uniform_pos(rand);\n        test_cnt = 0;\n        while (test < (((((M_PI * M_PI) * M_PI) * M_PI) * test_rand1) / 90.0))\n        {\n          test_cnt += 1;\n          test += 1 / (((test_cnt * test_cnt) * test_cnt) * test_cnt);\n        }\n\n        fr_dum = (-log(((test_rand2 * test_rand3) * test_rand4) * test_rand5)) / test_cnt;\n        fr_dum *= (K_B * hydro_data->temp[i]) / PL_CONST;\n        y_dum = 0;\n        yfr_dum = 1;\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], hydro_data->r2[i]);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].comv_p0 = *(p_comv + 0);\n      (*ph)[ph_tot].comv_p1 = *(p_comv + 1);\n      (*ph)[ph_tot].comv_p2 = *(p_comv + 2);\n      (*ph)[ph_tot].comv_p3 = *(p_comv + 3);\n      position_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r0_size[i]) - (0.5 * hydro_data->r0_size[i]);\n      position2_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r1_size[i]) - (0.5 * hydro_data->r1_size[i]);\n      position3_rand = (gsl_rng_uniform_pos(rand) * hydro_data->r2_size[i]) - (0.5 * hydro_data->r2_size[i]);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i] + position_rand, hydro_data->r1[i] + position2_rand, hydro_data->r2[i] + position3_rand);\n      (*ph)[ph_tot].r0 = cartesian_position_rand_array[0];\n      (*ph)[ph_tot].r1 = cartesian_position_rand_array[1];\n      (*ph)[ph_tot].r2 = cartesian_position_rand_array[2];\n      (*ph)[ph_tot].s0 = 1;\n      (*ph)[ph_tot].s1 = 0;\n      (*ph)[ph_tot].s2 = 0;\n      (*ph)[ph_tot].s3 = 0;\n      (*ph)[ph_tot].num_scatt = 0;\n      (*ph)[ph_tot].weight = ph_weight_adjusted;\n      (*ph)[ph_tot].nearest_block_index = 0;\n      (*ph)[ph_tot].type = INJECTED_PHOTON;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/23"}
{"code": "for (int i = 0; i < size_mat; i++)\n{\n  for (int j = 0; j < size_mat; j++)\n  {\n    (cout << _MAT[i][j]) << \"  \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SboneloMdluli/ELEN4020-Lab2/OpenMP/block_MP/1"}
{"code": "for (int idx = 0; idx < mm_len; idx++)\n{\n  double nm = n[matids[idx]];\n  p_compact_list[idx] = ((nm * rho_compact_list[idx]) * t_compact_list[idx]) / Vf_compact_list[idx];\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(thx*thy)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/compact/3"}
{"code": "for (i = 0; i < nclusters; i++)\n{\n  clusters[i] = (float *) omp_target_alloc(nfeatures * (sizeof(float)), -100);\n  total_size += nfeatures * (sizeof(float));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/kmeans/kmeans_openmp/kmeans_clustering/8"}
{"code": "for (int i = (bloc_size / 2) - 1; i >= 0; i--)\n  heapify(bloc, bloc_size, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/4"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    float prod = 0.0f;\n    for (k = 0; k < n; ++k)\n    {\n      prod += A[(k * n) + i] * B[(j * n) + k];\n    }\n\n    C[(j * n) + i] = (alpha * prod) + (beta * C[(j * n) + i]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared( A, B, C, n ) private( i, j, k ) schedule( static )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnicely/computeWorks_examples/jupyter/src/openmp/2"}
{"code": "for (int i = k + 1; i < n; ++i)\n{\n  double t = A[i][k] / A[k][k];\n  b[i] -= t * b[k];\n  for (int j = k + 1; j < n; ++j)\n  {\n    A[i][j] -= t * A[k][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for if(k < 800)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/145"}
{"code": "for (i = 0; i < tmp; i++)\n  localscore[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/15"}
{"code": "for (i = 0; i < num_array; i++)\n{\n  *(gamma + i) = gamma_infinity;\n  *(vx + i) = 0;\n  *(vy + i) = vel;\n  *(dens + i) = ddensity;\n  *(dens_lab + i) = lab_dens;\n  *(pres + i) = (A_RAD * pow(t_comov, 4.0)) / (3 * pow(C_LIGHT, 2.0));\n  *(temp + i) = pow(((3 * (*(pres + i))) * pow(C_LIGHT, 2.0)) / A_RAD, 1.0 / 4.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/15"}
{"code": "for (int i = 1; i < n; i++)\n{\n  result += (2 * f((i * h) + a)) * ((i % 2) + 1);\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+ : result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sMeDDveD/ComputerArchitecture/OpenMP/2_Integration/Program/0"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/52"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    command_queue[i][j] = clCreateCommandQueue(context, device_id[i], 0, &err);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/2"}
{"code": "for (register int jj = 0; jj <= (count - 1); jj += 1)\n{\n  int idx = list[jj];\n  sum += tmp[idx];\n}\n\n", "pragma": "omp parallel for reduction (+:sum) firstprivate (count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_v1_accumulateForce/0"}
{"code": "for (i = 0; i < nrows; i++)\n  temp[i] = w[index[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/31"}
{"code": "for (int i = 0; i < reduced_size; i++)\n{\n  for (int j = 0; j < reduced_size; j++)\n  {\n    a11[i][j] = A[i][j];\n    a12[i][j] = A[i][j + reduced_size];\n    a21[i][j] = A[i + reduced_size][j];\n    a22[i][j] = A[i + reduced_size][j + reduced_size];\n    b11[i][j] = B[i][j];\n    b12[i][j] = B[i][j + reduced_size];\n    b21[i][j] = B[i + reduced_size][j];\n    b22[i][j] = B[i + reduced_size][j + reduced_size];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YShoun/matrix-mul/main/7"}
{"code": "for (int i = 0; i < NODES_NUM; i++)\n{\n  next_rank[i] = 0;\n  rank[i] = 1.0 / NODES_NUM;\n  outedge_number_per_node[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhixue/Parrallel-programming-course/hk2_openmp/hw2_3/6"}
{"code": "for (int i = 0; i < num_of_wires; i++)\n{\n  free(wires[i].currentPath);\n  free(wires[i].prevPath);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/13"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  count_r[i] = 0;\n  count_g[i] = 0;\n  count_b[i] = 0;\n  private_count_r[i] = 0;\n  private_count_g[i] = 0;\n  private_count_b[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/6"}
{"code": "for (j = 0; j < 40000000; j++)\n{\n  aSumErr += ((a[j] - aj) >= 0) ? (a[j] - aj) : (-(a[j] - aj));\n  bSumErr += ((b[j] - bj) >= 0) ? (b[j] - bj) : (-(b[j] - bj));\n  cSumErr += ((c[j] - cj) >= 0) ? (c[j] - cj) : (-(c[j] - cj));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/9"}
{"code": "for (int k = k1; k < k2; k++)\n{\n  mytotal += points->p[k].cost;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/7"}
{"code": "for (i = 0; i < (384 - 6); ++i)\n{\n  *(redmeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 6));\n  *(greenmeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 6));\n  *(bluemeanfilteredmatrix + i) = (int *) malloc((sizeof(int)) * (512 - 6));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-3/codes/with-sections/meanfilter7x7/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] * dt;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/rhs/10"}
{"code": "for (long i = 0; i < nv; i++)\n{\n  const long start = (vertexColor[i] < 0) ? (numColor - 1) : (vertexColor[i]);\n  __sync_fetch_and_add(&colorPtr[((long) start) + 1], 1);\n}\n\n", "pragma": "#pragma omp parallel for firstprivate(numColor) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/0"}
{"code": "for (i = 40 / 2; i < 40; i++)\n  printf(\" %2d\", A[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanecaradonna/openMP/Ejercicio7/ejercicio7/5"}
{"code": "for (j = 0; j < (1 << 16); j++)\n{\n  X[j] = j;\n  Y[j] = 2 * j;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh2496/OpenMP-Programming-Problems/P3/p3/0"}
{"code": "for (size_t i = 0; i <= (gast.size() - 1); ++i)\n{\n  {\n    calcularDistancia(gast[i], gast, planetas, n_threads);\n    calcularMovimientoNormal(gast[i], gast, planetas, n_threads);\n    calcularFuerzaX(gast[i], gast, planetas, n_threads);\n    calcularFuerzaY(gast[i], gast, planetas, n_threads);\n    calcularMovimientoAsteriode(gast[i], n_threads);\n    calcularRebotePared(gast[i]);\n  }\n}\n\n", "pragma": "                    #pragma omp parallel for ordered num_threads(n_threads) firstprivate(planetas)                     ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Montware/sequential-vs-openmp/_old_par/main/0"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 200; j++)\n  {\n    O[i][j] = 0;\n    for (k = 0; k < 200; k++)\n    {\n      O[i][j] = O[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/CAB401-OpenMP/matMult-comparison/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpkr3hjjuv.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (int i = 0; i < m; i++)\n{\n  b[i] = a[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/22"}
{"code": "for (i = 0; i < num_data; i++)\n{\n  tot_sum += data[i];\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+:tot_sum) default(none) private(i) shared(num_data, data)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_basic_sum/0"}
{"code": "for (short i = 0; i < imageMap[0].size(); i++)\n{\n  for (short j = 0; j < imageMap.size(); j++)\n  {\n    if (isColor)\n    {\n      (ofs << imageMap[j][i].red) << \" \";\n      (ofs << imageMap[j][i].green) << \" \";\n      (ofs << imageMap[j][i].blue) << \" \";\n    }\n    else\n    {\n      ofs << imageMap[j][i].grey;\n    }\n\n    if (j != (height - 1))\n    {\n      ofs << \" \";\n    }\n\n  }\n\n  ofs << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tjp77/Seam-Carver/Seam Carver/4"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (i = 0; i < m; i++)\n  {\n    k = (*seed) / 127773;\n    *seed = (16807 * ((*seed) - (k * 127773))) - (k * 2836);\n    if ((*seed) < 0)\n    {\n      *seed = (*seed) + i4_huge;\n    }\n\n    r[i + (j * m)] = a + (((b - a) * ((double) (*seed))) * 4.656612875E-10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPC-Project/openMp/openmp/8"}
{"code": "for (y = 0; y < numOnes; y++)\n  likelihoodSum += (pow(I[ind[y]] - 100, 2) - pow(I[ind[y]] - 228, 2)) / 50.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/18"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = (double *) malloc((n + 1) * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BorhaneddineHamadou/Gausse-Jordan-Algorithm/openmp/1"}
{"code": "for (i = 0; i < remainder; i++)\n{\n  myPoints[myPointNum + i] = points[j];\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ranaihab/Frequency-Histogram/a3/0"}
{"code": "for (c1 = 0; c1 <= (((((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) < (nm + (-1))) ? (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nj > nm) ? (nj) : (nm); c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nk > nm) ? (nk) : (nm); c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = (nj > nk) ? (nj) : (nk); c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/1"}
{"code": "for (int32_t i = 0; i < N; ++i)\n{\n  int32_t idx = 0;\n  if (vals[i] < N)\n  {\n    idx = vals[i];\n  }\n  else\n  {\n    idx = N;\n  }\n\n  ++buffer[idx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = rand() / ((float) 32767);\n  y[i] = rand() / ((float) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PurplePachyderm/openmp-gputool/tests/0"}
{"code": "for (i = 1; i <= ((n - 1) - 1); i += 1)\n{\n  for (j = 1; j <= ((m - 1) - 1); j += 1)\n  {\n    resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n    u[i][j] = uold[i][j] - (omega * resid);\n    error = error + (resid * resid);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_v1_jacobi_seq/0"}
{"code": "for (i = 1; i < m; i++)\n{\n  rowU[i] = i - 1;\n  rowD[i - 1] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/7"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(stderr, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(stderr, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(stderr, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static/2"}
{"code": "for (i = 0; i <= 6; i += 1)\n{\n  if (timer_read(i) != 0.0)\n  {\n    printf(\"timer %2d(%16s( :%10.6f\\n\", i, tstrings[i], timer_read(i));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/25"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 5; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemafe7/SistemasDistribuidos/p5/2"}
{"code": "for (int i = 0; i < 8; ++i)\n  for (int j = 0, k = 0; j < 8; ++j)\n  ;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/tools/clang/test/Analysis/openmp-unsupported/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    YTF[i][j] = YF[j][i];\n    YTD[i][j] = YD[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yemrecakir/ParalelMatrisCarpimi/Blockmatrixopenmp/Blockmatrixopenmp/5"}
{"code": "for (int j = 0; j < num_mutations; j++)\n{\n  int indiv_to_mutate = uniform_pop(this->mt);\n  int locus_to_mutate = uniform_locus(this->mt);\n  int new_trait = next_trait[locus_to_mutate];\n  ++next_trait[locus_to_mutate];\n  population_traits[(indiv_to_mutate * numloci) + locus_to_mutate] = new_trait;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmadsen/neutral-model-cpp/src/population/3"}
{"code": "for (size_t i = 1; i < (array_size - 1); ++i)\n{\n  float out[4];\n  _mm_store_ps(out, vY1[i]);\n  if (((((is_valid == true) && (out[0] == vecy1[j])) && (out[1] == vecy1[j + 1])) && (out[2] == vecy1[j + 2])) && (out[3] == vecy1[j + 3]))\n  {\n    j += 4;\n  }\n  else\n  {\n    is_valid = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/8"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/81"}
{"code": "for (long int itr = 0; itr < number; itr++)\n{\n  if (algo == 1)\n  {\n    if (Algorithm_1_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n  else\n    if (algo == 2)\n  {\n    if (Algorithm_2_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n  else\n    if (algo == 3)\n  {\n    if (Algorithm_3_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(thread) schedule(guided, limit) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/6"}
{"code": "for (iIteration = 0; iIteration < MAX_NUM_ITERATIONS_4_CONV; iIteration++)\n{\n  fxErr = 0.0;\n  for (i = 0; i < n; i++)\n  {\n    double fSum;\n    double fDiff;\n    fSum = b[i];\n    for (j = 0; j < n; j++)\n      fSum -= A[i][j] * xk[j];\n\n    fSum += A[i][i] * xk[i];\n    xkp1[i] = fSum / A[i][i];\n    fDiff = xkp1[i] - xk[i];\n    fxErr += fDiff * fDiff;\n  }\n\n  if (fxErr < ATOL)\n    break;\n  else\n  {\n    for (i = 0; i < n; i++)\n      xk[i] = xkp1[i];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/1"}
{"code": "for (i = 0; i < file.height; i++)\n  for (j = 0; j < file.width; j++)\n{\n  if (file.maxval > 255)\n  {\n    output_file.write((char *) (&new_map[i][j]), 2);\n  }\n  else\n  {\n    uint8_t temp = new_map[i][j];\n    output_file << temp;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FedosCucumber/OpenMPSchedulingTest/main/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += a[i];\n  printf(\"Thread %d, itteration %d : sum = %d\\n\", omp_get_thread_num(), i, sum);\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satyatejachikatla/OpenMP-examples/02-Reduction/main/1"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  sum[thread_id] += x[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m7azeem/HPC-OpenMP/part3/1.4/without_critical_serial_sum/0"}
{"code": "for (i = 1; i <= 10000; i++)\n{\n  for (j = 1; j <= 10000; j++)\n  {\n    dt = fmax(fabs(Temperature[i][j] - Temperature_last[i][j]), dt);\n    Temperature_last[i][j] = Temperature[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) reduction(max: dt)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bakitybacon/parallelprogramming/Exercises/OpenMP/laplace_10k/1"}
{"code": "for (j = 0; j < nx; j++)\n{\n  bxy[(4 * j) + kk] = bxy[4 * j];\n  bxy[(1 + (4 * j)) + kk] = bxy[1 + (4 * j)];\n  bxy[(2 + (4 * j)) + kk] = bxy[2 + (4 * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/29"}
{"code": "for (j = 0; j < len; j++)\n{\n  c[i][j] = a[i][j] * b[i][j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB098-simd2-orig-no/3"}
{"code": "for (i = 0; i < 16384; ++i)\n{\n  for (j = 0; j < 16384; ++j)\n  {\n    A[(i * 16384) + j] = ((float) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/2DCONV/2DConvolution/1"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  ;\n}\n\n", "pragma": "#pragma omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/teams_distribute_parallel_for_messages/0"}
{"code": "for (i = 0; i < 37; ++i)\n  bar(i);\n\n", "pragma": "omp parallel for schedule (nonmonotonic : dynamic, 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-24/0"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  long result = 0;\n  for (int j = 0; j < i; j++)\n  {\n    result += signature_number[j];\n  }\n\n  start_point[i] = result;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JiyanBlack/MPI-HPC-Project2/Project2/2"}
{"code": "for (int i = (M / 4) * 4; i < M; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double C_ij = C[i + (j * lda)];\n    for (int k = 0; k < K; k++)\n    {\n      C_ij += A[((((i / 8) * 8) * lda) + (k * 8)) + (i % 8)] * B[k + (j * lda)];\n    }\n\n    C[i + (j * lda)] = C_ij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-bad/5"}
{"code": "for (int i = 0; i < numSteps; i++)\n  Weights[i].resize(IDs[i].size(), 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FRSingleOMP/5"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  err = 0;\n  err |= clSetKernelArg(compute_kernel, 0, sizeof(cl_mem), &cur_buffer);\n  err |= clSetKernelArg(compute_kernel, 1, sizeof(cl_mem), &next_buffer);\n  err |= clSetKernelArg(compute_kernel, 2, sizeof(cl_mem), &diff);\n  err |= clSetKernelArg(compute_kernel, 3, sizeof(cl_mem), &instable);\n  err |= clSetKernelArg(compute_kernel, 4, sizeof(cl_mem), &stable);\n  check(err, \"Failed to set kernel arguments\");\n  err = clEnqueueNDRangeKernel(queue, compute_kernel, 2, 0, global, local, 0, 0, 0);\n  check(err, \"Failed to execute kernel\");\n  if ((index_it % 10) == 0)\n  {\n    err = clEnqueueReadBuffer(queue, diff, CL_TRUE, 0, sizeof(unsigned), ret, 0, 0, 0);\n    check(err, \"Failed to read the mask\");\n  }\n\n  {\n    if ((index_it % 10) == 0)\n      if (ret[0] == 0)\n    {\n      return it;\n    }\n\n\n    cl_mem tmp = cur_buffer;\n    cur_buffer = next_buffer;\n    next_buffer = tmp;\n    cl_mem tmp2 = instable;\n    instable = stable;\n    stable = tmp2;\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/39"}
{"code": "for (ii = 0; ii < params.maxIters; ii++)\n{\n  timestep(params, cells, tmp_cells, obstacles);\n  av_vels[ii] = av_velocity(params, cells, obstacles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sd12832/High-Performance-Computing-Files/d2q9-bgk-OpenMP/5"}
{"code": "for (int i = 0; i < points.num; i++)\n{\n  points.p[i].weight = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/34"}
{"code": "for (i = 1; i <= nodesCount; i += block_size)\n{\n  if (i == k)\n  {\n    continue;\n  }\n\n  for (j = 1; j <= nodesCount; j += block_size)\n  {\n    if (j == k)\n    {\n      continue;\n    }\n\n    if ((((i + block_size) - 1) > nodesCount) && (((j + block_size) - 1) <= nodesCount))\n    {\n      fw(i, nodesCount, j, (j + block_size) - 1, k, end);\n    }\n    else\n      if ((((i + block_size) - 1) > nodesCount) && (((j + block_size) - 1) > nodesCount))\n    {\n      fw(i, nodesCount, j, nodesCount, k, end);\n    }\n    else\n      if ((((i + block_size) - 1) <= nodesCount) && (((j + block_size) - 1) > nodesCount))\n    {\n      fw(i, (i + block_size) - 1, j, nodesCount, k, end);\n    }\n    else\n    {\n      fw(i, (i + block_size) - 1, j, (j + block_size) - 1, k, end);\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(k, end) private(i, j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongfeiyang/Parallel-Flyord-Warshall-OpenMP-/proj1/3"}
{"code": "for (uint64_t i = size; i > (size - k); i--)\n{\n  r[size - i] /= i * r0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/15"}
{"code": "for (i = 0; i < ns_inst; i++)\n{\n  fscanf(fin, \"%d %f\", &ival, &val);\n  segs[i] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/16"}
{"code": "for (id = 0; id < nworkers; id++)\n{\n  setup_worker(X, a, p, maxorder, L, nbits, id, algorithm);\n}\n\n", "pragma": "omp parallel for private(id)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bumbleblo/ppd-openmp/vow_with_hash/0"}
{"code": "for (int i = 0; i < getVertexNumber(gr); i++)\n{\n  M[i] = 0;\n  C[i] = -1;\n  U[i] = -1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/2"}
{"code": "for (int j = 0; j < 2000; j++)\n{\n  double sum = 0;\n  for (int k = 0; k < 2000; k++)\n  {\n    sum += A[i][k] * B[k][j];\n  }\n\n  C[i][j] = sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KunxiSun/matrix_multiplication_and_openmp_in_c_2/src/q1/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    printf(\"%d \", dataSet.A[(i * N) + j]);\n  }\n\n  putchar('\\n');\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-HW/4/code/q1/6"}
{"code": "for (int neuron = 0; neuron < L2_NEURONS; neuron++)\n{\n  for (int input = 0; input < L2_DIM; input++)\n  {\n    printf(\"%.3f \", WL2[neuron][input]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/11"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    a[i][j] += 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB095-doall2-taskloop-orig-yes/0"}
{"code": "for (int i = 0; i < n; i++)\n  e(i) = S(i, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/JacobiAsync/3"}
{"code": "for (i = 1; i < (lines + 1); i++)\n{\n  for (j = 1; j < (columns + 1); j++)\n  {\n    fprintf(out, \"%c \", matrix[i][j]);\n  }\n\n  if (i != lines)\n    fprintf(out, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexmustata19/C-OpenMP-Game-of-life/g_omp/9"}
{"code": "for (i1 = 0; i1 < n1; i1++)\n{\n  z[i3][i2][i1] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(n3 ,i1 ,i2 ,z ,n1 ,n2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/20"}
{"code": "for (i = 0; i < omp_threads; i++)\n{\n  qsort(base + index[i], index[i + 1] - index[i], size, comp);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mantri/parallel_algorithms/sample_sort/1"}
{"code": "for (int j = 0; j < ImageWidthSize; j++)\n{\n  for (int k = 0; k < ImageHeightSize; k++)\n  {\n    ImagePixelsData[j][k] = rand() % 256;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/invernoe/openMP-Assignments/lab6_openMP/0"}
{"code": "for (int j = 0; j < n; j++)\n{\n  if ((j % 2) == 0)\n  {\n    rowsort(j, a, n);\n  }\n  else\n  {\n    rowrevsort(j, a, n);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcordero26/parallel-computing/hw3/shear/3"}
{"code": "for (int i = 0; i < len; i++)\n{\n  b[i] = 0;\n  for (int j = 0; j < len; j++)\n  {\n    b[i] += (j + 1) * dataA[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hitaciry/study-cpp-gauss-parallel/mpi_sample/main/0"}
{"code": "for (int a = 0; a < nang; a++)\n{\n  for (int g = 0; g < ng; g++)\n  {\n    for (int k = 0; k < nz; k++)\n    {\n      for (int j = 0; j < ny; j++)\n      {\n        for (int i = 0; i < nx; i++)\n        {\n          for (int o = 0; o < noct; o++)\n          {\n            output_flux[((((a + (nang * i)) + ((nang * nx) * j)) + (((nang * nx) * ny) * k)) + ((((nang * nx) * ny) * nz) * o)) + (((((nang * nx) * ny) * nz) * noct) * g)] = tmp[((((a + (nang * g)) + ((nang * ng) * i)) + (((nang * ng) * nx) * j)) + ((((nang * ng) * nx) * ny) * k)) + (((((nang * nx) * ny) * nz) * ng) * o)];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_core/3"}
{"code": "for (int i = 0; i < (threads - 1); ++i)\n{\n  pthread_join(thr[i], NULL);\n  global += pdat[i].global;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < Ones; j++)\n  {\n    index_X = round(arrayX[i]) + objxy[(j * 2) + 1];\n    index_Y = round(arrayY[i]) + objxy[j * 2];\n    index[(i * Ones) + j] = fabs((((index_X * Y) * Z) + (index_Y * Z)) + iter);\n    if (index[(i * Ones) + j] >= max_size)\n      index[(i * Ones) + j] = 0;\n\n  }\n\n  probability[i] = 0;\n  for (j = 0; j < Ones; j++)\n  {\n    probability[i] += (pow(array[index[(i * Ones) + j]] - 100, 2) - pow(array[index[(i * Ones) + j]] - 228, 2)) / 50.0;\n  }\n\n  probability[i] = probability[i] / ((double) Ones);\n}\n\n", "pragma": "omp parallel for private (i, j, index_X, index_Y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jason11ac/OpenMP-Optimization/func/2"}
{"code": "for (i = 0; i < _PB_N; i++)\n  y[i] = 0;\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/kernels/atax/atax/0"}
{"code": "for (int j = 0; j < N; j += SMALL_N)\n{\n  int sub_N = (SMALL_N < (N - j)) ? (SMALL_N) : (N - j);\n  compute(A + ((i * lda) + (k * 4)), B + ((j * lda) + k), C + ((j * lda) + i), sub_M, sub_N, sub_K, lda);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-so-good4/4"}
{"code": "for (i = 0; i < seqLength; i++)\n  SeqMatrix[n][i] = seq[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alperencubuk/Sequence-Alignment-with-NW-Algorithm/SequenceAlignment/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n    a[i][j] = i;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB093-doall2-collapse-orig-no/0"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  uint32_t j;\n  for (j = 0; j < totalPartitions; ++j)\n  {\n    uint32_t k;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      uint32_t src = partition->edgeList->edges_array_src[k];\n      uint32_t dest = partition->edgeList->edges_array_dest[k];\n      if (stats->components[src] != sampleComp)\n      {\n        if (neighbor[src] >= stats->neighbor_rounds)\n        {\n          linkNodes(src, dest, stats->components);\n        }\n        else\n        {\n          neighbor[src]++;\n        }\n\n      }\n\n      if (stats->components[dest] != sampleComp)\n      {\n        linkNodes(dest, src, stats->components);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/30"}
{"code": "for (int ii = 0; ii < (N + 2); ii++)\n{\n  printf(\"\\nPrint slice %d in direction 0.\\n\", ii);\n  print_slice(array3d, N, 0, ii);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/17"}
{"code": "for (int l = 0; l < p; l++)\n{\n  int pos = (l == 0) ? (data_chunk * l) : ((data_chunk * l) + mod_part);\n  int size = (l == 0) ? (data_chunk + mod_part) : (data_chunk);\n  disps[l] = pos;\n  recvcounts[l] = size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/ass3_6/2"}
{"code": "for (int n = 0; n < max_steps; n++)\n{\n  ((cout << \"it: \") << n) << endl;\n  ts = omp_get_wtime();\n  do_iteration();\n  te = omp_get_wtime();\n  t += te - ts;\n  grid_to_file(n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/acse-hz6818/OpenMP_ConwaysGame/ConwaysGame_OpenMP/5"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm512_set1_epi32(noff);\n  v_moff = _mm512_set1_epi32(moff);\n  v_loff = _mm512_set1_epi32(loff);\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  v_edgelx = _mm512_set1_ps(edgelx);\n  v_edgely = _mm512_set1_ps(edgely);\n  v_edgelz = _mm512_set1_ps(edgelz);\n  v_edgerx = _mm512_set1_ps(edgerx);\n  v_edgery = _mm512_set1_ps(edgery);\n  v_edgerz = _mm512_set1_ps(edgerz);\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  nps = 4 * (nn / 4);\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nps; i += 4)\n      {\n        m = 4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)));\n        v_at = _mm512_loadunpacklo_ps(v_at, &fxyz[m]);\n        v_at = _mm512_loadunpackhi_ps(v_at, &fxyz[m + 16]);\n        m = 4 * ((i + (mxv * j)) + (mxyv * k));\n        _mm512_packstorelo_ps(&sfxyz[m], v_at);\n        _mm512_packstorehi_ps(&sfxyz[m + 16], v_at);\n      }\n\n      for (i = nps; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[3 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[3 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  memset((void *) (&ncl[26 * l]), 0, 26 * (sizeof(int)));\n  nps = 16 * (npp / 16);\n  sum1 = 0.0;\n  v_sum1 = _mm512_set1_pd(0.0);\n  for (j = 0; j < nps; j += 16)\n  {\n    v_x = _mm512_load_ps(&ppart[j + npoff]);\n    v_y = _mm512_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_z = _mm512_load_ps(&ppart[(j + (2 * nppmx)) + npoff]);\n    v_nn = _mm512_cvtfxpnt_round_adjustps_epi32(v_x, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_mm = _mm512_cvtfxpnt_round_adjustps_epi32(v_y, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_ll = _mm512_cvtfxpnt_round_adjustps_epi32(v_z, _MM_ROUND_MODE_DOWN, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_nn, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dxp = _mm512_sub_ps(v_x, v_dxp);\n    v_dyp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_mm, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dyp = _mm512_sub_ps(v_y, v_dyp);\n    v_dzp = _mm512_cvtfxpnt_round_adjustepi32_ps(v_ll, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_dzp = _mm512_sub_ps(v_z, v_dzp);\n    v_nn = _mm512_sub_epi32(v_nn, v_noff);\n    v_mm = _mm512_sub_epi32(v_mm, v_moff);\n    v_ll = _mm512_sub_epi32(v_ll, v_loff);\n    v_it = _mm512_mullo_epi32(v_mxyv4, v_ll);\n    v_it = _mm512_add_epi32(v_it, _mm512_mullo_epi32(v_mxv4, v_mm));\n    v_nn = _mm512_add_epi32(_mm512_slli_epi32(v_nn, 2), v_it);\n    v_amx = _mm512_sub_ps(v_one, v_dxp);\n    v_amy = _mm512_sub_ps(v_one, v_dyp);\n    v_amz = _mm512_sub_ps(v_one, v_dzp);\n    v_dx1 = _mm512_mul_ps(v_dxp, v_dyp);\n    v_dyp = _mm512_mul_ps(v_amx, v_dyp);\n    v_amx = _mm512_mul_ps(v_amx, v_amy);\n    v_amy = _mm512_mul_ps(v_dxp, v_amy);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_mul_ps(v_amx, a);\n    v_dx = _mm512_fmadd_ps(v_amy, p, v_dx);\n    v_dy = _mm512_mul_ps(v_amx, b);\n    v_dy = _mm512_fmadd_ps(v_amy, q, v_dy);\n    v_dz = _mm512_mul_ps(v_amx, c);\n    v_dz = _mm512_fmadd_ps(v_amy, r, v_dz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_dx = _mm512_fmadd_ps(v_dyp, a, v_dx);\n    v_dx = _mm512_fmadd_ps(v_dx1, p, v_dx);\n    v_dx = _mm512_mul_ps(v_amz, v_dx);\n    v_dy = _mm512_fmadd_ps(v_dyp, b, v_dy);\n    v_dy = _mm512_fmadd_ps(v_dx1, q, v_dy);\n    v_dy = _mm512_mul_ps(v_amz, v_dy);\n    v_dz = _mm512_fmadd_ps(v_dyp, c, v_dz);\n    v_dz = _mm512_fmadd_ps(v_dx1, r, v_dz);\n    v_dz = _mm512_mul_ps(v_amz, v_dz);\n    v_nn = _mm512_add_epi32(v_nn, v_mxyv4);\n    _mm512_store_epi32(kk, v_nn);\n    mm = kk[0];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14];\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15];\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_mul_ps(v_amx, a);\n    v_vx = _mm512_fmadd_ps(v_amy, p, v_vx);\n    v_vy = _mm512_mul_ps(v_amx, b);\n    v_vy = _mm512_fmadd_ps(v_amy, q, v_vy);\n    v_vz = _mm512_mul_ps(v_amx, c);\n    v_vz = _mm512_fmadd_ps(v_amy, r, v_vz);\n    mm = kk[0] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[1] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[2] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[3] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    p = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[4] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[5] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[6] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[7] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    b = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[8] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[9] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[10] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[11] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    c = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    r = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    mm = kk[12] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(255), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[13] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(255), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(255), &sfxyz[mm + 16]);\n    mm = kk[14] + (4 * mxv);\n    e = _mm512_mask_loadunpacklo_ps(e, _mm512_int2mask(65280), &sfxyz[mm]);\n    e = _mm512_mask_loadunpackhi_ps(e, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    mm = kk[15] + (4 * mxv);\n    f = _mm512_mask_loadunpacklo_ps(f, _mm512_int2mask(65280), &sfxyz[mm]);\n    f = _mm512_mask_loadunpackhi_ps(f, _mm512_int2mask(65280), &sfxyz[mm + 16]);\n    d = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), f, 177);\n    s = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(3855), e, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(61680), b, 177);\n    f = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(3855), a, 177);\n    g = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(61680), d, 177);\n    b = _mm512_mask_permute4f128_ps(d, _mm512_int2mask(3855), c, 177);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    c = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    b = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), b, 78);\n    p = (int) _mm512_permutevar_epi32(v_perm, (int) p);\n    q = (int) _mm512_permutevar_epi32(v_perm, (int) q);\n    r = (int) _mm512_permutevar_epi32(v_perm, (int) r);\n    s = (int) _mm512_permutevar_epi32(v_perm, (int) s);\n    e = _mm512_mask_permute4f128_ps(p, _mm512_int2mask(61680), q, 177);\n    f = _mm512_mask_permute4f128_ps(q, _mm512_int2mask(3855), p, 177);\n    g = _mm512_mask_permute4f128_ps(r, _mm512_int2mask(61680), s, 177);\n    q = _mm512_mask_permute4f128_ps(s, _mm512_int2mask(3855), r, 177);\n    p = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(65280), g, 78);\n    r = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(255), e, 78);\n    q = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(65280), q, 78);\n    v_vx = _mm512_fmadd_ps(v_dyp, a, v_vx);\n    v_vx = _mm512_fmadd_ps(v_dx1, p, v_vx);\n    v_dx = _mm512_fmadd_ps(v_dzp, v_vx, v_dx);\n    v_vy = _mm512_fmadd_ps(v_dyp, b, v_vy);\n    v_vy = _mm512_fmadd_ps(v_dx1, q, v_vy);\n    v_dy = _mm512_fmadd_ps(v_dzp, v_vy, v_dy);\n    v_vz = _mm512_fmadd_ps(v_dyp, c, v_vz);\n    v_vz = _mm512_fmadd_ps(v_dx1, r, v_vz);\n    v_dz = _mm512_fmadd_ps(v_dzp, v_vz, v_dz);\n    v_dxp = _mm512_load_ps(&ppart[(j + (3 * nppmx)) + npoff]);\n    v_dyp = _mm512_load_ps(&ppart[(j + (4 * nppmx)) + npoff]);\n    v_dzp = _mm512_load_ps(&ppart[(j + (5 * nppmx)) + npoff]);\n    v_vx = _mm512_fmadd_ps(v_qtm, v_dx, v_dxp);\n    v_vy = _mm512_fmadd_ps(v_qtm, v_dy, v_dyp);\n    v_vz = _mm512_fmadd_ps(v_qtm, v_dz, v_dzp);\n    v_dxp = _mm512_add_ps(v_dxp, v_vx);\n    v_dyp = _mm512_add_ps(v_dyp, v_vy);\n    v_dzp = _mm512_add_ps(v_dzp, v_vz);\n    v_at = _mm512_mul_ps(v_dxp, v_dxp);\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dyp, v_dyp));\n    v_at = _mm512_add_ps(v_at, _mm512_mul_ps(v_dzp, v_dzp));\n    v_sum1 = _mm512_add_pd(v_sum1, _mm512_cvtpslo_pd(v_at));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_at, 78));\n    v_sum1 = _mm512_add_pd(v_sum1, v_d);\n    v_dx = _mm512_fmadd_ps(v_vx, v_dt, v_x);\n    v_dy = _mm512_fmadd_ps(v_vy, v_dt, v_y);\n    v_dz = _mm512_fmadd_ps(v_vz, v_dt, v_z);\n    v_mm = _mm512_setzero_epi32();\n    msk1 = _mm512_cmp_ps_mask(v_dx, v_edgerx, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dx, v_edgelx, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dx;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_1, v_1);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dx, v_anx, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dx, v_anx);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_1);\n        msk2 = _mm512_cmp_ps_mask(v_dx, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dx, v_anx);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anx, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dx = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dy, v_edgery, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dy, v_edgely, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dy;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_3, v_3);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dy, v_any, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dy, v_any);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_3);\n        msk2 = _mm512_cmp_ps_mask(v_dy, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dy, v_any);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_any, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dy = v_x;\n\n      }\n\n    }\n\n    msk1 = _mm512_cmp_ps_mask(v_dz, v_edgerz, _MM_CMPINT_GE);\n    msk2 = _mm512_cmp_ps_mask(v_dz, v_edgelz, _MM_CMPINT_LT);\n    ii = _mm512_mask2int(_mm512_kor(msk1, msk2));\n    if (ii != 0)\n    {\n      ii = _mm512_mask2int(msk1);\n      v_x = v_dz;\n      if (ii != 0)\n      {\n        v_it = _mm512_add_epi32(v_9, v_9);\n        v_mm = _mm512_mask_add_epi32(v_mm, msk1, v_mm, v_it);\n        msk1 = _mm512_cmp_ps_mask(v_dz, v_anz, _MM_CMPINT_GE);\n        v_x = _mm512_mask_sub_ps(v_x, msk1, v_dz, v_anz);\n        ii = _mm512_mask2int(msk1);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n      ii = _mm512_mask2int(msk2);\n      if (ii != 0)\n      {\n        v_it = _mm512_mask_mov_epi32(v_0, msk2, v_9);\n        msk2 = _mm512_cmp_ps_mask(v_dz, v_zero, _MM_CMPINT_LT);\n        v_x = _mm512_mask_add_ps(v_x, msk2, v_dz, v_anz);\n        msk1 = _mm512_cmp_ps_mask(v_x, v_anz, _MM_CMPINT_GE);\n        msk1 = _mm512_kand(msk1, msk2);\n        v_x = _mm512_mask_mov_ps(v_x, msk1, v_zero);\n        v_it = _mm512_mask_mov_epi32(v_it, msk1, v_0);\n        v_mm = _mm512_add_epi32(v_mm, v_it);\n        ii = _mm512_mask2int(msk2);\n        if (ii != 0)\n          v_dz = v_x;\n\n      }\n\n    }\n\n    _mm512_store_ps(&ppart[j + npoff], v_dx);\n    _mm512_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm512_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_dz);\n    _mm512_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vx);\n    _mm512_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vy);\n    _mm512_store_ps(&ppart[(j + (5 * nppmx)) + npoff], v_vz);\n    _mm512_store_epi32(kk, v_mm);\n    for (i = 0; i < 16; i++)\n    {\n      mm = kk[i];\n      if (mm > 0)\n      {\n        ncl[(mm + (26 * l)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * l))] = (j + i) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nn = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    dx = amz * ((dx + (dyp * sfxyz[nn + (4 * mxv)])) + (dx1 * sfxyz[(nn + (4 * mxv)) + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[(nn + (4 * mxv)) + 1])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[(nn + (4 * mxv)) + 2])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 2) + 4]));\n    mm = nn + (4 * mxyv);\n    vx = (amx * sfxyz[mm]) + (amy * sfxyz[mm + 4]);\n    vy = (amx * sfxyz[mm + 1]) + (amy * sfxyz[(mm + 1) + 4]);\n    vz = (amx * sfxyz[mm + 2]) + (amy * sfxyz[(mm + 2) + 4]);\n    dx = dx + (dzp * ((vx + (dyp * sfxyz[mm + (4 * mxv)])) + (dx1 * sfxyz[(mm + (4 * mxv)) + 4])));\n    dy = dy + (dzp * ((vy + (dyp * sfxyz[(mm + (4 * mxv)) + 1])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 1) + 4])));\n    dz = dz + (dzp * ((vz + (dyp * sfxyz[(mm + (4 * mxv)) + 2])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 2) + 4])));\n    dxp = ppart[(j + (3 * nppmx)) + npoff];\n    dyp = ppart[(j + (4 * nppmx)) + npoff];\n    dzp = ppart[(j + (5 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    vz = dzp + (qtm * dz);\n    dxp += vx;\n    dyp += vy;\n    dzp += vz;\n    sum1 += ((dxp * dxp) + (dyp * dyp)) + (dzp * dzp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    dz = z + (vz * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  _mm512_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,ii,noff,moff,loff,npp,npoff,nps,nn,mm,ll,ih,nh,x,y,z, dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,vx,vy,vz,edgelx,edgely,edgelz, edgerx,edgery,edgerz,sum1,v_noff,v_moff,v_loff,v_nn,v_mm,v_ll,v_it,v_x, v_y,v_z,v_dxp,v_dyp,v_dzp,v_amx,v_amy,v_amz,v_dx1,v_dx,v_dy,v_dz,v_vx, v_vy,v_vz,v_at,v_edgelx,v_edgely,v_edgelz,v_edgerx,v_edgery,v_edgerz, v_d,v_sum1,a,b,c,d,e,f,g,p,q,r,s,msk1,msk2,kk,dd,sfxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic3/kncmpush3/1"}
{"code": "for (i = 0; i < NK; i++)\n{\n  for (j = 0; j < NJ; j++)\n  {\n    B[(i * NK) + j] = (((DATA_TYPE) i) * (j + 1)) / NJ;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm_omp_out/1"}
{"code": "for (int jj = 1; jj < (params.lx + 1); ++jj)\n{\n  int x_e = jj + 1;\n  int x_w = jj - 1;\n  if ((((!obstacles[(row2 * params.lx) + (jj - 1)]) && ((cells[((row2 + 1) * params.nx) + x_w].speeds[1] - w1a) > 0.0f)) && ((cells[((row1 + 1) * params.nx) + x_w].speeds[8] - w2a) > 0.0f)) && ((cells[((row3 + 1) * params.nx) + x_w].speeds[5] - w2a) > 0.0f))\n  {\n    cells[((row2 + 1) * params.nx) + x_e].speeds[3] += w1a;\n    cells[((row1 + 1) * params.nx) + x_e].speeds[7] += w2a;\n    cells[((row3 + 1) * params.nx) + x_e].speeds[6] += w2a;\n    cells[((row2 + 1) * params.nx) + x_w].speeds[1] -= w1a;\n    cells[((row1 + 1) * params.nx) + x_w].speeds[8] -= w2a;\n    cells[((row3 + 1) * params.nx) + x_w].speeds[5] -= w2a;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/11"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  xi = ((double) iglob) / (nx0 - 1);\n  for (j = 0; j < ny; j++)\n  {\n    jglob = j;\n    eta = ((double) jglob) / (ny0 - 1);\n    for (k = 0; k < nz; k++)\n    {\n      zeta = ((double) k) / (nz - 1);\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/5"}
{"code": "for (int i = 0; i < d; i++)\n{\n  if (i == v)\n  {\n    if (v == 0)\n    {\n      b[i] = mod(a[i] + sign, Nt);\n    }\n    else\n    {\n      b[i] = mod(a[i] + sign, Ns);\n    }\n\n  }\n  else\n  {\n    b[i] = a[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/0"}
{"code": "for (splatt_blas_int i = 0; i < N; ++i)\n{\n  neqs[i + (i * N)] = 1. + reg;\n  for (splatt_blas_int j = 0; j < N; ++j)\n  {\n    neqs[j + (i * N)] = 1.;\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  v3[i] = v1[i] + v2[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(static,4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/void-mckenzie/OpenMP-Work/Programs/vector_addition/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d executes loop iteration %d\\n\", omp_get_thread_num(), i);\n  b[i] = 2 * a[i];\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.12-two-for-loops/1"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    cu[i + 1][j] = (.5 * (p[i + 1][j] + p[i][j])) * u[i + 1][j];\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/2"}
{"code": "for (int i = 0; i < (N + 1); i++)\n  for (int j = 1; j < _M; j++)\n  for (int k = 1; k < K; k++)\n  sum += ((wetness(i, b_U[idx(i, j, k)], 1) * sdL[i]) * dLx[j]) * dLy[k];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/66"}
{"code": "for (int i = 1; i <= m_nReaches; i++)\n{\n  m_qsInput[i] = ((m_qsInput[i] * (m_tsCounter - 1)) + m_qsTemp[i]) / m_tsCounter;\n  m_qiInput[i] = ((m_qiInput[i] * (m_tsCounter - 1)) + m_qiTemp[i]) / m_tsCounter;\n  m_qsInput[0] += m_qsInput[i];\n  m_qiInput[0] += m_qiInput[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/HS_WB/HS_WB/1"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  sum += A[i] * B[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nghialuffy/OpenMP-Exercises/Bai6/Bai6/0"}
{"code": "for (int i = 0; i < 4000; ++i)\n{\n  buffer[i] = i * rank;\n}\n\n", "pragma": "omp parallel for firstprivate(buffer) schedule(static,1000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tudasc/CommPart/demo-codes/full_buffer/0"}
{"code": "for (i = 0; i < 1000000; i = i + 1)\n{\n  Buyers[i].buyerOrSeller = 1;\n  Buyers[i].quantityHeld = 0;\n  Buyers[i].value = (rand() % 20) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp/1"}
{"code": "for (const_iterator i = summs.begin(); i != summs.end(); ++i)\n{\n  (sum_out << (*i)) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_2/parallel_2/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = rand() % randMax;\n  char flag = 'f';\n  if ((a[i] % 7) == 0)\n  {\n    flag = 't';\n  }\n\n  printf(\"%d:%c \", a[i], flag);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/20"}
{"code": "for (int i = 0; i < h; ++i)\n{\n  memset(&data.canva[((data.width * data.bpp) * (i + y)) + (x * data.bpp)], 0, (sizeof(unsigned char)) * w);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/DataProviders/Images/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  memcpy(str_buffer, genes[i].c_str(), genes_length[i]);\n  MPI_Bcast(str_buffer, genes_length[i], MPI_CHAR, root, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing12/test/0"}
{"code": "for (int p = 0; p < nproc; p++)\n{\n  values_count[p] = A->ptr[(p * n_local) + ptr_count[p]] - A->ptr[p * n_local];\n  values_displs[p] = A->ptr[p * n_local];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/12"}
{"code": "for (i = 1; i <= t_last; i++)\n{\n  printf(\"  %-10s:%9.3f  (%6.2f%%)\\n\", t_names[i], trecs[i], (trecs[i] * 100.) / tmax);\n  if (i == t_transfb_c)\n  {\n    t2 = trecs[t_convect] - trecs[t_transfb_c];\n    printf(\"    --> %11s:%9.3f  (%6.2f%%)\\n\", \"sub-convect\", t2, (t2 * 100.) / tmax);\n  }\n  else\n    if (i == t_transfb)\n  {\n    t2 = (trecs[t_diffusion] - trecs[t_transf]) - trecs[t_transfb];\n    printf(\"    --> %11s:%9.3f  (%6.2f%%)\\n\", \"sub-diffuse\", t2, (t2 * 100.) / tmax);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/ua/4"}
{"code": "for (int i = 0; i < n; ++i)\n  arr[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP For/merge_final_working/3"}
{"code": "for (n = 0; n <= 4; n += 1)\n{\n  lhs[i][j][k][0][m][n] = 0.0;\n  lhs[i][j][k][1][m][n] = 0.0;\n  lhs[i][j][k][2][m][n] = 0.0;\n}\n\n", "pragma": "omp parallel for private (n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/47"}
{"code": "for (int i = 0; i <= (N / 2); i++)\n{\n  abort = 0;\n  if (isPrime(i))\n  {\n    for (int j = N - 1; j >= (N / 2); j--)\n    {\n      if (isPrime(j) && ((i + j) == N))\n      {\n        abort = 1;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for schedule(dynamic, 25) num_threads(numthd[proc]) private(before, after, time_diff)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/OpenMP/Goldbach_conjecture/goldbach_omp_d/1"}
{"code": "for (i = 0; i < N; ++i)\n  Y[i] += a * X[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/interop/examples/axpy_omp/1"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  assert(sum[i] == 6);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/mapping/private_mapping/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = x;\n  x = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/outputdep-orig-yes/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp1 = a[(k * n) + i];\n  a[(k * n) + i] = a[(kd * n) + i];\n  a[(kd * n) + i] = temp1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NisargGB/Multi-threaded-LU-Decomposition/pthread_sections/0"}
{"code": "for (int x = 0; x < (image->width - 1); x++)\n{\n  sort_column(image, x);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, 4) num_threads(glitch::threads) if(glitch::parallel_enabled)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MenesesGHZ/glitch/lib/glitch/6"}
{"code": "for (int k = 1; k < count; ++k)\n{\n  s_h(k) = s_h(nlcl * k);\n  for (int i = 1; i < nlcl; ++i)\n    s_h(k) += s_h((nlcl * k) + i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/10"}
{"code": "for (int j = 0; j < height; j++)\n{\n  for (int i = 0; i < width; i++)\n  {\n    double p_r = c_r + (d * (i - (width / 2)));\n    double p_i = c_i + (d * ((height / 2) - j));\n    int iter = mandelbrot(iter_max, p_r, p_i);\n    pixmap_put_pixel(sketch, colormap[iter & iter_mask], i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/03.multisampling/00.cpu/mandelbrot/1"}
{"code": "for (int i = 0; i < kb_cache_pts.size(); i++)\n{\n  if (kb_cache_pts[i] == s2->X)\n    kb_cache_pts[i] = X;\n\n  if (kb_cache_pts[i] == s2->Y)\n    kb_cache_pts[i] = Y;\n\n  if (kb_cache_pts[i] == s2->Z)\n    kb_cache_pts[i] = Z;\n\n  if (kb_cache_pts[i] == ((double *) (&s2->Time)))\n    kb_cache_pts[i] = (double *) (&Time);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/120"}
{"code": "for (i = 0; i < 32; ++i)\n{\n  for (j = 0; j < 32; ++j)\n  {\n    for (k = 0; k < 32; ++k)\n    {\n      A[((i * (32 * 32)) + (j * 32)) + k] = ((i % 12) + (2 * (j % 7))) + (3 * (k % 13));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3DCONV/3DConvolution/15"}
{"code": "for (i = 0; i < n; i++)\n{\n  xxexp = exp(dx * (i - 1));\n  for (j = 0; j < n; j++)\n  {\n    yy = dy * (j - 1);\n    temp = u[i][j] - (xxexp * exp((-2.0) * yy));\n    error += temp * temp;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:error) private(i, j, xxexp, yy, temp)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thiagowfx/coc-472-CAD/T2/ex1/jacobi/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  dx = x[j] - x[i];\n  dy = y[j] - y[i];\n  dz = z[j] - z[i];\n  invr = 1.0 / sqrtf((((dx * dx) + (dy * dy)) + (dz * dz)) + eps);\n  invr3 = (invr * invr) * invr;\n  f = (F_QUOC * m[j]) * invr3;\n  ax += f * dx;\n  ay += f * dy;\n  az += f * dz;\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for num_threads(threads) private(dx,dy,dz,invr,invr3,f) reduction(+:ax,ay,az)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brabemi/ctu-fit-mi-pap-mod/main_sse/0"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  for (int i = 0; i < 1000000; i++)\n  {\n    randomnumber = rand() % 6;\n    dnabig[i] = dna[randomnumber];\n  }\n\n  replacecharacters(dnabig);\n  countA(dnabig);\n  end = clock();\n  total_time = ((double) (end - start)) / CLOCKS_PER_SEC;\n  nDynamic1[j] = total_time;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/2"}
{"code": "for (big i = 0; i < num; ++i)\n{\n  if (!arr[i])\n    printf(\"%lld\\n\", i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulgurnani/parallel-seive/eseive/5"}
{"code": "for (int i = 0; i < Rows; i++)\n{\n  Res.Vec[i] = RowSum(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/120"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n  v[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_collapse_01/0"}
{"code": "for (; (i + 31) < n; i += 32)\n{\n  xv[0] = _mm256_loadu_ps(&x[i + 0]);\n  xv[1] = _mm256_loadu_ps(&x[i + 8]);\n  xv[2] = _mm256_loadu_ps(&x[i + 16]);\n  xv[3] = _mm256_loadu_ps(&x[i + 24]);\n  _mm256_storeu_ps(&y[i + 0], xv[0]);\n  _mm256_storeu_ps(&y[i + 8], xv[1]);\n  _mm256_storeu_ps(&y[i + 16], xv[2]);\n  _mm256_storeu_ps(&y[i + 24], xv[3]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/4"}
{"code": "for (int kk = 0; kk < 20; kk++)\n  ;\n\n", "pragma": "#pragma omp target parallel for is_device_ptr ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_parallel_for_is_device_ptr_messages/1"}
{"code": "for (i = 0; i < (1 << NUM_BUCKETS_LOG_2); i++)\n  for (k = myid + 1; k < num_procs; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/43"}
{"code": "for (i = 0; i < (p7 + 4); i++)\n{\n  if (i < p7)\n    b[i] = -6;\n\n  a[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-13/0"}
{"code": "for (i = 0; i < 800; i++)\n  X[i] = MA[i][800];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-1/4"}
{"code": "for (i = 0; i < x; i++)\n{\n  for (j = 0; j < y; j++)\n  {\n    for (k = 0; k < z; k++)\n    {\n      if (dom[i][j][k] == 0)\n      {\n        mean_pressure += pre[i][j][k];\n        counter_mean_pressure++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/noise_generator/14"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    A[i][j] = rand() % 5;\n    B[i][j] = rand() % 5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/1"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  test_communicateGhostP2G(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/14"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((0.75 - TEMP_MIN) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * SAMPLES), stat[i].e2 / ((((double) (L * L)) * (L * L)) * SAMPLES), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/47"}
{"code": "for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n{\n  X[c15][n - 1] = X[c15][n - 1] / B[c15][n - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/6"}
{"code": "for (i = 0; i < 16; i = i + 2)\n  for (j = i; j < 16; j += 2)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/21"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      uijk = us[k][j][i];\n      up1 = us[k][j][i + 1];\n      um1 = us[k][j][i - 1];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dx1tx1 * ((u[k][j][i + 1][0] - (2.0 * u[k][j][i][0])) + u[k][j][i - 1][0]))) - (tx2 * (u[k][j][i + 1][1] - u[k][j][i - 1][1]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dx2tx1 * ((u[k][j][i + 1][1] - (2.0 * u[k][j][i][1])) + u[k][j][i - 1][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[k][j][i + 1][1] * up1) - (u[k][j][i - 1][1] * um1)) + ((((u[k][j][i + 1][4] - square[k][j][i + 1]) - u[k][j][i - 1][4]) + square[k][j][i - 1]) * c2)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dx3tx1 * ((u[k][j][i + 1][2] - (2.0 * u[k][j][i][2])) + u[k][j][i - 1][2]))) + (xxcon2 * ((vs[k][j][i + 1] - (2.0 * vs[k][j][i])) + vs[k][j][i - 1]))) - (tx2 * ((u[k][j][i + 1][2] * up1) - (u[k][j][i - 1][2] * um1)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dx4tx1 * ((u[k][j][i + 1][3] - (2.0 * u[k][j][i][3])) + u[k][j][i - 1][3]))) + (xxcon2 * ((ws[k][j][i + 1] - (2.0 * ws[k][j][i])) + ws[k][j][i - 1]))) - (tx2 * ((u[k][j][i + 1][3] * up1) - (u[k][j][i - 1][3] * um1)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dx5tx1 * ((u[k][j][i + 1][4] - (2.0 * u[k][j][i][4])) + u[k][j][i - 1][4]))) + (xxcon3 * ((qs[k][j][i + 1] - (2.0 * qs[k][j][i])) + qs[k][j][i - 1]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[k][j][i + 1][4] * rho_i[k][j][i + 1]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k][j][i - 1][4] * rho_i[k][j][i - 1])))) - (tx2 * ((((c1 * u[k][j][i + 1][4]) - (c2 * square[k][j][i + 1])) * up1) - (((c1 * u[k][j][i - 1][4]) - (c2 * square[k][j][i - 1])) * um1)));\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    i = 1;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n    }\n\n    i = 2;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((((-4.0) * u[k][j][i - 1][m]) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 3; i <= (nx2 - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n      }\n\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    i = nx2 - 1;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])));\n    }\n\n    i = nx2;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (5.0 * u[k][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/2"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/57"}
{"code": "for (long long i = 2; (i * i) <= n; ++i)\n  if (a[i])\n  for (long long j = i * i; j <= n; j += i)\n  a[j] = false;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LilyOSullivan/twin_primes_openMP/main/1"}
{"code": "for (size_t i = 0; i < a.m; ++i)\n  for (size_t j = 0; j < b.n; ++j)\n{\n  _c[i][j] = 0;\n  for (size_t k = 0; k < a.n; ++k)\n    _c[i][j] += a[i][k] * b[k][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/mat_mult/4"}
{"code": "for (size_t i = 0; i < zSize; ++i)\n{\n  if (!((((r[i] + 1) < aSize) && (a[r[i]] <= z[i])) && (z[i] < a[r[i] + 1])))\n  {\n    ((cout << msg) << \": incorrect result:\") << endl;\n    ((((cout << \"index = \") << i) << \" r[index] = \") << r[i]) << endl;\n    (((((cout << a[r[i]]) << \" <= \") << z[i]) << \" < \") << a[r[i] + 1]) << endl;\n    break;\n  }\n\n  r[i] = 0xFFFFFFFF;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bsearch-omp/main/3"}
{"code": "for (int i = 0; i < wi_.dim1(); ++i)\n{\n  for (int j = 0; j < wi_.dim2(); ++j)\n  {\n    HistogramWeight(wi_[i][j] * scales_[i], &histogram);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/10"}
{"code": "for (i = 1; i < xDim; i++)\n{\n  memcpy(matrix[i], matrix1[i], (sizeof(double)) * xDim);\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varunsharma0286/LaplaceEquation/Openmp Solution/parallel/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->vertices[v] = v;\n  stats->degrees[v] = graph->vertices->out_degree[v];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/0"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  this->mat_.row[i] = cast_perm->vec_[src.mat_.row[i]];\n  this->mat_.col[i] = cast_perm->vec_[src.mat_.col[i]];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/14"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  cosMolRef[*thisMol][i] = 0.0;\n  sinMolRef[*thisMol][i] = 0.0;\n  for (uint j = 0; j < thisKind.NumAtoms(); j++)\n  {\n    if (particleHasNoCharge[startAtom + j])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(mols.MolStart(*thisMol) + j, kxRef[box][i], kyRef[box][i], kzRef[box][i], molCoords);\n    cosMolRef[*thisMol][i] += thisKind.AtomCharge(j) * cos(dotProduct);\n    sinMolRef[*thisMol][i] += thisKind.AtomCharge(j) * sin(dotProduct);\n  }\n\n  sumRnew[box][i] += lambdaCoef * cosMolRef[*thisMol][i];\n  sumInew[box][i] += lambdaCoef * sinMolRef[*thisMol][i];\n}\n\n", "pragma": "      #pragma omp parallel for default(none) shared(box, lambdaCoef, molCoords, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/2"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dneto12[col] = value[col + 4];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/20"}
{"code": "for (size_t element = world_rank; element < _numberOfSets; element = element + world_size)\n  _setsVector.push_back(Set(dimensionality, iterations, numberOfElements, vec));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariodematties/MPI_Tests/SuperSet/1"}
{"code": "for (i = 0; i < 9; ++i)\n  for (j = 0; j < 9; ++j)\n{\n  cpyPz[i][j] = puzzle[inBlock[blocks[i / 3]][i % 3]][j];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blu-J/sudoku-openmp/sudoku/5"}
{"code": "for (int i = 1; i < (nz - 1); i++)\n  vector[1][1][i] += vector[0][0][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/23"}
{"code": "for (int row = 1; row <= RowN; row++)\n{\n  while ((cnt < MtxV.Len()) && (MtxV[cnt].Val1 == row))\n  {\n    RowSpVV[row - 1].Add(TIntFltKd(MtxV[cnt].Val2 - 1, MtxV[cnt].Val3()));\n    cnt++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/2"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (k = 1; k < (nz - 1); k++)\n    {\n      rtmp_G[0][j][i][k] = rtmp_G[0][j][i][k] + ((dz1 * tz1) * ((utmp_G[0][j][i][k - 1] - (2.0 * utmp_G[0][j][i][k])) + utmp_G[0][j][i][k + 1]));\n      rtmp_G[1][j][i][k] = (rtmp_G[1][j][i][k] + (((tz3 * C3) * C4) * (flux_G[1][j][i][k + 1] - flux_G[1][j][i][k]))) + ((dz2 * tz1) * ((utmp_G[1][j][i][k - 1] - (2.0 * utmp_G[1][j][i][k])) + utmp_G[1][j][i][k + 1]));\n      rtmp_G[2][j][i][k] = (rtmp_G[2][j][i][k] + (((tz3 * C3) * C4) * (flux_G[2][j][i][k + 1] - flux_G[2][j][i][k]))) + ((dz3 * tz1) * ((utmp_G[2][j][i][k - 1] - (2.0 * utmp_G[2][j][i][k])) + utmp_G[2][j][i][k + 1]));\n      rtmp_G[3][j][i][k] = (rtmp_G[3][j][i][k] + (((tz3 * C3) * C4) * (flux_G[3][j][i][k + 1] - flux_G[3][j][i][k]))) + ((dz4 * tz1) * ((utmp_G[3][j][i][k - 1] - (2.0 * utmp_G[3][j][i][k])) + utmp_G[3][j][i][k + 1]));\n      rtmp_G[4][j][i][k] = (rtmp_G[4][j][i][k] + (((tz3 * C3) * C4) * (flux_G[4][j][i][k + 1] - flux_G[4][j][i][k]))) + ((dz5 * tz1) * ((utmp_G[4][j][i][k - 1] - (2.0 * utmp_G[4][j][i][k])) + utmp_G[4][j][i][k + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/rhs/18"}
{"code": "for (size_t i = 0; i < 10; i++)\n{\n  for (size_t j = 0; j < 10; j++)\n  {\n    for (size_t k = 0; k < 10; k++)\n      sum += A[i][k] * B[k][j];\n\n    C[i][j] = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, CHUNK) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/djaliiil/OpenMP/omp_tp1_exo3/0"}
{"code": "for (v = 0; v < V; v++)\n{\n  if ((graph[u][v] && (visited[v] == 0)) && (graph[u][v] < key[v]))\n    from[v] = u, key[v] = graph[u][v];\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parthvshah/parallel-prims/src/bench/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  compute_hash(cur_salt, saved_key[index], (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ike_fmt_plug/0"}
{"code": "for (i = 0; i < ndim; i++)\n{\n  if (unlikely(from_mvs->suboffsets[i] >= 0))\n  {\n    PyErr_Format(PyExc_ValueError, \"Cannot copy memoryview slice with indirect dimensions (axis %d)\", i);\n    goto fail;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/41"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    sum[i][j] = multi[i][j] + c[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task5(a+b)/2"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      xi = ((double) i) * dnxm1;\n      exact_solution(xi, eta, zeta, u_exact);\n      for (m = 0; m < 5; m++)\n      {\n        add = u[k][j][i][m] - u_exact[m];\n        rms[m] = rms[m] + (add * add);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/16"}
{"code": "for (int i = 0; i < size1; i++)\n{\n  if (!dataset1[i].isFrequent)\n  {\n    continue;\n  }\n\n  for (int j = 0; j < size2; j++)\n  {\n    if (!dataset2[j].isFrequent)\n    {\n      continue;\n    }\n\n    if (strcmp(dataset1[i].item, dataset2[j].item) < 0)\n    {\n      strcat(str, dataset1[i].item);\n      strcat(str, \",\");\n      strcat(str, dataset2[j].item);\n    }\n    else\n    {\n      strcat(str, dataset2[j].item);\n      strcat(str, \",\");\n      strcat(str, dataset1[i].item);\n    }\n\n    tmp_data[lpi][tid].num_itens = dataset1[i].num_itens + 1;\n    tmp_data[lpi++][tid].item = str;\n    str = 0;\n    free(str);\n    str = malloc(LINE_MAX * (sizeof(char)));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cart-pucminas/machine-learning/Apriori/AprioriOpenMP/AP/apriori/1"}
{"code": "for (int y = 0; y < height; y++)\n{\n  int row = row_pointers[y];\n  for (int x = 0; x < width; x++)\n  {\n    int px = &row[x * 4];\n    px[0] = 255 - px[0];\n    px[1] = 255 - px[1];\n    px[2] = 255 - px[2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/negationImageParallel/1"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  diameters[i] = diametersThreads[i];\n  for (j = 1; j < numThreads; j++)\n  {\n    if (diameters[i] < diametersThreads[(j * numOfClusters) + i])\n      diameters[i] = diametersThreads[(j * numOfClusters) + i];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/itaytas/Parallel-and-Distributed-Computing-Course/Parallel K-Means/quality/2"}
{"code": "for (i = N1; i < N2; i += step)\n  if (a[i] != b[i])\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp-loop01/5"}
{"code": "for (i = 1; i <= 1000; i++)\n  for (j = 1; j <= 1000; j++)\n{\n  Anew[i][j] = 0.25 * (((A[i + 1][j] + A[i - 1][j]) + A[i][j + 1]) + A[i][j - 1]);\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_jacobi/0"}
{"code": "for (int i = 0; i < siz; i++)\n{\n  for (int j = 0; j < siz; j++)\n  {\n    grid[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/0"}
{"code": "for (unsigned int k = 0; k < 256; ++k)\n{\n  arr[k] = (long *) malloc(N * (sizeof(long)));\n  for (unsigned int curThread = 0; curThread < N; ++curThread)\n  {\n    arr[k][curThread] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative2/1"}
{"code": "for (int p = 0; p < (num_procs - 1); p++)\n{\n  vecDataSize[p] = vSize;\n  vecDataDispls[p] = p * vSize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorukTaneli/sparse-matrix-vector-multiplication/src/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  re += (xx[i].re * yy[i].re) + (xx[i].im * yy[i].im);\n  im += (xx[i].re * yy[i].im) - (xx[i].im * yy[i].re);\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+ : re) reduction(+ : im)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/dotc/0"}
{"code": "for (int k = 0; k < K; k++)\n{\n  rand_point_i = rand() % MAX_POINTS;\n  for (int j = 0; j < DIM; j++)\n  {\n    centroids[k][j] = points[rand_point_i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(rand_point_i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Plutone11011/ParallelKMEANS/kmeans/1"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n    for (int k = 0; k < nzn; k++)\n  {\n    pXZsn[is][i][j][k] += invVOL * moments[i][j][k][6];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/8"}
{"code": "for (int i = 0; i < myRows; i++)\n{\n  for (int j = 0; j < WORLD_SIZE; j++)\n  {\n    if (myWorld[i][j] == ALIVE)\n      computeNeigh(myWorld, newWorld, upper, below, i, j, myRows, windDirection, windForce);\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parrallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattNot/fireEmulation/main/2"}
{"code": "for (; i < count; i++)\n  if (d == crypt_out[(i * 4) + 3])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash2_fmt_plug/4"}
{"code": "for (i = &b[0][0][0]; i < (&b[0][0][10]); i++)\n  for (float *j = &b[0][15][0]; j > (&b[0][0][0]); j -= 10)\n  for (float *k = &b[0][0][10]; k > (&b[0][0][0]); --k)\n  b[i - (&b[0][0][0])][((j - (&b[0][0][0])) / 10) - 1][(k - (&b[0][0][0])) - 1] -= 3.5;\n\n\n\n", "pragma": "omp target parallel for simd schedule(static, 32) collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr81768-1/0"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_out, 0);\n    gettimeofday(&s_bck_hid, 0);\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_hid, 0);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/16"}
{"code": "for (i = 0; i < numVertices; ++i)\n{\n  vertex_cnt[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iMeanHow/OpenMP/Radix/src/sort/0"}
{"code": "for (j = 1; j <= n; j++)\n{\n  rowstr[j] = 0;\n  mark[j] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/CG/cg_single/1"}
{"code": "for (int i = 0; i < mpi_size; i++)\n  if (i != mpi_rank)\n  do_check_and_send(i);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/7"}
{"code": "for (i = 0; i < grr_sq->size1; ++i)\n{\n  for (j = 0; j < grr_sq->size2; ++j)\n  {\n    gsl_matrix_set(grr_sq, i, j, grr_sq_fun(gsl_matrix_get(R_r, i, j), E->data[j]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/boatx/ltbToolkit/src/ltb/4"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  parallel_qsort_sort1(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/qsort/4"}
{"code": "for (int i = 0; i < k; i++)\n{\n  data.insert(data.end(), bkt[0][i].begin(), bkt[0][i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/sampleSort/sort_sample/6"}
{"code": "for (int i = 1; i <= n; i++)\n  czyPierwsza[i] = true;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/3"}
{"code": "for (int j = 0; j < 5; j++)\n{\n  for (int i = 0; i < repeat; i++)\n  {\n    printf(\"Sorting for %d\", NUM_OF_ELEMENT);\n    generate_number(unsorted, NUM_OF_ELEMENT);\n    clock_gettime(CLOCK_MONOTONIC, &start);\n    radix_solve(unsorted, sorted, NUM_OF_ELEMENT, BIT_BLOCK_SIZE);\n    clock_gettime(CLOCK_MONOTONIC, &end);\n    elapsed_time = get_elapsed_time(start, end);\n    total_elapsed_time += elapsed_time;\n    printf(\"\\nTime elapsed (microsec) iter %d : %lg block %d\", i, elapsed_time, BIT_BLOCK_SIZE);\n  }\n\n  printf(\"\\nTime average elapsed (microsec) : %lg block %d\\n\", total_elapsed_time / repeat, BIT_BLOCK_SIZE);\n  printf(\"\\n\\n\\n\");\n  BIT_BLOCK_SIZE *= 2;\n  elapsed_time = 0;\n  total_elapsed_time = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jessinra/IF3230-Radix-Sort-OpenMP/src/radix_sort_for_display/0"}
{"code": "for (i = 0; i < number_of_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mishal23/parallel-programming-openmp/value-of-pi/reduction/0"}
{"code": "for (size_t i = 0; i < compressor.image_height; i++)\n{\n  (void) jpeg_write_scanlines(&compressor, &output_rows_buffer[i], 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/grayscaler-openmp/main/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int flow_dir = reverse_dir_[i];\n  if ((flow_dir == dir_nodata_) || (flow_dir < 0))\n  {\n    continue;\n  }\n\n  flow_in_num_[i] = 0;\n  if (flow_dir & 1)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 2)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 4)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 8)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 16)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 32)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 64)\n  {\n    flow_in_num_[i]++;\n  }\n\n  if (flow_dir & 128)\n  {\n    flow_in_num_[i]++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (int j = 0; j < nthreads; j++)\n  {\n    force[i][0] += local_force[(j * n) + i][0];\n    force[i][1] += local_force[(j * n) + i][1];\n  }\n\n}\n\n", "pragma": "omp for schedule(static, chunksize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/1"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE]\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/6"}
{"code": "for (int i = 0; i < 100; i++)\n  sumr = sumr + arr[i];\n\n", "pragma": "    #pragma omp parallel for reduction(+:sumr)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/farit2000/OpenMP_tests/tasks/6/0"}
{"code": "for (k = 1; k < taille; k++)\n{\n  result -= tab[k];\n}\n\n", "pragma": "omp parallel for reduction(-:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex6/3"}
{"code": "for (i = 0; i < bands; i++)\n{\n  free(a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/1"}
{"code": "for (i = 1; i <= (num_procs - 1); i++)\n{\n  dest = i;\n  tag = num_rows;\n  k = num_rows * n;\n  num_rows = num_rows + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/matVec-mpi/4"}
{"code": "for (int i = 0; i < num_nodes; ++i)\n{\n  nodes_distance[i] = ((int *) ((nodes_distance + num_nodes) + 1)) + (i * num_nodes);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/intesar-gist/floyd_warshall_openmp/floyd_warshall_openmp/3"}
{"code": "for (i = 0; i < total_nvgpu; i++)\n  nvgpu_selection[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/4"}
{"code": "for (int j = 1; j < size; j++)\n  if (a[j] <= min)\n  min = a[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Mini Project - ROOM ASSIGNMENT/mpi_room_assignment/3"}
{"code": "for (i = 0; i < DIM; i++)\n  if (mins_seq[i] > max_of_mins_seq)\n{\n  {\n    max_of_mins_seq = mins_seq[i];\n  }\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/min_max_matrix_element/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  int j;\n  for (j = 0; j < N; j++)\n  {\n    x1[i] = x1[i] + (a[(i * N) + j] * y1[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/MVT/mvt/0"}
{"code": "for (int i = 0; i < n_threads; i++)\n  bubble_sort((void *) (&buckets[i]));\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juan-burtet/ParallelBucketSort/bucketsort/0"}
{"code": "for (j = i; j < 3; j++)\n{\n  ratio = A[j][i] / A[i][i];\n  for (k = i; k < 3; k++)\n  {\n    A[j][k] -= ratio * A[i][k];\n    b[j] -= ratio * b[i];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/openmp/0"}
{"code": "for (int i = 0; i < len_vec; i++)\n{\n  i_bin = bin_finder(&vec[i], len_bin, min, max);\n  omp_set_lock(&hist_lock[i_bin]);\n  histogram[i_bin]++;\n  omp_unset_lock(&hist_lock[i_bin]);\n}\n\n", "pragma": "#pragma omp parallel for private(i_bin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/6"}
{"code": "for (int ipT = 0; ipT < pT_tab_length; ipT++)\n{\n  pTValues[ipT] = pT_tab->get(1, ipT + 1);\n  pTWeights[ipT] = pT_tab->get(2, ipT + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/8"}
{"code": "for (i = 1; i < (NBLAYER - 1); ++i)\n{\n  layerSize[i] = NBHD;\n}\n\n", "pragma": "omp for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/12"}
{"code": "for (int i = 0; i < length; i++)\n{\n  unsigned long t = ((unsigned long) rand()) << 32;\n  data[i] = t | rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/2"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (4 * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 3; jj++)\n    {\n      t2 = conjf(f[(jj + (4 * (nxh - j))) + joff]);\n      t1 = f[(jj + (4 * j)) + joff] + t2;\n      t2 = (f[(jj + (4 * j)) + joff] - t2) * t3;\n      f[(jj + (4 * j)) + joff] = t1 + t2;\n      f[(jj + (4 * (nxh - j))) + joff] = conjf(t1 - t2);\n    }\n\n  }\n\n  for (jj = 0; jj < 3; jj++)\n  {\n    f[(jj + (4 * nxhh)) + joff] = 2.0 * conjf(f[(jj + (4 * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(4 * j1) + joff];\n      t2 = f[(1 + (4 * j1)) + joff];\n      t3 = f[(2 + (4 * j1)) + joff];\n      f[(4 * j1) + joff] = f[(4 * j) + joff];\n      f[(1 + (4 * j1)) + joff] = f[(1 + (4 * j)) + joff];\n      f[(2 + (4 * j1)) + joff] = f[(2 + (4 * j)) + joff];\n      f[(4 * j) + joff] = t1;\n      f[(1 + (4 * j)) + joff] = t2;\n      f[(2 + (4 * j)) + joff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = (4 * ns2) * k;\n      k2 = k1 + (4 * ns);\n      for (j = 0; j < ns; j++)\n      {\n        t1 = conjf(sct[kmr * j]);\n        t2 = t1 * f[((4 * j) + k2) + joff];\n        t3 = t1 * f[((1 + (4 * j)) + k2) + joff];\n        t4 = t1 * f[((2 + (4 * j)) + k2) + joff];\n        f[((4 * j) + k2) + joff] = f[((4 * j) + k1) + joff] - t2;\n        f[((1 + (4 * j)) + k2) + joff] = f[((1 + (4 * j)) + k1) + joff] - t3;\n        f[((2 + (4 * j)) + k2) + joff] = f[((2 + (4 * j)) + k1) + joff] - t4;\n        f[((4 * j) + k1) + joff] += t2;\n        f[((1 + (4 * j)) + k1) + joff] += t3;\n        f[((2 + (4 * j)) + k1) + joff] += t4;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    f[(3 + (4 * j)) + joff] = cimagf(f[(2 + (4 * j)) + joff]) + (cimagf(f[(3 + (4 * j)) + joff]) * _Complex_I);\n    at1 = crealf(f[(2 + (4 * j)) + joff]);\n    f[(2 + (4 * j)) + joff] = cimagf(f[(4 * j) + joff]) + (cimagf(f[(1 + (4 * j)) + joff]) * _Complex_I);\n    at2 = crealf(f[(1 + (4 * j)) + joff]);\n    f[(1 + (4 * j)) + joff] = at1 + (0.0 * _Complex_I);\n    f[(4 * j) + joff] = crealf(f[(4 * j) + joff]) + (at2 * _Complex_I);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,joff,at1,at2,t1,t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/24"}
{"code": "for (i = 0; i < numOfProc; i++)\n{\n  disp[i] = counter;\n  if (i == root)\n  {\n    counts[i] = rootDatabaseSize;\n    counter += rootDatabaseSize;\n  }\n  else\n  {\n    counts[i] = salveDatabaseSize;\n    counter += salveDatabaseSize;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/MPI_Kmeans/5"}
{"code": "for (i = 0; i < numdims; i++)\n{\n  ans += (coord1[i] - coord2[i]) * (coord1[i] - coord2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdigenis/High_Performance_Computing/k-means_northwestern_Optimized/seq_kmeans/1"}
{"code": "for (search = 0; search < num_searchers; search++)\n{\n  int search_flag = 0;\n  int parent = search;\n  int follows_to = searchers[parent].follows;\n  while (!search_flag)\n  {\n    if (follows_to == parent)\n      search_flag = 1;\n    else\n    {\n      parent = follows_to;\n      follows_to = searchers[parent].follows;\n    }\n\n  }\n\n  searchers[search].follows = follows_to;\n}\n\n", "pragma": "omp for private(search)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/4"}
{"code": "for (int i = 0; i < K; i++)\n{\n  (((cout << \"Cluster \") << i) << \" contains: \") << endl;\n  int count = 0;\n  for (int j = 0; j < numPoints; j++)\n  {\n    if (i == globalMembership[j])\n    {\n      ((cout << \"Point \") << dataset[j].id) << endl;\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/19"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double posXi = pos[i * 3];\n  double posYi = pos[(i * 3) + 1];\n  double posZi = pos[(i * 3) + 2];\n  if (((((posXi >= xPrs1Min) && (posXi <= xPrs1Max)) && (posYi >= yPrs1Min)) && (posYi <= yPrs1Max)) || ((((posXi >= xPrs2Min) && (posXi <= xPrs2Max)) && (posYi >= yPrs2Min)) && (posYi <= yPrs2Max)))\n  {\n    if ((posZi >= zPrs1min) && (posZi <= zPrs1max))\n    {\n      if (press[i] > 0.0)\n      {\n        double v0 = posP1[0] - posXi;\n        double v1 = posP1[1] - posYi;\n        double v2 = posP1[2] - posZi;\n        double dst2 = ((v0 * v0) + (v1 * v1)) + (v2 * v2);\n        if (dst2 < riP1)\n        {\n          P1 = press[i];\n          riP1 = dst2;\n        }\n\n      }\n\n    }\n\n    if ((posZi >= zPrs2min) && (posZi <= zPrs2max))\n    {\n      if (press[i] > 0.0)\n      {\n        double v0 = posP2[0] - posXi;\n        double v1 = posP2[1] - posYi;\n        double v2 = posP2[2] - posZi;\n        double dst2 = ((v0 * v0) + (v1 * v1)) + (v2 * v2);\n        if (dst2 < riP2)\n        {\n          P2 = press[i];\n          riP2 = dst2;\n        }\n\n      }\n\n    }\n\n  }\n\n  double v0 = posP1[0] - posXi;\n  double v1 = posP1[1] - posYi;\n  double v2 = posP1[2] - posZi;\n  double dst2 = ((v0 * v0) + (v1 * v1)) + (v2 * v2);\n  if (dst2 < reS2)\n  {\n    double dst = sqrt(dst2);\n    double wS = weight(dst, reS, weightType);\n    if (press[i] > 0.0)\n    {\n      pndP1 += wS;\n      P1wij += press[i] * wS;\n    }\n\n  }\n\n  v0 = posP2[0] - posXi;\n  v1 = posP2[1] - posYi;\n  v2 = posP2[2] - posZi;\n  dst2 = ((v0 * v0) + (v1 * v1)) + (v2 * v2);\n  if (dst2 < reS2)\n  {\n    double dst = sqrt(dst2);\n    double wS = weight(dst, reS, weightType);\n    if (press[i] > 0.0)\n    {\n      pndP2 += wS;\n      P2wij += press[i] * wS;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: pndP1, pndP2, pndP3, pndP4, P1wij, P2wij, P3wij, P4wij)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/94"}
{"code": "for (i = 0; i < n; i++)\n{\n  diag = A[i + (i * n)];\n  for (j = 0; j < n; j++)\n  {\n    if (j != i)\n    {\n      rowmn = A[i + (j * n)];\n      rowmn2 += rowmn * rowmn;\n    }\n\n  }\n\n  if (diag < sqrt(rowmn2))\n  {\n    dom = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i, j, diag, rowmn, rowmn2) shared(n, A, dom)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cegonse/Jacobi/src/isdom/0"}
{"code": "for (size_t i = 0; i < array.size(); i++)\n{\n  (cout << array[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yinglyu/openmp-gaussian-process-regression/gpr/5"}
{"code": "for (i = 0; i < (layerSize[currentLayer + 1] * layerSize[currentLayer]); ++i)\n{\n  layer->weight[i] = ((1.0 * ((double) rand())) / 32767) - (1.0 / 2);\n}\n\n", "pragma": "omp for schedule(static) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/3"}
{"code": "for (int i = 0; i < (Gsize * rGsizec); ++i)\n{\n  rGc[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/114"}
{"code": "for (unsigned int j = 0; j < N; ++j)\n{\n  for (unsigned int k = 0; k < N; ++k)\n  {\n    float b = B[(k * N) + j];\n    for (unsigned int i = 0; i < N; ++i)\n    {\n      C[(i * N) + j] += b * A[(i * N) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/06matmul_omp/2"}
{"code": "for (i = 0; i < NumOfClusters; i++)\n{\n  root = Clusters[i].root;\n  fprintf(fo, \"%d Cluster: Center x = %lf y = %lf\\n\", i + 1, Clusters[i].x, Clusters[i].y);\n  while (root)\n  {\n    fprintf(fo, \"%lf %lf\\n\", Field[root->Index].x, Field[root->Index].y);\n    root = GoNext(root);\n  }\n\n  fprintf(fo, \"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/StaVorosh/K-Means-method/main/8"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  __assume_aligned(cells->speed_0, 64);\n  __assume_aligned(cells->speed_1, 64);\n  __assume_aligned(cells->speed_2, 64);\n  __assume_aligned(cells->speed_3, 64);\n  __assume_aligned(cells->speed_4, 64);\n  __assume_aligned(cells->speed_5, 64);\n  __assume_aligned(cells->speed_6, 64);\n  __assume_aligned(cells->speed_7, 64);\n  __assume_aligned(cells->speed_8, 64);\n  __assume_aligned(tmp_cells->speed_0, 64);\n  __assume_aligned(tmp_cells->speed_1, 64);\n  __assume_aligned(tmp_cells->speed_2, 64);\n  __assume_aligned(tmp_cells->speed_3, 64);\n  __assume_aligned(tmp_cells->speed_4, 64);\n  __assume_aligned(tmp_cells->speed_5, 64);\n  __assume_aligned(tmp_cells->speed_6, 64);\n  __assume_aligned(tmp_cells->speed_7, 64);\n  __assume_aligned(tmp_cells->speed_8, 64);\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    const int y_n = (jj + 1) % params.ny;\n    const int x_e = (ii + 1) % params.nx;\n    const int y_s = (jj == 0) ? ((jj + params.ny) - 1) : (jj - 1);\n    const int x_w = (ii == 0) ? ((ii + params.nx) - 1) : (ii - 1);\n    const float s0 = cells->speed_0[ii + (jj * params.nx)];\n    const float s1 = cells->speed_1[x_w + (jj * params.nx)];\n    const float s2 = cells->speed_2[ii + (y_s * params.nx)];\n    const float s3 = cells->speed_3[x_e + (jj * params.nx)];\n    const float s4 = cells->speed_4[ii + (y_n * params.nx)];\n    const float s5 = cells->speed_5[x_w + (y_s * params.nx)];\n    const float s6 = cells->speed_6[x_e + (y_s * params.nx)];\n    const float s7 = cells->speed_7[x_e + (y_n * params.nx)];\n    const float s8 = cells->speed_8[x_w + (y_n * params.nx)];\n    const float local_density = (((((((s0 + s1) + s2) + s3) + s4) + s5) + s6) + s7) + s8;\n    const float u_x = (((s1 + s5) + s8) - ((s3 + s6) + s7)) / local_density;\n    const float u_y = (((s2 + s5) + s6) - ((s4 + s7) + s8)) / local_density;\n    const float u_sq = (u_x * u_x) + (u_y * u_y);\n    float u[9];\n    u[1] = u_x;\n    u[2] = u_y;\n    u[3] = -u_x;\n    u[4] = -u_y;\n    u[5] = u_x + u_y;\n    u[6] = (-u_x) + u_y;\n    u[7] = (-u_x) - u_y;\n    u[8] = u_x - u_y;\n    float d_equ[9];\n    d_equ[0] = (w0 * local_density) * (1.f - (u_sq / (2.f * c_sq)));\n    d_equ[1] = (w1 * local_density) * (((1.f + (u[1] / c_sq)) + ((u[1] * u[1]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[2] = (w1 * local_density) * (((1.f + (u[2] / c_sq)) + ((u[2] * u[2]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[3] = (w1 * local_density) * (((1.f + (u[3] / c_sq)) + ((u[3] * u[3]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[4] = (w1 * local_density) * (((1.f + (u[4] / c_sq)) + ((u[4] * u[4]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[5] = (w2 * local_density) * (((1.f + (u[5] / c_sq)) + ((u[5] * u[5]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[6] = (w2 * local_density) * (((1.f + (u[6] / c_sq)) + ((u[6] * u[6]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[7] = (w2 * local_density) * (((1.f + (u[7] / c_sq)) + ((u[7] * u[7]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    d_equ[8] = (w2 * local_density) * (((1.f + (u[8] / c_sq)) + ((u[8] * u[8]) / ((2.f * c_sq) * c_sq))) - (u_sq / (2.f * c_sq)));\n    const float t0 = (obstacles[(jj * params.nx) + ii] != 0) ? (s0) : (s0 + (params.omega * (d_equ[0] - s0)));\n    const float t1 = (obstacles[(jj * params.nx) + ii] != 0) ? (s3) : (s1 + (params.omega * (d_equ[1] - s1)));\n    const float t2 = (obstacles[(jj * params.nx) + ii] != 0) ? (s4) : (s2 + (params.omega * (d_equ[2] - s2)));\n    const float t3 = (obstacles[(jj * params.nx) + ii] != 0) ? (s1) : (s3 + (params.omega * (d_equ[3] - s3)));\n    const float t4 = (obstacles[(jj * params.nx) + ii] != 0) ? (s2) : (s4 + (params.omega * (d_equ[4] - s4)));\n    const float t5 = (obstacles[(jj * params.nx) + ii] != 0) ? (s7) : (s5 + (params.omega * (d_equ[5] - s5)));\n    const float t6 = (obstacles[(jj * params.nx) + ii] != 0) ? (s8) : (s6 + (params.omega * (d_equ[6] - s6)));\n    const float t7 = (obstacles[(jj * params.nx) + ii] != 0) ? (s5) : (s7 + (params.omega * (d_equ[7] - s7)));\n    const float t8 = (obstacles[(jj * params.nx) + ii] != 0) ? (s6) : (s8 + (params.omega * (d_equ[8] - s8)));\n    const float local_density_v = (((((((t0 + t1) + t2) + t3) + t4) + t5) + t6) + t7) + t8;\n    const float u_x_v = (((t1 + t5) + t8) - ((t3 + t6) + t7)) / local_density_v;\n    const float u_y_v = (((t2 + t5) + t6) - ((t4 + t7) + t8)) / local_density_v;\n    tot_u += (obstacles[(jj * params.nx) + ii] != 0) ? (0) : (sqrtf((u_x_v * u_x_v) + (u_y_v * u_y_v)));\n    tot_cells += (obstacles[(jj * params.nx) + ii] != 0) ? (0) : (1);\n    tmp_cells->speed_0[ii + (jj * params.nx)] = t0;\n    tmp_cells->speed_1[ii + (jj * params.nx)] = t1;\n    tmp_cells->speed_2[ii + (jj * params.nx)] = t2;\n    tmp_cells->speed_3[ii + (jj * params.nx)] = t3;\n    tmp_cells->speed_4[ii + (jj * params.nx)] = t4;\n    tmp_cells->speed_5[ii + (jj * params.nx)] = t5;\n    tmp_cells->speed_6[ii + (jj * params.nx)] = t6;\n    tmp_cells->speed_7[ii + (jj * params.nx)] = t7;\n    tmp_cells->speed_8[ii + (jj * params.nx)] = t8;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:tot_u), reduction(+:tot_cells)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreiCNitu/HPC/lattice-boltzmann/openMP/lbm/0"}
{"code": "for (i = 0; i < line_count; i++)\n  if (lines[i] != 0)\n  free(lines[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_tokenize/1"}
{"code": "for (i = -2; i < m1; i++)\n  for (j = m2; j < (-2); j++)\n{\n  for (k = 13; k < m3; k++)\n  {\n    if ((omp_get_num_threads() == 8) && (((((i + 2) * 12) + ((j + 5) * 4)) + (k - 13)) != ((omp_get_thread_num() * 9) + (f++))))\n      l++;\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for num_threads (8) collapse(3) schedule(static, 9) reduction(+:l) firstprivate(f)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/collapse-2/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 1; j < (12 + 1); j++)\n  {\n    WL1[i][j] = (((float) rand()) / ((float) (32767 / 2))) - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex3/ex3/7"}
{"code": "for (i_imopVarPre75 = 2; i_imopVarPre75 <= (6 * ((((64 * 64) / 4) + ((64 * 64) / 4)) + ((64 * 64) / 4))); i_imopVarPre75++)\n{\n  ex[i_imopVarPre75] = ex[i_imopVarPre75 - 1] * ex[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/19"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 784; j++)\n  {\n    scanfReturn = fscanf(myFile, \"%f%*c\", &myvar);\n    if (scanfReturn == 1)\n    {\n    }\n    else\n    {\n      printf(\"error in %d,%d. \\n\", i, j);\n      return 1;\n    }\n\n    if ((i >= start) && (i <= end))\n    {\n      block[i - start][j] = myvar;\n    }\n\n    if (i > end)\n    {\n      goto stop;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giannis-mel/Parallel-and-Destributed-Systems/2. kNN implementation using MPI and openMP/code/mpi2/0"}
{"code": "for (i = 0; i < steps; i++)\n{\n  play(prev, next, size);\n  printf(\"%d ----------\\n\", i);\n  print(next, size);\n  tmp = next;\n  next = prev;\n  prev = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/jogo_da_vida/paralell_life/7"}
{"code": "for (j = 0; j < (32 * no_of_processes); j++)\n{\n  if (TFIDF_buff[j].numDocsWithWord != (-1))\n  {\n    sprintf(strings[cursor], \"%s@%s\\t%.16f\", TFIDF_buff[j].document, TFIDF_buff[j].word, TFIDF_buff[j].TFIDF_val);\n    cursor++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lkmokadam/TFIDF_MPI_OpenMP/TFIDF_extra/9"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->present[i] == BOTTOMUP_NOT_VISITED_MARKER)\n  {\n    int start_edge = g->incoming_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->incoming_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int incoming = g->incoming_edges[neighbor];\n      if (frontier->present[incoming] == iteration)\n      {\n        distances[i] = distances[incoming] + 1;\n        local_count++;\n        frontier->present[i] = iteration + 1;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:local_count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chaihf/BFS-OpenMP/bfs/bfs/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i + 1;\n  b[i] = i + 2;\n  validate[i] = log(a[i]) * log(b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/math_flog/math_flog/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  result += fabsf(x[i * inc_x]);\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/2"}
{"code": "for (i = 0; i < NumPart; i++)\n  if (P[i].Ti_endstep < 0)\n  P[i].Ti_endstep = (-P[i].Ti_endstep) - 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/density/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  min_arrival_time = min(min_arrival_time, p[i].arrival_time);\n  max_completion_time = max(max_completion_time, p[i].completion_time);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/prio_nonp_parallel/2"}
{"code": "for (unsigned i = 0; i < blockImages.size(); i++)\n{\n  returnBlocks[i].block_id = i;\n  returnBlocks[i].block_image = makeBlur(blockImages.at(i), kernel_size);\n  bluredImages.push_back(returnBlocks[i]);\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alejandroariasz/parallel-programming/huaariasza-dabaquerot/openmp/blur-openmp/1"}
{"code": "for (i = 0; i < vecsize; i++)\n  if (((i + 1) % 2) != 0)\n{\n  sum += vec_a[i];\n}\n\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab5/lab5/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  a[i] = (rand() % 100) * 1.0;\n  b[i] = ((rand() % 100) + 500) * 1.0;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,10) num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mazuruk-O/OpenMP_example/OpenMp_1_lab/OpenMP_1_lab/OpenMP_1_lab/0"}
{"code": "for (int i = 0; i < num_classes; i++)\n{\n  result += X[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/11"}
{"code": "for (int p = 2; p <= n; p++)\n  if (prime[p])\n  primes++;\n\n\n", "pragma": "omp parallel for reduction(+:primes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa03/sieve/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if (i == 9)\n  {\n    printf(\"thread %d, before tweak, x: %d\\n\", omp_get_thread_num(), x);\n    x = 0;\n    printf(\"thread %d, after tweak, x: %d\\n\\n\", omp_get_thread_num(), x);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/drifter1/openmptutorials/Parallel For Loops/first_last_private/1"}
{"code": "for (i = 0; i < SIZE; i++)\n  for (j = 0; j < SIZE; j++)\n{\n  C[i][j] = 0;\n  for (k = 0; k < SIZE; k++)\n    C[i][j] += A[i][k] * B[k][j];\n\n}\n\n\n", "pragma": "omp parallel for shared(A, B, C) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidabrahim/Parallel-computing-labs/TP1/matrices_calculator/1"}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  base[i] = 0.5 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/indirectaccess1-orig-yes/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  s = s + 1;\n}\n\n", "pragma": "omp for reduction(+:s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdh266/OpenMP_Practice/barrier/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  bar();\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/17"}
{"code": "for (int x = 1; x < (pcolumns - 1); x++)\n{\n  fX = yStart + ((x - 1) * deltaX);\n  updateVal = (((((u_old[(1 * pcolumns) + (x - 1)] + u_old[(1 * pcolumns) + (x + 1)]) * cx) + ((u_old[(0 * pcolumns) + x] + u_old[(2 * pcolumns) + x]) * cy)) + (u_old[(1 * pcolumns) + x] * cc)) - ((((fX * fX) - 1.0) * ((alpha * (1.0 - (fY * fY))) + 2.0)) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  u[(1 * pcolumns) + x] = u_old[(1 * pcolumns) + x] - (relax * updateVal);\n  loop_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:loop_error) private(fX, updateVal, x) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dora-jpg/parallel-jacobi-SOR/HybridMPI/openmpi/3"}
{"code": "for (int i = 0; i <= 3; i++)\n{\n  res[i + 6] = 0;\n  res[i + 30] = 0;\n  res[i + 46] = 0;\n  res[i + 50] = 0;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tastypeanut/uc3m-ca-openmp/img-par/0"}
{"code": "for (i = 0; i < ctrs.size(); ++i)\n{\n  res = IV;\n  if (i > 0)\n  {\n    ctr_i = increment_counter(start_counter, i);\n  }\n\n  res.insert(res.end(), ctr_i.begin(), ctr_i.end());\n  ctrs[i] = res;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/franneck94/CUDA-AES/AES OpenMP/Mode/2"}
{"code": "for (i = 0; i < count; i++)\n{\n  unsigned char *p = (unsigned char *) saved_key[i];\n  if (*p)\n  {\n    uint32_t nr;\n    uint32_t add;\n    uint32_t tmp;\n    while (((*p) == ' ') || ((*p) == '\\t'))\n      p++;\n\n    tmp = (uint32_t) ((unsigned char) (*(p++)));\n    nr = 1345345333 ^ ((((1345345333 & 63) + 7) * tmp) + (1345345333U << 8));\n    add = 7 + tmp;\n    for (; *p; p++)\n    {\n      if (((*p) == ' ') || ((*p) == '\\t'))\n        continue;\n\n      tmp = (uint32_t) ((unsigned char) (*p));\n      nr ^= (((nr & 63) + add) * tmp) + (nr << 8);\n      add += tmp;\n    }\n\n    crypt_key[i][0] = nr & ((((uint32_t) 1) << 31) - 1);\n    continue;\n  }\n\n  crypt_key[i][0] = 1345345333 & ((((uint32_t) 1) << 31) - 1);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(count, saved_key, crypt_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mysql_fmt_plug/0"}
{"code": "for (i = 0; i < 150; i++)\n{\n  a1[2][i] = e[2][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/10"}
{"code": "for (i = 1; i < k; i++)\n  score = score + scoringMatrix[i][i + n];\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/calculations/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    b[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/igrishaev/vsu-prp/matrix_fox_omp/8"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_parallel_copyin())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/parallel/omp_parallel_copyin/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  static int tmp = 0;\n  tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/2018-static-origin-yes/0"}
{"code": "for (int i = 0; i < (*all_cells).size(); i++)\n{\n  static int i_Oxy_i = (*all_cells)[i]->custom_data.find_variable_index(\"intra_oxy\");\n  static int i_Glu_i = (*all_cells)[i]->custom_data.find_variable_index(\"intra_glu\");\n  static int i_Lac_i = (*all_cells)[i]->custom_data.find_variable_index(\"intra_lac\");\n  static int energy_vi = (*all_cells)[i]->custom_data.find_variable_index(\"intra_energy\");\n  if ((*all_cells)[i]->is_out_of_domain == false)\n  {\n    double cell_volume = (*all_cells)[i]->phenotype.volume.total;\n    double oxy_val_int = (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[oxygen_substrate_index] / cell_volume;\n    double glu_val_int = (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[glucose_substrate_index] / cell_volume;\n    double lac_val_int = (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[lactate_substrate_index] / cell_volume;\n    (*all_cells)[i]->phenotype.intracellular->set_parameter_value(\"Oxygen\", oxy_val_int);\n    (*all_cells)[i]->phenotype.intracellular->set_parameter_value(\"Glucose\", glu_val_int);\n    (*all_cells)[i]->phenotype.intracellular->set_parameter_value(\"Lactate\", lac_val_int);\n    (*all_cells)[i]->phenotype.intracellular->update();\n    (*all_cells)[i]->phenotype.intracellular->update_phenotype_parameters((*all_cells)[i]->phenotype);\n    (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[oxygen_substrate_index] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Oxygen\") * cell_volume;\n    (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[glucose_substrate_index] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Glucose\") * cell_volume;\n    (*all_cells)[i]->phenotype.molecular.internalized_total_substrates[lactate_substrate_index] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Lactate\") * cell_volume;\n    (*all_cells)[i]->custom_data[i_Oxy_i] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Oxygen\");\n    (*all_cells)[i]->custom_data[i_Glu_i] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Glucose\");\n    (*all_cells)[i]->custom_data[i_Lac_i] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Lactate\");\n    (*all_cells)[i]->custom_data[energy_vi] = (*all_cells)[i]->phenotype.intracellular->get_parameter_value(\"Energy\");\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/sample_projects_intracellular/ode/ode_energy/custom_modules/custom/1"}
{"code": "for (int i = 0; i < tamanho; i++)\n{\n  printf(\"-\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/novo_jogo_da_vida/jogo/2"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + .5) * step;\n  tablica[id + j] += 4.0 / (1. + (x * x));\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/INFJakZda/Parallel-Programming/OpenMP/main/1"}
{"code": "for (i = 0; i < lnv; i++)\n{\n  value[i] += 1;\n}\n\n", "pragma": "        #pragma omp distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-sequence-distribute-parallel-for/test/0"}
{"code": "for (i = 0; i < M; i++)\n  for (j = 0; j < N; j++)\n  matrixC[(i * K) + j] = (drand48() * 2.0) - 1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/lds-prob3/lds-prob3/2"}
{"code": "for (k = 8; k > 0; k--)\n{\n  indice = lectura_caracteres[0] % 2;\n  lectura_caracteres[0] = lectura_caracteres[0] / 2;\n  lectura_binario[k - 1] = digitos_binario[indice];\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chuucks/C-Multi-Parallel-programing-with-and-OpenMp-and-MPI/encriptador_paralelo/1"}
{"code": "for (int i = 0; i < M; i += SMALL_M)\n{\n  int sub_M = (SMALL_M < (M - i)) ? (SMALL_M) : (M - i);\n  {\n    for (int j = 0; j < N; j += SMALL_N)\n    {\n      int sub_N = (SMALL_N < (N - j)) ? (SMALL_N) : (N - j);\n      compute(A + ((i * lda) + (k * 8)), B + ((j * lda) + k), C + ((j * lda) + i), sub_M, sub_N, sub_K, lda);\n    }\n\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/6"}
{"code": "for (i = 0; i < 12; i += 2)\n{\n  printf(\"Hello Again %d\\n\", i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-nowait/1"}
{"code": "for (c1 = nm; c1 <= (nj + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/29"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < (n - 1); j++)\n    fprintf(heatmap, \"%lf,\", u[(i * n) + j]);\n\n  fprintf(heatmap, \"%lf\\n\", u[((i * n) + n) - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emmanuellujan/2d-diff-eq-julia-vs-c-openmp/diffusion-parallel/3"}
{"code": "for (i = 0; i < (SIZE * SIZE); i++)\n{\n  initCell(grid, i);\n}\n\n", "pragma": "    #pragma omp parallel for simd collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilisG/Game-of-Life-in-OpenMP-and-OpenCL/Game of Life/Game_of_Life_parallel_CPU_OpenMP_4.0/main/0"}
{"code": "for (i = 0; i < npoints; i++)\n{\n  int tid = omp_get_thread_num();\n  index = find_nearest_point(feature + (i * nfeatures), nfeatures, clusters, nclusters);\n  if (membership[i] != index)\n    delta += 1.0;\n\n  membership[i] = index;\n  partial_new_centers_len[(tid * nclusters) + index]++;\n  for (j = 0; j < nfeatures; j++)\n    partial_new_centers[(((tid * nclusters) * nfeatures) + (index * nfeatures)) + j] += feature[(i * nfeatures) + j];\n\n}\n\n", "pragma": "omp parallel for shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len) private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/kmeans/kmeans_clustering.ref/0"}
{"code": "for (j = 0; a.length() != 0; j++)\n{\n  int i = a.find(\"|\");\n  if (i > a.length())\n  {\n    gram[np][j + 1] = a;\n    a = \"\";\n  }\n  else\n  {\n    gram[np][j + 1] = a.substr(0, i);\n    a = a.substr(i + 1, a.length());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-CYK-CFG-Parser-OMP/src/parser/1"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm3_start = wtime();\n  for (int source = 0; source < V; ++source)\n  {\n    cc(source, g);\n  }\n\n  btm3_sum += wtime() - btm3_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/2"}
{"code": "for (j = 1; j < (128 + 1); j++)\n{\n  mean[j] = 0.0;\n  for (i = 1; i < (128 + 1); i++)\n  {\n    mean[j] += data[(i * (128 + 1)) + j];\n  }\n\n  mean[j] /= (DATA_TYPE) 3214212.01f;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/25"}
{"code": "for (int k = 0; k < Yk; k++)\n{\n  img_integration_kernel(d_pProj, nDetXMap, nDetYMap, integrateYcoord, k * 9, 0, nProj, teams, teamX, teamY, threads, threadX, threadY, threadZ);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/13"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  x1[i] = ((float) i) / 2048;\n  x2[i] = (((float) i) + 1) / 2048;\n  y1[i] = (((float) i) + 3) / 2048;\n  y2[i] = (((float) i) + 4) / 2048;\n  for (j = 0; j < 2048; j++)\n    A[(i * 2048) + j] = (((float) i) * j) / 2048;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/14"}
{"code": "for (int i = 0; i < len; i++)\n{\n  input[i] = rand() % len;\n  idx[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/4"}
{"code": "for (iterator it = lookUp.begin(); it != lookUp.end(); it++)\n{\n  it->second += offset;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/rebuild/7"}
{"code": "for (i = 0; i < N; i++)\n  a[i] = (float *) malloc(N * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/backsub/backsub_parallel/0"}
{"code": "for (k = n - 1; k >= 0; k--)\n{\n  x[k] = y[k];\n  for (j = k + 1; j < n; j++)\n  {\n    x[k] -= A[k][j] * x[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/Numerical_Analysis/parallel/openmp_gaussian_elimination_l/gauss/8"}
{"code": "for (int i = 0; i < asteps; i++)\n  gs[i] = Gamma(2.0 - (i / ((T) (asteps - 1))));\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/4"}
{"code": "for (int i = 0; i < seqLength; ++i)\n{\n  nextHiddenStateEfficient(input_t, h_tminus1, c_tminus1, hiddenSize, miniBatch);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_1/6"}
{"code": "for (int i = 0; i < (k * n); i++)\n{\n  histograms[i] = (int *) malloc(hist_size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gulsumgudukbay/Parallel-P3-FaceRecognition/FaceDetection/src/lbp_omp/11"}
{"code": "for (int i = j; i < (j + (N / 2)); i++)\n{\n  y[i] = x[i];\n  int team = omp_get_team_num();\n  int nteams = omp_get_num_teams();\n  int tid = omp_get_thread_num();\n  int nthreads = omp_get_num_threads();\n  printf(\"Iteration %d given to thread %d from team %d.\\n\", i, tid, team);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/colleeneb/openmp45_examples/04_target_teams_distribute_parallel/1"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  for (k = 0; k < 50; k++)\n  colidx[i][j][k] = 0;\n\n\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/pointer2Array3/0"}
{"code": "for (int i = 0; i < FILTER_MATRIX_SIZE; i++)\n{\n  filtervec[i] = SharpenFilter[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alaxalves/matrix/OpenMP/src/pspd-proj1/1"}
{"code": "for (int rotation = 0; rotation < numprocs; rotation++)\n{\n  for (int i = 1; i < numprocs; i++)\n  {\n    struct tablo *SubMatrixAByCols = allocateTablo(getSizeSubmatrixDividedByCols(matrixB, numprocs));\n    getSubmatrixDividedByCols(matrixB, SubMatrixAByCols, i, numprocs);\n    send_slice(SubMatrixAByCols->tab, SubMatrixAByCols->size, i);\n    free(SubMatrixAByCols);\n  }\n\n  struct tablo *my_cols = allocateTablo(getSizeSubmatrixDividedByRows(matrixB, numprocs));\n  getSubmatrixDividedByCols(matrixB, my_cols, 0, numprocs);\n  my_cols->nb_rows = dim;\n  my_cols->nb_cols = dim / numprocs;\n  struct tablo *my_product = allocateTablo(getMatrixSizeToAllocate(my_rows, my_cols));\n  multiply3(my_rows, my_cols, my_product);\n  fillMatrix(bigMatrix, my_product, ((((rank + step) % numprocs) * dim) / numprocs) % dim);\n  step++;\n  rotateMatrixToTheRight(matrixB, ((dim / numprocs) * numprocs) - (dim / numprocs));\n  free(my_cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/14"}
{"code": "for (int i = 0; i < row2; i++)\n{\n  for (int j = 0; j < col2; j++)\n  {\n    printf(\"%d\\t\", b[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zeeshanmahar007/Matrix-Matrix-Multiplication-in-Parallel/omp_parallel/8"}
{"code": "for (int i = 0; i < (images.size() - 1); i++)\n{\n  MatchPair > match_list;\n  match_keypoints(kpt_lists[i], kpt_lists[i + 1], match_list);\n  matches[i] = match_list;\n  if (match_list.size() == 0)\n  {\n    matchListSizeZero = true;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic) num_threads(16) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_cuda/image_stitching/12"}
{"code": "for (j = k; j <= l; j += m - 1)\n  a[j] = 2;\n\n", "pragma": "omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-18/1"}
{"code": "for (vi = nvtxs >> 2; vi < nvtxs; vi++)\n{\n  if (((txadj[vi + 1] - txadj[vi]) << 9) > vi)\n    break;\n\n  if (((xadj[vi + 1] - xadj[vi]) << 4) > (nvtxs - vi))\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/14"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (x[i] != 0.0)\n  {\n    absxi = fabs(x[i]);\n    if (scale < absxi)\n    {\n      ssq = 1.0 + (ssq * pow(scale / absxi, 2));\n      scale = absxi;\n    }\n    else\n    {\n      ssq = ssq + pow(absxi / scale, 2);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilcoln/be-enseeiht-openmp/norm2_noowr/main/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  a[i] = ((double) i) / 2.0;\n  b[i] = ((double) i) / 3.0;\n  c[i] = ((double) i) / 7.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB111-linearmissing-orig-yes/1"}
{"code": "for (unsigned i = 0; i < x.size(); ++i)\n{\n  int nz;\n  int ierr;\n  zbesj_(&x[i], &y[i], &r_1, &c_1, &c_1, &re_ref[i], &im_ref[i], &nz, &ierr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/2"}
{"code": "for (int j = 0; j < x.ncol(); j++)\n{\n  for (int i = 0; i < x.nrow(); i++)\n    ret(i, j) = x(i, j) - vec(i);\n\n}\n\n", "pragma": "  #pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wrathematics/Romp/src/examples_rcpp/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  if (!memcmp(binary, crypt_out[index], (20 - 2) - 2))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/aix_ssha_fmt_plug/2"}
{"code": "for (i = 0; i < (2 * NK); i++)\n  x[i] = -1.0e99;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/EP/ep/1"}
{"code": "for (uint8_t *mask = segmentation_map; mask < (segmentation_map + (width * height)); ++mask)\n  if ((*mask) > 0)\n  *mask = COLOR_FOREGROUND;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/14"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  changement = 0;\n  for (int i = 1; i < (GRAIN + 1); i += 1)\n    for (int j = 1; j < (GRAIN + 1); j += 1)\n  {\n    ;\n    if (!tab_unstable[(i * (GRAIN + 2)) + j])\n    {\n      if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n        tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n    }\n    else\n    {\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n      changement += tab_unstable[(i * (GRAIN + 2)) + j];\n    }\n\n  }\n\n\n  if (changement == 0)\n    return it;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/36"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n  {\n    fprintf(fp, \"1 \");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/144"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  graph_free(graphs[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/20"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/33"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arzunuvar/Scientific_Computing_Codes/Paralel_Programlama_Ders_\u0130ci_Kodlar/countSorting (parallel)/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/9"}
{"code": "for (i = 2; i <= N; ++i)\n{\n  primes[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/sieve_of_erastosthenes_openmp/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    vijk = vs[i][j][k];\n    vp1 = vs[i][j + 1][k];\n    vm1 = vs[i][j - 1][k];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dy1ty1 * ((u[i][j + 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j - 1][k][0]))) - (ty2 * (u[i][j + 1][k][2] - u[i][j - 1][k][2]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dy2ty1 * ((u[i][j + 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j - 1][k][1]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][1] * vp1) - (u[i][j - 1][k][1] * vm1)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dy3ty1 * ((u[i][j + 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j - 1][k][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[i][j + 1][k][2] * vp1) - (u[i][j - 1][k][2] * vm1)) + ((((u[i][j + 1][k][4] - square[i][j + 1][k]) - u[i][j - 1][k][4]) + square[i][j - 1][k]) * c2)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dy4ty1 * ((u[i][j + 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j - 1][k][3]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][3] * vp1) - (u[i][j - 1][k][3] * vm1)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dy5ty1 * ((u[i][j + 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j - 1][k][4]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[i][j + 1][k][4] * rho_i[i][j + 1][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j - 1][k][4] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[i][j + 1][k][4]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[i][j - 1][k][4]) - (c2 * square[i][j - 1][k])) * vm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(vijk, vp1, vm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/45"}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/18"}
{"code": "for (count = 0; count < (V - 1); count++)\n{\n  int u = minKeySeq(key, visited, V);\n  visited[u] = 1;\n  int v;\n  for (v = 0; v < V; v++)\n    if ((graph[u][v] && (visited[v] == 0)) && (graph[u][v] < key[v]))\n    from[v] = u, key[v] = graph[u][v];\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parthvshah/parallel-prims/src/bench/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    float diff = fabsf(test[i][j] - ref[i][j]);\n    if (diff < 1e-2)\n    {\n      fprintf(stderr, \"%8.2f \", test[i][j]);\n    }\n    else\n    {\n      fprintf(stderr, \"%7.2f* \", test[i][j]);\n    }\n\n    max_err = fmaxf(max_err, diff);\n    min_err = fminf(min_err, diff);\n    verif = verif && (diff < 1e-2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/9"}
{"code": "for (int i = 0; i < N; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/4"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < 2048; j++)\n  {\n    grid[i][j] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fad-andrade/GameOfLife/omp_version/4"}
{"code": "for (j = active_size; j < l; j++)\n  G[j] = G_bar[j] + p[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/2"}
{"code": "for (i = 0; i < ((int) distributed_particles); i++)\n{\n  if (gBestFitness == pBestFitness[i])\n    min = i;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/mpiomp/4"}
{"code": "for (i = 0; i < n; i++)\n  if (index[i] == 1)\n{\n  new_index[i] = tmp_ind;\n  tmp_ind++;\n}\nelse\n{\n  new_index[i] = tmp_ind;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/compact/compact_parallel/5"}
{"code": "for (int k = 0; k < cyl_geom->n_grid_z; k++)\n{\n  b = 2. * (1. - (((dr * dr) / (dz * dz)) * (cos((PI * (k + 1)) / (cyl_geom->n_grid_z + 1)) - 1)));\n  d = ((dr * dr) * t_charge_density[0][k]) / EPSILON0;\n  alpha[1] = 4. / (2. + b);\n  beta[1] = d / (2. + b);\n  for (int i = 1; i < (cyl_geom->n_grid_r - 1); i++)\n  {\n    a = 1. - (1. / (2. * i));\n    c = 1. + (1. / (2. * i));\n    d = ((dr * dr) * t_charge_density[i][k]) / EPSILON0;\n    alpha[i + 1] = c / (b - (alpha[i] * a));\n    beta[i + 1] = (d + (beta[i] * a)) / (b - (alpha[i] * a));\n  }\n\n  for (int i = cyl_geom->n_grid_r - 2; i >= 0; i--)\n    fi[i][k] = beta[i + 1] + (alpha[i + 1] * fi[i + 1][k]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/poissonDirichlet/2"}
{"code": "for (int i = 0; i < n; ++i)\n  if (x[i] != y[i])\n{\n  info = 1;\n  x[i] = y[i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/3"}
{"code": "for (i = 0; i < ArraySize; i++)\n{\n  array[i] = Ranf(-1.f, 1.f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tanyakhemani/parallel-programming/project2/project2/0"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  if ((node_distance_array[i] < dist) && (visited_nodes_array[i] == 0))\n  {\n    node = i;\n    dist = node_distance_array[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/10"}
{"code": "for (int i = 0; i < coord.size(); ++i)\n  convert(coord[i], coord_s[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/SandBox/einspline_io/2"}
{"code": "for (k = 0; k < n; k++)\n{\n  c[i][j] += a[j][k] * b[k][j];\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/threeparallel/2"}
{"code": "for (int i = 0; i < n; i++)\n  index[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ChrisPster/vantage-point-tree/src/vptree_openmp/2"}
{"code": "for (int i = 0; i < Size; i++)\n{\n  fprintf(fp2, \"%f\\n\", Sums[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daniel-lindsay/Comparison-of-Parallel-Programming-Methods/Project 7/Project7/try/0"}
{"code": "for (i = 1; i < ((BLOCK_WIDTH * BLOCK_HEIGHT) + 1); i++)\n{\n  mySendArr[i] = pixels[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/mandelbrot-hybrid/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    a2[(i * size) + j] = a[i][j];\n    b2[(i * size) + j] = b[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(a2, b2, a, b, size) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_block_transpose/1"}
{"code": "for (i = 0; i < Np; i++)\n  r0[i] = r[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/20"}
{"code": "for (int i = 1; i <= halfLen; i++)\n{\n  for (int j = 1; j <= halfLen; j++)\n  {\n    A11->matrixPush(matrixA->getMatrixElement(i, j));\n    A12->matrixPush(matrixA->getMatrixElement(i, j + halfLen));\n    A21->matrixPush(matrixA->getMatrixElement(i + halfLen, j));\n    A22->matrixPush(matrixA->getMatrixElement(i + halfLen, j + halfLen));\n    B11->matrixPush(matrixB->getMatrixElement(i, j));\n    B12->matrixPush(matrixB->getMatrixElement(i, j + halfLen));\n    B21->matrixPush(matrixB->getMatrixElement(i + halfLen, j));\n    B22->matrixPush(matrixB->getMatrixElement(i + halfLen, j + halfLen));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nablax/OpenMP-CUDA-Matrix-Multiplication/QtMatrixOpenMP/MatrixCalculation/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  AA[i] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wolfram18/OpenMP-Practice/OpenMP-Project/Project345/Synchronization/7"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  fprintf(resultFile, \"C%d  \\n\", i + 1);\n  for (j = 0; j < dimensions; j++)\n  {\n    fprintf(resultFile, \"%4.3lf    \", allClusters[i].virutalCenter.coordinates[j]);\n  }\n\n  fprintf(resultFile, \"\\n\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/main/0"}
{"code": "for (int i = 1; i < n; i++)\n{\n  res = max(res, arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tokarevart/parallel-ensembling/OpenMPParallelEnsembling/2"}
{"code": "for (iz = 0; iz < nzl; iz++)\n{\n  for (ip = 0; ip < numP; ip++)\n  {\n    for (j = 0; j < nrows; j++)\n    {\n      bufoff = ((j * nxl) + (ip * chunksize)) + ((iz * nxl) * nyl);\n      rowoff = ((j * nxfull) + (ip * nxl)) + ((iz * nxl) * nyl);\n      for (i = 0; i < nxl; i++)\n      {\n        obuf[i + bufoff] = ibuf[i + rowoff];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/fft_util_omp45/8"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (int i = h_graph_nodes__starting; i < (h_graph_nodes__no_of_edges + h_graph_nodes__starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_bug/0"}
{"code": "for (int e = 0; e < experTime; e++)\n{\n  times[e] = scale_omp(input, output, len);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/3"}
{"code": "for (int64_t i = 0; i < num_local; i++)\n{\n  sum += f(h * ((((i * size64) + rank64) + 1) - 0.5));\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum) schedule(static, 2000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndrewGaspar/estimate-pi-openmp/main/0"}
{"code": "for (; i < N; i++)\n{\n  for (; j < N; j++)\n  {\n    if ((i % 2) == 0)\n    {\n      c[i] = re[i / 2];\n    }\n    else\n    {\n      c[i] = im[(i + 1) / 2];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/9"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    *IDX(grid, i, j, n) = randab(fmin, fmax);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fam4r/uni-hpc/project/src/omp-earthquake/4"}
{"code": "for (int n = 1; n <= N; n++)\n{\n  aux = vex3 / (((n * n) * pow(X, n)) * w);\n  if ((n % 2) == 0)\n  {\n    aux = -aux;\n  }\n\n  sum += aux;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonedarts/rendezvous/openCL/rendezvous/rendezvous-opencl/3"}
{"code": "for (i = 0; i <= 10; i++)\n{\n  x = i;\n  printf_s(\"Thread number: %d         x: %d\\n\", omp_get_thread_num(), x);\n}\n\n", "pragma": "#pragma omp parallel for lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_programing_CSharp/LU5/Ex1/Ex1/Exercise/0"}
{"code": "for (i = 0; i < V; i++)\n{\n  int distIK = graph[(i * V) + k];\n  if (distIK == infinity)\n    continue;\n\n  for (j = 0; j < V; j++)\n  {\n    if (graph[(i * V) + j] > (distIK + graph[(k * V) + j]))\n    {\n      graph[(i * V) + j] = distIK + graph[(k * V) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j) num_threads(numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/25"}
{"code": "for (int i = 0; i < res_nz; i++)\n{\n  full_C_rows[i] = lower_C_rows[i];\n  full_C_rows[res_nz + i] = lower_C_cols[i];\n  full_C_cols[i] = lower_C_cols[i];\n  full_C_cols[res_nz + i] = lower_C_rows[i];\n  full_C_values_coo[i] = lower_C_values[i];\n  full_C_values_coo[res_nz + i] = lower_C_values[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andriotis/Parallel-Distributed-Systems-1/openmp/4"}
{"code": "for (int i = 0; i < AA_NUMBER; i++)\n  one_l_div_total[i] = ((double) one_l[i]) / total_l;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DylanPW/cvtree-Parallelisation/parallel/2"}
{"code": "for (iter = 1; iter <= niter; iter++)\n{\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_start(T_EVOLVE);\n  }\n\n  evolve(u0, u1, iter, indexmap, dims[0]);\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_stop(T_EVOLVE);\n  }\n\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_start(T_FFT);\n  }\n\n  fft(-1, u1, u2);\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_stop(T_FFT);\n  }\n\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_start(T_CHECKSUM);\n  }\n\n  checksum(iter, u2, dims[0]);\n  if (TIMERS_ENABLED == TRUE)\n  {\n    timer_stop(T_CHECKSUM);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/benchmark-subsetting/NPB3.0-omp-C/FT/ft/0"}
{"code": "for (i = 0; i < lvec; i++)\n{\n  pe = pe + (V1[i] * V2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/13"}
{"code": "for (; (i < N) && (j < N); i += incX * 4, j += incY * 4)\n{\n  save = _mm_load_ps(Y + i);\n  _mm_store_ps(Y + i, _mm_load_ps(X + i));\n  _mm_store_ps(X + i, save);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/swap/3"}
{"code": "for (j = x_min - 2; j <= (x_max + 2); j++)\n{\n  cellx[FTNREF1D(j, x_min - 2)] = 0.5 * (vertexx[FTNREF1D(j, x_min - 2)] + vertexx[FTNREF1D(j + 1, x_min - 2)]);\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/initialise_chunk_kernel_c/4"}
{"code": "for (i = 0; i < 1000000000; i++)\n  a[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/sum_and_dot_product/sum_multi_thread/1"}
{"code": "for (i = 0; i < 8192; i++)\n  dot += X[i] * Y[i];\n\n", "pragma": "omp parallel for schedule(static) reduction(+ : dot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/1"}
{"code": "for (c2 = nm; c2 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/18"}
{"code": "for (i = 1; i < (DIM - 1); i++)\n{\n  for (j = 1; j < (DIM - 1); j++)\n    next_img(i, j) = verify_life(i, j);\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pravez/VitaeLabilis/src/compute/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = bt * r1;\n    t2 = 0.5 * (r4 + r5);\n    rhs[0][i][j][k] = bt * (r4 - r5);\n    rhs[1][i][j][k] = -r3;\n    rhs[2][i][j][k] = r2;\n    rhs[3][i][j][k] = (-t1) + t2;\n    rhs[4][i][j][k] = t1 + t2;\n  }\n\n}\n\n", "pragma": "omp parallel for private (r1,r2,r3,r4,r5,t1,t2,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/88"}
{"code": "for (int p = 0; p < Population; p++)\n  f[p] = Eval(solver.GetStateArr()[p]);\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orthopteroid/psychic-sniffle/src/quadratic/main/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  arr[i] *= 2;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/easy_mapper/main/1"}
{"code": "for (j = 0; j < 256; j++)\n  fftwf_execute_dft(p1d, (fftwf_complex *) in_fftw[k][j][0], (fftwf_complex *) in_fftw[k][j][0]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dumitrux/Parallelism-FIB/Laboratorio/Lab1/Material-lab1/lab1/3dfft/3dfft_omp/4"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      Pworksx[LOC3D(i, j, k)] = (Pxfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pxfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n      Pworksy[LOC3D(i, j, k)] = (Pyfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pyfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n      Pworksz[LOC3D(i, j, k)] = (Pzfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pzfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/4"}
{"code": "for (i = 0; i < d; i++)\n{\n  num_array[i] = num % 10;\n  num /= 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jk78346/countsort_openmp/01_MP1/code/src/sort/6"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  A[i] = x[i] + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/allocate/test_allocate_on_device/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  double sum = 0.0;\n  #pragma cetus private(j)\n  #pragma loop name mv#0#0\n  #pragma cetus reduction(+: sum)\n  #pragma cetus parallel\n  for (j = 0; j < 1000; j++)\n  {\n    sum += a[i][j] * v[j];\n  }\n\n  v_out[i] = sum;\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB062-matrixvector2-orig-no/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  fread(buffer, sizeof(float), cols, fsignal);\n  for (j = 0; j < cols; j++)\n  {\n    if (buffer[j] != nvalue)\n    {\n      if (smax < buffer[j])\n      {\n        smax = buffer[j];\n        maxrow = i;\n        maxcol = j;\n      }\n\n    }\n\n  }\n\n  fseek(fsignal, (cols * (bands - 1)) * (sizeof(float)), 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/2"}
{"code": "for (i = 0; i < matrixAData.iSize; i++)\n{\n  for (j = 0; j < matrixBData.jSize; j++)\n  {\n    matrixAIndex = matrixAData.startingJ + ((matrixAData.startingI + i) * matrixAData.matrixJSize);\n    matrixBIndex = (matrixBData.startingJ + j) + (matrixBData.startingI * matrixBData.matrixJSize);\n    resultIndex = (resultData.startingJ + j) + ((resultData.startingI + i) * resultData.matrixJSize);\n    result[resultIndex] = 0;\n    for (k = 0; k < matrixAData.jSize; k++)\n    {\n      result[resultIndex] += matrixA[matrixAIndex] * matrixB[matrixBIndex];\n      matrixAIndex++;\n      matrixBIndex += matrixBData.matrixJSize;\n    }\n\n    if (!isPositive)\n    {\n      result[resultIndex] = -result[resultIndex];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for nowait collapse(2) private(i, j, k, matrixAIndex, matrixBIndex, resultIndex)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_MatrixInverse/inverse_matrix/1"}
{"code": "for (int ii = 0; ii < NUM_FIELDS; ++ii)\n{\n  if (fields[ii])\n  {\n    double *deviceField = 0;\n    switch (ii + 1)\n    {\n      case FIELD_DENSITY:\n        deviceField = density;\n        break;\n\n      case FIELD_ENERGY0:\n        deviceField = energy0;\n        break;\n\n      case FIELD_ENERGY1:\n        deviceField = energy;\n        break;\n\n      case FIELD_U:\n        deviceField = u;\n        break;\n\n      case FIELD_P:\n        deviceField = p;\n        break;\n\n      case FIELD_SD:\n        deviceField = sd;\n        break;\n\n      default:\n        panic(416, \"/tmp/tmp5a87sqwx.c\", \"Incorrect field provided: %d.\\n\", ii + 1);\n\n    }\n\n    kernel(_chunk.x, _chunk.y, _chunk.z, deviceField, buffer + offsets[ii], depth, offload);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/12"}
{"code": "for (i = 18; i > 0; i--)\n{\n  p0 = m0;\n  p1 = m1;\n  p2 = m2;\n  for (j = 48; j > 0; j--)\n  {\n    t0 = (p0[0] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n    t1 = (p1[0] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n    t2 = (p2[0] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n    j--;\n    t0 = (p0[1] ^= lotus_magic_table[ARCH_INDEX(j + t0)]);\n    p0 += 2;\n    t1 = (p1[1] ^= lotus_magic_table[ARCH_INDEX(j + t1)]);\n    p1 += 2;\n    t2 = (p2[1] ^= lotus_magic_table[ARCH_INDEX(j + t2)]);\n    p2 += 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus5_fmt_plug/4"}
{"code": "for (int ii = 0; ii < NY; ii++)\n{\n  for (int jj = 0; jj < NX; jj++)\n  {\n    int pos = (ii * NX) + jj;\n    double *s = cells[pos].speeds;\n    if ((ii * NX) == secondRow)\n      if ((((!obstacles[pos]) && (s[3] - DENSITY_ACCEL_D9)) && (s[6] - DENSITY_ACCEL_D36)) && (s[7] - DENSITY_ACCEL_D36))\n    {\n      s[1] += DENSITY_ACCEL_D9;\n      s[5] += DENSITY_ACCEL_D36;\n      s[8] += DENSITY_ACCEL_D36;\n      s[3] -= DENSITY_ACCEL_D9;\n      s[6] -= DENSITY_ACCEL_D36;\n      s[7] -= DENSITY_ACCEL_D36;\n    }\n\n\n    int y_n = (ii == (NY - 1)) ? (0) : (ii + 1);\n    int x_e = (jj == (NX - 1)) ? (0) : (jj + 1);\n    int y_s = (!ii) ? ((ii + NY) - 1) : (ii - 1);\n    int x_w = (!jj) ? ((jj + NX) - 1) : (jj - 1);\n    int iiNX = ii * NX;\n    int ynNX = y_n * NX;\n    int ysNX = y_s * NX;\n    tmp_cells[iiNX + jj].speeds[0] = s[0];\n    tmp_cells[iiNX + x_e].speeds[1] = s[1];\n    tmp_cells[ynNX + jj].speeds[2] = s[2];\n    tmp_cells[iiNX + x_w].speeds[3] = s[3];\n    tmp_cells[ysNX + jj].speeds[4] = s[4];\n    tmp_cells[ynNX + x_e].speeds[5] = s[5];\n    tmp_cells[ynNX + x_w].speeds[6] = s[6];\n    tmp_cells[ysNX + x_w].speeds[7] = s[7];\n    tmp_cells[ysNX + x_e].speeds[8] = s[8];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/noobcode/High-Performance-Computing/Src_OpenMP/d2q9-bgk/0"}
{"code": "for (l = 1; l < nzh; l++)\n{\n  dkz = dnz * ((float) l);\n  ll = nxyhd * l;\n  lj = nxvyh * l;\n  l1 = (nxvyh * nz) - lj;\n  ws = 0.0;\n  wp = 0.0;\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    for (j = 1; j < nxh; j++)\n    {\n      dkx = dnx * ((float) j);\n      afdt = adt * cimagf(ffc[(j + kk) + ll]);\n      zt1 = (-cimagf(exyz[2 + (3 * ((j + kj) + lj))])) + (crealf(exyz[2 + (3 * ((j + kj) + lj))]) * _Complex_I);\n      zt2 = (-cimagf(exyz[1 + (3 * ((j + kj) + lj))])) + (crealf(exyz[1 + (3 * ((j + kj) + lj))]) * _Complex_I);\n      zt3 = (-cimagf(exyz[3 * ((j + kj) + lj)])) + (crealf(exyz[3 * ((j + kj) + lj)]) * _Complex_I);\n      zt4 = bxyz[3 * ((j + kj) + lj)] - (dth * ((dky * zt1) - (dkz * zt2)));\n      zt5 = bxyz[1 + (3 * ((j + kj) + lj))] - (dth * ((dkz * zt3) - (dkx * zt1)));\n      zt6 = bxyz[2 + (3 * ((j + kj) + lj))] - (dth * ((dkx * zt2) - (dky * zt3)));\n      zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n      zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n      zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n      zt7 = (exyz[3 * ((j + kj) + lj)] + (cdt * ((dky * zt1) - (dkz * zt2)))) - (afdt * cu[3 * ((j + kj) + lj)]);\n      zt8 = (exyz[1 + (3 * ((j + kj) + lj))] + (cdt * ((dkz * zt3) - (dkx * zt1)))) - (afdt * cu[1 + (3 * ((j + kj) + lj))]);\n      zt9 = (exyz[2 + (3 * ((j + kj) + lj))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (3 * ((j + kj) + lj))]);\n      zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n      zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n      zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n      exyz[3 * ((j + kj) + lj)] = zt7;\n      exyz[1 + (3 * ((j + kj) + lj))] = zt8;\n      exyz[2 + (3 * ((j + kj) + lj))] = zt9;\n      ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n      zt4 -= dth * ((dky * zt1) - (dkz * zt2));\n      zt5 -= dth * ((dkz * zt3) - (dkx * zt1));\n      zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n      bxyz[3 * ((j + kj) + lj)] = zt4;\n      bxyz[1 + (3 * ((j + kj) + lj))] = zt5;\n      bxyz[2 + (3 * ((j + kj) + lj))] = zt6;\n      wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n      zt1 = (-cimagf(exyz[2 + (3 * ((j + k1) + lj))])) + (crealf(exyz[2 + (3 * ((j + k1) + lj))]) * _Complex_I);\n      zt2 = (-cimagf(exyz[1 + (3 * ((j + k1) + lj))])) + (crealf(exyz[1 + (3 * ((j + k1) + lj))]) * _Complex_I);\n      zt3 = (-cimagf(exyz[3 * ((j + k1) + lj)])) + (crealf(exyz[3 * ((j + k1) + lj)]) * _Complex_I);\n      zt4 = bxyz[3 * ((j + k1) + lj)] + (dth * ((dky * zt1) + (dkz * zt2)));\n      zt5 = bxyz[1 + (3 * ((j + k1) + lj))] - (dth * ((dkz * zt3) - (dkx * zt1)));\n      zt6 = bxyz[2 + (3 * ((j + k1) + lj))] - (dth * ((dkx * zt2) + (dky * zt3)));\n      zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n      zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n      zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n      zt7 = (exyz[3 * ((j + k1) + lj)] - (cdt * ((dky * zt1) + (dkz * zt2)))) - (afdt * cu[3 * ((j + k1) + lj)]);\n      zt8 = (exyz[1 + (3 * ((j + k1) + lj))] + (cdt * ((dkz * zt3) - (dkx * zt1)))) - (afdt * cu[1 + (3 * ((j + k1) + lj))]);\n      zt9 = (exyz[2 + (3 * ((j + k1) + lj))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (3 * ((j + k1) + lj))]);\n      zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n      zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n      zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n      exyz[3 * ((j + k1) + lj)] = zt7;\n      exyz[1 + (3 * ((j + k1) + lj))] = zt8;\n      exyz[2 + (3 * ((j + k1) + lj))] = zt9;\n      ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n      zt4 += dth * ((dky * zt1) + (dkz * zt2));\n      zt5 -= dth * ((dkz * zt3) - (dkx * zt1));\n      zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n      bxyz[3 * ((j + k1) + lj)] = zt4;\n      bxyz[1 + (3 * ((j + k1) + lj))] = zt5;\n      bxyz[2 + (3 * ((j + k1) + lj))] = zt6;\n      wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n      zt1 = (-cimagf(exyz[2 + (3 * ((j + kj) + l1))])) + (crealf(exyz[2 + (3 * ((j + kj) + l1))]) * _Complex_I);\n      zt2 = (-cimagf(exyz[1 + (3 * ((j + kj) + l1))])) + (crealf(exyz[1 + (3 * ((j + kj) + l1))]) * _Complex_I);\n      zt3 = (-cimagf(exyz[3 * ((j + kj) + l1)])) + (crealf(exyz[3 * ((j + kj) + l1)]) * _Complex_I);\n      zt4 = bxyz[3 * ((j + kj) + l1)] - (dth * ((dky * zt1) + (dkz * zt2)));\n      zt5 = bxyz[1 + (3 * ((j + kj) + l1))] + (dth * ((dkz * zt3) + (dkx * zt1)));\n      zt6 = bxyz[2 + (3 * ((j + kj) + l1))] - (dth * ((dkx * zt2) - (dky * zt3)));\n      zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n      zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n      zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n      zt7 = (exyz[3 * ((j + kj) + l1)] + (cdt * ((dky * zt1) + (dkz * zt2)))) - (afdt * cu[3 * ((j + kj) + l1)]);\n      zt8 = (exyz[1 + (3 * ((j + kj) + l1))] - (cdt * ((dkz * zt3) + (dkx * zt1)))) - (afdt * cu[1 + (3 * ((j + kj) + l1))]);\n      zt9 = (exyz[2 + (3 * ((j + kj) + l1))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (3 * ((j + kj) + l1))]);\n      zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n      zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n      zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n      exyz[3 * ((j + kj) + l1)] = zt7;\n      exyz[1 + (3 * ((j + kj) + l1))] = zt8;\n      exyz[2 + (3 * ((j + kj) + l1))] = zt9;\n      ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n      zt4 -= dth * ((dky * zt1) + (dkz * zt2));\n      zt5 += dth * ((dkz * zt3) + (dkx * zt1));\n      zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n      bxyz[3 * ((j + kj) + l1)] = zt4;\n      bxyz[1 + (3 * ((j + kj) + l1))] = zt5;\n      bxyz[2 + (3 * ((j + kj) + l1))] = zt6;\n      wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n      zt1 = (-cimagf(exyz[2 + (3 * ((j + k1) + l1))])) + (crealf(exyz[2 + (3 * ((j + k1) + l1))]) * _Complex_I);\n      zt2 = (-cimagf(exyz[1 + (3 * ((j + k1) + l1))])) + (crealf(exyz[1 + (3 * ((j + k1) + l1))]) * _Complex_I);\n      zt3 = (-cimagf(exyz[3 * ((j + k1) + l1)])) + (crealf(exyz[3 * ((j + k1) + l1)]) * _Complex_I);\n      zt4 = bxyz[3 * ((j + k1) + l1)] + (dth * ((dky * zt1) - (dkz * zt2)));\n      zt5 = bxyz[1 + (3 * ((j + k1) + l1))] + (dth * ((dkz * zt3) + (dkx * zt1)));\n      zt6 = bxyz[2 + (3 * ((j + k1) + l1))] - (dth * ((dkx * zt2) + (dky * zt3)));\n      zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n      zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n      zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n      zt7 = (exyz[3 * ((j + k1) + l1)] - (cdt * ((dky * zt1) - (dkz * zt2)))) - (afdt * cu[3 * ((j + k1) + l1)]);\n      zt8 = (exyz[1 + (3 * ((j + k1) + l1))] - (cdt * ((dkz * zt3) + (dkx * zt1)))) - (afdt * cu[1 + (3 * ((j + k1) + l1))]);\n      zt9 = (exyz[2 + (3 * ((j + k1) + l1))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (3 * ((j + k1) + l1))]);\n      zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n      zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n      zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n      exyz[3 * ((j + k1) + l1)] = zt7;\n      exyz[1 + (3 * ((j + k1) + l1))] = zt8;\n      exyz[2 + (3 * ((j + k1) + l1))] = zt9;\n      ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n      zt4 += dth * ((dky * zt1) - (dkz * zt2));\n      zt5 += dth * ((dkz * zt3) + (dkx * zt1));\n      zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n      bxyz[3 * ((j + k1) + l1)] = zt4;\n      bxyz[1 + (3 * ((j + k1) + l1))] = zt5;\n      bxyz[2 + (3 * ((j + k1) + l1))] = zt6;\n      wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    }\n\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    afdt = adt * cimagf(ffc[kk + ll]);\n    zt1 = (-cimagf(exyz[2 + (3 * (kj + lj))])) + (crealf(exyz[2 + (3 * (kj + lj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (kj + lj))])) + (crealf(exyz[1 + (3 * (kj + lj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (kj + lj)])) + (crealf(exyz[3 * (kj + lj)]) * _Complex_I);\n    zt4 = bxyz[3 * (kj + lj)] - (dth * ((dky * zt1) - (dkz * zt2)));\n    zt5 = bxyz[1 + (3 * (kj + lj))] - (dth * (dkz * zt3));\n    zt6 = bxyz[2 + (3 * (kj + lj))] + (dth * (dky * zt3));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (kj + lj)] + (cdt * ((dky * zt1) - (dkz * zt2)))) - (afdt * cu[3 * (kj + lj)]);\n    zt8 = (exyz[1 + (3 * (kj + lj))] + (cdt * (dkz * zt3))) - (afdt * cu[1 + (3 * (kj + lj))]);\n    zt9 = (exyz[2 + (3 * (kj + lj))] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * (kj + lj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (kj + lj)] = zt7;\n    exyz[1 + (3 * (kj + lj))] = zt8;\n    exyz[2 + (3 * (kj + lj))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * ((dky * zt1) - (dkz * zt2));\n    zt5 -= dth * (dkz * zt3);\n    zt6 += dth * (dky * zt3);\n    bxyz[3 * (kj + lj)] = zt4;\n    bxyz[1 + (3 * (kj + lj))] = zt5;\n    bxyz[2 + (3 * (kj + lj))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * (k1 + lj)] = zero;\n    bxyz[1 + (3 * (k1 + lj))] = zero;\n    bxyz[2 + (3 * (k1 + lj))] = zero;\n    exyz[3 * (k1 + lj)] = zero;\n    exyz[1 + (3 * (k1 + lj))] = zero;\n    exyz[2 + (3 * (k1 + lj))] = zero;\n    zt1 = (-cimagf(exyz[2 + (3 * (kj + l1))])) + (crealf(exyz[2 + (3 * (kj + l1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (kj + l1))])) + (crealf(exyz[1 + (3 * (kj + l1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (kj + l1)])) + (crealf(exyz[3 * (kj + l1)]) * _Complex_I);\n    zt4 = bxyz[3 * (kj + l1)] - (dth * ((dky * zt1) + (dkz * zt2)));\n    zt5 = bxyz[1 + (3 * (kj + l1))] + (dth * (dkz * zt3));\n    zt6 = bxyz[2 + (3 * (kj + l1))] + (dth * (dky * zt3));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (kj + l1)] + (cdt * ((dky * zt1) + (dkz * zt2)))) - (afdt * cu[3 * (kj + l1)]);\n    zt8 = (exyz[1 + (3 * (kj + l1))] - (cdt * (dkz * zt3))) - (afdt * cu[1 + (3 * (kj + l1))]);\n    zt9 = (exyz[2 + (3 * (kj + l1))] - (cdt * (dky * zt3))) - (afdt * cu[2 + (3 * (kj + l1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (kj + l1)] = zt7;\n    exyz[1 + (3 * (kj + l1))] = zt8;\n    exyz[2 + (3 * (kj + l1))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * ((dky * zt1) + (dkz * zt2));\n    zt5 += dth * (dkz * zt3);\n    zt6 += dth * (dky * zt3);\n    bxyz[3 * (kj + l1)] = zt4;\n    bxyz[1 + (3 * (kj + l1))] = zt5;\n    bxyz[2 + (3 * (kj + l1))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * (k1 + l1)] = zero;\n    bxyz[1 + (3 * (k1 + l1))] = zero;\n    bxyz[2 + (3 * (k1 + l1))] = zero;\n    exyz[3 * (k1 + l1)] = zero;\n    exyz[1 + (3 * (k1 + l1))] = zero;\n    exyz[2 + (3 * (k1 + l1))] = zero;\n  }\n\n  k1 = nxvh * nyh;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + ll]);\n    zt1 = (-cimagf(exyz[2 + (3 * (j + lj))])) + (crealf(exyz[2 + (3 * (j + lj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + lj))])) + (crealf(exyz[1 + (3 * (j + lj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + lj)])) + (crealf(exyz[3 * (j + lj)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + lj)] + (dth * (dkz * zt2));\n    zt5 = bxyz[1 + (3 * (j + lj))] - (dth * ((dkz * zt3) - (dkx * zt1)));\n    zt6 = bxyz[2 + (3 * (j + lj))] - (dth * (dkx * zt2));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + lj)] - (cdt * (dkz * zt2))) - (afdt * cu[3 * (j + lj)]);\n    zt8 = (exyz[1 + (3 * (j + lj))] + (cdt * ((dkz * zt3) - (dkx * zt1)))) - (afdt * cu[1 + (3 * (j + lj))]);\n    zt9 = (exyz[2 + (3 * (j + lj))] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (3 * (j + lj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + lj)] = zt7;\n    exyz[1 + (3 * (j + lj))] = zt8;\n    exyz[2 + (3 * (j + lj))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 += dth * (dkz * zt2);\n    zt5 -= dth * ((dkz * zt3) - (dkx * zt1));\n    zt6 -= dth * (dkx * zt2);\n    bxyz[3 * (j + lj)] = zt4;\n    bxyz[1 + (3 * (j + lj))] = zt5;\n    bxyz[2 + (3 * (j + lj))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * ((j + k1) + lj)] = zero;\n    bxyz[1 + (3 * ((j + k1) + lj))] = zero;\n    bxyz[2 + (3 * ((j + k1) + lj))] = zero;\n    exyz[3 * ((j + k1) + lj)] = zero;\n    exyz[1 + (3 * ((j + k1) + lj))] = zero;\n    exyz[2 + (3 * ((j + k1) + lj))] = zero;\n    zt1 = (-cimagf(exyz[2 + (3 * (j + l1))])) + (crealf(exyz[2 + (3 * (j + l1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (3 * (j + l1))])) + (crealf(exyz[1 + (3 * (j + l1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[3 * (j + l1)])) + (crealf(exyz[3 * (j + l1)]) * _Complex_I);\n    zt4 = bxyz[3 * (j + l1)] - (dth * (dkz * zt2));\n    zt5 = bxyz[1 + (3 * (j + l1))] + (dth * ((dkz * zt3) + (dkx * zt1)));\n    zt6 = bxyz[2 + (3 * (j + l1))] - (dth * (dkx * zt2));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[3 * (j + l1)] + (cdt * (dkz * zt2))) - (afdt * cu[3 * (j + l1)]);\n    zt8 = (exyz[1 + (3 * (j + l1))] - (cdt * ((dkz * zt3) + (dkx * zt1)))) - (afdt * cu[1 + (3 * (j + l1))]);\n    zt9 = (exyz[2 + (3 * (j + l1))] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (3 * (j + l1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[3 * (j + l1)] = zt7;\n    exyz[1 + (3 * (j + l1))] = zt8;\n    exyz[2 + (3 * (j + l1))] = zt9;\n    ws += anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    zt4 -= dth * (dkz * zt2);\n    zt5 += dth * ((dkz * zt3) + (dkx * zt1));\n    zt6 -= dth * (dkx * zt2);\n    bxyz[3 * (j + l1)] = zt4;\n    bxyz[1 + (3 * (j + l1))] = zt5;\n    bxyz[2 + (3 * (j + l1))] = zt6;\n    wp += anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    bxyz[3 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    exyz[3 * ((j + k1) + l1)] = zero;\n    exyz[1 + (3 * ((j + k1) + l1))] = zero;\n    exyz[2 + (3 * ((j + k1) + l1))] = zero;\n  }\n\n  afdt = adt * cimagf(ffc[ll]);\n  zt2 = (-cimagf(exyz[1 + (3 * lj)])) + (crealf(exyz[1 + (3 * lj)]) * _Complex_I);\n  zt3 = (-cimagf(exyz[3 * lj])) + (crealf(exyz[3 * lj]) * _Complex_I);\n  zt4 = bxyz[3 * lj] + (dth * (dkz * zt2));\n  zt5 = bxyz[1 + (3 * lj)] - (dth * (dkz * zt3));\n  zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exyz[3 * lj] - (cdt * (dkz * zt2))) - (afdt * cu[3 * lj]);\n  zt8 = (exyz[1 + (3 * lj)] + (cdt * (dkz * zt3))) - (afdt * cu[1 + (3 * lj)]);\n  zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exyz[3 * lj] = zt7;\n  exyz[1 + (3 * lj)] = zt8;\n  exyz[2 + (3 * lj)] = zero;\n  ws += anorm * ((zt7 * conjf(zt7)) + (zt8 * conjf(zt8)));\n  zt4 += dth * (dkz * zt2);\n  zt5 -= dth * (dkz * zt3);\n  bxyz[3 * lj] = zt4;\n  bxyz[1 + (3 * lj)] = zt5;\n  bxyz[2 + (3 * lj)] = zero;\n  wp += anorm * ((zt4 * conjf(zt4)) + (zt5 * conjf(zt5)));\n  bxyz[3 * (k1 + lj)] = zero;\n  bxyz[1 + (3 * (k1 + lj))] = zero;\n  bxyz[2 + (3 * (k1 + lj))] = zero;\n  exyz[3 * (k1 + lj)] = zero;\n  exyz[1 + (3 * (k1 + lj))] = zero;\n  exyz[2 + (3 * (k1 + lj))] = zero;\n  bxyz[3 * l1] = zero;\n  bxyz[1 + (3 * l1)] = zero;\n  bxyz[2 + (3 * l1)] = zero;\n  exyz[3 * l1] = zero;\n  exyz[1 + (3 * l1)] = zero;\n  exyz[2 + (3 * l1)] = zero;\n  bxyz[3 * (k1 + l1)] = zero;\n  bxyz[1 + (3 * (k1 + l1))] = zero;\n  bxyz[2 + (3 * (k1 + l1))] = zero;\n  exyz[3 * (k1 + l1)] = zero;\n  exyz[1 + (3 * (k1 + l1))] = zero;\n  exyz[2 + (3 * (k1 + l1))] = zero;\n  sum1 += ws;\n  sum2 += wp;\n}\n\n", "pragma": "omp for nowait private(j,k,l,k1,l1,ll,lj,kk,kj,dkz,dky,dkx,afdt,zt1,zt2,zt3,zt4,zt5, zt6,zt7,zt8,zt9,ws,wp) reduction(+:sum1,sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/19"}
{"code": "for (i = 0; i < p->get_numNodes(); i++)\n{\n  G->begin[i] = edg;\n  for (j = 0; j < p->get_numNodes(); j++)\n  {\n    if ((p->get_selfloop() == false) && (i == j))\n      continue;\n\n    int idx = (comm[i] * k) + comm[j];\n    double probability = edgeProbabilityMatrix[idx];\n    double generated_value = stream2->sprng();\n    if (probability > generated_value)\n    {\n      if (p->get_weighted())\n      {\n        int w = generateweight(*p, stream2);\n        G->weights[edg] = w;\n      }\n\n      G->node_idx[edg] = j;\n      edg++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jkrishnavs/OpenMPGraphAlgorithms/graphGenerator/graphgenerator/1"}
{"code": "for (i = 0; i < 20; ++i)\n{\n  dpt *= dt;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_reduction/11"}
{"code": "for (i = 0; i < num_edges; i++)\n{\n  src = edgeListmem->edges_array_src[i];\n  dest = edgeListmem->edges_array_dest[i];\n  if (symmetric)\n  {\n    edgeList->edges_array_src[i] = src;\n    edgeList->edges_array_dest[i] = dest;\n  }\n  else\n  {\n    edgeList->edges_array_src[i] = src;\n    edgeList->edges_array_dest[i] = dest;\n  }\n\n}\n\n", "pragma": "omp parallel for private(src,dest)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/6"}
{"code": "for (int i = 0; i < n_neighbor; i++)\n{\n  int neighbor = neighbors[i];\n  if (U[neighbor] > (C[node_id] + getWeight(gr, node_id, neighbor)))\n  {\n    U[i] = C[node_id] + getWeight(gr, node_id, neighbor);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/6"}
{"code": "for (long z = 0; z < contRelationOk; z++)\n{\n  int64_t temp = listExponentOk_mod2[z][row_i];\n  listExponentOk_mod2[z][row_i] = listExponentOk_mod2[z][cont_rig];\n  listExponentOk_mod2[z][cont_rig] = temp;\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_no_gmp/3"}
{"code": "for (uint64_t ii = start_chunk; ii < end_chunk; ++ii)\n{\n  my_keys[ii] = pcg32_boundedrand_r(&rng, MAX_KEY_VAL);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    matrix1[i][j] = rand();\n    matrix2[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Joseph-18-analyst/Large_Matrix_Multiplication_OpenMP/Efficient_matrix_Multiplication/1"}
{"code": "for (int i = 1; i < 15999; i++)\n{\n  b[i] = ((a[i - 1] + a[i]) + a[i + 1]) / 3.0;\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic, chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanTrofimov/parallel-programming/code/iterable/4"}
{"code": "for (int h = 0; h < tamlinha; h++)\n{\n  temp[h] = matriz[linha][h];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Landecrispim/Metodo-de-Gauss-cpp-OpenMP/guss/1"}
{"code": "for (int i = 0; i < length; i++)\n{\n  array[i] = rand() % 20;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex10/0"}
{"code": "for (i_imopVar88 = 0; i_imopVar88 < grid_points[0]; i_imopVar88++)\n{\n  xi_imopVar95 = ((double) i_imopVar88) * dnxm1;\n  for (j_imopVar89 = 0; j_imopVar89 < grid_points[1]; j_imopVar89++)\n  {\n    eta_imopVar96 = ((double) j_imopVar89) * dnym1;\n    for (k_imopVar90 = 0; k_imopVar90 < grid_points[2]; k_imopVar90++)\n    {\n      zeta_imopVar97 = ((double) k_imopVar90) * dnzm1;\n      for (ix_imopVar92 = 0; ix_imopVar92 < 2; ix_imopVar92++)\n      {\n        double *_imopVarPre191;\n        double _imopVarPre192;\n        _imopVarPre191 = &Pface_imopVar98[ix_imopVar92][0][0];\n        _imopVarPre192 = (double) ix_imopVar92;\n        exact_solution(_imopVarPre192, eta_imopVar96, zeta_imopVar97, _imopVarPre191);\n      }\n\n      for (iy_imopVar93 = 0; iy_imopVar93 < 2; iy_imopVar93++)\n      {\n        double *_imopVarPre195;\n        double _imopVarPre196;\n        _imopVarPre195 = &Pface_imopVar98[iy_imopVar93][1][0];\n        _imopVarPre196 = (double) iy_imopVar93;\n        exact_solution(xi_imopVar95, _imopVarPre196, zeta_imopVar97, _imopVarPre195);\n      }\n\n      for (iz_imopVar94 = 0; iz_imopVar94 < 2; iz_imopVar94++)\n      {\n        double *_imopVarPre199;\n        double _imopVarPre200;\n        _imopVarPre199 = &Pface_imopVar98[iz_imopVar94][2][0];\n        _imopVarPre200 = (double) iz_imopVar94;\n        exact_solution(xi_imopVar95, eta_imopVar96, _imopVarPre200, _imopVarPre199);\n      }\n\n      for (m_imopVar91 = 0; m_imopVar91 < 5; m_imopVar91++)\n      {\n        Pxi_imopVar99 = (xi_imopVar95 * Pface_imopVar98[1][0][m_imopVar91]) + ((1.0 - xi_imopVar95) * Pface_imopVar98[0][0][m_imopVar91]);\n        Peta_imopVar100 = (eta_imopVar96 * Pface_imopVar98[1][1][m_imopVar91]) + ((1.0 - eta_imopVar96) * Pface_imopVar98[0][1][m_imopVar91]);\n        Pzeta_imopVar101 = (zeta_imopVar97 * Pface_imopVar98[1][2][m_imopVar91]) + ((1.0 - zeta_imopVar97) * Pface_imopVar98[0][2][m_imopVar91]);\n        u[i_imopVar88][j_imopVar89][k_imopVar90][m_imopVar91] = (((((Pxi_imopVar99 + Peta_imopVar100) + Pzeta_imopVar101) - (Pxi_imopVar99 * Peta_imopVar100)) - (Pxi_imopVar99 * Pzeta_imopVar101)) - (Peta_imopVar100 * Pzeta_imopVar101)) + ((Pxi_imopVar99 * Peta_imopVar100) * Pzeta_imopVar101);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/47"}
{"code": "for (int i = 0; i < m; i++)\n  omp_init_lock(&Lock[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/BucketSort/5"}
{"code": "for (iouter = 1; iouter <= n; iouter++)\n{\n  nzv = nonzer;\n  int *_imopVarPre193;\n  int *_imopVarPre194;\n  _imopVarPre193 = &colidx[n];\n  _imopVarPre194 = &colidx[0];\n  sprnvc(n, nzv, v, iv, _imopVarPre194, _imopVarPre193);\n  int *_imopVarPre196;\n  _imopVarPre196 = &nzv;\n  vecset(n, v, iv, _imopVarPre196, iouter, 0.5);\n  for (ivelt = 1; ivelt <= nzv; ivelt++)\n  {\n    jcol = iv[ivelt];\n    int _imopVarPre198;\n    _imopVarPre198 = jcol >= firstcol;\n    if (_imopVarPre198)\n    {\n      _imopVarPre198 = jcol <= lastcol;\n    }\n\n    if (_imopVarPre198)\n    {\n      scale = size * v[ivelt];\n      for (ivelt1 = 1; ivelt1 <= nzv; ivelt1++)\n      {\n        irow = iv[ivelt1];\n        int _imopVarPre200;\n        _imopVarPre200 = irow >= firstrow;\n        if (_imopVarPre200)\n        {\n          _imopVarPre200 = irow <= lastrow;\n        }\n\n        if (_imopVarPre200)\n        {\n          nnza = nnza + 1;\n          if (nnza > nz)\n          {\n            printf(\"Space for matrix elements exceeded in makea\\n\");\n            printf(\"nnza, nzmax = %d, %d\\n\", nnza, nz);\n            printf(\"iouter = %d\\n\", iouter);\n            exit(1);\n          }\n\n          acol[nnza] = jcol;\n          arow[nnza] = irow;\n          aelt[nnza] = v[ivelt1] * scale;\n        }\n\n      }\n\n    }\n\n  }\n\n  size = size * ratio;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/21"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    m[i][j] = 4;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp2/ejer10/pmv-OPM-10/3"}
{"code": "for (int i = 0; i < D; ++i)\n{\n  dist += (key->dim[i] - curr[i]) * (key->dim[i] - curr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/3"}
{"code": "for (int j = 0; j < 12; j++)\n{\n  if (aligned_result[j].result->maxProduct > result->maxProduct)\n  {\n    result->maxProduct = aligned_result[j].result->maxProduct;\n    result->idx_max = aligned_result[j].result->idx_max;\n  }\n\n  if (aligned_result[j].result->minProduct < result->minProduct)\n  {\n    result->minProduct = aligned_result[j].result->minProduct;\n    result->idx_min = aligned_result[j].result->idx_min;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/agujjar2206/OpenMP/openMp/2"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  if ((((i * n) + j) % 20) == 0)\n    fprintf(POLYBENCH_DUMP_TARGET, \"\\n\");\n\n  fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/jacobi-2d/jacobi-2d/2"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  x = drandom();\n  y = drandom();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "omp for reduction(+:Ncirc) private(x,y,test)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/pi_monte_carlo/Solutions/pi_mc_par/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n  for (j = 0; j < 64; j++)\n  {\n    if (percentDiff(A[(i * 64) + j], A_outputFromGpu[(i * 64) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GRAMSCHM/gramschmidt/24"}
{"code": "for (i = 1; i <= n; i++)\n{\n  t1 = ((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * x;\n  x1 = (int) t1;\n  x2 = x - (((((((((((((((((((((((2.0 * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * x1);\n  t1 = (a1 * x2) + (a2 * x1);\n  t2 = (int) (((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * t1);\n  z = t1 - (((((((((((((((((((((((2.0 * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * t2);\n  t3 = (((((((((((((((((((((((2.0 * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * z) + (a2 * x2);\n  t4 = (int) ((((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * ((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5)) * t3);\n  x = t3 - ((((((((((((((((((((((((2.0 * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * ((((((((((((((((((((((2.0 * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0) * 2.0)) * t4);\n  y[i] = (((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * ((((((((((((((((((((((0.5 * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5) * 0.5)) * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/EP/ep_single/1"}
{"code": "for (unsigned int it = start; it < end; it += 1)\n{\n  update_acceleration(it, nb_body);\n  update_velocity(it);\n  update_position(it);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(nb_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/mpi+openmp/src/nbody_mpi+openmp/3"}
{"code": "for (gridpoint[0] = lower[0], u = 0; u < tot_ev_per_dim[0]; gridpoint[0] += dx[0], u++)\n{\n  int HalfPosition = ((gridpoint[0] - x0[0]) / dx[0]) * pdf->pdfcumsize[0];\n  __assume_aligned(densValues, 64);\n  __assume_aligned(densPosition, 64);\n  #pragma simd private(PCdot,temp) assert\n  for (v = 0; v < tot_ev_per_dim[1]; v++)\n  {\n    PCdot[0] = (eigenvectors->me[0][0] * gridpoint[0]) + (eigenvectors->me[0][1] * (lower[1] + (dx[1] * v)));\n    PCdot[1] = (eigenvectors->me[1][0] * gridpoint[0]) + (eigenvectors->me[1][1] * (lower[1] + (dx[1] * v)));\n    temp = (((PC[0] - PCdot[0]) * (PC[0] - PCdot[0])) + ((PC[1] - PCdot[1]) * (PC[1] - PCdot[1]))) / h2;\n    densPosition[v] = HalfPosition + ((((lower[1] + (dx[1] * v)) - x0[1]) / dx[1]) * pdf->pdfcumsize[1]);\n    densValues[v] = (((0.5 / cd) * (2 + 2.)) * (1. - temp)) * (fabs(temp) < 1.);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/14"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * (((((-4.0) * u[i_imopVar110][j_imopVar111 - 1][k_imopVar112][m_imopVar113]) + (6.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113])) - (4.0 * u[i_imopVar110][j_imopVar111 + 1][k_imopVar112][m_imopVar113])) + u[i_imopVar110][j_imopVar111 + 2][k_imopVar112][m_imopVar113]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/17"}
{"code": "for (j = 0; j < total_grid_elem; j++)\n{\n  sum += A[j];\n}\n\n", "pragma": "omp for reduction(+:sum) private(j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlessandroPiccolo/poisson-openmp-solver/source/poisson_parallel/5"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j][k - 1][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/120"}
{"code": "for (size_t i = 1; i < (N + 1); i++)\n{\n  u_mat(i, 0) = g(i * h, 0);\n  u_mat(i, N + 1) = g(i * h, (N + 1) * h);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/second/functions/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  printf(\"%d \", cols[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Dept-Labs/Parallel-Computing/Lab4/sum/4"}
{"code": "for (i = 0; i < numImg; i++)\n  fprintf(fptr, \"|%d\\t |%d\\t  |\\n\", i, cluster_id[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m <= 2; m += 1)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    for (m = 0; m <= 2; m += 1)\n    {\n      rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i][j1][k];\n    for (m = 0; m <= 2; m += 1)\n    {\n      rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,i,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/187"}
{"code": "for (i = 0; i < (n + 2); i++)\n{\n  for (j = 0; j < (n + 2); j++)\n  {\n    x = (-1) + (h * i);\n    y = (-1) + (h * j);\n    f[(i * (n + 2)) + j] = (((2 * 3.14159265358979323846) * 3.14159265358979323846) * sin(3.14159265358979323846 * x)) * sin(3.14159265358979323846 * y);\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terkelbo/OpenMP-Poisson-Problem/src/inittools_ccnuma/3"}
{"code": "for (i = 0; i < dim_cpu.space_elem; i = i + 1)\n{\n  fv_cpu[i].v = 0;\n  fv_cpu[i].x = 0;\n  fv_cpu[i].y = 0;\n  fv_cpu[i].z = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/lavaMD/OneFile/6"}
{"code": "for (kk = 0; kk < dim; kk++)\n{\n  for (jj = 0; jj < dim; jj++)\n  {\n    for (ii = 0; ii < dim; ii++)\n    {\n      uniqueid = index2unique(ii, jj, kk);\n      switch (uniqueid)\n      {\n        case 7:\n          value = evaluate_array3d(array3d, N, ii / 2, jj / 2, kk / 2);\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 6:\n          value1 = evaluate_array3d(array3d, N, (ii - 1) / 2, jj / 2, kk / 2);\n          value2 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, jj / 2, kk / 2);\n          value = (value1 + value2) / 2.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 5:\n          value1 = evaluate_array3d(array3d, N, ii / 2, (jj - 1) / 2, kk / 2);\n          value2 = evaluate_array3d(array3d, N, ii / 2, ((jj - 1) / 2) + 1, kk / 2);\n          value = (value1 + value2) / 2.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 4:\n          value1 = evaluate_array3d(array3d, N, (ii - 1) / 2, (jj - 1) / 2, kk / 2);\n          value2 = evaluate_array3d(array3d, N, (ii - 1) / 2, ((jj - 1) / 2) + 1, kk / 2);\n          value3 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, (jj - 1) / 2, kk / 2);\n          value4 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, ((jj - 1) / 2) + 1, kk / 2);\n          value = (((value1 + value2) + value3) + value4) / 4.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 3:\n          value1 = evaluate_array3d(array3d, N, ii / 2, jj / 2, (kk - 1) / 2);\n          value2 = evaluate_array3d(array3d, N, ii / 2, jj / 2, ((kk - 1) / 2) + 1);\n          value = (value1 + value2) / 2.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 2:\n          value1 = evaluate_array3d(array3d, N, (ii - 1) / 2, jj / 2, (kk - 1) / 2);\n          value2 = evaluate_array3d(array3d, N, (ii - 1) / 2, jj / 2, ((kk - 1) / 2) + 1);\n          value3 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, jj / 2, (kk - 1) / 2);\n          value4 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, jj / 2, ((kk - 1) / 2) + 1);\n          value = (((value1 + value2) + value3) + value4) / 4.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 1:\n          value1 = evaluate_array3d(array3d, N, ii / 2, (jj - 1) / 2, (kk - 1) / 2);\n          value2 = evaluate_array3d(array3d, N, ii / 2, (jj - 1) / 2, ((kk - 1) / 2) + 1);\n          value3 = evaluate_array3d(array3d, N, ii / 2, ((jj - 1) / 2) + 1, (kk - 1) / 2);\n          value4 = evaluate_array3d(array3d, N, ii / 2, ((jj - 1) / 2) + 1, ((kk - 1) / 2) + 1);\n          value = (((value1 + value2) + value3) + value4) / 4.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n        case 0:\n          value1 = evaluate_array3d(array3d, N, (ii - 1) / 2, (jj - 1) / 2, (kk - 1) / 2);\n          value2 = evaluate_array3d(array3d, N, (ii - 1) / 2, (jj - 1) / 2, ((kk - 1) / 2) + 1);\n          value3 = evaluate_array3d(array3d, N, (ii - 1) / 2, ((jj - 1) / 2) + 1, (kk - 1) / 2);\n          value4 = evaluate_array3d(array3d, N, (ii - 1) / 2, ((jj - 1) / 2) + 1, ((kk - 1) / 2) + 1);\n          value = (((value1 + value2) + value3) + value4) / 8.;\n          value1 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, (jj - 1) / 2, (kk - 1) / 2);\n          value2 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, (jj - 1) / 2, ((kk - 1) / 2) + 1);\n          value3 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, ((jj - 1) / 2) + 1, (kk - 1) / 2);\n          value4 = evaluate_array3d(array3d, N, ((ii - 1) / 2) + 1, ((jj - 1) / 2) + 1, ((kk - 1) / 2) + 1);\n          value += (((value1 + value2) + value3) + value4) / 8.;\n          fill_array3d(array3d_new, N_new, ii, jj, kk, value);\n          break;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(ii, jj, uniqueid, value, value1, value2, value3, value4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/prolongation3d/0"}
{"code": "for (int j = 0; j < numgrps; j++)\n{\n  varmat.col(j) *= sum(tmp.subvec(start(j), start(j + 1) - 1)) / denom(j);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, nthr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harveybarnhard/looperr/src/loo_linear/3"}
{"code": "for (int gid = 0; gid < elemsInBlock; gid++)\n  C0[crtIdx + gid] = A0[crtIdx + gid] + (scalar * B0[crtIdx + gid]);\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(blockSize) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/triad-omp/triad/2"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  for (int k = 0; k < CVT_INT(m_nSoilLyrs[i]); k++)\n  {\n    float wt1 = 0.f;\n    float conv_wt = 0.f;\n    wt1 = (m_soilBD[i][k] * m_soilThk[i][k]) * 0.01f;\n    conv_wt = 1.e6f * wt1;\n    m_conv_wt[i][k] = conv_wt;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NUTR_TF/Nutrient_Transformation/0"}
{"code": "for (i = 0; i < NGRUPOS; i++)\n{\n  for (j = 0; j < (NCAR + 1); j++)\n  {\n    additions[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for private(i, j) schedule(dynamic,2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/gengrupos_p/0"}
{"code": "for (int ii = 0; ii < params.ny; ii++)\n{\n  for (int jj = 0; jj < params.nx; jj++)\n  {\n    index = (ii * params.nx) + jj;\n    int y_n = (ii + 1) % params.ny;\n    int x_e = (jj + 1) % params.nx;\n    int y_s = (ii == 0) ? ((ii + params.ny) - 1) : (ii - 1);\n    int x_w = (jj == 0) ? ((jj + params.nx) - 1) : (jj - 1);\n    tmp_cells[(ii * params.nx) + jj].speeds[0] = cells[index].speeds[0];\n    tmp_cells[(ii * params.nx) + x_e].speeds[1] = cells[index].speeds[1];\n    tmp_cells[(y_n * params.nx) + jj].speeds[2] = cells[index].speeds[2];\n    tmp_cells[(ii * params.nx) + x_w].speeds[3] = cells[index].speeds[3];\n    tmp_cells[(y_s * params.nx) + jj].speeds[4] = cells[index].speeds[4];\n    tmp_cells[(y_n * params.nx) + x_e].speeds[5] = cells[index].speeds[5];\n    tmp_cells[(y_n * params.nx) + x_w].speeds[6] = cells[index].speeds[6];\n    tmp_cells[(y_s * params.nx) + x_w].speeds[7] = cells[index].speeds[7];\n    tmp_cells[(y_s * params.nx) + x_e].speeds[8] = cells[index].speeds[8];\n  }\n\n}\n\n", "pragma": "omp for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk.pomp/0"}
{"code": "for (int i = 0; i < div; i++)\n  integral += paralel_integral(xmin + (i * delta), xmin + ((i + 1) * delta), n, i, div);\n\n", "pragma": "        #pragma omp parallel for reduction(+: integral) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joaocassianox7x/Parallel_Integral/paralel_integral/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  wcoefs[i] = xcoefs[i];\n}\n\n", "pragma": "      \t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gadube/simple_openmp_examples/cg-solve/cgsolve_omp/3"}
{"code": "for (i2 = 1; i2 < (n2 - 1); i2++)\n{\n  for (i1 = 1; i1 < (n1 - 1); i1++)\n  {\n    s = s + pow(or[(((i3 * n2) * n1) + (i2 * n1)) + i1], 2.0);\n    a = fabs(or[(((i3 * n2) * n1) + (i2 * n1)) + i1]);\n    temp = max(temp, a);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:s) reduction(max:temp) private(i2,i1) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/17"}
{"code": "for (int x = 0; x < len; x++)\n{\n  int n = chars[len - (x + 1)] - '0';\n  sum = sum + powInt(n, x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atbender/nbodies-openmp/main/3"}
{"code": "for (int i = 0; i < 2; ++i)\n{\n  int ID = omp_get_thread_num();\n  printf(\"hello,%d\\n\", ID);\n  printf(\"world,%d\\n\", ID);\n}\n\n", "pragma": "\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lumeng16/OpenMPstudy/Basic/runtime/0"}
{"code": "for (int i = 1; i < NUM_PI; i++)\n{\n  sendsum += sendsize[i - 1];\n  MPI_Recv(outmsg[0] + sendsum, sendsize[i], MPI_BYTE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n  MPI_Recv(&elapsedtime[i], 1, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ReinhartC/Parallel-RSA-on-Raspberry-Pi/Builds/LB_OMP_MPI/RSA_LB_OMP_MPI/13"}
{"code": "for (int y = 0; y < wym; y++)\n{\n  for (int x = 0; x < row_per_proc; x++)\n  {\n    smallslice[y + (x * wym)] = lastslice[y][x];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aenyewedien/GameOfLife/game/7"}
{"code": "for (i = 0; i < VECLEN; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/ParallelRegionOrphanedDirective/1"}
{"code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  m = part[1 + (idimp * j)];\n  n = n / mx;\n  m = m / my;\n  m = n + (mx1 * m);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[i + (idimp * (ip + (nppmx * m)))] = part[i + (idimp * j)];\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/29"}
{"code": "for (i = 1; i < (3000 - 1); i++)\n  for (j = 0; j < 3000; j++)\n{\n  if ((j != 0) && (j != (3000 - 1)))\n    result_image[i][j] = data[r];\n\n  r++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/8"}
{"code": "for (int i = atoi(argv[1]); i <= atoi(argv[2]); i++)\n{\n  char str[1024];\n  sprintf(str, \"CI_vis %i\", i);\n  system(str);\n  (((cout << i) << \" \") << str) << endl;\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/sample_projects/cancer_immune/scripts/CI_script/0"}
{"code": "for (int j = 0; j < Time_cell; ++j)\n{\n  for (int i = 0; i < Freq_cell; ++i)\n  {\n    fprintf(map_fp, \"%f,\", hsa_map[j][i]);\n  }\n\n  fprintf(map_fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/46"}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], ARCH_SIZE))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC_fmt_plug/2"}
{"code": "for (i = 0, pi = 0.0; i < NUM_THREADS; i++)\n  pi += sum[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daramgineer/OpenMP_study/Source/for_loop_compare/2"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      tmp1 = dt * tz1;\n      tmp2 = dt * tz2;\n      lhs[i][j][k][AA][0][0] = (((-tmp2) * fjac[i][j][k - 1][0][0]) - (tmp1 * njac[i][j][k - 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][AA][0][1] = ((-tmp2) * fjac[i][j][k - 1][0][1]) - (tmp1 * njac[i][j][k - 1][0][1]);\n      lhs[i][j][k][AA][0][2] = ((-tmp2) * fjac[i][j][k - 1][0][2]) - (tmp1 * njac[i][j][k - 1][0][2]);\n      lhs[i][j][k][AA][0][3] = ((-tmp2) * fjac[i][j][k - 1][0][3]) - (tmp1 * njac[i][j][k - 1][0][3]);\n      lhs[i][j][k][AA][0][4] = ((-tmp2) * fjac[i][j][k - 1][0][4]) - (tmp1 * njac[i][j][k - 1][0][4]);\n      lhs[i][j][k][AA][1][0] = ((-tmp2) * fjac[i][j][k - 1][1][0]) - (tmp1 * njac[i][j][k - 1][1][0]);\n      lhs[i][j][k][AA][1][1] = (((-tmp2) * fjac[i][j][k - 1][1][1]) - (tmp1 * njac[i][j][k - 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][AA][1][2] = ((-tmp2) * fjac[i][j][k - 1][1][2]) - (tmp1 * njac[i][j][k - 1][1][2]);\n      lhs[i][j][k][AA][1][3] = ((-tmp2) * fjac[i][j][k - 1][1][3]) - (tmp1 * njac[i][j][k - 1][1][3]);\n      lhs[i][j][k][AA][1][4] = ((-tmp2) * fjac[i][j][k - 1][1][4]) - (tmp1 * njac[i][j][k - 1][1][4]);\n      lhs[i][j][k][AA][2][0] = ((-tmp2) * fjac[i][j][k - 1][2][0]) - (tmp1 * njac[i][j][k - 1][2][0]);\n      lhs[i][j][k][AA][2][1] = ((-tmp2) * fjac[i][j][k - 1][2][1]) - (tmp1 * njac[i][j][k - 1][2][1]);\n      lhs[i][j][k][AA][2][2] = (((-tmp2) * fjac[i][j][k - 1][2][2]) - (tmp1 * njac[i][j][k - 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][AA][2][3] = ((-tmp2) * fjac[i][j][k - 1][2][3]) - (tmp1 * njac[i][j][k - 1][2][3]);\n      lhs[i][j][k][AA][2][4] = ((-tmp2) * fjac[i][j][k - 1][2][4]) - (tmp1 * njac[i][j][k - 1][2][4]);\n      lhs[i][j][k][AA][3][0] = ((-tmp2) * fjac[i][j][k - 1][3][0]) - (tmp1 * njac[i][j][k - 1][3][0]);\n      lhs[i][j][k][AA][3][1] = ((-tmp2) * fjac[i][j][k - 1][3][1]) - (tmp1 * njac[i][j][k - 1][3][1]);\n      lhs[i][j][k][AA][3][2] = ((-tmp2) * fjac[i][j][k - 1][3][2]) - (tmp1 * njac[i][j][k - 1][3][2]);\n      lhs[i][j][k][AA][3][3] = (((-tmp2) * fjac[i][j][k - 1][3][3]) - (tmp1 * njac[i][j][k - 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][AA][3][4] = ((-tmp2) * fjac[i][j][k - 1][3][4]) - (tmp1 * njac[i][j][k - 1][3][4]);\n      lhs[i][j][k][AA][4][0] = ((-tmp2) * fjac[i][j][k - 1][4][0]) - (tmp1 * njac[i][j][k - 1][4][0]);\n      lhs[i][j][k][AA][4][1] = ((-tmp2) * fjac[i][j][k - 1][4][1]) - (tmp1 * njac[i][j][k - 1][4][1]);\n      lhs[i][j][k][AA][4][2] = ((-tmp2) * fjac[i][j][k - 1][4][2]) - (tmp1 * njac[i][j][k - 1][4][2]);\n      lhs[i][j][k][AA][4][3] = ((-tmp2) * fjac[i][j][k - 1][4][3]) - (tmp1 * njac[i][j][k - 1][4][3]);\n      lhs[i][j][k][AA][4][4] = (((-tmp2) * fjac[i][j][k - 1][4][4]) - (tmp1 * njac[i][j][k - 1][4][4])) - (tmp1 * dz5);\n      lhs[i][j][k][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dz1);\n      lhs[i][j][k][BB][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n      lhs[i][j][k][BB][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n      lhs[i][j][k][BB][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n      lhs[i][j][k][BB][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n      lhs[i][j][k][BB][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n      lhs[i][j][k][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dz2);\n      lhs[i][j][k][BB][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n      lhs[i][j][k][BB][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n      lhs[i][j][k][BB][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n      lhs[i][j][k][BB][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n      lhs[i][j][k][BB][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n      lhs[i][j][k][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dz3);\n      lhs[i][j][k][BB][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n      lhs[i][j][k][BB][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n      lhs[i][j][k][BB][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n      lhs[i][j][k][BB][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n      lhs[i][j][k][BB][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n      lhs[i][j][k][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dz4);\n      lhs[i][j][k][BB][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n      lhs[i][j][k][BB][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n      lhs[i][j][k][BB][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n      lhs[i][j][k][BB][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n      lhs[i][j][k][BB][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n      lhs[i][j][k][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dz5);\n      lhs[i][j][k][CC][0][0] = ((tmp2 * fjac[i][j][k + 1][0][0]) - (tmp1 * njac[i][j][k + 1][0][0])) - (tmp1 * dz1);\n      lhs[i][j][k][CC][0][1] = (tmp2 * fjac[i][j][k + 1][0][1]) - (tmp1 * njac[i][j][k + 1][0][1]);\n      lhs[i][j][k][CC][0][2] = (tmp2 * fjac[i][j][k + 1][0][2]) - (tmp1 * njac[i][j][k + 1][0][2]);\n      lhs[i][j][k][CC][0][3] = (tmp2 * fjac[i][j][k + 1][0][3]) - (tmp1 * njac[i][j][k + 1][0][3]);\n      lhs[i][j][k][CC][0][4] = (tmp2 * fjac[i][j][k + 1][0][4]) - (tmp1 * njac[i][j][k + 1][0][4]);\n      lhs[i][j][k][CC][1][0] = (tmp2 * fjac[i][j][k + 1][1][0]) - (tmp1 * njac[i][j][k + 1][1][0]);\n      lhs[i][j][k][CC][1][1] = ((tmp2 * fjac[i][j][k + 1][1][1]) - (tmp1 * njac[i][j][k + 1][1][1])) - (tmp1 * dz2);\n      lhs[i][j][k][CC][1][2] = (tmp2 * fjac[i][j][k + 1][1][2]) - (tmp1 * njac[i][j][k + 1][1][2]);\n      lhs[i][j][k][CC][1][3] = (tmp2 * fjac[i][j][k + 1][1][3]) - (tmp1 * njac[i][j][k + 1][1][3]);\n      lhs[i][j][k][CC][1][4] = (tmp2 * fjac[i][j][k + 1][1][4]) - (tmp1 * njac[i][j][k + 1][1][4]);\n      lhs[i][j][k][CC][2][0] = (tmp2 * fjac[i][j][k + 1][2][0]) - (tmp1 * njac[i][j][k + 1][2][0]);\n      lhs[i][j][k][CC][2][1] = (tmp2 * fjac[i][j][k + 1][2][1]) - (tmp1 * njac[i][j][k + 1][2][1]);\n      lhs[i][j][k][CC][2][2] = ((tmp2 * fjac[i][j][k + 1][2][2]) - (tmp1 * njac[i][j][k + 1][2][2])) - (tmp1 * dz3);\n      lhs[i][j][k][CC][2][3] = (tmp2 * fjac[i][j][k + 1][2][3]) - (tmp1 * njac[i][j][k + 1][2][3]);\n      lhs[i][j][k][CC][2][4] = (tmp2 * fjac[i][j][k + 1][2][4]) - (tmp1 * njac[i][j][k + 1][2][4]);\n      lhs[i][j][k][CC][3][0] = (tmp2 * fjac[i][j][k + 1][3][0]) - (tmp1 * njac[i][j][k + 1][3][0]);\n      lhs[i][j][k][CC][3][1] = (tmp2 * fjac[i][j][k + 1][3][1]) - (tmp1 * njac[i][j][k + 1][3][1]);\n      lhs[i][j][k][CC][3][2] = (tmp2 * fjac[i][j][k + 1][3][2]) - (tmp1 * njac[i][j][k + 1][3][2]);\n      lhs[i][j][k][CC][3][3] = ((tmp2 * fjac[i][j][k + 1][3][3]) - (tmp1 * njac[i][j][k + 1][3][3])) - (tmp1 * dz4);\n      lhs[i][j][k][CC][3][4] = (tmp2 * fjac[i][j][k + 1][3][4]) - (tmp1 * njac[i][j][k + 1][3][4]);\n      lhs[i][j][k][CC][4][0] = (tmp2 * fjac[i][j][k + 1][4][0]) - (tmp1 * njac[i][j][k + 1][4][0]);\n      lhs[i][j][k][CC][4][1] = (tmp2 * fjac[i][j][k + 1][4][1]) - (tmp1 * njac[i][j][k + 1][4][1]);\n      lhs[i][j][k][CC][4][2] = (tmp2 * fjac[i][j][k + 1][4][2]) - (tmp1 * njac[i][j][k + 1][4][2]);\n      lhs[i][j][k][CC][4][3] = (tmp2 * fjac[i][j][k + 1][4][3]) - (tmp1 * njac[i][j][k + 1][4][3]);\n      lhs[i][j][k][CC][4][4] = ((tmp2 * fjac[i][j][k + 1][4][4]) - (tmp1 * njac[i][j][k + 1][4][4])) - (tmp1 * dz5);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/17"}
{"code": "for (unsigned i = 131071; i <= 2147483647; i += 127)\n  a[i] += foo();\n\n", "pragma": "#pragma omp for schedule(static, 5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_codegen/6"}
{"code": "for (i = n; i >= 2; i--)\n{\n  l = i - 1;\n  h = (scale = 0.0);\n  if (l > 1)\n  {\n    for (k = 1; k <= l; k++)\n      scale += fabs(a(i - 1, k - 1).Val);\n\n    if (scale == 0.0)\n      e[i] = a(i - 1, l - 1);\n    else\n    {\n      for (k = 1; k <= l; k++)\n      {\n        a(i - 1, k - 1) /= scale;\n        h += a(i - 1, k - 1) * a(i - 1, k - 1);\n      }\n\n      f = a(i - 1, l - 1);\n      g = (f >= 0.0) ? (-sqrt(h)) : (sqrt(h));\n      EAssertR(_isnan(g) == 0, GetStr(h));\n      e[i] = scale * g;\n      h -= f * g;\n      a(i - 1, l - 1) = f - g;\n      f = 0.0;\n      for (j = 1; j <= l; j++)\n      {\n        a(j - 1, i - 1) = a(i - 1, j - 1) / h;\n        g = 0.0;\n        for (k = 1; k <= j; k++)\n          g += a(j - 1, k - 1) * a(i - 1, k - 1);\n\n        for (k = j + 1; k <= l; k++)\n          g += a(k - 1, j - 1) * a(i - 1, k - 1);\n\n        e[j] = g / h;\n        f += e[j] * a(i - 1, j - 1);\n      }\n\n      hh = f / (h + h);\n      for (j = 1; j <= l; j++)\n      {\n        f = a(i - 1, j - 1);\n        e[j] = (g = e[j] - (hh * f));\n        for (k = 1; k <= j; k++)\n        {\n          a(j - 1, k - 1) -= (f * e[k]) + (g * a(i - 1, k - 1));\n          EAssert(!a(j - 1, k - 1).IsNan());\n        }\n\n      }\n\n    }\n\n  }\n  else\n    e[i] = a(i - 1, l - 1);\n\n  d[i] = h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/60"}
{"code": "for (i = 0; i < (bands * cols); i++)\n{\n  noise1[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/19"}
{"code": "for (i = 0; i < ndim; i++)\n{\n  memviewslice->strides[i] = buf->strides[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/25"}
{"code": "for (int64_t e = 0; e < nedges; ++e)\n{\n  need_update[e] = 1;\n  need_update_new[e] = 0;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    r = 0;\n    g = 0;\n    b = 0;\n    tot = 0;\n    for (k = (0 > (i - radio)) ? (0) : (i - radio); k <= (((n - 1) < (i + radio)) ? (n - 1) : (i + radio)); k++)\n    {\n      for (l = (0 > (j - radio)) ? (0) : (j - radio); l <= (((m - 1) < (j + radio)) ? (m - 1) : (j + radio)); l++)\n      {\n        v = ppdBloque[(k - i) + radio][(l - j) + radio];\n        r += ppsImagenOrg[k][l].r * v;\n        g += ppsImagenOrg[k][l].g * v;\n        b += ppsImagenOrg[k][l].b * v;\n        tot += v;\n      }\n\n    }\n\n    resultado.r /= tot;\n    resultado.g /= tot;\n    resultado.b /= tot;\n    ppsImagenDst[i][j].r = r;\n    ppsImagenDst[i][j].g = g;\n    ppsImagenDst[i][j].b = b;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,l,k,j,r,g,b,tot)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical1/imagenes/0"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  sum_a += a[i];\n  sum_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum_a, sum_b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task6/1"}
{"code": "for (k = 1; k < (nz0 - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      sum0 = sum0 + (v[i][j][k][0] * v[i][j][k][0]);\n      sum1 = sum1 + (v[i][j][k][1] * v[i][j][k][1]);\n      sum2 = sum2 + (v[i][j][k][2] * v[i][j][k][2]);\n      sum3 = sum3 + (v[i][j][k][3] * v[i][j][k][3]);\n      sum4 = sum4 + (v[i][j][k][4] * v[i][j][k][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/17"}
{"code": "for (int k = i; k < m; k++)\n{\n  qv_j += b[k] * u[k - i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+: qv_j)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/17"}
{"code": "for (vertex_id = 0; vertex_id < stats->num_vertices; vertex_id++)\n{\n  sum += stats->distances[vertex_id];\n  printf(\"v: %u d: %u \\n\", vertex_id, sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/17"}
{"code": "for (size_t i = 0; i < n; ++i)\n  s[i] = ((i < 100) || ((!i) % 279)) ? (hi) : (lo);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex7-imbalance-openmp/2"}
{"code": "for (i = 1; i < n; i++)\n{\n  b[i] = (a[i] + a[i - 1]) / 2;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny01/ocl_tiny01/tiny01/0"}
{"code": "for (i = 0; i < slices; i++)\n{\n  SpGEMM_bigslice(Acol, Arow, An, Bcol, Brow, Bm, &Ccol_tBlock[i], Crow_tBlock[i], &Ccol_sizes[i], i * tBlock, (i + 1) * tBlock);\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/0"}
{"code": "for (int i = 0; i < (N / 2); i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/2"}
{"code": "for (i = 0; i < stopLength; i++)\n{\n  if (strcmp(stop[i], key) == 0)\n    temp += 1;\n\n}\n\n", "pragma": "omp parallel for private(i) schedule(dynamic,100) reduction(+:temp) num_threads(4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/0"}
{"code": "for (i = 0; i < SIMD_WIDTH; i++)\n{\n  if (sign[i])\n  {\n    OutputX[i] = 1.0 - OutputX[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/black_scholes/blackscholes.simd/3"}
{"code": "for (long i = 0; i < 65536; i++)\n{\n  sum = sum + num[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arunabellgutteramesh/ConcurrentProgrammingWithOpenMPandOpenCL/OpenMP/OpenMP_NormalAlgorithm/0"}
{"code": "for (int aux = 0; aux < 10; aux++)\n  if (result[aux] > 0)\n  fprintf(fout, \"%s\\n%d\\n\", desc_dna[aux], result[aux]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/infernanda/ProgramacaoParalelaBMHS/dna_openmp/5"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < i; ++j)\n  {\n    double tmp = 0.0;\n    for (int k = 0; k < M; ++k)\n      tmp += pow(x_[(i * M) + k] - x_[(j * M) + k], 2.0);\n\n    ans(i, j) = sqrt(tmp);\n    ans(j, i) = ans(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(x_,N,M) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/USCbiostats/r-parallel-benchmark/norm/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  j = i * incx;\n  sx[j] *= sa;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD2_OMP/MolDyn/correction/solQ4/dscal/1"}
{"code": "for (i = 0; i < 6; i++)\n  for (j = 0; j < 6; j++)\n  newTask->board[i][j] = board[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/3"}
{"code": "for (int i = 0; i < N2; ++i)\n{\n  for (int j = 0; j < N1; ++j)\n  {\n    C[i] = A[j] + B[j];\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-tracekernel/clangtrace/2"}
{"code": "for (c = 0; c < nChunks; c++)\n{\n  doCrypt(c, plain, crypt, key);\n}\n\n", "pragma": "omp parallel for firstprivate(nChunks) private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/frobino/openmp_introduction/Examples/crypt/crypt_omp_cu/0"}
{"code": "for (unsigned long i = 0; i < n1; i++)\n{\n  L[i] = arr[left + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/mergesort/0"}
{"code": "for (i = 0; i < rhs.rows; i++)\n  for (j = 0; j < rhs.cols; j++)\n  help.m[i][j] = x0.m[i][j];\n\n\n", "pragma": "omp for SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/linsolv/2"}
{"code": "for (int i = 0; i < p; ++i)\n{\n  this->SymbolicMatMatMult(tmp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/46"}
{"code": "for (int jj = N - 1; jj >= 0; jj--)\n{\n  for (int ii = 0; ii < N; ii++)\n  {\n    (cout << evaluate_array3d(array3d, N, ii, jj, index)) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/array3d/5"}
{"code": "for (i = 0; i < width; i++)\n{\n  Compl z;\n  Compl c;\n  int repeats;\n  double temp;\n  double lengthsq;\n  for (j = 0; j < height; j++)\n  {\n    z.real = 0.0;\n    z.imag = 0.0;\n    c.real = (-2.0) + (((double) i) * (4.0 / ((double) width)));\n    c.imag = (-2.0) + (((double) j) * (4.0 / ((double) height)));\n    repeats = 0;\n    lengthsq = 0.0;\n    while ((repeats < 100000) && (lengthsq < 4.0))\n    {\n      temp = ((z.real * z.real) - (z.imag * z.imag)) + c.real;\n      z.imag = ((2 * z.real) * z.imag) + c.imag;\n      z.real = temp;\n      lengthsq = (z.real * z.real) + (z.imag * z.imag);\n      repeats++;\n    }\n\n    omp_set_lock(&lock);\n    XSetForeground(display, gc, (1024 * 1024) * (repeats % 256));\n    XDrawPoint(display, window, gc, i, j);\n    omp_unset_lock(&lock);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule(dynamic, 2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markdtw/parallel-programming/mandelbrot-set/openmp_dynamic/0"}
{"code": "for (int iter = 0; (off_diag_norm(A01, A02, A12) >= tolerance) && (iter < max_iters); ++iter)\n{\n  double c;\n  double s;\n  double B00;\n  double B01;\n  double B02;\n  double B10;\n  double B11;\n  double B12;\n  double B20;\n  double B21;\n  double B22;\n  c = 1.0, s = 0.0;\n  if (A01 != 0.0)\n  {\n    double tau = (A11 - A00) / (2.0 * A01);\n    double sgn = (tau < 0.0) ? (-1.0) : (1.0);\n    double t = sgn / ((sgn * tau) + sqrt(1.0 + (tau * tau)));\n    c = 1.0 / sqrt(1.0 + (t * t));\n    s = t * c;\n  }\n\n  B00 = (c * A00) - (s * A01);\n  B01 = (s * A00) + (c * A01);\n  B10 = (c * A01) - (s * A11);\n  B11 = (s * A01) + (c * A11);\n  B02 = A02;\n  A00 = (c * B00) - (s * B10);\n  A01 = (c * B01) - (s * B11);\n  A11 = (s * B01) + (c * B11);\n  A02 = (c * B02) - (s * A12);\n  A12 = (s * B02) + (c * A12);\n  B00 = (c * V00) - (s * V01);\n  V01 = (s * V00) + (c * V01);\n  V00 = B00;\n  B10 = (c * V10) - (s * V11);\n  V11 = (s * V10) + (c * V11);\n  V10 = B10;\n  B20 = (c * V20) - (s * V21);\n  V21 = (s * V20) + (c * V21);\n  V20 = B20;\n  c = 1.0, s = 0.0;\n  if (A02 != 0.0)\n  {\n    double tau = (A22 - A00) / (2.0 * A02);\n    double sgn = (tau < 0.0) ? (-1.0) : (1.0);\n    double t = sgn / ((sgn * tau) + sqrt(1.0 + (tau * tau)));\n    c = 1.0 / sqrt(1.0 + (t * t));\n    s = t * c;\n  }\n\n  B00 = (c * A00) - (s * A02);\n  B01 = (c * A01) - (s * A12);\n  B02 = (s * A00) + (c * A02);\n  B20 = (c * A02) - (s * A22);\n  B22 = (s * A02) + (c * A22);\n  A00 = (c * B00) - (s * B20);\n  A12 = (s * A01) + (c * A12);\n  A02 = (c * B02) - (s * B22);\n  A22 = (s * B02) + (c * B22);\n  A01 = B01;\n  B00 = (c * V00) - (s * V02);\n  V02 = (s * V00) + (c * V02);\n  V00 = B00;\n  B10 = (c * V10) - (s * V12);\n  V12 = (s * V10) + (c * V12);\n  V10 = B10;\n  B20 = (c * V20) - (s * V22);\n  V22 = (s * V20) + (c * V22);\n  V20 = B20;\n  c = 1.0, s = 0.0;\n  if (A12 != 0.0)\n  {\n    double tau = (A22 - A11) / (2.0 * A12);\n    double sgn = (tau < 0.0) ? (-1.0) : (1.0);\n    double t = sgn / ((sgn * tau) + sqrt(1.0 + (tau * tau)));\n    c = 1.0 / sqrt(1.0 + (t * t));\n    s = t * c;\n  }\n\n  B02 = (s * A01) + (c * A02);\n  B11 = (c * A11) - (s * A12);\n  B12 = (s * A11) + (c * A12);\n  B21 = (c * A12) - (s * A22);\n  B22 = (s * A12) + (c * A22);\n  A01 = (c * A01) - (s * A02);\n  A02 = B02;\n  A11 = (c * B11) - (s * B21);\n  A12 = (c * B12) - (s * B22);\n  A22 = (s * B12) + (c * B22);\n  B01 = (c * V01) - (s * V02);\n  V02 = (s * V01) + (c * V02);\n  V01 = B01;\n  B11 = (c * V11) - (s * V12);\n  V12 = (s * V11) + (c * V12);\n  V11 = B11;\n  B21 = (c * V21) - (s * V22);\n  V22 = (s * V21) + (c * V22);\n  V21 = B21;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aop-omp/main/1"}
{"code": "for (j = 0; j < LOOPCOUNT; ++j)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[j];\n}\n\n", "pragma": "omp for schedule(dynamic, 1) reduction(^ : exclusiv_bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_for_reduction/6"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  count[arr[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gomathi18/parallel-counting-sort/main/1"}
{"code": "for (int i = 0; i < 20; i++)\n  for (int j = 0; j < 20; j++)\n{\n  A[i][j] = 0.0;\n  for (int k = 0; k < 20; ++k)\n    A[i][j] += B[i][k] * C[k][j];\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/1.norace13/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"iteration: %d, thread: %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrycz/c-parallel-programming/openmp/openmp_parallel_for/0"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  sum = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    sum = sum + (a[k] * p[colidx[k]]);\n  }\n\n  w[j] = sum;\n}\n\n", "pragma": "\t\t#pragma omp for private(sum,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/6"}
{"code": "for (i = 0; i < total_its; i++)\n{\n  omp_offloading_start(__off_info__);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/sum/sum_ompacc/1"}
{"code": "for (int col = 0; col < columns; col++)\n{\n  maxs[col] = calculateMax(dataset, col, rows);\n  mins[col] = calculateMin(dataset, col, rows);\n}\n\n", "pragma": "    #pragma omp parallel for shared(maxs, mins, columns, dataset)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-CUDA-OpenMP-MPI/OpenMP/MinMax/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  f[i] = f[i] + (dt * smb[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) shared(f,dt,N,smb) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victor13165/projet-1-SNHP/CPP/projet1/4"}
{"code": "for (int i = n; i < (n + num_pad); i++)\n{\n  for (int j = 0; j < (n + 1); j++)\n  {\n    new_a[(i * (n + 1)) + j] = 0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/3"}
{"code": "for (int k = 0; k < model->no_clusters; k++)\n{\n  for (int c = 0; c < model->columns; c++)\n  {\n    if (cluster_count[k] != 0)\n      model->centroids[(k * model->columns) + c] = sum_cluster_columns[(k * model->columns) + c] / ((float) cluster_count[k]);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajshrestha86/kmeans-clusterize/openmp/kmeans_omp/3"}
{"code": "for (long i = 0; i < numUniqueClusters; i++)\n{\n  omp_init_lock(&nlocks[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/2"}
{"code": "for (our_current_row = OUR_NUMBER_OF_ROWS + 1; our_current_row >= 0; our_current_row--)\n{\n  free(our_next_grid[our_current_row]);\n  free(our_current_grid[our_current_row]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andrewpap22/Conway_sGameOfLife/GoL_All_Source_Files/life/4"}
{"code": "for (int i = 0; i < n; i++)\n  vec[i] = (rand() % 10) - 5;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task9/2"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < NODESY; j++)\n  {\n    TOPO[i + 1][j + 1] = count;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/69"}
{"code": "for (i = 1; i < n; i++)\n  if (relprime(n, i))\n  length += 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxburton/DPT-coursework/OpenMP/totientRangeParallel/1"}
{"code": "for (i = 1; i < (matrix.rows + 1); i++)\n{\n  int elements = matrix.ia[i] - matrix.ia[i - 1];\n  if (elements == 0)\n  {\n    continue;\n  }\n\n  int pos = matrix.ia[i - 1];\n  while ((pos - matrix.ia[i - 1]) <= elements)\n  {\n    if (matrix.ja[pos] == (i - 1))\n    {\n      trace += matrix.nnz.f[pos];\n      break;\n    }\n    else\n      if (matrix.ja[pos] > (i - 1))\n    {\n      break;\n    }\n\n\n    pos++;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:trace) shared(matrix) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/3"}
{"code": "for (int i0 = 0; i0 < (N / 32); i0++)\n  for (int j0 = 0; j0 < (N / 32); j0++)\n  for (int k0 = 0; k0 < (N / 32); k0++)\n  for (int i1 = 32 * i0; i1 < ((32 * i0) + 32); i1++)\n  for (int j1 = 32 * j0; j1 < ((32 * j0) + 32); j1++)\n  for (int k1 = 32 * k0; k1 < ((32 * k0) + 32); k1++)\n  C[(i1 * N) + j1] += A[(i1 * N) + k1] * B2[(j1 * N) + k1];\n\n\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RahimACM/matrix-multiplication-optimization/matrix_multiplication/7"}
{"code": "for (int j = 0; j < 4; j++)\n  b->q[j] += h * dq[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zcl2016/Gazebo-exercise/gazebo7_7.14.0_exercise/deps/opende/src/util/2"}
{"code": "for (int i = 0; i < size; i++)\n  B[i] = A[i] * alpha;\n\n", "pragma": "    #pragma omp parallel for schedule (dynamic, 64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/5"}
{"code": "for (int it = 0; it < num_itr; it++)\n{\n  for (int i = 1; i < (y_points - 1); i++)\n  {\n    for (int j = 1; j < (x_points - 1); j++)\n    {\n      p_new[i][j] = ((((del_y * del_y) * (p[i][j + 1] + p[i][j - 1])) + ((del_x * del_x) * (p[i + 1][j] + p[i - 1][j]))) - ((((del_x * del_x) * del_y) * del_y) * b[i][j])) / (2 * ((del_x * del_x) + (del_y * del_y)));\n    }\n\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    p_new[i][0] = 0;\n    p_new[i][x_points - 1] = 0;\n  }\n\n  for (int j = 0; j < x_points; j++)\n  {\n    p_new[0][j] = 0;\n    p_new[y_points - 1][j] = 0;\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    for (int j = 0; j < x_points; j++)\n    {\n      p[i][j] = p_new[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Poissons Equation/2-D_Poissons_Equation/main/4"}
{"code": "for (i = 0; i < 16; ++i)\n  for (int j = 0; j < 16; ++j)\n{\n  for (int k = 0; k < 16; ++k)\n    i += j;\n\n}\n\n\n", "pragma": "omp for simd collapse(-5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_misc_messages/0"}
{"code": "for (int i = 0; i < ((size + 1) / 3); i++)\n{\n  feuilles[i] = malloc(sizeof(node));\n  file_nodes[i] = malloc(sizeof(node));\n  file_nodes[i]->id = i;\n  file_nodes[i]->rule = file_words[3 * i];\n  file_nodes[i]->parent_id = -1;\n  file_nodes[i]->str_dependencies = file_words[(3 * i) + 1];\n  file_nodes[i]->parents = malloc(((size + 1) / 3) * (sizeof(node *)));\n  file_nodes[i]->number_parents = 0;\n  file_nodes[i]->isReady = 0;\n  char *cmd = file_words[(3 * i) + 2];\n  if (cmd[0] != '\\t')\n  {\n    printf(\"Rule[*%s*] : Makefile missing separator error in spite of using the correct indentation\", file_words[3 * i]);\n    exit(1);\n  }\n\n  if (system(c) != 0)\n  {\n    printf(\"%sCannot open Makefile directory \\n\", KRED);\n    exit(1);\n  }\n\n  char *src = c;\n  char *b = \"; \";\n  size_t sizeFull = ((strlen(src) + strlen(b)) + strlen(cmd)) + 3;\n  char *full = (char *) malloc(sizeFull);\n  strcpy(full, src);\n  strcat(full, b);\n  strcat(full, cmd);\n  file_nodes[i]->command = full;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elouatih/distributed_make_mpi_openmp/parser/2"}
{"code": "for (int i = 0; i < points; i++)\n{\n  if (fabs(h_output[i] - output[i]) > 1e-6)\n  {\n    printf(\"%lf %lf\\n\", h_output[i], output[i]);\n    ok = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fresnel-omp/main/3"}
{"code": "for (int i = 0; i < DIM; i++)\n  for (int j = 0; j < DIM; j++)\n{\n  gather_block(N, ts, &Alin[i * ts][j * ts], A[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/8"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < rows; j++)\n  {\n    mat[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/2L2CU/ParallelComputing/main/0"}
{"code": "for (i = 0; i < stages; i++)\n{\n  for (j = 0; j < stages_array[i]; j++)\n  {\n    for (k = 0; k < 3; k++)\n    {\n      for (l = 0; l < 4; l++)\n      {\n        if (fgets(mystring, 12, fp) != NULL)\n          rectangles_array[r_index] = atoi(mystring);\n        else\n          break;\n\n        r_index++;\n      }\n\n      if (fgets(mystring, 12, fp) != NULL)\n      {\n        weights_array[w_index] = atoi(mystring);\n      }\n      else\n        break;\n\n      w_index++;\n    }\n\n    if (fgets(mystring, 12, fp) != NULL)\n      tree_thresh_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha1_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha2_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    tree_index++;\n    if (j == (stages_array[i] - 1))\n    {\n      if (fgets(mystring, 12, fp) != NULL)\n        stages_thresh_array[i] = atoi(mystring);\n      else\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rajanjitenpatel/Face_detection/Parallel_code/haar/6"}
{"code": "for (k = 0; k < div; k++)\n{\n  for (i = 0; i < num_volatility; i++)\n    op[k].implied_vol[i] = newton_raphson(op[k].V_market[i][0], low_vol, epsilon, op[k].S, op[k].K[i], op[k].r, op[k].T, op[k].V_market[i][1]);\n\n}\n\n", "pragma": "omp parallel for default(private) shared(low_vol, epsilon, op) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DomenicoNatella/implied_volatility/implied_vol_newton_ver2/0"}
{"code": "for (y = 0; y < OMP_yMax; y += 8)\n{\n  int ind = OMP_Index(0, y, z);\n  u[ind] *= boundryScale;\n  u[ind + OMP_xMax] *= boundryScale;\n  u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  for (x = 1; x < OMP_xMax; x++)\n  {\n    int xyzInd = OMP_Index(x, y, z);\n    u[xyzInd] += u[xyzInd - 1] * nu;\n    u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n    u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n  }\n\n  u[ind] *= boundryScale;\n  u[ind + OMP_xMax] *= boundryScale;\n  u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n  for (x = OMP_xMax - 2; x >= 0; x--)\n  {\n    int xyzInd = OMP_Index(x, y, z);\n    u[xyzInd] += u[xyzInd + 1] * nu;\n    u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n    u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n  }\n\n}\n\n", "pragma": "omp parallel for private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/vompDeblur/0"}
{"code": "for (i = 0; i < NCLUSTERS; i++)\n{\n  for (j = 0; j < NFEATURES; j++)\n  {\n    if (new_centers_len[i] > 0)\n      clusters[i][j] = new_centers[i][j] / new_centers_len[i];\n\n    new_centers[i][j] = 0.0;\n  }\n\n  new_centers_len[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/Heterogeniuses/opencl/kmeans/kmeans_clustering/4"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (j = 0; j < 26; j++)\n  {\n    ncl[j + (26 * l)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nn = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    dx = amz * ((dx + (dyp * sfxyz[nn + (4 * mxv)])) + (dx1 * sfxyz[(nn + (4 * mxv)) + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[(nn + (4 * mxv)) + 1])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[(nn + (4 * mxv)) + 2])) + (dx1 * sfxyz[((nn + (4 * mxv)) + 2) + 4]));\n    mm = nn + (4 * mxyv);\n    vx = (amx * sfxyz[mm]) + (amy * sfxyz[mm + 4]);\n    vy = (amx * sfxyz[mm + 1]) + (amy * sfxyz[(mm + 1) + 4]);\n    vz = (amx * sfxyz[mm + 2]) + (amy * sfxyz[(mm + 2) + 4]);\n    dx = dx + (dzp * ((vx + (dyp * sfxyz[mm + (4 * mxv)])) + (dx1 * sfxyz[(mm + (4 * mxv)) + 4])));\n    dy = dy + (dzp * ((vy + (dyp * sfxyz[(mm + (4 * mxv)) + 1])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 1) + 4])));\n    dz = dz + (dzp * ((vz + (dyp * sfxyz[(mm + (4 * mxv)) + 2])) + (dx1 * sfxyz[((mm + (4 * mxv)) + 2) + 4])));\n    dxp = ppart[(j + (3 * nppmx)) + npoff];\n    dyp = ppart[(j + (4 * nppmx)) + npoff];\n    dzp = ppart[(j + (5 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    vz = dzp + (qtm * dz);\n    dxp += vx;\n    dyp += vy;\n    dzp += vz;\n    sum1 += ((dxp * dxp) + (dyp * dyp)) + (dzp * dzp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    dz = z + (vz * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,noff,moff,loff,npp,npoff,nn,mm,ll,ih,nh,x,y,z,dxp,dyp, dzp,amx,amy,amz,dx1,dx,dy,dz,vx,vy,vz,edgelx,edgely,edgelz,edgerx, edgery,edgerz,sum1,sfxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic3/vmpush3/1"}
{"code": "for (int i = 0; i < sampleSize; i++)\n{\n  double serial = serial_multiplication(n);\n  double parallel = parallel_for_multiplication(n);\n  sum1 += serial;\n  sum2 += parallel;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vini2/ParallelMatrixMultiplicationUsingOpenMP/old files/MatrixMultiplier/3"}
{"code": "for (int i = 0; i < N; ++i)\n  counts_team += 1;\n\n", "pragma": "#pragma omp for reduction(+: counts_team)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/sollve_vv/tests/4.5/application_kernels/reduction_separated_directives/0"}
{"code": "for (int i = 0; i <= 100; i++)\n{\n  for (int j = 0; j <= 200; j++)\n  {\n    printf(\"custkey = %d, orderkey = %d, threadId = %d, NTeams = %d \\n\", values[i].custkey, values_o[j].orderkey, omp_get_thread_num(), omp_get_num_teams());\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kallebyramos/Nested-Loop-Openmp/src/main/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  printf(\" %d\", A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anushaasaad/comparsion-of-sorting-algorithms-using-Pthreads-OpenMP/BubbleOpenMP/2"}
{"code": "for (iteration = 1; iteration <= 10; iteration++)\n{\n  printf(\"        %d\\n\", iteration);\n  rank(iteration);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/11"}
{"code": "for (j = 0; j < 1080; j++)\n{\n  for (k = 0; k < 1080; k++)\n  {\n    if (videoseuil[i][j][k] != videoseuilOld[j][k])\n      videoDiff[i][j][k] = 1;\n    else\n      videoDiff[i][j][k] = 0;\n\n    videoseuilOld[j][k] = videoseuil[i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/1"}
{"code": "for (int v = 0; v < 8; v++)\n{\n  const int n1 = i + VOISINS[v][0];\n  const int n2 = j + VOISINS[v][1];\n  CHECK((((n1 >= 0) && (n1 < nrows)) && (n2 >= 0)) && (n2 < ncols));\n  if (Wprec[(n1 * ncols) + n2] == m->no_data)\n    continue;\n\n  CHECK(TERRAIN(m, i, j) > m->no_data);\n  CHECK(Wprec[(i * ncols) + j] > m->no_data);\n  CHECK(Wprec[(n1 * ncols) + n2] > m->no_data);\n  const float Wn = Wprec[(n1 * ncols) + n2] + EPSILON;\n  if (TERRAIN(m, i, j) >= Wn)\n  {\n    W[(i * ncols) + j] = TERRAIN(m, i, j);\n    modif = 1;\n    if (W[(i * ncols) + j] < min_darboux)\n      min_darboux = W[(i * ncols) + j];\n\n  }\n  else\n    if (Wprec[(i * ncols) + j] > Wn)\n  {\n    W[(i * ncols) + j] = Wn;\n    modif = 1;\n    if (W[(i * ncols) + j] < min_darboux)\n      min_darboux = W[(i * ncols) + j];\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/darboux/6"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  matrix[i][j] = ((1. / ((float) N)) * ((float) i)) * 100.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/histogram_2D/openmp_histogram/7"}
{"code": "for (first = 0; first < N; first++)\n{\n  if ((first % 2) == 0)\n  {\n    for (i = 1; i < N; i += 2)\n    {\n      if (A[i - 1] > A[i])\n      {\n        temp = A[i - 1];\n        A[i - 1] = A[i];\n        A[i] = temp;\n      }\n\n    }\n\n  }\n  else\n  {\n    for (i = 1; i < (N - 1); i += 2)\n    {\n      if (A[i] > A[i + 1])\n      {\n        temp = A[i + 1];\n        A[i + 1] = A[i];\n        A[i] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none),shared(A,N,first),private(temp,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 14 & 15/bubble_omp/0"}
{"code": "for (int i = 10; i > 1; i--)\n{\n  a[k]++;\n  k = k + 3;\n}\n\n", "pragma": "  #pragma omp for simd linear(k : 3) schedule(simd, nonmonotonic: dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/1"}
{"code": "for (int i = 0; i < length_A; i++)\n  for (int j = 0; j < length_B; j++)\n{\n  error = fabs(distance[i][j] - dist[i][j]);\n  error_omp = fabs(distance_omp[i][j] - dist[i][j]);\n  if ((error < threshold) && (error_omp < threshold))\n  {\n    printf(\"pass %f\", distance[i][j]);\n    printf(\"     %f\", distance_omp[i][j]);\n    printf(\"     %f \\n\", dist[i][j]);\n  }\n  else\n  {\n    printf(\"fail %f\", distance[i][j]);\n    printf(\"     %f\", distance_omp[i][j]);\n    printf(\"     %f \\n\", dist[i][j]);\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/distance/11"}
{"code": "for (int k = 0; k < wym; k++)\n{\n  getright[k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aenyewedien/GameOfLife/game/3"}
{"code": "for (i = 0; i < N; i++)\n  arr[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DariaVoo/OpenMP_MPI/OpenMP/lab3/1"}
{"code": "for (n = 0; n < numngb_inbox; n++)\n{\n  j = Ngblist[(tid * MAX_NGB) + n];\n  dx = pos[0] - P[j].Pos[0];\n  dy = pos[1] - P[j].Pos[1];\n  dz = pos[2] - P[j].Pos[2];\n  r2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n  if (r2 < h2)\n  {\n    numngb++;\n    r = sqrt(r2);\n    u = r * hinv;\n    if (u < 0.5)\n    {\n      wk = hinv3 * (KERNEL_COEFF_1 + (((KERNEL_COEFF_2 * (u - 1)) * u) * u));\n      dwk = (hinv4 * u) * ((KERNEL_COEFF_3 * u) - KERNEL_COEFF_4);\n    }\n    else\n    {\n      wk = (((hinv3 * KERNEL_COEFF_5) * (1.0 - u)) * (1.0 - u)) * (1.0 - u);\n      dwk = ((hinv4 * KERNEL_COEFF_6) * (1.0 - u)) * (1.0 - u);\n    }\n\n    mass_j = P[j].Mass;\n    rho += mass_j * wk;\n    weighted_numngb += (NORM_COEFF * wk) / hinv3;\n    dhsmlrho += (-mass_j) * (((NUMDIMS * hinv) * wk) + (u * dwk));\n    if (r > 0)\n    {\n      fac = (mass_j * dwk) / r;\n      dvx = vel[0] - SphP[j].VelPred[0];\n      dvy = vel[1] - SphP[j].VelPred[1];\n      dvz = vel[2] - SphP[j].VelPred[2];\n      divv -= fac * (((dx * dvx) + (dy * dvy)) + (dz * dvz));\n      rotv[0] += fac * ((dz * dvy) - (dy * dvz));\n      rotv[1] += fac * ((dx * dvz) - (dz * dvx));\n      rotv[2] += fac * ((dy * dvx) - (dx * dvy));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/density/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%f \", Cmatrix[i + (n * j)]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patlewis/matrix-matrix-multiplication/ring_matrix_part_b/4"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  arr[i] = i + 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/declare_variant/test_declare_variant/2"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < columns; j++)\n  {\n    fprintf(fp, \"%d \", matrix[j][i]);\n  }\n\n  fputs(\"\\n\", fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cesargdm/game-of-life/main/5"}
{"code": "for (int i = 0; i < NUM_PI; i++)\n  sendsize[i] = load[i] * MAX_STR_LEN;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ReinhartC/Parallel-RSA-on-Raspberry-Pi/Builds/LB_OMP_MPI/RSA_LB_OMP_MPI/1"}
{"code": "for (int i = (8 * n) / 16; i < ((9 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/16"}
{"code": "for (l = 0; l <= (ub - 1); l += 1)\n{\n  int l8 = l * 8;\n  int l36 = l * 36;\n  real8 h12 = m[((l8 + 0) * 4) + 1];\n  real8 h13 = m[((l8 + 0) * 4) + 2];\n  real8 h14 = m[((l8 + 0) * 4) + 3];\n  real8 h22 = m[((l8 + 1) * 4) + 1];\n  real8 h23 = m[((l8 + 1) * 4) + 2];\n  real8 h24 = m[((l8 + 1) * 4) + 3];\n  real8 h32 = m[((l8 + 2) * 4) + 1];\n  real8 h33 = m[((l8 + 2) * 4) + 2];\n  real8 h34 = m[((l8 + 2) * 4) + 3];\n  real8 h42 = m[((l8 + 3) * 4) + 1];\n  real8 h43 = m[((l8 + 3) * 4) + 2];\n  real8 h44 = m[((l8 + 3) * 4) + 3];\n  real8 h52 = m[((l8 + 4) * 4) + 1];\n  real8 h53 = m[((l8 + 4) * 4) + 2];\n  real8 h54 = m[((l8 + 4) * 4) + 3];\n  real8 h62 = m[((l8 + 5) * 4) + 1];\n  real8 h63 = m[((l8 + 5) * 4) + 2];\n  real8 h64 = m[((l8 + 5) * 4) + 3];\n  real8 h72 = m[((l8 + 6) * 4) + 1];\n  real8 h73 = m[((l8 + 6) * 4) + 2];\n  real8 h74 = m[((l8 + 6) * 4) + 3];\n  real8 h82 = m[((l8 + 7) * 4) + 1];\n  real8 h83 = m[((l8 + 7) * 4) + 2];\n  real8 h84 = m[((l8 + 7) * 4) + 3];\n  real8 ddd = d__[l];\n  y[l36 + 0] += ddd * (((h12 * h12) + (h13 * h13)) + (h14 * h14));\n  y[l36 + 1] += ddd * (((h12 * h22) + (h13 * h23)) + (h14 * h24));\n  y[l36 + 2] += ddd * (((h22 * h22) + (h23 * h23)) + (h24 * h24));\n  y[l36 + 3] += ddd * (((h12 * h32) + (h13 * h33)) + (h14 * h34));\n  y[l36 + 4] += ddd * (((h22 * h32) + (h23 * h33)) + (h24 * h34));\n  y[l36 + 5] += ddd * (((h32 * h32) + (h33 * h33)) + (h34 * h34));\n  y[l36 + 6] += ddd * (((h12 * h42) + (h13 * h43)) + (h14 * h44));\n  y[l36 + 7] += ddd * (((h22 * h42) + (h23 * h43)) + (h24 * h44));\n  y[l36 + 8] += ddd * (((h32 * h42) + (h33 * h43)) + (h34 * h44));\n  y[l36 + 9] += ddd * (((h42 * h42) + (h43 * h43)) + (h44 * h44));\n  y[l36 + 10] += ddd * (((h12 * h52) + (h13 * h53)) + (h14 * h54));\n  y[l36 + 11] += ddd * (((h22 * h52) + (h23 * h53)) + (h24 * h54));\n  y[l36 + 12] += ddd * (((h32 * h52) + (h33 * h53)) + (h34 * h54));\n  y[l36 + 13] += ddd * (((h42 * h52) + (h43 * h53)) + (h44 * h54));\n  y[l36 + 14] += ddd * (((h52 * h52) + (h53 * h53)) + (h54 * h54));\n  y[l36 + 15] += ddd * (((h12 * h62) + (h13 * h63)) + (h14 * h64));\n  y[l36 + 16] += ddd * (((h22 * h62) + (h23 * h63)) + (h24 * h64));\n  y[l36 + 17] += ddd * (((h32 * h62) + (h33 * h63)) + (h34 * h64));\n  y[l36 + 18] += ddd * (((h42 * h62) + (h43 * h63)) + (h44 * h64));\n  y[l36 + 19] += ddd * (((h52 * h62) + (h53 * h63)) + (h54 * h64));\n  y[l36 + 20] += ddd * (((h62 * h62) + (h63 * h63)) + (h64 * h64));\n  y[l36 + 21] += ddd * (((h12 * h72) + (h13 * h73)) + (h14 * h74));\n  y[l36 + 22] += ddd * (((h22 * h72) + (h23 * h73)) + (h24 * h74));\n  y[l36 + 23] += ddd * (((h32 * h72) + (h33 * h73)) + (h34 * h74));\n  y[l36 + 24] += ddd * (((h42 * h72) + (h43 * h73)) + (h44 * h74));\n  y[l36 + 25] += ddd * (((h52 * h72) + (h53 * h73)) + (h54 * h74));\n  y[l36 + 26] += ddd * (((h62 * h72) + (h63 * h73)) + (h64 * h74));\n  y[l36 + 27] += ddd * (((h72 * h72) + (h73 * h73)) + (h74 * h74));\n  y[l36 + 28] += ddd * (((h12 * h82) + (h13 * h83)) + (h14 * h84));\n  y[l36 + 29] += ddd * (((h22 * h82) + (h23 * h83)) + (h24 * h84));\n  y[l36 + 30] += ddd * (((h32 * h82) + (h33 * h83)) + (h34 * h84));\n  y[l36 + 31] += ddd * (((h42 * h82) + (h43 * h83)) + (h44 * h84));\n  y[l36 + 32] += ddd * (((h52 * h82) + (h53 * h83)) + (h54 * h84));\n  y[l36 + 33] += ddd * (((h62 * h82) + (h63 * h83)) + (h64 * h84));\n  y[l36 + 34] += ddd * (((h72 * h82) + (h73 * h83)) + (h74 * h84));\n  y[l36 + 35] += ddd * (((h82 * h82) + (h83 * h83)) + (h84 * h84));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_livenessTest/2"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  q[i] = 0.0;\n  for (j = 0; j < 8192; j++)\n  {\n    q[i] = q[i] + (A[(i * 8192) + j] * p[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/BICG/src/bicg/7"}
{"code": "for (int i = 0; i < n_ysize; i++)\n{\n  for (int j = 0; j < n_xsize; j++)\n  {\n    int id = p_data[(i * n_xsize) + j];\n    if (nodata_value != id)\n    {\n      if (bbox_map.find(id) == bbox_map.end())\n      {\n        bbox_map[id] = SubBasin(j, i, j, i);\n      }\n      else\n      {\n        if (j < bbox_map[id].x_min)\n        {\n          bbox_map[id].x_min = j;\n        }\n        else\n          if (j > bbox_map[id].x_max)\n        {\n          bbox_map[id].x_max = j;\n        }\n\n\n        if (i > bbox_map[id].y_max)\n        {\n          bbox_map[id].y_max = i;\n        }\n\n      }\n\n      bbox_map[id].cell_count += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/import_raster/import_raster/0"}
{"code": "for (int i = 0; i < number_of_images; ++i)\n{\n  rc = lodepng_decode32(&(*images)[i], &(*widths)[i], &(*heights)[i], encoded_images[i], encoded_images_sz[i]);\n  if (rc)\n  {\n    printf(\"decode error: %s\\n\", lodepng_error_text(rc));\n  }\n\n}\n\n", "pragma": "omp parallel for shared(encoded_images, encoded_images_sz, images, widths, heights, number_of_images) private(rc)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_omp/0"}
{"code": "for (int i = 1; i <= leftRow; i++)\n{\n  for (int k = 1; k <= rightCol; k++)\n  {\n    for (int j = 1; j <= col; j++)\n    {\n      sumPerLine += leftMatrix->getMatrixElement(i, j) * rightMatrix->getMatrixElement(j, k);\n    }\n\n    tmpMatrix->matrixPush(sumPerLine);\n    sumPerLine = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nablax/OpenMP-CUDA-Matrix-Multiplication/QtMatrixOpenMP/MatrixCalculation/2"}
{"code": "for (i = 14; i < (nx - 14); i += 1)\n{\n  float tmp = coeffs[0] * (A0[i + 1] + A0[i - 1]);\n  tmp += coeffs[1] * (A0[i + 2] + A0[i - 2]);\n  tmp += coeffs[2] * (A0[i + 3] + A0[i - 3]);\n  tmp += coeffs[3] * (A0[i + 4] + A0[i - 4]);\n  tmp += coeffs[4] * (A0[i + 5] + A0[i - 5]);\n  tmp += coeffs[5] * (A0[i + 6] + A0[i - 6]);\n  tmp += coeffs[6] * (A0[i + 7] + A0[i - 7]);\n  tmp += coeffs[7] * (A0[i + 8] + A0[i - 8]);\n  tmp += coeffs[8] * (A0[i + 9] + A0[i - 9]);\n  tmp += coeffs[9] * (A0[i + 10] + A0[i - 10]);\n  tmp += coeffs[10] * (A0[i + 11] + A0[i - 11]);\n  tmp += coeffs[11] * (A0[i + 12] + A0[i - 12]);\n  tmp += coeffs[12] * (A0[i + 13] + A0[i - 13]);\n  tmp += coeffs[13] * (A0[i + 14] + A0[i - 14]);\n  tmp += coeffs[14] * A0[i];\n  Anext[i] = tmp;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_35_parallel_heat_eq/0"}
{"code": "for (i = 0; i < NY; i++)\n{\n  if (percentDiff(s[i], s_outputFromGpu[i]) > PERCENT_DIFF_ERROR_THRESHOLD)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/BICG/bicg_omp_out/3"}
{"code": "for (int i = 0; i < 32; i++)\n{\n  if (maxvals[i] > maxval)\n  {\n    maxval = maxvals[i];\n    maxloc = maxlocs[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-3/parallel_not_critical/1"}
{"code": "for (int i = 0; i < N; i++)\n  visited[i + offset] = local_visited[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/4"}
{"code": "for (j = 1; j <= log2(N); j++)\n{\n  if (n & (1 << (((int) log2(N)) - j)))\n    p |= 1 << (j - 1);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qixuxiang/simple-fft-openmp/fft_omp/5"}
{"code": "for (int iter = 0; iter < niter; iter++)\n{\n  for (i = 1; i < (n - 1); i++)\n  {\n    for (j = 1; j < (m - 1); j += 2)\n    {\n      int shift;\n      if ((i % 2) == 0)\n      {\n        shift = 1;\n      }\n      else\n      {\n        shift = 0;\n      }\n\n      int index = getIndex(i, j + shift, m);\n      int pos_l = getIndex(i - 1, j + shift, m);\n      int pos_r = getIndex(i + 1, j + shift, m);\n      int pos_u = getIndex(i, (j + 1) + shift, m);\n      int pos_d = getIndex(i, (j - 1) + shift, m);\n      T[index] = (((1.0 - alpha) * T[index]) + ((alpha / 4.0) * (((T[pos_l] + T[pos_r]) + T[pos_u]) + T[pos_d]))) + b[index];\n    }\n\n  }\n\n  for (i = 1; i < (n - 1); i++)\n  {\n    for (j = 2; j < (m - 1); j += 2)\n    {\n      int shift;\n      if ((i % 2) == 0)\n      {\n        shift = -1;\n      }\n      else\n      {\n        shift = 0;\n      }\n\n      int index = getIndex(i, j + shift, m);\n      int pos_l = getIndex(i - 1, j + shift, m);\n      int pos_r = getIndex(i + 1, j + shift, m);\n      int pos_u = getIndex(i, (j + 1) + shift, m);\n      int pos_d = getIndex(i, (j - 1) + shift, m);\n      T[index] = (((1.0 - alpha) * T[index]) + ((alpha / 4.0) * (((T[pos_l] + T[pos_r]) + T[pos_u]) + T[pos_d]))) + b[index];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/serial_mg/3"}
{"code": "for (size_t bucket = 0; bucket < size; bucket++)\n{\n  for (size_t elem = 0; elem < arr[bucket]->n_elem; elem++)\n  {\n    res[w++] = arr[bucket]->array[elem];\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/old_openmp/main/4"}
{"code": "for (i = 0; i < (2 * N); i += 1)\n{\n  incx = i * incX;\n  incy = i * incY;\n  save = y[incy];\n  y[incy] = x[incx];\n  x[incx] = save;\n}\n\n", "pragma": "omp for schedule(static) private(save, incx, incy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/swap/4"}
{"code": "for (; r < rows; r++)\n{\n  if (r > 0)\n  {\n    printf(\",\");\n  }\n\n  printf(\"{\");\n  int c = 0;\n  for (; c < cols; c++)\n  {\n    if (c > 0)\n    {\n      printf(\",\");\n    }\n\n    printf(\"%d\", mat[(r * cols) + c]);\n  }\n\n  printf(\"}\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pnookala/MIC_OpenMP_GeMTC/src/Apps/MatrixMul/4"}
{"code": "for (i = 0; i < nnodes; i++)\n{\n  i1 = tree[i].left;\n  i2 = tree[i].right;\n  if (i1 < 0)\n  {\n    index = (-i1) - 1;\n    order1 = nodeorder[index];\n    counts1 = nodecounts[index];\n  }\n  else\n  {\n    order1 = order[i1];\n    counts1 = 1;\n  }\n\n  if (i2 < 0)\n  {\n    index = (-i2) - 1;\n    order2 = nodeorder[index];\n    counts2 = nodecounts[index];\n  }\n  else\n  {\n    order2 = order[i2];\n    counts2 = 1;\n  }\n\n  if (order1 > order2)\n  {\n    tree[i].left = i2;\n    tree[i].right = i1;\n  }\n\n  nodecounts[i] = counts1 + counts2;\n  nodeorder[i] = ((counts1 * order1) + (counts2 * order2)) / (counts1 + counts2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/90"}
{"code": "for (int i = at * (n / nThreads); i < end; i++)\n  sum1P[at] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/sum/5"}
{"code": "for (iy = 0; iy < iy_max; iy++)\n{\n  y = y_min + (iy * pix_h);\n  if (fabs(y) < (pix_h / 2))\n    y = 0.0;\n\n  for (ix = 0; ix < ix_max; ix++)\n  {\n    x = x_min + (ix * pix_w);\n    Zx = 0.0;\n    Zy = 0.0;\n    Zx2 = Zx * Zx;\n    Zy2 = Zy * Zy;\n    for (t = 1; (t < t_max) && ((Zx2 + Zy2) < (esc_rad * esc_rad)); t++)\n    {\n      Zy = ((2 * Zx) * Zy) + y;\n      Zx = (Zx2 - Zy2) + x;\n      Zx2 = Zx * Zx;\n      Zy2 = Zy * Zy;\n    }\n\n    if (t == t_max)\n    {\n      color[0] = 0;\n      color[1] = 0;\n      color[2] = 0;\n    }\n    else\n    {\n      color[0] = 255;\n      color[1] = 255;\n      color[2] = 255;\n    }\n\n    ;\n    fseek(fp, (((iy * 800) + ix) * 3) + 22, 0);\n    fwrite(color, 1, 3, fp);\n  }\n\n}\n\n", "pragma": "omp parallel for private(y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ram-Aditya/Parallel-Computing/MandelBrot`s Set/Mandelbrot_Parallel/0"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  x[i] = 0.00001 * i;\n  y[i] = 0.00033 * i;\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-273738/clang-273738/0"}
{"code": "for (int i = 1; i <= N_a; i++)\n{\n  for (int j = 1; j <= N_b; j++)\n  {\n    if (H[i][j] == 0)\n      M[i][j] = 0;\n    else\n      if (seq_a[i - 1] == seq_b[j - 1])\n      M[i][j] = H[i - 1][j - 1];\n    else\n      M[i][j] = MAX(MAX(MAX(MAX(MAX(M[i - 1][j], H[i - 1][j]), M[i][j - 1]), H[i][j - 1]), M[i - 1][j - 1]), H[i - 1][j - 1]);\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SharanBabu/Parallel-Programming/plagiarism detection/hash_mpi/2"}
{"code": "for (int j = 1; j < (N - 1); j++)\n  s->Bt[j] = ((s->Mcoefs2[0][j] * x[j - 1]) + (s->Mcoefs2[1][j] * x[j])) + (s->Mcoefs2[2][j] * x[j + 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/131"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < b[i].size(); j++)\n  {\n    b[i][j].push_back(rand() % 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnomDevgun/ParallelComputing/openMP/cp/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrixC[i][j] = 0;\n    for (k = 0; k < o; k++)\n    {\n      matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekaryaREPO/Concurrent-Programming-with-Java-and-OpenMP/ASSIGNMENT 2-OpenMP/SOURCE CODE AND EXECUTABLES/MatrixMultiplicationUsingThreads/0"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = i % 120;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB047-doallchar-orig-no/0"}
{"code": "for (j = 0; j < Maze->Sections[0]; ++j)\n{\n  Maze->Nodes[0][j].Friends[3] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/15"}
{"code": "for (int i = size; i < (img.width() - size); i++)\n  for (int j = size; j < (img.height() - size); j++)\n{\n  float cont1 = 0.0;\n  float cont2 = 0.0;\n  float cont3 = 0.0;\n  for (int k = -size; k <= size; k++)\n  {\n    for (int k1 = -size; k1 <= size; k1++)\n    {\n      cont1 += img(i + k1, j + k, 0) * mask[k1 + size][k + size];\n      cont2 += img(i + k1, j + k, 1) * mask[k1 + size][k + size];\n      cont3 += img(i + k1, j + k, 2) * mask[k1 + size][k + size];\n    }\n\n  }\n\n  cont1 *= 1.0;\n  cont2 *= 1.0;\n  cont3 *= 1.0;\n  cont1 /= dim;\n  cont2 /= dim;\n  cont3 /= dim;\n  imgt(i, j, 0) = cont1;\n  imgt(i, j, 1) = cont2;\n  imgt(i, j, 2) = cont3;\n}\n\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic,1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amh28/Gaussian-Filter/convolution_parallel/0"}
{"code": "for (int i = 0; i < nOgrid; ++i)\n{\n  w[i] *= 0.166666666666667;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/4"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < cols; j++)\n{\n  a = adjacent_to(board, i, j, rows, cols);\n  if (a == 2)\n    newboard[(i * cols) + j] = board[(i * cols) + j];\n\n  if (a == 3)\n    newboard[(i * cols) + j] = 1;\n\n  if (a < 2)\n    newboard[(i * cols) + j] = 0;\n\n  if (a > 3)\n    newboard[(i * cols) + j] = 0;\n\n}\n\n\n", "pragma": "omp parallel for private(i, j, a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosevoul/parallel-game-of-life/src/play/0"}
{"code": "for (m = 3; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      n = ((m - 3) + 1) * 5;\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,k ,j1 ,j ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/181"}
{"code": "for (int i = 0; i < datas.size(); i++)\n{\n  int center_number = find_center(datas[i]);\n  omp_set_lock(&lock);\n  clusters[center_number].push_back(&datas[i]);\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/k-means/k-means-1/3"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < m; j++)\n  fscanf(inFile, \"%f\", (A + (i * m)) + j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZeyuuOne/Lab_2_OpenMP/Lab_2_OpenMP/main/0"}
{"code": "for (int i = 0; i < 1; i++)\n{\n  int array_offset_index = group_offsets[i];\n  size_t offset = (sizeof(array[0])) * group_offsets[i];\n  size_t bytes_being_read;\n  if (i != (1 - 1))\n    bytes_being_read = (sizeof(array[0])) * group_stride_workload;\n  else\n  {\n    bytes_being_read = (sizeof(array[0])) * (group_stride_workload + group_stride_remainder);\n  }\n\n  status = clEnqueueReadBuffer(commandQueue[i], *arrayBuffer, CL_TRUE, offset, bytes_being_read, array + array_offset_index, 0, 0, 0);\n  assert(status == CL_SUCCESS);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/3"}
{"code": "for (int j = 0; j < n; j++)\n  u[j] = 1.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emmanuellujan/2d-diff-eq-julia-vs-c-openmp/diffusion-parallel/2"}
{"code": "for (i = 0; i < LOCKNUM; i++)\n  omp_init_lock(&lck[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lockarray/7"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlusInverse->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/17"}
{"code": "for (i = 0; i < Core_N; i++)\n{\n  core_val[i] = ffrand(0, 1);\n  if (i == 0)\n  {\n    for (j = 0; j < order; j++)\n      core_index[j] = 0;\n\n  }\n  else\n  {\n    for (j = 0; j < order; j++)\n    {\n      core_index[(i * order) + j] = core_index[((i - 1) * order) + j];\n    }\n\n    core_index[((i * order) + order) - 1]++;\n    k = order - 1;\n    while (core_index[(i * order) + k] >= rrank)\n    {\n      core_index[(i * order) + k] -= rrank;\n      core_index[((i * order) + k) - 1]++;\n      k--;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/33"}
{"code": "for (int i = 0; i < numOfRowIndeces; ++i)\n{\n  const double AO_i = row_AO_values[i];\n  for (int j = 0; j < numOfColIndeces; ++j)\n  {\n    rho += (PA.get(i, j) * AO_i) * col_AO_values[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCalcGridX/2"}
{"code": "for (i = 0; i < p; ++i)\n  for (j = 0; j < q; ++j)\n  b[i][j] = 7;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sujoyyyy/High-Performance-Computing/Lab 2/matrix_multiplication/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  durParalelo[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HaslerUNMSM/PI-OpenMP/CalculoPI/3"}
{"code": "for (i = 0; i < 256; i++)\n{\n  life(grid1, grid2, 511);\n  swap = grid1;\n  grid1 = grid2;\n  grid2 = swap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SgtSwagrid/supercomputing/02 - Conway+RDF/life/5"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 4)\n    {\n      int pp = IDX(i, j, k);\n      DzDzu[pp] = (((((-u[pp - (2 * n)]) + (16.0 * u[pp - n])) - (30.0 * u[pp])) + (16.0 * u[pp + n])) - u[pp + (2 * n)]) * idz_sqrd_by_12;\n      DzDzu[pp + 1] = (((((-u[(pp + 1) - (2 * n)]) + (16.0 * u[(pp + 1) - n])) - (30.0 * u[pp + 1])) + (16.0 * u[(pp + 1) + n])) - u[(pp + 1) + (2 * n)]) * idz_sqrd_by_12;\n      DzDzu[pp + 2] = (((((-u[(pp + 2) - (2 * n)]) + (16.0 * u[(pp + 2) - n])) - (30.0 * u[pp + 2])) + (16.0 * u[(pp + 2) + n])) - u[(pp + 2) + (2 * n)]) * idz_sqrd_by_12;\n      DzDzu[pp + 3] = (((((-u[(pp + 3) - (2 * n)]) + (16.0 * u[(pp + 3) - n])) - (30.0 * u[pp + 3])) + (16.0 * u[(pp + 3) + n])) - u[(pp + 3) + (2 * n)]) * idz_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/20"}
{"code": "for (i = 0; password[i] != 0; i++)\n{\n  a += AdRandomNumbers[((i + password[i]) + userlength) & 0x7ff];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/cq_fmt_plug/2"}
{"code": "for (i = 0; i < cs; i++)\n  tmp += flush[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicoTolly/stage_openmp/cholesky/choleskyMP/common/polybench/0"}
{"code": "for (t = 0; t < tmax; t++)\n{\n  double *x = (double *) malloc((sizeof(double)) * nl);\n  double *y = (double *) malloc((sizeof(double)) * nl);\n  double **A = (double **) malloc((sizeof(double *)) * nl);\n  double **B = (double **) malloc((sizeof(double *)) * nl);\n  double **C = (double **) malloc((sizeof(double *)) * nl);\n  for (i = 0; i < nl; i++)\n  {\n    A[i] = (double *) malloc((sizeof(double)) * nc);\n    B[i] = (double *) malloc((sizeof(double)) * nc);\n    C[i] = (double *) malloc((sizeof(double)) * nc);\n    for (j = 0; j < nc; j++)\n    {\n      A[i][j] = rand() % 10;\n      B[i][j] = rand() % 10;\n      C[i][j] = 0;\n    }\n\n    x[i] = rand() % 10;\n    y[i] = 0;\n  }\n\n  printf(\"\\nProduit Matrice Vecteur \\n\");\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      for (j = 0; j < nc; j++)\n      {\n        printf(\"A%d%d %f\\n\", i, j, A[i][j]);\n      }\n\n    }\n\n    for (i = 0; i < nl; i++)\n    {\n      printf(\"x%d %f\\n\", i, x[i]);\n    }\n\n  }\n\n  debut = omp_get_wtime();\n  ProdMatVect(nc, nl, A, x, y);\n  fin = omp_get_wtime();\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      printf(\"y%d %f\\n\", i, y[i]);\n    }\n\n  }\n\n  printf(\"\\ntemps: %3.6f s\\n\", fin - debut);\n  fprintf(fichier, \"\\n%f;\", fin - debut);\n  printf(\"\\nProduit Matrice Matrice \\n\");\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      for (j = 0; j < nc; j++)\n      {\n        printf(\"A%d%d %f\\n\", i, j, A[i][j]);\n      }\n\n    }\n\n    for (i = 0; i < nl; i++)\n    {\n      for (j = 0; j < nc; j++)\n      {\n        printf(\"B%d%d %f\\n\", i, j, B[i][j]);\n      }\n\n    }\n\n  }\n\n  debut = omp_get_wtime();\n  ProdMatMat(nc, nl, A, B, &C);\n  fin = omp_get_wtime();\n  if (tmax == 1)\n  {\n    for (i = 0; i < nl; i++)\n    {\n      for (j = 0; j < nc; j++)\n      {\n        printf(\"C%d%d %f\\n\", i, j, C[i][j]);\n      }\n\n    }\n\n  }\n\n  printf(\"\\ntemps: %3.6f s\\n\", fin - debut);\n  fprintf(fichier, \"%f;\", fin - debut);\n  fprintf(fichier, \"%d;%d;\", nl, nc);\n  for (i = 0; i < nl; i++)\n  {\n    free(A[i]);\n    free(B[i]);\n    free(C[i]);\n  }\n\n  free(A);\n  free(B);\n  free(C);\n  free(x);\n  free(y);\n  nc *= 2;\n  nl *= 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex7/5"}
{"code": "for (k = 0; k < 3; k++)\n{\n  for (j = 0; j < N_y; j++)\n  {\n    for (i = 0; i < N_x; i++)\n    {\n      phi[i][j][k] = phi[i][j][k] + (Delta_t * ((((k1[i][j][k] / 6) + (k2[i][j][k] / 3)) + (k3[i][j][k] / 3)) + (k4[i][j][k] / 6)));\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DeanJanami/ShallowWaterEquations/SWE_op/4"}
{"code": "for (j = reachableSet->head; j < reachableSet->tail; j++)\n{\n  tempV = reachableSet->queue[j];\n  degreeTemp = graph->vertices->out_degree[tempV];\n  edgeTemp = graph->vertices->edges_idx[tempV];\n  for (k = edgeTemp; k < (edgeTemp + degreeTemp); k++)\n  {\n    tempU = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[k]);\n    while (stats->dest[stats->dest[tempU]] != stats->dest[tempU])\n    {\n      stats->dest[tempU] = stats->dest[stats->dest[tempU]];\n    }\n\n    setBitAtomic(bitmapNC, tempU);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/4"}
{"code": "for (i = 0; i < C.hpad; i++)\n  for (j = 0; j < C.stride; j++)\n{\n  C.elements[(i * C.stride) + j] = 0.0;\n  Cref.elements[(i * Cref.stride) + j] = 0.0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.hsa.c/tiling-1/3"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  dkx = dnx * ((float) j);\n  zt2 = cimagf(amu[1 + (6 * j)]) - (crealf(amu[1 + (6 * j)]) * _Complex_I);\n  zt3 = cimagf(amu[2 + (6 * j)]) - (crealf(amu[2 + (6 * j)]) * _Complex_I);\n  zt2 = dkx * zt2;\n  zt3 = dkx * zt3;\n  dcu[3 * j] = zero;\n  dcu[1 + (3 * j)] = zt2;\n  dcu[2 + (3 * j)] = zt3;\n  dcu[3 * (j + k1)] = zero;\n  dcu[1 + (3 * (j + k1))] = zero;\n  dcu[2 + (3 * (j + k1))] = zero;\n  dcu[3 * (j + l1)] = zero;\n  dcu[1 + (3 * (j + l1))] = zero;\n  dcu[2 + (3 * (j + l1))] = zero;\n  dcu[3 * ((j + k1) + l1)] = zero;\n  dcu[1 + (3 * ((j + k1) + l1))] = zero;\n  dcu[2 + (3 * ((j + k1) + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/24"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    scanf(\"%lf\", &phi[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiackAloZ/OPoly/benchmarks/src/omp-gauss-seidel-2d/2"}
{"code": "for (const_iterator r = faces2.begin(); r != faces2.end(); r++)\n  faces.push_back(Rect((smallImg.cols - r->x) - r->width, r->y, r->width, r->height));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/ComputerVision/ufacedetect/4"}
{"code": "for (i = 0; i < 64; i++)\n{\n  array[i] = 0;\n  printf(\"ZERO_SETTING: Thread %d set index %d to %d\\n\", omp_get_thread_num(), i, array[i]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/david-kishi/Learning-Parallelized-Computing/Homework/04/array_loops/0"}
{"code": "for (i = 1; i <= 100; ++i)\n{\n  for (j = 1; j <= 100; ++j)\n  {\n    org[i][j] = h[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Jacob_iterations_OpenMP/6"}
{"code": "for (int itonos = 0; itonos < halfN; ++itonos)\n{\n  int i = (itonos << 1) - (itonos & maskj);\n  int ij = i ^ j;\n  if (a[i] > a[ij])\n  {\n    exchange(i, ij);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kipoujr/bitonic/openmp/5"}
{"code": "for (i = 0; i < reDim; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FrancoLeal/hpcLab2_OpenMP/funciones/3"}
{"code": "for (row = 0; row < 1024; row++)\n  for (col = 0; col < 1024; col++)\n  B[(row * 1024) + col] = rand();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Indrasish117/Parallel-Matrix-multiplication-in-C-using-OpenMP/MatrixMul/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (k = 0; k < p; k++)\n  {\n    D[(i * p) + k] *= beta;\n    for (j = 0; j < n; j++)\n      D[(i * p) + k] += (alpha * A[(i * n) + j]) * B[(j * p) + k];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bhaskariitm/OpenMP-codes/Code/0"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  for (j = 0; j < 4096; j++)\n  {\n    if (percentDiff(C[(i * 4096) + j], C_Gpu[(i * 4096) + j]) > 0.10)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYR2K/syr2k_cpu/7"}
{"code": "for (int i = 0; i < (rows * cols); ++i)\n{\n  outPixels[i].red = 0.0;\n  outPixels[i].green = 0.0;\n  outPixels[i].blue = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/llama95/Parallel_Programming/Patterns/stencil/openmp/9"}
{"code": "for (int k = instance->ptr[current_option]; k < p; k++)\n  if (item_number == instance->options[k])\n  errx(1, \"Objet %s r\u00e9p\u00e9t\u00e9 dans l'option %d\\n\", instance->item_name[item_number], current_option);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/14"}
{"code": "for (i = 0; i < cache->sets; i++)\n{\n  cache->cacheLines[i] = (struct CacheLine *) my_malloc((cache->assoc + 1) * (sizeof(struct CacheLine)));\n  for (j = 0; j < (cache->assoc + 1); j++)\n  {\n    invalidate(&cache->cacheLines[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < 2; j++)\n  {\n    A[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sharatchandraj/Gaussian-Process-Regression-OpenMP/GPR/1"}
{"code": "for (ny = 0; ny < n; ny += block_size)\n{\n  pe += eval_pef_sub_level_2(n, delta, grav, sep, fcon, x, y, z, fx, fy, fz, nx, ny, block_size);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abu-abraham/open-MP/examples/Cloth Simulation/kernel_main_omp_block/0"}
{"code": "for (i = 0; i < thread_count; ++i)\n{\n  if (finished[i])\n    continue;\n\n  if (first)\n  {\n    min = a[keys[i]];\n    first = false;\n    minkey_index = i;\n  }\n  else\n    if (a[keys[i]] < min)\n  {\n    min = a[keys[i]];\n    minkey_index = i;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JiangLu-CS/High-Performance-Computing-Experiments/openMPMultiThread/openMPMultiThread/openMPMultiThread/2"}
{"code": "for (int i = 0; i < noOfChar; i++)\n{\n  messageStream << symbol;\n  encodedStream << encoder.Encode2(symbol);\n  symbol = inputFile.get();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MeetSable/Huffman-encoding-and-Adaptive-Huffman-encoding-OpenMP/adaptiveHuffman/0"}
{"code": "for (int i = 0; i < length; i++)\n{\n  (cout << vector[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task8/3"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * (((5.0 * u[i][j][k][m_imopVar133]) - (4.0 * u[i + 1][j][k][m_imopVar133])) + u[i + 2][j][k][m_imopVar133]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/60"}
{"code": "for (int c = 0; c < old_no; ++c)\n{\n  const double *weights = wf_[c];\n  for (int i = 0; i < ni; ++i)\n    means[i] += weights[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/3"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  xcrdif[m] = fabs((xcr[m] - xcrref[m]) / xcrref[m]);\n  xcedif[m] = fabs((xce[m] - xceref[m]) / xceref[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/151"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = 1.0 * i;\n  b[i] = 2.10 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rishdas/hpc/assignment2/problem2/1"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  norm_temp11 = norm_temp11 + (x[j] * z[j]);\n  norm_temp12 = norm_temp12 + (z[j] * z[j]);\n}\n\n", "pragma": "omp for reduction(+:norm_temp11,norm_temp12)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/2"}
{"code": "for (j = 0; j < HEIGHT; j++)\n{\n  for (i = 0; i < WIDTH; i++)\n  {\n    fprintf(fp, \"%d \", pixels[i + (j * WIDTH)]);\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/mandelbrot-hybrid/0"}
{"code": "for (int j = 0; j < m; j++)\n{\n  for (i = 0; i < n; i++)\n  {\n    pC[j][i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCMMA/10"}
{"code": "for (i = k; i < len2; i++)\n  score = score + scoringMatrix[i][(i + n) + 1];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/calculations/1"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) VF[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/118"}
{"code": "for (i = 0; i < 512; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/24"}
{"code": "for (i = 0; i < (1 << 27); i++)\n  key_buff2[i] = 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/13"}
{"code": "for (n = 0; n < 5; n++)\n{\n  lhs[i][j][k][0][m][n] = 0.0;\n  lhs[i][j][k][1][m][n] = 0.0;\n  lhs[i][j][k][2][m][n] = 0.0;\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,n ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/51"}
{"code": "for (k = 0; k < grid_points[2]; k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    lhs[i][j][k][1][m][m] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/54"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][1][m] = rsd[i][j][1][m] - (dssp * ((((+5.0) * u[i][j][1][m]) - (4.0 * u[i][j][2][m])) + u[i][j][3][m]));\n  rsd[i][j][2][m] = rsd[i][j][2][m] - (dssp * (((((-4.0) * u[i][j][1][m]) + (6.0 * u[i][j][2][m])) - (4.0 * u[i][j][3][m])) + u[i][j][4][m]));\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/120"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmplc9jdiri.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/projects/openmp/runtime/test/affinity/format/affinity_values/1"}
{"code": "for (int j = i + 1; j < (N - 1); j++)\n{\n  for (int k = j + 1; k < N; k++)\n  {\n    float det = ((((((v[i][0] * v[j][1]) * v[k][2]) + ((v[i][1] * v[j][2]) * v[k][0])) + ((v[i][2] * v[j][0]) * v[k][1])) - ((v[i][2] * v[j][1]) * v[k][0])) - ((v[i][0] * v[j][2]) * v[k][1])) - ((v[i][1] * v[j][0]) * v[k][2]);\n    if (abs(det) < EPS)\n    {\n      printf(\"%d %d %d: det=%.1f \\t - complanar\\n\", i, j, k, det);\n      complanar_count++;\n    }\n    else\n    {\n      printf(\"%d %d %d: det=%.1f\\n\", i, j, k, det);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kirillston/OpenMP-MPI/7_2/serial/0"}
{"code": "for (i = n - 2; i >= 0; i--)\n{\n  x[i] = a[i][n];\n  for (j = i + 1; j < n; j++)\n  {\n    x[i] = x[i] - (a[i][j] * x[j]);\n  }\n\n  x[i] = x[i] / a[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amal-meer/Gaussian-Elimination-Parallelism-using-OpenMP-and-MPI/GaussianElimination/1"}
{"code": "for (i = 0; i < n; i++)\n  result = result + (a[i] * b[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static, chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarthaCarrillo/OpenMP/openmp/parallelfor_00/0"}
{"code": "for (k = 0; k < rct; k++)\n{\n  float *row = (float *) malloc(cct * (sizeof(float)));\n  if (row == 0)\n  {\n    fprintf(stderr, \"row Couldn't alocate sufficient row space.\\n\");\n    exit(1);\n  }\n\n  sh_rows[k] = row;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hailuy/os_week10/findvals/1"}
{"code": "for (j = 0; j < n; j++)\n  kc1[j] = kc[j];\n\n", "pragma": "            #pragma omp parallel for shared(j,kc,kc1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/kMeans/3"}
{"code": "for (int i = 0; i < np; i++)\n{\n  destino_mat[i] = origem_mat[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JonatasDelatorre/Modelo_HPP_OpenMP/trabalhoHPP/1"}
{"code": "for (int i = 0; i < time_steps; i++)\n{\n  time_step();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/8"}
{"code": "for (i = 1; i < 1; i++)\n  for (j = 0; j < 1; j++)\n  ys[(i * 1) + j] = ys[((i - 1) * 1) + j] + ycell;\n\n\n", "pragma": "omp parallel for num_threads(NUMTHREADS) collapse(2) schedule (static,1) default(none) private(i,j) shared(ys, ycell)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/1"}
{"code": "for (int i = 0; i < (rows * cols); i++)\n  clone[i] = img[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/delchiaro/parallel-project/src/mainSimpleStructured/3"}
{"code": "for (vertex_id = 0; vertex_id < graphCSR->num_edges; vertex_id++)\n{\n  fwrite(&graphCSR->sorted_edges_array->edges_array_src[vertex_id], sizeof(graphCSR->sorted_edges_array->edges_array_src[vertex_id]), 1, pBinary);\n  fwrite(&graphCSR->sorted_edges_array->edges_array_dest[vertex_id], sizeof(graphCSR->sorted_edges_array->edges_array_dest[vertex_id]), 1, pBinary);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphCSR/2"}
{"code": "for (float fi = 0; fi < 10.0; fi++)\n{\n  c[(int) fi] = a[(int) fi] + b[(int) fi];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/6"}
{"code": "for (k = 0; k < 80800; k++)\n  histo[k].freq = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/word_count/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, q[i]);\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/bicg/bicg/5"}
{"code": "for (int i1 = 0; i1 < N1; i1++)\n{\n  for (int i2 = 0; i2 < N2; i2++)\n  {\n    for (int i3 = 0; i3 < N3; i3++)\n    {\n      for (int i4 = 0; i4 < N4; i4++)\n      {\n        RES[4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)] = A1[i1];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 1] = A2[i2];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 2] = A3[i3];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 3] = A4[i4];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AleiynikovPavel/OpenMPLab7/main/0"}
{"code": "for (i = 0; i < numClusters; i++)\n{\n  diameters[i] = diametersThreads[i];\n  for (j = 1; j < threadsNum; j++)\n  {\n    if (diameters[i] < diametersThreads[(j * numClusters) + i])\n      diameters[i] = diametersThreads[(j * numClusters) + i];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/10"}
{"code": "for (int rep = 0; rep < total_reps; rep++)\n{\n  MPI_Isend(&src_buf[0], 3, MPI_CHAR, rUleft, DIR_ULEFT, cartesian, &sendRequests[DIR_ULEFT]);\n  MPI_Isend(src_buf, blockwidth, MPI_CHAR, rUp, DIR_UP, cartesian, &sendRequests[DIR_UP]);\n  MPI_Isend(&src_buf[blockwidth - 3], 3, MPI_CHAR, rUright, DIR_URIGHT, cartesian, &sendRequests[DIR_URIGHT]);\n  MPI_Isend(src_buf, 1, type_column_rgb, rLeft, DIR_LEFT, cartesian, &sendRequests[DIR_LEFT]);\n  MPI_Isend(&src_buf[blockwidth - 3], 1, type_column_rgb, rRight, DIR_RIGHT, cartesian, &sendRequests[DIR_RIGHT]);\n  MPI_Isend(&src_buf[(blockheight - 1) * blockwidth], 3, MPI_CHAR, rDleft, DIR_DLEFT, cartesian, &sendRequests[DIR_DLEFT]);\n  MPI_Isend(&src_buf[(blockheight - 1) * blockwidth], blockwidth, MPI_CHAR, rDown, DIR_DOWN, cartesian, &sendRequests[DIR_DOWN]);\n  MPI_Isend(&src_buf[(blockheight * blockwidth) - 3], 3, MPI_CHAR, rDright, DIR_DRIGHT, cartesian, &sendRequests[DIR_DRIGHT]);\n  sendRequests[DIR_CENTER] = MPI_REQUEST_NULL;\n  MPI_Irecv(&ulCorner, 3, MPI_CHAR, rUleft, DIR_DRIGHT, cartesian, &recvRequests[DIR_ULEFT]);\n  MPI_Irecv(upRow, blockwidth, MPI_CHAR, rUp, DIR_DOWN, cartesian, &recvRequests[DIR_UP]);\n  MPI_Irecv(&urCorner, 3, MPI_CHAR, rUright, DIR_DLEFT, cartesian, &recvRequests[DIR_URIGHT]);\n  MPI_Irecv(leftCol, blockheight * 3, MPI_CHAR, rLeft, DIR_RIGHT, cartesian, &recvRequests[DIR_LEFT]);\n  MPI_Irecv(rightCol, blockheight * 3, MPI_CHAR, rRight, DIR_LEFT, cartesian, &recvRequests[DIR_RIGHT]);\n  MPI_Irecv(&dlCorner, 3, MPI_CHAR, rDleft, DIR_URIGHT, cartesian, &recvRequests[DIR_DLEFT]);\n  MPI_Irecv(downRow, blockwidth, MPI_CHAR, rDown, DIR_UP, cartesian, &recvRequests[DIR_DOWN]);\n  MPI_Irecv(&drCorner, 3, MPI_CHAR, rDright, DIR_ULEFT, cartesian, &recvRequests[DIR_DRIGHT]);\n  recvRequests[DIR_CENTER] = MPI_REQUEST_NULL;\n  for (int i = 1; i < (blockheight - 1); i++)\n    for (int l = 3; l < (blockwidth - 3); l++)\n  {\n    unsigned int offset = (i * blockwidth) + l;\n    unsigned int val = ((src_buf[(offset - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[offset - blockwidth] * filter[DIR_DOWN])) + (src_buf[(offset - blockwidth) + 3] * filter[DIR_DLEFT]);\n    ;\n    val += ((src_buf[offset] * filter[DIR_CENTER]) + (src_buf[offset - 3] * filter[DIR_RIGHT])) + (src_buf[offset + 3] * filter[DIR_LEFT]);\n    ;\n    val += ((src_buf[(offset + blockwidth) - 3] * filter[DIR_URIGHT]) + (src_buf[offset + blockwidth] * filter[DIR_UP])) + (src_buf[(offset + blockwidth) + 3] * filter[DIR_ULEFT]);\n    ;\n    val /= filt_total;\n    dest_buf[offset] = ((char) val) & 0xFF;\n  }\n\n\n  MPI_Waitall(8, recvRequests, MPI_STATUSES_IGNORE);\n  for (int i = 3; i < (blockwidth - 3); i++)\n  {\n    unsigned int val = ((src_buf[i] * filter[DIR_CENTER]) + (src_buf[i - 3] * filter[DIR_RIGHT])) + (src_buf[i + 3] * filter[DIR_LEFT]);\n    ;\n    val += ((src_buf[(i + blockwidth) - 3] * filter[DIR_URIGHT]) + (src_buf[i + blockwidth] * filter[DIR_UP])) + (src_buf[(i + blockwidth) + 3] * filter[DIR_ULEFT]);\n    ;\n    val += upRow[i - 3] * filter[DIR_DRIGHT];\n    val += upRow[i] * filter[DIR_DOWN];\n    val += upRow[i + 3] * filter[DIR_DLEFT];\n    val /= filt_total;\n    dest_buf[i] = ((char) val) & 0xFF;\n  }\n\n  unsigned int last_line = (blockheight - 1) * blockwidth;\n  for (int i = 3; i < (blockwidth - 3); i++)\n  {\n    unsigned int val = ((src_buf[((last_line + i) - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[(last_line + i) - blockwidth] * filter[DIR_DOWN])) + (src_buf[((last_line + i) - blockwidth) + 3] * filter[DIR_DLEFT]);\n    ;\n    val += ((src_buf[last_line + i] * filter[DIR_CENTER]) + (src_buf[(last_line + i) - 3] * filter[DIR_RIGHT])) + (src_buf[(last_line + i) + 3] * filter[DIR_LEFT]);\n    ;\n    val += downRow[i - 3] * filter[DIR_URIGHT];\n    val += downRow[i] * filter[DIR_UP];\n    val += downRow[i + 3] * filter[DIR_ULEFT];\n    val /= filt_total;\n    dest_buf[last_line + i] = ((char) val) & 0xFF;\n  }\n\n  unsigned int base = 0;\n  unsigned int val = 0;\n  for (unsigned char stream = 0; stream < 3; stream++)\n  {\n    for (unsigned int i = 1; i < (blockheight - 1); i++)\n    {\n      base = (i * blockwidth) + stream;\n      val = ((src_buf[base] * filter[DIR_CENTER]) + (src_buf[base - blockwidth] * filter[DIR_DOWN])) + (src_buf[base + blockwidth] * filter[DIR_UP]);\n      ;\n      val += ((src_buf[(base - blockwidth) + 3] * filter[DIR_DLEFT]) + (src_buf[base + 3] * filter[DIR_LEFT])) + (src_buf[(base + blockwidth) + 3] * filter[DIR_ULEFT]);\n      ;\n      val += leftCol[((i - 1) * 3) + stream] * filter[DIR_DRIGHT];\n      val += leftCol[(i * 3) + stream] * filter[DIR_RIGHT];\n      val += leftCol[((i + 1) * 3) + stream] * filter[DIR_URIGHT];\n      val /= filt_total;\n      dest_buf[base] = ((char) val) & 0xFF;\n    }\n\n    for (unsigned int i = 1; i < (blockheight - 1); i++)\n    {\n      base = (((i + 1) * blockwidth) - 3) + stream;\n      val = ((src_buf[base] * filter[DIR_CENTER]) + (src_buf[base - blockwidth] * filter[DIR_DOWN])) + (src_buf[base + blockwidth] * filter[DIR_UP]);\n      ;\n      val += ((src_buf[(base - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[base - 1] * filter[DIR_RIGHT])) + (src_buf[(base + blockwidth) - 3] * filter[DIR_URIGHT]);\n      ;\n      val += rightCol[((i - 1) * 3) + stream] * filter[DIR_DLEFT];\n      val += rightCol[(i * 3) + stream] * filter[DIR_LEFT];\n      val += rightCol[((i + 1) * 3) + stream] * filter[DIR_ULEFT];\n      val /= filt_total;\n      dest_buf[base] = ((char) val) & 0xFF;\n    }\n\n    val = src_buf[stream] * filter[DIR_CENTER];\n    val += src_buf[stream + 3] * filter[DIR_LEFT];\n    val += src_buf[stream + blockwidth] * filter[DIR_UP];\n    val += src_buf[(stream + blockwidth) + 3] * filter[DIR_ULEFT];\n    val += upRow[stream] * filter[DIR_DOWN];\n    val += upRow[stream + 3] * filter[DIR_DLEFT];\n    val += leftCol[stream] * filter[DIR_RIGHT];\n    val += leftCol[stream + 3] * filter[DIR_URIGHT];\n    val += ulCorner[stream] * filter[DIR_DRIGHT];\n    val /= filt_total;\n    dest_buf[stream] = ((char) val) & 0xFF;\n    base = (blockwidth + stream) - 3;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base - 3] * filter[DIR_RIGHT];\n    val += src_buf[base + blockwidth] * filter[DIR_UP];\n    val += src_buf[(base + blockwidth) - 3] * filter[DIR_URIGHT];\n    val += upRow[base] * filter[DIR_DOWN];\n    val += upRow[base - 3] * filter[DIR_DRIGHT];\n    val += rightCol[stream] * filter[DIR_LEFT];\n    val += rightCol[stream + 3] * filter[DIR_ULEFT];\n    val += urCorner[stream] * filter[DIR_DLEFT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n    base = ((blockheight - 1) * blockwidth) + stream;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base + 3] * filter[DIR_LEFT];\n    val += src_buf[base - blockwidth] * filter[DIR_DOWN];\n    val += src_buf[(base - blockwidth) + 3] * filter[DIR_DLEFT];\n    val += downRow[stream] * filter[DIR_UP];\n    val += downRow[stream + 3] * filter[DIR_ULEFT];\n    val += leftCol[(blockheight + stream) - 3] * filter[DIR_RIGHT];\n    val += leftCol[(blockheight + stream) - 6] * filter[DIR_DRIGHT];\n    val += dlCorner[stream] * filter[DIR_URIGHT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n    base = ((blockheight * blockwidth) + stream) - 3;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base - 3] * filter[DIR_RIGHT];\n    val += src_buf[base - blockwidth] * filter[DIR_DOWN];\n    val += src_buf[(base - blockwidth) - 3] * filter[DIR_DRIGHT];\n    val += downRow[(blockwidth + stream) - 3] * filter[DIR_UP];\n    val += downRow[(blockwidth + stream) - 6] * filter[DIR_URIGHT];\n    val += rightCol[(blockheight + stream) - 3] * filter[DIR_LEFT];\n    val += rightCol[(blockheight + stream) - 6] * filter[DIR_DLEFT];\n    val += drCorner[stream] * filter[DIR_ULEFT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n  }\n\n  MPI_Waitall(8, sendRequests, MPI_STATUSES_IGNORE);\n  unsigned char *tmp = dest_buf;\n  dest_buf = src_buf;\n  src_buf = tmp;\n  if ((rep & 31) == 31)\n  {\n    unsigned char any_diff;\n    unsigned char diff = 0;\n    for (int i = 0; i < (blockwidth * blockheight); i++)\n      if (src_buf[i] != dest_buf[i])\n    {\n      diff = 1;\n      break;\n    }\n\n\n    MPI_Reduce(&diff, &any_diff, 1, MPI_CHAR, MPI_MAX, 0, cartesian);\n    MPI_Bcast(&any_diff, 1, MPI_CHAR, 0, cartesian);\n    if (any_diff == 0)\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikofil/convolution/mpi/convolution/3"}
{"code": "for (int i = 0; i < WDOT_SIZE; i++)\n{\n  host_molwt[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/s3d-omp/S3D/1"}
{"code": "for (unsigned int i = 0; i < list.size(); i++)\n{\n  if (list[i] == edge)\n    ret = true;\n\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex-87/HyperGraphLib/src/algorithm/Connected/1"}
{"code": "for (int j = 0; j < m.y; j++)\n{\n  for (int i = 0; i < m.x; i++)\n  {\n    in >> m.m[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GromHoll/Kat-8sem-PP-sum/sum/0"}
{"code": "for (i = 2; i < limit; i++)\n{\n  if (primes[i])\n  {\n    for (j = i; (i * j) < limit; j++)\n    {\n      primes[i * j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunalkhade/Sieve-of-Eratosthenes/SieveEratosthenes/0"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    if (rowval[j] != 0.0)\n      rowval[j] = 1 + (((rowval[j] > 0.0) ? (log(rowval[j])) : (-log(-rowval[j]))) * logscale);\n\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/58"}
{"code": "for (j = 1; j < m; j++)\n  b[i][j] = b[i][j] * 2;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rutgers-apl/omp-racer/tests/microbenchmarks/reclamation_test/test_1/0"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  mat[i][j] = (1.3 * i) * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rishdas/hpc/assignment2/matrix_mult/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    matrix[(j * n) + i] = matrix[(j * n) + i] + matrix[(i * n) + j];\n    matrix[(i * n) + j] = matrix[(j * n) + i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/4"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp84zgwp6o.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/llvm-openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (i = bestOffs - SCANWIND; i < end; i++)\n{\n  if (i == bestOffs)\n    continue;\n\n  corr = (float) calcCrossCorr(refPos + (channels * i), pMidBuffer, norm);\n  float tmp = ((float) (((2 * i) - seekLength) - 1)) / ((float) seekLength);\n  corr = (corr + 0.1f) * (1.0f - ((0.25f * tmp) * tmp));\n  if (corr > bestCorr)\n  {\n    bestCorr = corr;\n    bestOffs = i;\n    best = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/branches/OpenMPT-1.25/include/soundtouch/source/SoundTouch/TDStretch/0"}
{"code": "for (int i = 0; i < l; i++)\n  update_alpha_status(i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/4"}
{"code": "for (int j = 0; j < CutOffPrint; j++)\n  printf(\"%.2f \", c[i][j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    for (int k = 0; k < size; k++)\n    {\n      result[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sajidamro/eclipse-workspace/Lab_1/matrix_Multi/1"}
{"code": "for (uint i = 1; i < numBlocks; ++i)\n{\n  for (uint j = 0; j < numBuckets; ++j)\n  {\n    uint delta = blockHistograms[((i - 1) * numBuckets) + j] + offsets[j];\n    blockExScan[(i * numBuckets) + j] += delta;\n    offsets[j] += blockHistograms[((i - 1) * numBuckets) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/2"}
{"code": "for (i = 0; i < (matrixsize + 1); i++)\n  row[i] = (multiplier * rowj[i]) + row[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/11"}
{"code": "for (int i = 0; i < line.length(); i++)\n{\n  char c = line.at(i);\n  if (c == ' ')\n  {\n    if (first_num == 0)\n    {\n      int n = stoi(str);\n      city_id = n;\n    }\n\n    if (first_num == 1)\n    {\n      double p = atof(str.c_str());\n      city_x = p;\n    }\n\n    str = \"\";\n    first_num++;\n  }\n  else\n  {\n    str += c;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prachi220/Parallel-Programming/Travelling Salesman Problem/tsp_2014CS50289/10"}
{"code": "for (i = 0; i < image->row; i++)\n{\n  for (j = 0; j < image->col; j++)\n  {\n    histo[iam][image->content[i][j]]++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_creative/0"}
{"code": "for (i = 0; i < omp_num_devices; i++)\n{\n  omp_device_t *dev = &omp_devices[i];\n  dev->status = 1;\n  dev->resident_data_maps = 0;\n  dev->offload_request = 0;\n  dev->offload_stack_top = -1;\n  int rt = pthread_create(&dev->helperth, &attr, (void *(*)(void *)) helper_thread_main, (void *) dev);\n  if (rt)\n  {\n    fprintf(stderr, \"cannot create helper threads for devices.\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/6"}
{"code": "for (i = 0; i < (the_index * the_index); i++)\n{\n  int row = i / the_index;\n  int column = i % the_index;\n  int k;\n  for (k = 0; k < the_index; k++)\n  {\n    simple_mult((double (*)[1024]) (&C[row * b][column * b]), (double (*)[1024]) (&A[row * b][k * b]), (double (*)[1024]) (&B[k * b][column * b]), b);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/msagor/parallel_matrix_block_multiplication/matrix_block_multiplication_in_parallel_using_openMP/mult/0"}
{"code": "for (int i = 0; i < A.Rows; i++)\n{\n  for (int j = 0; j < Bt.Rows; j++)\n  {\n    float sum = 0.0f;\n    for (int k = 0; k < A.Cols; k++)\n    {\n      sum += arrayA[i][k] * arrayBt[j][k];\n    }\n\n    arrayD[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/Prob3/Prob3/Parallel/0"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/108"}
{"code": "for (i = 0; i < rows; i++)\n  array[i] = &data[cols * i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/3"}
{"code": "for (j = 0; j < n; j++)\n{\n  if ((visited[j] == 0) && (min_edge[j][0] < fmin_local))\n  {\n    fmin_local = min_edge[j][0];\n    index_local = j;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stefanusgusega/mst-openmp-openmpi/src/MST_OpenMP/0"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      Pdqdx_4d[LOC4D(i, j, k, m)] = 0.0;\n      Pdqdx_4d[LOC4D(i, j, k, m)] = 0.0;\n      Pdqdx_4d[LOC4D(i, j, k, m)] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/3"}
{"code": "for (i = 0; i < OUTPUTS; i++)\n{\n  for (j = 0; j < SAMPLES; j++)\n  {\n    (((cout << setprecision(2)) << fixed) << ATV2[i][j]) << \"\\t\";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Functional/parallel/parallel_feed/0"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  jsum = 0.0;\n  for (j = 0; j < numParticles; j++)\n  {\n    if (i == j)\n      continue;\n\n    difference = calcDistanceInverseSquared(p[i], p[j]);\n    if (difference == 0)\n      continue;\n\n    difference -= distanceMean;\n    jsum += difference * difference;\n  }\n\n  isum += jsum / (numParticles - 1);\n}\n\n", "pragma": "omp for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/9"}
{"code": "for (i = 0; i < 13; i += 3)\n{\n  printf(\"Second Hello %d\\n\", i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-nowait/2"}
{"code": "for (int i = 0; i < W_Comb; i++)\n{\n  x_sampt[i] = origx[offset + (i * sigma)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/evanmacbride/parallel-fft/original-sources/sFFT-1.0-2.0-par-openacc/sFFT-1.0-2.0-par-openacc/computefourier/4"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = grid_points[2] - 2; k >= 0; k += -1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      for (n = 0; n <= 4; n += 1)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i][j][k + 1][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/147"}
{"code": "for (i = 0; i < mat1_1d; i++)\n{\n  for (j = 0; j < mat1_2d; j++)\n  {\n    printf(\"%4.2f \", matr1[i][j]);\n    if (j == (mat1_2d - 1))\n      printf(\"\\n\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/7"}
{"code": "for (int i = 0; i < replot.size(); i++)\n{\n  searchID = replot[i][10].toInt(0, 16);\n  if (searchID % 2)\n  {\n    pairID = searchID + 1;\n  }\n  else\n  {\n    pairID = searchID - 1;\n  }\n\n  for (int j = 0; j < pixelList.size(); j++)\n  {\n    if (pixelList[j][0] == replot[i][0])\n    {\n      tmp1.clear();\n      for (int m = 0; m < 25; m++)\n      {\n        tmp1.append(pixelList[j][m]);\n      }\n\n      tmp2.append(tmp1);\n      break;\n    }\n\n  }\n\n  for (int j = 0; j < pixelList.size(); j++)\n  {\n    if (((pixelList[j][10].toInt(0, 16) == pairID) && (replot[i][11] == pixelList[j][11])) && (replot[i][12] == pixelList[j][12]))\n    {\n      tmp1.clear();\n      for (int m = 0; m < 25; m++)\n      {\n        tmp1.append(pixelList[j][m]);\n      }\n\n      tmp2.append(tmp1);\n      break;\n    }\n\n  }\n\n  p.setValue(i);\n  p.show();\n  processEvents();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/50"}
{"code": "for (int i = 0; i < (N - 1); i += 2)\n{\n  if (A[i] > A[i + 1])\n  {\n    int temp = A[i];\n    A[i] = A[i + 1];\n    A[i + 1] = temp;\n    exch0 = 1;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Joycepy/ParallelProgramming/openmp/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  particles[i].ax = ((double) particles[i].fx) / particles[i].m;\n  particles[i].ay = ((double) particles[i].fy) / particles[i].m;\n  particles[i].vx = particles[i].vx + (delta_t * particles[i].ax);\n  particles[i].vy = particles[i].vy + (delta_t * particles[i].ay);\n  double updt = particles[i].vx * delta_t;\n  particles[i].sx = adjust_pos(particles[i].sx, updt);\n  updt = particles[i].vy * delta_t;\n  particles[i].sy = adjust_pos(particles[i].sy, updt);\n}\n\n", "pragma": "            #pragma omp for schedule(static, chunks)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkmandke/nbody/src/barnes_openmp/1"}
{"code": "for (c2 = 0; c2 <= 499; c2 += 1)\n{\n  for (c8 = 1; c8 <= 499; c8 += 1)\n  {\n    B[c2][c8] = B[c2][c8] - ((A[c2][c8] * A[c2][c8]) / B[c2][c8 - 1]);\n  }\n\n  for (c8 = 1; c8 <= 499; c8 += 1)\n  {\n    X[c2][c8] = X[c2][c8] - ((X[c2][c8 - 1] * A[c2][c8]) / B[c2][c8 - 1]);\n  }\n\n  for (c8 = 0; c8 <= 497; c8 += 1)\n  {\n    X[c2][(500 - c8) - 2] = (X[c2][(500 - 2) - c8] - (X[c2][((500 - 2) - c8) - 1] * A[c2][(500 - c8) - 3])) / B[c2][(500 - 3) - c8];\n  }\n\n}\n\n", "pragma": "omp parallel for private (c2,c8)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB043-adi-parallel-no/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/97"}
{"code": "for (i = 0; i < numChildren; i++)\n{\n  nodePtr = &n[i];\n  nodePtr->height = parent->height + 1;\n  for (j = 0; j < computeGranularity; j++)\n  {\n    rng_spawn(parent->state.state, nodePtr->state.state, i);\n  }\n\n  nodePtr->numChildren = uts_numChildren(nodePtr);\n  _taskFunc1_((void *) 0, numChildren);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/uts/src/uts_ompi_trim/0"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float a = 1. + (tn * tn);\n  float b = (-2.) * (xc + (yc * tn));\n  float c = ((xc * xc) + (yc * yc)) - (r * r);\n  float d = (b * b) - ((4. * a) * c);\n  if (d < 0)\n  {\n    continue;\n  }\n\n  d = sqrt(d);\n  float t1 = ((-b) + d) / (2. * a);\n  float t2 = ((-b) - d) / (2. * a);\n  float tmin = (t1 < t2) ? (t1) : (t2);\n  if (tmin < 0)\n  {\n    continue;\n  }\n\n  float xcir = tmin;\n  float ycir = tmin * tn;\n  float nx = xcir - xc;\n  float ny = ycir - yc;\n  float nxy = sqrt((nx * nx) + (ny * ny));\n  nx /= nxy;\n  ny /= nxy;\n  float inx = xcir - 0.;\n  float iny = ycir - 0.;\n  float in = sqrt((inx * inx) + (iny * iny));\n  inx /= in;\n  iny /= in;\n  float dot = (inx * nx) + (iny * ny);\n  float outx = inx - ((2. * nx) * dot);\n  float outy = iny - ((2. * ny) * dot);\n  float tt = (0. - ycir) / outy;\n  if (tt < 0)\n  {\n    continue;\n  }\n\n  numHits++;\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(xcs,ycs,rs,tn) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulienMinato/Using-Cpp-Parallel-Programming/pro1/pro1/0"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  printf(\"i = %d, threadID = %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  for (y = 0; y < countOnes; y++)\n  {\n    indX = roundDouble(arrayX[x]) + objxy[(y * 2) + 1];\n    indY = roundDouble(arrayY[x]) + objxy[y * 2];\n    ind[(x * countOnes) + y] = fabs((((indX * IszY) * Nfr) + (indY * Nfr)) + k);\n    if (ind[(x * countOnes) + y] >= max_size)\n      ind[(x * countOnes) + y] = 0;\n\n  }\n\n  likelihood[x] = 0;\n  for (y = 0; y < countOnes; y++)\n    likelihood[x] += (pow(I[ind[(x * countOnes) + y]] - 100, 2) - pow(I[ind[(x * countOnes) + y]] - 228, 2)) / 50.0;\n\n  likelihood[x] = likelihood[x] / ((double) countOnes);\n}\n\n", "pragma": "omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/3"}
{"code": "for (int j = 1; j < (n - 1); j++)\n{\n  for (int i = 1; i < (m - 1); i++)\n  {\n    A[j][i] = Anew[j][i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jefflarkin/GTC16-S6510/c99/01-threaded-fused/laplace2d/1"}
{"code": "for (i = 0; i < edgeList->num_edges; i++)\n{\n  uint32_t src;\n  uint32_t dest;\n  src = edgeList->edges_array_src[i];\n  dest = edgeList->edges_array_dest[i];\n  edgeList->edges_array_src[i] = labels[src];\n  edgeList->edges_array_dest[i] = labels[dest];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/10"}
{"code": "for (i = 0; i < n; ++i)\n  r += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/ex3/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    C[i][j] = A[i][j] - B[i][j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YShoun/matrix-mul/main/5"}
{"code": "for (int i = 0; i <= col_len; i++)\n{\n  omp_init_lock(&weightlock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/L1FE0FJ4Y/Parallel_Ensemble_Classifier/svm/0"}
{"code": "for (i = 0; i < num_ph; i++)\n{\n  *(sorted_indexes + i) = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/8"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/3"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    matrix1[i][j] = rand() % 2;\n    if (outputOn)\n      fprintf(outFile, \"%d \", matrix1[i][j]);\n\n  }\n\n  if (outputOn)\n    fprintf(outFile, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcFW/CITS3402/Assignment1/OpenMP/2"}
{"code": "for (unsigned long long int i = 0; i < combinations; i++)\n{\n  if (found == 0)\n    run(i);\n\n}\n\n", "pragma": "omp parallel for shared(found) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogoazevedos/hash-breaker/main/0"}
{"code": "for (size_t codeletCounter = 0; codeletCounter < ((size_t) this->numThreads); codeletCounter++)\n{\n  *checkInCodelets511Ptr = _checkInCodelets511(1, 1, this, codeletCounter);\n  checkInCodelets511Ptr++;\n  *checkInCodelets508Ptr = _checkInCodelets508(1, 1, this, codeletCounter);\n  checkInCodelets508Ptr++;\n  *checkInCodelets509Ptr = _checkInCodelets509(2, 1, this, codeletCounter);\n  (*checkInCodelets509Ptr).decDep();\n  checkInCodelets509Ptr++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    fprintf(file, \"%lf \", l_mat[(i * n) + j]);\n  }\n\n  fprintf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/2"}
{"code": "for (j = 0; j < Block_order; j++)\n  for (i = 0; i < Block_order; i++)\n  B_p[(i + istart) + (order * j)] += Work_in_p[i + (Block_order * j)];\n\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Transpose/transpose/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  pr[i + 1] += local_sum_val;\n}\n\n", "pragma": "    #pragma omp for schedule(auto) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/prefixsum/prefixsum/2"}
{"code": "for (i = 0; i < (table_size - 1); i++)\n{\n  for (j = 0; j < ((table_size - i) - 1); j++)\n  {\n    if (tab[j] > tab[j + 1])\n    {\n      swap = tab[j];\n      tab[j] = tab[j + 1];\n      tab[j + 1] = swap;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Wicz3k/MPR_OpenMP/zad_2/main/1"}
{"code": "for (int i = k1; i < k2; i++)\n  (*feasible)[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/18"}
{"code": "for (int x = 0; x < size; x++)\n{\n  for (int y = 0; y < size; y++)\n  {\n    printf(\"%d \", Matrix[y][x]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ERovirosa/openMPPractice/matrixMult/2"}
{"code": "for (i = 0; i < (N - 1); i++)\n{\n  tmp = (b[i] + c[i]) / 2.0;\n  a[i] = ta[i] + tmp;\n}\n\n", "pragma": "omp for private(i, tmp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/clone_array/2"}
{"code": "for (int i = start; i < stop; i++)\n  for (int j = start; j < stop; j++)\n  temp[h++] = mat1[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TeoGavrilescu31/Parallel-Programming-Project-OPENMP/proiect/5"}
{"code": "for (k = 0; k < mxyz1; k++)\n{\n  npp = kpic[k];\n  for (j = 0; j < npp; j++)\n  {\n    m = kp[j + (nppmx * k)];\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[j + (nppmx * (i + (idimp * k)))] = part[i + (idimp * m)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,npp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/0"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_time_kernel2 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/27"}
{"code": "for (i = 0; i < r; i++)\n  a1[i] = (int *) malloc(c * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog2_MatrixMul_opemmp/1"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  if (A[i] != 1)\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, (double) 1, A[i]);\n    fail = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_loop/nested_loop/1"}
{"code": "for (i = 0; i < 2000; i++)\n  X[i] = MA[i][2000];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-10/3"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"%d \", b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture5/Loop_construct_implicit_barrier/Loop_construct_implicit_barrier/3"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    E[(i * SIZE) + j] = 0.0;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      E[(i * SIZE) + j] += C[(i * SIZE) + k] * D[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/2MM/2mm/1"}
{"code": "for (j = 0; j < 10000.0; j++)\n{\n  x = (-50.0) / 2.0;\n  for (i = 0; i < 10000.0; i++)\n  {\n    printf(\"%12.6lf\\t%12.6lf\\t%12.6lf\\n\", x, y, m[i][j]);\n    x = x + dx;\n  }\n\n  y = y + dy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HardProxy/OpenMP/prog_in/3"}
{"code": "for (i = 1; i <= n; i++)\n{\n  M1[i] = M1[i - 1] + test[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/TransposeSPMX/2"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < cols; ++j)\n  {\n    int out_offset = i + (j * rows);\n    for (int x = i - 1, kx = 0; x <= (i + 1); ++x, ++kx)\n    {\n      for (int y = i - 1, ky = 0; y <= (i + 1); ++y, ++ky)\n      {\n        if ((((x >= 0) && (x < rows)) && (y >= 0)) && (y < cols))\n        {\n          int in_offset = x + (y * rows);\n          int k_offset = kx + (ky * 3);\n          if ((sizeof(prewittX[k_offset])) != (sizeof(double)))\n          {\n            perror(\"bad kernal\\n\");\n            exit(-1);\n          }\n\n          if ((sizeof(prewittY[k_offset])) != (sizeof(double)))\n          {\n            perror(\"bad kernal\\n\");\n            exit(-1);\n          }\n\n          xEdge[out_offset] += prewittX[k_offset] * blurImage[in_offset];\n          yEdge[out_offset] += prewittY[k_offset] * blurImage[in_offset];\n        }\n\n      }\n\n    }\n\n    outIntensity[out_offset] = sqrt((xEdge[out_offset] * xEdge[out_offset]) + (yEdge[out_offset] * yEdge[out_offset]));\n    out[out_offset].red = outIntensity[out_offset];\n    out[out_offset].green = outIntensity[out_offset];\n    out[out_offset].blue = outIntensity[out_offset];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/llama95/Parallel_Programming/Patterns/stencil/openmp/5"}
{"code": "for (i = i_min; i <= i_max; i++)\n{\n  int coef = getGaussCoefficient_h(M + i);\n  red_aux += coef * red[(y * width) + x];\n  green_aux += coef * green[(y * width) + x];\n  blue_aux += coef * blue[(y * width) + x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/gaussian/gaussian2/3"}
{"code": "for (int i = 0; i < nrows; i++)\n{\n  ((((cout << \" [\") << indi[i]) << \" , \") << indj[i]) << \" ]\";\n  (cout << val[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/1"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  w[j] = d;\n}\n\n", "pragma": "omp for private(d, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/13"}
{"code": "for (int i = 2; i < limit; i++)\n{\n  evaluate(head, i);\n}\n\n", "pragma": "omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Osmanyasal/openmpExamples/5-primeNumbers/parallelPrime/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  u000ijk[m] = ((ce[0][m] + ((ce[1][m] + ((ce[4][m] + ((ce[7][m] + (ce[10][m] * xi)) * xi)) * xi)) * xi)) + ((ce[2][m] + ((ce[5][m] + ((ce[8][m] + (ce[11][m] * eta)) * eta)) * eta)) * eta)) + ((ce[3][m] + ((ce[6][m] + ((ce[9][m] + (ce[12][m] * zeta)) * zeta)) * zeta)) * zeta);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/13"}
{"code": "for (f = 0; f < N; f++)\n  for (c = f; c < N; c++)\n  v2[f] += M[f][c] * v1[c];\n\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danidiaz1/AC-Arquitectura-de-Computadores-UGR-2015-2016/Practica3/src/pmtv-OpenMP/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] += 1.0;\n  b[i] += i + 1.0;\n  c[i] += (2 * i) + 2.0;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for map(tofrom: a[:n], b[:n], c[:n])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/usm/mixed_maps/mixed_maps/6"}
{"code": "for (dest = 1; dest <= numworkers; dest++)\n{\n  rows = (dest <= extra) ? (averow + 1) : (averow);\n  printf(\"Sending %d rows to task %d offset=%d\\n\", rows, dest, offset);\n  MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&rows, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&a[offset][0], rows * 250, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  MPI_Send(&b, 250 * 200, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  offset = offset + rows;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wahmingchen/parallel-computing/matrix_multiplication_with_MPI/mpi_mm/4"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n    for (k = 0; k < o; k++)\n  {\n    bar(i, j, k);\n  }\n\n\n}\n\n", "pragma": "omp for collapse(2) ordered(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/sink-1/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/6"}
{"code": "for (int k = 0; k < n; k++)\n{\n  sem_wait(&sem_workerstart[t_id]);\n  for (int i = (k + 1) + t_id; i < n; i += THREAD_NUM)\n  {\n    t2 = mat[i][k];\n    for (int j = k + 1; j < n; j++)\n    {\n      mat[i][j] -= t2 * mat[k][j];\n    }\n\n    mat[i][k] = 0.0;\n  }\n\n  sem_post(&sem_main);\n  sem_wait(&sem_workerend[t_id]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/3"}
{"code": "for (iterator I = Types.begin(), E = Types.end(); I != E; ++I, ++IR)\n{\n  if (Context.hasSameType(QTy, *I))\n  {\n    (Diag(Range.getBegin(), err_omp_reduction_redeclared) << (*I)) << Range;\n    Diag(IR->getBegin(), note_previous_declaration) << (*IR);\n    IsValid = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/2"}
{"code": "for (int i = 0; i < l; i++)\n{\n  for (int k = 0; k < n; k++)\n  {\n    ((((((cout << \"Matrix[\") << i) << \"][\") << k) << \"] = \") << result[i][k]) << endl;\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac4/MatrixMultiplication_OpenMP/5"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  k = 1;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][k]) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n  k = 2;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][k - 1]) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/27"}
{"code": "for (int i = 0; i < table.size(); i++)\n{\n  b_vec2.push_back(pointer2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amy090912/Word-Count-with-MapReduce-and-openMP/lab4b3/8"}
{"code": "for (long i = 0; i < IT_END; i++)\n{\n  arr[i] = arr[i] + 1;\n}\n\n", "pragma": "        #pragma omp for schedule(dynamic, GRAINSIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rutgers-apl/omp-racer/tests/microbenchmarks/09_for_dynamic/test_for_1/0"}
{"code": "for (r = 0; r < n; r++)\n{\n  solution[r] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sor/0"}
{"code": "for (i = 0; i < (*row); i++)\n{\n  image[i] = (unsigned char *) malloc((*col) * (sizeof(unsigned char)));\n  assert(image[i] != 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_atomic/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++r;\n}\n\n", "pragma": "#pragma omp for reduction(+ : r)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/task_messages/1"}
{"code": "for (i = 1; i < argc; i++)\n  if (strcmp(argv[i], \"-d\") == 0)\n{\n  dimi = atoi(argv[i + 1]);\n  dimj = atoi(argv[i + 2]);\n  i += 2;\n}\nelse\n  if (strcmp(argv[i], \"-g\") == 0)\n{\n  generations = atoi(argv[i + 1]);\n  i++;\n}\nelse\n  if (strcmp(argv[i], \"-i\") == 0)\n{\n  if (my_rank == 0)\n  {\n    if ((input = fopen(argv[i + 1], \"r\")) == 0)\n    {\n      fprintf(stderr, \"There was a problem opening the file %s.\\n\", argv[3]);\n      perror(0);\n    }\n\n    i++;\n  }\n\n}\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petros-ioannidis/parallel_CGOL/OPENMP_CGOL/graph_main_openmp/4"}
{"code": "for (int i = 0; i < nt; i++)\n  *sd += pow((end[i] - start[i]) - (*average), 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/freesdyla/Math-424-Semester-Project/stereo/3"}
{"code": "for (int tt = 0; tt < params.maxIters; tt = tt + 2)\n{\n  av_vels[tt] = timestep(params, cells, tmp_cells, obstacles);\n  av_vels[tt + 1] = timestep(params, tmp_cells, cells, obstacles);\n  printf(\"==timestep: %d==\\n\", tt);\n  printf(\"av velocity: %.12E\\n\", av_vels[tt]);\n  printf(\"tot density: %.12E\\n\", total_density(params, cells));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abcdrm/LBM-OpenMP/d2q9-bgk/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  dot += X[i] * Y[i];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:dot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/dot/0"}
{"code": "for (int i = 0; i < numNodes; ++i)\n{\n  solution[i] = equal_prob;\n  if (outgoing_size(g, i) == 0)\n  {\n    index = __sync_fetch_and_add(&no_counter, 1);\n    no_outgoing_nodes[index] = i;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank/page_rank/0"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    yvel1[FTNREF2D(j, 1 - k, x_max + 5, x_min - 2, y_min - 2)] = -yvel1[FTNREF2D(j, 1 + k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/40"}
{"code": "for (i = 0; i <= (m * n); i++)\n{\n  *w[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/backprop/backprop_gpu/1"}
{"code": "for (i = 0; i < matrixSize; i++)\n{\n  double *AHead = &A[i * matrixSize];\n  double tmp = 0;\n  for (j = 0; j < matrixSize; j++)\n  {\n    tmp += AHead[j] * V[j];\n  }\n\n  results[i] = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/benchmarking/matrix_vector_multiplication/mvm_benchmarking/2"}
{"code": "for (j = 0; j <= (d[1] - 1); j += 1)\n{\n  for (i = 0; i <= (fftblock - 1); i += 1)\n  {\n    y0[j][i].real = x[k][j][i + ii].real;\n    y0[j][i].imag = x[k][j][i + ii].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/9"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  const int j = urand() * n;\n  const int k = urand() * n;\n  swap(p[j], p[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/12"}
{"code": "for (i = 0; i < 5; i++)\n{\n  row_sum = 0;\n  for (j = 0; j < 2; j++)\n  {\n    row_sum += (*((array + (i * 2)) + j)) * (*(vector + j));\n  }\n\n  result[i] = row_sum;\n}\n\n", "pragma": "omp parallel for private(i, j, row_sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1b_MatrixVectorMult_OpenMP_approach2/0"}
{"code": "for (int a = 0; a < size_matrix; a++)\n{\n  for (int i = 0; i < size_matrix; i++)\n  {\n    int adder = 0;\n    for (int j = 0; j < size_matrix; j++)\n    {\n      adder += matrix_A[i][j] * matrix_B[j][a];\n    }\n\n    matrix_Out[i][a] = adder;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/11"}
{"code": "for (int i = 0; i < NUM; i++)\n{\n  allOne = allOne && b[i];\n  printf(\"%d \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/func-ptr/func-ptr/1"}
{"code": "for (size_t i = 0; i < ex.size(); i++)\n  LOG_ERROR(((((\"ex[\" << ijk) << \"][\") << i) << \"]=\") << ex[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/GridStore/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*class_npb) == 'U')\n  {\n    printf(\"          %2d  %20.13E\\n\", m + 1, xce[m]);\n  }\n  else\n    if (xcedif[m] <= epsilon)\n  {\n    printf(\"          %2d  %20.13E%20.13E%20.13E\\n\", m + 1, xce[m], xceref[m], xcedif[m]);\n  }\n  else\n  {\n    *verified = FALSE;\n    printf(\" FAILURE: %2d  %20.13E%20.13E%20.13E\\n\", m + 1, xce[m], xceref[m], xcedif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/40"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  j = grid_points[1] - 3;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])));\n  j = grid_points[1] - 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (5.0 * ue[j][m])));\n}\n\n", "pragma": "omp parallel for private (j,m) firstprivate (dssp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/24"}
{"code": "for (int i = 0; i < MAXN; i++)\n{\n  sum = sum + (a[i] * b[i]);\n  printf(\"tid %d i %d\\n\", tid, i);\n}\n\n", "pragma": "\t#pragma omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_orphan/0"}
{"code": "for (i = k + 1; i <= n; i++)\n{\n  currVal = (A[((k - 1) * Alda) + (i - 1)] > 0.0) ? (A[((k - 1) * Alda) + (i - 1)]) : (-A[((k - 1) * Alda) + (i - 1)]);\n  if (piv_local < currVal)\n  {\n    piv_local = currVal;\n    iPiv_local = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matey97/LU_OpenMP_MPI/LU_pivR_OpenMP/0"}
{"code": "for (i = 0; i < nx; i++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, y[i]);\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/atax/atax/4"}
{"code": "for (size_t i = 0; i < (k * 2); i++)\n{\n  if (i < k)\n    *(new_bloc + i) = *((*bloc1) + i);\n  else\n    *(new_bloc + i) = *(((*bloc2) + i) - k);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/6"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  vs[n] = Ranf(VMIN, VMAX);\n  ths[n] = Ranf(THMIN, THMAX);\n  gs[n] = Ranf(GMIN, GMAX);\n  hs[n] = Ranf(HMIN, HMAX);\n  ds[n] = Ranf(DMIN, DMAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jaegeun1393/OpenMP-Monte-Carlo-Simulation/p1/0"}
{"code": "for (j = jj; j < (((jj + bsize) < 5000) ? (jj + bsize) : (5000)); j++)\n{\n  for (h = 0; h < loop_unroll_limit; h++)\n  {\n    B[i + h][j] = A[j][i + h];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/TiledTranspose/tiled_transpose_with_loop_unroll_parallel_for_j/0"}
{"code": "for (i = 10000000; i >= 1; i--)\n{\n  res = res + (1 / ((double) i));\n}\n\n", "pragma": "omp parallel for reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesyangc/ECE563-Parallel-Programming/hw3/hw3_c_omp/1"}
{"code": "for (int neuron = 0; neuron < (layers[layer] - 1); neuron += 1)\n{\n  double REGISTER = 0.0;\n  for (int synapse = 0; synapse < layers[layer - 1]; synapse += 1)\n  {\n    REGISTER += weights[layer - 1][neuron][synapse] * a[layer - 1][synapse];\n  }\n\n  z[layer][neuron] = REGISTER;\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/neural-network/src/forward/0"}
{"code": "for (int i = 0; i < SDMGeom->HALO_Node(); ++i)\n{\n  sxx[i] = f;\n  syy[i] = f;\n  szz[i] = f;\n  sxy[i] = f;\n  sxz[i] = f;\n  syz[i] = f;\n  vx[i] = f;\n  vy[i] = f;\n  vz[i] = f;\n  ux[i] = f;\n  uy[i] = f;\n  uz[i] = f;\n  dsxx_dx[i] = f;\n  dsxy_dy[i] = f;\n  dsxz_dz[i] = f;\n  dsxy_dx[i] = f;\n  dsyy_dy[i] = f;\n  dsyz_dz[i] = f;\n  dsxz_dx[i] = f;\n  dsyz_dy[i] = f;\n  dszz_dz[i] = f;\n  dvx_dx[i] = f;\n  dvy_dy[i] = f;\n  dvz_dz[i] = f;\n  dvx_dy[i] = f;\n  dvy_dx[i] = f;\n  dvx_dz[i] = f;\n  dvz_dx[i] = f;\n  dvy_dz[i] = f;\n  dvz_dy[i] = f;\n  df_dI[i] = f;\n  df_dJ[i] = f;\n  df_dK[i] = f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/3"}
{"code": "for (k = 0; k < n; k++)\n{\n  r[i][j] = r[i][j] + (a[i][k] * b[k][j]);\n}\n\n", "pragma": "omp parallel for shared(i,j,a,b,r,n,k)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunaljani1100/High-Performance-Computing-Using-OPENMP-and-MPI/matrix_parallel_innermost/0"}
{"code": "for (i = 0; i < 8; i++)\n  for (j = 0; j < 8; j++)\n  if (c1[i][j] != c2[i][j])\n  return 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/1"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n{\n  temp2 = 0;\n  for (k = 0; k < N; k++)\n    temp2 += L[(i * N) + k] * U[(k * N) + j];\n\n  if ((((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) > 0.1) || (((A2[(i * N) + j] - temp2) / A2[(i * N) + j]) < (-0.1)))\n    temp++;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/benchmarks/LU/old/lu-dep-timed/5"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  mem_dev_cpy[i] = i * 2;\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/target/test_target_memcpy_async_no_obj/0"}
{"code": "for (int i = 0; i < (Gsize * rGsize); ++i)\n{\n  (*rG)[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/113"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  C[A[i]] = C[A[i]] + 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feperessim/counting-sort-parallel-openmp/counting_sort_serial_and_parallel/0"}
{"code": "for (int i = 0; i < A_row; i++)\n{\n  for (int j = 0; j < A_col; j++)\n  {\n    fscanf(input, \"%d\", &A[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coherent17/Matrix-Multiplication-optimize-by-OpenMP/Parallel_Matrix_Multiplication_With_Openmp/ijk_optimize/3"}
{"code": "for (indice = 0; indice < filasXproceso; indice++)\n{\n  arbolesContagiando = 0;\n  vecinosVisitados = 0;\n  if (indice > 0)\n  {\n    if (matrizLocal[indice - 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 1].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice > 1)\n  {\n    if (matrizLocal[indice - 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 2].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 1))\n  {\n    if (matrizLocal[indice + 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 1].fila < 800)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 2))\n  {\n    if (matrizLocal[indice + 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 2].fila < 800)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < 800)\n  {\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + 800].fila)\n    {\n      if (arregloArriba[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((matrizLocal[indice].fila - 1) == arregloArriba[indice + (800 + 1)].fila) && (indice < (800 - 1)))\n    {\n      if (arregloArriba[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + (800 - 1)].fila)\n    {\n      if (arregloArriba[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 800)].fila)\n    {\n      if (matrizLocal[indice + (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 800)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice > (800 - 1)) && (indice < (800 * 2)))\n  {\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((indice - (800 + 1)) >= 0) && ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila))\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (800 * 2)) && (indice < (filasXproceso - (2 * 800))))\n  {\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 800)].fila)\n    {\n      if (matrizLocal[indice + (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 800)].fila)\n    {\n      if (matrizLocal[indice - (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (filasXproceso - (800 * 2))) && (indice < (filasXproceso - 800)))\n  {\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajo].fila)\n    {\n      if (arregloAbajo[indiceAbajo].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajo].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (800 * 2)].fila)\n    {\n      if (matrizLocal[indice - (800 * 2)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 * 2)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if ((indice >= (filasXproceso - 800)) && (indice < filasXproceso))\n  {\n    if (indiceAbajoB == 800)\n    {\n      indiceAbajoB = 0;\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB].fila)\n    {\n      if (arregloAbajo[indiceAbajoB].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (indiceAbajoB > 0)\n    {\n      if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB - 1].fila)\n      {\n        if (arregloAbajo[indiceAbajoB - 1].color == 3)\n        {\n          arbolesContagiando++;\n        }\n\n        if (arregloAbajo[indiceAbajoB - 1].fila < 800)\n        {\n          vecinosVisitados++;\n        }\n\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB + 1].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 1].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 1].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajoB + 800].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 800)].fila)\n    {\n      if (matrizLocal[indice - (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if (matrizLocal[indice].edad < 157)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.35 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.35;\n    }\n\n  }\n\n  if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.17 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.17;\n    }\n\n  }\n\n  if (matrizLocal[indice].edad >= 1821)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.63 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.63;\n    }\n\n  }\n\n  matrizLocalAux[indice].edad += 1;\n  if (matrizLocal[indice].color == 4)\n  {\n    matrizLocalAux[indice].semanasInfectado += 1;\n    matrizLocalAux[indice].semanasTotales++;\n  }\n\n  if (matrizLocal[indice].semanasInfectado == 3)\n  {\n    matrizLocalAux[indice].color = 3;\n  }\n\n  if (matrizLocal[indice].color == 3)\n  {\n    matrizLocalAux[indice].semanasTotales++;\n    if ((rand() % 100) <= 85)\n    {\n      matrizLocalAux[indice].color = 2;\n      matrizLocalAux[indice].semanasInfectado = 0;\n      matrizLocalAux[indice].semanasTotales += 1;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 2)\n  {\n    if (matrizLocal[indice].semanasTotales <= 8)\n    {\n      matrizLocalAux[indice].semanasTotales++;\n    }\n    else\n    {\n      if (matrizLocal[indice].edad < 157)\n      {\n        if ((rand() % 100) > 3)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n      {\n        if ((rand() % 100) > 15)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if (matrizLocal[indice].edad >= 1821)\n      {\n        if ((rand() % 100) > 53)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n          matrizLocalAux[indice].edad = 57;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 1)\n  {\n    if (matrizLocal[indice].semanasPodado <= 12)\n    {\n      matrizLocalAux[indice].semanasPodado++;\n    }\n    else\n    {\n      matrizLocalAux[indice].color = 5;\n      matrizLocalAux[indice].semanasPodado = 0;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 5)\n  {\n    porcentajeEnfermos = (float) (arbolesContagiando / vecinosVisitados);\n    probabilidadContagio = (((float) (porcentajeEnfermos + susceptibilidad)) * 0.60) + 0.07;\n    if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n    {\n      matrizLocalAux[indice].color = 4;\n    }\n\n  }\n\n  if (semana > 0)\n  {\n    probHeridas = rand() % 101;\n    if ((matrizLocal[indice].edad < 157) && (probHeridas < 23))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if (((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821)) && (probHeridas < 8))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if ((matrizLocal[indice].edad >= 1821) && (probHeridas < 37))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(indice,indiceAbajoB, susceptibilidad, porcentajeEnfermos, probabilidadContagio, probHeridas, arbolesContagiando, vecinosVisitados) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalHibrido800/1"}
{"code": "for (i = (2 * width) + 2; i < ((array_size - (2 * width)) - 2); i++)\n{\n  if ((i % ((row_number * width) - 2)) == 0)\n  {\n    i += 3;\n    row_number++;\n    continue;\n  }\n\n  dest_array[i] = calculate_filtered_pixel(i, src_array, width, height, filter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Convolution-filter/convolution-filter-MPI/processing_img/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  q = sol->r[i];\n  idiag = i - 1;\n  offset = 1;\n  while (idiag > 0)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag--;\n  }\n\n  idiag = i + 1;\n  offset = 1;\n  while (idiag < 8)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag++;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    q2 = sol->r[j];\n    if (j == i)\n    {\n      continue;\n    }\n\n    if (q2 == q)\n    {\n      printf(\"cols false!\\n\");\n      return 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonaut/8queensOpenMP/hw3/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joeladams/patternlets/patternlets/openMP/08.reduction/reduction/0"}
{"code": "for (int i = y_min; i <= y_max; i++)\n{\n  if ((max_overlap_horiz[i] < min_max) || ((max_overlap_horiz[i] == min_max) && (horizontal[i] < min_agg)))\n  {\n    best = i;\n    min_max = max_overlap_horiz[best];\n    min_agg = horizontal[best];\n    new_bendy1 = i;\n    new_bendx1 = wire.x1;\n    new_bendx1 = -1;\n    new_bendy1 = -1;\n    new_bendx2 = -1;\n    new_bendy2 = -1;\n    if (!((wire.y1 == wire.y2) && (i == wire.y1)))\n    {\n      new_bendy1 = i;\n      if (i == wire.y1)\n      {\n        new_bendx1 = wire.x2;\n      }\n      else\n      {\n        new_bendx1 = wire.x1;\n      }\n\n      if ((i != wire.y1) && (i != wire.y2))\n      {\n        new_bendx2 = wire.x2;\n        new_bendy2 = i;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jenniferleeny/openMP/code/wireroute/1"}
{"code": "for (i = 1; i < (num_buckets - 1); ++i)\n{\n  thresholds[i] = thresholds[i - 1] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/19"}
{"code": "for (int i = 1; i <= NUM_FOLDS; i++)\n{\n  fprintf(stdout, \"Fold %d Time : \\t\\t\", i);\n  fprintf(stdout, \"%f\\n\", timer[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/L1FE0FJ4Y/Parallel_Ensemble_Classifier/ensemble/0"}
{"code": "for (i = 0; i < size_matrix; i++)\n{\n  for (j = 0; j < size_matrix; j++)\n  {\n    a[i][j] = rand() % 100;\n    b[i][j] = rand() % 100;\n    c[i][j] = -1;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) firstprivate(size_matrix) private(i,j) shared(a,b,c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitumenezes/matrix-multiplication-pthreads-OpenMP/openmp/src/matrix_calc_omp/0"}
{"code": "for (j = 0; j < count; j++)\n{\n  for (i = 0; i < rows; i++)\n    data2[i][j] = data[j][i];\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((i % 2) == 0)\n    factor = 1.0;\n  else\n    factor = -1.0;\n\n  sum += factor / ((2 * i) + 1);\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum) private(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdh266/OpenMP_Practice/pi/0"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  printf(\"%d \", local[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francesc0rtu/Parallel-kd-tree/test/04-for/5"}
{"code": "for (i = 0; i < 100; i++)\n  result = result + (a[i] * b[i]);\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static,chunk) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javierip/parallel-processing-teaching-toolkit/03-multi-core-processors/01-openMP/08-reduction/main/1"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    for (k = 0; k < 3072; k++)\n    {\n      C[(i * 3072) + j] += (12435 * A[(i * 3072) + k]) * A[(j * 3072) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk_cpu/10"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, 9, (MPI_Datatype) 0x4c000406, T, 9, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/31"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    b[i][j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  sel = rand() % 100000;\n  for (int j = 0; j < i; j++)\n  {\n    if (sel == temp[j])\n    {\n      flag = 1;\n      break;\n    }\n\n  }\n\n  if (flag == 1)\n  {\n    flag = 0;\n    i--;\n  }\n  else\n  {\n    temp[i] = sel;\n    cpyVec(&vectors[sel][0], &centres[i][0]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project2/K-Means-OpenMP/4"}
{"code": "for (j = 3; j <= (grid_points[1] - 4); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,comz1 ,comz4 ,comz6 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/66"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if (choice)\n    printf(\"Thread #%d is doing row %d.\\n\", th_id, i);\n\n  for (j = 0; j < dim; j++)\n  {\n    *(result + (j + (i * dim))) = 0;\n    for (k = 0; k < dim; k++)\n      *(result + (j + (i * dim))) += (*(mat1 + (k + (i * dim)))) * (*(mat2 + (j + (k * dim))));\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided,part_rows)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anishmrao/MultithreadMatrixMul/mattry/0"}
{"code": "for (i = 0; i < sizeB; i++)\n{\n  for (c = 0; c < sizeC; c++)\n  {\n    if (seqC[c] == seqB[i])\n    {\n      break;\n    }\n\n  }\n\n  if (c == sizeC)\n  {\n    seqC[sizeC] = seqB[i];\n    sizeC++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giov8/lcs-openmp/openmp/lcs/5"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/master_messages/0"}
{"code": "for (j = 0; j < 80000000; j++)\n  a[j] = b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KonstantinosKr/delta/meta/benchmark/ham7/stream/stream/5"}
{"code": "for (size_t i = 0; i < Nqd; i++)\n{\n  x1(i) = quadf(i, 0);\n  x2(i) = quadf(i, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/1"}
{"code": "for (i = 1; i < 3; i++)\n{\n  if (flower[i] > vote_count)\n  {\n    vote_count = flower[i];\n    final_class = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/SVM/2"}
{"code": "for (box = 0; box < level->num_my_boxes; box++)\n{\n  int i;\n  int j;\n  int k;\n  const int jStride = level->my_boxes[box].jStride;\n  const int kStride = level->my_boxes[box].kStride;\n  const int ghosts = level->my_boxes[box].ghosts;\n  const int dim_i = level->my_boxes[box].dim;\n  const int dim_j = level->my_boxes[box].dim;\n  const int dim_k = level->my_boxes[box].dim;\n  for (k = 0; k <= dim_k; k++)\n  {\n    for (j = 0; j <= dim_j; j++)\n    {\n      for (i = 0; i <= dim_i; i++)\n      {\n        int ijk = ((i + ghosts) + ((j + ghosts) * jStride)) + ((k + ghosts) * kStride);\n        double x = hLevel * (((double) (i + level->my_boxes[box].low.i)) + 0.5);\n        double y = hLevel * (((double) (j + level->my_boxes[box].low.j)) + 0.5);\n        double z = hLevel * (((double) (k + level->my_boxes[box].low.k)) + 0.5);\n        double A;\n        double B;\n        double Bx;\n        double By;\n        double Bz;\n        double Bi;\n        double Bj;\n        double Bk;\n        double U;\n        double Ux;\n        double Uy;\n        double Uz;\n        double Uxx;\n        double Uyy;\n        double Uzz;\n        A = 1.0;\n        B = 1.0;\n        Bx = 0.0;\n        By = 0.0;\n        Bz = 0.0;\n        Bi = 1.0;\n        Bj = 1.0;\n        Bk = 1.0;\n        evaluateBeta(x - (hLevel * 0.5), y, z, &Bi, &Bx, &By, &Bz);\n        evaluateBeta(x, y - (hLevel * 0.5), z, &Bj, &Bx, &By, &Bz);\n        evaluateBeta(x, y, z - (hLevel * 0.5), &Bk, &Bx, &By, &Bz);\n        evaluateBeta(x, y, z, &B, &Bx, &By, &Bz);\n        evaluateU(x, y, z, &U, &Ux, &Uy, &Uz, &Uxx, &Uyy, &Uzz, level->boundary_condition.type == BC_PERIODIC);\n        double F = ((a * A) * U) - (b * ((((Bx * Ux) + (By * Uy)) + (Bz * Uz)) + (B * ((Uxx + Uyy) + Uzz))));\n        level->my_boxes[box].vectors[VECTOR_BETA_I][ijk] = Bi;\n        level->my_boxes[box].vectors[VECTOR_BETA_J][ijk] = Bj;\n        level->my_boxes[box].vectors[VECTOR_BETA_K][ijk] = Bk;\n        level->my_boxes[box].vectors[VECTOR_ALPHA][ijk] = A;\n        level->my_boxes[box].vectors[VECTOR_F][ijk] = F;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/problem.p4/3"}
{"code": "for (j = 2 * i; j <= n; j += i)\n{\n  primes[j] = 1;\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aman-Chopra/CUDA-vs-OpenMP/Sieve/sieve_openmp/0"}
{"code": "for (i = 1; i < TOPEF; i++)\n{\n  index = v2[i];\n  j = i;\n  while ((j > 0) && (v2[j - 1] > index))\n  {\n    v2[j] = v2[j - 1];\n    j = j - 1;\n  }\n\n  v2[j] = index;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/6"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  front[iel] = newc[iel];\n}\n\n", "pragma": "omp parallel for default(shared) private(iel)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/1"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  global_diff += abs_func(score_new[i] - solution[i]);\n  solution[i] = score_new[i];\n  if (outgoing_size(g, i) == 0)\n  {\n    sum += solution[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+ : global_diff), reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ace821017/OpenMP-Programming/part2/page_rank/page_rank/1"}
{"code": "for (int e = 0; e < gr->E; e++)\n{\n  int u = (get < 0) > gr->edge_array[e];\n  int v = (get < 1) > gr->edge_array[e];\n  gr->weights[e] = (gr->weights[e] + h[u]) - h[v];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  count = 0;\n  for (j = 0; j < n; j++)\n    if (a[j] < a[i])\n    count++;\n  else\n    if ((a[j] == a[i]) && (j < i))\n    count++;\n\n\n\n  temp[count] = a[i];\n}\n\n", "pragma": "omp parallel for default(none) private(j, i, count) shared(a, temp, n) num_threads(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adrianoferruzzi/SD-OpenMP-MPI/Parallel_2/sort_parallel/0"}
{"code": "for (j = 1; j < cache->assoc; j++)\n{\n  if (getSRRPV(&cache->cacheLines[i][j]) > min)\n  {\n    victim = j;\n    min = getSRRPV(&cache->cacheLines[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/24"}
{"code": "for (int h = 0; h < goldenResult->image_height; h++)\n  for (int w = 0; w < goldenResult->image_width; w++)\n{\n  output_file.read((char *) (&goldenResult->intensity[pos]), sizeof(float));\n  output_file.read((char *) (&goldenResult->distance[pos]), sizeof(float));\n  output_file.read((char *) (&goldenResult->min_height[pos]), sizeof(float));\n  output_file.read((char *) (&goldenResult->max_height[pos]), sizeof(float));\n  pos++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/points2image/kernel/3"}
{"code": "for (int i = leftover; i > 0; i--)\n{\n  (*transfer_points_arr)[amount_with_lefover - i] = transfer_points[transfer_points_amount - i];\n}\n\n", "pragma": "#pragma omp parallel for shared(transfer_points, transfer_points_arr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/22"}
{"code": "for (i = 0; i < 4096; ++i)\n{\n  for (j = 0; j < 4096; ++j)\n  {\n    A[(i * 4096) + j] = ((float) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    A[i][j] = (A[i][j] + (u1[i] * v1[j])) + (u2[i] * v2[j]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aleksyav/C-MPI-OMP-Gemver/OpenMP/gemver/1"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (strcmp(\"-NR\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%d\", &NR);\n  }\n\n  if (strcmp(\"-NC\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%d\", &NC);\n  }\n\n  if (strcmp(\"-NRC\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%d\", &NR);\n    sscanf(argv[i + 1], \"%d\", &NC);\n  }\n\n  if (strcmp(\"-NITER\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%d\", &NITER);\n  }\n\n  if (strcmp(\"-EXTRA\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%d\", &EXTRA);\n  }\n\n  if (strcmp(\"-barrier\", argv[i]) == 0)\n  {\n    barrier = 1;\n  }\n\n  if (strcmp(\"-no_barrier\", argv[i]) == 0)\n  {\n    barrier = 0;\n  }\n\n  if (strcmp(\"-reduce\", argv[i]) == 0)\n  {\n    reduce = 1;\n  }\n\n  if (strcmp(\"-no_reduce\", argv[i]) == 0)\n  {\n    reduce = 0;\n  }\n\n  if (strcmp(\"-vf\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%s\", fileOutName);\n    fOut = 1;\n  }\n\n  if (strcmp(\"-tf\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%s\", timesOutName);\n    tOut = 1;\n  }\n\n  if (strcmp(\"-cpuf\", argv[i]) == 0)\n  {\n    sscanf(argv[i + 1], \"%s\", cpuOutName);\n    cOut = 1;\n  }\n\n  if (strcmp(\"-s\", argv[i]) == 0)\n  {\n    sOut = 1;\n  }\n\n  if (strcmp(\"-v\", argv[i]) == 0)\n  {\n    vOut = 1;\n  }\n\n  if (strcmp(\"-nh\", argv[i]) == 0)\n  {\n    pHeader = 0;\n  }\n\n  if (strcmp(\"--help\", argv[i]) == 0)\n  {\n    printf(\"Usage: %s {-NR num-rows -NC num-cols} | {-NRC num-rows/cols}\\n              -NITER num-iter [-EXTRA extra-flop] \\n              [-[no_]barrier] [-[no_]reduce] \\n              [-v | -s] [-vf verbose-out-filename] \\n              [-cpuf cpu_loc-out-filename] \\n              [-tf time-out-filename] \\n              [--help] \\n\", argv[0]);\n    exit(0);\n  }\n\n  if (strcmp(\"-pc\", argv[i]) == 0)\n  {\n    pContext = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/4"}
{"code": "for (i = 0; i < N; i++)\n  if ((i < 10) && (a[i] != 0))\n{\n  rc++;\n  printf(\"1:Wrong value: a[%d]=%d\\n\", i, a[i]);\n}\nelse\n  if ((i >= 10) && (a[i] != b[i]))\n{\n  rc++;\n  printf(\"2:Wrong value: a[%d]=%d\\n\", i, a[i]);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-with-continue/no_loop_with_continue/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  codes[si].codeword[i] = c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TransientObject/ParallelizeAlgos/lib/huffman_compression_main_proj/openmp_version/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j - 1][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/33"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] *= temp;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/14"}
{"code": "for (int i = 0; i < Nelem; ++i)\n{\n  for (int k = EIA[i]; k < EIA[i + 1]; ++k)\n  {\n    int j = EJA[k];\n    NIA[j + 1]++;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lovgager/parallel-methods/FirstTask/FirstTask/2"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    s = cimagf(g[j + (3 * (ny - k))]) + (crealf(g[j + (3 * (ny - k))]) * _Complex_I);\n    g[j + (3 * (ny - k))] = conjf(g[j + (3 * k)] - s);\n    g[j + (3 * k)] += s;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/43"}
{"code": "for (int k = 0; k < o; k++)\n{\n  int v = (k * n) * m;\n  do_xy_plane(T, R, v, n, m, o, k);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/heatsink_openmp/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  coe_i = 10 * exp(lamda * i);\n  j = (size - 1) + i;\n  coe[j] = coe_i;\n  j = (size - 1) - i;\n  coe[j] = coe_i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/0"}
{"code": "for (size_t i = 1; i < (1 + ncolX()); i++)\n{\n  BestSubsetHelper(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RobertWSmith/RcppRegression/src/ls/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\n\", orden[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer2/scheduler-clauseModificado/1"}
{"code": "for (int i = 0; i < n; i++, x >>= 1)\n  result = (result << 1) | (x & 1U);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/evanmacbride/parallel-fft/src/fft/4"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n{\n  bins[i].num_particles = 0;\n  bins[i].particles.clear();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yuchaoran2011/particles-OpenMP-simulation/openmp/0"}
{"code": "for (int i = 0; i < size_target; i++)\n{\n  float best = distance(vec3(pos[0]), vec3(pos[i + size_scene]));\n  pair[i] = 0;\n  for (int j = 1; j < size_scene; j++)\n  {\n    float d = distance(vec3(pos[j]), vec3(pos[i + size_scene]));\n    if (d < best)\n    {\n      pair[i] = j;\n      best = d;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(size_scene, size_target, pos, pair)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinayakvivek/Iterative-Closest-Point/src/icp/3"}
{"code": "for (int number_of_threads = 2; number_of_threads <= max_number_of_threads; ++number_of_threads)\n{\n  omp_set_num_threads(number_of_threads);\n  cout << endl;\n  cout << endl;\n  ((cout << \"  number of threads = \") << number_of_threads) << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"                          ScalarProduct                        \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"         i  |       times        |    s   |      results       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  for (int i = 4; i <= n; i *= 2)\n  {\n    start = omp_get_wtime();\n    result = ScalarProduct(veca, vecb, i);\n    end = omp_get_wtime();\n    time = end - start;\n    start_parallel = omp_get_wtime();\n    result_parallel = ScalarProductParallel(veca, vecb, i);\n    end_parallel = omp_get_wtime();\n    time_parallel = end_parallel - start_parallel;\n    (((((((((((((((((((((((cout << setw(10)) << right) << i) << \"  |  \") << fixed) << setprecision(4)) << time) << \"    \") << fixed) << setprecision(4)) << time_parallel) << \"  |  \") << fixed) << setprecision(2)) << (time / time_parallel)) << \"  |  \") << fixed) << setprecision(0)) << result) << \"    \") << fixed) << setprecision(0)) << result_parallel) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kr0nverk/Hello_Parallel_OpenMP/Scalar_Product/ScalarProduct/3"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm2_start = wtime();\n  for (int source = 0; source < V; ++source)\n  {\n    sssp_cpu_for_apsp(source, g);\n  }\n\n  btm2_sum = wtime() - btm2_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/1"}
{"code": "for (i = 2; i <= N; ++i)\n{\n  if (nums[i] != 0)\n  {\n    curr_num = i;\n    fprintf(fp, \"%d, %d, %d\\n\", rank++, curr_num, curr_num - prev_num);\n    prev_num = curr_num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephbieselin/Primes-OpenMP/parallel/genprime/3"}
{"code": "for (i = 0; i < Team_num; ++i)\n{\n  if ((Team[i].team_flag == 1) && (Team[i].task.thread_id == team_thread_id))\n  {\n    Team[i].itask[thread_num].task_id = -1;\n    Team[i].itask[thread_num].task_parent_id = -1;\n    Team[i].itask[thread_num].flag = 0;\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaodao90/wrapper/OpenMP/OMP_wrapper/8"}
{"code": "for (i = 1; i < (nx + 1); i++)\n{\n  for (j = 1; j < (ny + 1); j++)\n  {\n    dt_sum = 0;\n    dt[i][j] = comp_CCL(i, j, dt_max);\n    do\n    {\n      dt_sum = dt_sum + dt[i][j];\n      if (dt_sum < dt_max)\n      {\n        D1V_old[i][j] = D1V[i][j];\n        comp_concentrations(i, j, dt[i][j]);\n        Rush_Larsen(i, j, dt[i][j]);\n        comp_voltage(i, j, dt[i][j]);\n      }\n      else\n      {\n        dt[i][j] = dt_max - (dt_sum - dt[i][j]);\n        D1V_old[i][j] = D1V[i][j];\n        comp_concentrations(i, j, dt[i][j]);\n        Rush_Larsen(i, j, dt[i][j]);\n        comp_voltage(i, j, dt[i][j]);\n        break;\n      }\n\n      it[i][j] = comp_currents(i, j, dt[i][j]);\n      D1V[i][j] = (-it[i][j]) + (-stim);\n      dt[i][j] = comp_CCL(i, j, dt[i][j]);\n    }\n    while (true);\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j, dt_sum) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/LRd2000-model/2D model/FDM02_LRd00_CCL_openmp/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  double vf_val = m_get_val(vf, 0, i);\n  double vfx_val = m_get_val(vfx, 0, i);\n  double vfy_val = m_get_val(vfy, 0, i);\n  double x_val = v_get_val(x, i);\n  double y_val = v_get_val(y, i);\n  double new_val = (((vf_val + (vfx_val * (x_val - xc))) + (vfy_val * (y_val - yc))) - vfmean) / L;\n  m_set_val(vfr, 0, i, new_val);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/18"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * (((5.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113]) - (4.0 * u[i_imopVar110][j_imopVar111 + 1][k_imopVar112][m_imopVar113])) + u[i_imopVar110][j_imopVar111 + 2][k_imopVar112][m_imopVar113]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/16"}
{"code": "for (int i = 0; i < R; i++)\n{\n  for (int j = 0; j < C; j++)\n  {\n    t_data[(i * C) + j] = data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/main/4"}
{"code": "for (miel = 0; miel < nelt; miel++)\n{\n  iel = mt_to_id_old[miel];\n  if (ich[iel] == 4)\n  {\n    action[front[miel] - 1] = miel;\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(miel,iel)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/adapt/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  ii = i * size;\n  for (j = 0; j < size; j++)\n  {\n    for (k = 0; k < size; k++)\n    {\n      C[ii + j] += A[ii + k] * B[(j * size) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimmyv9/parallel-matrix/lab2/4"}
{"code": "for (int k = 0; k < m_nSoilLyrs[i]; k++)\n{\n  tnsoil += m_soilNO3[i][k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/ecology/PG_ORYZA/RiceGrowth_ORYZA/6"}
{"code": "for (long i = 0; i < NV_in; i++)\n{\n  long adj1 = vtxPtrIn[i];\n  long adj2 = vtxPtrIn[i + 1];\n  for (long j = adj1; j < adj2; j++)\n  {\n    long tail = vtxIndIn[j].tail;\n    assert((C[i] < numUniqueClusters) && (C[tail] < numUniqueClusters));\n    if (C[i] == C[tail])\n    {\n      long location = ((C[i] * (C[i] + 1)) / 2) + C[i];\n      __sync_fetch_and_add(&tmpCounter[location], vtxIndIn[j].weight);\n    }\n    else\n    {\n      if (C[i] > C[tail])\n      {\n        long location = ((C[i] * (C[i] + 1)) / 2) + C[tail];\n        __sync_fetch_and_add(&tmpCounter[location], vtxIndIn[j].weight);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/7"}
{"code": "for (int i = 0; i < N; i++)\n  b[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/forestdan/OpenMPLearn/src/09_scan/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  float t = 10.f;\n  if ((m_tMax != NULL) && (m_tMin != NULL))\n  {\n    t = (m_tMax[i] + m_tMin[i]) / 2.f;\n  }\n\n  float snowMelt = 0.f;\n  float snowAcc = 0.f;\n  if (m_snowMelt != NULL)\n  {\n    snowMelt = m_snowMelt[i];\n  }\n\n  if (m_snowAccu != NULL)\n  {\n    snowAcc = m_snowAccu[i];\n  }\n\n  float hWater = m_pNet[i];\n  if (t <= m_tSnow)\n  {\n    hWater = 0.0f;\n  }\n  else\n    if (((t > m_tSnow) && (t <= m_t0)) && (snowAcc > hWater))\n  {\n    hWater = 0.0f;\n  }\n  else\n  {\n    hWater = (m_pNet[i] + m_sd[i]) + snowMelt;\n  }\n\n\n  hWater += m_sr[i];\n  float matricPotential = ((m_porosity[i] - m_initSoilMoisture[i]) * m_capillarySuction[i]) / 1000.f;\n  float ks = (m_ks[i] / 1000.f) / 3600.f;\n  float dt = m_dt;\n  float infilDepth = m_accumuDepth[i] / 1000.f;\n  float p1 = (float) ((ks * dt) - (2.0 * infilDepth));\n  float p2 = ks * (infilDepth + matricPotential);\n  float infilRate = (float) ((p1 + sqrt(pow(p1, 2.0f) + ((8.0f * p2) * dt))) / (2.0f * dt));\n  float infilCap = (m_porosity[i] - m_soilMoisture[i]) * m_rootDepth[i];\n  if (hWater > 0)\n  {\n    if (m_soilMoisture[i] > m_porosity[i])\n    {\n      m_infil[i] = 0.0f;\n      m_infilCapacitySurplus[i] = 0.f;\n    }\n    else\n    {\n      m_infil[i] = min((infilRate * dt) * 1000.f, infilCap);\n      if (m_infil[i] > hWater)\n      {\n        m_infilCapacitySurplus[i] = m_infil[i] - hWater;\n        m_infil[i] = hWater;\n      }\n      else\n      {\n        m_infilCapacitySurplus[i] = 0.f;\n      }\n\n      m_accumuDepth[i] += m_infil[i];\n      m_sr[i] = hWater - m_infil[i];\n      if (m_rootDepth != NULL)\n      {\n        m_soilMoisture[i] += m_infil[i] / m_rootDepth[i];\n      }\n\n    }\n\n  }\n  else\n  {\n    m_sr[i] = 0.0f;\n    m_infil[i] = 0.0f;\n    m_infilCapacitySurplus[i] = min((infilRate * dt) * 1000.f, infilCap);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/SUR_SGA/StormGreenAmpt/1"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (-1.0) + (dx * (i - 1));\n  yy = (-1.0) + (dy * (j - 1));\n  temp = u[i][j] - ((1.0 - (xx * xx)) * (1.0 - (yy * yy)));\n  error = error + (temp * temp);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/jacobi-ompacc2/3"}
{"code": "for (int i = 0; i < SIZE; i++)\n  if (ARRAY[i] < min)\n  min = ARRAY[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant04/4"}
{"code": "for (i = 0; i < length; i++)\n{\n  sum += array[i] / length;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sgsdeshp/OpenMP/marketing_research/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i] = i;\n  for (int j = 0; j < n; j++)\n  {\n    if (j < i)\n    {\n      u[i][j] = 0.0;\n      l[i][j] = drand48();\n    }\n    else\n      if (j == i)\n    {\n      l[i][j] = 1.0;\n      u[i][j] = drand48();\n    }\n    else\n    {\n      u[i][j] = drand48();\n      l[i][j] = 0.0;\n    }\n\n\n    a[i][j] = drand48();\n    a_orig[i][j] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/4"}
{"code": "for (i = 0; i < x.dim1(); ++i)\n{\n  for (j = 0; j < y.dim2(); ++j)\n  {\n    sum = 0;\n    d = y.dim1();\n    for (k = 0; k < d; k++)\n    {\n      sum += x[i][k] * y[k][j];\n    }\n\n    z[i][j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leoaugustoam/PCA-Parallel-OpenMP/pca/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  local[i] = rank_me();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/test/rput/1"}
{"code": "for (i = 0; i < 2400; i++)\n{\n  for (j = 0; j < 2400; j++)\n  {\n    int k;\n    for (k = 0; k < 2400; k++)\n    {\n      D[(i * 2400) + j] += (12435 * A[(i * 2400) + k]) * A[(j * 2400) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYRK/syrk/7"}
{"code": "for (i = 0; i < 4; i++)\n{\n  zc[0][i] = 0.0;\n  zc[0][4 + i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/8"}
{"code": "for (unsigned int block = 0; block < total_blocks; block++)\n{\n  if (((nx > 1) && (ny > 1)) && (nz > 1))\n  {\n    field[block] = zfp_field_3d(&off_arr[((block * MIN_BLOCK_SIZE) * ny) * nx], type, nx, ny, block_dim[block]);\n  }\n  else\n  {\n    field[block] = zfp_field_2d(&off_arr[(block * MIN_BLOCK_SIZE) * nx], type, nx, block_dim[block]);\n  }\n\n  zfp_stream_rewind(zfp[block]);\n  zfp_size[block] = zfp_compress(zfp[block], field[block]);\n  if (!zfp_size[block])\n  {\n    (Logger->Error() << \"compression failed\") << '\\n';\n    exit(EXIT_FAILURE);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/utils/compressor/Compressor/2"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n{\n  if ((key_buff2[i] >= k1) && (key_buff2[i] < k2))\n  {\n    k = --key_buff_ptr_global[key_buff2[i]];\n    key_array[k] = key_buff2[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/4"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  uint32_t key[SSE_GROUP_SZ_SHA256][8];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n  {\n    pbkdf2_sha256((unsigned char *) saved_key[i + index], strlen(saved_key[i + index]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, (unsigned char *) key[i], 32, 0);\n  }\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n  {\n    AES_KEY akey;\n    AES_set_encrypt_key((unsigned char *) key[i], 256, &akey);\n    AES_ecb_encrypt((unsigned char *) \"lastpass rocks\\x02\\x02\", (unsigned char *) crypt_out[i + index], &akey, AES_ENCRYPT);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lastpass_fmt_plug/1"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n  c[j] = a[j] + b[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/20"}
{"code": "for (int i = 0; i < y.size(); i++)\n{\n  y[i] = x[i] + (alpha * y[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/xpay/0"}
{"code": "for (i = l1; i < l2; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    buffer[((i - l1) * width) + j] = aux[i][j].white_black;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/9"}
{"code": "for (i = 0; i < DIM; i++)\n  for (j = 0; j < DIM; j++)\n{\n  ck[i][j] = i + j;\n  c[i][j] = ck[i][j];\n  w[i][j] = i - j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/knuth/knut_fix/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (data[i] != (-1))\n    max_idx[i] = i;\n\n  max_idx1[i] = i;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle0/4"}
{"code": "for (i = 0; i < ntarget; i++)\n{\n  for (j = 0; j < 100; j++)\n  {\n    x = ((float) rand()) / ((float) 32767);\n  }\n\n  xa[i] = x;\n}\n\n", "pragma": "omp parallel for private(x,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rsnemmen/OpenMP-examples/waste_omp/0"}
{"code": "for (exp = 0; exp < 7; exp++)\n{\n  init_array(X);\n  start = _rdtsc();\n  parallel_merge_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X))\n  {\n    fprintf(stderr, \"ERROR: the array is not properly sorted\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/mergesort/3"}
{"code": "for (int i = 74; i < 98; ++i)\n{\n  w[i] *= (B3 * 146.0) * invCORRP;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/26"}
{"code": "for (j = 1; j < (Ny - 1); j++)\n{\n  for (i = 1; i < (Nx - 1); i++)\n  {\n    I[i][j] = Un[i][j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saggelit/OpenMp/project2020parallel/6"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"a[%d]:%d\\n\", i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_7/Ejercicio_2/ordered_openmp/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  expr = i % ((3 * (i / 30)) + 1);\n  if (expr == 0)\n  {\n    jmax[i] = N;\n  }\n  else\n  {\n    jmax[i] = 1;\n  }\n\n  c[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cstyl/omp-scheduling/src/loops/workload/1"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    Y[start][i][j] = X[start][i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshtburris/CS-475-PA2/MMScan/0"}
{"code": "for (ej = 0, nedges = 0, vi = 0; vi < nvtxs; vi++)\n{\n  for (ei = xadj[vi], eiend = xadj[vi + 1]; ei < eiend; ei++, ej++)\n  {\n    vault->ktedges[ej].vi = gk_min(vault->iperm[vi], vault->iperm[adjncy[ei]]);\n    vault->ktedges[ej].vj = gk_max(vault->iperm[vi], vault->iperm[adjncy[ei]]);\n    if (adjwgt[ei] > 0)\n      vault->ktedges[ej].k = (-sups[nedges++]) + 2;\n    else\n      vault->ktedges[ej].k = 2;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/11"}
{"code": "for (i = 0; i < (M + 1); i++)\n{\n  for (j = 0; j < (N + 1); j++)\n  {\n    data[(i * (N + 1)) + j] = (((DATA_TYPE) i) * j) / (M + 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/CORR/correlation/2"}
{"code": "for (i = 0; i < (1 << 11); i++)\n  key_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    temp[i] = (A[(i * n) + j] * p[j]) + temp[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/23"}
{"code": "for (int i = 0; i < (size - 1); i++)\n{\n  if ((data_gpu[i] > data_gpu[i + 1]) || (data_gpu[i] != data_cpu[i]))\n  {\n    pass = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bitonic-sort-omp/main/5"}
{"code": "for (i = 1; i < num_roots; ++i)\n{\n  void *status;\n  pthread_join(roots[i], &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/root-threads-affinity/3"}
{"code": "for (int i = 1; i < (DIM - 1); i++)\n  for (int j = 1; j < (DIM - 1); j++)\n{\n  int g = TABLE[(i * DIM) + j];\n  int r;\n  int v;\n  int b;\n  r = (v = (b = 0));\n  if (g == 1)\n    v = 255;\n  else\n    if (g == 2)\n    b = 255;\n  else\n    if (g == 3)\n    r = 255;\n  else\n    if (g == 4)\n    r = (v = (b = 255));\n  else\n    if (g > 4)\n    r = (b = 255 - ((240 * ((double) g)) / ((double) max_grains)));\n\n\n\n\n\n  cur_img(i, j) = (((r << 24) | (v << 16)) | (b << 8)) | 255;\n  if (g > max)\n    max = g;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/14"}
{"code": "for (i = 1; i <= channels; i++)\n{\n  lnorm -= (mixingPos[-i] * mixingPos[-i]) >> overlapDividerBitsNorm;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/TDStretch/7"}
{"code": "for (int n = begin_vec.at(0); n < 0; n++)\n{\n  for (int h = begin_vec.at(1); h < 1; h++)\n  {\n    ;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/openmp_capture_const_var_ast_print/0"}
{"code": "for (int i = 0; i < nAntenas; i++)\n{\n  actualizar(mapa, rows, cols, antenas[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cramer-0xbit/antenas-openmp/antenas/6"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_fwd, 0);\n    gettimeofday(&s_bck_out, 0);\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_out, 0);\n    gettimeofday(&s_bck_hid, 0);\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_hid, 0);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/20"}
{"code": "for (int i = 0; i < numProcs; ++i)\n{\n  slave.push_back(threadId);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shohirose/openmp-examples/src/gather/0"}
{"code": "for (int i = 0; i < input.lookups; i++)\n  validation_hash += verification[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-offload/simulation/1"}
{"code": "for (int j = half_length + 1; j < (row - (half_length + 1)); j++)\n{\n  for (int i = 0; i < col; i++)\n  {\n    float acc = 0.0f;\n    for (int k = 0; k < filter_length; k++)\n    {\n      acc += temp[(((j + k) - half_length) * col) + i] * filter[k];\n    }\n\n    calculated->mem[(j * col) + i] = acc;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akgunduz/benchpar/src/app/conv/convfuncs/1"}
{"code": "for (long i = 0; i < N; i++)\n{\n  if (C[i] == 0)\n    isZero = true;\n\n  if (C[i] < 0)\n    isNegative = true;\n\n  if (C[i] > nC)\n  {\n    nC = C[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/22"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n  if (isBoundary(i))\n  nb_bounds++;\n\n\n", "pragma": "#pragma omp parallel for reduction(+:nb_bounds)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/io/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i][j][k + 1] = lhs[0][i][j][k + 1] + comz1;\n    lhs[1][i][j][k + 1] = lhs[1][i][j][k + 1] - comz4;\n    lhs[2][i][j][k + 1] = lhs[2][i][j][k + 1] + comz5;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/36"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/32"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    matvec_sub(lhs[i][j][k][AA], rhs[i - 1][j][k], rhs[i][j][k]);\n    matmul_sub(lhs[i][j][k][AA], lhs[i - 1][j][k][CC], lhs[i][j][k][BB]);\n    binvcrhs(lhs[i][j][k][BB], lhs[i][j][k][CC], rhs[i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/41"}
{"code": "for (int x = 0; x < 10; ++x)\n  foo();\n\n", "pragma": "    #pragma omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_private_messages/2"}
{"code": "for (int j3 = 1; j3 < (m3j - 1); j3++)\n{\n  int i3 = (2 * j3) - d3;\n  for (int j2 = 1; j2 < (m2j - 1); j2++)\n  {\n    int i2 = (2 * j2) - d2;\n    double x1[M];\n    double y1[M];\n    double x2;\n    double y2;\n    for (int j1 = 1; j1 < m1j; j1++)\n    {\n      int i1 = (2 * j1) - d1;\n      x1[i1] = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      y1[i1] = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n    }\n\n    int tmp = 0;\n    for (int j1 = 1; j1 < (m1j - 1); j1++)\n    {\n      tmp += 2;\n      int i1 = (tmp - d1) + 1;\n      int tmp2 = tmp - d1;\n      y2 = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n      x2 = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      s[j3][j2][j1] = (((0.5 * r[i3 + 1][i2 + 1][i1]) + (0.25 * ((r[i3 + 1][i2 + 1][i1 - 1] + r[i3 + 1][i2 + 1][i1 + 1]) + x2))) + (0.125 * ((x1[i1 - 1] + x1[i1 + 1]) + y2))) + (0.0625 * (y1[i1 - 1] + y1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(d1,d2,d3) collapse(1) num_threads(threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment10/real/real/2"}
{"code": "for (int i = 10 - 1; i > 1; i--)\n{\n  for (int j = 0; j <= (i - 1); j++)\n  {\n    if (tab[j + 1] < tab[j])\n    {\n      int t = tab[j + 1];\n      tab[j + 1] = tab[j];\n      tab[j] = t;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/tris/bulle-omp/1"}
{"code": "for (j = 0; j < N; j++)\n{\n  sum += matrix[i][j];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luki00765/PROBLEMY/DODAWANIE_ELEMENTOW_MATRIXA/OpenMP/openmp/0"}
{"code": "for (i = 0; i < 4; i++)\n  pthread_create(&threads[i], 0, binary_search, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = i; j < n; j++)\n  {\n    srand48(time(0));\n    R[i][j] = drand48();\n    sum += R[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yinglyu/openmp-matrix-inversion/ir_openmp/2"}
{"code": "for (i = 1; i < ((*tcount) + 1); i++)\n{\n  MMX22[i] = MMX2[i];\n  MMX33[i] = MMX3[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXreduction/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    printf(\"%d \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  result += x[i] * y[i];\n}\n\n", "pragma": "#pragma omp for schedule(static) reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gtrabes/OpenMPExample/openmp_example/3"}
{"code": "for (ii = 0; (ii < bots_arg_size) && ok; ii++)\n{\n  for (jj = 0; (jj < bots_arg_size) && ok; jj++)\n  {\n    if ((SEQ[(ii * bots_arg_size) + jj] == ((void *) 0)) && (BENCH[(ii * bots_arg_size) + jj] != ((void *) 0)))\n      ok = 0;\n\n    if ((SEQ[(ii * bots_arg_size) + jj] != ((void *) 0)) && (BENCH[(ii * bots_arg_size) + jj] == ((void *) 0)))\n      ok = 0;\n\n    if ((SEQ[(ii * bots_arg_size) + jj] != ((void *) 0)) && (BENCH[(ii * bots_arg_size) + jj] != ((void *) 0)))\n      ok = checkmat(SEQ[(ii * bots_arg_size) + jj], BENCH[(ii * bots_arg_size) + jj]);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/sparselu/src/sparselu_ompi/5"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (wm1,wijk,wp1,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/132"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (ai == this->mat_.col[aj])\n    {\n      ++size;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/35"}
{"code": "for (int k = 0; k < this->nrow_; ++k)\n{\n  marker[k] = 0;\n  nd[k] = (this->mat_.row_offset[k + 1] - this->mat_.row_offset[k]) - 1;\n  if (nd[k] > maxdeg)\n  {\n    maxdeg = nd[k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/75"}
{"code": "for (int i = 0; i < len; i++)\n{\n  sz = arr_host[i].len * (sizeof(int));\n  arr_host[i].arr_dev = (int *) omp_target_alloc(sz, device_id);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/alloc/main_nested/0"}
{"code": "for (int n = 0; n < nt; ++n)\n{\n  if ((n % 300) == 0)\n  {\n    (cout << n) << endl;\n    if (plotnum < 10)\n    {\n      SF.WriteData((\"modsqr_0\" + to_string(plotnum)) + \".dat\");\n    }\n    else\n    {\n      SF.WriteData((\"modsqr_\" + to_string(plotnum)) + \".dat\");\n    }\n\n    plotnum += 1;\n  }\n\n  rk4_step(NGHOST, NX1, NX2, dt, dx, dy, idx, idy, 1., ISIGMASQ, SF, dummy1, dummy2, dummy3, dummy4);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rc634/Schr-OpenMP-dinger/ErwinSchrodinger/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_for_nowait())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_nowait/2"}
{"code": "for (unsigned int i = 0; i < latlen; i++)\n  vectoradd(mag, lattice[i], 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keygenx/N-Vector-Model/Vector Model/15"}
{"code": "for (unsigned int i = 0; i < ((L / NODESY) + 2); i++)\n  grs[i] = gnt[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/89"}
{"code": "for (int i = 0; i < height; ++i)\n{\n  for (int j = 0; j < width; ++j)\n  {\n    if (a[i][j])\n    {\n      (((out << (i + 1)) << ' ') << (j + 1)) << '\\n';\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexSofienko/Game_of_life/life_modulator/4"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (dssp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/106"}
{"code": "for (row = 0; row < width; row++)\n{\n  cy = 0.10461 + (row * dy);\n  for (col = 0; col < width; col++)\n  {\n    cx = 0.74395 + (col * dx);\n    x = -cx;\n    y = -cy;\n    depth = maxdepth;\n    do\n    {\n      x2 = x * x;\n      y2 = y * y;\n      y = ((2 * x) * y) - cy;\n      x = (x2 - y2) - cx;\n      depth--;\n    }\n    while ((depth > 0) && ((x2 + y2) <= 5.0));\n    cnt[(row * width) + col] = depth & 255;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(width,dy,dx,maxdepth,cnt) private(row,cy,cx,x,y,depth,col,x2,y2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Froy137/openMP/fractal_omp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  InitializeArray_Parallel(tid, i, x, 0.0);\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yilehu/CG_OpenMP/main/0"}
{"code": "for (size_t i = 0; i < KERNEL_HEIGHT; i++)\n{\n  for (size_t j = 0; j < KERNEL_WIDTH; j++)\n  {\n    const double v = kernel_row[i] * kernel_row[j];\n    output.kernel[i][j] = v;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/blurrifier-openmp/main/2"}
{"code": "for (i = 0; i < 10; i++)\n  b[i] = (c[i] = i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bhuvaneswar005/OpenMP/Assignment 4/Code/fptp/2"}
{"code": "for (int i = 1; i < (nxn - 2); i++)\n  for (int j = 1; j < (nyn - 2); j++)\n  for (int k = 1; k < (nzn - 2); k++)\n{\n  Bxt = Bxn[i][j][k] + Bx_ext[i][j][k];\n  Byt = Byn[i][j][k] + By_ext[i][j][k];\n  Bzt = Bzn[i][j][k] + Bz_ext[i][j][k];\n  localBenergy += ((((.5 * dx) * dy) * dz) * (((Bxt * Bxt) + (Byt * Byt)) + (Bzt * Bzt))) / FourPI;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/114"}
{"code": "for (int i = imax; i < mySeeds.size(); i++)\n  (app_log() << setw(12)) << mySeeds[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/OhmmsApp/RandomNumberControl/5"}
{"code": "for (int cin = 0; cin < Cin; ++cin)\n{\n  for (int i = 0; i < 4; ++i)\n  {\n    BTxB[((cin * 16) + (i * 4)) + 0] = BTx[((cin * 28) + (i * 7)) + 0] - BTx[((cin * 28) + (i * 7)) + 4];\n    BTxB[((cin * 16) + (i * 4)) + 1] = BTx[((cin * 28) + (i * 7)) + 2] + BTx[((cin * 28) + (i * 7)) + 4];\n    BTxB[((cin * 16) + (i * 4)) + 2] = (-BTx[((cin * 28) + (i * 7)) + 2]) + BTx[((cin * 28) + (i * 7)) + 4];\n    BTxB[((cin * 16) + (i * 4)) + 3] = BTx[((cin * 28) + (i * 7)) + 2] - BTx[((cin * 28) + (i * 7)) + 6];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/winograd_transform/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  ptr[i] = malloc((sizeof(int)) * m);\n  for (int j = 0; j < m; j++)\n  {\n    ptr[i][j] = rand() % 10;\n    if (print_arr)\n      printf(\"%d \", ptr[i][j]);\n\n  }\n\n  if (print_arr)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t1/3"}
{"code": "for (int iter = 0; iter < n_n_items; iter++)\n{\n  remaining_to_send = npts_to_proc % n_n_items;\n  npts_to_send = (npts_to_proc / n_n_items) + ((iter == 0) ? (remaining_to_send) : (0));\n  offset_to_send = (iter * npts_to_send) + ((iter == 0) ? (0) : (remaining_to_send));\n  MPI_Recv(coul_ao_node + ((offset_to_send * nao) * nao), (npts_to_send * nao) * nao, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenTho-Uni/libqqc/libqqc/loader/loader_qmp2_from_file_mpi/7"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < o; j++)\n  {\n    double sum = 0.0;\n    for (int k = 0; k < n; k++)\n    {\n      sum += mat1[i][k] * mat2[k][j];\n    }\n\n    res[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pradeepsinngh/practice-parallel-programming/openmp/matrix_multiplication_openmp/0"}
{"code": "for (size_t i = 0u; i < n_centroids; ++i)\n{\n  centroids[i] = pixels[rand() % n_pixels];\n  struct pixel tmp = {0.0, 0.0, 0.0};\n  sums[i] = tmp;\n  counts[i] = 0u;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/2"}
{"code": "for (int nIter = 0; nIter < 50; nIter++)\n{\n  double J;\n  double JA;\n  double JB;\n  EvaluateFit(data, A, B, J, JA, JB);\n  if ((nIter == 0) || (J < bestJ))\n  {\n    bestJ = J;\n    bestA = A;\n    bestB = B;\n  }\n\n  double norm = Sqr(JA) + Sqr(JB);\n  if (norm < 1e-10)\n    break;\n\n  const int cl = -1;\n  double Jc = EvaluateFit(data, A + (((cl * lambda) * JA) / norm), B + (((cl * lambda) * JB) / norm));\n  if (Jc > J)\n  {\n    while (lambda > 1e-5)\n    {\n      lambda = 0.5 * lambda;\n      Jc = EvaluateFit(data, A + (((cl * lambda) * JA) / norm), B + (((cl * lambda) * JB) / norm));\n    }\n\n  }\n  else\n    if (Jc < J)\n  {\n    while (lambda < 1e5)\n    {\n      double lambda2 = 2 * lambda;\n      double Jc2 = EvaluateFit(data, A + (((cl * lambda2) * JA) / norm), B + (((cl * lambda2) * JB) / norm));\n      if (Jc2 > Jc)\n      {\n        break;\n      }\n\n      if (IsNan(Jc2))\n      {\n        break;\n      }\n\n      lambda = lambda2;\n      Jc = Jc2;\n    }\n\n  }\n\n\n  if (Jc >= J)\n    break;\n\n  A += ((cl * lambda) * JA) / norm;\n  B += ((cl * lambda) * JB) / norm;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/92"}
{"code": "for (int i = 1; i < N; i++)\n{\n  A[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabdam/hpc/lab6/lab6/1"}
{"code": "for (i = 0; i <= (2048 + 1); i++)\n{\n  T[i][0] = 0.0;\n  T[i][2048 + 1] = (128.0 / 2048) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/sc20-gpu-offloading/4_data/openmp/laplace_mp/3"}
{"code": "for (int i = 0; i < vec.size(); i++)\n{\n  ret = (ret && (hi[i] == vec[i].x[0])) && (lo[i] == vec[i].x[1]);\n  if (ret == false)\n    return ret;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/basic_op/vector_comparison/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < columns; j++)\n  {\n    if ((cost[i][j] < min) && is_valid_edge(i, j, vertices_in_mst))\n    {\n      min = cost[i][j];\n      a = i;\n      b = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lffloyd/prog-paralela-trabalho/src/omp_prim/omp_prim/0"}
{"code": "for (int i = 0; i < step; i++)\n{\n  printf(\"%u \", output[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/omp10/0"}
{"code": "for (m = c + 1; m <= (N - 1); m++)\n{\n  if ((m % c) == 0)\n  {\n    list[m] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheinemann/exercise_code_openmp_mpi_hybrid/sieve/sieve.openmp/1"}
{"code": "for (iy = 0; iy < config.screeny; iy++)\n{\n  for (ix = 0; ix < config.screenx; ix++)\n  {\n    bitmap[(iy * config.screenx) + ix].r = escapetime[(iy * config.screenx) + ix];\n    bitmap[(iy * config.screenx) + ix].g = escapetime[(iy * config.screenx) + ix];\n    bitmap[(iy * config.screenx) + ix].b = escapetime[(iy * config.screenx) + ix];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/h3nnn4n/Parallel_Mandelbrot_set/src/main_openmp/1"}
{"code": "for (int thrd_i = 0; thrd_i < total_thrd; ++thrd_i)\n  ((((cout << \"Thread \") << thread_rows[thrd_i].first) << \" -> Processing Chunk starting at Row \") << thread_rows[thrd_i].second) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/changgyhub/distributed-systems/3 OpenMP/Sobel/2"}
{"code": "for (int i = 0; i < numHidden1Nodes; ++i)\n{\n  layer1_weights[i] = (double *) malloc((sizeof(double)) * numInputs);\n  layer1_bias[i] = weights_init();\n  for (int j = 0; j < numInputs; ++j)\n  {\n    layer1_weights[i][j] = weights_init();\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/2"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  xi = ((double) i) * dnxm1;\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    eta = ((double) j) * dnym1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[i][j][k][m] = temp[m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/10"}
{"code": "for (i = 0; i < 100; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/29"}
{"code": "for (i = 0; i < vezes; i++)\n{\n  unsigned long long plain = 0;\n  unsigned long long cipher;\n  int indice = i * 8;\n  int x;\n  for (x = 0; x < 8; x++)\n    plain = plain | (((unsigned long long) inByteArray[indice + x]) << (64 - (8 * (x + 1))));\n\n  cipher = encryptDESplain(plain, subKeys);\n  for (x = 0; x < 8; x++)\n    outByteArray[indice + x] = (unsigned char) ((cipher >> (56 - (8 * x))) & 0xFF);\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(vezes,outByteArray) private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/DES/DES/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total_error += squared_errors[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+ : total_error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/sgd/omp_target/3"}
{"code": "for (int k = 0; k < ((Size * Size) - Size); k += Size + 1)\n{\n  for (int i = k + Size; i < (Size * Size); i += Size)\n  {\n    tmp = (-pMatrix[i]) / pMatrix[k];\n    for (int j = i; j < (i + Size); j++)\n    {\n      for (int h = k; h < (k + Size); h++)\n      {\n        if (j == (h + (Size * count)))\n        {\n          pMatrix[j] += pMatrix[h] * tmp;\n        }\n\n      }\n\n    }\n\n    count++;\n  }\n\n  count = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savinaDaria/Cramer_rule_OpenMP/lab2OpenMP/lab2OpenMP/3"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-i\") == 0)\n  {\n    maxiter = atoi(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-w\") == 0)\n  {\n    width = atoi(argv[++i]);\n    height = width;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    size = atof(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-o\") == 0)\n  {\n    if ((fp = fopen(\"mandel.out\", \"wb\")) == 0)\n    {\n      fprintf(stderr, \"Unable to open file\\n\");\n      return 1;\n    }\n\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    x0 = atof(argv[++i]);\n    y0 = atof(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-i maxiter -w windowsize -c x0 y0 -s size]\\n\", argv[0]);\n    fprintf(stderr, \"\t   -i to specify maximum number of iterations at each point (default 1000)\\n\");\n    fprintf(stderr, \"\t   -w to specify the size of the image to compute (default 800x800 elements)\\n\");\n    fprintf(stderr, \"\t   -c to specify the center x0+iy0 of the square to compute (default origin)\\n\");\n    fprintf(stderr, \"\t   -s to specify the size of the square to compute (default 2, i.e. size 4 by 4)\\n\");\n    return 1;\n  }\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab3/par2312-lab3/code/mandel-omp-taskloop-point/1"}
{"code": "for (i = 0; i < r_length; i++)\n{\n  for (j = 0; j < c_length; j++)\n  {\n    printf(\"%6.2f   \\t\", m[(i * c_length) + j]);\n    printf(((j % line_length) == (line_length - 1)) ? (\"\\n\") : (\"\"));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/par_mm/6"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d workds on element %d.\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i) schedule(static, n_per_thread)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/vector_addition/0"}
{"code": "for (int i = 0; i < ((height * width) * 3); i++)\n{\n  pic[i] = input.get();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GermanRandle/contrast-openmp/image-processor/main/5"}
{"code": "for (i = 0; i < k; i++)\n  scanfArgs += scanf(\"%lf %lf %lf\", mean + (i * 3), (mean + (i * 3)) + 1, (mean + (i * 3)) + 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/almeidaraul/kmeans-openmp/kmeans/1"}
{"code": "for (long i = 2; i <= 500; i *= 2)\n{\n  res[i] = matrixMulParallel(i);\n  printf(\"#threads: %ld time: %lf\\n\", i, res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q4/q4/3"}
{"code": "for (int i = 0; i < dataset->nOfOutputs; i++)\n{\n  for (int j = 0; j < dataset->nOfOutputs; j++)\n  {\n    confusionMatrix[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/28"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  if (i != line)\n  {\n    for (j = 0; j <= dimension; j++)\n    {\n      matrix[(i * (dimension + 1)) + j] -= vet[i] * matrix[(line * (dimension + 1)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giovaniortolani/Projeto2-ProgConc/src/gauss/8"}
{"code": "for (int mat = (cc.Nmats / 2) + 1; mat < ((cc.Nmats / 2) + 5); mat++)\n{\n  int i = 2;\n  int j = (sizey / 2) + 1;\n  cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 0.0;\n  cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 0.0;\n  cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 0.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/7"}
{"code": "for (int i = 0; i < 102400; i++)\n{\n  sum += vecC[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/gpu-openmp/gpu-functions/sum/1"}
{"code": "for (size_t i = 0; i < params.num_rows; i++)\n{\n  transform_input_image_row(params.scanned_lines[i], params.output_lines[i], params.decompressor->output_width);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/grayscaler-openmp/main/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  pos(i).x = i;\n  pos(i).y = i + 1;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/target_map_messages/0"}
{"code": "for (steps = 0; steps < np; steps++)\n{\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < col; j++)\n    {\n      tmp1 = 0;\n      for (k = 0; k < 3; k++)\n      {\n        mult_tmp = mm[(i * 3) + k] * matrix[(k * col) + j];\n        mod = mult_tmp / PMOD;\n        mult_tmp = mult_tmp - (((long double) mod) * ((long double) PMOD));\n        if ((mult_tmp < 0.0) && (col <= 1))\n          mult_tmp += (long double) PMOD;\n\n        tmp1 += mult_tmp;\n      }\n\n      mod = tmp1 / PMOD;\n      tmp1 = tmp1 - (((long double) mod) * ((long double) PMOD));\n      if ((tmp1 < 0.0) && (col <= 1))\n        tmp1 += (long double) PMOD;\n\n      ret1[i][j] = tmp1;\n    }\n\n  }\n\n  for (i = 0; i < 3; i++)\n  {\n    for (j = 0; j < col; j++)\n    {\n      retmatrix[(i * col) + j] = ret1[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prod-feng/CLCG-Parallel-RNG/clcg-parallel-mrg32k3a/1"}
{"code": "for (int i = 0; i < Nx; i++)\n  un[i] = (double *) malloc(Ny * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/3"}
{"code": "for (i = 0; i < 1200; i++)\n{\n  for (j = 0; j < 1200; j++)\n  {\n    A[(i * 1200) + j] = (((DATA_TYPE) i) * j) / 1200;\n  }\n\n  for (j = 0; j < 1200; j++)\n  {\n    C[(i * 1200) + j] = ((((DATA_TYPE) i) * j) + 2) / 1200;\n    D[(i * 1200) + j] = ((((DATA_TYPE) i) * j) + 2) / 1200;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYRK/syrk/13"}
{"code": "for (i = start_frame; i <= last_frame; i++)\n{\n  for (j = 0; j < num_files; j++)\n  {\n    switch (j)\n    {\n      case 0:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P0\");\n        break;\n\n      case 1:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P1\");\n        break;\n\n      case 2:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P2\");\n        break;\n\n      case 3:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P3\");\n        break;\n\n      case 4:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R0\");\n        break;\n\n      case 5:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R1\");\n        break;\n\n      case 6:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R2\");\n        break;\n\n      case 7:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"NS\");\n        break;\n\n    }\n\n    snprintf(file_no_thread_num, sizeof(file_no_thread_num), \"%s%s%d%s%s%s\", dir, \"mcdata_\", i, \"_\", mcdata_type, \".dat\");\n    snprintf(filename_0, sizeof(filename_0), \"%s%s%d%s%s%s\", dir, \"mcdata_\", i, \"_\", mcdata_type, \"_0.dat\");\n    snprintf(filename_1, sizeof(filename_1), \"%s%s%d%s%s%s\", dir, \"mcdata_\", i, \"_\", mcdata_type, \"_1.dat\");\n    if ((access(filename_0, F_OK) != (-1)) && (access(filename_1, F_OK) != (-1)))\n    {\n      snprintf(cmd, sizeof(cmd), \"%s%s %s%s%s\", \"cat \", filename_0, filename_1, \" > \", file_no_thread_num);\n    }\n    else\n      if ((access(filename_0, F_OK) == (-1)) && (access(filename_1, F_OK) != (-1)))\n    {\n      snprintf(cmd, sizeof(cmd), \"%s%s%s%s\", \"cat \", filename_1, \" > \", file_no_thread_num);\n    }\n    else\n      if ((access(filename_0, F_OK) != (-1)) && (access(filename_1, F_OK) == (-1)))\n    {\n      snprintf(cmd, sizeof(cmd), \"%s%s%s%s\", \"cat \", filename_0, \" > \", file_no_thread_num);\n    }\n    else\n    {\n      printf(\"No mcdata files exist for frame %d\\n\", i);\n    }\n\n\n\n    system(cmd);\n    snprintf(cmd, sizeof(cmd), \"%s%s\", \"rm \", filename_0);\n    system(cmd);\n    snprintf(cmd, sizeof(cmd), \"%s%s\", \"rm \", filename_1);\n    system(cmd);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/17"}
{"code": "for (size_t m1BlockCount = 0; m1BlockCount < (threadsNum * threadsNum); m1BlockCount++)\n{\n  size_t iBlockIndex = m1BlockCount / threadsNum;\n  size_t jBlockIndex = m1BlockCount % threadsNum;\n  for (size_t tBlockIndex = 0; tBlockIndex < threadsNum; tBlockIndex++)\n  {\n    for (size_t i = iBlockIndex * m1BlockHeight; i < ((iBlockIndex + 1) * m1BlockHeight); i++)\n      for (size_t j = jBlockIndex * m1BlockWidth; j < ((jBlockIndex + 1) * m1BlockWidth); j++)\n      for (size_t t = tBlockIndex * m2BlockWidth; t < ((tBlockIndex + 1) * m2BlockWidth); t++)\n      resultMatrix[i][t] += matrix1[i][j] * matrix2[j][t];\n\n\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sncodeGit/openmp_labs/Task4/Task4/0"}
{"code": "for (int l = 0; l < num; ++l)\n{\n  (cout << y[l]) << \" \";\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vksmgr/OpenMp/src/openmp/run/3"}
{"code": "for (i = 0; i < LINHAS; i++)\n{\n  for (j = 0; j < COLUNAS_B; j++)\n    printf(\"%6.2f   \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/6-Matriz/MultiMatriz/MultiMatriz/Origem/4"}
{"code": "for (int i = 1; i <= 2500000; i++)\n  funcsum[0] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  fgets(buf, sizeof(buf), fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GChaitanya2001/HP3-OpenMP/Many Body Simulation/many-body-sim-program/5"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].update_dim_size(num_samples);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/12"}
{"code": "for (int i = k; i <= maxim; i++)\n{\n  if (X[i] == Y[k - 1])\n  {\n    C[i][k] = C[i - 1][k - 1] + 1;\n  }\n  else\n  {\n    C[i][k] = max(C[i][k - 1], C[i - 1][k]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided,granularity)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/himanshudhawale/LongestCommonSubsequence-OpenMP-Advanced/lcs/1"}
{"code": "for (int row = 0; row < height; ++row)\n  if (fwrite(output[row], sizeof(int), width, fp) != width)\n{\n  fprintf(stderr, \"Output file not written correctly\\n\");\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab3/mandel-omp/1"}
{"code": "for (i = 1; i < (h - 1); ++i)\n  for (j = 1; j < (w - 1); ++j)\n  draw_point(j - 1, i - 1, g[(i * w) + j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/compute/5"}
{"code": "for (int i = 0; i < dimord; i++)\n{\n  gaussian_filter[i] = Gaussian1D(abs(i - halfdimord), sigma);\n  acumuladorgauss += gaussian_filter[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vorixo/OMP-ImageFiltering-EasyBMP/Proyecto/Practica1/0"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n  arr1[i][j] = rand() % 10;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task2/0"}
{"code": "for (; j < second_partition_end; j++)\n{\n  *(output_sorted + copy_to) = *(exchange_rankings + j);\n  copy_to++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/community-exchange/3"}
{"code": "for (int s = 0; s < nb_system; s++)\n{\n  double min = systems[s].variable_value_prev_t[0];\n  double max = systems[s].variable_value_prev_t[0];\n  for (int i = 0; i < systems[s].system_size; i++)\n  {\n    systems[s].variable_value_t[i] = 0;\n    min = min(min, systems[s].variable_value_prev_t[i]);\n    max = max(max, systems[s].variable_value_prev_t[i]);\n  }\n\n  for (int i = 0; i < systems[s].system_size; i++)\n  {\n    for (int j = 0; j < systems[s].system_size; j++)\n    {\n      systems[s].variable_value_t[i] += systems[s].variable_value_prev_t[j] * systems[s].value_matrix[i][j];\n    }\n\n    systems[s].variable_value_t[i] = (systems[s].variable_value_t[i] - min) / (max - min);\n  }\n\n  for (int i = 0; i < systems[s].system_size; i++)\n  {\n    systems[s].variable_value_prev_t[i] = systems[s].variable_value_t[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(shared) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.2/multiple_system_solver/0"}
{"code": "for (r = 0; r < 32768; r++)\n  hist[r] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/13"}
{"code": "for (short j = 1; j < width; j++)\n{\n  if (cumalativeEnergyMap[row][j] < minValue)\n  {\n    minValue = cumalativeEnergyMap[row][j];\n    minXLoc = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tjp77/Seam-Carver/Seam Carver/8"}
{"code": "for (i = 0; i < DIM; i++)\n  for (j = 0; j < DIM; j++)\n{\n  if (c[i][j] != ck[i][j])\n  {\n    printf(\"Bad! %d %d %i %i\\n\", i, j, c[i][j], ck[i][j]);\n    exit(1);\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/knuth/knut_fix/2"}
{"code": "for (i = k + 1; i < m_size; i++)\n  for (j = k + 1; j < m_size; j++)\n{\n  aArray[i][j] = aArray[i][j] - (lArray[i][k] * uArray[k][j]);\n}\n\n\n", "pragma": "    #pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    const elem_t d = a[(i * n) + j] - (i == j);\n    e += d * d;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/Sci Lab Code in C/3.Inverse_openMP/6"}
{"code": "for (ti = 0; ti < (2048 / 32); ti++)\n{\n  for (tj = 0; tj < (2048 / 32); tj++)\n  {\n    register int diag = ti + tj;\n    if (!((diag >= first) && (diag <= last)))\n    {\n      continue;\n    }\n\n    for (i = ti * 32; i < (32 + (ti * 32)); i++)\n    {\n      for (j = tj * 32; j < (32 + (tj * 32)); j++)\n      {\n        if ((i > 0) && (j == 0))\n        {\n          current[i][0] = previous[i][0] + 4;\n        }\n        else\n          if ((j > 0) && (i == 0))\n        {\n          current[0][j] = previous[0][j] + 2;\n        }\n\n\n        if ((0 != i) && (0 != j))\n        {\n          if (((i % 32) == 0) && ((j % 32) == 0))\n          {\n            current[i][j] = ((previous[i - 1][j] + previous[i][j - 1]) + previous[i][j]) / 3;\n          }\n          else\n            if ((j % 32) == 0)\n          {\n            current[i][j] = ((current[i - 1][j] + previous[i][j - 1]) + previous[i][j]) / 3;\n          }\n          else\n            if ((i % 32) == 0)\n          {\n            current[i][j] = ((previous[i - 1][j] + current[i][j - 1]) + previous[i][j]) / 3;\n          }\n          else\n          {\n            current[i][j] = ((current[i - 1][j] + current[i][j - 1]) + previous[i][j]) / 3;\n          }\n\n\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) default(none) shared(current, previous, first, last) private(i,j,ti,tj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab6_OpenMP/macropipelinev2/0"}
{"code": "for (i = 0; i < spreps; i++)\n{\n  D.zeros();\n  shuffle = uvec > ((n, distr_param(0, B.n_cols - 1)));\n  BG = B.cols(shuffle);\n  strp.zeros();\n  for (j = 0; j < n; j++)\n  {\n    Res = StrROne(D, P, data_proc.col(j).head(cov_num), cov_num, level_num, bsize, B, BG, strp);\n    strp = Res(0, 0);\n    BG = Res(1, 0);\n    assignew(j) = Res(2, 0)(0, 0);\n    D = Res(3, 0);\n  }\n\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  sp(i) = ((-sum(data_proc.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data_proc.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/44"}
{"code": "for (i = 0; i < (buckets_count - 1); i++)\n{\n  bucket_boundaries[i] = 0 + ((i + 1) * bucket_step);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc2/bsort/5"}
{"code": "for (int ki = 0; ki < k; ki++)\n{\n  printf(\"k%d\\t\", ki);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/20"}
{"code": "for (int i = 0; i < ((stringExample.length() - substringExample.length()) + 1); i++)\n{\n  int count = 0;\n  for (int j = 0; j < substringExample.length(); j++)\n  {\n    if (stringExample[i + j] != substringExample[j])\n    {\n      break;\n    }\n\n    count++;\n  }\n\n  if (count == substringExample.length())\n  {\n    result2 = i;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_7/7/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      dZ[i][j] += dX[i][k] * dY[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j,k) collapse(3) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yarensonmez/Seri-ve-Paralel-Matris-Carpimi/paralelproje/paralelproje/5"}
{"code": "for (i = start; i < end; i++)\n{\n  byte = byte_array_get(array, i);\n  if (!byte)\n    break;\n\n  ret |= do_or_single(byte);\n  if (ret == 1)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sudipta1411/bitsor/do_or/3"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    exact_solution(xi, eta, zeta, temp);\n    for (m = 0; m < 5; m++)\n    {\n      u[k][j][i][m] = temp[m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/initialize/2"}
{"code": "for (int i = 0; i < (geom1->n_grid_r - 1); i++)\n  j_r[i][geom1->n_grid_z - 1] = 0.;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/current/1"}
{"code": "for (i = 1; i <= 1000000; i = i + 1)\n{\n  buyerIndex = rand() % 10000;\n  bidPrice = (rand() % Buyers[buyerIndex].value) + 1;\n  sellerIndex = rand() % 10000;\n  askPrice = Sellers[sellerIndex].value + (rand() % ((20 - Sellers[sellerIndex].value) + 1));\n  if (((Buyers[buyerIndex].quantityHeld == 0) && (Sellers[sellerIndex].quantityHeld == 1)) && (bidPrice >= askPrice))\n  {\n    transactionPrice = askPrice + (rand() % ((bidPrice - askPrice) + 1));\n    Buyers[buyerIndex].price = transactionPrice;\n    Sellers[sellerIndex].price = transactionPrice;\n    Buyers[buyerIndex].quantityHeld = 1;\n    Sellers[sellerIndex].quantityHeld = 0;\n  }\n\n  ;\n}\n\n", "pragma": "omp parallel for private(buyerIndex, bidPrice, sellerIndex, askPrice, transactionPrice) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp1/0"}
{"code": "for (i = 0; i < ncolors; i++)\n{\n  smats[i]->rowind = gk_imalloc(smats[i]->rowptr[nrows], \"gk_csr_Split: smats[i]->rowind\");\n  smats[i]->rowval = gk_fmalloc(smats[i]->rowptr[nrows], \"gk_csr_Split: smats[i]->rowval\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/26"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  omp_set_lock(&lock);\n  sum += 1;\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/base_mutex/0"}
{"code": "for (int j = 0; j < num_asteroides; j++)\n{\n  double fuerza_x = 0;\n  double fuerza_y = 0;\n  for (int k = 0; k < num_asteroides; k++)\n  {\n    if (j != k)\n    {\n      if (sqrt(distaa(as_copia[j], as_copia[k])) <= 5)\n      {\n        as[j].set_vx(as_copia[k].get_vx());\n        as[j].set_vy(as_copia[k].get_vy());\n      }\n      else\n      {\n        fuerza_x += fuerzaxaa(as_copia[j], as_copia[k]);\n        fuerza_y += fuerzayaa(as_copia[j], as_copia[k]);\n      }\n\n    }\n\n  }\n\n  for (int k = 0; k < num_planetas; k++)\n  {\n    fuerza_x += fuerzaxpa(ps[k], as_copia[j]);\n    fuerza_y += fuerzaypa(ps[k], as_copia[j]);\n  }\n\n  actualizar(as[j], fuerza_x, fuerza_y);\n  {\n    if (as[j].get_px() <= 0)\n    {\n      as[j].set_px(5);\n      as[j].set_vx(0 - as[j].get_vx());\n    }\n\n    if (as[j].get_px() >= width)\n    {\n      as[j].set_px(width - 5);\n      as[j].set_vx(0 - as[j].get_vx());\n    }\n\n    if (as[j].get_py() <= 0)\n    {\n      as[j].set_py(5);\n      as[j].set_vy(0 - as[j].get_vy());\n    }\n\n    if (as[j].get_py() >= height)\n    {\n      as[j].set_py(height - 5);\n      as[j].set_vy(0 - as[j].get_vy());\n    }\n\n  }\n}\n\n", "pragma": "\t\t#pragma omp parallel for shared(as_copia, ps, as)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alejandrodzga/AC-Practica-Final/nasteroids-par/0"}
{"code": "for (int i = 0; i < g->num_verts; ++i)\n{\n  if (conn[i] == IN_SET)\n    ++num_in;\n  else\n    if (conn[i] == SCC_SET)\n    ++num_scc;\n  else\n    if (conn[i] == OUT_SET)\n    ++num_out;\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/scc/12"}
{"code": "for (k = 0; k < m; k++)\n  for (j = 0; j < n; j++)\n{\n  c[k][j] = r8_uniform_01(&seed);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brett-stephen/HP-Matrix-Multiplication/matrix/1"}
{"code": "for (i = 0; i < num_threads; i++)\n{\n  local_clusters[i] = (double **) malloc(k * (sizeof(double *)));\n  for (j = 0; j < k; j++)\n  {\n    local_clusters[i][j] = (double *) malloc(3 * (sizeof(double)));\n    local_clusters[i][j][0] = 0;\n    local_clusters[i][j][1] = 0;\n    local_clusters[i][j][2] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbish/pc-means/par_kmeans/7"}
{"code": "for (int i = 0; i < (*length); i++)\n{\n  mass_sum += soa->mass[i];\n  wx += soa->x[i] * soa->mass[i];\n  wy += soa->y[i] * soa->mass[i];\n}\n\n", "pragma": "omp parallel for reduction(+:mass_sum,wx,wy)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mishig25/2017Block2/patterns/reduce/openmp/0"}
{"code": "for (int k = 0; k < ((int) colours.size()); ++k)\n{\n  int dist = getMinDist(colours[k], x, y);\n  if (dist > limit)\n  {\n    limit = dist;\n    color_limit = (int) check.size();\n  }\n\n  if (dist == limit)\n  {\n    if (colours[k] < color_limit)\n    {\n      color_limit = colours[k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/10"}
{"code": "for (int i = 0; i < omp_n_threads; ++i)\n{\n  size_t seed_val = generate_seed_value(i, omp_n_threads, rand_engine);\n  rand_engines_vec.push_back(rand_engine_t(seed_val));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kthohr/optim/src/unconstrained/de/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  fn6();\n}\n\n", "pragma": "#pragma omp distribute parallel for if (Arg)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-5.0.0/llvm/tools/clang/test/OpenMP/distribute_parallel_for_if_codegen/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    ret = fscanf(file, \"%lf\", &(*hmm)->observationProbabilityMatrix[i][j]);\n  }\n\n  ret = fscanf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/graph_models/graph_models_omp/3"}
{"code": "for (int i = 0; i < E; i++)\n{\n  int u = (get < 0) > edges[i];\n  int v = (get < 1) > edges[i];\n  int weight = weights[i];\n  if ((dist[u] != INT_MAX) && ((dist[u] + weight) < dist[v]))\n    no_neg_cycle = false;\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/5"}
{"code": "for (int row_num = 0; row_num < ny; row_num++)\n{\n  *(g + row_num) = (double *) malloc(nx * (sizeof(double)));\n  *(h + row_num) = (double *) malloc(nx * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joshuaburkhart/laplace/laplace/1"}
{"code": "for (int i = 0; i < colourNr; ++i)\n{\n  colours.push_back(i);\n  check.push_back(false);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/2"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n  wClones[ip]->setNumSamples(nSamplesPerThread);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/CorrelatedSampling/CSVMC/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i] = r[i] + (beta * p[i]);\n}\n\n", "pragma": "omp parallel for num_threads(t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/9"}
{"code": "for (int i = 1; i < Nnodes_simplex; i++)\n{\n  b.nV[i - 1] = (-Beta.nM[i][i]) * (Norm_l.nV[simplex[0]] - Norm_l.nV[simplex[i]]);\n  for (int j = 0; j < Ndim; j++)\n  {\n    A.nM[i - 1][j] = l.nM[simplex[i]][j] - l.nM[simplex[0]][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  v[i] = (double *) malloc(m * (sizeof(double)));\n  if (v[i] == NULL)\n  {\n    printf(\"** Error: Insufficient memory **\");\n    free_matrix(v, n);\n    return NULL;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pesfahanian/Parallel_Strassen/Strassan Matrix Multiplication Final/0"}
{"code": "for (j = 0; j < ny; j++)\n{\n  y = ((double) j) / ((double) (ny - 1));\n  for (i = 0; i < nx; i++)\n  {\n    x = ((double) i) / ((double) (nx - 1));\n    uexact[i][j] = u_exact(x, y);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/poisson/3"}
{"code": "for (int i = 0; i < NB_LINE; ++i)\n{\n  for (int j = 0; j < NB_COLUMN; ++j)\n  {\n    printf(\"%d \", x[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/khaledbendia/matrice_openmp/khaled_bendia_matrice_openmp/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n  rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n  fac2 = 1. / lhs[n + 2][i][j1][k];\n  rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,k) firstprivate (j,n,j1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/193"}
{"code": "for (i = 0; i < arraySize; i++)\n{\n  array[i] = temp[i];\n}\n\n", "pragma": "omp parallel for shared(array, arraySize, temp) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcpablo/cefet-openmp/counting-sort/openmp/parallel/1"}
{"code": "for (x = 0; x < (num_snp * num_snp); x++)\n  scores[x] = FLT_MAX;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/epistatis-omp/main/10"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  n++;\n}\n\n", "pragma": "omp parallel for reduction(+:n)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CHOUAKIsalim/Exemples-OpenMP/datarace/0"}
{"code": "for (i = 0; i < observRows; i++)\n{\n  if (arr[i] < 0)\n  {\n    fprintf(f, \"\\n\\n\\n \");\n    fprintf(f, \"NEW PATH \\n-----------\\n \", arr[i]);\n    fprintf(f, \"%d, \", -arr[i]);\n    i++;\n  }\n\n  if (i == observRows)\n    break;\n\n  if (i != (observRows - 1))\n  {\n    fprintf(f, \"%d, \", arr[i]);\n  }\n  else\n  {\n    fprintf(f, \"%d\", arr[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/24"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (data->phase_discovered > max_distance)\n    max_distance = data->phase_discovered;\n\n  1(\"node_%d: parent = %d, dist = %d\\n\", cur->label, data->parent_label, data->phase_discovered);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/bfs_dijkstra/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum_pr_critical += a[i];\n}\n\n", "pragma": "#pragma omp for private(i) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/custom_reduction/1"}
{"code": "for (int i = 0; i < sd; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    (out_file << to_string(user_matrix[i][j])) << \" \";\n  }\n\n  out_file << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/10"}
{"code": "for (int i = 0; i < (max + 1); i++)\n{\n  double sum = 0.0;\n  for (int j = 0; j < (max + 1); j++)\n  {\n    if (graph2dArray[i][j] == 1)\n    {\n      sum = sum + (pagerankArray[j] / outlinkNumArray[j]);\n    }\n\n  }\n\n  pagerankArray[i] = (0.15 / totalnodes) + (0.85 * sum);\n  if (pagerankArray[i] < minPG)\n  {\n    minPG = pagerankArray[i];\n    minPgIndex = i;\n  }\n\n  if (pagerankArray[i] > maxPG)\n  {\n    maxPG = pagerankArray[i];\n    maxPgIndex = i;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soumitraj/OpenMP-MPI/Task1/task1/1"}
{"code": "for (i = 0; i < matB.l; i++)\n{\n  for (j = 0; j < matB.c; j++)\n  {\n    fscanf(pfileB, \"%f\", &matB.mat[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/mult_matriz/main/5"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 0; j <= (grid_points[1] - 1); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      xi = ((double) i) * dnxm1;\n      for (ix = 0; ix < 2; ix++)\n      {\n        exact_solution((double) ix, eta, zeta, &Pface[ix][0][0]);\n      }\n\n      for (iy = 0; iy < 2; iy++)\n      {\n        exact_solution(xi, (double) iy, zeta, &Pface[iy][1][0]);\n      }\n\n      for (iz = 0; iz < 2; iz++)\n      {\n        exact_solution(xi, eta, (double) iz, &Pface[iz][2][0]);\n      }\n\n      for (m = 0; m < 5; m++)\n      {\n        Pxi = (xi * Pface[1][0][m]) + ((1.0 - xi) * Pface[0][0][m]);\n        Peta = (eta * Pface[1][1][m]) + ((1.0 - eta) * Pface[0][1][m]);\n        Pzeta = (zeta * Pface[1][2][m]) + ((1.0 - zeta) * Pface[0][2][m]);\n        u[k][j][i][m] = (((((Pxi + Peta) + Pzeta) - (Pxi * Peta)) - (Pxi * Pzeta)) - (Peta * Pzeta)) + ((Pxi * Peta) * Pzeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/25"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%c \", comp[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/compact/compact_parallel/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DelSquared/OpenMP-Matrix-Multiplication-Parallelisation-Comarison/Parallel/Parallel/0"}
{"code": "for (int x = 0; x < GLOBAL_GRID_H; ++x)\n{\n  for (int y = 0; y < GLOBAL_GRID_W; ++y)\n    if (abs(grid_values[get_index_row(x, y)] - grid_precise_values[get_index_row(x, y)]) > 0.000001)\n    (((((((((cout << x) << ' ') << y) << ' ') << get_index_row(x, y)) << ' ') << grid_values[get_index_row(x, y)]) << \"~\") << grid_precise_values[get_index_row(x, y)]) << endl;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/27"}
{"code": "for (int i = 0; i < nodeNum; i++)\n  free(edges[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/15"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((ar[i] % 2) == 0)\n    even = even + ar[i];\n  else\n    odd = odd + ar[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gunjapandey/Introduction-to-OpenMP/l2_prog4/0"}
{"code": "for (i = 0; i < rows; i++)\n  Q[i][k] *= tmp;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.51.3/1"}
{"code": "for (i = 0; i < gr->nodes; i++)\n{\n  find_min(gr, minedge, i);\n}\n\n", "pragma": "omp parralel for num_threads(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris21gr/Boruvka_and_Dijkstra_Parallel/openMP_boruvka/openMP_boruvka/0"}
{"code": "for (int i = 0; i < size; i++)\n  printf(\"v[%d]: %f\\n\", i, v[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/17"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (i = ist; i <= iend; i++)\n    {\n      {\n        u[0][k][j][i] = u[0][k][j][i] + (tmp * rsd[0][k][j][i]);\n        u[1][k][j][i] = u[1][k][j][i] + (tmp * rsd[1][k][j][i]);\n        u[2][k][j][i] = u[2][k][j][i] + (tmp * rsd[2][k][j][i]);\n        u[3][k][j][i] = u[3][k][j][i] + (tmp * rsd[3][k][j][i]);\n        u[4][k][j][i] = u[4][k][j][i] + (tmp * rsd[4][k][j][i]);\n      }\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/ssor/1"}
{"code": "for (int x = x_m; x < (x_M / balance_factor); x++)\n{\n  for (int y = y_m; y < y_M; y++)\n  {\n    float r0 = vp[(x * size_u[0]) + y] * vp[(x * size_u[0]) + y];\n    ut1[(x * size_u[0]) + y] = ((((((-3.99999982e-2F) * r0) * r1) * ut0[(x * size_u[0]) + y]) + (9.99999955e-3F * (((((r0 * r1) * ut0[((x * size_u[0]) - 1) + y]) + ((r0 * r1) * ut0[((x - 1) * size_u[0]) + y])) + ((r0 * r1) * ut0[((x + 1) * size_u[0]) + y])) + ((r0 * r1) * ut0[((x * size_u[0]) + 1) + y])))) + (1.99999991F * ut0[(x * size_u[0]) + y])) - (9.99999955e-1F * ut2[(x * size_u[0]) + y]);\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(guided) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation_cpu/0"}
{"code": "for (unsigned int i = 0; i < TDim; ++i)\n{\n  step_datum[i] = step_datum_fast[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/8"}
{"code": "for (i = 1; i < (xcell + 1); i++)\n{\n  for (j = 1; j < (ycell + 1); j++)\n  {\n    u[0][i][j] = ((((i - 1) + xs[my_rank]) * ((10 - i) - xs[my_rank])) * ((j - 1) + ys[my_rank])) * ((10 - j) - ys[my_rank]);\n    u[1][i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUMTHREADS) collapse(2) schedule (static,1) default(none) private(i,j) shared(u, xs, ys, xcell, ycell, my_rank)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/6"}
{"code": "for (size_t i = 1; i < size; i++)\n{\n  size_t row_start = (size_t) (i * rows_per_worker);\n  size_t amt_of_rows = (size_t) (((i + 1) * rows_per_worker) - row_start);\n  num_organisms[i - 1] = (process_info[0] = amt_of_rows * world_size);\n  beginning[i - 1] = (process_info[1] = row_start * world_size);\n  MPI_Send(process_info, 2, MPI_SIZE_T, i, 0, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmorykan/BacteriaGrowthSimulation/simulation-distributed/5"}
{"code": "for (int i = 0; i < threadAmountThatUserPrefers; ++i)\n{\n  if (tempBiggests[i] > theBiggest)\n  {\n    theBiggest = tempBiggests[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fatihazir/OpenMP-Maximum-Value-Of-2d-Matris/MaxValueOfMatris/2"}
{"code": "for (int r = 0; r < N; r++)\n{\n  for (int c = 0; c < N; c++)\n  {\n    if (grid1[r][c] < 0)\n    {\n      if (grid1[r][c] == grid[r][c])\n      {\n        not_MTs++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:not_MTs)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CI4822-EneMar2020/BombingField/src/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  aS[i] = 0;\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trannguyendev/transportation-problem/ss/2"}
{"code": "for (i = 0; i < num_lines; i++)\n{\n  for (j = 0; j < num_lines; j++)\n  {\n    fprintf(output, \"%f \", result[i][j]);\n  }\n\n  fputs(\"\\n\", output);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaaasonwu/HeatDistribution/openmp_heat_distribution/2"}
{"code": "for (int _i0 = 2; _i0 < R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 2; _i1 < C; _i1 = _i1 + 1)\n  {\n    Sxy[(_i0 * (2 + C)) + _i1] = (((((((Ixy[(((-1) + _i0) * (2 + C)) + ((-1) + _i1)] + Ixy[(((-1) + _i0) * (2 + C)) + _i1]) + Ixy[(((-1) + _i0) * (2 + C)) + (1 + _i1)]) + Ixy[(_i0 * (2 + C)) + ((-1) + _i1)]) + Ixy[(_i0 * (2 + C)) + _i1]) + Ixy[(_i0 * (2 + C)) + (1 + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + ((-1) + _i1)]) + Ixy[((1 + _i0) * (2 + C)) + _i1]) + Ixy[((1 + _i0) * (2 + C)) + (1 + _i1)];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/6"}
{"code": "for (myrow = 0; myrow < SIZE; myrow++)\n  if (grid[myrow][col] == num)\n{\n  alreadyincol = 1;\n  myrow = SIZE;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/16"}
{"code": "for (j = 1; j < (2048 + 1); j++)\n{\n  stddev[j] = 0.0;\n  for (i = 1; i < (2048 + 1); i++)\n  {\n    stddev[j] += (data[(i * (2048 + 1)) + j] - mean[j]) * (data[(i * (2048 + 1)) + j] - mean[j]);\n  }\n\n  stddev[j] /= 3214212.01f;\n  stddev[j] = sqrt(stddev[j]);\n  if (stddev[j] <= 0.005f)\n  {\n    stddev[j] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/CORR/correlation/1"}
{"code": "for (i = 0; i < 16; i++)\n  ;\n\n", "pragma": "omp parallel for simd if (a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/if-1/0"}
{"code": "for (i = 1; i < (2048 + 1); i++)\n{\n  for (j = 1; j < (2048 + 1); j++)\n  {\n    data[(i * (2048 + 1)) + j] -= mean[j];\n    data[(i * (2048 + 1)) + j] /= sqrt(3214212.01f) * stddev[j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/CORR/correlation/2"}
{"code": "for (int i = 0; i < (dimension * dimension); i++)\n{\n  if ((i % dimension) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\"%*d\", count, squareMatrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JaredP94/Parallel-Matrix-Transposition/Code/OpenMP/lab2-OpenMP/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (x[i] > max_x)\n    max_x = x[i];\n\n  if (x[i] > min_x)\n    min_x = x[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rishdas/hpc/assignment2/problem3/1"}
{"code": "for (int i = 0; i < 2000; i++)\n{\n  for (int j = 0; j < 2000; j++)\n  {\n    arrA[i][j] = ((float) rand()) / 32767;\n    arrB[i][j] = ((float) rand()) / 32767;\n    arrC[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kbcovingtonjr/Matrix-Matrix_Multiplication_Optimization/Part_2/matMult/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  psum += arr[i];\n  pprod *= arr[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/diff-cs-openmp/0"}
{"code": "for (j = 0; j < (Size / 2); j++)\n  if (pData[2 * j] > pData[(2 * j) + 1])\n  swap(pData[2 * j], pData[(2 * j) + 1]);\n\n\n", "pragma": "#pragma omp parallel for shared(pData)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/sort/4"}
{"code": "for (i = 1; i < (maxI - 1); i++)\n{\n  for (j = 1; j < (maxJ - 1); j++)\n  {\n    if ((i + j) & 1)\n      continue;\n\n    C = (i * maxJ) + j;\n    N = ((i - 1) * maxJ) + j;\n    E = (i * maxJ) + (j + 1);\n    S = ((i + 1) * maxJ) + j;\n    W = (i * maxJ) + (j - 1);\n    old = arr[C];\n    new = (((arr[N] + arr[S]) + arr[W]) + arr[E]) / 4.0;\n    if (((((new - old) > 0.0) ? (new - old) : ((-new) - old)) / (((new > 0.0) ? (new) : (-new)) + SMALL)) > eps)\n    {\n      not_precise = 1;\n    }\n\n    arr[C] = new;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, old, new, C, N, E, S, W) reduction(+:not_precise)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/0"}
{"code": "for (unsigned i = 0; i < dists.size(); ++i)\n{\n  (((os << i) << ' ') << dists.at(i)) << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yowgf/delta-stepping/lib/main/appliance/Alg/deltaStepping/0"}
{"code": "for (ei_new = 0; ei_new < public.tMask_elem; ei_new++)\n{\n  private.d_tMask[ei_new] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/2"}
{"code": "for (int i = 1; i < (y_points - 1); i++)\n{\n  for (int j = 1; j < (x_points - 1); j++)\n  {\n    u_new[i][j] = ((((u[i][j] - ((u[i][j] * (del_t / del_x)) * (u[i][j] - u[i][j - 1]))) - ((v[i][j] * (del_t / del_y)) * (u[i][j] - u[i - 1][j]))) - ((del_t / ((2 * rho) * del_x)) * (p[i][j + 1] - p[i][j - 1]))) + (nu * (((del_t / (del_x * del_x)) * ((u[i][j + 1] + u[i][j - 1]) - (2 * u[i][j]))) + ((del_t / (del_y * del_y)) * ((u[i + 1][j] + u[i - 1][j]) - (2 * u[i][j])))))) + (F * del_t);\n    v_new[i][j] = (((v[i][j] - ((u[i][j] * (del_t / del_x)) * (v[i][j] - v[i][j - 1]))) - ((v[i][j] * (del_t / del_y)) * (v[i][j] - v[i - 1][j]))) - ((del_t / ((2 * rho) * del_y)) * (p[i + 1][j] - p[i - 1][j]))) + (nu * (((del_t / (del_x * del_x)) * ((v[i][j + 1] + v[i][j - 1]) - (2 * v[i][j]))) + ((del_t / (del_y * del_y)) * ((v[i + 1][j] + v[i - 1][j]) - (2 * v[i][j])))));\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Channel Flow/2-D_Channel_Flow/main/0"}
{"code": "for (int i = 0; i < (size * size); i++)\n{\n  fscanf(fp, \"%1d\", &arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/8"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dtty2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/70"}
{"code": "for (long i = 0; i < size; i++)\n{\n  Third[i] = First[i] + Second[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(First,Second,Third,size) schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Vector_Addition_Serial_Parallel/0"}
{"code": "for (int j = 0; j < rows; ++j)\n{\n  L += array[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p1c/1"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14u \", pageRankCorrelationStats_array[x].levenshtein_distance);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/27"}
{"code": "for (i = 0; i < 8; i++)\n{\n  out3[i] = (atoi16[ARCH_INDEX(ciphertext[(i * 2) + l])] * 16) + atoi16[ARCH_INDEX(ciphertext[((i * 2) + l) + 1])];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/oracle_fmt_plug/2"}
{"code": "for (int i = 0; i < wClones.size(); i++)\n  numW += wClones[i]->getActiveWalkers();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/8"}
{"code": "for (i = 0; i < _PB_NI; i++)\n{\n  for (j = 0; j < _PB_NJ; j++)\n    C[i][j] *= beta;\n\n  for (k = 0; k < _PB_NK; k++)\n    for (j = 0; j < _PB_NJ; j++)\n    C[i][j] += (alpha * A[i][k]) * B[k][j];\n\n\n}\n\n", "pragma": "omp parallel for private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/linear-algebra/blas/gemm/gemm/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  cout << \"\\n\";\n  for (j = 0; j < n; j++)\n    (cout << \"\\t\") << ary[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/void-mckenzie/OpenMP-Work/Programs/travelling_salesman/1"}
{"code": "for (int i = 0; i < (r / part); i++)\n{\n  sgemv(\"t\", &c, &part, &onef, mat + ((i * c) * part), &c, ones.data(), &one, &zerof, res + (i * part), &one);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(240)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savoptik/summation_of_matrix_rows_in_OpenMP/summation_of_matrix_rows_in_OpenMP/main/7"}
{"code": "for (i = 0; i < size; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/critical/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      adj_matrix[(i * n) + j] = 0;\n    }\n    else\n      if (flip(rand_engine) < p)\n    {\n      adj_matrix[(i * n) + j] = choose_weight(rand_engine);\n      E++;\n    }\n    else\n    {\n      adj_matrix[(i * n) + j] = INT_MAX;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/0"}
{"code": "for (it = 1; it <= nit; it++)\n{\n  if (((it == 1) || (it == nit)) || ((it % 100) == 0))\n  {\n    printf(\"  iter %3d\\n\", it);\n  }\n\n  mg3P(u, v, r, a, c, n1, n2, n3);\n  resid(u, v, r, n1, n2, n3, a, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/24"}
{"code": "for (int i = rank * chunk; i < ((rank + 1) * chunk); i++)\n  local_sum += f(((double) i) / 1000000);\n\n", "pragma": "omp for schedule(dynamic) reduction(+:local_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture15/hybrid_pi/0"}
{"code": "for (int tid = 0; tid < (GRID_SIZE * BLOCK_SIZE); tid++)\n{\n  const int threadN = GRID_SIZE * BLOCK_SIZE;\n  int i;\n  int path;\n  float L[NN];\n  float z[NN];\n  for (path = tid; path < NPATH; path += threadN)\n  {\n    for (i = 0; i < h_N; i++)\n    {\n      z[i] = 0.3f;\n      L[i] = 0.05f;\n    }\n\n    path_calc(L, z, h_lambda, h_delta, h_Nmat, h_N);\n    h_v[path] = portfolio(L, h_lambda, h_maturities, h_swaprates, h_delta, h_Nmat, h_N, h_Nopt);\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for num_teams(GRID_SIZE) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/14"}
{"code": "for (int i = 0; i < bm.length; i++)\n{\n  xm.val[i] = 0;\n  vm.val[i] = 0;\n  pm.val[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/14"}
{"code": "for (int i = 1; i < target_size_; i++)\n{\n  for (int elem = 0; elem < 3; elem++)\n  {\n    if (target_[i].data[elem] > maxVoxel.data[elem])\n      maxVoxel.data[elem] = target_[i].data[elem];\n\n    if (target_[i].data[elem] < minVoxel.data[elem])\n      minVoxel.data[elem] = target_[i].data[elem];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/11"}
{"code": "for (; (i < N) && (j < N); i = (i + incX) + 2, j = (j + incY) + 2)\n{\n  v = _mm_load_pd(X + i);\n  _mm_store_pd(Y + i, v);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/6"}
{"code": "for (int v = 0; v < nov; v++)\n{\n  if (distance[v] == level)\n  {\n    for (int j = row[v]; j < row[v + 1]; j++)\n    {\n      int u = col[j];\n      if (distance[u] < 0)\n      {\n        distance[u] = level + 1;\n        improvement = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for reduction(||:improvement) schedule(guided, 32)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/wbfs/0"}
{"code": "for (int l = 0; l < n; l++)\n{\n  if (odd[l] != 0)\n    printf(\"%d\\n\", odd[l]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Seperating_even_odds_openMP/6"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 1; j < (784 + 1); j++)\n  {\n    WL1[i][j] = (((float) rand()) / ((float) (32767 / 2))) - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex4/ex4/4"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  a[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prashant-vishwakarma/OpenMP-Reduction/src/minmax/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  A[i] = (REAL) (lower + ((((REAL) rand()) / ((REAL) 32767)) * (upper - lower)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/bm2d/bm2d/1"}
{"code": "for (int i = 0; i <= (height - 1); i += 1)\n  for (int j = 0; j <= (linea - 1); j += 3)\n{\n  {\n    tmpB = 0;\n    tmpG = 0;\n    tmpR = 0;\n    for (int s = -2; s <= 2; s++)\n    {\n      for (int t = -2; t <= 2; t++)\n      {\n        columnaByte = j + (t * 3);\n        filaGauss = s + 2;\n        columnaGauss = t + 2;\n        byte = ((i + s) * linea) + columnaByte;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= columnaByte)) && (columnaByte <= (linea - 1)))\n          tmpB += mGauss[filaGauss][columnaGauss] * pixels[byte];\n\n        byte += 1;\n        columnaByte += 1;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= columnaByte)) && (columnaByte <= (linea - 1)))\n          tmpG += mGauss[filaGauss][columnaGauss] * pixels[byte];\n\n        byte += 1;\n        columnaByte += 1;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= columnaByte)) && (columnaByte <= (linea - 1)))\n          tmpR += mGauss[filaGauss][columnaGauss] * pixels[byte];\n\n      }\n\n    }\n\n    tmpB /= w;\n    tmpG /= w;\n    tmpR /= w;\n    pixelsN[(i * linea) + j] = (unsigned char) tmpB;\n    pixelsN[((i * linea) + j) + 1] = (unsigned char) tmpG;\n    pixelsN[((i * linea) + j) + 2] = (unsigned char) tmpR;\n  }\n}\n\n\n", "pragma": "    #pragma omp parallel for private(tmpB, tmpR, tmpG)schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarZeta-hub/pr-ctica-OpenMP/image-par/image-par/3"}
{"code": "for (i = 0; i <= (162 + 1); i++)\n{\n  for (k = 0; k <= (162 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/22"}
{"code": "for (int i = 0; i < NumOptimizables; i++)\n  for (int j = 0; j < NumOptimizables; j++)\n  Ham2(i, j) += (((2 * m_vec(0, j)) * (m_vec(3, i) - (2.0 * m_vec(4, i)))) + ((2 * m_vec(0, i)) * (m_vec(3, j) - (2.0 * m_vec(4, j))))) + (((4 * m_vec(0, i)) * m_vec(0, j)) * E2_avg);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/VMC/VMCLinearOptOMP/4"}
{"code": "for (x = 0; x < n; x++)\n{\n  for (y = 0; y < nc; y++)\n  {\n    sum = C[x + (n * y)];\n    for (z = 0; z < nc; z++)\n    {\n      sum = sum + (Atemp[x + (n * z)] * B[(z + (j2 * nc)) + (n * y)]);\n    }\n\n    C[x + (n * y)] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private (x, y, z, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patlewis/matrix-matrix-multiplication/ring_matrix_part_b/0"}
{"code": "for (int i = 0; i < max_length; ++i)\n{\n  if (i < fi_len)\n    flux_i[i] = 0.0;\n\n  if (i < fj_len)\n    flux_j[i] = 0.0;\n\n  if (i < fk_len)\n    flux_k[i] = 0.0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/7"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/124"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  out_degree = vertices->out_degree[v];\n  if (stats->distances[v] == UINT32_MAX)\n  {\n    edge_idx = vertices->edges_idx[v];\n    for (j = edge_idx; j < (edge_idx + out_degree); j++)\n    {\n      u = EXTRACT_VALUE(sorted_edges_array[j]);\n      AccessDoubleTaggedCacheUInt32(stats->cache, (uint64_t) (&bitmapCurr->bitarray[word_offset(u)]), 'r', u, EXTRACT_MASK(sorted_edges_array[j]));\n      if (getBit(bitmapCurr, u))\n      {\n        stats->distances[v] = stats->distances[u] + 1;\n        if (stats->distances[v] == (stats->distances[u] + 1))\n        {\n          stats->sigma[v] += stats->sigma[u];\n          stats->predecessors[v].nodes[stats->predecessors[v].degree] = u;\n          stats->predecessors[v].degree++;\n        }\n\n        setBitAtomic(bitmapNext, v);\n        nf++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(j,u,v,out_degree,edge_idx) shared(stats,bitmapCurr,bitmapNext,graph,vertices,sorted_edges_array) reduction(+:nf) schedule(dynamic, 1024)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/algorithms/openmp/betweennessCentrality/0"}
{"code": "for (i = 0; i < 5000; i++)\n  for (j = 0; j < 5000; j++)\n{\n  if (i % 3)\n    image[i][j] = (i + j) % 10;\n  else\n    image[i][j] = (i + (i * j)) % 10;\n\n}\n\n\n", "pragma": "omp parallel for collapse(2) shared(image) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/2"}
{"code": "for (c1 = nj; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/5"}
{"code": "for (int i = 0; i < ((ROWSIZE / np) * COLSIZE); i++)\n{\n  recA[i] = 0;\n  recC[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/SREC_workshop/ex3_mpi_mm_gpu_omp/mm/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  for (j = k + 1; j < n; j++)\n    A[k][j] = A[k][j] / A[k][k];\n\n  for (i = k + 1; i < n; i++)\n    for (j = k + 1; j < n; j++)\n    A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ronak-B/Parallel-LU-factorization/final/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    fprintf(fp, \"%0.9f\", A[(i * size) + j]);\n    if (j != (size - 1))\n    {\n      fwrite(\" \", sizeof(char), 1, fp);\n    }\n\n  }\n\n  fwrite(\"\\n\", sizeof(char), 1, fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/8"}
{"code": "for (i = 0; i < 128; i++)\n{\n  Q[(i * 128) + k] = A[(i * 128) + k] / R[(k * 128) + k];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GRAMSCHM/gramschmidt/15"}
{"code": "for (int segment = 0; segment < 5; segment++)\n{\n  cloud_segments_array[segment] = in_cloud_ptr + current_segment_pos[segment];\n  for (int i = current_segment_pos[segment]; i < cloud_size; i++)\n  {\n    if (segment_index[i] == segment)\n    {\n      Point swap_tmp = in_cloud_ptr[current_segment_pos[segment]];\n      in_cloud_ptr[current_segment_pos[segment]] = in_cloud_ptr[i];\n      in_cloud_ptr[i] = swap_tmp;\n      segment_index[i] = segment_index[current_segment_pos[segment]];\n      segment_index[current_segment_pos[segment]] = segment;\n      current_segment_pos[segment]++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/7"}
{"code": "for (i = 0; i < FSMSIZE; i++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    trans[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fsm-omp/main/4"}
{"code": "for (int i = 0; i < n; ++i)\n  array[i] = 1.;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/Cuda-Polynomial/polynomial/2"}
{"code": "for (int i = 0; i < nb_nodes; ++i)\n  task.target[i] = -1;\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/2"}
{"code": "for (int neuron = 0; neuron < (layers[layers.size() - layer] - 1); neuron += 1)\n{\n  for (int synapse = 0; synapse < layers[(layers.size() - layer) - 1]; synapse += 1)\n  {\n    weights[(layers.size() - layer) - 1][neuron][synapse] -= (LEARNING_RATE * delta[(layers.size() - layer) - 1][neuron]) * a[(layers.size() - layer) - 1][synapse];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/neural-network/src/optimize/6"}
{"code": "for (j = 0; j < size; j++)\n{\n  temp = 0.0;\n  for (i = 0; i < size; i++)\n  {\n    temp += A[i + (size * j)] * b[i];\n  }\n\n  x[j] = temp;\n}\n\n", "pragma": "omp for reduction(+:temp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/matrix_vector/1"}
{"code": "for (i = 0; i <= nsub; i++)\n{\n  xn[i] = ((((double) (nsub - i)) * xl) + (((double) i) * xr)) / ((double) nsub);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/9"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  for (int j = 0; j < command_line_args.seq_len; j++)\n  {\n    m_arrays[i][j] = ((RAND_START + rand()) % RAND_STOP) / 100.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/2"}
{"code": "for (int i = 0; i < num_bins; ++i)\n{\n  bins[i].num_par = 0;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nlyu/Project_particle_simulation/openmp/6"}
{"code": "for (int i = 0; i < n_arrays; i++)\n{\n  arrays[i].array = 0;\n  arrays[i].size = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juan-burtet/ParallelBucketSort/bucketsort/4"}
{"code": "for (int i = 1; i < 4; i++)\n{\n  a[i] = a[i + 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/dataracetest1/0"}
{"code": "for (i = 0; i < nx; i++)\n{\n  currWorld[i][0] = 0;\n  currWorld[i][ny - 1] = 0;\n  nextWorld[i][0] = 0;\n  nextWorld[i][ny - 1] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/meaydira/GameofLifeParallel/life/1"}
{"code": "for (i = 0; i < 256; i++)\n{\n  histo[i] = 0;\n  for (j = 0; j < num_thread; j++)\n    histo_thread[i][j] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_creative/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  mult[i] = vect1[i] * vect2[i];\n  printf(\"[Proceso %d] (Multiplicacion) He calculado %f (indice=%d)\\n\", id, mult[i], i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/6"}
{"code": "for (i = 0; i < (N / P); i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    buffSize[j] = M / P;\n    dispA[j] = (((M / P) * (N / P)) * j) + ((M / P) * i);\n    dispB[j] = (M * i) + ((M / P) * j);\n  }\n\n  MPI_Alltoallv(a, buffSize, dispA, (MPI_Datatype) 0x4c000405, b, buffSize, dispB, (MPI_Datatype) 0x4c000405, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/10"}
{"code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n  strcat(ftname, \"_\");\n  strcat(ftname, DEIDname);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/94"}
{"code": "for (i = 1; i < (_PB_NI - 1); ++i)\n  for (j = 1; j < (_PB_NJ - 1); ++j)\n  for (k = 1; k < (_PB_NK - 1); ++k)\n{\n  B[i][j][k] = ((((((((((((((2 * A[i - 1][j - 1][k - 1]) + (4 * A[i + 1][j - 1][k - 1])) + (5 * A[i - 1][j - 1][k - 1])) + (7 * A[i + 1][j - 1][k - 1])) + ((-8) * A[i - 1][j - 1][k - 1])) + (10 * A[i + 1][j - 1][k - 1])) + ((-3) * A[i][j - 1][k])) + (6 * A[i][j][k])) + ((-9) * A[i][j + 1][k])) + (2 * A[i - 1][j - 1][k + 1])) + (4 * A[i + 1][j - 1][k + 1])) + (5 * A[i - 1][j][k + 1])) + (7 * A[i + 1][j][k + 1])) + ((-8) * A[i - 1][j + 1][k + 1])) + (10 * A[i + 1][j + 1][k + 1]);\n}\n\n\n\n", "pragma": "omp for private (j,k) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/stencils/convolution-3d/convolution-3d/0"}
{"code": "for (i = 0; i < iterations; i++)\n{\n  double aa = ba;\n  double ab = bb;\n  double ac = bc;\n  double ad = bd;\n  double ae = be;\n  alter(&aa, &ab, &ac, &ad, &ae);\n  double error = calc_error(aa, ab, ac, ad, ae);\n  if (error < best_err)\n  {\n    ba = aa;\n    bb = ab;\n    bc = ac;\n    bd = ad;\n    be = ae;\n    best_err = error;\n    printf(\"New best found: %.24lf\\n\", best_err);\n    k++;\n  }\n\n  if (!(i & 0x3fff))\n  {\n    update_loading_text(count, iterations);\n  }\n\n  count++;\n}\n\n", "pragma": "omp parallel for schedule(static) num_threads(n_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MilaudMiremadi/Preprocessor-sRGBtoLinear/src/preprocsrgb/0"}
{"code": "for (int i = start + 1; i < end; i++)\n  if (compare_g((void *) (&data[min_idx]), (void *) (&data[i])))\n  min_idx = i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/08_quicksort.v2/1"}
{"code": "for (v_can = 1; v_can < D_can_height; v_can++)\n{\n  v = v_can * D_candidate_stepsize;\n  for (u_can = 1; u_can < D_can_width; u_can++)\n  {\n    u = u_can * D_candidate_stepsize;\n    *(D_can + getAddressOffsetImage(u_can, v_can, D_can_width)) = -1;\n    d = computeMatchingDisparity(u, v, I1_desc, I2_desc, false);\n    if (d >= 0)\n    {\n      d2 = computeMatchingDisparity(u - d, v, I1_desc, I2_desc, true);\n      if ((d2 >= 0) && (abs(d - d2) <= lr_threshold))\n        *(D_can + getAddressOffsetImage(u_can, v_can, D_can_width)) = d;\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/8"}
{"code": "for (i = 1930; i <= 1943; i++)\n{\n  years_bag[j] = i;\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgxavier/openmp/temperature/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 1.f;\n  b[i] = 2.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/advanced-hpc-examples/OpenMP/vecadd-openmp/1"}
{"code": "for (int i = 0; i < y.size(); i++)\n{\n  y[i] = alpha * x[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/scale/0"}
{"code": "for (j = 0; j < nxhs; j += 2)\n{\n  v_at1 = _mm512_mask_loadunpacklo_ps(v_zero, _mm512_int2mask(15), (float *) (&ffc[j]));\n  v_at1 = _mm512_mask_loadunpackhi_ps(v_at1, _mm512_int2mask(15), (float *) (&ffc[j + 8]));\n  v_at1 = _mm512_permute4f128_ps(v_at1, 0);\n  v_at4 = (int) _mm512_mask_shuffle_epi32((int) v_at1, _mm512_int2mask(13260), (int) v_at1, 78);\n  v_at1 = (int) _mm512_mask_shuffle_epi32((int) v_at4, _mm512_int2mask(43690), (int) v_at4, 177);\n  v_at1 = _mm512_mul_ps(v_ci2, v_at1);\n  v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n  v_dkx = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dkx = _mm512_mul_ps(v_dnx, v_dkx);\n  v_dk1 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(3084), v_dkx);\n  v_dk2 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(12336), v_dkx);\n  v_at2 = _mm512_mul_ps(v_at1, v_dk1);\n  v_at3 = _mm512_mul_ps(v_at1, v_dk2);\n  v_at4 = (int) _mm512_mask_shuffle_epi32((int) v_at4, _mm512_int2mask(21845), (int) v_at4, 177);\n  v_at1 = _mm512_mul_ps(v_at1, v_at4);\n  v_zt3 = _mm512_load_ps((float *) (&cu[4 * j]));\n  v_zt3 = _mm512_mask_sub_ps(v_zt3, _mm512_int2mask(43690), v_zero, v_zt3);\n  v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n  v_zt1 = _mm512_mul_ps(v_at2, v_zt3);\n  v_zt2 = _mm512_mul_ps(v_at3, v_zt3);\n  v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n  v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n  v_zt1 = _mm512_sub_ps(v_zt1, v_zt2);\n  if (j == 0)\n  {\n    v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n    v_zt3 = _mm512_mask_mov_ps(v_zt3, _mm512_int2mask(255), v_zero);\n  }\n\n  _mm512_store_ps((float *) (&bxyz[4 * j]), v_zt1);\n  v_zt4 = _mm512_mul_ps(v_at1, _mm512_mask_mul_ps(v_zero, _mm512_int2mask(16191), v_zt3, v_zt3));\n  v_wp = _mm512_add_pd(v_wp, _mm512_cvtpslo_pd(v_zt4));\n  v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_zt4, 78));\n  v_wp = _mm512_add_pd(v_wp, v_d);\n  _mm512_store_ps((float *) (&bxyz[4 * (j + k1)]), v_zero);\n  _mm512_store_ps((float *) (&bxyz[4 * (j + l1)]), v_zero);\n  _mm512_store_ps((float *) (&bxyz[4 * ((j + k1) + l1)]), v_zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/49"}
{"code": "for (int r = 0; r < rows; r++)\n{\n  while ((left != right) && (right > left))\n  {\n    int temp = d[(r * cols) + left];\n    d[(r * cols) + left] = d[((r * cols) + cols) - right];\n    d[((r * cols) + cols) - right] = temp;\n    right--;\n    left++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vijay-72/Openmp-Image-Inversion/parallel_code/2"}
{"code": "for (j; j < nproc; j++)\n{\n  printf(\"receive from %d\\n\", j);\n  MPI_Recv(output->R + (j * chunksize1), chunksize1, (MPI_Datatype) 0x4c000405, j, 1, (MPI_Comm) 0x44000000, &status);\n  MPI_Recv(output->G + (j * chunksize1), chunksize1, (MPI_Datatype) 0x4c000405, j, 2, (MPI_Comm) 0x44000000, &status);\n  MPI_Recv(output->B + (j * chunksize1), chunksize1, (MPI_Datatype) 0x4c000405, j, 3, (MPI_Comm) 0x44000000, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eyadfhafi/HPC_OPENMP/conva-hybrid/1"}
{"code": "for (size_t i = 0; i < pV.size(); i++)\n{\n  pV[i].prev_iterate_pressure = pV[i].curr_iterate_pressure;\n  computeSumDIJ(pV, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/agam-kashyap/Fluid-Simulation-Rendering/Simulation/src/iisph-forces/0"}
{"code": "for (i = 0; i < 8; ++i)\n{\n  histo[i] = malloc(256 * (sizeof(long)));\n  memset(histo[i], 0, 256 * (sizeof(long)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_creative/1"}
{"code": "for (int j = 0; j < mode; ++j)\n{\n  for (int i = 0; i < length; ++i)\n  {\n    MixtureResult[j][i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/9"}
{"code": "for (dest = 1; dest <= numworkers; dest++)\n{\n  rows = (dest <= extra) ? (averow + 1) : (averow);\n  printf(\"Sending %d rows to task %d offset=%d\\n\", rows, dest, offset);\n  MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&rows, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&a[offset][0], rows * 10, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  MPI_Send(&b, 10 * 10, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  offset = offset + rows;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/matrix_multipy/1"}
{"code": "for (j = 0; j < y; j++)\n{\n  if (dom[i][j][k] == 0)\n  {\n    tmpdy = zdy[j];\n    tmp = min_dt(zdx[i], tmpdy);\n    svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / tmp;\n    xvel = fabs(vx[i][j][k]) / zdx[i];\n    yvel = fabs(vy[i][j][k]) / tmpdy;\n    max_tmp2 = max_dt(svel, xvel);\n    max_tmp3 = max_dt(max_tmp2, yvel);\n    rdt1 = max_dt(max_tmp3, rdt1);\n    if (viscosity_on_off == 1)\n    {\n      temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n      kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n      s_visc = kin_viscosity / (tmp * tmp);\n      rdt1 = max_dt(s_visc, rdt1);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc/0"}
{"code": "for (int i = chunkNum; i > 1; i >>= 1)\n{\n  multiThreadMergeGeneral(data.buffers[data.selector], data.buffers[data.selector ^ 1], dataLen, i, blockLen);\n  data.selector ^= 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/28"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    val = rand() % 100;\n    (*matrix)[i][j] = val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/4"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  p[i] = i * M_PI;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/BICG/bicg/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  const unsigned char color[] = {(unsigned char) (m[i] / SQRT_MAX_WEIGHT), 255, (unsigned char) (((int) m[i]) % SQRT_MAX_WEIGHT)};\n  img.draw_point(x[i], y[i], color);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brabemi/ctu-fit-mi-pap-mod/main/0"}
{"code": "for (i = (2U * 0x7fffffff) + 1; i >= ((2U * 0x7fffffff) + 1); i--)\n  c++;\n\n", "pragma": "omp parallel for reduction(+:c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr43893/5"}
{"code": "for (i = 0; i < 12; i++)\n{\n  for (j = 0; j < 12; j++)\n  {\n    for (k = 0; k < 12; k++)\n    {\n      tmp1 = 6.0 / m;\n      a[i][j][k] = tmp1 + 4;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,tmp1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB170-nestedloops-orig-no/0"}
{"code": "for (i_imopVar125 = 1; i_imopVar125 < (grid_points[0] - 1); i_imopVar125++)\n{\n  for (j_imopVar126 = 1; j_imopVar126 < (grid_points[1] - 1); j_imopVar126++)\n  {\n    double *_imopVarPre418;\n    double (*_imopVarPre419)[5];\n    double (*_imopVarPre420)[5];\n    _imopVarPre418 = rhs[i_imopVar125][j_imopVar126][0];\n    _imopVarPre419 = lhs[i_imopVar125][j_imopVar126][0][2];\n    _imopVarPre420 = lhs[i_imopVar125][j_imopVar126][0][1];\n    binvcrhs(_imopVarPre420, _imopVarPre419, _imopVarPre418);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/41"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  NDOF += NDIM * cell(ci).getNV();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/52"}
{"code": "for (int i = 0; i < treeNumber; i++)\n{\n  if (output[i] != reference[i])\n  {\n    fail = true;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/layout-omp/main/3"}
{"code": "for (i = 0; i < nu; i++)\n{\n  adiag[i] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/1"}
{"code": "for (idx_t j = 0; j < J; ++j)\n{\n  mylambda[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/9"}
{"code": "for (int iter = 0; iter <= dom->nbiter_; ++iter)\n  fprintf(fileid, \"%17.13e %17.13e\\n\", iter * dom->dt_, l2norm_(iter));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yasahi-hpc/P3-miniapps/miniapps/vlp4d_mpi/openacc/Diags/1"}
{"code": "for (i = 0; i < n_images; i++)\n{\n  width[i] = g->SavedImages[i].ImageDesc.Width;\n  height[i] = g->SavedImages[i].ImageDesc.Height;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/load_pixels/0"}
{"code": "for (int i = 0; i < n; ++i)\n  printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/argha072k/openmp/path/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  if (i < 4)\n  {\n    center.x = left.x;\n    if (i < 2)\n      center.y = left.y;\n    else\n      center.y = right.y;\n\n  }\n  else\n  {\n    center.x = right.x;\n    if (i < 6)\n      center.y = left.y;\n    else\n      center.y = right.y;\n\n  }\n\n  if ((i % 2) == 0)\n    center.z = left.z;\n  else\n    center.z = right.z;\n\n  NewNode(&(*A)->leaves[i], center, halfL, interpolation_order);\n  (*A)->leaves[i]->parent = *A;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/28"}
{"code": "for (i = 1; i < tam; i++)\n{\n  if (vetor[i] > maximum)\n    maximum = vetor[i];\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/FindMaximum/FindMaximum/1"}
{"code": "for (i = 0; i < npts; i++)\n{\n  float dist;\n  dist = euclid_dist_2(pt, pts + (i * nfeatures), nfeatures);\n  if (dist < min_dist)\n  {\n    min_dist = dist;\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/kmeans/kmeans_clustering.ref/1"}
{"code": "for (unsigned long long it = 2000; it >= 600; it -= 400)\n{\n  this->a = ((double) b) + 1.5;\n  c[1][1] = ++a;\n}\n\n", "pragma": "    #pragma omp target parallel for if(target: n>60)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/7"}
{"code": "for (i = 0; i < info->N; i++)\n{\n  for (j = 0; j < info->K; j++)\n  {\n    fscanf(myFile, \"%f\", ((*pos) + (i * info->K)) + j);\n  }\n\n  for (j = 0; j < info->K; j++)\n  {\n    fscanf(myFile, \"%f\", ((*vel) + (i * info->K)) + j);\n  }\n\n  fscanf(myFile, \"%d\", (*group) + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/2"}
{"code": "for (j = 0; j <= (dims[2][1] - 1); j += 1)\n{\n  jj = (((((j + 1) + ystart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n  ij2 = (jj * jj) + ii2;\n  for (k = 0; k <= (dims[2][2] - 1); k += 1)\n  {\n    kk = (((((k + 1) + zstart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n    indexmap[k][j][i] = (kk * kk) + ij2;\n  }\n\n}\n\n", "pragma": "omp parallel for private (jj,ij2,kk,j,k) firstprivate (ii2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/3"}
{"code": "for (i = i_start; i < n; i++)\n{\n  float *tmp_uold = &uold[(((i + uold_0_offset) * uold_m) + uold_1_offset) + j_start];\n  float *tmp_f = &f[(i * m) + j_start];\n  float *tmp_u = &u[(i * m) + j_start];\n  for (j = j_start; j < m; j++)\n  {\n    float resid = ((((ax * (tmp_uold[uold_m] + tmp_uold[-uold_m])) + (ay * (tmp_uold[-1] * tmp_uold[1]))) + (b * tmp_uold[0])) - (*tmp_f)) / b;\n    *tmp_u = (*tmp_uold = omega * resid);\n    er = er + (resid * resid);\n    tmp_uold++;\n    tmp_f++;\n    tmp_u++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) reduction(+:er) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_cpu_omp_kernel/1"}
{"code": "for (j = 0; j < nxhs; j += 2)\n{\n  v_zt2 = _mm512_load_ps((float *) (&cu[4 * j]));\n  if (j == 0)\n  {\n    v_zt2 = _mm512_mask_mov_ps(v_zt2, _mm512_int2mask(255), v_zero);\n  }\n\n  v_zt2 = _mm512_mask_mov_ps(v_zt2, _mm512_int2mask(771), v_zero);\n  _mm512_store_ps((float *) (&cu[4 * j]), v_zt2);\n  _mm512_store_ps((float *) (&cu[4 * (j + k1)]), v_zero);\n  _mm512_store_ps((float *) (&cu[4 * (j + l1)]), v_zero);\n  _mm512_store_ps((float *) (&cu[4 * ((j + k1) + l1)]), v_zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/46"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  matrix_pointer[i] = (double *) malloc((sizeof(double)) * M);\n  for (int _iqw_ = 0; _iqw_ < M; ++_iqw_)\n  {\n    matrix_pointer[i][_iqw_] = 0.0;\n  }\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vmykh/parallel_computing_PDE/explicit/3"}
{"code": "for (int i = 1; i < N; ++i)\n{\n  for (int j = 0; j < i; ++j)\n  {\n    double r2 = 0.0;\n    double rij[3];\n    for (int k = 0; k < 3; ++k)\n    {\n      rij[k] = rn[i][k] - rn[j][k];\n      if (rij[k] > L2[k])\n      {\n        rij[k] -= L[k];\n      }\n      else\n        if (rij[k] < (-L2[k]))\n      {\n        rij[k] += L[k];\n      }\n\n\n      r2 += rij[k] * rij[k];\n    }\n\n    double f_r = 0;\n    utot += Potential(r2);\n    f_r = ForceDevByRange(r2);\n    assert((r2 != INFINITY) && (r2 != 0));\n    for (int k = 0; k < 3; ++k)\n    {\n      assert(f_r == f_r);\n      f[i][k] += ((float) f_r) * ((float) rij[k]);\n      f[j][k] -= ((float) f_r) * ((float) rij[k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akarazeev/MolecularDynamics-3sem-MIPT-2015/OmpMolecDynam/OmpMolecDynam/main/4"}
{"code": "for (long i = 0; i < 500; i++)\n{\n  for (long k = 0; k < 500; k++)\n  {\n    C[i][k] = 0;\n    for (long j = 0; j < 500; j++)\n    {\n      C[i][k] += A[i][j] * B[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q4/q4/0"}
{"code": "for (int i = 0; i < N; i++)\n  if ((c[i] = malloc(M * (sizeof(double)))) == 0)\n{\n  perror(\"init_memory: memory allocation failure for c\");\n  exit(1);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/10"}
{"code": "for (q = 0; q < 1024; q++)\n{\n  forces[q][0] = (forces[q][1] = (forces[q][2] = 0));\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    forces[q][0] += loc_forces[thread][q][0];\n    forces[q][1] += loc_forces[thread][q][1];\n    forces[q][2] += loc_forces[thread][q][2];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwwwwwOwO/Parallel-program/nbody/OpenMP_solver/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  graph[i] = (int *) malloc(n * (sizeof(int)));\n  for (int j = 0; j < n; j++)\n  {\n    graph[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/5"}
{"code": "for (c1 = (ni > nk) ? (ni) : (nk); c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/25"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < N; j++)\n    printf(\"%d \", matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/command/2"}
{"code": "for (int nbcpu = 1; nbcpu <= maxthreads; nbcpu++)\n{\n  omp_set_num_threads(nbcpu);\n  ((cout << \"number of threads : \") << nbcpu) << endl;\n  int res_static;\n  double t0 = omp_get_wtime();\n  res_static = cmbpremier_s(parameter);\n  double t1 = omp_get_wtime();\n  double time_static = t1 - t0;\n  int res_dynamic;\n  double t2 = omp_get_wtime();\n  res_dynamic = cmbpremier_d(parameter);\n  double t3 = omp_get_wtime();\n  double time_dynamic = t3 - t2;\n  ((cout << \"time spent static :\") << time_static) << endl;\n  ((cout << \"result schedule static :\") << res_static) << endl;\n  ((cout << \"time spent dynamic :\") << time_dynamic) << endl;\n  ((cout << \"result schedule dynamic :\") << res_dynamic) << endl;\n  fprintf(fo1, \"%d %f %f\\n\", nbcpu, time_static, time_dynamic);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/premier/premier_v2/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = C[i] * x[i];\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for simd \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMPTarget/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  if (IS_NAN(ent->v.velocity[i]))\n  {\n    Con_Printf(\"Got a NaN velocity on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.velocity[i] = 0;\n  }\n\n  if (IS_NAN(ent->v.origin[i]))\n  {\n    Con_Printf(\"Got a NaN origin on %s\\n\", PR_GetString(ent->v.classname));\n    ent->v.origin[i] = 0;\n  }\n\n  if (ent->v.velocity[i] > sv_maxvelocity.value)\n    ent->v.velocity[i] = sv_maxvelocity.value;\n  else\n    if (ent->v.velocity[i] < (-sv_maxvelocity.value))\n    ent->v.velocity[i] = -sv_maxvelocity.value;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jrk/QuakeTM/server/sv_phys/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    arrayX[x] += 1 + (5 * randn(seed, x));\n    arrayY[x] += (-2) + (2 * randn(seed, x));\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/2"}
{"code": "for (i = 0; i < size; i++)\n  U.elements[i] = A.elements[i];\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) default(none) private(i) shared(U, size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/0"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  x[i] = i * del_x;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Burgers Equation/1D_Burgers_Equation/main/0"}
{"code": "for (i = 0; (i < start) && (errors < 25); i++)\n{\n  if (b[i] != (-1))\n    printf(\"%4i: before, got %d, expected %d, %d error\\n\", i, b[i], -1, ++errors);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-large-array/test/4"}
{"code": "for (i = 0; i < nodes; i++)\n{\n  for (j = 0; j < numthreads; j++)\n  {\n    if (w2[j][i])\n    {\n      w[i][0] += w1[j][i].first;\n      w[i][1] += w1[j][i].second;\n      w[i][2] += w1[j][i].third;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j) collapse(2) firstprivate(nodes,numthreads) shared(w,w1,w2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/6"}
{"code": "for (i = 0; i < histogram_size; i++)\n  histogram[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/histogram/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  distances[i] = dist[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/3"}
{"code": "for (i = 0; i < 8192; i++)\n  for (j = 0; j < 8192; j++)\n  x2[i] += a[(j * 8192) + i] * y2[j];\n\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/5"}
{"code": "for (c2 = 0; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/70"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    idx = j + (i * n);\n    if ((((i == 0) || (i == (n - 1))) || (j == 0)) || (j == (n - 1)))\n    {\n      un[idx] = 0.;\n    }\n    else\n    {\n      un[idx] = ((2 * uc[idx]) - uo[idx]) + ((VSQR * (dt * dt)) * (((((((uc[idx - 1] + uc[idx + 1]) + uc[idx + n]) + uc[idx - n]) + (0.25 * (((uc[(idx - n) - 1] + uc[(idx + n) - 1]) + uc[(idx - n) + 1]) + uc[(idx + n) + 1]))) - (5 * uc[idx])) / (h * h)) + f(pebbles[idx], t)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(nthreads) private(idx, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deepakguptancsu/Lake-simulation-parallel-processing/omp_acc/lake/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  getRow(dataset, i, supDataset, m);\n  sum += eucliDist(supCentroid, supDataset, m) * clusters[i][ki];\n}\n\n", "pragma": "omp parallel for private(supDataset) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/0"}
{"code": "for (uint i = 0; i < keys.size(); ++i)\n{\n  uint key = (keys[i] >> startBit) & mask;\n  ++histogramRadixFrequency[key];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q2/6"}
{"code": "for (int i = 0; i < length; i++)\n{\n  unsigned long x = data[i];\n  char cnt = 0;\n  for (char i = 0; i < 64; i++)\n  {\n    cnt = cnt + (x & 0x1);\n    x = x >> 1;\n  }\n\n  result[i] = cnt;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/6"}
{"code": "for (i = 0; i < k; i++)\n{\n  tempX = (counts[i]) ? (tempC[i].x / counts[i]) : (0);\n  tempY = (counts[i]) ? (tempC[i].y / counts[i]) : (0);\n  if ((centroids[i].x != tempX) || (centroids[i].y != tempY))\n  {\n    check += 1;\n    centroids[i].x = tempX;\n    centroids[i].y = tempY;\n  }\n\n}\n\n", "pragma": "omp parallel for private(tempX, tempY) reduction(+:check) num_threads(p)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yq314/k-means/k-means-openmp/kmeans/2"}
{"code": "for (j = 0; j < kxps; j++)\n{\n  dkx = dnx * ((float) (j + joff));\n  jj = nyhd * j;\n  at1 = dkx * dkx;\n  at2 = pow(dkx * ax, 2);\n  for (k = 0; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    at3 = (dky * dky) + at1;\n    at4 = exp((-.5) * (pow(dky * ay, 2) + at2));\n    if (at3 == 0.0)\n    {\n      ffc[k + jj] = affp + (1.0 * _Complex_I);\n    }\n    else\n    {\n      ffc[k + jj] = ((affp * at4) / at3) + (at4 * _Complex_I);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/35"}
{"code": "for (long int i = 0; i < N; i++)\n{\n  out[i] = in[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PascalRomb/fftparallelanalysis/FFTPARALLEL/resources/FFTOpenMP/3"}
{"code": "for (i = 0; i < 8; i++)\n{\n  t = get_first_task(&lists_heads[i]);\n  while (t != 0)\n  {\n    {\n      move((int **) t->board, t->x, t->y, t->move_num);\n    }\n    t = get_first_task(&lists_heads[i]);\n  }\n\n}\n\n", "pragma": "omp for private(t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/0"}
{"code": "for (int i = 0; i < table->n; i++)\n{\n  real_t r = table->x0 + (i * dR);\n  fprintf(potData, \"%d %e %e\\n\", i, r, table->values[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  p[i] = i * 3.14159;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/23"}
{"code": "for (int p = 0; p < numPoints; p++)\n{\n  (((myfile << dataset[p].id) << \",\") << clusters[globalMembership[p]].id) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/20"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    if (explored != numsOfParts[indexGroup])\n    {\n      (cout << \"*\") << \" \";\n      explored--;\n    }\n    else\n      if (ind != numsOfParts[indexGroup])\n    {\n      (cout << island[j + (i * width)]) << \" \";\n      ind++;\n    }\n    else\n    {\n      (cout << \"*\") << \" \";\n    }\n\n\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/2"}
{"code": "for (int index = 0; index < readsCount; index++)\n{\n  if (cluster[index] < 0)\n  {\n    int offsetOne = representative * 4;\n    int offsetTwo = index * 4;\n    int magic = ((min(magicBase[offsetOne + 0], magicBase[offsetTwo + 0]) + min(magicBase[offsetOne + 1], magicBase[offsetTwo + 1])) + min(magicBase[offsetOne + 2], magicBase[offsetTwo + 2])) + min(magicBase[offsetOne + 3], magicBase[offsetTwo + 3]);\n    int length = lengths[index];\n    int minLength = ceilf(((float) length) * threshold);\n    if (magic > minLength)\n    {\n      cluster[index] = -2;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_threads(128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/deredundancy-omp/kernels/10"}
{"code": "for (j = 0; j < n; j += 32)\n  for (i = 0; i < n; i += 32)\n  for (k = 0; k < n; k += 32)\n  dgemm_blocking(n, i, j, k, A, B, C);\n\n\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkhorrow/parallel-computing-material/exercise_6/dgemm_multithread_parallel_ss/0"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  for (int j = 0; j < cur->degree; j++)\n  {\n    node *neighbor = *((node **) elem_at(&cur->neighbors, j));\n    enqueue(invite_ql, neighbor->label, &data->invite);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/3"}
{"code": "for (kk = 0; kk < bots_arg_size; kk++)\n{\n  lu0(BENCH[(kk * bots_arg_size) + kk]);\n  for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    fwd(BENCH[(kk * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj]);\n  }\n\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n  {\n    bdiv(BENCH[(kk * bots_arg_size) + kk], BENCH[(ii * bots_arg_size) + kk]);\n  }\n\n\n  for (ii = kk + 1; ii < bots_arg_size; ii++)\n    if (BENCH[(ii * bots_arg_size) + kk] != 0)\n    for (jj = kk + 1; jj < bots_arg_size; jj++)\n    if (BENCH[(kk * bots_arg_size) + jj] != 0)\n  {\n    if (BENCH[(ii * bots_arg_size) + jj] == 0)\n      BENCH[(ii * bots_arg_size) + jj] = allocate_clean_block();\n\n    bmod(BENCH[(ii * bots_arg_size) + kk], BENCH[(kk * bots_arg_size) + jj], BENCH[(ii * bots_arg_size) + jj]);\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/sparselu/sparselu_for/sparselu/11"}
{"code": "for (int i = omp_get_thread_num() + 1; i < N; i += 8)\n{\n  for (int j = 1; j < i; j++)\n  {\n    tmpsum3 += (j + sin(x + j)) / (((2 * i) * j) - 1);\n  }\n\n  if (tmpsum3 != 0)\n  {\n    sum += 1 / tmpsum3;\n  }\n\n  tmpsum3 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/5"}
{"code": "for (int i = 0; i < l; i++)\n{\n  int soma = 0;\n  for (int j = 0; j < l; j++)\n  {\n    for (int k = 0; k < l; k++)\n    {\n      soma = soma + (matriz1[i][k] * matriz2[k][j]);\n    }\n\n    matrizF[i][j] = soma;\n    soma = 0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidInojosa/Project2-Thread/openmp/0"}
{"code": "for (size_t i = 0; i < K; ++i)\n{\n  if (clusters_sizes[i] != 0)\n  {\n    for (size_t d = 0; d < dimensions; ++d)\n    {\n      centroids[i][d] /= clusters_sizes[i];\n    }\n\n  }\n  else\n  {\n    centroids[i] = GetRandomPosition(centroids);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/6"}
{"code": "for (i = 0; i < numOfParts; i++)\n{\n  sum += fun((a + (i * dx)) + (dx / 2), k);\n}\n\n", "pragma": "#pragma omp parallel for private(i) schedule(static) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gitsebste/openmpImproperintegral/improperIntegral/improperIntegral/improperIntegral/0"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  while ((ch = fgetc(fpin)) != EOF)\n  {\n    fputc(ch, fpout);\n    if (ch == '\\n')\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main1/1"}
{"code": "for (int row = i + 1; row < size; row++)\n{\n  double factor = input_matrix[row][i];\n  for (int col = 0; col < size; col++)\n  {\n    input_matrix[row][col] -= factor * input_matrix[i][col];\n    I[row][col] -= factor * I[i][col];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Presto412/Parallel-Matrix-Inversion-with-OpenMP/pdc-da2-inverse-gje/2"}
{"code": "for (int ii = 0; ii < nSteps; ++ii)\n{\n  startTimer(velocityTimer);\n  advanceVelocity(s, s->boxes->nLocalBoxes, 0.5 * dt);\n  stopTimer(velocityTimer);\n  startTimer(positionTimer);\n  advancePosition(s, s->boxes->nLocalBoxes, dt);\n  stopTimer(positionTimer);\n  startTimer(redistributeTimer);\n  redistributeAtoms(s);\n  stopTimer(redistributeTimer);\n  startTimer(computeForceTimer);\n  computeForce(s);\n  stopTimer(computeForceTimer);\n  startTimer(velocityTimer);\n  advanceVelocity(s, s->boxes->nLocalBoxes, 0.5 * dt);\n  stopTimer(velocityTimer);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/timestep/4"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 1; j < SIZE; j++)\n  {\n    ex[(i * (SIZE + 1)) + j] = ex[(i * (SIZE + 1)) + j] - (0.5 * (hz[(i * SIZE) + j] - hz[(i * SIZE) + (j - 1)]));\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/FDTD2D/fdtd2d/2"}
{"code": "for (int j = 0; j < n; ++j)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    u_tmp[i + (j * n)] = ((((r2 * u[i + (j * n)]) + (r * ((i < (n - 1)) ? (u[(i + 1) + (j * n)]) : (0.0)))) + (r * ((i > 0) ? (u[(i - 1) + (j * n)]) : (0.0)))) + (r * ((j < (n - 1)) ? (u[i + ((j + 1) * n)]) : (0.0)))) + (r * ((j > 0) ? (u[i + ((j - 1) * n)]) : (0.0)));\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for simd collapse(2) thread_limit(block_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/heat-omp/heat/2"}
{"code": "for (int i = 0; i < adj[u].size(); i++)\n{\n  dfs1(adj[u][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  GaussEliNd1(MT, r, i);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/GaussEli/0"}
{"code": "for (long i = 0; i < 11; i++)\n{\n  for (int u = 0; u < 100000000; u++)\n  {\n    result++;\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_loop/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  q[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/EP/ep/3"}
{"code": "for (i = 0; i < 32768; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/10"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  double fjac[PROBLEM_SIZE + 1][5][5];\n  double njac[PROBLEM_SIZE + 1][5][5];\n  double lhs[PROBLEM_SIZE + 1][3][5][5];\n  double tmp1;\n  double tmp2;\n  double tmp3;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 0; i <= isize; i++)\n    {\n      tmp1 = rho_i[k][j][i];\n      tmp2 = tmp1 * tmp1;\n      tmp3 = tmp1 * tmp2;\n      fjac[i][0][0] = 0.0;\n      fjac[i][1][0] = 1.0;\n      fjac[i][2][0] = 0.0;\n      fjac[i][3][0] = 0.0;\n      fjac[i][4][0] = 0.0;\n      fjac[i][0][1] = (-((u[k][j][i][1] * tmp2) * u[k][j][i][1])) + (c2 * qs[k][j][i]);\n      fjac[i][1][1] = (2.0 - c2) * (u[k][j][i][1] / u[k][j][i][0]);\n      fjac[i][2][1] = (-c2) * (u[k][j][i][2] * tmp1);\n      fjac[i][3][1] = (-c2) * (u[k][j][i][3] * tmp1);\n      fjac[i][4][1] = c2;\n      fjac[i][0][2] = (-(u[k][j][i][1] * u[k][j][i][2])) * tmp2;\n      fjac[i][1][2] = u[k][j][i][2] * tmp1;\n      fjac[i][2][2] = u[k][j][i][1] * tmp1;\n      fjac[i][3][2] = 0.0;\n      fjac[i][4][2] = 0.0;\n      fjac[i][0][3] = (-(u[k][j][i][1] * u[k][j][i][3])) * tmp2;\n      fjac[i][1][3] = u[k][j][i][3] * tmp1;\n      fjac[i][2][3] = 0.0;\n      fjac[i][3][3] = u[k][j][i][1] * tmp1;\n      fjac[i][4][3] = 0.0;\n      fjac[i][0][4] = (((c2 * 2.0) * square[k][j][i]) - (c1 * u[k][j][i][4])) * (u[k][j][i][1] * tmp2);\n      fjac[i][1][4] = ((c1 * u[k][j][i][4]) * tmp1) - (c2 * (((u[k][j][i][1] * u[k][j][i][1]) * tmp2) + qs[k][j][i]));\n      fjac[i][2][4] = ((-c2) * (u[k][j][i][2] * u[k][j][i][1])) * tmp2;\n      fjac[i][3][4] = ((-c2) * (u[k][j][i][3] * u[k][j][i][1])) * tmp2;\n      fjac[i][4][4] = c1 * (u[k][j][i][1] * tmp1);\n      njac[i][0][0] = 0.0;\n      njac[i][1][0] = 0.0;\n      njac[i][2][0] = 0.0;\n      njac[i][3][0] = 0.0;\n      njac[i][4][0] = 0.0;\n      njac[i][0][1] = (((-con43) * c3c4) * tmp2) * u[k][j][i][1];\n      njac[i][1][1] = (con43 * c3c4) * tmp1;\n      njac[i][2][1] = 0.0;\n      njac[i][3][1] = 0.0;\n      njac[i][4][1] = 0.0;\n      njac[i][0][2] = ((-c3c4) * tmp2) * u[k][j][i][2];\n      njac[i][1][2] = 0.0;\n      njac[i][2][2] = c3c4 * tmp1;\n      njac[i][3][2] = 0.0;\n      njac[i][4][2] = 0.0;\n      njac[i][0][3] = ((-c3c4) * tmp2) * u[k][j][i][3];\n      njac[i][1][3] = 0.0;\n      njac[i][2][3] = 0.0;\n      njac[i][3][3] = c3c4 * tmp1;\n      njac[i][4][3] = 0.0;\n      njac[i][0][4] = (((((-((con43 * c3c4) - c1345)) * tmp3) * (u[k][j][i][1] * u[k][j][i][1])) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][2] * u[k][j][i][2]))) - (((c3c4 - c1345) * tmp3) * (u[k][j][i][3] * u[k][j][i][3]))) - ((c1345 * tmp2) * u[k][j][i][4]);\n      njac[i][1][4] = (((con43 * c3c4) - c1345) * tmp2) * u[k][j][i][1];\n      njac[i][2][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][2];\n      njac[i][3][4] = ((c3c4 - c1345) * tmp2) * u[k][j][i][3];\n      njac[i][4][4] = c1345 * tmp1;\n    }\n\n    lhsinit(lhs, isize);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      tmp1 = dt * tx1;\n      tmp2 = dt * tx2;\n      lhs[i][AA][0][0] = (((-tmp2) * fjac[i - 1][0][0]) - (tmp1 * njac[i - 1][0][0])) - (tmp1 * dx1);\n      lhs[i][AA][1][0] = ((-tmp2) * fjac[i - 1][1][0]) - (tmp1 * njac[i - 1][1][0]);\n      lhs[i][AA][2][0] = ((-tmp2) * fjac[i - 1][2][0]) - (tmp1 * njac[i - 1][2][0]);\n      lhs[i][AA][3][0] = ((-tmp2) * fjac[i - 1][3][0]) - (tmp1 * njac[i - 1][3][0]);\n      lhs[i][AA][4][0] = ((-tmp2) * fjac[i - 1][4][0]) - (tmp1 * njac[i - 1][4][0]);\n      lhs[i][AA][0][1] = ((-tmp2) * fjac[i - 1][0][1]) - (tmp1 * njac[i - 1][0][1]);\n      lhs[i][AA][1][1] = (((-tmp2) * fjac[i - 1][1][1]) - (tmp1 * njac[i - 1][1][1])) - (tmp1 * dx2);\n      lhs[i][AA][2][1] = ((-tmp2) * fjac[i - 1][2][1]) - (tmp1 * njac[i - 1][2][1]);\n      lhs[i][AA][3][1] = ((-tmp2) * fjac[i - 1][3][1]) - (tmp1 * njac[i - 1][3][1]);\n      lhs[i][AA][4][1] = ((-tmp2) * fjac[i - 1][4][1]) - (tmp1 * njac[i - 1][4][1]);\n      lhs[i][AA][0][2] = ((-tmp2) * fjac[i - 1][0][2]) - (tmp1 * njac[i - 1][0][2]);\n      lhs[i][AA][1][2] = ((-tmp2) * fjac[i - 1][1][2]) - (tmp1 * njac[i - 1][1][2]);\n      lhs[i][AA][2][2] = (((-tmp2) * fjac[i - 1][2][2]) - (tmp1 * njac[i - 1][2][2])) - (tmp1 * dx3);\n      lhs[i][AA][3][2] = ((-tmp2) * fjac[i - 1][3][2]) - (tmp1 * njac[i - 1][3][2]);\n      lhs[i][AA][4][2] = ((-tmp2) * fjac[i - 1][4][2]) - (tmp1 * njac[i - 1][4][2]);\n      lhs[i][AA][0][3] = ((-tmp2) * fjac[i - 1][0][3]) - (tmp1 * njac[i - 1][0][3]);\n      lhs[i][AA][1][3] = ((-tmp2) * fjac[i - 1][1][3]) - (tmp1 * njac[i - 1][1][3]);\n      lhs[i][AA][2][3] = ((-tmp2) * fjac[i - 1][2][3]) - (tmp1 * njac[i - 1][2][3]);\n      lhs[i][AA][3][3] = (((-tmp2) * fjac[i - 1][3][3]) - (tmp1 * njac[i - 1][3][3])) - (tmp1 * dx4);\n      lhs[i][AA][4][3] = ((-tmp2) * fjac[i - 1][4][3]) - (tmp1 * njac[i - 1][4][3]);\n      lhs[i][AA][0][4] = ((-tmp2) * fjac[i - 1][0][4]) - (tmp1 * njac[i - 1][0][4]);\n      lhs[i][AA][1][4] = ((-tmp2) * fjac[i - 1][1][4]) - (tmp1 * njac[i - 1][1][4]);\n      lhs[i][AA][2][4] = ((-tmp2) * fjac[i - 1][2][4]) - (tmp1 * njac[i - 1][2][4]);\n      lhs[i][AA][3][4] = ((-tmp2) * fjac[i - 1][3][4]) - (tmp1 * njac[i - 1][3][4]);\n      lhs[i][AA][4][4] = (((-tmp2) * fjac[i - 1][4][4]) - (tmp1 * njac[i - 1][4][4])) - (tmp1 * dx5);\n      lhs[i][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][0][0])) + ((tmp1 * 2.0) * dx1);\n      lhs[i][BB][1][0] = (tmp1 * 2.0) * njac[i][1][0];\n      lhs[i][BB][2][0] = (tmp1 * 2.0) * njac[i][2][0];\n      lhs[i][BB][3][0] = (tmp1 * 2.0) * njac[i][3][0];\n      lhs[i][BB][4][0] = (tmp1 * 2.0) * njac[i][4][0];\n      lhs[i][BB][0][1] = (tmp1 * 2.0) * njac[i][0][1];\n      lhs[i][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][1][1])) + ((tmp1 * 2.0) * dx2);\n      lhs[i][BB][2][1] = (tmp1 * 2.0) * njac[i][2][1];\n      lhs[i][BB][3][1] = (tmp1 * 2.0) * njac[i][3][1];\n      lhs[i][BB][4][1] = (tmp1 * 2.0) * njac[i][4][1];\n      lhs[i][BB][0][2] = (tmp1 * 2.0) * njac[i][0][2];\n      lhs[i][BB][1][2] = (tmp1 * 2.0) * njac[i][1][2];\n      lhs[i][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][2][2])) + ((tmp1 * 2.0) * dx3);\n      lhs[i][BB][3][2] = (tmp1 * 2.0) * njac[i][3][2];\n      lhs[i][BB][4][2] = (tmp1 * 2.0) * njac[i][4][2];\n      lhs[i][BB][0][3] = (tmp1 * 2.0) * njac[i][0][3];\n      lhs[i][BB][1][3] = (tmp1 * 2.0) * njac[i][1][3];\n      lhs[i][BB][2][3] = (tmp1 * 2.0) * njac[i][2][3];\n      lhs[i][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][3][3])) + ((tmp1 * 2.0) * dx4);\n      lhs[i][BB][4][3] = (tmp1 * 2.0) * njac[i][4][3];\n      lhs[i][BB][0][4] = (tmp1 * 2.0) * njac[i][0][4];\n      lhs[i][BB][1][4] = (tmp1 * 2.0) * njac[i][1][4];\n      lhs[i][BB][2][4] = (tmp1 * 2.0) * njac[i][2][4];\n      lhs[i][BB][3][4] = (tmp1 * 2.0) * njac[i][3][4];\n      lhs[i][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][4][4])) + ((tmp1 * 2.0) * dx5);\n      lhs[i][CC][0][0] = ((tmp2 * fjac[i + 1][0][0]) - (tmp1 * njac[i + 1][0][0])) - (tmp1 * dx1);\n      lhs[i][CC][1][0] = (tmp2 * fjac[i + 1][1][0]) - (tmp1 * njac[i + 1][1][0]);\n      lhs[i][CC][2][0] = (tmp2 * fjac[i + 1][2][0]) - (tmp1 * njac[i + 1][2][0]);\n      lhs[i][CC][3][0] = (tmp2 * fjac[i + 1][3][0]) - (tmp1 * njac[i + 1][3][0]);\n      lhs[i][CC][4][0] = (tmp2 * fjac[i + 1][4][0]) - (tmp1 * njac[i + 1][4][0]);\n      lhs[i][CC][0][1] = (tmp2 * fjac[i + 1][0][1]) - (tmp1 * njac[i + 1][0][1]);\n      lhs[i][CC][1][1] = ((tmp2 * fjac[i + 1][1][1]) - (tmp1 * njac[i + 1][1][1])) - (tmp1 * dx2);\n      lhs[i][CC][2][1] = (tmp2 * fjac[i + 1][2][1]) - (tmp1 * njac[i + 1][2][1]);\n      lhs[i][CC][3][1] = (tmp2 * fjac[i + 1][3][1]) - (tmp1 * njac[i + 1][3][1]);\n      lhs[i][CC][4][1] = (tmp2 * fjac[i + 1][4][1]) - (tmp1 * njac[i + 1][4][1]);\n      lhs[i][CC][0][2] = (tmp2 * fjac[i + 1][0][2]) - (tmp1 * njac[i + 1][0][2]);\n      lhs[i][CC][1][2] = (tmp2 * fjac[i + 1][1][2]) - (tmp1 * njac[i + 1][1][2]);\n      lhs[i][CC][2][2] = ((tmp2 * fjac[i + 1][2][2]) - (tmp1 * njac[i + 1][2][2])) - (tmp1 * dx3);\n      lhs[i][CC][3][2] = (tmp2 * fjac[i + 1][3][2]) - (tmp1 * njac[i + 1][3][2]);\n      lhs[i][CC][4][2] = (tmp2 * fjac[i + 1][4][2]) - (tmp1 * njac[i + 1][4][2]);\n      lhs[i][CC][0][3] = (tmp2 * fjac[i + 1][0][3]) - (tmp1 * njac[i + 1][0][3]);\n      lhs[i][CC][1][3] = (tmp2 * fjac[i + 1][1][3]) - (tmp1 * njac[i + 1][1][3]);\n      lhs[i][CC][2][3] = (tmp2 * fjac[i + 1][2][3]) - (tmp1 * njac[i + 1][2][3]);\n      lhs[i][CC][3][3] = ((tmp2 * fjac[i + 1][3][3]) - (tmp1 * njac[i + 1][3][3])) - (tmp1 * dx4);\n      lhs[i][CC][4][3] = (tmp2 * fjac[i + 1][4][3]) - (tmp1 * njac[i + 1][4][3]);\n      lhs[i][CC][0][4] = (tmp2 * fjac[i + 1][0][4]) - (tmp1 * njac[i + 1][0][4]);\n      lhs[i][CC][1][4] = (tmp2 * fjac[i + 1][1][4]) - (tmp1 * njac[i + 1][1][4]);\n      lhs[i][CC][2][4] = (tmp2 * fjac[i + 1][2][4]) - (tmp1 * njac[i + 1][2][4]);\n      lhs[i][CC][3][4] = (tmp2 * fjac[i + 1][3][4]) - (tmp1 * njac[i + 1][3][4]);\n      lhs[i][CC][4][4] = ((tmp2 * fjac[i + 1][4][4]) - (tmp1 * njac[i + 1][4][4])) - (tmp1 * dx5);\n    }\n\n    binvcrhs(lhs[0][BB], lhs[0][CC], rhs[k][j][0]);\n    for (i = 1; i <= (isize - 1); i++)\n    {\n      matvec_sub(lhs[i][AA], rhs[k][j][i - 1], rhs[k][j][i]);\n      matmul_sub(lhs[i][AA], lhs[i - 1][CC], lhs[i][BB]);\n      binvcrhs(lhs[i][BB], lhs[i][CC], rhs[k][j][i]);\n    }\n\n    matvec_sub(lhs[isize][AA], rhs[k][j][isize - 1], rhs[k][j][isize]);\n    matmul_sub(lhs[isize][AA], lhs[isize - 1][CC], lhs[isize][BB]);\n    binvrhs(lhs[isize][BB], rhs[k][j][isize]);\n    for (i = isize - 1; i >= 0; i--)\n    {\n      for (m = 0; m < BLOCK_SIZE; m++)\n      {\n        for (n = 0; n < BLOCK_SIZE; n++)\n        {\n          rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[i][CC][n][m] * rhs[k][j][i + 1][n]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/37"}
{"code": "for (i = 0; i < 1000; i++)\n  for (k = 0; k < 1000; k++)\n  for (j = 0; j < 1000; j++)\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/autoParallelization/tests/matrixmultiply2/0"}
{"code": "for (int i = 0; i < cluster_amount; i++)\n{\n  int current_cluster_offset = cluster_points_offset[i] * (sizeof(Axis));\n  int points_amount = cluster_points_amount[i];\n  unpack_elements(&current_cluster_offset, buffer, buffer_size, cluster_points_axis[i], points_amount, axis_type);\n}\n\n", "pragma": "#pragma omp parallel for shared(cluster_points_offset,cluster_points_amount,buffer,buffer_size,cluster_points_axis,axis_type)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/24"}
{"code": "for (long i = 0; i < people.size(); i++)\n{\n  people[i].setInteraction(setInteractionNum());\n  simulateDailyInteraction(i);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(runtime) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rskim47/disease-propagation/simulation/7"}
{"code": "for (int i = 1; i < generations; i++)\n{\n  if (0 == 1)\n  {\n    printTable(table, size, threads, i);\n    getchar();\n  }\n\n  newTable = stepGeneration(table, size, threads);\n  table = newTable;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arielfreire/conways-game-of-life/jogo_da_vida/4"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  this->mat_.val[i] += alpha;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/20"}
{"code": "for (__pyx_t_6 = 0; __pyx_t_6 < __pyx_t_5; __pyx_t_6 += 1)\n{\n  __pyx_v_i = __pyx_t_6;\n  (void) memcpy(__pyx_v_dst_data, __pyx_v_src_data, __pyx_v_itemsize);\n  __pyx_v_src_data = __pyx_v_src_data + __pyx_v_src_stride;\n  __pyx_v_dst_data = __pyx_v_dst_data + __pyx_v_dst_stride;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/13"}
{"code": "for (i = 0; i < nsub; i++)\n  printf(\"  %8d  %8d  %8d\\n\", i + 1, node[0 + (i * 2)], node[1 + (i * 2)]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/16"}
{"code": "for (int i = 0; i < t_h; ++i)\n{\n  for (int j = 0; j < t_w; ++j)\n  {\n    dist = pow(i - (((double) t_h) / 2), 2) + pow(j - (((double) t_w) / 2), 2);\n    m_wei[(i * t_w) + j] = 1 - (dist / band_width);\n    C_ += m_wei[(i * t_w) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DasudaRunner/Object-Tracking/TrackingLib/src/MeanShift/8"}
{"code": "for (int k = 0, i = train_len; i < N; k++, i++)\n  y_test[k] = y[index[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/5"}
{"code": "for (j = 0; j < d[1]; j++)\n{\n  for (ii = 0; ii <= (d[0] - fftblock); ii += fftblock)\n  {\n    for (k = 0; k < d[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        y0[k][i].real = x[k][j][i + ii].real;\n        y0[k][i].imag = x[k][j][i + ii].imag;\n      }\n\n    }\n\n    cfftz(is, logd[2], d[2], y0, y1);\n    for (k = 0; k < d[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        xout[k][j][i + ii].real = y0[k][i].real;\n        xout[k][j][i + ii].imag = y0[k][i].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/FT/ft/4"}
{"code": "for (i = 0; i < 5; i++)\n{\n  sum = (sum + a[i]) + b[i];\n  printf(\"CPU:%d\\t Thread:%d\\t Value:%d\\n\", sched_getcpu(), omp_get_thread_num(), sum);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/reduction sum/0"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, C[i][j]);\n  if ((((i * ni) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gemm/gemm/3"}
{"code": "for (int ii = b_i; ii < GET_MIN(b_i + block_size, mat_size); ii++)\n{\n  for (int jj = b_j; jj < GET_MIN(b_j + block_size, mat_size); jj++)\n  {\n    psum = 0.0;\n    for (int kk = b_k; kk < GET_MIN(b_k + block_size, mat_size); kk++)\n    {\n      psum += A[ii][kk] * B[kk][jj];\n    }\n\n    C[ii][jj] += psum;\n  }\n\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/medasuryatej/advanced_parallel_computation/strassen_matmul_omp/strassen_omp_tasks/4"}
{"code": "for (int i = 0; i < 512; i++)\n  for (int j = 0; j < 512; j++)\n  for (int k = 0; k < 512; k++)\n  C[i][j] += A[i][k] * B[k][j];\n\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Supercool1604/OpenMP-Codes/Matrix_Mul/0"}
{"code": "for (i = ibeg; i <= ifin; i++)\n{\n  iglob = i;\n  for (k = ki1; k <= ki2; k++)\n  {\n    phi1[i][k] = C2 * (u[i][jbeg][k][4] - ((0.50 * ((pow2(u[i][jbeg][k][1]) + pow2(u[i][jbeg][k][2])) + pow2(u[i][jbeg][k][3]))) / u[i][jbeg][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/38"}
{"code": "for (int i = 0; i < num_outputs; ++i)\n{\n  const double *this_i = updates_[i];\n  const double *other_i = other.updates_[i];\n  for (int j = 0; j < num_inputs; ++j)\n  {\n    double product = this_i[j] * other_i[j];\n    if (product < 0.0)\n      *changed -= product;\n    else\n      *same += product;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/9"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  reverse_col[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/116"}
{"code": "for (int i = 0; i < x.dim1(); i++)\n{\n  for (int j = 0; j < x.dim2(); j++)\n  {\n    (cout << x[i][j]) << \"  \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leoaugustoam/PCA-Parallel-OpenMP/pca/8"}
{"code": "for (i = 0; i < OBSERVES; i++)\n  MPI_Bcast(&emissionMat[i][0], STATES, MPI_INT, 0, MPI_COMM_WORLD);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/2"}
{"code": "for (int j = 0; j < i; j++)\n  sub += L[i][j] * v[j];\n\n", "pragma": "omp parallel for reduction(+:sub)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/6"}
{"code": "for (int i = 0; i < buckets; i++)\n{\n  printf(\"bin[%d] = %d\\n\", i, bin[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reniby/Parallel-Computing/openMP/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  P_a = particles + i;\n  P_a->x = P_a->x_n;\n  P_a->y = P_a->y_n;\n  colli_mat[i] = 0;\n}\n\n", "pragma": "omp parallel for private(P_a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nexuslrf/Parallelizable_Particle_Collision_Simulation/collision_grid_p/1"}
{"code": "for (i = 0; i < ((ptrdiff_t) count); ++i)\n{\n  int64_t v = vertex[i];\n  owner[i] = VERTEX_OWNER(v);\n  local[i] = VERTEX_LOCAL(v);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_replicated/3"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_merge_sort1(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/7"}
{"code": "for (t = 0; t < size; t++)\n{\n  if (t < period)\n  {\n    t9emaTable.at(t) = 0;\n    continue;\n  }\n\n  for (int j = t; j >= (t - period); j--)\n  {\n    t9emaTable.at(t) += (alpha * pow(beta, t - j)) * macd_line[j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(threads) private(t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harshnagarkar/OpenMP-MACD-performance-evaluator/stock_macd_omp/6"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    if (x[i][j] == INT_MIN)\n      cout << \"x \";\n    else\n      (cout << x[i][j]) << \" \";\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mujundi/assembler/Assembler/assemble/3"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      if (m == mst)\n      {\n        Pworksx[LOC3D(i, j, k)] = (Pxfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pxfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n        Pworksy[LOC3D(i, j, k)] = (Pyfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pyfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n        Pworksz[LOC3D(i, j, k)] = (Pzfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pzfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n      }\n\n      Pdqdx_4d[LOC4D(i, j, k, m)] = (-Pworksx[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n      Pdqdy_4d[LOC4D(i, j, k, m)] = (-Pworksy[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n      Pdqdz_4d[LOC4D(i, j, k, m)] = (-Pworksz[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/report/FYArray/src/main/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  idx = (i * n) + j;\n  uo[idx] = u0[idx];\n  uc[idx] = u1[idx];\n}\n\n\n", "pragma": "omp parallel for num_threads(nthreads) private(idx, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deepakguptancsu/Lake-simulation-parallel-processing/omp_acc/lake/0"}
{"code": "for (int gene = 0; gene < 500; gene++)\n{\n  eval = evaluation(POPULATION[gene]);\n  if (eval == 0)\n    return gene;\n\n  gene_score = MAX_THREATS - eval;\n  sum_score += gene_score;\n  scores[gene] = gene_score;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.0/4"}
{"code": "for (i = 0; i < local_n1; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < Nf; k++)\n{\n  const int z = (((i * N) + j) * Nf) + k;\n  U_hat[z] = U_hat0[z] + (b[rk] * dU[z]);\n  V_hat[z] = V_hat0[z] + (b[rk] * dV[z]);\n  W_hat[z] = W_hat0[z] + (b[rk] * dW[z]);\n}\n\n\n\n", "pragma": "                #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/10"}
{"code": "for (int i = 0; i < fin; i++)\n{\n  if (numero == arreglo.at(i))\n  {\n    contador++;\n  }\n  else\n  {\n    if (contador > contadorAux)\n    {\n      contadorAux = contador;\n      numeroAux = numero;\n    }\n\n    contador = 1;\n    numero = arreglo.at(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IsraelRamirez/Promediador-Omp-Mpi-Secuencial/openmp-cpp/main/3"}
{"code": "for (n = 0; n < N; n++)\n{\n  sum0 = -INFINITY;\n  sum1 = -INFINITY;\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    sum1 = max(sum1, A1[k + (n * rsctrellis.numStates)] + B1[k + (n * rsctrellis.numStates)]);\n    sum0 = max(sum0, A0[k + (n * rsctrellis.numStates)] + B0[k + (n * rsctrellis.numStates)]);\n  }\n\n  extrinsic_data[n] = (sum1 - sum0) - apriori_data[n];\n  extrinsic_coded[2 * n] = (sum1 - sum0) - Lc1I[n];\n}\n\n", "pragma": "#pragma omp parallel for private(n, k, sum0, sum1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/8"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  timeStart = omp_get_wtime();\n  AxBParallelForCritical(masA, M, N, masB, N, K, masC);\n  timeEnd = omp_get_wtime();\n  time += timeEnd - timeStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/Matr/4"}
{"code": "for (i = 0; i < DATA_SIZE; i++)\n{\n  data[i] = rand() % MAX_RAND;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/0"}
{"code": "for (unsigned int u = 0; u < m_uNumberOfGridPoints1D; ++u)\n{\n  for (unsigned int v = 0; v < m_uNumberOfGridPoints1D; ++v)\n  {\n    snprintf(chBuffer, 16, \"%f\", m_gridHeat[u][v]);\n    m_strLogHeatDistribution += chBuffer;\n    m_strLogHeatDistribution += \" \";\n  }\n\n  m_strLogHeatDistribution += '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/3"}
{"code": "for (int i = 0; i < npatches; i++)\n{\n  for (int j = 0; j < npatches; j++)\n  {\n    cout << flush;\n    ((((((cout << \"Patch: [ \") << i) << \" , \") << j) << \" ] ::  \") << TUsage[i][j].work) << endl;\n  }\n\n  cout << \"\\n\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arghyac007/DMRG-openMP/openmpPrototypeTests/3Level_Indi_aHT/0"}
{"code": "for (i = 1; i < total; i++)\n{\n  float y = pointerf[i]->y;\n  if (pointerf[miny_ind]->y > y)\n    miny_ind = i;\n\n  if (pointerf[maxy_ind]->y < y)\n    maxy_ind = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/2"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  for (int j = 1; j < (tasksize + 1); j++)\n  {\n    Crow[(i * tasksize) + j] += row_sum;\n  }\n\n  row_sum = Crow[(i + 1) * tasksize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/7"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if ((i % 2) == 0)\n  {\n    out_real[i] = in_real[i];\n    out_imag[i] = in_imag[i];\n  }\n  else\n  {\n    out_real[i] = -in_real[i];\n    out_imag[i] = -in_imag[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lsqt-omp/vector/7"}
{"code": "for (long i = 0; i < nC1; i++)\n{\n  clusterDist1[i] = commPtr1[i + 1];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/6"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  result[i] = a[i] / b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/24"}
{"code": "for (int k = 1; k < CVT_INT(m_nSoilLyrs[i]); k++)\n{\n  vap = (m_soilSolP[i][k] * m_soilPerco[i][k]) / ((m_cvtWt[i][k] * 0.001f) * m_pperco);\n  vap = Min(vap, 0.2f * m_soilSolP[i][k]);\n  m_soilSolP[i][k] -= vap;\n  if (k < (m_nSoilLyrs[i] - 1))\n  {\n    m_soilSolP[i][k + 1] += vap;\n  }\n  else\n  {\n    m_percoP[i] = vap;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrMV/NutrientMovementViaWater/8"}
{"code": "for (i = 0; i < m->nrows; ++i)\n{\n  values[i] = (double *) malloc(max_entries_per_row * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/blocked/6"}
{"code": "for (int x = 0; x < (n - 1); x++)\n{\n  int iMin = x;\n  for (int y = x + 1; y < n; y++)\n  {\n    if (ilgi[y] > ilgi[iMin])\n      iMin = y;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OsamaTab/openMp/OpenMp/Source/1"}
{"code": "for (int n = 0; n < N; n++)\n{\n  mult(out + n, in1, in2);\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/sollve_vv/tests/5.0/application_kernels/gridmini_ptr/0"}
{"code": "for (i = 0; i <= n; i++)\n{\n  x = h * (((double) i) + 0.5);\n  sum += (4.0 / (1.0 + (x * x))) / n;\n}\n\n", "pragma": "omp parallel for reduction(+:sum) shared(h) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/006_data_race_condition_compute/0"}
{"code": "for (int i = 0; i < image_dim_y; i++)\n{\n  for (int j = 0; j < image_dim_x; j++)\n  {\n    output_image(i, j) = high_res_output_image(i, j) + low_res_extended_output_image_linterp((i + image_dim_y) + (g_cpt_dim_y / 2), (j + image_dim_x) + (g_cpt_dim_x / 2));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/22"}
{"code": "for (int tid = 0; tid < testsize; tid++)\n{\n  svd(input[tid + (0 * testsize)], input[tid + (1 * testsize)], input[tid + (2 * testsize)], input[tid + (3 * testsize)], input[tid + (4 * testsize)], input[tid + (5 * testsize)], input[tid + (6 * testsize)], input[tid + (7 * testsize)], input[tid + (8 * testsize)], output[tid + (0 * testsize)], output[tid + (1 * testsize)], output[tid + (2 * testsize)], output[tid + (3 * testsize)], output[tid + (4 * testsize)], output[tid + (5 * testsize)], output[tid + (6 * testsize)], output[tid + (7 * testsize)], output[tid + (8 * testsize)], output[tid + (9 * testsize)], output[tid + (10 * testsize)], output[tid + (11 * testsize)], output[tid + (12 * testsize)], output[tid + (13 * testsize)], output[tid + (14 * testsize)], output[tid + (15 * testsize)], output[tid + (16 * testsize)], output[tid + (17 * testsize)], output[tid + (18 * testsize)], output[tid + (19 * testsize)], output[tid + (20 * testsize)]);\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/svd3x3-omp/main/0"}
{"code": "for (int i = 0; i < VERTEX_COUNT; i++)\n  visited_count += visited[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/19"}
{"code": "for (int i = 0; i < number_of_edges; i++)\n  offset[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/11"}
{"code": "for (i = 0; i < k; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp parallel for private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/vector_add/0"}
{"code": "for (int i = 0; i < 7; ++i)\n  for (int j = i; j < 7; ++j)\n  ;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/clang/test/OpenMP/tile_messages/2"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  for (subcycle = 0; subcycle < 10; subcycle++)\n  {\n    partArray[0]->update_count = 1;\n    partArray[0]->firstZone->value = calc_deposit();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp/15"}
{"code": "for (i = 0; i < dim; i++)\n  sum += fabs(yn[i]);\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jacobi_column/jacobi_omp_col/2"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  at2 = (-ci2) * crealf(ffe[k]);\n  at1 = at2 * cimagf(ffe[k]);\n  at2 = at2 * at2;\n  exy[3 * k] = at1 * dcu[3 * k];\n  exy[1 + (3 * k)] = at1 * dcu[1 + (3 * k)];\n  exy[2 + (3 * k)] = at1 * dcu[2 + (3 * k)];\n  exy[3 * k1] = zero;\n  exy[1 + (3 * k1)] = zero;\n  exy[2 + (3 * k1)] = zero;\n  wp += at2 * (((dcu[3 * k] * conjf(dcu[3 * k])) + (dcu[1 + (3 * k)] * conjf(dcu[1 + (3 * k)]))) + (dcu[2 + (3 * k)] * conjf(dcu[2 + (3 * k)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpdpic2/mpdpush2/18"}
{"code": "for (int i = maxLength; i >= 1; i--)\n{\n  if ((((char) shared_block.gene1Result[i]) == '_') && (((char) shared_block.gene2Result[i]) == '_'))\n  {\n    gapsEncountered = i + 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaraaSameer/Pairwise-Sequence-Alignment/SequenceAlgo_OpenMP/4"}
{"code": "for (i = 0; i < iterationsNumber; i++)\n{\n  if (n == function1(i))\n    counter++;\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_1/z1/1"}
{"code": "for (i = 0; i < NL; i++)\n{\n  for (j = 0; j < NI; j++)\n  {\n    if (percentDiff(E[(i * NI) + j], E_GPU[(i * NI) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2MM/2mm/6"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  if (abs(a[i][k]) > max)\n  {\n    max = abs(a[i][k]);\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PAAnisimofff/SLAU_OpenMP/SLAU_OpenMP/SLAU_OpenMP/0"}
{"code": "for (int i = 146; i < 194; ++i)\n{\n  w[i] *= D1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/19"}
{"code": "for (i = 0; i < (*num_ts); i++)\n{\n  receive_int_message(&(*int_to_evaluate)[i], 0, tag);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/16"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  min_idx = i;\n  for (j = i + 1; j < n; j++)\n    if (arr[j] < arr[min_idx])\n    min_idx = j;\n\n\n  swap(&arr[min_idx], &arr[i]);\n  swap_int(&neighbors_index[min_idx], &neighbors_index[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/npaschos/kNN-Search-MPI-OpenMP/main/8"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n  topo.stenc[i].resize(64, -1);\n\n", "pragma": "#pragma omp for schedule(static,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/mesh/4"}
{"code": "for (i = 0; i < MatrixDim; i++)\n{\n  L[i] = (FP_NUMBER *) malloc((sizeof(FP_NUMBER)) * MatrixDim);\n  U[i] = (FP_NUMBER *) malloc((sizeof(FP_NUMBER)) * MatrixDim);\n  A[i] = (FP_NUMBER *) malloc((sizeof(FP_NUMBER)) * MatrixDim);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_lud/tools/gen_input/2"}
{"code": "for (int i = 0; i < localSize(); i++)\n{\n  avg += abs((*this)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/src/Scalar/0"}
{"code": "for (size_t i = 0; i < temp.size(); ++i)\n{\n  temp[i] = tolower(temp[i]);\n  if (!((((temp[i] >= 'a') && (temp[i] <= 'z')) || (temp[i] == '\\'')) || (temp[i] == '-')))\n  {\n    if (i == 0)\n    {\n      temp = temp.substr(1, temp.size());\n      temp[i] = tolower(temp[i]);\n    }\n    else\n    {\n      temp[i] = ':';\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jayrobo/OpenMP/Lab 4/Word_Count/0"}
{"code": "for (int i = num - 1; i > 0; --i)\n{\n  for (int k = i - 1; k >= 0; --k)\n  {\n    mul = M2[k][i];\n    for (int count = i; count < (num + 1); ++count)\n    {\n      M2[k][count] = M2[k][count] - (mul * M2[i][count]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/43"}
{"code": "for (int i = 0; i < generation_size; i++)\n  population[i] = random_individual(g, K);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jpaton/graph-ga/Engines/basic/0"}
{"code": "for (int i = iters.size() - 1; i >= 0; i--)\n{\n  N_strs[i] = iter_i(i) + N_strs[i + 1];\n  if (i < (((int) iters.size()) - 1))\n  {\n    out += \",const int _N\" + N_strs[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/einsxiao/evawiz/evawiz/src/evacc/syntax_launch_kernel/2"}
{"code": "for (int i = 0; i < (60000 * 500); i++)\n{\n  tmp = rand() % 60000;\n  desiredOut[class_train[tmp]] = 0.9;\n  trainNN(data_train[tmp], desiredOut);\n  desiredOut[class_train[tmp]] = 0.1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/10"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    x = ((((double) (j - 1)) * x_max) + (((double) (m - j)) * x_min)) / ((double) (m - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (n - i)) * y_min)) / ((double) (n - 1));\n    count[i][j] = 0;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2)) || (2 < x2)) || (y2 < (-1))) || (1 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if ((count[i][j] % 2) == 1)\n    {\n      r[i][j] = 255;\n      g[i][j] = 255;\n      b[i][j] = 255;\n    }\n    else\n    {\n      c = (int) (255.0 * sqrt(sqrt(sqrt(((double) count[i][j]) / ((double) count_max)))));\n      r[i][j] = (3 * c) / 5;\n      g[i][j] = (3 * c) / 5;\n      b[i][j] = c;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Diogo45/OpenMPI/mandelbrot_dynamic/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/37"}
{"code": "for (int i = 0; i < num_output_channels; i++)\n{\n  output_buffer[i].resize(num_output_samples);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tristanelma/reverb_parallelization/project/impulse_parallel/0"}
{"code": "for (i = 0; i < 2000000000; i++)\n{\n  x = (i + 0.5) * interval_width;\n  pi += 1.0 / ((x * x) + 1.0);\n}\n\n", "pragma": "omp parallel for reduction(+:pi) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/pireduction-orig-no/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  printf(\"%d \", division[i]);\n  if (((i + 1) % 10) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/demos/openmp/parallel-for/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  generate_data(kernel, dim_kernel);\n  generate_data(image, dim_image);\n  double time_init = omp_get_wtime();\n  convolucion(kernel, image, result, thread_count);\n  double time_final = omp_get_wtime();\n  double n_elapsed = time_final - time_init;\n  if (n_elapsed < elapsed)\n    elapsed = n_elapsed;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/ConvolutionOpenMP/convolucion/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  hb[i] = 0;\n  hg[i] = 0;\n  hr[i] = 0;\n  hgray[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AsielTrejo/BlurringEffect/blur/2"}
{"code": "for (i = 1; i < 1000; i++)\n{\n  x = sqrt(b[i]) - 1;\n  a[i] = ((x * x) + (2 * x)) + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/simoatze/archer_race_examples/data-race03/1"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  update(cars, grid, new_grid, &sim, xsubj);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/9"}
{"code": "for (int i = -win_radius; i <= win_radius; i++)\n{\n  r = kptr_i + i;\n  if ((r <= 0) || (r >= (h - 1)))\n    continue;\n\n  for (int j = -win_radius; j <= win_radius; j++)\n  {\n    c = kptc_i + j;\n    if ((c <= 0) || (c >= (w - 1)))\n      continue;\n\n    magni = grdData[(r * w) + c];\n    angle = rotData[(r * w) + c];\n    fbin = (angle * nBins) / _2PI;\n    weight = expf((((i - d_kptr) * (i - d_kptr)) + ((j - d_kptc) * (j - d_kptc))) * exp_factor);\n    bin = (int) (fbin - 0.5f);\n    float d_fbin = (fbin - 0.5f) - bin;\n    float mw = weight * magni;\n    float dmw = d_fbin * mw;\n    tmpHist[(bin + nBins) % nBins] += mw - dmw;\n    tmpHist[(bin + 1) % nBins] += dmw;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/11"}
{"code": "for (int v = 0; v < 8; v++)\n{\n  const int n1 = i + VOISINS[v][0];\n  const int n2 = j + VOISINS[v][1];\n  CHECK((((n1 >= 0) && (n1 < nrows)) && (n2 >= 0)) && (n2 < ncols));\n  if (Wprec[(n1 * ncols) + n2] == m->no_data)\n    continue;\n\n  CHECK(TERRAIN(m, i, j) > m->no_data);\n  CHECK(Wprec[(i * ncols) + j] > m->no_data);\n  CHECK(Wprec[(n1 * ncols) + n2] > m->no_data);\n  const float Wn = Wprec[(n1 * ncols) + n2] + EPSILON;\n  if (TERRAIN(m, i, j) >= Wn)\n  {\n    W[(i * ncols) + j] = TERRAIN(m, i, j);\n    modif = 1;\n  }\n  else\n    if (Wprec[(i * ncols) + j] > Wn)\n  {\n    W[(i * ncols) + j] = Wn;\n    modif = 1;\n    if (W[(i * ncols) + j] < min_darboux)\n      min_darboux = W[(i * ncols) + j];\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/darboux/4"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    exp_inv_r += (1. / sqrt((wf.x1[i] * wf.x1[i]) + (wf.x2[j] * wf.x2[j]))) * norm(wf.wave[wf.in2(j, i)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/36"}
{"code": "for (int i = 0; i < nx; i++)\n{\n  for (int j = 0; j < ny; j++)\n  {\n    uex[(i * nx) + j] = sin(pi * x[i]) * sin(pi * y[j]);\n    f[(i * nx) + j] = (((-2.0) * pi) * pi) * uex[(i * nx) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/jacobi_omp/9"}
{"code": "for (int vertex_other = 0; vertex_other < VERTEX_COUNT; vertex_other++)\n{\n  int edge_idx = EDGE_INDICES[(vertex * VERTEX_COUNT) + vertex_other];\n  if (edge_idx >= 0)\n  {\n    if ((edges[edge_idx] == 1) && (visited[vertex_other] == 0))\n    {\n      is_connected_recursive(vertex_other, edges, visited);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/18"}
{"code": "for (int k = 0; k < nodesCount; ++k)\n{\n  int tmp;\n  for (int i = 0; i < nodesCount; ++i)\n  {\n    if (distance[i][k] != 2147483647)\n    {\n      for (int j = 0; j < nodesCount; ++j)\n      {\n        if (distance[k][j] != 2147483647)\n        {\n          omp_set_lock(&lock[k][j]);\n          tmp = distance[i][k] + distance[k][j];\n          omp_unset_lock(&lock[k][j]);\n          omp_set_lock(&lock[i][j]);\n          if ((distance[i][j] == 2147483647) || (tmp < distance[i][j]))\n          {\n            distance[i][j] = tmp;\n          }\n\n          omp_unset_lock(&lock[i][j]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pancak3/Diameter-OpenMP/FloydsParallel/1"}
{"code": "for (int iter = 0; iter < (40 * 5); iter++)\n  foobar(iter);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/data_issue_59/data_issue_59/1"}
{"code": "for (i = 0; i < (HIgh_h / 2); i++)\n{\n  for (j = (Low_w / 4) * 3; j < (Low_w - 2); j++)\n  {\n    bicubic_Y[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Y[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/12"}
{"code": "for (int i = 0; i < numDimensions; i++)\n{\n  position[i] = p[i];\n  velocity[i] = v[i];\n  acceleration[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Dynamique_Moleculaire/DynMol_parallel/0"}
{"code": "for (i = 0; i < a_r; i++)\n{\n  printf(\"\\ncan not multiply\");\n  goto again;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejaswiParuchuri/ParalleProcessing/mulmp/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    *((arr + (i * size)) + j) = val++;\n  }\n\n}\n\n", "pragma": "omp for schedule (static, size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SboneloMdluli/ELEN4020-Lab2/OpenMP/digOpenMp/0"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  l = i + 1;\n  g = w[i];\n  if (i != (n - 1))\n    for (j = l; j < n; j++)\n    u[i][j] = 0.0;\n\n\n  if (g != 0.0)\n  {\n    if (i != (n - 1))\n    {\n      for (j = l; j < n; j++)\n      {\n        s = 0.0;\n        for (k = l; k < m; k++)\n          s += u[k][i] * u[k][j];\n\n        f = (s / u[i][i]) / g;\n        for (k = i; k < m; k++)\n          u[k][j] += f * u[k][i];\n\n      }\n\n    }\n\n    for (j = i; j < m; j++)\n      u[j][i] /= g;\n\n  }\n  else\n    for (j = i; j < m; j++)\n    u[j][i] = 0.0;\n\n\n  u[i][i] += 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/15"}
{"code": "for (i = 0; i < 20000; i++)\n  for (j = 0; j < 20000; j++)\n  graph[j][i] = graph[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Parth-31/Parallel-Prims-Algorithm-using-OpenMP/Code/primspar/6"}
{"code": "for (uint64_t i = 0; i < result.iSize; i++)\n{\n  for (uint64_t j = 0; j < result.jSize; j++)\n  {\n    result.matrix[(i * result.jSize) + j] = 0;\n    for (uint64_t k = 0; k < matrixA.jSize; k++)\n    {\n      result.matrix[(i * result.jSize) + j] += matrixA.matrix[(i * matrixA.jSize) + k] * matrixB.matrix[(k * matrixB.jSize) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for nowait collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_GaussianProcessRegression/gpr/0"}
{"code": "for (i = 0; i < SZ; i++)\n{\n  for (j = 0; j < SZ; j++)\n  {\n    double *pA;\n    double *pB;\n    double S;\n    S = 0.0;\n    pA = a + (i * SZ);\n    pB = b + (j * SZ);\n    for (k = SZ; k > 0; k--, pA++, pB++)\n      S += (*pA) * (*pB);\n\n    c[(i * SZ) + j] = S;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/MPP1/algoritmo_2/0"}
{"code": "for (int i = 0; i < mu; i++)\n{\n  F[(t + 1) & 1][i] = func(x[i], num);\n}\n\n", "pragma": "        #pragma omp parallel for shared(mu,t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/backup/new_codes/R1ES_omp_alt/6"}
{"code": "for (int h = 0; h < qlength; ++h)\n{\n  head = levset[h];\n  for (int k = this->mat_.row_offset[head]; k < this->mat_.row_offset[head + 1]; ++k)\n  {\n    tmp = this->mat_.col[k];\n    if ((marker[tmp] == 0) && (tmp != head))\n    {\n      nextlevset[position] = tmp;\n      marker[tmp] = 1;\n      cast_perm->vec_[tmp] = next;\n      ++next;\n      ++position;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/76"}
{"code": "for (long int i = 0; i < 1000000000; i++)\n{\n  myseed = omp_get_thread_num();\n  double r_x = ((double) (rand_r(&myseed) % (1000000000 + 1))) / 1000000000;\n  double r_y = ((double) (rand_r(&myseed) % (1000000000 + 1))) / 1000000000;\n  double tot = (r_x * r_x) + (r_y * r_y);\n  if (tot <= 1.0)\n    c_point++;\n\n}\n\n", "pragma": "omp parallel for reduction(+:c_point)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ath-90/hpc-openmp-assignment/monte_carlo_2/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  v[i] = L++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/CUDA/VectorAdd/parallel_omp/0"}
{"code": "for (i = 0; i < nra; i++)\n{\n  for (j = 0; j < nca; j++)\n  {\n    a[i][j] = (double) (i + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonyz0x0/parallel-computing/omp_saxp/1"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  media += arr[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio8/ejercicio8Paralelo/3"}
{"code": "for (int i = 0; i < n; i++)\n  printf(\"%d \", result[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task3/5"}
{"code": "for (j = 0; j < nop; j++)\n{\n  n = part[idimp * j];\n  m = part[1 + (idimp * j)];\n  n = n / mx;\n  m = m / my;\n  m = n + (mx1 * m);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    kp[ip + (nppmx * m)] = j;\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/28"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((m != centre) && (m != near_ind[0]))\n  {\n    if ((min2 == (-1.0)) || (dist_list[m] < min2))\n    {\n      min2 = dist_list[m];\n      near_ind[1] = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/12"}
{"code": "for (int i = 0; i < alignedN; i += 16)\n  _mm512_storeu_ps(&y[i], _mm512_add_ps(_mm512_loadu_ps(&a[i]), _mm512_loadu_ps(&b[i])));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/8"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < feat5; j++)\n  {\n    for (int k = 0; k < 6; k++)\n    {\n      for (int l = 0; l < 6; l++)\n      {\n        layer6[i] = weight622[i][j][k][l] * pool62[j][k][l];\n      }\n\n    }\n\n  }\n\n  layer6[i] += 1;\n  layer6[i] = max((double) 0, layer6[i]);\n}\n\n", "pragma": "                    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/15"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      int index = (((ii * _chunk.x) * _chunk.y) + (jj * _chunk.x)) + kk;\n      const double smvp = SMVP(u);\n      r[index] = u0[index] - smvp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_solver_methods/1"}
{"code": "for (row = 0; row < m; row++)\n  for (col = 0; col < p; col++)\n  printf(\"%f : \", D[(row * p) + col]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bhaskariitm/OpenMP-codes/Code/6"}
{"code": "for (j = 0; j < npxy; j++)\n{\n  dsum1 += part[2 + (idimp * j)];\n  dsum2 += part[3 + (idimp * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/8"}
{"code": "for (unsigned I = 0, N = E->getNumArgs(); I != N; ++I)\n{\n  if (I > 0)\n    OS << \", \";\n\n  E->getArg(I)->getType().print(OS, Policy);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/AST/StmtPrinter/12"}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  int attempt = 0;\n  double ktests[3];\n  int domoretests = 1;\n  while (domoretests)\n  {\n    double start = omp_get_wtime();\n    thrMM(A, B, C);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n    if (attempt < 3)\n    {\n      ktests[attempt] = elapsed;\n    }\n    else\n    {\n      insertTest(elapsed, ktests);\n    }\n\n    if (attempt == 20)\n      domoretests = 0;\n\n    if ((attempt >= 5) && withinTol(ktests))\n      domoretests = 0;\n\n    attempt++;\n  }\n\n  for (int i = 0; i < 3; i++)\n    printf(\"# %f\\n\", ktests[i]);\n\n  printf(\"# attempts: %d\\n\", attempt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_main/1"}
{"code": "for (i = T_bench; i < T_last; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/8"}
{"code": "for (int i = 0; i < 54; i++)\n{\n  xx[i] = fgetc(image);\n  fputc(xx[i], outputImage);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Carlos-Ramos-Gtz/OpenMP/Examen Scheduled/7"}
{"code": "for (int j = first; j < SIZE; j += 2)\n  if (vector[j - 1] > vector[j])\n  swap(&vector[j - 1], &vector[j]);\n\n\n", "pragma": "            #pragma omp parallel for default(none), shared(vector,first,SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s4mukka/bubblesortparallel/final_project/0"}
{"code": "for (int i = 1; i < ((n - L) + 1); i++)\n{\n  int j = (i + L) - 1;\n  m[i + ((j * (j - 1)) / 2)] = 4294967294;\n  for (int k = i; k <= (j - 1); k++)\n  {\n    int q = (m[i + ((k * (k - 1)) / 2)] + m[(k + 1) + ((j * (j - 1)) / 2)]) + ((p[i - 1] * p[k]) * p[j]);\n    if (q < m[i + ((j * (j - 1)) / 2)])\n    {\n      m[i + ((j * (j - 1)) / 2)] = q;\n      bracket[i + ((j * (j - 1)) / 2)] = k;\n    }\n\n  }\n\n}\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/6"}
{"code": "for (int j = 0; j < numRows; j++)\n{\n  for (int i = 0; i < numCols; i++)\n  {\n    float amb_temp = 80.0;\n    int c = i + (j * numCols);\n    int xy = numCols * numRows;\n    int W = (i == 0) ? (c) : (c - 1);\n    int E = (i == (numCols - 1)) ? (c) : (c + 1);\n    int N = (j == 0) ? (c) : (c - numCols);\n    int S = (j == (numRows - 1)) ? (c) : (c + numCols);\n    float temp1;\n    float temp2;\n    float temp3;\n    temp1 = (temp2 = tIn[c]);\n    temp3 = tIn[c + xy];\n    tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n    c += xy;\n    W += xy;\n    E += xy;\n    N += xy;\n    S += xy;\n    for (int k = 1; k < (layers - 1); ++k)\n    {\n      temp1 = temp2;\n      temp2 = temp3;\n      temp3 = tIn[c + xy];\n      tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n      c += xy;\n      W += xy;\n      E += xy;\n      N += xy;\n      S += xy;\n    }\n\n    temp1 = temp2;\n    temp2 = temp3;\n    tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n  }\n\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hotspot3D-omp/3D/0"}
{"code": "for (ii = 0; ii < 10; ++jj)\n  c[ii] = a[jj];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/21"}
{"code": "for (unsigned long long i = 0; i < n; i++)\n{\n  sum += 4.0 / (1.0 + (((i + 0.5) * step) * ((i + 0.5) * step)));\n}\n\n", "pragma": "omp parallel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/pi/0"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = random() % RMAX;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Octonion-Star/Parallel-Programming/Lab8_1/0"}
{"code": "for (int j = 0; j < Freq_cell; ++j)\n{\n  for (int i = 0; i < Holo_Freq_cell; ++i)\n  {\n    if ((hhs_map[j][i] > 1000000000000.0) || (hhs_map[j][i] < (-1000000000000.0)))\n      continue;\n\n    fprintf(map_fp, \"%f %f %f\\n\", HHS_dFMf * j, HHS_dAMf * i, hhs_map[j][i]);\n    HHS_map[(i * Freq_cell) + j] = hhs_map[j][i] + 0.00000001;\n    if (hhs_map[j][i] > HHS_max)\n      HHS_max = hhs_map[j][i];\n\n    if (hhs_map[j][i] < HHS_min)\n      HHS_min = hhs_map[j][i];\n\n  }\n\n  fprintf(map_fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/55"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = A[i] + 1;\n  printf(\"A[%d] is computed by thread number : %d\\n\", i, thread_id);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/grandma-tutorial/OpenMP-tutorial/Worksharing/example_worksharing_1/0"}
{"code": "for (long long int x = 0; x < rowA; x += 8)\n{\n  for (long long int y = 0; y < colB; y += 8)\n  {\n    _mm_prefetch((matB + (((y + 16) + 0) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 1) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 2) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 3) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 4) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 5) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 6) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 7) * rowA)) + x, _MM_HINT_T0);\n    I0 = _mm256_loadu_si256((long long int *) ((matB + ((y + 0) * rowA)) + x));\n    I1 = _mm256_loadu_si256((long long int *) ((matB + ((y + 1) * rowA)) + x));\n    I2 = _mm256_loadu_si256((long long int *) ((matB + ((y + 2) * rowA)) + x));\n    I3 = _mm256_loadu_si256((long long int *) ((matB + ((y + 3) * rowA)) + x));\n    I4 = _mm256_loadu_si256((long long int *) ((matB + ((y + 4) * rowA)) + x));\n    I5 = _mm256_loadu_si256((long long int *) ((matB + ((y + 5) * rowA)) + x));\n    I6 = _mm256_loadu_si256((long long int *) ((matB + ((y + 6) * rowA)) + x));\n    I7 = _mm256_loadu_si256((long long int *) ((matB + ((y + 7) * rowA)) + x));\n    T0 = _mm256_unpacklo_epi64(I0, I1);\n    T1 = _mm256_unpackhi_epi64(I0, I1);\n    T2 = _mm256_unpacklo_epi64(I2, I3);\n    T3 = _mm256_unpackhi_epi64(I2, I3);\n    T4 = _mm256_unpacklo_epi64(I4, I5);\n    T5 = _mm256_unpackhi_epi64(I4, I5);\n    T6 = _mm256_unpacklo_epi64(I6, I7);\n    T7 = _mm256_unpackhi_epi64(I6, I7);\n    I0 = _mm256_unpacklo_epi64(T0, T2);\n    I1 = _mm256_unpackhi_epi64(T0, T2);\n    I2 = _mm256_unpacklo_epi64(T1, T3);\n    I3 = _mm256_unpackhi_epi64(T1, T3);\n    I4 = _mm256_unpacklo_epi64(T4, T6);\n    I5 = _mm256_unpackhi_epi64(T4, T6);\n    I6 = _mm256_unpacklo_epi64(T5, T7);\n    I7 = _mm256_unpackhi_epi64(T5, T7);\n    T0 = _mm256_permute2x128_si256(I0, I4, 0x20);\n    T1 = _mm256_permute2x128_si256(I1, I5, 0x20);\n    T2 = _mm256_permute2x128_si256(I2, I6, 0x20);\n    T3 = _mm256_permute2x128_si256(I3, I7, 0x20);\n    T4 = _mm256_permute2x128_si256(I0, I4, 0x31);\n    T5 = _mm256_permute2x128_si256(I1, I5, 0x31);\n    T6 = _mm256_permute2x128_si256(I2, I6, 0x31);\n    T7 = _mm256_permute2x128_si256(I3, I7, 0x31);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 0) * colB)) + y), T0);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 1) * colB)) + y), T1);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 2) * colB)) + y), T2);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 3) * colB)) + y), T3);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 4) * colB)) + y), T4);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 5) * colB)) + y), T5);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 6) * colB)) + y), T6);\n    _mm256_storeu_si256((long long int *) ((matD + ((x + 7) * colB)) + y), T7);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunth2001/Software-Programming-for-Performance/Assignment2/trials/10/1"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  for (j = 0; j < num_cols; j++)\n  {\n    matrix_a[(i * num_cols) + j] = (((float) rand()) / ((float) 32767)) - 0.5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/matrix vector multiplication/matrix_vector_multiply/2"}
{"code": "for (int i = 0; i < 60000; i++)\n{\n  activateNN(data_train[i]);\n  evaluate(class_train[i], confusionMatrixTrain);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[i] += a * x[i];\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/axpy/0"}
{"code": "for (q1 = 0; q1 < one; q1++)\n  for (q2 = 0; q2 < 64; q2 += 8)\n  for (q3 = 0; q3 < one; ++q3)\n{\n  for (i = q2; i < (q2 + 8); ++i)\n  {\n    g.s += 3 * a[i];\n    h.s *= 3 - c[i];\n    m.s += 4 * a[i];\n    n.s *= c[i];\n    if (((((g.t != 7) && (g.t != 3)) || ((h.t != 5) && (h.t != 9))) || ((m.t != 7) && (m.t != 3))) || ((n.t != 5) && (n.t != 9)))\n      abort();\n\n    baz(i, a, c);\n  }\n\n}\n\n\n\n", "pragma": "omp for schedule(monotonic: dynamic, 1) reduction (task, +: g, m) reduction (task, *: h, n) collapse(3)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/task-reduction-8/2"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA1][32];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 0);\n  }\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    cracked[index + i] = vmx_decrypt(cur_salt, master[i], cur_salt->blob);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vmx_fmt_plug/1"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  cout << s[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/0"}
{"code": "for (i = 0; i < newTam; i++)\n{\n  for (j = 0; j < newTam; j++)\n  {\n    D[i][j] = C11[i][j];\n    D[i][newTam + j] = C12[i][j];\n    D[newTam + i][j] = C21[i][j];\n    D[newTam + i][newTam + j] = C22[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 3/Trab3_Strassen_OMP/7"}
{"code": "for (int i = lower + (my_rank * delta); i < ((my_rank == (comm_sz - 1)) ? (upper) : (lower + ((my_rank + 1) * delta))); i++)\n{\n  sum += m->SquareMatrix[row][i] * m->SquareMatrix[i][column];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/Parallel_1.0/8"}
{"code": "for (j = 0; j < (1 << 20); j++)\n{\n  test();\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkourt/gcc-ompinfo/for-test/3"}
{"code": "for (int i = 1; i < num_procs; i++)\n{\n  int y = i - 1;\n  MPI_Send(&y, 1, MPI_INT, i, TagType_AssignTask, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hi2p-perim/smallpt-mpi/src/main/0"}
{"code": "for (y = 0; y < env_width; y++)\n{\n  environment[y] = (char *) malloc(env_width * (sizeof(char)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/8"}
{"code": "for (int i = 0; i < size; i++)\n{\n  arr[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tanghyd/CITS5507Project01/random_array/2"}
{"code": "for (int k = 0; k < num_clusters; ++k)\n{\n  sum_of_x_per_cluster[k] = 0.0;\n  sum_of_y_per_cluster[k] = 0.0;\n  num_points_in_cluster[k] = 0;\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/1"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  x1 = _mm_load_ps((float *) (&vX1[i]));\n  x2 = _mm_load_ps((float *) (&vX2[i]));\n  p = _mm_mul_ps(x1, x2);\n  s = _mm_add_ps(s, p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/1"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  dkx = dnx * ((float) j);\n  afdt = adt * cimagf(ffc[j]);\n  zt1 = (-cimagf(exyz[2 + (4 * j)])) + (crealf(exyz[2 + (4 * j)]) * _Complex_I);\n  zt2 = (-cimagf(exyz[1 + (4 * j)])) + (crealf(exyz[1 + (4 * j)]) * _Complex_I);\n  zt5 = bxyz[1 + (4 * j)] + (dth * (dkx * zt1));\n  zt6 = bxyz[2 + (4 * j)] - (dth * (dkx * zt2));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n  zt8 = (exyz[1 + (4 * j)] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * j)]);\n  zt9 = (exyz[2 + (4 * j)] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (4 * j)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n  exyz[4 * j] = zero;\n  exyz[1 + (4 * j)] = zt8;\n  exyz[2 + (4 * j)] = zt9;\n  at1 = anorm * ((zt8 * conjf(zt8)) + (zt9 * conjf(zt9)));\n  ws += (double) at1;\n  zt5 += dth * (dkx * zt1);\n  zt6 -= dth * (dkx * zt2);\n  bxyz[4 * j] = zero;\n  bxyz[1 + (4 * j)] = zt5;\n  bxyz[2 + (4 * j)] = zt6;\n  at1 = anorm * ((zt5 * conjf(zt5)) + (zt6 * conjf(zt6)));\n  wp += (double) at1;\n  bxyz[4 * (j + k1)] = zero;\n  bxyz[1 + (4 * (j + k1))] = zero;\n  bxyz[2 + (4 * (j + k1))] = zero;\n  exyz[4 * (j + k1)] = zero;\n  exyz[1 + (4 * (j + k1))] = zero;\n  exyz[2 + (4 * (j + k1))] = zero;\n  bxyz[4 * (j + l1)] = zero;\n  bxyz[1 + (4 * (j + l1))] = zero;\n  bxyz[2 + (4 * (j + l1))] = zero;\n  exyz[4 * (j + l1)] = zero;\n  exyz[1 + (4 * (j + l1))] = zero;\n  exyz[2 + (4 * (j + l1))] = zero;\n  bxyz[4 * ((j + k1) + l1)] = zero;\n  bxyz[1 + (4 * ((j + k1) + l1))] = zero;\n  bxyz[2 + (4 * ((j + k1) + l1))] = zero;\n  exyz[4 * ((j + k1) + l1)] = zero;\n  exyz[1 + (4 * ((j + k1) + l1))] = zero;\n  exyz[2 + (4 * ((j + k1) + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/57"}
{"code": "for (i = 0; i < s->N; i++)\n{\n  const Point xi = s->positions[i];\n  Point *ai = &accelerations[i];\n  ai->x = 0;\n  ai->y = 0;\n  ai->z = 0;\n  for (j = 0; j < s->N; j++)\n  {\n    const Point xj = s->positions[j];\n    Point diff;\n    if (i == j)\n    {\n      continue;\n    }\n\n    diff.x = xj.x - xi.x;\n    diff.y = xj.y - xi.y;\n    diff.z = xj.z - xi.z;\n    const double dist = sqrt((pow(diff.x, 2) + pow(diff.y, 2)) + pow(diff.z, 2));\n    const double factor = s->masses[j] / pow(dist, 3);\n    ai->x += diff.x * factor;\n    ai->y += diff.y * factor;\n    ai->z += diff.z * factor;\n  }\n\n}\n\n", "pragma": "omp for schedule(guided,2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vahidkianfar/N-body_simulation-Parallel-Programming-/N-body simulation/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int m = 0; m < 4; ++m)\n  {\n    mean[i].elements[m] = tep[i].elements[m] / (count1[i] * 100000);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/9"}
{"code": "for (int i = 0; i < N; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/xteam-red-1/xteam_red_1/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  val = val * (i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/1/MacLaurin/main/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float Fx = 0.0f;\n  float Fy = 0.0f;\n  float Fz = 0.0f;\n  for (int j = 0; j < n; j++)\n  {\n    const float dx = p[j].x - p[i].x;\n    const float dy = p[j].y - p[i].y;\n    const float dz = p[j].z - p[i].z;\n    const float dist_sqr = (((dx * dx) + (dy * dy)) + (dz * dz)) + softening;\n    const float inv_dist = m / sqrtf(dist_sqr);\n    const float inv_dist3 = (inv_dist * inv_dist) * inv_dist;\n    Fx += dx * inv_dist3;\n    Fy += dy * inv_dist3;\n    Fz += dz * inv_dist3;\n  }\n\n  p[i].vx += t_step * Fx;\n  p[i].vy += t_step * Fy;\n  p[i].vz += t_step * Fz;\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jackspyder/CPS_Coursework2/Threaded_CPU_Nbody/Threaded/1"}
{"code": "for (int j = start; j <= (end - 1); j++)\n{\n  if (array[j] <= t)\n  {\n    i++;\n    change(&array[i], &array[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/full_assignment/3"}
{"code": "for (int i = 0; i < NUM_OF_TASKS; i++)\n{\n  if (min_elem_in_task[i] < min)\n  {\n    min = min_elem_in_task[i];\n    min_row = min_row_in_task[i];\n    min_col = min_col_in_task[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalgoyall/ParallelMatrixMult/Competition/main/4"}
{"code": "for (int i = 0; i < nt; i++)\n{\n  for (int j = 0; j < nt; j++)\n  {\n    assert(Ah[i][j] != 0);\n    free(Ah[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-1/cholesky-for-opt/solution/cholesky/12"}
{"code": "for (k = 0; k < matA.c; k++)\n{\n  for (i = 0; i < matA.l; i++)\n  {\n    for (j = 0; j < matB.c; j++)\n    {\n      matR.mat[i][j] += matA.mat[i][k] * matB.mat[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/mult_matriz/main/0"}
{"code": "for (int i = 0; i < IT_END; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rutgers-apl/omp-racer/tests/microbenchmarks/contention_test/test_1/0"}
{"code": "for (i = 0; i < row; i++)\n{\n  output->content[i] = (unsigned char *) malloc(col * (sizeof(unsigned char)));\n  assert(output->content[i] != 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/histogram/histo_atomic/3"}
{"code": "for (i = 0; i <= (public.in_mod_elem - 1); i += 1)\n{\n  in_final_sum = in_final_sum + d_in[i];\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:in_final_sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  graph->traverseSequential();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/2"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  struct point *p = &dataset[n];\n  int k = p->cluster;\n  sum_of_x_per_cluster[k] += p->x;\n  sum_of_y_per_cluster[k] += p->y;\n  num_points_in_cluster[k]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/3"}
{"code": "for (i = 1; i <= nodesCount; ++i)\n{\n  if (distance[i][k] != NOT_CONNECTED)\n  {\n    for (j = 1; j <= nodesCount; ++j)\n    {\n      if ((distance[k][j] != NOT_CONNECTED) && ((distance[i][j] == NOT_CONNECTED) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n      {\n        distance[i][j] = distance[i][k] + distance[k][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp for private(j) schedule(dynamic) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victorskl/openmp-graph-diameter/diameter/1"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  flux[i][j][k][0] = u[i][j][k][2];\n  u31 = u[i][j][k][2] / u[i][j][k][0];\n  q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n  flux[i][j][k][1] = u[i][j][k][1] * u31;\n  flux[i][j][k][2] = (u[i][j][k][2] * u31) + (0.40e+00 * (u[i][j][k][4] - q));\n  flux[i][j][k][3] = u[i][j][k][3] * u31;\n  flux[i][j][k][4] = ((1.40e+00 * u[i][j][k][4]) - (0.40e+00 * q)) * u31;\n}\n\n", "pragma": "omp parallel for private (q,u31,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/102"}
{"code": "for (int i = 0; i <= (no_of_nodes - 1); i += 1)\n{\n  h_cost[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/bfs/bfs/2"}
{"code": "for (i = 0; i < numCities; i++)\n{\n  (localPopulation + (numCities * populationStartIndex))[i] = tempTours[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n3nash/Parallel-travellingsalesman/IndMPINode/3"}
{"code": "for (i_imopVar150 = 0; i_imopVar150 < grid_points[0]; i_imopVar150++)\n{\n  for (j_imopVar151 = 0; j_imopVar151 < grid_points[1]; j_imopVar151++)\n  {\n    for (k_imopVar152 = 0; k_imopVar152 < grid_points[2]; k_imopVar152++)\n    {\n      for (m_imopVar153 = 0; m_imopVar153 < 5; m_imopVar153++)\n      {\n        for (n_imopVar154 = 0; n_imopVar154 < 5; n_imopVar154++)\n        {\n          lhs[i_imopVar150][j_imopVar151][k_imopVar152][0][m_imopVar153][n_imopVar154] = 0.0;\n          lhs[i_imopVar150][j_imopVar151][k_imopVar152][1][m_imopVar153][n_imopVar154] = 0.0;\n          lhs[i_imopVar150][j_imopVar151][k_imopVar152][2][m_imopVar153][n_imopVar154] = 0.0;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/0"}
{"code": "for (int y = 0; y < height; y++)\n{\n  float scaled_x = (((1.f - (-2.5f)) / width) * x) - 2.5f;\n  float scaled_y = (((1.f - (-1.f)) / height) * y) - 1.f;\n  float real = 0.f;\n  float imaginary = 0.f;\n  int iteration = 0;\n  while ((((real * real) + (imaginary * imaginary)) <= (2 * 2)) && (iteration <= max_iteration))\n  {\n    float xtemp = ((real * real) - (imaginary * imaginary)) + scaled_x;\n    imaginary = ((2 * real) * imaginary) + scaled_y;\n    real = xtemp;\n    iteration += 1;\n  }\n\n  pixels->data[(y * pixels->rows) + x] = iteration;\n}\n\n", "pragma": "omp for schedule(dynamic, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jackfine0062/mandelbrotHPC/mandelbrot_openmp/1"}
{"code": "for (int i = 0; i < n; i++)\n  arr_host[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/alloc/main/0"}
{"code": "for (j = jbeg; j <= jfin; j++)\n{\n  jglob = j;\n  for (k = ki1; k <= ki2; k++)\n  {\n    phi2[j][k] = 0.40e+00 * (u[ifin][j][k][4] - ((0.50 * (((u[ifin][j][k][1] * u[ifin][j][k][1]) + (u[ifin][j][k][2] * u[ifin][j][k][2])) + (u[ifin][j][k][3] * u[ifin][j][k][3]))) / u[ifin][j][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/18"}
{"code": "for (unsigned int i = 0; i < NodeIds.size(); i++)\n{\n  iterator it = root_model_part->Nodes().find(NodeIds[i]);\n  if (it != root_model_part->NodesEnd())\n    aux.push_back(*it.base());\n  else\n    ((KRATOS_ERROR << \"while adding nodes to submodelpart, the node with Id \") << NodeIds[i]) << \" does not exist in the root model part\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/sources/model_part/0"}
{"code": "for (int i = 1; i < N; ++i)\n{\n  for (int j = 1; (j < N) && (result == 0); ++j)\n  {\n    for (int k = 1; k < N; ++k)\n    {\n      if (((i * i) == ((k * k) + (j * j))) && (((i + k) + j) == N))\n      {\n        result = (i * j) * k;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cyrillwork/EulerProject/tasks/task9/0"}
{"code": "for (i = 0; i < tlines; ++i)\n{\n  for (j = 0; j < trows; ++j)\n  {\n    if (world[(i * trows) + j] == 1)\n    {\n      attrset(COLOR_PAIR(2) | WA_BOLD);\n      mvaddch(i, j, '@');\n    }\n\n    if (world[(i * trows) + j] == 0)\n    {\n      attrset(COLOR_PAIR(1) | WA_NORMAL);\n      mvaddch(i, j, ' ');\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/batmac/conway-ncurses-openmp/nlife/4"}
{"code": "for (long int i = 0; i < 10000000000; i++)\n  i = i + 1;\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nirjhar323/Parallel-Programming/parallel/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    res[i][j] = 0;\n    for (k = 0; k < SIZE; k++)\n    {\n      res[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(a,b) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/matrix-multiplication/2"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->AssignToFlock(omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (mask1[index1][i] && mask2[index2][i])\n  {\n    double term1 = data1[index1][i];\n    double term2 = data2[index2][i];\n    double w = weight[i];\n    sum1 += w * term1;\n    sum2 += w * term2;\n    result += (w * term1) * term2;\n    denom1 += (w * term1) * term1;\n    denom2 += (w * term2) * term2;\n    tweight += w;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/37"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n  mat[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW4/det/4"}
{"code": "for (int w = 0; w < previousLayer->numberOfNodes; ++w)\n{\n  temp += previousLayer->nodes[w].output * node->weights[w];\n}\n\n", "pragma": "omp parallel for reduction(+: temp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/2"}
{"code": "for (i = 0; i < 16; ++i)\n  for (int j = 0; j < 16; ++j)\n{\n  for (int k = 0; k < 16; ++k)\n    i += j;\n\n}\n\n\n", "pragma": "omp target teams distribute parallel for collapse(-5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_teams_distribute_parallel_for_misc_messages/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    Q[j + (n * (i + (m * 0)))] = 4.0;\n    Q[j + (n * (i + (m * 1)))] = 0.0;\n    Q[j + (n * (i + (m * 2)))] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eduardlopez/swallow-water-simulation-parallel-multiprocessing/swater2D-omp/11"}
{"code": "for (int i = start1; i < (start1 + pointsPerProcess); i++)\n{\n  int thread = omp_get_thread_num();\n  for (int j = start2; j < (start2 + pointsPerProcess); j++)\n  {\n    calcForces(i, j, j - start2, thread);\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic, block) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Garrus007/GravSim2/MPIGrav/Simulator/MpiGravSim/7"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  iglob = i;\n  for (j = jst; j <= jend; j++)\n  {\n    jglob = j;\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      exact(iglob, jglob, k, u000ijk);\n      for (m = 0; m < 5; m++)\n      {\n        tmp = u000ijk[m] - u[i][j][k][m];\n        errnm[m] = errnm[m] + (tmp * tmp);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/30"}
{"code": "for (unsigned i = 0, e = Node->getNumOutputs(); i != e; ++i)\n{\n  if (i != 0)\n    OS << \", \";\n\n  if (!Node->getOutputName(i).empty())\n  {\n    OS << '[';\n    OS << Node->getOutputName(i);\n    OS << \"] \";\n  }\n\n  VisitStringLiteral(Node->getOutputConstraintLiteral(i));\n  OS << \" (\";\n  Visit(Node->getOutputExpr(i));\n  OS << \")\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/lib/AST/StmtPrinter/0"}
{"code": "for (i = 0; i < num_hilos; i++)\n  if (registros[i].valor > maximo)\n{\n  maximo = registros[i].valor;\n  registros[num_hilos].valor = maximo;\n  registros[num_hilos].x = registros[i].x;\n  registros[num_hilos].y = registros[i].y;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UVA-Gonzalez-Pardo/parallel-computing/practica-1-openmp/antenas4.0/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/98"}
{"code": "for (int32_t v_can = 1; v_can < D_can_height; v_can++)\n  for (int32_t u_can = 1; u_can < D_can_width; u_can++)\n  if ((*(D_can + getAddressOffsetImage(u_can, v_can, D_can_width))) >= 0)\n  partial_p_support[tid].push_back(support_pt(u_can * D_candidate_stepsize, v_can * D_candidate_stepsize, *(D_can + getAddressOffsetImage(u_can, v_can, D_can_width))));\n\n\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/9"}
{"code": "for (int i = 0; i < node->data.size(); i++)\n{\n  double dist = getDistance(t, node->data.at(i), D);\n  if (pq.size() == k)\n  {\n    if (dist < pq.top().second)\n    {\n      pq.pop();\n      pq.emplace(make_pair(node->data.at(i)->idx, dist));\n    }\n\n  }\n  else\n    pq.emplace(make_pair(node->data.at(i)->idx, dist));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/13"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  for (j = 1; j < (cols - 1); j++)\n  {\n    sum = 0;\n    for (k = -1; k < 2; k++)\n    {\n      for (m = -1; m < 2; m++)\n        sum = sum + (InputImage[i + k][j + m] * Kernel[k + 1][m + 1]);\n\n      OuputImage[i][j] = sum;\n    }\n\n    printf(\" \\n Thread %d has i = %d and j= %d for Output Pixel[i][j] = %d \\n\", omp_get_thread_num(), i, j, OuputImage[i][j]);\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nawalmunif/Kernel-Image-Processing-using-OpenMP/ConsoleApplication2/0"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  grid[i][j] = inf;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dcarvalho21/Algoritmo-de-Lee---Paralelo/rotpar/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Column %u : %u \\n\", i, csum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab4-Matrix_Sums/rowsum/4"}
{"code": "for (int x = x_m; x < x_M; x += 1)\n{\n  for (int y = y_m; y < y_M; y += 1)\n  {\n    u[t1][x][y] = u[t0][x][y] + 1;\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(2) firstprivate(t0, t1) shared(u, x_m, x_M, y_m, y_M, size_u) default(none)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/time_marching/0"}
{"code": "for (int i = 0; i < ((height * width) * 3); i += 3)\n{\n  thread_freq_r[pic[i]]++;\n  thread_freq_g[pic[i + 1]]++;\n  thread_freq_b[pic[i + 2]]++;\n}\n\n", "pragma": "            #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GermanRandle/contrast-openmp/image-processor/main/6"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  tmpPosition[i].x = satellites[i].position.x;\n  tmpPosition[i].y = satellites[i].position.y;\n  tmpVelocity[i].x = satellites[i].velocity.x;\n  tmpVelocity[i].y = satellites[i].velocity.y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheDK0309/Parallel_computing/Part1/parallel/1"}
{"code": "for (int i = 0; i < m->height; i++)\n{\n  for (int y = 0; y < m->width; y++)\n  {\n    printf(\"%d \", getValue(m, i, y));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aurelienspnll/matrix-mult-ring-rotation/matrix-mult-ring-rotation/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    int comp_w = 0;\n    for (k = 0; k < size; k++)\n    {\n      comp_w += M[i][k] * N[k][j];\n    }\n\n    W[i][j] = comp_w;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i), shared(W)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmotel/zjp-labs/lab6/zad2/main/3"}
{"code": "for (int p = 0; p < (NUMPCLS * 8); p++)\n{\n  p2[p] = p1[p];\n}\n\n", "pragma": "  #pragma omp for schedule(static,NUMPCLS*4) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testv2/6"}
{"code": "for (i = kypi - 1; i < kypt; i++)\n{\n  joff = (2 * nxvh) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t1 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < 2; k++)\n    {\n      t = conjf(f[(k + (2 * (nxh - j))) + joff]);\n      s = f[(k + (2 * j)) + joff] + t;\n      t = (f[(k + (2 * j)) + joff] - t) * t1;\n      f[(k + (2 * j)) + joff] = s + t;\n      f[(k + (2 * (nxh - j))) + joff] = conjf(s - t);\n    }\n\n  }\n\n  for (k = 0; k < 2; k++)\n  {\n    f[k + joff] = (crealf(f[k + joff]) + cimagf(f[k + joff])) + ((crealf(f[k + joff]) - cimagf(f[k + joff])) * _Complex_I);\n    if (nxhh > 0)\n      f[(k + (2 * nxhh)) + joff] = 2.0 * conjf(f[(k + (2 * nxhh)) + joff]);\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(2 * j1) + joff];\n      t2 = f[(1 + (2 * j1)) + joff];\n      f[(2 * j1) + joff] = f[(2 * j) + joff];\n      f[(1 + (2 * j1)) + joff] = f[(1 + (2 * j)) + joff];\n      f[(2 * j) + joff] = t1;\n      f[(1 + (2 * j)) + joff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indx1; m++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = conjf(sct[kmr * j]);\n        t1 = s * f[(2 * j2) + joff];\n        t2 = s * f[(1 + (2 * j2)) + joff];\n        f[(2 * j2) + joff] = f[(2 * j1) + joff] - t1;\n        f[(1 + (2 * j2)) + joff] = f[(1 + (2 * j1)) + joff] - t2;\n        f[(2 * j1) + joff] += t1;\n        f[(1 + (2 * j1)) + joff] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 * j) + joff]);\n    f[(2 * j) + joff] = crealf(f[(2 * j) + joff]) + (crealf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n    f[(1 + (2 * j)) + joff] = at1 + (cimagf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,joff,at1,s,t,t1,t2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mppic2/mppush2/4"}
{"code": "for (int p1 = 0; p1 < divider; p1++)\n  for (int y1 = 0; y1 < divider; y1++)\n  for (int x1 = 0; x1 < divider; x1++)\n{\n  if (x1 == dx)\n    break;\n\n  sum += *(((matrixdata + ((x * divider) + x1)) + (((y * divider) + y1) * DtCol)) + ((((p * divider) + p1) * DtCol) * DtRow));\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/24"}
{"code": "for (i = 0; i < d.dim2(); ++i)\n{\n  mean = 0;\n  for (j = 0; j < d.dim1(); ++j)\n  {\n    mean += d[j][i];\n  }\n\n  mean /= d.dim1();\n  means[i] = mean;\n  for (j = 0; j < d.dim1(); ++j)\n  {\n    d[j][i] -= mean;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leoaugustoam/PCA-Parallel-OpenMP/pca/0"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd3 * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[(3 * i) + i1];\n        t2 = f[(1 + (3 * i)) + i1];\n        t3 = f[(2 + (3 * i)) + i1];\n        f[(3 * i) + i1] = f[(3 * i) + i0];\n        f[(1 + (3 * i)) + i1] = f[(1 + (3 * i)) + i0];\n        f[(2 + (3 * i)) + i1] = f[(2 + (3 * i)) + i0];\n        f[(3 * i) + i0] = t1;\n        f[(1 + (3 * i)) + i0] = t2;\n        f[(2 + (3 * i)) + i0] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = conjf(sct[kmr * j]);\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[(3 * i) + i1];\n          t3 = t1 * f[(1 + (3 * i)) + i1];\n          t4 = t1 * f[(2 + (3 * i)) + i1];\n          f[(3 * i) + i1] = f[(3 * i) + i0] - t2;\n          f[(1 + (3 * i)) + i1] = f[(1 + (3 * i)) + i0] - t3;\n          f[(2 + (3 * i)) + i1] = f[(2 + (3 * i)) + i0] - t4;\n          f[(3 * i) + i0] += t2;\n          f[(1 + (3 * i)) + i0] += t3;\n          f[(2 + (3 * i)) + i0] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2,t3, t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/32"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d did row %d\\n\", tid, i);\n  for (j = 0; j <= i; j++)\n    c[i] += a[i][j] * b[j];\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amir-saadat/Scientific-computing/lab7/matvec_part6/0"}
{"code": "for (i = (500 / 250) - 1; i < 500; i += 500 / 250)\n{\n  init(i, vector, selected_cpu);\n  k_nearest_cpu(i, vector, selected_cpu);\n  order_points(i, vector, selected_cpu);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/other-nearest/src/other-nearest_gpu/6"}
{"code": "for (int i = 0; i < imgSize; ++i)\n  for (int j = 0; j < imgSize; ++j)\n  img[(i * imgSize) + j] = i % 256;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/histograma/src/main/0"}
{"code": "for (int i = n - index; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    a[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/cpu_parallel_convolution/3"}
{"code": "for (int v = 0; v < g->n; v++)\n{\n  int cap = residualFlow[IDX(s, v, g->n)];\n  if ((cap > 0) && (s != v))\n  {\n    residualFlow[IDX(s, v, g->n)] = 0;\n    residualFlow[IDX(v, s, g->n)] += cap;\n    netFlowOutS += cap;\n    excessFlow[v] = cap;\n    if (v == t)\n    {\n      netFlowInT += cap;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:netFlowOutS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/7"}
{"code": "for (mp = cluster_item.begin(); mp != cluster_item.end(); mp++)\n{\n  row = Calculate_Mean(mp->second);\n  means[mp->first] = row;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roy-1996/k-means-clustering/kmeans-parallel/4"}
{"code": "for (i = 0; i <= (64 + 1); i++)\n{\n  for (k = 0; k <= (64 + 1); k++)\n  {\n    phi1[i][k] = 0.0;\n    phi2[i][k] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/13"}
{"code": "for (int i = 1; i < 20; i++)\n  for (int j = 1; j < 20; j++)\n  A[i][j] = A[i - 1][j - 1];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/1.race1/0"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    u[i][j] = u_new[i][j];\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Linear Convection/2-D_Linear_Convection/main/2"}
{"code": "for (int x = 0; x < rowA; x += 8)\n{\n  for (int y = 0; y < colB; y += 8)\n  {\n    _mm_prefetch((matB + (((y + 16) + 0) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 1) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 2) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 3) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 4) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 5) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 6) * rowA)) + x, _MM_HINT_T0);\n    _mm_prefetch((matB + (((y + 16) + 7) * rowA)) + x, _MM_HINT_T0);\n    I0 = _mm256_loadu_si256((int *) ((matB + ((y + 0) * rowA)) + x));\n    I1 = _mm256_loadu_si256((int *) ((matB + ((y + 1) * rowA)) + x));\n    I2 = _mm256_loadu_si256((int *) ((matB + ((y + 2) * rowA)) + x));\n    I3 = _mm256_loadu_si256((int *) ((matB + ((y + 3) * rowA)) + x));\n    I4 = _mm256_loadu_si256((int *) ((matB + ((y + 4) * rowA)) + x));\n    I5 = _mm256_loadu_si256((int *) ((matB + ((y + 5) * rowA)) + x));\n    I6 = _mm256_loadu_si256((int *) ((matB + ((y + 6) * rowA)) + x));\n    I7 = _mm256_loadu_si256((int *) ((matB + ((y + 7) * rowA)) + x));\n    T0 = _mm256_unpacklo_epi32(I0, I1);\n    T1 = _mm256_unpackhi_epi32(I0, I1);\n    T2 = _mm256_unpacklo_epi32(I2, I3);\n    T3 = _mm256_unpackhi_epi32(I2, I3);\n    T4 = _mm256_unpacklo_epi32(I4, I5);\n    T5 = _mm256_unpackhi_epi32(I4, I5);\n    T6 = _mm256_unpacklo_epi32(I6, I7);\n    T7 = _mm256_unpackhi_epi32(I6, I7);\n    I0 = _mm256_unpacklo_epi64(T0, T2);\n    I1 = _mm256_unpackhi_epi64(T0, T2);\n    I2 = _mm256_unpacklo_epi64(T1, T3);\n    I3 = _mm256_unpackhi_epi64(T1, T3);\n    I4 = _mm256_unpacklo_epi64(T4, T6);\n    I5 = _mm256_unpackhi_epi64(T4, T6);\n    I6 = _mm256_unpacklo_epi64(T5, T7);\n    I7 = _mm256_unpackhi_epi64(T5, T7);\n    T0 = _mm256_permute2x128_si256(I0, I4, 0x20);\n    T1 = _mm256_permute2x128_si256(I1, I5, 0x20);\n    T2 = _mm256_permute2x128_si256(I2, I6, 0x20);\n    T3 = _mm256_permute2x128_si256(I3, I7, 0x20);\n    T4 = _mm256_permute2x128_si256(I0, I4, 0x31);\n    T5 = _mm256_permute2x128_si256(I1, I5, 0x31);\n    T6 = _mm256_permute2x128_si256(I2, I6, 0x31);\n    T7 = _mm256_permute2x128_si256(I3, I7, 0x31);\n    _mm256_storeu_si256((int *) ((matD + ((x + 0) * colB)) + y), T0);\n    _mm256_storeu_si256((int *) ((matD + ((x + 1) * colB)) + y), T1);\n    _mm256_storeu_si256((int *) ((matD + ((x + 2) * colB)) + y), T2);\n    _mm256_storeu_si256((int *) ((matD + ((x + 3) * colB)) + y), T3);\n    _mm256_storeu_si256((int *) ((matD + ((x + 4) * colB)) + y), T4);\n    _mm256_storeu_si256((int *) ((matD + ((x + 5) * colB)) + y), T5);\n    _mm256_storeu_si256((int *) ((matD + ((x + 6) * colB)) + y), T6);\n    _mm256_storeu_si256((int *) ((matD + ((x + 7) * colB)) + y), T7);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/7"}
{"code": "for (unsigned int j = 0; j < vectorLength; j++)\n{\n  dest[j] = calculateFractalOpenMP64(cReal[j], cImaginary[j], maxIteration);\n}\n\n", "pragma": "    #pragma omp parallel for default(none) num_threads(4) shared(cReal, cImaginary, maxIteration, vectorLength, dest) schedule(nonmonotonic:dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/eragp/mandelbrot/backend/src/mandelbrot/MandelbrotOpenMP64/0"}
{"code": "for (i = l1; i < l2; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    buffer[3 * (((i - l1) * width) + j)] = aux[i][j].r;\n    buffer[(3 * (((i - l1) * width) + j)) + 1] = aux[i][j].g;\n    buffer[(3 * (((i - l1) * width) + j)) + 2] = aux[i][j].b;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/10"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    const double smvp = SMVP(sd);\n    r[index] -= smvp;\n    u[index] += sd[index];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_ppcg_kernel/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    A[i][j] = rand();\n    B[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/OpenMP/matrixsyn/0"}
{"code": "for (i = 0; i < N; i++)\n  b[i] = 1.0e0 + i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_array/reduction_array/1"}
{"code": "for (unsigned int i = 0; i < 3; i++)\n  U[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/77"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  for (j = 0; j < ny; j++)\n  {\n    jglob = j;\n    double *_imopVarPre239;\n    _imopVarPre239 = &u[i][j][0][0];\n    exact(iglob, jglob, 0, _imopVarPre239);\n    double *_imopVarPre242;\n    int _imopVarPre243;\n    _imopVarPre242 = &u[i][j][nz - 1][0];\n    _imopVarPre243 = nz - 1;\n    exact(iglob, jglob, _imopVarPre243, _imopVarPre242);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/0"}
{"code": "for (unsigned int i = 0; i < number_of_voxels(); i++)\n{\n  bulk_uptake_rate_function(this, i, &uptake_rates[i]);\n  bulk_supply_rate_function(this, i, &supply_rates[i]);\n  bulk_supply_target_densities_function(this, i, &supply_target_densities_times_supply_rates[i]);\n  supply_target_densities_times_supply_rates[i] *= supply_rates[i];\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_microenvironment/12"}
{"code": "for (j = 0; j < rows; j++)\n{\n  if (i != j)\n  {\n    const elem_t factor = a[(j * cols) + i];\n    for (k = 0; k < cols; k++)\n    {\n      a[(j * cols) + k] -= a[(i * cols) + k] * factor;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/Sci Lab Code in C/3.Inverse_openMP/0"}
{"code": "for (long i = 0; i < 10; i++)\n  result++;\n\n", "pragma": "omp for schedule(dynamic,1) reduction(+: result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dave96/libminiomp/test/tworkshare/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    res[i] += A[i][j] * b[j];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i, j) shared(res, n, A, b) default(none)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/Instrumental/2"}
{"code": "for (int i = 10; i > 1; i--)\n{\n  a += 1;\n}\n\n", "pragma": "  #pragma omp target parallel for if(target: 0) linear(k : 3) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/1"}
{"code": "for (y = 0; y < (1 * omp_para); y++)\n  for (x = 0; x < SIMD_COEF_32; x++)\n{\n  if (((MD5_word *) binary)[0] == ((MD5_word *) sout)[x + ((y * SIMD_COEF_32) * 4)])\n    return 1;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/MD5_fmt/2"}
{"code": "for (int i = 1; i < graph->num_nodes; i++)\n{\n  sol->distances[i] = NOT_VISITED_MARKER;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static,32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/bfs/bfs/3"}
{"code": "for (int i = 0; i < (*w); i++)\n{\n  (*dgauss_Kernel)[i] = ((-1) * (i - pw)) * exp((((-1) * (i - pw)) * (i - pw)) / ((2 * sigma) * sigma));\n  sum -= i * (*dgauss_Kernel)[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcoisgood/High-Performance-Computing/3.Canny-Edge-Detector with MPI&openMP+MPI)/openMP+MPI/canny_edge_Mix/4"}
{"code": "for (int i = 0; i < (NX + 2); i++)\n{\n  for (int j = 0; j < (NY + 2); j++)\n  {\n    fprintf(final_file, \"%g %g %g\\n\", x_axis[i], y_axis[j], u_val[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nmac-dev/parallel-2D-advection/src/advection2D/8"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    double *_imopVarPre344;\n    double *_imopVarPre345;\n    double (*_imopVarPre346)[5];\n    _imopVarPre344 = rhs[i][j][k];\n    _imopVarPre345 = rhs[i - 1][j][k];\n    _imopVarPre346 = lhs[i][j][k][0];\n    matvec_sub(_imopVarPre346, _imopVarPre345, _imopVarPre344);\n    double (*_imopVarPre350)[5];\n    double (*_imopVarPre351)[5];\n    double (*_imopVarPre352)[5];\n    _imopVarPre350 = lhs[i][j][k][1];\n    _imopVarPre351 = lhs[i - 1][j][k][2];\n    _imopVarPre352 = lhs[i][j][k][0];\n    matmul_sub(_imopVarPre352, _imopVarPre351, _imopVarPre350);\n    double *_imopVarPre356;\n    double (*_imopVarPre357)[5];\n    double (*_imopVarPre358)[5];\n    _imopVarPre356 = rhs[i][j][k];\n    _imopVarPre357 = lhs[i][j][k][2];\n    _imopVarPre358 = lhs[i][j][k][1];\n    binvcrhs(_imopVarPre358, _imopVarPre357, _imopVarPre356);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/78"}
{"code": "for (iteration = 1; iteration <= 10; iteration++)\n{\n  if ('S' != 'S')\n    printf(\"        %d\\n\", iteration);\n\n  rank(iteration);\n  nthreads = omp_get_num_threads();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/IS/is/0"}
{"code": "for (int i = sx; i <= ex; i++)\n  for (int j = sy; j <= ey; j++)\n  for (int k = sz; k <= ez; k++)\n{\n  if (onConstEdge(i, j, k))\n    get(next, i, j, k) = 0;\n  else\n    get(next, i, j, k) = get(curr, i, j, k) + (delta(i, j, k, curr) / 2);\n\n}\n\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haalon-old/parallel2020/block/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  double sumq = 0.0;\n  #pragma acc loop reduction(+:sumq)\n  for (k = 0; k < np; k++)\n    sumq = sumq + qq[k][i];\n\n  q[i] = sumq;\n  gc += sumq;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/EP/ep/5"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  check_rows_fn(&i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidatorPthread/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n    b[i][j] = 0.5;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB031-truedepfirstdimension-orig-yes/0"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    soundspeed[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = soundspeed[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/26"}
{"code": "for (j = 0; j < n; j++)\n{\n  if (kc1[j] == kc[j])\n  {\n    l++;\n  }\n\n}\n\n", "pragma": "        #pragma parallel omp for shared(j,l,kc,kc1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/kMeans/2"}
{"code": "for (int j = 0; j < 2; j++)\n{\n  randNeighbour(curSites[j], newSite[j]);\n  int *beginSite = curSites[j];\n  if (((((newSite[j][X] + nRow) - 1) % nRow) == curSites[j][X]) || (((newSite[j][Y] + 1) % nCol) == curSites[j][Y]))\n  {\n    beginSite = newSite[j];\n  }\n\n  int beginPos = ((beginSite[X] * nCol) + beginSite[Y]) * 2;\n  int linkID = beginPos + Y;\n  if (((((newSite[j][Y] + nRow) - 1) % nRow) == curSites[j][Y]) || (((newSite[j][Y] + 1) % nCol) == curSites[j][Y]))\n  {\n    linkID = beginPos + X;\n  }\n\n  omp_set_lock(&Locks[linkID]);\n  if (isAccept(linkID))\n  {\n    if (!Links[linkID])\n      Links[linkID] = true;\n    else\n      Links[linkID] = false;\n\n    curSites[j][X] = newSite[j][X];\n    curSites[j][Y] = newSite[j][Y];\n  }\n\n  omp_unset_lock(&Locks[linkID]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elena1905/ParallelIsingModel/src/worm/two_threads/Worm/4"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < dim2; k++)\n    {\n      double diff = fabs(control[i][j][k] - result[i][j][k]);\n      assert(diff >= 0.0);\n      sum_abs_diff = sum_abs_diff + diff;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cooneyro/concurrent-systems/Assignment1/5"}
{"code": "for (i = 1; i <= (1400 + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/CG/cg_single/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  fscanf(fptr, \"%d\", &arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajjadaziz/OpenMP-Pthreads-Serial-and-Parallel-Execution-of-Searching-Algorithms-in-C/Source Code/project/1"}
{"code": "for (i = 0; i <= 10; i++)\n{\n  x = i;\n  printf(\"Thread number: %d     x: %d\\n\", omp_get_thread_num(), x);\n}\n\n", "pragma": "#pragma omp parallel for lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iuliacornea/L3-openmp/last_private/0"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < 512; j++)\n{\n  ac = 0;\n  for (k = 0; k < 512; k++)\n    ac += sqrt(pow(A[i][k] - W[k], 2) * pow(B[k][j] - W[k], 2));\n\n  C[i][j] = ac;\n}\n\n\n", "pragma": "omp parallel for schedule (static, chunk) num_threads(threads_nro) shared(A,B,chunk) private(ac,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maturocha/multiplication-matrix/src/openmp_multiplication/0"}
{"code": "for (c3 = (0 > (((-N) + c1) + 1)) ? (0) : (((-N) + c1) + 1); c3 <= ((c1 - 1) / 129); c3 += 1)\n  for (c4 = 0; c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c10 = (0 > (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1)) ? (0) : (((((-c1) + (64 * c3)) - c9) + (((((N + c1) + c3) + c9) + 1) / 2)) + 1); c10 <= 1; c10 += 1)\n    {\n      if (c10 == 1)\n      {\n        M[((N - c1) + c3) - 1][c9] = (M[((N - c1) + c3) - 1][c9] > (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1])) ? (M[((N - c1) + c3) - 1][c9]) : (M[((N - c1) + c3) - 1][c9 - 1] + Puu[c9 - 1]);\n      }\n      else\n      {\n        for (c11 = (128 * c3) + 2; c11 <= ((((-N) + c1) - c3) + c9); c11 += 1)\n          M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n      }\n\n    }\n\n\n  }\n  else\n  {\n    for (c5 = 0; c5 <= (8 * c3); c5 += 1)\n      for (c9 = (N - c1) + (129 * c3); c9 <= (((N - 1) < (((N - c1) + (129 * c3)) + 127)) ? (N - 1) : (((N - c1) + (129 * c3)) + 127)); c9 += 1)\n      for (c11 = 16 * c5; c11 <= ((((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) < ((((-N) + c1) - c3) + c9)) ? ((((128 * c3) + 1) < ((16 * c5) + 15)) ? ((128 * c3) + 1) : ((16 * c5) + 15)) : ((((-N) + c1) - c3) + c9)); c11 += 1)\n      M[((N - c1) + c3) - 1][c9] = ((M[((N - c1) + c3) - 1][c9] > ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) ? (M[((N - c1) + c3) - 1][c9]) : ((M[((N - c1) + c3) - 1][(c11 + (((N - c1) + c3) - 1)) - 1] + M[(c11 + (((N - c1) + c3) - 1)) + 1][c9 - 1]) + (delta * Pbp[c11 + (((N - c1) + c3) - 1)][c9]))) * paired(c11 + (((N - c1) + c3) - 1), c9 - 1);\n\n\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mea_traco/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    int temp = 0;\n    for (int k = 0; k < n; k++)\n    {\n      temp += a[(i * n) + k] * b[(k * n) + j];\n    }\n\n    res[(i * n) + j] = temp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_strassen/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d\\t\", *((squareMatrix + (n * i)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tukzGobetse/DICs-Labs/lab2/lab2opm/2"}
{"code": "for (int m = i; m < j; m++)\n{\n  for (int n = m; n <= j; n++)\n  {\n    if (a[n] < a[m])\n    {\n      temp = a[m];\n      a[m] = a[n];\n      a[n] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/parallel_sorts/bsort/1"}
{"code": "for (i = i_inicial, j = j_inicial; (i >= 0) && (j < yblocks); i--, j++)\n{\n  indi[size] = i;\n  indj[size] = j;\n  size++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/filtro-bloques/1"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    numoutside += testpoint(c);\n  }\n\n}\n\n", "pragma": "omp for collapse(2) reduction(+:numoutside)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adaickalavan/OpenMP-Tim-Mattson/apps/mandel/0"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  linear_result = linear_operation(w, h, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sotheanithsok/CECS-574-Collection/A-2-OpenMP/main/2"}
{"code": "for (int i = 0; i < tam; i++)\n{\n  for (int j = 0; j < tam; j++)\n  {\n    for (int k = 0; k < 3; k++)\n    {\n      imagen[k][i][j] = (i * j) % 256;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/16"}
{"code": "for (pos = myNode->count; (val < myNode->val[pos]) && (pos > 1); pos--)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Bigtable-in-C/B-tree/4"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"b[%d]=%d\\t\", i, b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica1/single/0"}
{"code": "for (i = 0; i < (N * NN); i++)\n{\n  Res[i] = -1;\n  CUs[i] = -2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/Threads1xxx/Threads1xxx/2"}
{"code": "for (size_t i = 0; i < layers; ++i)\n  AddLayer(layers_size[i] - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Networks/MLP/4"}
{"code": "for (jj = 0; jj < order; jj += block)\n{\n  for (kk = 0; kk < order; kk += block)\n  {\n    for (jg = jj, j = 0; jg < MIN(jj + block, order); j++, jg++)\n      for (kg = kk, k = 0; kg < MIN(kk + block, order); k++, kg++)\n      BB[j + ((block + 12) * k)] = B[kg + (order * jg)];\n\n\n    for (ii = 0; ii < order; ii += block)\n    {\n      for (kg = kk, k = 0; kg < MIN(kk + block, order); k++, kg++)\n        for (ig = ii, i = 0; ig < MIN(ii + block, order); i++, ig++)\n        AA[i + ((block + 12) * k)] = A[ig + (order * kg)];\n\n\n      for (jg = jj, j = 0; jg < MIN(jj + block, order); j++, jg++)\n        for (ig = ii, i = 0; ig < MIN(ii + block, order); i++, ig++)\n        CC[i + ((block + 12) * j)] = 0.0;\n\n\n      for (kg = kk, k = 0; kg < MIN(kk + block, order); k++, kg++)\n        for (jg = jj, j = 0; jg < MIN(jj + block, order); j++, jg++)\n        for (ig = ii, i = 0; ig < MIN(ii + block, order); i++, ig++)\n        CC[i + ((block + 12) * j)] += AA[i + ((block + 12) * k)] * BB[j + ((block + 12) * k)];\n\n\n\n      for (jg = jj, j = 0; jg < MIN(jj + block, order); j++, jg++)\n        for (ig = ii, i = 0; ig < MIN(ii + block, order); i++, ig++)\n        C[ig + (order * jg)] += CC[i + ((block + 12) * j)];\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/DGEMM/dgemm/0"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  int tID = omp_get_thread_num();\n  printf(\"[%d] by thread %d\\n\", i, tID);\n  Sleep(tID % 1);\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic, 1) num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture14/dynamic_scheduling/dynamic_scheduling/0"}
{"code": "for (int l = 0; l < numberOfNonZeroElements; l++)\n{\n  prediction[l] = 0;\n  delta[l] = 0;\n  for (int k = 0; k < numberOfFeatures; k++)\n  {\n    prediction[l] += L[(nonZeroUserIndexes[l] * numberOfFeatures) + k] * R[(k * numberOfItems) + nonZeroItemIndexes[l]];\n  }\n\n  delta[l] = A[(nonZeroUserIndexes[l] * numberOfItems) + nonZeroItemIndexes[l]] - prediction[l];\n}\n\n", "pragma": "        #pragma omp for private(l, k) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pedrorio/parallel_and_distributed_computing/omp/src/updateLR/1"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (k = 0; k < nz; k++)\n    {\n      flux_G[0][j][i][k] = rsd[3][k][j][i];\n      u41 = rsd[3][k][j][i] / rsd[0][k][j][i];\n      q = (0.50 * (((rsd[1][k][j][i] * rsd[1][k][j][i]) + (rsd[2][k][j][i] * rsd[2][k][j][i])) + (rsd[3][k][j][i] * rsd[3][k][j][i]))) / rsd[0][k][j][i];\n      flux_G[1][j][i][k] = rsd[1][k][j][i] * u41;\n      flux_G[2][j][i][k] = rsd[2][k][j][i] * u41;\n      flux_G[3][j][i][k] = (rsd[3][k][j][i] * u41) + (C2 * (rsd[4][k][j][i] - q));\n      flux_G[4][j][i][k] = ((C1 * rsd[4][k][j][i]) - (C2 * q)) * u41;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/16"}
{"code": "for (int jj = 0; jj < depth; ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int base = kk;\n    buffer[base + (((_chunk.y - HALO_PAD) + jj) * _chunk.x)] = buffer[base + ((((_chunk.y - HALO_PAD) - 1) - jj) * _chunk.x)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_update_halo/2"}
{"code": "for (int i = start_i; i < ((int) max_y); i++)\n{\n  for (int j = start_j; j < ((int) max_x); j++)\n  {\n    if ((*resImg)(i, j) == 0)\n    {\n      if (((i + 1) < max_y) && (copyRes(i + 1, j) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j);\n      }\n      else\n        if (((i - 1) >= fmax(min_y, 0)) && (copyRes(i - 1, j) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j);\n      }\n      else\n        if (((j + 1) < max_x) && (copyRes(i, j + 1) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i, j + 1);\n      }\n      else\n        if (((j - 1) >= fmax(min_x, 0)) && (copyRes(i, j - 1) != 0))\n      {\n        (*resImg)(i, j) = copyRes(i, j - 1);\n      }\n      else\n        if ((((i + 1) < max_y) && ((j + 1) < max_x)) && copyRes(i + 1, j + 1))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j + 1);\n      }\n      else\n        if ((((i - 1) >= fmax(min_y, 0)) && ((j + 1) < max_x)) && copyRes(i - 1, j + 1))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j + 1);\n      }\n      else\n        if ((((i + 1) < max_y) && ((j - 1) >= fmax(min_x, 0))) && copyRes(i + 1, j - 1))\n      {\n        (*resImg)(i, j) = copyRes(i + 1, j - 1);\n      }\n      else\n        if ((((i - 1) >= fmax(min_y, 0)) && ((j - 1) >= fmax(min_x, 0))) && copyRes(i - 1, j - 1))\n      {\n        (*resImg)(i, j) = copyRes(i - 1, j - 1);\n      }\n\n\n\n\n\n\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_pure_openmp/image_stitching/1"}
{"code": "for (j = 13; j >= 1; j--)\n{\n  if (size[j] == '.')\n  {\n    size[j] = ' ';\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/EP/ep/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (k = 0; k < 100; k++)\n  {\n    for (j = 0; j < 100; j++)\n      c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB060-matrixmultiply-orig-no/3"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"a[%d] = %2d\\n\", i, a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rookiehpc/rookiehpc.github.io/openmp/exercises/exercise_2/solution/1"}
{"code": "for (jj = ii; jj < (ii + params.nx); ++jj)\n{\n  if ((((!obstacles[jj]) && ((cells[jj].speeds[3] - w1) > 0.0)) && ((cells[jj].speeds[6] - w2) > 0.0)) && ((cells[jj].speeds[7] - w2) > 0.0))\n  {\n    cells[jj].speeds[1] += w1;\n    cells[jj].speeds[5] += w2;\n    cells[jj].speeds[8] += w2;\n    cells[jj].speeds[3] -= w1;\n    cells[jj].speeds[6] -= w2;\n    cells[jj].speeds[7] -= w2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/an4/HPC-OpenMP/d2q9-bgk/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/131"}
{"code": "for (i = 0; i < number_of_rows_A; i++)\n  for (j = 0; j < number_of_columns_A; j++)\n  A[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (static, block_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaarrmiinnn/parallel_matrix_multiplication/mm_regular_row/0"}
{"code": "for (int y = 0; y < height; y++)\n  png_free(png_ptr, f[y]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmaeilkeshavarz/Edge-detection-with-C-using-OpenMp/phase2/6"}
{"code": "for (i = 0, j = 0; i < (nthreads * num_iters); ++i)\n{\n  if (iters[i] != (-1))\n    final_iters[j++] = iters[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/worksharing/for/omp_for_static_large_chunk/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (Distance[i] > INFINITY)\n    Distance[i] = INFINITY;\n\n  (cout << Distance[i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IzaanSohail1999/OpenMP-ShortestPathProblem-BellmanFord/Shortest_path_problem_openmp/0"}
{"code": "for (i = 0; i < matrix_size; i++)\n{\n  for (j = 0; j < matrix_size; j++)\n  {\n    result += to_string(data[i][j]) + \", \";\n  }\n\n  result += \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nrvru/parallel-lab1/SquareMatrix/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (a[i] > pivot)\n  {\n    right[l] = a[i];\n    l++;\n  }\n\n  if (a[i] < pivot)\n  {\n    left[m] = a[i];\n    m++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/med/3"}
{"code": "for (size_t i = 0; i < 100; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d: c[%2zu] = %g\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp for schedule(dynamic, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/schedule/0"}
{"code": "for (j = 0; j < ((lastrow - firstrow) + 1); j++)\n{\n  sum = 0.0;\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    sum = sum + (a[k] * p[colidx[k]]);\n  }\n\n  q[j] = sum;\n}\n\n", "pragma": "omp parallel for private(sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tclin914/ConjugateGradient_openmp/CG_openmp/cg/0"}
{"code": "for (int i = 0; i < ((int) pJ->GetX()); i++)\n{\n  for (int j = 0; j < ((int) pJ->GetY()); j++)\n  {\n    if (((pJ->GetValue(i, j).isCond2D(CT_NODE_IS_SET_2D) && (!pJ->GetValue(i, j).isCond2D(CT_SOLID_2D))) && (pJ->GetValue(i, j).time == 0.)) && (delta > 0))\n    {\n      if (pJ->GetValue(i, j).l_min <= delta)\n        pJ->GetValue(i, j).S[i2d_RhoU] = (pJ->GetValue(i, j).S[i2d_RhoU] * pJ->GetValue(i, j).l_min) / delta;\n\n      pJ->GetValue(i, j).S[i2d_RhoV] = (pJ->GetValue(i, j).S[i2d_RhoV] * pJ->GetValue(i, j).l_min) / delta;\n      pJ->GetValue(i, j).FillNode2D(0, 1);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/12"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  communicate(pathArr, start, end);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/5"}
{"code": "for (int i = 0; i < 7; i++)\n{\n  for (int j = 0; j < 7; j++)\n  {\n    if ((i == 0) && (j == 0))\n      heat[i][j] = 1;\n    else\n      if ((i < 3) && (j < 3))\n    {\n      if ((i == 2) && (j == 2))\n      {\n        heat[i][j] = 0.75;\n      }\n      else\n        heat[i][j] = (heat[j][i] = 0.85);\n\n    }\n    else\n      if ((i < 5) && (j < 5))\n    {\n      if ((i == 4) && (j == 4))\n      {\n        heat[i][j] = 0.65;\n      }\n      else\n        heat[i][j] = (heat[j][i] = 0.75);\n\n    }\n    else\n      if ((i < 6) && (j < 6))\n    {\n      if ((i == 5) && (j == 5))\n      {\n        heat[i][j] = 0.6;\n      }\n      else\n        heat[i][j] = (heat[j][i] = 0.65);\n\n    }\n    else\n      if ((i < 7) && (j < 7))\n    {\n      if ((i == 6) && (j == 6))\n      {\n        heat[i][j] = 0;\n      }\n      else\n        heat[i][j] = (heat[j][i] = 0.6);\n\n    }\n\n\n\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alibozkurtkyrd/OpenMP-C/q4/v7/1"}
{"code": "for (k = 0; k < dims[2]; k++)\n{\n  x0 = starts[k];\n  for (j = 0; j < dims[1]; j++)\n  {\n    vranlc(2 * NX, &x0, A, (double *) (&u0[k][j][0]));\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(k,j,x0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/7"}
{"code": "for (unsigned int i = 0; i < (query_nb * k); i++)\n  dist[i] = sqrtf(dist[i]);\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/7"}
{"code": "for (unsigned r = 0; r < result.numRows(); ++r)\n{\n  for (unsigned c = 0; c < result.numCols(); ++c)\n  {\n    double sum = 0;\n    for (unsigned i = 0; i < m1.numRows(); ++i)\n    {\n      sum = sum + (m1a[(r * m1.numCols()) + i] * m2a[(i * m2.numCols()) + c]);\n    }\n\n    ra[(r * result.numCols()) + c] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hckr/matrix-multiplication/matrix_multiplication/parallel/multiply1/0"}
{"code": "for (int i = 0; i < row; i++)\n{\n  printf(\"[\");\n  for (int j = 0; j < col; j++)\n    printf(\" %d\", data[i][j]);\n\n  printf(\" ]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/zerojudge/b442/parallel/3"}
{"code": "for (int i = 0; i < SD.length_nuclide_grid; i++)\n{\n  SD.nuclide_grid[i].energy = LCG_random_double(&seed);\n  SD.nuclide_grid[i].total_xs = LCG_random_double(&seed);\n  SD.nuclide_grid[i].elastic_xs = LCG_random_double(&seed);\n  SD.nuclide_grid[i].absorbtion_xs = LCG_random_double(&seed);\n  SD.nuclide_grid[i].fission_xs = LCG_random_double(&seed);\n  SD.nuclide_grid[i].nu_fission_xs = LCG_random_double(&seed);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/xsbench-omp/GridInit/1"}
{"code": "for (unsigned int j = 1; j < (m_uNumberOfGridPoints1D - 1); ++j)\n{\n  double vecPreviousHeat[m_uNumberOfGridPoints1D];\n  vecPreviousHeat[0] = 0.0;\n  vecPreviousHeat[m_uNumberOfGridPoints1D - 1] = 0.0;\n  for (unsigned int i = 1; i < (m_uNumberOfGridPoints1D - 1); ++i)\n  {\n    vecPreviousHeat[i] = m_gridHeat[i][j] + (m_dDiffusionFactor * ((m_gridHeat[i + 1][j] - (2 * m_gridHeat[i][j])) + m_gridHeat[i - 1][j]));\n  }\n\n  solveMatrixFast(vecPreviousHeat, m_uNumberOfGridPoints1D, m_matCoefficients[2], m_matCoefficients[1], m_matCoefficients[0]);\n  for (unsigned int u = 0; u < m_uNumberOfGridPoints1D; ++u)\n  {\n    m_gridHeat[u][j] = vecPreviousHeat[u];\n  }\n\n}\n\n", "pragma": "        #pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/0"}
{"code": "for (int i = 0; i < M; ++i)\n  for (int j = 0; j < M; ++j)\n{\n  if ((((i % 2) == 0) && ((j % 2) == 0)) || (((i % 2) != 0) && ((j % 2) != 0)))\n    black += chess[i][j];\n\n  if ((((i % 2) == 0) && ((j % 2) != 0)) || (((i % 2) != 0) && ((j % 2) == 0)))\n    white += chess[i][j];\n\n}\n\n\n", "pragma": "\t\t#pragma omp for reduction(+: black) reduction(+: white)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kei91/openmp/7/1"}
{"code": "for (i = 0; i < NGRUPOS; i++)\n{\n  if (additions[i][NCAR] > 0)\n  {\n    for (j = 0; j < NCAR; j++)\n    {\n      newcent[i][j] = additions[i][j] / additions[i][NCAR];\n    }\n\n    discent = gendist(&newcent[i][0], &cent[i][0]);\n    if (discent > DELTA)\n    {\n      fin = 0;\n    }\n\n    for (j = 0; j < NCAR; j++)\n    {\n      cent[i][j] = newcent[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(i, j, discent) schedule(dynamic,2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/gengrupos_p/1"}
{"code": "for (i = 0; i < 8; i++)\n{\n  printf(\"loop_0[%d]: %lu, loop_1[%d]: %lu, loop_2[%d]: %lu\\n\", i, loop_0[i], i, loop_1[i], i, loop_2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/3"}
{"code": "for (int c = 0; c < k; c++)\n{\n  sum += pow(getDistance(oldCentroids[c], centroids[c], nCol), 2);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum) firstprivate(centroids,oldCentroids,nCol)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/7"}
{"code": "for (i = 0; i < 10; i++)\n{\n  A[i] = i;\n  B[i] = 2 * i;\n  C[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LuckThemAll/parallel-programming/OpenMP/task2/0"}
{"code": "for (unsigned i = 0, e = Node->getNumHandlers(); i < e; ++i)\n{\n  OS << \" \";\n  PrintRawCXXCatchStmt(Node->getHandler(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/AST/StmtPrinter/4"}
{"code": "for (int x = 0; x < W; ++x)\n  for (int y = 0; y < W; ++y)\n{\n  kernel[x][y] = exp((-0.5) * (pow((x - mean) / sigma, 2.0) + pow((y - mean) / sigma, 2.0))) / (((2 * M_PI) * sigma) * sigma);\n  sum += kernel[x][y];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martinneumann/gaussian-openmp/main/0"}
{"code": "for (i = 0; i < (128 + 1); i++)\n{\n  for (j = 0; j < (128 + 1); j++)\n  {\n    uold[i][j] = u[i][j];\n    vold[i][j] = v[i][j];\n    pold[i][j] = p[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/21"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  initializeQueue(&queues[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekmurali/producer_consumer_openmp/omp_tokenizer/2"}
{"code": "for (j = 0, k = 0; j < (size_seq2 + 1); j++, k++)\n{\n  if ((*i) == j)\n  {\n    (*new_seq2)[*i] = '-';\n    (*scores)->mute_loc = *i;\n    j += 1;\n  }\n\n  (*new_seq2)[j] = seq2[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/5"}
{"code": "for (i = 0; i < (m - 1); i++)\n{\n  if (ten[ind][i] > ten[ind][i + 1])\n  {\n    temp = ten[ind][i + 1];\n    ten[ind][i + 1] = ten[ind][i];\n    ten[ind][i] = temp;\n    j_temp = j1[ind][i + 1];\n    j1[ind][i + 1] = j1[ind][i];\n    j1[ind][i] = j_temp;\n    j_temp = j2[ind][i + 1];\n    j2[ind][i + 1] = j2[ind][i];\n    j2[ind][i] = j_temp;\n    j_temp = j3[ind][i + 1];\n    j3[ind][i + 1] = j3[ind][i];\n    j3[ind][i] = j_temp;\n  }\n  else\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/3"}
{"code": "for (int i = DIM / 4; i < (DIM - 1); i += DIM / 4)\n  for (int j = DIM / 4; j < (DIM - 1); j += DIM / 4)\n  TABLE[(i * DIM) + j] = (i * j) / 4;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/17"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  aSumErr += ((a[j] - aj) >= 0) ? (a[j] - aj) : (-(a[j] - aj));\n  bSumErr += ((b[j] - bj) >= 0) ? (b[j] - bj) : (-(b[j] - bj));\n  cSumErr += ((c[j] - cj) >= 0) ? (c[j] - cj) : (-(c[j] - cj));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/22"}
{"code": "for (idx = 0; idx < k; idx++)\n{\n  if (i != idx)\n  {\n    distance(clusters_arr[idx].x, clusters_arr[idx].y, clusters_arr[i].x, clusters_arr[i].y, &dist);\n    qm += diameter / dist;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction (+: qm)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stefani237/K-MEANS/Initial/func/8"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = (float) strtod(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->fvsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->ivsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = strtof(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = strtof(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/16"}
{"code": "for (i = 0; i < subprob_size; i++)\n{\n  rlcbuff[i] = INITIAL_GRID;\n  rfcbuff[i] = 1.0;\n  rlrbuff[i] = 0.0;\n  rfrbuff[i] = INITIAL_GRID;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/3"}
{"code": "for (j = N - 1; j >= 0; j--)\n{\n  RR[j] = (t = t - gh);\n  SS[j] = t - g;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/13"}
{"code": "for (int k = 0; k < K; k++)\n{\n  sum += squared_norm(clusters[k], mean);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/24"}
{"code": "for (int i = 0; i < N; i++)\n{\n  particles[i].x = buffer[6 * i];\n  particles[i].y = buffer[(6 * i) + 1];\n  particles[i].ux = buffer[(6 * i) + 3];\n  particles[i].uy = buffer[(6 * i) + 4];\n  particles[i].ax = 0;\n  particles[i].ay = 0;\n  particles[i].m = buffer[(6 * i) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuanx749/n-body/barnes_hut/2"}
{"code": "for (i = 0; i < numInputs; i++)\n{\n  if (strcmp(&arrayPtr[i * 15], searchStr) == 0)\n  {\n    posFoundS = i;\n    processFoundS = tid;\n    sliceNum = i / sliceSize;\n  }\n\n}\n\n", "pragma": "omp for schedule( static, sliceSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carlislk/OpenMP-ArraySearch/Program/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/nesting_of_regions/0"}
{"code": "for (i = 0; i < (1 << 27); i++)\n{\n  x = randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  x += randlc(&seed, &a);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/IS/is/6"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, 9, (MPI_Datatype) 0x4c000406, T, 9, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/29"}
{"code": "for (i = 0; i < dimention; i++)\n{\n  for (j = 0; j < dimention; j++)\n  {\n    int a;\n    int b;\n    int c;\n    if ((generation == 1) || (generation == 0))\n    {\n      a = 0xff;\n      b = 0xff;\n      c = 0xff;\n    }\n    else\n      if ((generation == 2) || (generation == 3))\n    {\n      a = 0xff;\n      b = 0x80;\n      c = 0x80;\n    }\n    else\n      if ((generation == 4) || (generation == 5))\n    {\n      a = 0x80;\n      b = 0xff;\n      c = 0x80;\n    }\n    else\n      if ((generation == 6) || (generation == 7))\n    {\n      a = 0x80;\n      b = 0x80;\n      c = 0xff;\n    }\n    else\n    {\n      a = rand() % 0x100;\n      b = rand() % 0x100;\n      c = rand() % 0x100;\n    }\n\n\n\n\n    Input2[i][j][0] = a;\n    Input2[i][j][1] = b;\n    Input2[i][j][2] = c;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ojani-Eguia/ImageGeneratorTest/OpenMP/ParShader/2"}
{"code": "for (v = 0; v < cache->numPropertyRegions; ++v)\n{\n  if ((addr >= cache->propertyRegions[v].lower_bound) && (addr < cache->propertyRegions[v].hot_bound))\n  {\n    result = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/16"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = (static_cast < ValueType) > 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/5"}
{"code": "for (i = 0; i < valptr; i++)\n  printf(\"%c\", val[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TransientObject/ParallelizeAlgos/lib/huffman_compression_main_proj/openmp_version/8"}
{"code": "for (int i = 0; i < ((int) imageSize[box]); i++)\n{\n  cosMolRef[*thisMol][i] = 0.0;\n  sinMolRef[*thisMol][i] = 0.0;\n  for (uint j = 0; j < thisKind.NumAtoms(); j++)\n  {\n    if (particleHasNoCharge[startAtom + j])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(mols.MolStart(*thisMol) + j, kx[box][i], ky[box][i], kz[box][i], molCoords);\n    cosMolRef[*thisMol][i] += thisKind.AtomCharge(j) * cos(dotProduct);\n    sinMolRef[*thisMol][i] += thisKind.AtomCharge(j) * sin(dotProduct);\n  }\n\n  sumRnew[box][i] += lambdaCoef * cosMolRef[*thisMol][i];\n  sumInew[box][i] += lambdaCoef * sinMolRef[*thisMol][i];\n}\n\n", "pragma": "      #pragma omp parallel for default(none) shared(box, lambdaCoef, molCoords, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/1"}
{"code": "for (k = 0; k < local_num_possible_vaules; k++)\n{\n  taules_aux2[k] = init_datasetV2(i, j, taules_aux[k].taula);\n  aux += taules_aux2[k][0].nelem;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/10"}
{"code": "for (cell = hyp.cell + 1; cell < v_size; cell++)\n{\n  if (cp_sudoku[cell])\n    continue;\n\n  for (val = m_size; val >= 1; val--)\n  {\n    if (is_safe_num(rows_mask, cols_mask, boxes_mask, cell / m_size, cell % m_size, val))\n    {\n      if (cell == last_pos)\n      {\n        cp_sudoku[cell] = val;\n        send_ring(&id, 2, -1);\n        return 1;\n      }\n\n      hyp.cell = cell;\n      hyp.num = val;\n      insert_head(work, hyp);\n    }\n\n  }\n\n  break;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/5"}
{"code": "for (i = 1; i < (30 - 1); i++)\n{\n  int thread = calc_thread(30, 30, i, 30 - 1);\n  printf(\"%d S: %p\\n\", thread, &w[i][30 - 1]);\n  w[i][30 - 1] = 100.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/1"}
{"code": "for (int i = 0; i < length; i++)\n{\n  a[i] = (rand() % 100) / 100.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Tests/testing/matMult/matrixMult/0"}
{"code": "for (i = 0; i < n; i++)\n  out[pos[i]] = in[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa09/silly/2"}
{"code": "for (iterator p = _collisionsOfNextTraversal[particleB.getGlobalParticleID()].begin(); p != _collisionsOfNextTraversal[particleB.getGlobalParticleID()].end(); p++)\n{\n  if (p->_copyOfPartnerParticle.getGlobalParticleID() == particleA.getGlobalParticleID())\n  {\n    dataSetB = &(*p);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/core/Engine/1"}
{"code": "for (int i = 1; i < (WIN_SIZE - 1); i++)\n{\n  for (int j = 1; j < (WIN_SIZE - 1); j++)\n    map[i][j] = (((tmp[i - 1][j] + tmp[i + 1][j]) + tmp[i][j - 1]) + tmp[i][j + 1]) * 0.25;\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(nb_thread)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/heat-dissipation/programs/openmp/src/main/3"}
{"code": "for (long int i = 0; i < N; ++i)\n{\n  for (long int j = 0; j < N; ++j)\n  {\n    A[(i * N) + j] = dis(gen);\n    B[(j * N) + i] = dis(gen);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP9/tests/matrix/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n  for (int j = 0; j < SIZE; j++)\n  for (int k = 0; k < SIZE; k++)\n  matrixc[i][j] = matrixc[i][j] + (matrixa[i][k] * matrixb[k][j]);\n\n\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/24"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/25"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  produit_scalaire_complexe = dotc1(d, e);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/18"}
{"code": "for (i = 0; i < length; i++)\n{\n  flag = 0;\n  for (j = 0; j < 15; j++)\n  {\n    if (data[i][j] != a[j])\n    {\n      flag = 1;\n      break;\n    }\n\n  }\n\n  if (flag == 0)\n    index.push_back(i);\n\n}\n\n", "pragma": "\t\t\t\t#pragma omp for private(flag, j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_2/search/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  var[i] = i;\n}\n\n", "pragma": "omp parallel for num_threads(2) shared(var)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PRUNERS/sword/test/parallel/critical/0"}
{"code": "for (int i = 0; i < totalSize; i++)\n{\n  fscanf(fpA, \"%lf\", &ptA[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JerryHu1994/CS-759-High-Performance-Computing/HW06/problem1A/1"}
{"code": "for (i = 0; i < 500; i++)\n{\n  A[i] = malloc(500 * (sizeof(double)));\n  B[i] = malloc(500 * (sizeof(double)));\n  C[i] = malloc(500 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanGit/Threads-OpenMP/Threads-OpenMP/OpenMP/task2_4/0"}
{"code": "for (row = kHalf; row < (paddedInputHeight - kHalf); row++)\n{\n  for (col = kHalf; col < (paddedInputWidth - kHalf); col++)\n  {\n    for (krow = 0; krow < kSize; krow++)\n    {\n      for (kcol = 0; kcol < kSize; kcol++)\n      {\n        for (ch = 0; ch < channels; ch++)\n        {\n          ucValue = paddedInput[(((((row - kHalf) + krow) * paddedInputWidth) * channels) + (((col - kHalf) + kcol) * channels)) + ch];\n          dValueKernel = kernel[(krow * kSize) + kcol];\n          dAgg[ch] += ucValue * dValueKernel;\n        }\n\n      }\n\n    }\n\n    for (ch = 0; ch < channels; ch++)\n    {\n      ucAgg = dAgg[ch];\n      if ((dAgg[ch] - ucAgg) >= 0.5)\n      {\n        ucAgg += 1;\n      }\n\n      output[((((row - kHalf) * width) * channels) + ((col - kHalf) * channels)) + ch] = ucAgg;\n      dAgg[ch] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(col, row, ch, krow, kcol, ucValue, dValueKernel, dAgg, ucAgg) collapse(2) schedule(dynamic, chunkSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sigurthorb/OpenMPvsGoroutines-Convolutions/ConvolutionLibrary/c/libConv/0"}
{"code": "for (size_t y = 1; y < (h - 1); ++y)\n{\n  for (size_t x = 1; x < (w - 1); ++x)\n  {\n    g1[(y * w) + x] = tinit[(((y - 1) * p->M) + x) - 1];\n    c[(y * w) + x] = cinit[(((y - 1) * p->M) + x) - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/compute/2"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  for (int j = 0; j < num_splines; j++)\n    eval_UBspline_3d_d_vgh(norm_splines[j], x, y, z, &norm_vals[j], &norm_grads[3 * j], &norm_hess[9 * j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/11"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  a[i] = (double *) malloc(NCA * (sizeof(double)));\n  c[i] = (double *) malloc(NCB * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/mm_v1_par/4"}
{"code": "for (int row = 0; row < m; row++)\n{\n  for (int col = 0; col < n; col++)\n  {\n    for (int inner = 0; inner < k; inner++)\n    {\n      sum += Mas1[row][inner] * Mas2[inner][col];\n    }\n\n    Mas3[row][col] = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/Matr/9"}
{"code": "for (t = 0; t < count; t++)\n{\n  unsigned char temp_key[8 * 2];\n  unsigned char final_key[8 * 2];\n  unsigned int i;\n  unsigned int sum20;\n  unsigned char destArray[4 * 16];\n  MD5_CTX ctx;\n  if (keyLen[t] < 0)\n  {\n    keyLen[t] = strlen(saved_plain[t]);\n    while (saved_plain[t][keyLen[t] - 1] == ' ')\n    {\n      if (keyLen[t] == 0)\n        break;\n\n      saved_plain[t][--keyLen[t]] = 0;\n    }\n\n    for (i = 0; i < keyLen[t]; i++)\n      saved_key[t][i] = transtable[ARCH_INDEX(saved_plain[t][i])];\n\n  }\n\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[t], keyLen[t]);\n  MD5_Update(&ctx, cur_salt->s, cur_salt->l);\n  MD5_Final(temp_key, &ctx);\n  sum20 = walld0rf_magic(t, temp_key, destArray);\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, destArray, sum20);\n  MD5_Final(final_key, &ctx);\n  for (i = 0; i < 8; i++)\n    ((char *) crypt_key[t])[i] = final_key[i + 8] ^ final_key[i];\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapB_fmt_plug/0"}
{"code": "for (int ii = 0; ii < (5 + 2); ii++)\n{\n  for (int i = 0; i < 5; i++)\n  {\n    a += i;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_par3/nested_par3/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (p[i] != (pp + (1 * i)))\n    printf(\"%d: p got %d, expected %d, error %d\\n\", i, p[i], pp + (1 * i), ++error);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x[i] = 1;\n  (cout << x[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnrn/Introduction-to-Algorithms/MultiThreaded/MatVec/omp/matvec/2"}
{"code": "for (int i = 0; i < Dim; i++)\n{\n  Res[i] = (int) Vec[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/99"}
{"code": "for (i = 1; i <= n; i++)\n{\n  l = i - 1;\n  if (d[i])\n  {\n    for (j = 1; j <= l; j++)\n    {\n      g = 0.0;\n      for (k = 1; k <= l; k++)\n        g += a(i - 1, k - 1) * a(k - 1, j - 1);\n\n      for (k = 1; k <= l; k++)\n      {\n        a(k - 1, j - 1) -= g * a(k - 1, i - 1);\n        EAssert(!a(k - 1, j - 1).IsNan());\n      }\n\n    }\n\n  }\n\n  d[i] = a(i - 1, i - 1);\n  a(i - 1, i - 1) = 1.0;\n  for (j = 1; j <= l; j++)\n    a(j - 1, i - 1) = (a(i - 1, j - 1) = 0.0);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/61"}
{"code": "for (p++; m[p]; p++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E2/sieve/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i;\n  sum += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilanfink/openmp-multithreading/openmp-multithreading/0"}
{"code": "for (i = 0; i < 24576; i++)\n{\n  x1[i] = ((DATA_TYPE) i) / 24576;\n  x2[i] = (((DATA_TYPE) i) + 1) / 24576;\n  x1_gpu[i] = x1[i];\n  x2_gpu[i] = x2[i];\n  y1[i] = (((DATA_TYPE) i) + 3) / 24576;\n  y2[i] = (((DATA_TYPE) i) + 4) / 24576;\n  for (j = 0; j < 24576; j++)\n  {\n    A[(i * 24576) + j] = (((DATA_TYPE) i) * j) / 24576;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/MVT/mvt_cpu/8"}
{"code": "for (i = 0; i < omp_num_devices; i++)\n{\n  omp_device_t *dev = &omp_devices[i];\n  char *mem_type = \"SHARED\";\n  if (dev->mem_type == OMP_DEVICE_MEM_DISCRETE)\n  {\n    mem_type = \"DISCRETE\";\n  }\n\n  printf(\"\\t%d|sysid: %d, type: %s, name: %s, ncores: %d, mem: %s, flops: %0.2fGFLOPS/s, bandwidth: %.2fMB/s, latency: %.2fus\\n\", dev->id, dev->sysid, omp_get_device_typename(dev), dev->name, dev->num_cores, mem_type, dev->total_real_flopss, dev->bandwidth, dev->latency);\n  if (dev->type == OMP_DEVICE_NVGPU)\n  {\n    if (dev->mem_type == OMP_DEVICE_MEM_DISCRETE)\n    {\n    }\n\n    if (dev->mem_type == OMP_DEVICE_MEM_SHARED)\n    {\n      printf(\"\\t\\tUnified Memory is NOT supported in the runtime, fall back to discrete memory for this device. To enable shared mem support in runtime, set the DEVICE_NVGPU_VSHAREDM macro.\\n\");\n      dev->mem_type = OMP_DEVICE_MEM_DISCRETE;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/runtime/homp_dev/4"}
{"code": "for (int i = 0; i < m_nRows; i++)\n{\n  for (int j = 0; j < m_nLayers; j++)\n  {\n    if (!FloatEqual(data[i][j], NODATA_VALUE))\n    {\n      if (FloatEqual(m_2DData[i][j], NODATA_VALUE))\n      {\n        m_2DData[i][j] = 0.f;\n      }\n\n      m_2DData[i][j] += data[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/4"}
{"code": "for (int i = 0; i < dataset->nOfPatterns; i++)\n{\n  feedInputsOriginal(dataset->inputs[i]);\n  forwardPropagateOriginal();\n  getOutputs(obtainedOutputs);\n  confusionMatrix[maxIndexVector(dataset->outputs[i], dataset->nOfOutputs)][maxIndexVector(obtainedOutputs, dataset->nOfOutputs)]++;\n  confusionMatrix[maxIndexVector(obtainedOutputs, dataset->nOfOutputs)][maxIndexVector(dataset->outputs[i], dataset->nOfOutputs)]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/29"}
{"code": "for (int j = 0; j < N; j++)\n  a[j] = b[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/openmp/veccopy/veccopy/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  if ((i % 2) == 0)\n  {\n    *((outVectorPar + i) + (size * 2)) = applyFunction(inVector[i]);\n  }\n  else\n  {\n    *((outVectorPar + i) + (size * 2)) = inVector[i];\n  }\n\n}\n\n", "pragma": "omp for private(i) schedule(dynamic, 3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/tests/parallelfor-test/parallelfor/2"}
{"code": "for (int mat = 1; mat < (cc.Nmats / 2); mat++)\n{\n  for (int j = (sizey / 2) - 3; j < ((sizey / 2) - 1); j++)\n    for (int i = 2; i < (5 + overlap_i); i++)\n  {\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[((((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n  }\n\n\n  for (int j = sizey / 2; j < (((sizey / 2) + 2) + overlap_j); j++)\n    for (int i = 2; i < 5; i++)\n  {\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/5"}
{"code": "for (int j = 0; j < K; j++)\n{\n  for (int t = 0; t < M; t++)\n  {\n    res_matrix[i][j] += matrix1[i][t] * matrix2[t][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergere15/OpenMP_tasks/Task2/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IvanOnJava/OpenMP_examples/OpenMP_example_BubleSort/2"}
{"code": "for (i = 0; i < t; i++)\n  inv[i] = conj(omg[i]);\n\n", "pragma": "    #pragma omp parallel for shared(inv,omg)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/1"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  *(u + i) = 1.0;\n  *(u_new + i) = 1.0;\n  if (((*(x + i)) > 0.5) && ((*(x + i)) < 1.0))\n  {\n    *(u + i) = 2.0;\n    *(u_new + i) = 2.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/1-D_Linear_Convection/1-D_Linear_Convection_Dynamic/main/0"}
{"code": "for (int t_id = 0; t_id < THREAD_NUM; t_id++)\n{\n  param[t_id].t_id = t_id;\n  pthread_create(&handles[t_id], nullptr, PT_Static_Elimination, (void *) (&param[t_id]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/15"}
{"code": "for (i = 0; i < slices; i++)\n{\n  Ccol_sizes[i] = init_size;\n  Ccol_tBlock[i] = malloc(init_size * (sizeof(int)));\n  Crow_tBlock[i] = malloc((tBlock + 1) * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/2"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  ndim = clcgrandom(1, xyz);\n  x = xyz[0];\n  ndim = clcgrandom(1, xyz);\n  y = xyz[0];\n  if (((x * x) + (y * y)) <= 1.0)\n    Ncirc++;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prod-feng/CLCG-Parallel-RNG/clcg-parallel-mrg32k3a/0"}
{"code": "for (int m = 0; m < nmats; m++)\n{\n  status = fscanf(fp, \"%s\", matname);\n  if (status < 0)\n  {\n    printf(\"error in read at line %d\\n\", 7);\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/9"}
{"code": "for (int a = 0; a < 256; a++)\n  (hist << freq[a]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/2"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  size_t ii = i % cX;\n  size_t jj = i / cX;\n  if (ii < jj)\n    continue;\n\n  double *X = X0 + (ii * rX);\n  double *Y = Y0 + (jj * rY);\n  double cc = 0.0;\n  double rc = 0.0;\n  size_t nn = 0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double t;\n    double y;\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    y = z - rc;\n    t = cc + y;\n    rc = (t - cc) - y;\n    cc = t;\n    nn++;\n  }\n\n  size_t j = jj + (ii * cX);\n  CC[i] = cc;\n  CC[j] = cc;\n  if (NN != NULL)\n  {\n    NN[i] = (double) nn;\n    NN[j] = (double) nn;\n  }\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/8"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    image[i][j].rgbRed = temp[i][j].rgbRed;\n    image[i][j].rgbGreen = temp[i][j].rgbGreen;\n    image[i][j].rgbBlue = temp[i][j].rgbBlue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/3"}
{"code": "for (int k = 0; k < ndr; k++)\n  b(0, k) = beta_hat(k + 1, 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_local_solver/1"}
{"code": "for (i = 0; i < nr_class; i++)\n  free(pairwise_prob[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/85"}
{"code": "for (int i = 0; i < a[0].localSize(); i++)\n{\n  for (int d = 0; d < DIM; d++)\n  {\n    ret[d][i] = a[d][i] + b[d][i];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/smsolivier/spectral_upcxx/src/Operators/4"}
{"code": "for (j = 0; j < num_angles; j++)\n{\n  if ((myid >= count) && (myid < (count + (*(each_num_to_restart_per_anglePtr + j)))))\n  {\n    color = j;\n  }\n\n  count += *(each_num_to_restart_per_anglePtr + j);\n  printf(\"Myid: %d, Color: %d, Count %d, Num To Start Per Angle: %d\\n\", myid, color, count, *(each_num_to_restart_per_anglePtr + j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/6"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  j = 1;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[j][m]) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n  j = 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[j - 1][m]) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/21"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  prewittX[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/llama95/Parallel_Programming/Patterns/stencil/openmp/7"}
{"code": "for (i = 0; i < Size; i++)\n{\n  pRes[i] = 0;\n  for (j = 0; j < Size; j++)\n  {\n    pRes[i] += pMat[(i * Size) + j] * pVec[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Matrix Multiplication/Parallel/main/3"}
{"code": "for (j = cnt1; j < (my_grid->dimension - 1); j = j + 2)\n{\n  temp = my_grid->element[(i * my_grid->dimension) + j];\n  my_grid->element[(i * my_grid->dimension) + j] = 0.20 * ((((my_grid->element[(i * my_grid->dimension) + j] + my_grid->element[((i - 1) * my_grid->dimension) + j]) + my_grid->element[((i + 1) * my_grid->dimension) + j]) + my_grid->element[(i * my_grid->dimension) + (j + 1)]) + my_grid->element[(i * my_grid->dimension) + (j - 1)]);\n  diff = diff + fabs(my_grid->element[(i * my_grid->dimension) + j] - temp);\n}\n\n", "pragma": "omp parallel for default(shared) private(j,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/solver/solver/2"}
{"code": "for (i = 0; i < n; ++i)\n{\n  a[i] += foo(i);\n}\n\n", "pragma": "\t#pragma omp for shared (a,n) private (i) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/loop/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  fprintf(stderr, \"%8.2f | \", 0.0f);\n  for (int j = 0; j < N; j++)\n  {\n    float diff = fabsf(test[i][j] - ref[i][j]);\n    if (diff < 1e-2)\n    {\n      fprintf(stderr, \"%8.2f \", test[i][j]);\n    }\n    else\n    {\n      fprintf(stderr, \"%7.2f* \", test[i][j]);\n    }\n\n    max_err = fmaxf(max_err, diff);\n    min_err = fminf(min_err, diff);\n    verif = verif && (diff < 1e-2);\n  }\n\n  fprintf(stderr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/14"}
{"code": "for (int i = 1; i <= omp_get_num_threads(); i++)\n{\n  int my_thread = omp_get_thread_num();\n  printf(\"Hello from thread %d\\n\", my_thread);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pyright/omp_hello/parallel_for_hello/0"}
{"code": "for (i = 0; i < ((2 * N) - 2); i++)\n  intraE += harmonic(i, i + 2, K_INTRA, R_INTRA);\n\n", "pragma": "omp for schedule(static) reduction(+:intraE)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/langevin/2"}
{"code": "for (uint i = 0; i < molKind.nonBonded.count; ++i)\n{\n  uint p1 = mols.start[molIndex] + molKind.nonBonded.part1[i];\n  uint p2 = mols.start[molIndex] + molKind.nonBonded.part2[i];\n  if (currentAxes.InRcut(distSq, currentCoords, p1, p2, box))\n  {\n    energy += forcefield.particles->CalcEn(distSq, molKind.AtomKind(molKind.nonBonded.part1[i]), molKind.AtomKind(molKind.nonBonded.part2[i]), 1.0);\n    if (electrostatic)\n    {\n      qi_qj_fact = (qqFact * molKind.AtomCharge(molKind.nonBonded.part1[i])) * molKind.AtomCharge(molKind.nonBonded.part2[i]);\n      if (qi_qj_fact != 0.0)\n      {\n        forcefield.particles->CalcCoulombAdd_1_4(energy, distSq, qi_qj_fact, true);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/12"}
{"code": "for (int i = 0; i < 100000; ++i)\n{\n  float rasc;\n  float decl;\n  if (fscanf(real_data_file, \"%f %f\", &rasc, &decl) != 2)\n  {\n    printf(\"   ERROR: Cannot read line %d in real data file %s\\n\", i + 1, argv[1]);\n    fclose(real_data_file);\n    return 1;\n  }\n\n  real_rasc[i] = rasc * arcmin2rad;\n  real_decl[i] = decl * arcmin2rad;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mabutko/CosmicDarkMatter/galaxy_openmp/8"}
{"code": "for (j = 0; j < N_BUCKETS; j++)\n{\n  qsort(buckets[j]->array, buckets[j]->n_elem, sizeof(int), cmpfunc);\n  memcpy(arr + i, buckets[j]->array, buckets[j]->n_elem * (sizeof(int)));\n  i += buckets[j]->n_elem;\n  free_bucket(buckets[j]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseFilipeFerreira/parallel-bucket-sort/omp/openmp/main/1"}
{"code": "for (unsigned long row = 0; row < result.Rows(); ++row)\n{\n  for (unsigned long column = 0; column < result.Columns(); ++column)\n  {\n    for (unsigned long i = 0; i < op1.Columns(); ++i)\n    {\n      result(row, column) = result(row, column) + (op1(row, i) * top2(column, i));\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShariqueMohd/Parallel-Image-Compression-using-PCA/DenseMatrix/11"}
{"code": "for (int j = 0; j < 2; j++)\n  test();\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wyh0655/OpenMP_EXA/exa1/1"}
{"code": "for (int i = 0; i < nU; i++)\n{\n  (*B)[i] = (double *) malloc((sizeof(double)) * nI);\n  (*L)[i] = (double *) malloc((sizeof(double)) * nF);\n  (*newL)[i] = (double *) malloc((sizeof(double)) * nF);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/4"}
{"code": "for (i = 0; i < matrix->m; i++)\n  for (j = 0; j < matrix->n; j++)\n  sum += m_get_val(matrix, i, j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/21"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  val[i] = rand() % RMAX;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/OddEvenSorting/0"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < HALO.y; j++)\n  {\n    for (int i = 0; i < SDMGeom->L_NodeX(); i++)\n    {\n      indx1 = (i + (j * NodLoc.x)) + ((k * HALO.y) * NodLoc.x);\n      indx2 = ((HALO.x + i) + (((j + SDMGeom->HALO_NodeY()) - HALO.y) * SDMGeom->HALO_NodeX())) + (((k + HALO.z) * SDMGeom->HALO_NodeX()) * SDMGeom->HALO_NodeY());\n      DomLoc[indx2] = BN[indx1];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_omp)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/12"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  WL2[i][0] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex3/ex3/6"}
{"code": "for (int gidRow = 0; gidRow < nRows; gidRow++)\n  for (int gidCol = 0; gidCol < nCols; gidCol++)\n{\n  size_t gid = (gidRow * nCols) + gidCol;\n  if (((gidCol >= HALF_LENGTH) && (gidCol < (nCols - HALF_LENGTH))) && ((gidRow >= HALF_LENGTH) && (gidRow < (nRows - HALF_LENGTH))))\n  {\n    float value = 0.f;\n    value += (prev[gid + 1] - (2.f * prev[gid])) + prev[gid - 1];\n    value += (prev[gid + nCols] - (2.f * prev[gid])) + prev[gid - nCols];\n    value *= dtDIVdxy * vel[gid];\n    next[gid] = ((2.f * prev[gid]) - next[gid]) + value;\n  }\n\n}\n\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd collapse(2) thread_limit(256) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/iso2dfd-omp/iso2dfd/4"}
{"code": "for (j = start; j < end; j++)\n{\n  fx = 0;\n  fy = 0;\n  if ((abs(x[j]) < 1000000) && (abs(y[j]) < 1000000))\n  {\n    for (k = 0; k < N; k++)\n    {\n      if (k != j)\n      {\n        if ((abs(x[k]) < 1000000) && (abs(y[k]) < 1000000))\n        {\n          ftemp = (q[j] * q[k]) / (pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n          fx += (ftemp * (x[j] - x[k])) / sqrt(pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n          fy += (ftemp * (y[j] - y[k])) / sqrt(pow(x[j] - x[k], 2.0) + pow(y[j] - y[k], 2.0));\n        }\n\n      }\n\n    }\n\n  }\n\n  Ax[j] = fx / m[j];\n  Ay[j] = fy / m[j];\n  dax[j] = d * Ax[j];\n  day[j] = d * Ay[j];\n  dvx[j] = d * vx[j];\n  dvy[j] = d * vy[j];\n}\n\n", "pragma": "omp parallel for schedule(dynamic) num_threads(t) private( ftemp, fx, fy,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/ass3_6/0"}
{"code": "for (i = 0; i < (num_processos - 1); i++)\n  pivos[i] = ListaPossiveisPivos[(((i + 1) * num_processos) + (num_processos / 2)) - 1];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aulospl/TrabConcorrente/PRSR/1"}
{"code": "for (uint32_t i = 0; i < m_StitchRelation.size(); i++)\n{\n  for (uint32_t j = 0; j < m_StitchRelation[i].size(); j++)\n  {\n    if (m_db->vPatternBbox[i]->color() != m_db->vPatternBbox[m_StitchRelation[i][j]]->color())\n      stitch_count++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/22"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  hist_array[i] += temp_array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulwankhede/OpenMP/parallel/2"}
{"code": "for (int jj = 0; jj < 2000; jj += 25)\n{\n  for (int kk = 0; kk < 2000; kk += 25)\n  {\n    for (int i = 0; i < 2000; i++)\n    {\n      for (int j = jj; j < (((jj + 25) > 2000) ? (2000) : (jj + 25)); j++)\n      {\n        int sum = 0;\n        for (int k = kk; k < (((kk + 25) > 2000) ? (2000) : (kk + 25)); k++)\n        {\n          sum += A[(i * 2000) + k] * B[(k * 2000) + j];\n        }\n\n        C[(i * 2000) + j] += sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KunxiSun/matrix_multiplication_and_openmp_in_c_2/src/q4/0"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at1 = crealf(ffc[j]) * cimagf(ffc[j]);\n  at2 = (at1 * dnx) * ((float) j);\n  zt1 = cimagf(q[j]) - (crealf(q[j]) * _Complex_I);\n  fxyz[4 * j] = at2 * zt1;\n  fxyz[1 + (4 * j)] = zero;\n  fxyz[2 + (4 * j)] = zero;\n  fxyz[4 * (j + k1)] = zero;\n  fxyz[1 + (4 * (j + k1))] = zero;\n  fxyz[2 + (4 * (j + k1))] = zero;\n  fxyz[4 * (j + l1)] = zero;\n  fxyz[1 + (4 * (j + l1))] = zero;\n  fxyz[2 + (4 * (j + l1))] = zero;\n  fxyz[4 * ((j + k1) + l1)] = zero;\n  fxyz[1 + (4 * ((j + k1) + l1))] = zero;\n  fxyz[2 + (4 * ((j + k1) + l1))] = zero;\n  at1 = at1 * (q[j] * conjf(q[j]));\n  wp += (double) at1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/54"}
{"code": "for (unsigned int i = 0; i < (((L / 1) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((L / NODESY) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/83"}
{"code": "for (i = rb; i < re; i++)\n  ret[i] = ret[i] + (al * p_g_precond[1][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/16"}
{"code": "for (int i = 0; i < WSIZE; i++)\n{\n  walkers[i]->collect();\n  if (i == 0)\n    printf(\"GPU walkers[%d]->collect([resVal resGrad resHess]) = [%e %e %e]\\n\", i, walkers[i]->resVal, walkers[i]->resGrad, walkers[i]->resHess);\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for map(alloc:walkers[0:WSIZE]) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Platforms/OMPTarget/main/4"}
{"code": "for (int *it = depth_index[d]; it < depth_index[d + 1]; it++)\n{\n  int src = *it;\n  int row_begin = row_offsets[src];\n  int row_end = row_offsets[src + 1];\n  for (int offset = row_begin; offset < row_end; offset++)\n  {\n    int dst = column_indices[offset];\n    if (succ.get_bit(offset))\n    {\n      deltas[src] += (((static_cast < ScoreT) > (path_counts[src] / static_cast)) < ScoreT) > (path_counts[dst] * (1 + deltas[dst]));\n    }\n\n  }\n\n  scores[src] += deltas[src];\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic, 64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bc/omp_target_base/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  A[(i * n) + j] = 0.0;\n  B[(i * n) + j] = i + (j * n);\n  C[(i * n) + j] = (i * n) + j;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/didharshthings/ShortAssignment9-OpenMP/hw9.1-sisi8853-openmp-manual/1"}
{"code": "for (i = start; i < end; i++)\n{\n  canvas[i] = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnisB/ParallelTP/TP1/inf8601-lab1-2.1.0/src/dragon/2"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  temp += p[i].y;\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/3"}
{"code": "for (size_t i = 0; i < Nqd; i++)\n{\n  x1(i) = quadss(i, 0);\n  x2(i) = quadss(i, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/6"}
{"code": "for (j = 0; j < cache->assoc; j++)\n{\n  setPLRU(&cache->cacheLines[i][j], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/13"}
{"code": "for (i = 0; i < r_length; i++)\n{\n  for (j = 0; j < c_length; j++)\n  {\n    aT[(j * r_length) + i] = a[(i * c_length) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/par_mm/4"}
{"code": "for (int i = 0; i < num_nodes; i++)\n{\n  for (int j = 0; j < num_nodes; j++)\n  {\n    if (fscanf(data_file, \"%d\", &temp) == EOF)\n    {\n      break;\n    }\n    else\n    {\n      if (i == j)\n      {\n        nodes_distance[i][j] = 0;\n      }\n      else\n      {\n        nodes_distance[i][j] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/intesar-gist/floyd_warshall_openmp/floyd_warshall_openmp/4"}
{"code": "for (i = 1; i < numberOfPopulations; i++)\n{\n  if (populations[i].best.evaluationValue < best.evaluationValue)\n    best = populations[i].best;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/20"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  sum = 0.;\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    sum += norm(wf.wave[wf.in2(j, i)]);\n  }\n\n  dist[j] = wf.dx1 * sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/34"}
{"code": "for (i2 = 0; i2 <= (n2 - 1); i2 += 1)\n{\n  for (i1 = 0; i1 <= (n1 - 1); i1 += 1)\n  {\n    u[n3 - 1][i2][i1] = u[1][i2][i1];\n    u[0][i2][i1] = u[n3 - 2][i2][i1];\n  }\n\n}\n\n", "pragma": "omp parallel for private (i1,i2) firstprivate (n1,n2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/5"}
{"code": "for (i = 0; i < ptr_idx_matching->length(); i++)\n{\n  extrinsic_data(ptr_idx_matching->get(i)) = (Viterbi_scaling_factor[0] * ((2.0 * extrinsic_data(ptr_idx_matching->get(i))) - 1.0)) * LLR;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/11"}
{"code": "for (i = 0; i < N; i++)\n{\n  tempSum += v[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/6"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n{\n  printf(\"A[%d]: %d\\trank[%d]: %d \\t Sorted[%d]: %d\\n\", i, A[i], i, rank[i], i, Sorted[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-fig/CISC-4335-OpenMP-Rank-Sort/rank_sort/4"}
{"code": "for (index = 0; index < count; index++)\n  if (((uint32_t *) binary)[0] == ((uint32_t *) (&crypt_key[index][0]))[0])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/salted_sha1_fmt_plug/1"}
{"code": "for (i = 0; i <= (1000 + 1); i++)\n{\n  t[i][0] = 0.0;\n  t[i][1000 + 1] = (100.0 / 1000) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kuanweih/XSEDE-HPC-Workshop/Exercises-my/OpenMP/Examples/laplace_parallel_region/4"}
{"code": "for (j = 0; j < Ny; ++j)\n{\n  un[0][j] = 0;\n  un[Nx - 1][j] = 0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/set/2020/exercise2/7"}
{"code": "for (int i = 0; i < MaxThreads; i++)\n{\n  const int Expected1 = 6;\n  if (i < NumThreads)\n  {\n    if (check1[i] != Expected1)\n    {\n      printf(\"invalid: check1[%d] should be %d, is %d\\n\", i, Expected1, check1[i]);\n    }\n\n  }\n  else\n    if (check1[i] != 0)\n  {\n    printf(\"invalid: check1[%d] should be 0, is %d\\n\", i, check1[i]);\n  }\n\n\n  const int Expected2 = 195;\n  if (i < NumThreads)\n  {\n    if (check2[i] != Expected2)\n    {\n      printf(\"invalid: check2[%d] should be %d, is %d\\n\", i, Expected2, check2[i]);\n    }\n\n  }\n  else\n    if (check2[i] != 0)\n  {\n    printf(\"invalid: check2[%d] should be 0, is %d\\n\", i, check2[i]);\n  }\n\n\n  const int Expected3 = 11;\n  if (i < NumThreads)\n  {\n    if (check3[i] != Expected3)\n    {\n      printf(\"invalid: check3[%d] should be %d, is %d\\n\", i, Expected3, check3[i]);\n    }\n\n  }\n  else\n    if (check3[i] != 0)\n  {\n    printf(\"invalid: check3[%d] should be 0, is %d\\n\", i, check3[i]);\n  }\n\n\n  const int Expected4 = 198;\n  if (i < NumThreads)\n  {\n    if (check4[i] != Expected4)\n    {\n      printf(\"invalid: check4[%d] should be %d, is %d\\n\", i, Expected4, check4[i]);\n    }\n\n  }\n  else\n    if (check4[i] != 0)\n  {\n    printf(\"invalid: check4[%d] should be 0, is %d\\n\", i, check4[i]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/libomptarget/deviceRTLs/nvptx/test/parallel/level/2"}
{"code": "for (unsigned int i = 0; i < parents.at(0).size(); ++i)\n{\n  daughter.push_back(\" \");\n  son.push_back(\" \");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/5"}
{"code": "for (i = 0; i < (2 * (nendmembers - 1)); i++)\n{\n  for (j = 0; j < (2 * (nendmembers - 1)); j++)\n  {\n    fprintf(report, \" %lf\", sqr[i][j]);\n  }\n\n  fprintf(report, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/SEE-E/15"}
{"code": "for (m = 0; m < 5; m++)\n{\n  tmp = u000ijk[m] - u[i][j][k][m];\n  errnm[m] = errnm[m] + (tmp * tmp);\n}\n\n", "pragma": "omp parallel for firstprivate(ist ,tmp ,m ,jst ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/41"}
{"code": "for (k = 0; k < lC; k++)\n{\n  if (S[i][C[k] - 1] == 1)\n  {\n    Ci[lCi][0] = C[k];\n    lCi = lCi + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/18"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  if (testBuf[i] != finalRecvBuf[i])\n  {\n    testFlag = FALSE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_pingping/0"}
{"code": "for (unsigned int r = 0; r < (geom->n_grid_r - 1); r++)\n  for (unsigned int z = 0; z < (geom->n_grid_z - 1); z++)\n{\n  double p_sum_2 = ((t_vec_r[r][z] * t_vec_r[r][z]) + (t_vec_phi[r][z] * t_vec_phi[r][z])) + (t_vec_z[r][z] * t_vec_z[r][z]);\n  if (p_sum_2 < (((REL_LIMIT * REL_LIMIT) * prtls->mass) * prtls->mass))\n    t_src[r][z] = ((t_sum[r][z] * t_sum[r][z]) - p_sum_2) / (((2 * prtls->mass) * count_sum[r][z]) * count_sum[r][z]);\n  else\n  {\n    double mc_2 = prtls->mass * LIGHT_SPEED_POW_2;\n    t_src[r][z] = sq_rt(((((t_sum[r][z] * t_sum[r][z]) - p_sum_2) * LIGHT_SPEED_POW_2) / (count_sum[r][z] * count_sum[r][z])) + (mc_2 * mc_2)) - mc_2;\n  }\n\n  t_src[r][z] /= abs(prtls->charge);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/temperature/2"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n  assert(v[i][j] == 1);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_collapse_01/1"}
{"code": "for (int i = 0; i < 45; i++)\n{\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter9/sibr/1"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpqqh1jn2d.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpqqh1jn2d.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/36"}
{"code": "for (uint32_t i = 0; i < 20; i++)\n  array[i] += i;\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_02/1"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n    debug_assignment(&dataset[n], closest_cluster, &centroids[closest_cluster], min_distance);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) reduction(+:cluster_changes)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp2_impl/2"}
{"code": "for (index = 0; index < tot_todo; index += inc)\n{\n  {\n    int i;\n    int len = saved_len[index];\n    char *pass = saved_key[index];\n    switch (cur_salt->type)\n    {\n      case 5:\n      {\n        MD5_CTX ctx;\n        MD5_Init(&ctx);\n        MD5_Update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          MD5_Update(&ctx, pass, len);\n\n        MD5_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 256:\n      {\n        SHA256_CTX ctx;\n        SHA256_Init(&ctx);\n        SHA256_Update(&ctx, cur_salt->salt, cur_salt->len);\n        for (i = 0; i <= cur_salt->rounds; ++i)\n          SHA256_Update(&ctx, pass, len);\n\n        SHA256_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n      case 512:\n      {\n        SHA512_CTX ctx;\n        SHA512_Init(&ctx);\n        SHA512_Update(&ctx, cur_salt->salt, cur_salt->len);\n        if ((len && ((128 % len) == 0)) && ((cur_salt->len + (len * cur_salt->rounds)) > 256))\n        {\n          int ex;\n          for (i = 0; i <= cur_salt->rounds; ++i)\n          {\n            SHA512_Update(&ctx, pass, len);\n            if (ctx.total > (128 + cur_salt->len))\n              break;\n\n          }\n\n          ++i;\n          ex = (256 - ctx.total) / len;\n          i += ex;\n          ctx.total += ex * len;\n          jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n          while ((i + (128 / len)) <= cur_salt->rounds)\n          {\n            ctx.total += 128;\n            jtr_sha512_hash_block(&ctx, ctx.buffer, 1);\n            i += 128 / len;\n          }\n\n          for (; i <= cur_salt->rounds; ++i)\n            ctx.total += len;\n\n        }\n        else\n        {\n          for (i = 0; i <= cur_salt->rounds; ++i)\n            SHA512_Update(&ctx, pass, len);\n\n        }\n\n        ctx.bIsQnxBuggy = 1;\n        SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n        break;\n      }\n\n    }\n\n  }\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/qnx_fmt_plug/0"}
{"code": "for (i = 0; i <= (public.in_mod_elem - 1); i += 1)\n{\n  in_sqr_final_sum = in_sqr_final_sum + private.d_in_sqr[i];\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:in_sqr_final_sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/1"}
{"code": "for (int tt = 0; tt < params.maxIters; tt += 2)\n{\n  __assume((tt % 2) == 0);\n  av_vels[tt] = timestep(params, &cells, &tmp_cells, obstacles);\n  av_vels[tt + 1] = timestep(params, &tmp_cells, &cells, obstacles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/openMP/d2q9-bgk/4"}
{"code": "for (size_t i = 0; i < this->nwords; ++i)\n  if (this->data[i])\n{\n  acc = true;\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bitmap/2"}
{"code": "for (int pp = 0; pp < (n - 2); pp += 2)\n{\n  int p = pp;\n  int q = p + 1;\n  rotateJacobi2(S, q, p);\n  debugMatrixForm(S);\n  ssteqr_debug(S);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/JacobiIteration1/3"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  input[i] = rand() / ((double) 32767);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/3"}
{"code": "for (a = 0; a < 2; ++this->a)\n  ++this->a;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_lastprivate_codegen/4"}
{"code": "for (t = 0; t < NUM_THREADS; t++)\n{\n  rc = pthread_join(thread[t], &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhston02/PthreadComparisonToOpenMP/main/2"}
{"code": "for (int i = 0; i < index.size(); i++)\n{\n  for (int j = 0; j < v.size(); j++)\n  {\n    res[j].push_back(v[j][index[i]]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/13"}
{"code": "for (int j = 0; j < 4; ++j)\n{\n  b[j] = b[j] + a[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-08-ParallelForParallelFor/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int u = rand() % (n - 1);\n  int v = ((rand() % ((n - u) - 1)) + u) + 1;\n  if (adj_matrix[u][v] == 0)\n  {\n    num_edges++;\n  }\n\n  adj_matrix[u][v] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/9"}
{"code": "for (int j = 0; j < mode; ++j)\n{\n  if (EMD_success[j] == false)\n  {\n    NDQ_success[j] = false;\n    printf(\"X\");\n    continue;\n  }\n\n  NDQ(result[j], FM[j], AM[j], IP[j], IF[j], data_len, dt, NDQ_success[j]);\n  if (NDQ_success[j])\n    printf(\"O\");\n  else\n    printf(\"X\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/43"}
{"code": "for (int i = 0; i < n; ++i)\n  if (v1[i] != v2[i])\n  return false;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/13"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j <= i; j++)\n  for (k = 1; k <= m; k++)\n  a[i][j] += ((double) ((i + 1) * (j + 1))) / ((double) ((((i + 1) + j) + 1) + k));\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/exercise_4/c_neighbor/0"}
{"code": "for (i = 0; i < 16384; i++)\n{\n  q[i] = 0.0;\n  for (j = 0; j < 16384; j++)\n  {\n    s[j] = s[j] + (r[i] * A[(i * 16384) + j]);\n    q[i] = q[i] + (A[(i * 16384) + j] * p[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiongsiwu/PolybenchOMP/OmpCPU/BICG/bicg/7"}
{"code": "for (int k = 0; k < edges; k++)\n{\n  {\n    removedNode = removeNodeFromS(setS, graph);\n    removeEdge(removedNode, graph, setS);\n    insertAtEnd(setL, removedNode);\n  }\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikosstam4/parallel_computing/psort/0"}
{"code": "for (i = 0; i < (size * size); i++)\n  *(m + i) = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/8"}
{"code": "for (int i = 1; i < image_height; i++)\n{\n  if (curr_t != message[i])\n  {\n    curr_t = message[i];\n    printf(\"Thread %d \u00ad-> Processing Chunk starting at Row %d\\n\", curr_t, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kujoukaren/CPP-Sobel-Algorithm-OpenMP/Implementation/1"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  vector[i] = vector[i] * value;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paulpaulych/parallel_labs/Lab2/var1/4"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[m][nz - 3][j][i] = frct[m][nz - 3][j][i] - (dssp * (((rsd[m][nz - 5][j][i] - (4.0 * rsd[m][nz - 4][j][i])) + (6.0 * rsd[m][nz - 3][j][i])) - (4.0 * rsd[m][nz - 2][j][i])));\n      frct[m][nz - 2][j][i] = frct[m][nz - 2][j][i] - (dssp * ((rsd[m][nz - 4][j][i] - (4.0 * rsd[m][nz - 3][j][i])) + (5.0 * rsd[m][nz - 2][j][i])));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/22"}
{"code": "for (q = 0; q < 1024; q++)\n{\n  for (k = q + 1; k < 1024; k++)\n  {\n    x_diff = pos[q][0] - pos[k][0];\n    y_diff = pos[q][1] - pos[k][1];\n    z_diff = pos[q][2] - pos[k][2];\n    dist = sqrt(((x_diff * x_diff) + (y_diff * y_diff)) + (z_diff * z_diff));\n    dist_cubed = (dist * dist) * dist;\n    force_qk[0] = (((1 * masses[q]) * masses[k]) / dist_cubed) * x_diff;\n    force_qk[1] = (((1 * masses[q]) * masses[k]) / dist_cubed) * y_diff;\n    force_qk[2] = (((1 * masses[q]) * masses[k]) / dist_cubed) * z_diff;\n    loc_forces[my_rank][q][0] -= force_qk[0];\n    loc_forces[my_rank][q][1] -= force_qk[1];\n    loc_forces[my_rank][q][2] -= force_qk[2];\n    loc_forces[my_rank][k][0] += force_qk[0];\n    loc_forces[my_rank][k][1] += force_qk[1];\n    loc_forces[my_rank][k][2] += force_qk[2];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwwwwwOwO/Parallel-program/nbody/OpenMP_solver/1"}
{"code": "for (size_t i = 0; i < npoints; ++i)\n{\n  centx = centx + cloud->points[i].x;\n  centy = centy + cloud->points[i].y;\n  centz = centz + cloud->points[i].z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/PCReconstruct/Cloud/2"}
{"code": "for (long pidx_darts_counter_temp1047 = *pidx; (pidx_darts_counter_temp1047 < endRange) && (pidx_darts_counter_temp1047 < this->inputsTPParent->lastIteration1047); pidx_darts_counter_temp1047++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1047], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/38"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    int a;\n    a = rand() % 2;\n    image[i].push_back(a);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/quick_hull_parallel/0"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  for (j = 0; j < 3000; j++)\n    if (j == 0)\n    fprintf(fp, \"%d\", result_image[i][j]);\n  else\n    fprintf(fp, \" %d\", result_image[i][j]);\n\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (n,j1,j2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/202"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    obs += norm(wf.wave[wf.in2(j, i)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/15"}
{"code": "for (i = 0; i < 512; i++)\n{\n  if (percentDiff(s[i], s_outputFromGpu[i]) > 0.7)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/BICG/bicg/35"}
{"code": "for (i = 1; i <= dimension; ++i)\n{\n  for (j = 1; j <= dimension; ++j)\n  {\n    fscanf(inputf, \"%d\", &array1[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/almazhankapan/game-of-life/game_of_life/2"}
{"code": "for (i = 0; i < nsize; i++)\n{\n  for (k = 0; k < nsize; k++)\n  {\n    matrix.a2[i][k] = 1.0;\n    matrix.b2[i][k] = 2.0;\n    matrix.c2[i][k] = 3.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avr-aics-riken/PMlib/doc/src_advanced/sub_dgemm/0"}
{"code": "for (uint32_t idx = 0; idx < dim; idx += 2)\n{\n  uint32_t i = (idx % originalW) + startingX;\n  uint32_t j = (idx / originalW) + startingY;\n  Pixel3 c = zero3f;\n  for (uint32_t y = 0; y < rows; y++)\n  {\n    int32_t jy = (j + ((ystart + y) * 2)) - startingY;\n    for (uint32_t x = 0; x < cols; x++)\n    {\n      int32_t ix = (i + ((xstart + x) * 2)) - startingX;\n      if ((((ix >= 0) && (ix < originalW)) && (jy >= 0)) && (jy < originalH))\n      {\n        double kern_elem = filter[getKernelPosition(x, y)];\n        Pixel3 px = *getPixel3(source, ix, jy);\n        c.x += px.x * kern_elem;\n        c.y += px.y * kern_elem;\n        c.z += px.z * kern_elem;\n      }\n      else\n      {\n        double kern_elem = filter[getKernelPosition(x, y)];\n        Pixel3 px = *getPixel3(source, i - startingX, j - startingY);\n        c.x += px.x * kern_elem;\n        c.y += px.y * kern_elem;\n        c.z += px.z * kern_elem;\n      }\n\n    }\n\n  }\n\n  setPixel3(dest, i / 2, j / 2, &c);\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(nThreads) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stranck/RealTimeLLF/src/OpenMP/openmp/3"}
{"code": "for (int idx = 0; idx < DATAXSIZE; idx++)\n{\n  for (int idy = 0; idy < DATAYSIZE; idy++)\n  {\n    for (int idz = 0; idz < DATAZSIZE; idz++)\n    {\n      double r = sqrt((SQ(idx - (0.5 * DATAXSIZE)) + SQ(idy - (0.5 * DATAYSIZE))) + SQ(idz - (0.5 * DATAZSIZE)));\n      if (r < r0)\n      {\n        phi[idx][idy][idz] = 1.0;\n      }\n      else\n      {\n        phi[idx][idy][idz] = -1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ace-sycl/main/0"}
{"code": "for (i = 0; i < mat2_1d; i++)\n{\n  free(matr2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/11"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    if (percentDiff(C[(i * 3072) + j], C_outputFromGpu[(i * 3072) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm_cpu/8"}
{"code": "for (j = 0; j < 1000000; j++)\n{\n  pAp = pAp + (P[j] * AP[j]);\n}\n\n", "pragma": "omp parallel for reduction(+:pAp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/CG/C/cg/0"}
{"code": "for (j = 1; j < N; j++)\n{\n  for (k = from; k < (to - j); k++)\n  {\n    if (column[k].value < column[k + 1].value)\n    {\n      auxCelda = column[k];\n      column[k] = column[k + 1];\n      column[k + 1] = aux;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cuiti/sistemasParalelos2015/TP2/tp2-omp/10"}
{"code": "for (i = 0; i < 20480; i++)\n{\n  tmp[i] = 0;\n  for (j = 0; j < 20480; j++)\n  {\n    tmp[i] = tmp[i] + (A[(i * 20480) + j] * x[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/ATAX/atax_cpu/0"}
{"code": "for (long i = 0; i <= NV; i++)\n{\n  edgeListPtr[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadPajekFormat/2"}
{"code": "for (k = 0; k <= (nz - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][j][k][m] = -frct[i][j][k][m];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/34"}
{"code": "for (int rw = 0; rw < m_nRows; rw++)\n{\n  if (!FloatEqual(data[rw][2], NoDataValue))\n  {\n    if (FloatEqual(m_1DDataWithRowCol[rw][2], NoDataValue))\n      m_1DDataWithRowCol[rw][2] = 0.0f;\n\n    m_1DDataWithRowCol[rw][0] = data[rw][0];\n    m_1DDataWithRowCol[rw][1] = data[rw][1];\n    if (data[rw][2] <= m_1DDataWithRowCol[rw][2])\n    {\n      m_1DDataWithRowCol[rw][2] = data[rw][2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/10"}
{"code": "for (int i = k + 1; i < N; i++)\n{\n  v1 = vmovq_n_f32(A[i][k]);\n  float32x4_t v2;\n  int j;\n  for (j = k + 1; j <= (N - 4); j += 4)\n  {\n    v2 = vld1q_f32(A[k] + j);\n    v0 = vld1q_f32(A[i] + j);\n    v2 = vmulq_f32(v1, v2);\n    v0 = vsubq_f32(v0, v2);\n    vst1q_f32(A[i] + j, v0);\n  }\n\n  for (j = j - 4; j < N; j++)\n    A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n\n  A[i][k] = 0;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp_SIMD/5"}
{"code": "for (int p = 0; p < (k - 1); p++)\n{\n  sum += L[k - 1][p] * U[p][j - 1];\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/croutMethod/2"}
{"code": "for (i = 0; i < nr_class; i++)\n  for (int j = i + 1; j < nr_class; j++)\n{\n  int si = start[i];\n  int sj = start[j];\n  int ci = count[i];\n  int cj = count[j];\n  int q = nz_start[i];\n  int k;\n  for (k = 0; k < ci; k++)\n    if (nonzero[si + k])\n    model->sv_coef[j - 1][q++] = f[p].alpha[k];\n\n\n  q = nz_start[j];\n  for (k = 0; k < cj; k++)\n    if (nonzero[sj + k])\n    model->sv_coef[i][q++] = f[p].alpha[ci + k];\n\n\n  ++p;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/64"}
{"code": "for (int i = 0; i < (NUMNODES * NUMNODES); i++)\n{\n  int iu = i % NUMNODES;\n  int iv = i / NUMNODES;\n  if ((((iu != 0) && (iu != (NUMNODES - 1))) && (iv != 0)) && (iv != (NUMNODES - 1)))\n  {\n    volume = volume + (fullTileArea * Height(iu, iv));\n  }\n  else\n    if (((((iu == 0) && (iv == 0)) || ((iu == (NUMNODES - 1)) && (iv == 0))) || ((iu == 0) && (iv == (NUMNODES - 1)))) || ((iu == (NUMNODES - 1)) && (iv == (NUMNODES - 1))))\n  {\n    volume = volume + ((0.25 * fullTileArea) * Height(iu, iv));\n  }\n  else\n  {\n    volume = volume + ((0.5 * fullTileArea) * Height(iu, iv));\n  }\n\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+ : volume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostNirv/Intro-to-Parallel-Programming/Volume calculation with OpenMP/Project 1/Main/0"}
{"code": "for (i = 0; i < nelements; i++)\n  result[i] = 1.0 / result[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/75"}
{"code": "for (int i = 0; i < lower_A_nzs; ++i)\n{\n  result = row_col_dot_product(full_A_indices, full_A_pointers[lower_A_rows[i]], full_A_pointers[lower_A_rows[i] + 1], full_A_pointers[lower_A_cols[i]], full_A_pointers[lower_A_cols[i] + 1]);\n  if (result != 0)\n  {\n    omp_set_lock(&writelock);\n    lower_C_rows[res_nz] = lower_A_rows[i];\n    lower_C_cols[res_nz] = lower_A_cols[i];\n    lower_C_values[res_nz] = result;\n    res_nz++;\n    omp_unset_lock(&writelock);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andriotis/Parallel-Distributed-Systems-1/openmp/3"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%d\\n\", m_pParticleData->m_vLPFOrderDown[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/51"}
{"code": "for (i = 0; i <= n; i++)\n{\n  dp[0][i] = i * pgap;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/5"}
{"code": "for (block_idx = 0; block_idx < block_limit; ++block_idx)\n{\n  MPI_Offset start_edge_index = int64_min(FILE_CHUNKSIZE * ((block_idx * nrows) + my_row), tg.nglobaledges);\n  MPI_Offset edge_count = int64_min(tg.nglobaledges - start_edge_index, FILE_CHUNKSIZE);\n  packed_edge *actual_buf = ((!tg.data_in_file) && ((block_idx % ranks_per_row) == my_col)) ? (tg.edgememory + (FILE_CHUNKSIZE * (block_idx / ranks_per_row))) : (buf);\n  if ((!tg.data_in_file) && ((block_idx % ranks_per_row) == my_col))\n  {\n    assert(((FILE_CHUNKSIZE * (block_idx / ranks_per_row)) + edge_count) <= tg.edgememory_size);\n  }\n\n  if (tg.write_file)\n  {\n    generate_kronecker_range(seed, SCALE, start_edge_index, start_edge_index + edge_count, actual_buf);\n    if (tg.data_in_file && (my_col == (block_idx % ranks_per_row)))\n    {\n      MPI_File_write_at(tg.edgefile, start_edge_index, actual_buf, edge_count, packed_edge_mpi_type, (MPI_Status *) 1);\n    }\n\n  }\n  else\n  {\n    MPI_File_read_at(tg.edgefile, start_edge_index, actual_buf, edge_count, packed_edge_mpi_type, (MPI_Status *) 1);\n  }\n\n  ptrdiff_t i;\n  for (i = 0; i < edge_count; ++i)\n  {\n    int64_t src = get_v0_from_edge(&actual_buf[i]);\n    int64_t tgt = get_v1_from_edge(&actual_buf[i]);\n    if (src == tgt)\n      continue;\n\n    if (((src / bitmap_size_in_bytes) / CHAR_BIT) == my_col)\n    {\n      has_edge[(src / CHAR_BIT) % bitmap_size_in_bytes] |= 1 << (src % CHAR_BIT);\n    }\n\n    if (((tgt / bitmap_size_in_bytes) / CHAR_BIT) == my_col)\n    {\n      has_edge[(tgt / CHAR_BIT) % bitmap_size_in_bytes] |= 1 << (tgt % CHAR_BIT);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/topanitanw/graph500_openmp/mpi/main/2"}
{"code": "for (y = 0; y < GLOBAL_GRID_W; ++y)\n  buf_grid_values[get_index_row(proc_x_indices.second, y)] = recv_buf_y[y];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/23"}
{"code": "for (int i = 0; i < p1.size(); i++)\n{\n  if (p1[i] == c)\n  {\n    p1[i] = p1[low];\n    p1[low] = p2[low];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aditi-Singla/Parallel-Distributed-Programming/Lab2 - Travelling Salesman Problem/src/tsp/2"}
{"code": "for (unsigned i = 0; i < x.size(); ++i)\n{\n  double err = sqr(re[i] - re_ref[i]) + sqr(im[i] - im_ref[i]);\n  if (err != 0)\n  {\n    (cout << format(\"error at \", i, \" : \", err)) << endl;\n    ++failures;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/3"}
{"code": "for (j = 0; j < DEV_NUM; j++)\n  num_rows[j] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/C/photomosaic/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  sum[i] = a[i] + b[i];\n  printf(\"CPU:%d\\tThread:%d\\tValue:%d\\n\", sched_getcpu(), omp_get_thread_num(), sum[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/sum of 2 arrays/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  sequential_bubble_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bubble/2"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      s = s + (r[i3][i2][i1] * r[i3][i2][i1]);\n      double _imopVarPre444;\n      double _imopVarPre445;\n      _imopVarPre444 = r[i3][i2][i1];\n      _imopVarPre445 = fabs(_imopVarPre444);\n      if (_imopVarPre445 > tmp)\n      {\n        tmp = _imopVarPre445;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/0"}
{"code": "for (;;)\n{\n  if (iz == 0)\n  {\n    value = 7.69711 - log(r4_uni(jsr));\n    break;\n  }\n\n  x = ((float) jz) * we[iz];\n  if ((fe[iz] + (r4_uni(jsr) * (fe[iz - 1] - fe[iz]))) < exp(-x))\n  {\n    value = x;\n    break;\n  }\n\n  jz = shr3_seeded(jsr);\n  iz = jz & 255;\n  if (jz < ke[iz])\n  {\n    value = ((float) jz) * we[iz];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/ziggurat_openmp_original/11"}
{"code": "for (i = 0; i < npos; i++)\n{\n  if (pos_orig[3 * i] >= 0)\n  {\n    pos[3 * i] = fmod(pos_orig[3 * i], L);\n  }\n  else\n  {\n    pos[3 * i] = L - fmod((-1) * pos_orig[3 * i], L);\n  }\n\n  if (pos_orig[(3 * i) + 1] >= 0)\n  {\n    pos[(3 * i) + 1] = fmod(pos_orig[(3 * i) + 1], L);\n  }\n  else\n  {\n    pos[(3 * i) + 1] = L - fmod((-1) * pos_orig[(3 * i) + 1], L);\n  }\n\n  if (pos_orig[(3 * i) + 2] >= 0)\n  {\n    pos[(3 * i) + 2] = fmod(pos_orig[(3 * i) + 2], L);\n  }\n  else\n  {\n    pos[(3 * i) + 2] = L - fmod((-1) * pos_orig[(3 * i) + 2], L);\n  }\n\n  if (pos[3 * i] < 0)\n  {\n    printf(\"pos_orig = %lf pos defect = %lf and i = %d and L =%lf\\n\", pos_orig[3 * i], pos[3 * i], i, L);\n  }\n\n  next[i] = -1;\n  forces[(3 * i) + 0] = 0;\n  forces[(3 * i) + 1] = 0;\n  forces[(3 * i) + 2] = 0;\n  idx = (int) ((pos[3 * i] / L) * boxdim);\n  idy = (int) ((pos[(3 * i) + 1] / L) * boxdim);\n  idz = (int) ((pos[(3 * i) + 2] / L) * boxdim);\n  bp = &b[idx][idy][idz];\n  next[i] = bp->head;\n  bp->head = i;\n}\n\n", "pragma": "omp parallel for schedule(static) private(i, idx, idy, idz, bp) shared(b, next) num_threads(NTHREADS)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/proj1/bd/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  dpp += u[i] * v[i];\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/dot_product/0"}
{"code": "for (int k = 0, end = 0; k < 100; ++k)\n{\n  for (int i = 0; i < length; ++i)\n  {\n    if (FM[i] < 0.0)\n      Absolute[i] = -FM[i];\n    else\n      Absolute[i] = FM[i];\n\n  }\n\n  FindExtrema(Absolute, length, UpExtrema, UpLength, LowExtrema, LowLength);\n  if (UpLength < 3)\n    break;\n\n  Spline(Absolute, UpEnvelope, length, UpExtrema, UpLength, 0);\n  for (int i = 0; i < length; ++i)\n  {\n    if (UpEnvelope[i] < 0.01)\n      UpEnvelope[i] = 0.01;\n\n    FM[i] = FM[i] / UpEnvelope[i];\n  }\n\n  end = 1;\n  for (int i = 0; i < length; ++i)\n  {\n    if ((FM[i] > 1.0) || (FM[i] < (-1.0)))\n      end = 0;\n\n  }\n\n  if (end)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/19"}
{"code": "for (int i = 0; i < (mNumHiddenLayers + 1); ++i)\n{\n  mNeuronLayers[i]->reset();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KawhiX/BP-Network-ParallelComputing/OMP/src/NetWork/0"}
{"code": "for (i = 0; i < N; i += 2)\n{\n  merge(a + tarr[i], a + tarr[i + 1], tarr[i + 1] - tarr[i], tarr[i + 2] - tarr[i + 1]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for private(i) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/4"}
{"code": "for (int64_t i = 0; i < vector_size; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_performance/tiny_bench/src/dense_vector/0"}
{"code": "for (i = 0; i < parN; i++)\n{\n  j *= STATE_N;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/6"}
{"code": "for (int n = 0; n < N; n++)\n{\n  z[n] = distribution(gen);\n  int val = 0;\n  for (int j = 0; j < M; j++)\n  {\n    double r = distribution(gen);\n    val += (pow(sqrt(1 - ccov), M - (j + 1)) * r) * P[j][n];\n  }\n\n  x[i][n] = m[t & 1][n] + (sigma * ((pow(sqrt(1 - ccov), M) * z[n]) + (sqrt(ccov) * val)));\n}\n\n", "pragma": "            #pragma omp prallel for shared(x,m,sigma,ccov,p,z)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/RmES_omp_alt/3"}
{"code": "for (; i < size; i++)\n{\n  m += (uint64_t) buffer[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/8"}
{"code": "for (i = 0; i < nvtxs; i++)\n{\n  pos[cot[i]] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/8"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    aux = cube[x][y];\n    while (aux != 0)\n    {\n      if (aux->status == 1)\n      {\n        z = aux->z;\n        tmp = mod(x + 1, size);\n        omp_set_lock(&locks[tmp][y]);\n        add_node(&cube[tmp][y], 1, 0, z);\n        omp_unset_lock(&locks[tmp][y]);\n        tmp = mod(x - 1, size);\n        omp_set_lock(&locks[tmp][y]);\n        add_node(&cube[tmp][y], 1, 0, z);\n        omp_unset_lock(&locks[tmp][y]);\n        tmp = mod(y + 1, size);\n        omp_set_lock(&locks[x][tmp]);\n        add_node(&cube[x][tmp], 1, 0, z);\n        omp_unset_lock(&locks[x][tmp]);\n        tmp = mod(y - 1, size);\n        omp_set_lock(&locks[x][tmp]);\n        add_node(&cube[x][tmp], 1, 0, z);\n        omp_unset_lock(&locks[x][tmp]);\n        tmp = mod(z + 1, size);\n        omp_set_lock(&locks[x][y]);\n        add_node(&cube[x][y], 1, 0, tmp);\n        omp_unset_lock(&locks[x][y]);\n        tmp = mod(z - 1, size);\n        omp_set_lock(&locks[x][y]);\n        add_node(&cube[x][y], 1, 0, tmp);\n        omp_unset_lock(&locks[x][y]);\n      }\n\n      aux = aux->next;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbsousa01/Game-of-Life3D/life3d-omp/life3d-omp/0"}
{"code": "for (i = 1; i < nr_class; i++)\n  start[i] = start[i - 1] + count[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/50"}
{"code": "for (register int x = 1; x < (height - 1); x++)\n{\n  for (register int y = 1; y < (width - 1); y++)\n  {\n    x_sum = ((((image->pixels[((x + 1) * width) + (y + 1)] - image->pixels[((x + 1) * width) + (y - 1)]) + (image->pixels[(x * width) + (y + 1)] << 1)) - (image->pixels[(x * width) + (y - 1)] << 1)) + image->pixels[((x - 1) * width) + (y + 1)]) - image->pixels[((x - 1) * width) + (y - 1)];\n    y_sum = ((((image->pixels[((x + 1) * width) + (y + 1)] + (image->pixels[((x + 1) * width) + y] << 1)) + image->pixels[((x + 1) * width) + (y - 1)]) - image->pixels[((x - 1) * width) + (y + 1)]) - (image->pixels[((x - 1) * width) + y] << 1)) - image->pixels[((x - 1) * width) + (y - 1)];\n    new_image->pixels[(x * width) + y] = ((abs(x_sum) + abs(y_sum)) > maxval) ? (maxval) : (0);\n  }\n\n}\n\n", "pragma": "omp parallel for private(x_sum, y_sum) schedule(static, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akastoras/sobel-filter/sobel_filter/0"}
{"code": "for (i = 0; i < bheight; ++i)\n  memmove(&data[((i + 1) * (bwidth + 2)) * channels], &data[(((i + 1) * (bwidth + 2)) + 1) * channels], channels * (sizeof(unsigned char)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/5"}
{"code": "for (int ii = HALO_PAD; ii < (z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (HALO_PAD + depth); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX)) + (((ii - HALO_PAD) * depth) * _chunk.innerX);\n      buffer[bufIndex] = field[(((ii * y) * x) + (jj * x)) + kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/3"}
{"code": "for (k = 0; k < d[2]; k++)\n{\n  for (jj = 0; jj <= (d[1] - fftblock); jj += fftblock)\n  {\n    for (j = 0; j < fftblock; j++)\n    {\n      for (i = 0; i < d[0]; i++)\n      {\n        y0[i][j].real = x[k][j + jj][i].real;\n        y0[i][j].imag = x[k][j + jj][i].imag;\n      }\n\n    }\n\n    int _imopVarPre247;\n    int _imopVarPre248;\n    _imopVarPre247 = d[0];\n    _imopVarPre248 = logd[0];\n    cfftz(is, _imopVarPre248, _imopVarPre247, y0, y1);\n    for (j = 0; j < fftblock; j++)\n    {\n      for (i = 0; i < d[0]; i++)\n      {\n        xout[k][j + jj][i].real = y0[i][j].real;\n        xout[k][j + jj][i].imag = y0[i][j].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/1"}
{"code": "for (counter = 0; counter < number_of_words; counter++)\n{\n  if (rank == 0)\n  {\n    strcpy(szSearchWord, words[counter]);\n    hasSearchWord = rank;\n    searchWordLength = strlen(szSearchWord);\n  }\n\n  MPI_Bcast(&searchWordLength, 1, (MPI_Datatype) 0x4c000405, hasSearchWord, 1);\n  MPI_Bcast(szSearchWord, searchWordLength + 1, (MPI_Datatype) 0x4c000101, hasSearchWord, 1);\n  int portion = 0;\n  int startNum = 0;\n  int endNum = 0;\n  if (rank == 0)\n  {\n    portion = numberOfFiles / nTasks;\n    startNum = 1;\n    endNum = portion;\n    int i;\n    for (i = 1; i < nTasks; i++)\n    {\n      int curStartNum = (i * portion) + 1;\n      int curEndNum = (i + 1) * portion;\n      if (i == (nTasks - 1))\n      {\n        curEndNum = numberOfFiles;\n      }\n\n      if (curStartNum < 0)\n      {\n        curStartNum = 0;\n      }\n\n      MPI_Send(&curStartNum, 1, (MPI_Datatype) 0x4c000405, i, 1, 1);\n      MPI_Send(&curEndNum, 1, (MPI_Datatype) 0x4c000405, i, 1, 1);\n    }\n\n  }\n  else\n  {\n    MPI_Status status;\n    MPI_Recv(&startNum, 1, (MPI_Datatype) 0x4c000405, 0, 1, 1, &status);\n    MPI_Recv(&endNum, 1, (MPI_Datatype) 0x4c000405, 0, 1, 1, &status);\n  }\n\n  int df = 0;\n  int curIndex;\n  for (curIndex = startNum; curIndex <= endNum; curIndex++)\n  {\n    int *tf;\n    tf = malloc(sizeof(int));\n    char path[10] = \"bible/\";\n    char file_index[5];\n    char ext[5] = \".txt\";\n    sprintf(file_index, \"%d\", curIndex);\n    char *name_with_extension;\n    name_with_extension = malloc((strlen(path) + strlen(file_index)) + strlen(ext));\n    strcpy(name_with_extension, path);\n    strcat(name_with_extension, file_index);\n    strcat(name_with_extension, ext);\n    int result = Search_in_File(name_with_extension, szSearchWord, tf);\n    if (result == 1)\n      df++;\n\n    FILE *tempf = fopen(\"tf.txt\", \"a\");\n    fprintf(tempf, \"%d %d %d\\n\", counter, curIndex, *tf);\n    fclose(tempf);\n  }\n\n  if (rank == 0)\n  {\n    MPI_Status status;\n    int i;\n    for (i = 1; i < nTasks; i++)\n    {\n      int temp;\n      MPI_Recv(&temp, 1, (MPI_Datatype) 0x4c000405, i, 3, 1, &status);\n      df += temp;\n    }\n\n  }\n  else\n    MPI_Send(&df, 1, (MPI_Datatype) 0x4c000405, 0, 3, 1);\n\n  if (rank == 0)\n  {\n    idf[counter] = numberOfFiles / df;\n    fprintf(dff, \"<%s , %f>\\n\", szSearchWord, idf[counter]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/docfreq2/6"}
{"code": "for (int i = 0; i < 10000; i++)\n  arr[i] = rand() % 1048576;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/unnikrishnan-c/hpcshiksha-openmp/Part2_Unni/findmax/findmax/1"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  if (((candidate.first == 0) && (candidate.second == 0)) && (visited[0] == NODE_VISITED))\n    candidate = make_pair(-1, INT32_MAX);\n\n  if (((visited[i] == NODE_UNVISITED) && (disFromStartOpenmp[i] != UNKNOWN_DISTANCE)) && (disFromStartOpenmp[i] < curClosestDistance))\n  {\n    curClosestNode = i;\n    curClosestDistance = disFromStartOpenmp[i];\n    candidate = make_pair(curClosestNode, curClosestDistance);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(minimum:candidate) firstprivate(curClosestDistance,curClosestNode)  ", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  factor = ((i % 2) == 0) ? (1.0) : (-1.0);\n  sum += factor / ((2 * i) + 1);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: sum) private(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/07_omp_pi/0"}
{"code": "for (train_counter = 0; train_counter < train_data.n; train_counter++)\n{\n  train_j = train_counter * image_size;\n  z = (px = (px_sum = 0));\n  while (z < image_size)\n  {\n    px = test_data.img[test_j + z] - train_data.img[train_j + z];\n    px_sum += px * px;\n    ++z;\n  }\n\n  if (px_sum < kk[KV - 1].dst)\n  {\n    kk[KV - 1].dst = px_sum;\n    kk[KV - 1].lbl = train_data.lbl[train_counter];\n    qsortk(kk, 0, KV - 1);\n  }\n\n}\n\n", "pragma": "omp for private(train_counter, train_j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xbasics/knn_openmp_mnist/knn_openmp/0"}
{"code": "for (j = f; j < m; j++)\n{\n  mj0 = m * j;\n  t = A + j;\n  c0 = C + mj0;\n  for (k = 0; k < w; k += 6)\n  {\n    km0 = k * m;\n    km1 = (k + 1) * m;\n    km2 = (k + 2) * m;\n    km3 = (k + 3) * m;\n    km4 = (k + 4) * m;\n    km5 = (k + 5) * m;\n    b00 = _mm_load1_ps(t + km0);\n    b01 = _mm_load1_ps(t + km1);\n    b02 = _mm_load1_ps(t + km2);\n    b03 = _mm_load1_ps(t + km3);\n    b04 = _mm_load1_ps(t + km4);\n    b05 = _mm_load1_ps(t + km5);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km1), b01));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km2), b02));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km3), b03));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km4), b04));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km5), b05));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n      *((C + i) + mj0) += (*((A + i) + km1)) * (*(t + km1));\n      *((C + i) + mj0) += (*((A + i) + km2)) * (*(t + km2));\n      *((C + i) + mj0) += (*((A + i) + km3)) * (*(t + km3));\n      *((C + i) + mj0) += (*((A + i) + km4)) * (*(t + km4));\n      *((C + i) + mj0) += (*((A + i) + km5)) * (*(t + km5));\n    }\n\n  }\n\n  for (k = w; k < n; k++)\n  {\n    km0 = k * m;\n    b00 = _mm_load1_ps(t + km0);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(t,s,c0,km0,km1,km2,km3,km4,km5,j,k,i,mj0,c00,b00,b01,b02,b03,b04,b05)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzpanda/CS61C-Proj3-Matrix-Decryption-/proj3-6-6-out/1"}
{"code": "for (m_imopVarPre78 = 0; m_imopVarPre78 < 5; m_imopVarPre78++)\n{\n  double _imopVarPre154;\n  double _imopVarPre155;\n  _imopVarPre154 = sum[m_imopVarPre78] / (((nx0 - 2) * (ny0 - 2)) * (nz0 - 2));\n  _imopVarPre155 = sqrt(_imopVarPre154);\n  sum[m_imopVarPre78] = _imopVarPre155;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/24"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double t = sqrt((inpG[2 * i] * inpG[2 * i]) + (inpG[(2 * i) + 1] * inpG[(2 * i) + 1]));\n  if (t != 0)\n  {\n    maxG = (minG = log(t));\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/15. filter (mkl)/filter/5"}
{"code": "for (int v = 0; v < n; v++)\n{\n  if (graph[source][v] == 1)\n  {\n    enqueue(frontier, v);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/9"}
{"code": "for (int i = 0; i < (kBuckets - 1); i++)\n{\n  tresholds[i] = kLeftBucketBoundary + ((i + 1) * kBucketWidth);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olszewskip/openmp_notes/locks0/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  maskedImageR[i] = 0;\n  maskedImageG[i] = 0;\n  maskedImageR[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/EdgeDetectionfinalparallel/1"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    int nn = ((((((currWorld[i + 1][j] + currWorld[i - 1][j]) + currWorld[i][j + 1]) + currWorld[i][j - 1]) + currWorld[i + 1][j + 1]) + currWorld[i - 1][j - 1]) + currWorld[i - 1][j + 1]) + currWorld[i + 1][j - 1];\n    nextWorld[i][j] = (currWorld[i][j]) ? ((nn == 2) || (nn == 3)) : (nn == 3);\n    sum += nextWorld[i][j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2) private(i,j) reduction(+:sum) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harunsasmaz/Game-Of-Life/source code/life-prl/0"}
{"code": "for (int i = 0; i < N; i++)\n  y.push_back(0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/axpy/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[i] = 0.0;\n  for (j = 0; j < length[i]; j++)\n  {\n    k = (j * n) + i;\n    y[i] += data[k] * x[indices[k]];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads) private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisaho/openmp/solver/3"}
{"code": "for (i = 1; i < (((L / 1) + 2) - 1); i++)\n{\n  j = ((L / 5) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = gre[i];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = gre[i];\n\n  j = 0;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = gro[i];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = gro[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/44"}
{"code": "for (i = 1; i <= ni; i++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    lhs[0][i][m] = 0.0;\n    lhsp[0][i][m] = 0.0;\n    lhsm[0][i][m] = 0.0;\n    lhs[nj][i][m] = 0.0;\n    lhsp[nj][i][m] = 0.0;\n    lhsm[nj][i][m] = 0.0;\n  }\n\n  lhs[0][i][2] = 1.0;\n  lhsp[0][i][2] = 1.0;\n  lhsm[0][i][2] = 1.0;\n  lhs[nj][i][2] = 1.0;\n  lhsp[nj][i][2] = 1.0;\n  lhsm[nj][i][2] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/initialize/3"}
{"code": "for (i = 1; i <= m; i++)\n{\n  volume = volume / ((double) i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task2_simplex/simplex_modified_for_omp/simplex/9"}
{"code": "for (i = 0; i < (input->N - 1); i++)\n{\n  shared_index = (omp_get_thread_num() * input->K) + points[i].cluster_id;\n  for (j = i + 1; j < input->N; j++)\n  {\n    if (points[i].cluster_id == points[j].cluster_id)\n    {\n      distance = calculate_distance_between_positions(&points[i].position, &points[j].position);\n      if (distance > shared_clusters_max_points_distance[shared_index])\n      {\n        shared_clusters_max_points_distance[shared_index] = distance;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(shared_index,j,distance)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/1"}
{"code": "for (i = 1; i <= 1000; i++)\n{\n  sum0 = sum0 + i;\n  i0 = i;\n}\n\n", "pragma": "omp for schedule(static,7) lastprivate(i0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_lastprivate/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (arr[i] > max)\n  {\n    max = arr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.1/atomic/test_atomic_compare/1"}
{"code": "for (i3 = 1; i3 < e3; i3++)\n{\n  x1 = x0;\n  for (i2 = 1; i2 < e2; i2++)\n  {\n    xx = x0;\n    double *_imopVarPre476;\n    double _imopVarPre477;\n    double *_imopVarPre478;\n    _imopVarPre476 = &z[i3][i2][0];\n    _imopVarPre477 = pow(5.0, 13);\n    _imopVarPre478 = &xx;\n    vranlc(d1, _imopVarPre478, _imopVarPre477, _imopVarPre476);\n    double *_imopVarPre480;\n    double _imopVarPre481;\n    _imopVarPre480 = &x1;\n    _imopVarPre481 = randlc(_imopVarPre480, a1);\n    rdummy = _imopVarPre481;\n  }\n\n  double *_imopVarPre483;\n  double _imopVarPre484;\n  _imopVarPre483 = &x0;\n  _imopVarPre484 = randlc(_imopVarPre483, a2);\n  rdummy = _imopVarPre484;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    c[i] += a[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/matrix_sum_omp/0"}
{"code": "for (i = 0; i < ndim; i++)\n{\n  amu[i] += amu[(i + (ndim * nx)) + (nnxe * ny)];\n  amu[(i + (ndim * nx)) + (nnxe * ny)] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/16"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  sumM = 0.0;\n  for (int j = 0; j < spmatrix->iia[i]; j++)\n  {\n    real_t hx = ABS(spmatrix->val[i][j]);\n    sumM += hx;\n    if (spmatrix->jja[i][j] == i)\n    {\n      sumP = spmatrix->val[i][j];\n      sumM -= hx;\n    }\n\n  }\n\n  eMax = (eMax < (sumP + sumM)) ? (sumP + sumM) : (eMax);\n  eMin = (eMin > (sumP - sumM)) ? (sumP - sumM) : (eMin);\n}\n\n", "pragma": "omp parallel for private(sumM,sumP) reduction(max:eMax) reduction(min:eMin)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/0"}
{"code": "for (int j = 0; j < (width * height); j++)\n  edgeimage[j] = (sum[j] > biggest) ? (biggest) : (sum[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moreflexible/openMpi/filter/7"}
{"code": "for (i = 0; i < num_elements; i++)\n{\n  histogram[input_data[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-Histogram/histogram/1"}
{"code": "for (char i = 0; i < 10; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/1"}
{"code": "for (int p = 0; p < (k - 1); p++)\n{\n  sum += L[k - 1][p] * U[p][i - 1];\n}\n\n", "pragma": "                        #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/choleskyMethod/3"}
{"code": "for (i = 1; i < (600 - 1); i++)\n{\n  for (j = 1; j < (600 - 1); j++)\n  {\n    r[i][j] = r[i][j] + (2 * ((((4 * alpha) + (((1 / 2) * dt) * potential[i][j])) * im[i][j]) - (alpha * (((im[i + 1][j] + im[i - 1][j]) + im[i][j + 1]) + im[i][j - 1]))));\n    im[i][j] = im[i][j] - (2 * ((((4 * alpha) + (((1 / 2) * dt) * potential[i][j])) * r[i][j]) + (alpha * (((r[i + 1][j] + r[i - 1][j]) + r[i][j + 1]) + r[i][j - 1]))));\n    p[i][j] = r[i][j] + (I * im[i][j]);\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, chunk) collapse(2) reduction(+:dt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bcoressh/hpc/src/paralelo/pprg/0"}
{"code": "for (int i = 0; i < crewN; i++)\n{\n  for (int j = 0; j < tileCrN; j++)\n    cout << ((islandParts[i][j]) ? (\"1 \") : (\"0 \"));\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/foxbeer/OpenMP_HW/OpenMP_HW/OpenMP_HW/2"}
{"code": "for (i = 1; i < (1 << (M - 16)); i++)\n  qq[i] = qq[i - 1] + 10;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/EP/ep/4"}
{"code": "for (i = 0; i < nrows; ++i)\n{\n  t = 0.0;\n  for (j = rowPtr[i]; j < rowPtr[i + 1]; ++j)\n  {\n    startCol = colInd[j];\n    tt = 0;\n    #pragma ivdep\n    for (k = nnzPtr[j]; k < nnzPtr[j + 1]; ++k)\n    {\n      t += value[k] * x[startCol + tt];\n      tt++;\n    }\n\n  }\n\n  r[i] = t;\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j, k, startCol, t, tt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/blocked/0"}
{"code": "for (j = 1; j < 2; j++)\n{\n  dd[0] += dd[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/30"}
{"code": "for (unsigned i = 1; i < x.size(); ++i)\n{\n  x[i] = xydist(random_sequence);\n  y[i] = xydist(random_sequence);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lloda/slatec-bessel-cpp/test/test-slatec/0"}
{"code": "for (j = i + 1; j < num_var; j++)\n  for (k = num_var; k >= 0; k--)\n{\n  var[(j * (num_var + 1)) + k] -= (var[(i * (num_var + 1)) + k] * var[(j * (num_var + 1)) + i]) / var[(i * (num_var + 1)) + i];\n}\n\n\n", "pragma": "\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/workout_3_gaussian_elimination/linearAlgebra_16EE30025/2"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = nppmx * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[(3 * i) + (mxv3 * j)] = fxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[(1 + (3 * i)) + (mxv3 * j)] = fxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[(2 + (3 * i)) + (mxv3 * j)] = fxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[(3 * i) + (mxv3 * j)] = bxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[(1 + (3 * i)) + (mxv3 * j)] = bxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[(2 + (3 * i)) + (mxv3 * j)] = bxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = (3 * (nn - noff)) + (mxv3 * (mm - moff));\n    amx = 1.0 - dxp;\n    amy = 1.0 - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += mxv3;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += mxv3;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[2 + (idimp * (j + npoff))] + dx;\n    acy = ppart[3 + (idimp * (j + npoff))] + dy;\n    acz = ppart[4 + (idimp * (j + npoff))] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0 / (1.0 + omt);\n    omt = 0.5 * (1.0 - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[2 + (idimp * (j + npoff))] = dx;\n    ppart[3 + (idimp * (j + npoff))] = dy;\n    ppart[4 + (idimp * (j + npoff))] = dz;\n    dx = x + (dx * dtc);\n    dy = y + (dy * dtc);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,ih,nh,x,y,dxp,dyp,amx,amy, dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3, rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery,sum1,sfxy, sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  v[i] = (int *) calloc(n, sizeof(int));\n  for (int j = 0; j < n; j++)\n    v[i][j] = INF;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luan-vilela/Parallel-Computing-Trabalho-1/matrixPar/0"}
{"code": "for (int thread = 0; thread < (nb_threads - 1); thread++)\n{\n  share = make_pair(added, added + portion);\n  shares.emplace_back(share);\n  added += portion;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/mpi+openmp/src/nbody_mpi+openmp/4"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  for (j = i + 1; j < n; j++)\n  {\n    if (x[j] < x[i])\n    {\n      tmp = x[i];\n      x[i] = x[j];\n      x[j] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/1"}
{"code": "for (int i = 0; i < vector_length; i++)\n{\n  v(i) = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/2"}
{"code": "for (i = 1; i < size; i++)\n  if (mat[i] > mat[privMaxIdx])\n  privMaxIdx = i;\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AdoniasAlcantara/project4-omp/src/parallel/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = i; j < n; ++j)\n  {\n    ltm[j][i] = mat[j][i];\n    for (int k = 0; k < i; ++k)\n    {\n      ltm[j][i] -= ltm[j][k] * utm[k][i];\n    }\n\n  }\n\n  utm[i][i] = 1;\n  for (int j = i + 1; j < n; ++j)\n  {\n    utm[i][j] = mat[i][j];\n    for (int k = 0; k < i; ++k)\n    {\n      utm[i][j] -= ltm[i][k] * utm[k][j];\n    }\n\n    utm[i][j] /= ltm[i][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Doolittle_LU_decomposition_OpenMP/4"}
{"code": "for (int i = 0; i < len; i++)\n  for (int j = 0; j < n; j++)\n  a[i] += x[(j * len) + i];\n\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/6"}
{"code": "for (i = 0; i < m; i++)\n{\n  scanf(\"%f\", &b[i][0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/normalequation/2"}
{"code": "for (int y = y0; y < y1; y++)\n{\n  int yLine = WORLD_WIDTH * y;\n  for (int x = x0; x < x1; x++)\n  {\n    int cnt = 0;\n    int group = 0;\n    for (int yy = y - 1; yy <= (y + 1); yy++)\n    {\n      for (int xx = x - 1; xx <= (x + 1); xx++)\n      {\n        if (m_matSrc[(WORLD_WIDTH * yy) + xx].age != CELL_DEAD)\n        {\n          cnt++;\n          group += m_matSrc[(WORLD_WIDTH * yy) + xx].group;\n        }\n\n      }\n\n    }\n\n    updateCell(x, yLine, cnt, group);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iwatake2222/FastGameOfLife/GameOfLife/LogicGroup/2"}
{"code": "for (int k = 1; k <= ((int) m_flowInIndex[id][0]); ++k)\n{\n  int flowInID = (int) m_flowInIndex[id][k];\n  Qin += m_Qkin[flowInID];\n  Sin += m_Qsn[flowInID];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/erosion/KinWavSed_OL/KinWavSed_OL/3"}
{"code": "for (int i = 1; i < (DIM - 1); i++)\n  for (int j = 1; j < (DIM - 1); j++)\n  TABLE[(i * DIM) + j] = 4;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/15"}
{"code": "for (int i = 0; i < height; i++)\n{\n  int ri = -1;\n  int rj = -1;\n  for (int j = 0; j < width; j++)\n  {\n    double di = i - i0;\n    double dj = j - j0;\n    double r = sqrt((di * di) + (dj * dj));\n    double theta = (PI / 256.0) * r;\n    int ri = (int) (((di * cos(theta)) - (dj * sin(theta))) + i0);\n    int rj = (int) (((di * sin(theta)) + (dj * cos(theta))) + j0);\n    if ((((ri >= 0) && (rj >= 0)) && (ri < height)) && (rj < width))\n      processedDataParallel[i][j] = imageData[ri][rj];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/15"}
{"code": "for (int i = 0; i < ((strlen(string) - strlen(substring)) + 1); i++)\n{\n  int matches_count = 0;\n  for (int j = 0; j < strlen(substring); j++)\n  {\n    if (string[i + j] != substring[j])\n      break;\n\n    matches_count++;\n  }\n\n  if (matches_count == strlen(substring))\n  {\n    result = i;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task7/OpenMPtask7/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    for (k = 0; k < size; ++k)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a,b,c) private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/matmul/0"}
{"code": "for (int i = 0; i < (N - 1); ++i)\n{\n  sum += (x[i + 1] - x[i]) * (fvals[i] + fvals[i + 1]);\n}\n\n", "pragma": "omp parallel for reduction(+:sum) num_threads(num_threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astrophpeter/C-OpenMP-MPI/homework3/src/integrate/0"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"b[%d] = %d. \\n\", i, b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_work_sharing_construct_single_directive/1"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  int fin = -1;\n  MPI_Send(&fin, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sheld0/parallel_raytracer/raytracer/3"}
{"code": "for (int i = 1; i < (YDIM - 1); i++)\n  for (int j = 1; j < (XDIM - 1); j++)\n  Lu[i][j] = (((((-4) * u[i][j]) + u[i + 1][j]) + u[i - 1][j]) + u[i][j + 1]) + u[i][j - 1];\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/avanlent/OpenMP_Android/app/src/main/cpp/Laplacian/1"}
{"code": "for (i = 1; i < thread; i++)\n  if (sum < sum_p[i])\n  sum = sum_p[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jr/jacobi_omp/6"}
{"code": "for (i = ni - 2; i >= 0; i--)\n  x[i] = x[i] - (c[i] * x[i + 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sheath-omp/main/11"}
{"code": "for (int i = 0; i < n; i++)\n  sum += arr[i];\n\n", "pragma": "      #pragma omp parallel for schedule(static, granularity) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/reduce/0"}
{"code": "for (j = my_start; j <= my_end; j++)\n{\n  for (i = 0; i < ((int) floor(WIDTH / 1.0)); i++)\n  {\n    if (((i + j) % 2) == 0)\n    {\n      next_ptr[j - my_start][i] = get_val_par(U_Curr_Above, current_ptr, U_Curr_Below, my_rank, i, j) + ((W / 4) * (((((get_val_par(U_Curr_Above, next_ptr, U_Curr_Below, my_rank, i - 1, j) + get_val_par(U_Curr_Above, next_ptr, U_Curr_Below, my_rank, i + 1, j)) + get_val_par(U_Curr_Above, next_ptr, U_Curr_Below, my_rank, i, j - 1)) + get_val_par(U_Curr_Above, next_ptr, U_Curr_Below, my_rank, i, j + 1)) - (4 * get_val_par(U_Curr_Above, next_ptr, U_Curr_Below, my_rank, i, j))) - (pow(1.0, 2) * f(i, j))));\n      enforce_bc_par(next_ptr, my_rank, i, j);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/357r4bd/2d-heat/src/openmp-2dheat/2"}
{"code": "for (long long idx = 0; idx < M11; idx++)\n{\n  upper_tri[idx] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/11"}
{"code": "for (i = 0; i < N; i++)\n{\n  A[i] = (int *) malloc(N * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex2/parallel/OpenMP/fwt_parfor/11"}
{"code": "for (int k = 0; k < lastNode; k++)\n{\n  finalDepth[k] = -10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac3/EulerTour_EREW_OpenMP/2"}
{"code": "for (i = 0; i < public.mask_conv_elem; i++)\n{\n  if (private.d_mask_conv[i] > fin_max_val)\n  {\n    fin_max_val = private.d_mask_conv[i];\n    fin_max_coo = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/18"}
{"code": "for (int i = 0; i < 2359296; i++)\n{\n  *(matrix_a + i) = 0.1f;\n  *(matrix_b + i) = 0.2f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RaffaelSchemmer/ParallelMatrix/matrixO/2"}
{"code": "for (int i = 0; i < l; ++i)\n  for (int j = 0; j < n; ++j)\n  for (int k = 0; k < m; ++k)\n  R[i][j] += P[i][k] * Q[k][j];\n\n\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/MatrixMultiplication/mm_par1/2"}
{"code": "for (int i = 0; i < K; i++)\n{\n  cluster_mean[i] = points[i][0];\n  cluster_count[i] = 1;\n  points[i][1] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/7_points_clustering/points_clustering/1"}
{"code": "for (int x = 0; x < MAP_SIZE; ++x)\n{\n  for (int y = 0; y < MAP_SIZE; ++y)\n  {\n    if (problemData.islandMap[x][y] >= LAND_THRESHOLD)\n    {\n      problemData.waveIntensity[0][x][y] = 0.0f;\n      problemData.waveIntensity[1][x][y] = 0.0f;\n    }\n    else\n    {\n      problemData.waveIntensity[0][x][y] = perlinNoise.accumulatedOctaveNoise2D_0_1((x * FREQUENCY_WAVES) / MAP_SIZE, (y * FREQUENCY_WAVES) / MAP_SIZE, OCTAVES_WAVES) * clamp(4.0f * (LAND_THRESHOLD - problemData.islandMap[x][y]), 0.0f, 1.0f);\n      problemData.waveIntensity[1][x][y] = problemData.waveIntensity[0][x][y];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/Utility/1"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Matrix_mult/matrix_mult_unblocked/0"}
{"code": "for (i = r; i < (((ii + bsize) < 5000) ? (ii + bsize) : (5000)); i = i + loop_unroll_limit)\n{\n  for (j = jj; j < (((jj + bsize) < 5000) ? (jj + bsize) : (5000)); j++)\n  {\n    for (h = 0; h < loop_unroll_limit; h++)\n    {\n      B[i + h][j] = A[j][i + h];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/TiledTranspose/tiled_transpose_with_loop_unroll_parallel_for_i/0"}
{"code": "for (int i = 0; i < n1; ++i)\n{\n  for (int j = 0; j < n2; ++j)\n  {\n    int sign = rand() % 2;\n    w1[i][j] = ((double) (rand() % 6)) / 10.0;\n    if (sign == 1)\n    {\n      w1[i][j] = -w1[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/6"}
{"code": "for (int i = 0; i < nU; i++)\n{\n  free((*B)[i]);\n  free((*L)[i]);\n  free((*newL)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/12"}
{"code": "for (int j = 0; j < uncropped_dim.y; j++)\n{\n  const uint8_t * const curr_line_end = getDataUncropped(uncropped_dim.x - 1, j) + bpp;\n  PoisonMemoryRegion(curr_line_end, padding);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/common/RawImage/1"}
{"code": "for (i = 0; i < n; i++)\n  suma += a[i];\n\n", "pragma": "omp parallel for reduction(+:suma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/6/reduction-clause/0"}
{"code": "for (i = 0; i < c_nx; i++)\n{\n  for (j = 0; j < c_ny; j++)\n  {\n    for (k = 0; k < c_nz; k++)\n    {\n      for (ii = 0; ii < 2; ii++)\n      {\n        for (jj = 0; jj < 2; jj++)\n        {\n          for (kk = 0; kk < 2; kk++)\n          {\n            idi = (2 * i) + ii;\n            idj = (2 * j) + jj;\n            idk = (2 * k) + kk;\n            if (((idi < f_nx) && (idj < f_ny)) && (idk < f_nz))\n            {\n              if (((ii == 0) && (jj == 0)) && (kk == 0))\n                f->f3d[idi][idj][idk] = c->f3d[i][j][k];\n              else\n                if (((ii == 0) && (jj == 0)) && (kk == 1))\n                f->f3d[idi][idj][idk] = 0.5 * (c->f3d[i][j][k] + c->f3d[i][j][k + 1]);\n              else\n                if (((ii == 0) && (jj == 1)) && (kk == 0))\n                f->f3d[idi][idj][idk] = 0.5 * (c->f3d[i][j][k] + c->f3d[i][j + 1][k]);\n              else\n                if (((ii == 0) && (jj == 1)) && (kk == 1))\n                f->f3d[idi][idj][idk] = 0.25 * (((c->f3d[i][j][k] + c->f3d[i][j + 1][k]) + c->f3d[i][j][k + 1]) + c->f3d[i][j + 1][k + 1]);\n              else\n                if (((ii == 1) && (jj == 0)) && (kk == 0))\n                f->f3d[idi][idj][idk] = 0.5 * (c->f3d[i][j][k] + c->f3d[i + 1][j][k]);\n              else\n                if (((ii == 1) && (jj == 0)) && (kk == 1))\n                f->f3d[idi][idj][idk] = 0.25 * (((c->f3d[i][j][k] + c->f3d[i + 1][j][k]) + c->f3d[i][j][k + 1]) + c->f3d[i + 1][j][k + 1]);\n              else\n                if (((ii == 1) && (jj == 1)) && (kk == 0))\n                f->f3d[idi][idj][idk] = 0.25 * (((c->f3d[i][j][k] + c->f3d[i][j + 1][k]) + c->f3d[i + 1][j][k]) + c->f3d[i + 1][j + 1][k]);\n              else\n                if (((ii == 1) && (jj == 1)) && (kk == 1))\n                f->f3d[idi][idj][idk] = 0.125 * (((((((c->f3d[i][j][k] + c->f3d[i][j][k + 1]) + c->f3d[i][j + 1][k]) + c->f3d[i][j + 1][k + 1]) + c->f3d[i + 1][j][k]) + c->f3d[i + 1][j][k + 1]) + c->f3d[i + 1][j + 1][k]) + c->f3d[i + 1][j + 1][k + 1]);\n\n\n\n\n\n\n\n\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/Mesh/10"}
{"code": "for (uint i = 0; i < 5000; i++)\n{\n  for (uint j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      goto not_prime;\n    }\n\n  }\n\n  total++;\n  not_prime:\n  ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stride-Apollo/proto-TBB/openmp_etc/0"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    A[(i * 3072) + j] = (((DATA_TYPE) i) * j) / 3072;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm_cpu/5"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i - 2][j][k] - (4.0 * u[m][i - 1][j][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/105"}
{"code": "for (i = 0; i < dim; i++)\n  for (j = 0; j < dim; j++)\n  C[(i * dim) + j] = 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZdravkoDimitrovArnaudov/PPCTR/p3/src/matmul/0"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    cells->speeds0[ii + (jj * params.nx)] = w0;\n    cells->speeds1[ii + (jj * params.nx)] = w1;\n    cells->speeds2[ii + (jj * params.nx)] = w1;\n    cells->speeds3[ii + (jj * params.nx)] = w1;\n    cells->speeds4[ii + (jj * params.nx)] = w1;\n    cells->speeds5[ii + (jj * params.nx)] = w2;\n    cells->speeds6[ii + (jj * params.nx)] = w2;\n    cells->speeds7[ii + (jj * params.nx)] = w2;\n    cells->speeds8[ii + (jj * params.nx)] = w2;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MichaelRol/Lattice-Boltzmann-OpenMP/d2q9-bgk/0"}
{"code": "for (int n = 0; n < (N * M); n++)\n{\n  int i = n / N;\n  int j = n % N;\n  dst[n] = src[(M * j) + i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucaAngioloni/ParallelComputingExam/Integral_Images_(final-term)/Code/OpenMP/openmp_integral_image/0"}
{"code": "for (int i = 0; i < images_nr; ++i)\n{\n  char image_name[256];\n  sprintf(image_name, \"%s%d%s\", image_prefix, i, image_suffix);\n  rc = lodepng_save_file(encoded_images[i], encoded_images_sz[i], image_name);\n  if (rc)\n  {\n    printf(\"save error: %s\\n\", lodepng_error_text(rc));\n  }\n\n  free(encoded_images[i]);\n  free((*images)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_omp/1"}
{"code": "for (size_t i = size - m->nrows; i < size; i++)\n  rowsPerProc[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/main/3"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    aux = cube[x][y];\n    while (aux != 0)\n    {\n      if (aux->status == 1)\n      {\n        fprintf(stdout, \"%d %d %d\\n\", x, y, aux->z);\n      }\n\n      aux = aux->next;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbsousa01/Game-of-Life3D/life3d-omp/4"}
{"code": "for (int id_fake = 0; id_fake < ((mask_height * mask_width) * c); id_fake++)\n{\n  int channel = id_fake / (mask_height * mask_width);\n  int y = ((id_fake % (mask_height * mask_width)) / mask_width) + boundBoxMinY;\n  int x = ((id_fake % (mask_height * mask_width)) % mask_width) + boundBoxMinX;\n  int id = (x + (y * w)) + ((channel * w) * h);\n  int idx_nextX = ((x + 1) + (w * y)) + ((w * h) * channel);\n  int idx_prevX = ((x - 1) + (w * y)) + ((w * h) * channel);\n  int idx_nextY = (x + (w * (y + 1))) + ((w * h) * channel);\n  int idx_prevY = (x + (w * (y - 1))) + ((w * h) * channel);\n  if (boundary_array[id] == INSIDE_MASK)\n  {\n    double neighbor_target = ((targetimg[idx_nextY] + targetimg[idx_nextX]) + targetimg[idx_prevX]) + targetimg[idx_prevY];\n    double neighbor_output = ((outimg[idx_nextY] + outimg[idx_nextX]) + outimg[idx_prevX]) + outimg[idx_prevY];\n    outimg[id] = 0.25 * (((4 * targetimg[id]) - neighbor_target) + neighbor_output);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic, CHUNKSIZE1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/14"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  out[i] = goodness[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjnsteven/wb_openmp/splitc/6"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  for (j = 18; j < (1000000 - 18); j++)\n  {\n    x[i][j] = x[i][j - 18] + sin(y[i][j]);\n    y[i][j] = y[i][j + 18] + cos(x[i][j]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/openMPI-examples/openmp/example3/simd/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  int i_4 = 4 * i;\n  int i_3 = 3 * i;\n  (*data_point_cluster)[i_4 + 0] = data_points[i_3 + 0];\n  (*data_point_cluster)[i_4 + 1] = data_points[i_3 + 1];\n  (*data_point_cluster)[i_4 + 2] = data_points[i_3 + 2];\n  (*data_point_cluster)[i_4 + 3] = 0;\n}\n\n", "pragma": "       #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anirudh8841/K-means-clustering/lab1_omp/6"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  scanf(\"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/vector_addition/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = i + 1; j < (N - 1); j++)\n  {\n    if (ndvi_median[i] > ndvi_median[j])\n    {\n      temp = ndvi_median[j];\n      ndvi_median[j] = ndvi_median[i];\n      ndvi_median[i] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i, j, temp) shared(N, ndvi_median)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBS/gdal_sebs_eta/3"}
{"code": "for (int i = 0; i < (smallImageWidth * 4); i++)\n{\n  for (int j = 0; j < smallImageHeight; j++)\n  {\n    smallImageBuffer[rot] = transposeSmallImageMatrix[i][j];\n    rot++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aksha/Breast-Tumor-Detection/ravicha_ImageSearch/9"}
{"code": "for (i = 0; i < 9; ++i)\n{\n  for (j = 0; j < 9; ++j)\n  {\n    puzzle[8 - i][j] = puzzle[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blu-J/sudoku-openmp/sudoku/9"}
{"code": "for (int i = 0; i < N; i++)\n{\n  host_arr[i].val = i;\n  host_arr[i].arr = (int *) malloc(sz_inner);\n  for (int j = 0; j < N; j++)\n  {\n    host_arr[i].arr[j] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/mixed_mapper/main/0"}
{"code": "for (unsigned int i = 1; i < (TDim + 1); ++i)\n{\n  step_data += N[i] * ((alpha * geom[i].FastGetSolutionStepValue(r_origin_variable)) + ((1 - alpha) * geom[i].FastGetSolutionStepValue(r_origin_variable, 1)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/9"}
{"code": "for (i = 3; i <= n; i++)\n{\n  nouv = der + av_der;\n  av_der = der;\n  der = nouv;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/exercices/fibonaci_parallel/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/201"}
{"code": "for (i = 0; i < omp_num_devices; i++)\n{\n  omp_device_t *dev = &omp_devices[i];\n  if (i < num_hostcpu_dev)\n  {\n    omp_init_hostcpu_device(dev, i, host_dev_sysid, 1);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), host_dev_sysid);\n    host_dev_sysid++;\n  }\n  else\n    if (i < (num_thsim_dev + num_hostcpu_dev))\n  {\n    omp_init_thsim_device(dev, i, thsim_dev_sysid, 1);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), thsim_dev_sysid);\n    thsim_dev_sysid++;\n  }\n  else\n    if (i < ((num_nvgpu_dev + num_hostcpu_dev) + num_thsim_dev))\n  {\n    for (; nvgpu_dev_sysid < total_nvgpu; nvgpu_dev_sysid++)\n    {\n      if (nvgpu_selection[nvgpu_dev_sysid])\n      {\n        break;\n      }\n\n    }\n\n    omp_init_nvgpu_device(dev, i, nvgpu_dev_sysid);\n    sprintf(dev->name, \"%s:%d\", omp_get_device_typename(dev), nvgpu_dev_sysid);\n    nvgpu_dev_sysid++;\n  }\n  else\n  {\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Mat-Mat/C/mat-mat/0"}
{"code": "for (int i = 1; i < N; i++)\n{\n  b[i] += a[i - 1];\n  a[i] += c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/loop_skewing/1"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (32 / 2)) % 32) - (32 / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/29"}
{"code": "for (i = 0; i < 100; i++)\n{\n  C[i] = A[i] + B[i];\n  printf(\"Thread %d:c[%d]=%f\\n\", tid, i, C[i]);\n}\n\n", "pragma": "omp for schedule(guided, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Labs/Parallel-Computing-Lab/Lab2/sum_2_vectors/0"}
{"code": "for (j = 0; j < nclusters; j++)\n  errors[j] = DBL_MAX;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/59"}
{"code": "for (i = 0; i < newTam; i++)\n{\n  for (j = 0; j < newTam; j++)\n  {\n    A11[i][j] = A[i][j];\n    A12[i][j] = A[i][newTam + j];\n    A21[i][j] = A[newTam + i][j];\n    A22[i][j] = A[newTam + i][newTam + j];\n    B11[i][j] = B[i][j];\n    B12[i][j] = B[i][newTam + j];\n    B21[i][j] = B[newTam + i][j];\n    B22[i][j] = B[newTam + i][newTam + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 3/Trab3_Strassen_OMP/6"}
{"code": "for (i = 0; i < 100000; i++)\n  (cout << sequence[i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PaletiKrishnasai/High-Performance-Computing/DesignActivity1/Q1/1"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  isum = 0;\n  for (j = 0; j < 8; j++)\n  {\n    ist = ncl[j + (8 * k)];\n    ncl[j + (8 * k)] = isum;\n    isum += ist;\n  }\n\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ip = 0;\n  for (j = 0; j < nh; j++)\n  {\n    j1 = ihole[2 * ((j + 1) + ((ntmax + 1) * k))] - 1;\n    ist = ihole[1 + (2 * ((j + 1) + ((ntmax + 1) * k)))];\n    ii = ncl[(ist + (8 * k)) - 1];\n    if (ii < npbmx)\n    {\n      for (i = 0; i < idimp; i++)\n      {\n        ppbuff[i + (idimp * (ii + (npbmx * k)))] = ppart[i + (idimp * (j1 + (nppmx * k)))];\n      }\n\n    }\n    else\n    {\n      ip = 1;\n    }\n\n    ncl[(ist + (8 * k)) - 1] = ii + 1;\n  }\n\n  if (ip > 0)\n    *irc = ncl[7 + (8 * k)];\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,isum,ist,nh,ip,j1,ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/6"}
{"code": "for (i = 0; i < NX; i++)\n{\n  q[i] = 0.0;\n  for (j = 0; j < NY; j++)\n  {\n    q[i] = q[i] + (A[(i * NY) + j] * p[j]);\n  }\n\n}\n\n", "pragma": "\t   #pragma omp target teams distribute parallel for map(tofrom: i, j)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/BICG/bicg_omp_out/7"}
{"code": "for (int j = 0; j < n; j++)\n  colsort(j, a, n);\n\n", "pragma": "        #pragma omp parallel for shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcordero26/parallel-computing/hw3/shear/4"}
{"code": "for (size_t i = 0; i < zs.size(); i++)\n  ns[i] = iterate_z(zs[i], c, max_iters);\n\n", "pragma": "#pragma omp parallel for default(none) shared(zs, c, max_iters, ns) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gjbex/training-material/CPlusPlus/Tbb/JuliaSet/julia_omp/1"}
{"code": "for (iter = 0; (iter <= file_info->LIMIT) && (total_has_changed > 0); iter++)\n{\n  has_changed = 0;\n  group_points_with_cuda(&has_changed, set_of_points, k_clusters, set_of_points_size, file_info->K);\n  update_clusters(k_clusters, file_info->K, set_of_points, set_of_points_size);\n  recalculate_centroids(k_clusters, file_info->K);\n  update_has_changed(&has_changed, &total_has_changed);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/4"}
{"code": "for (m = 0; m < 5; m++)\n{\n  u[i][j][k][m] = u[i][j][k][m] + (tmp * rsd[i][j][k][m]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/58"}
{"code": "for (int k = 0; k < (counts[size - 1] + displs[size - 1]); k++)\n  alldata[k] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VulovicDanilo/PatternMatching/PatternMatcher/9"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  int begin = i * distributecol;\n  int end = begin + distributecol;\n  if (i == (numprocs - 1))\n    end = n;\n\n  MPI_Datatype block;\n  MPI_Type_vector(n, end - begin, n, MPI_FLOAT, &block);\n  MPI_Type_commit(&block);\n  MPI_Send((void *) (A[0] + begin), 1, block, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/MPI_omp_col/0"}
{"code": "for (int i = 0; i < IonTypes.size(); i++)\n  ((((app_log() << \"Atom type(\") << i) << \") = \") << IonTypes(i)) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderESHDF.fft/2"}
{"code": "for (i = 0; i < input->K; i++)\n{\n  (*clusters)[i].id = i;\n  (*clusters)[i].center.x = points[i].position.x;\n  (*clusters)[i].center.y = points[i].position.y;\n  (*clusters)[i].center.z = points[i].position.z;\n  (*clusters)[i].num_of_points = 0;\n  (*clusters)[i].diameter = 0;\n  (*clusters)[i].sum_of_points.x = 0;\n  (*clusters)[i].sum_of_points.y = 0;\n  (*clusters)[i].sum_of_points.z = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/4"}
{"code": "for (iter = 1; iter <= niter; iter++)\n{\n  if (timers_enabled)\n    timer_start(T_evolve);\n\n  evolve(u0, u1, twiddle, dims[0], dims[1], dims[2]);\n  if (timers_enabled)\n    timer_stop(T_evolve);\n\n  if (timers_enabled)\n    timer_start(T_fft);\n\n  fft(-1, u1, u1);\n  if (timers_enabled)\n    timer_stop(T_fft);\n\n  if (timers_enabled)\n    timer_start(T_checksum);\n\n  checksum(iter, u1, dims[0], dims[1], dims[2]);\n  if (timers_enabled)\n    timer_stop(T_checksum);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/9"}
{"code": "for (i = 0; i < 2; i++)\n{\n  free(cdata[i]);\n  free(cmask[i]);\n  free(count[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/117"}
{"code": "for (int cdp_id = 0; cdp_id < ncdps; cdp_id++)\n{\n  int t_id0 = (cdp_id > 0) ? (ntraces_by_cdp_id[cdp_id - 1]) : (0);\n  int t_idf = ntraces_by_cdp_id[cdp_id];\n  int stride = t_idf - t_id0;\n  compute_semblances(d_h, d_c, d_samples + (t_id0 * ns), d_num, d_stt, t_id0, t_idf, idt, dt, tau, w, nc, ns);\n  redux_semblances(d_num, d_stt, d_ctr, d_str, d_stk, nc, cdp_id, ns);\n  number_of_semblances += stride;\n  LOG(DEBUG, ((\"Progress: \" + to_string(cdp_id)) + \"/\") + to_string(ncdps));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cmp-omp/main/1"}
{"code": "for (j = jbeg; j <= jfin1; j += 1)\n{\n  frc1 = frc1 + (((((((phi1[i][j] + phi1[i + 1][j]) + phi1[i][j + 1]) + phi1[i + 1][j + 1]) + phi2[i][j]) + phi2[i + 1][j]) + phi2[i][j + 1]) + phi2[i + 1][j + 1]);\n}\n\n", "pragma": "omp parallel for private (j) reduction (+:frc1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/70"}
{"code": "for (i = 0; i < sizeOfTableOutput; ++i)\n{\n  if (i == vectorOutput[raw])\n  {\n    out[i] = 1.0;\n  }\n  else\n  {\n    out[i] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/18"}
{"code": "for (j = 0; j < 10000000; j++)\n{\n  if (((((a[j] / aj) - 1.0) >= 0) ? ((a[j] / aj) - 1.0) : (-((a[j] / aj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Common_Core/C/stream/7"}
{"code": "for (int i = 0; (i < 2) && (scanf(\"%d %u %u\", &N[i][0], &keys[i].key1[0], &keys[i].key2[0]) == 3); i++)\n{\n  local_work_size[i][0] = 1 << 10;\n  dynamic_link_params(&kernel[i], &keys[i], N[i]);\n  has_task[i] = 1;\n  padsum[i] = enqueueCommand(&keys[i], &commandQueue[i], &kernel[i], 1, global_work_size[i], local_work_size[i], group_number[i], N[i], &group_offsets[i], &group_stride_workload[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/9"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/erhs/0"}
{"code": "for (i = 1; i < (block_height - 1); i++)\n{\n  for (j = 1; j < (block_width - 1); j++)\n  {\n    pk(i, j) -= tau * rk(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/21"}
{"code": "for (int64_t i = 0; i < n; ++i)\n  order[start[lev[i]]++] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/5"}
{"code": "for (u = 0; u < graph->num_vertices; u++)\n{\n  uint32_t degree_u = graph->vertices->out_degree[u];\n  uint32_t edge_idx_u = graph->vertices->edges_idx[u];\n  uint32_t v;\n  for (v = edge_idx_u; v < (edge_idx_u + degree_u); v++)\n  {\n    uint32_t node_v = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[v]);\n    uint32_t degree_v = graph->vertices->out_degree[node_v];\n    uint32_t edge_idx_v = graph->vertices->edges_idx[node_v];\n    uint32_t w;\n    uint32_t degree_iter = graph->vertices->out_degree[u];\n    uint32_t edge_idx_iter = graph->vertices->edges_idx[u];\n    uint32_t iter;\n    for (w = edge_idx_v; w < (edge_idx_v + degree_v); w++)\n    {\n      uint32_t node_w = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[w]);\n      uint32_t node_iter = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[edge_idx_iter]);\n      for (iter = edge_idx_iter; iter < (edge_idx_iter + degree_iter); iter++)\n      {\n        node_iter = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[iter]);\n        if (node_iter == node_w)\n          stats->counts[u]++;\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(stats) schedule(dynamic, 128)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/triangleCount/1"}
{"code": "for (i = 0; i < n; i++)\n  work1(i, n);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.34.2/0"}
{"code": "for (int i = startIndex; i < endIndex; i++)\n{\n  videoOut.write(filtered_stack[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kisung5/evm-cpp-jetson/src/processing_functions/0"}
{"code": "for (i = 0; i < DIM; i++)\n  for (j = 0; j < DIM; j++)\n  for (k = 0; k < DIM; k++)\n  ctest[i][j] += a[i][k] * b[k][j];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yaiciwalid/Programmation-Parall-le/archi/2"}
{"code": "for (i = 0; i < 3000; i++)\n{\n  printf(\"%.2f \", B[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/finalomp/5"}
{"code": "for (i = 0; i < m; i++)\n  y[i] = z[i];\n\n", "pragma": "omp for nowait ordered schedule ( monotonic : runtime )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/ompfor10/1"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  weight = graph->sorted_edges_array->edges_array_weight[e];\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/21"}
{"code": "for (int row = 0; row < 6; row++)\n  x_t[row] = x[row] + (step_dir[row] * a_t);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/8"}
{"code": "for (i = 0; i < n_line; i++)\n{\n  points_array[i].cluster_id = assign_cluster(points_array[i], actual_centroids_array, n_clusters);\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/0"}
{"code": "for (i = 0; i < m; ++i)\n{\n  *(matrix + i) = (int *) malloc((sizeof(int)) * n);\n  for (j = 0; j < n; ++j)\n    fscanf(fptr, \"%d\", (*(matrix + i)) + j);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-3/codes/with-sections/meanfilter3x3/4"}
{"code": "for (i = 0; i < p_count; i++)\n{\n  printf(\"%d \", recvCount[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/10"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%d \", nearMeshType[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/120"}
{"code": "for (int i = 0; i < (tagstr.size() - 1); ++i)\n  ((cout << \"   \") << tagstr[i]) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallel18computing/Histogram_NER_OpenMP/main/0"}
{"code": "for (i = 0; i < (SIMD_COEF_32 * SIMD_PARA_SHA256); ++i)\n{\n  SHA256_Init(&ctx);\n  SHA256_Update(&ctx, saved_key[index + i], strlen(saved_key[index + i]));\n  SHA256_Update(&ctx, salt, n_salt);\n  SHA256_Final(digest, &ctx);\n  for (j = 0; j < 32; ++j)\n    keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((j & (0xffffffff - 3)) * SIMD_COEF_32)) + (j & 3)) + ((((((unsigned int) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = digest[j];\n\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((j & (0xffffffff - 3)) * SIMD_COEF_32)) + (j & 3)) + ((((((unsigned int) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0x80;\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((62 & (0xffffffff - 3)) * SIMD_COEF_32)) + (62 & 3)) + ((((((unsigned int) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/keyring_fmt_plug/9"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/111"}
{"code": "for (c1 = (ni > nj) ? (ni) : (nj); c1 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/21"}
{"code": "for (i = 1; i < (3000 - 1); i++)\n{\n  for (j = 1; j < (3000 - 1); j++)\n  {\n    aux = G[i][j];\n    G[i][j] = (((((G[i + 1][j] + G[i - 1][j]) * k) * k) + (((G[i][j - 1] + G[i][j + 1]) * h) * h)) - ((((k * h) * k) * h) * P(0))) / (2.0 * ((h * h) + (k * k)));\n    aux = fabs(aux - G[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuilhermeMachado13/Equa-o-de-Poisson-em-2D-em-Paralelo-OpenMP-/projeto_openmp/0"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  sum0 += A[i] * B[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/2.norace7/1"}
{"code": "for (int i = 1; i < p; i++)\n{\n  {\n    finalRcvDispls[i] = finalRcvDispls[i - 1] + finalRcvCounts[i - 1];\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/swapnilushinde/OpenMP_MPI_Sample_sort_algorithm/Source code/SSHINDE2/sampleSortOpenMP/16"}
{"code": "for (i = 1; i < (500 - 1); i++)\n{\n  w[i][0] = 100.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/0"}
{"code": "for (j = 0; j <= (nrows - 1); j++)\n{\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n    a[k] = 0.0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/CG/cg/0"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  x >>= 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_atomic/10"}
{"code": "for (size_t row = 0; row < rows_size; ++row)\n{\n  const size_t row_start = A.row_ptr[row];\n  const size_t row_end = A.row_ptr[row + 1];\n  double sum = 0;\n  for (size_t i = row_start; i < row_end; ++i)\n  {\n    sum += A.values(i) * x(A.col_idx(i));\n  }\n\n  ycoefs[row] = sum;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gadube/simple_openmp_examples/cg-solve/cgsolve_omp/1"}
{"code": "for (i = 0; i < 2000; i++)\n  if (A[i] != nthreads)\n  abort();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/critical-2/2"}
{"code": "for (j = start; j < (end - 1); j++)\n{\n  for (i = j + 1; i < end; i++)\n  {\n    coef = A[i][j] / A[j][j];\n    for (k = 0; k < N; k++)\n    {\n      A[i][k] -= coef * A[j][k];\n    }\n\n    b[i] -= coef * b[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/parallel/ParallelSweepMethod/0"}
{"code": "for (i = 0; i < pairs; i++)\n{\n  if (params->q != 0)\n  {\n    free(params->q);\n  }\n\n  if (params->q != 0)\n  {\n    free(params->d);\n  }\n\n  params->q = 0;\n  params->d = 0;\n  params->q_cnt = 0;\n  params->d_cnt = 0;\n  readPair(params, max_size_q, min_size_q, size_d);\n  result = calc_2d_table(n_threads, performance, params->q_cnt, params->d_cnt, params->q, params->d, match, mismatch, gap);\n  for (j = 0; j < result[0].count; j++)\n  {\n    fprintf(fp, \"\\nQ:\\t%s\", params->q);\n    fprintf(fp, \"\\nD:\\t%s\", params->d);\n    fprintf(fp, \"\\n MATCH %d [Score:%d, Start:%d, End:%d]\", j + 1, result[j].score, result[j].start, result[j].end);\n    fprintf(fp, \"\\n\\tQ:%s\", result[j].s1);\n    fprintf(fp, \"\\n\\tD:%s\", result[j].s2);\n    fprintf(fp, \"\\n\");\n    free(result[j].s1);\n    free(result[j].s2);\n  }\n\n  free(result);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkasfikis/Smith-Waterman-/myProj_OMP_FG/2"}
{"code": "for (int i = 0; i < num_data; i++)\n{\n  tot_sum += data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_basic_sum/1"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    vol_flux_x[FTNREF2D(1 - j, k, x_max + 5, x_min - 2, y_min - 2)] = -vol_flux_x[FTNREF2D(1 + j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/46"}
{"code": "for (int i = 2; i < (nx + 2); ++i)\n{\n  double x = ((i - 2) - ((nx - 1) / 2.)) * dx;\n  for (int j = 2; j < (ny + 2); ++j)\n  {\n    double y = ((j - 2) - ((ny - 1) / 2.)) * dy;\n    for (int k = 2; k < (nz + 2); ++k)\n    {\n      int s = columnMajorLinearIndex(i, j, k, nx + 4, ny + 4, nz + 4);\n      if (y > x)\n        e[s] = PRECISION(0.00778147);\n      else\n        e[s] = PRECISION(0.124503);\n\n      p[s] = e[s] / 3.;\n      u->ux[s] = 0.;\n      u->uy[s] = 0.;\n      u->un[s] = 0.;\n      u->ut[s] = 1.;\n      up->ux[s] = 0.;\n      up->uy[s] = 0.;\n      up->un[s] = 0.;\n      up->ut[s] = 1.;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/rhic/src/InitialConditions/6"}
{"code": "for (j = 0; j < n; j++)\n{\n  particles[j].part_id = j;\n  particles[j].vx = 0.0;\n  particles[j].vy = 0.0;\n  particles[j].fx = 0.0;\n  particles[j].fy = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkmandke/nbody/src/barnes_openmp/0"}
{"code": "for (int i = 0; i < (size * size); i++)\n{\n  a[i] = u(e);\n  b[i] = u(e);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_simd/0"}
{"code": "for (i = 0; i < spreps; i++)\n{\n  D.zeros();\n  for (j = 0; j < n; j++)\n  {\n    D = AdjBCDOne(D, P, data_proc.col(j).head(cov_num), a);\n    assignew(j) = D(D.n_elem - 1);\n  }\n\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  sp(i) = ((-sum(data_proc.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data_proc.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/36"}
{"code": "for (int pos = 0; pos < slice_size; pos++)\n  image_slice[pos] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Davide95/mandelbrot-CUCL/code/mpi/degree2/0"}
{"code": "for (m = i; m < l; m++)\n{\n  for (n = j; n < k; n++)\n  {\n    sum += img1.arr[m][n] * f.arr[m - i][n - j];\n  }\n\n}\n\n", "pragma": "\t\t\t\t#pragma omp for private(m,n) collapse(2) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Images/Ivpomp/3"}
{"code": "for (row = 1; row < 750; ++row)\n{\n  for (col = 1; col < 750; ++col)\n  {\n    m[(row * 750) + col] = (m[((row - 1) * 750) + col] + m[(row * 750) + (col - 1)]) - m[((row - 1) * 750) + (col - 1)];\n  }\n\n}\n\n", "pragma": "omp for ordered(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/worksharing/for/omp_doacross/0"}
{"code": "for (middle = 0; middle < 800; middle++)\n{\n  int *dm = distance_matrix[middle];\n  for (src = 0; src < 800; src++)\n  {\n    int *ds = distance_matrix[src];\n    for (dst = 0; dst < 800; dst++)\n    {\n      ds[dst] = (ds[dst] < (ds[middle] + dm[dst])) ? (ds[dst]) : (ds[middle] + dm[dst]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuvrajdalia/openmp_project/floydp/2"}
{"code": "for (int i = 0; i < N2; i++)\n{\n  for (int j = 0; j < N2; j++)\n  {\n    nextGen[i][j] = table[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnstephenson39/gameoflife_openmp/gol/3"}
{"code": "for (i_p = 0; i_p < parameters->n_particles; i_p++)\n{\n  rn_skip((((i_b * parameters->n_generations) + i_g) * parameters->n_particles) + i_p);\n  get_particle(&p, &source_bank->p[i_p]);\n  transport(parameters, geometry, material, source_bank, fission_bank, tally, &p);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wangsnowyin/monte-carlo/eigenvalue/0"}
{"code": "for (int i = 0; i < num_edges; i++)\n{\n  randweights.push_back(i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free/10"}
{"code": "for (i = 0; i < kmin; i++)\n{\n  for (j = 0; j < kmin; j++)\n  {\n    if (graph[memPos[i][j].first][memPos[i][j].second] > (graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second]))\n    {\n      graph[memPos[i][j].first][memPos[i][j].second] = graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second];\n    }\n\n  }\n\n  for (j = kmax; j < V; j++)\n  {\n    if (graph[memPos[i][j].first][memPos[i][j].second] > (graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second]))\n    {\n      graph[memPos[i][j].first][memPos[i][j].second] = graph[memPos[i][k].first][memPos[i][k].second] + graph[memPos[k][j].first][memPos[k][j].second];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,j) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/29"}
{"code": "for (int i = 0; i < TestN; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    kernel_matrix(i, j) = exp(-sum(pow(TestX.row(i) - X.row(j), 2)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/utilities/4"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  for (int j = 0; j < jmax[i]; j++)\n  {\n    for (int k = 0; k < j; k++)\n    {\n      c[i] += ((k + 1) * log(b[i][j])) * rN2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), schedule(runtime), shared(b, c, rN2, jmax)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/1"}
{"code": "for (i = deb + 1; i <= fin; i++)\n{\n  if (T[i] < pivot)\n  {\n    compt++;\n    echanger(T, compt, i);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/sort/qsort/0"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/3"}
{"code": "for (bj = 0; bj < M; bj++)\n  for (bi = 0; bi < M; bi++)\n  check += C[(bj * M) + bi];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/matmul/blocked/2"}
{"code": "for (i = 0; i < n; ++i)\n  sums[j] += u[i] + v[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex3-dot-product-openmp-sta/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  A[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMPsearchCLV/1"}
{"code": "for (k = lt; k >= (lb + 1); k--)\n{\n  j = k - 1;\n  rprj3(r[k], m1[k], m2[k], m3[k], r[j], m1[j], m2[j], m3[j], k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/19"}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      lhs[i][j][k][1][m][m] = 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/53"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  count[i] = 0;\n  private_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/0"}
{"code": "for (int i = 0; i < bins; i++)\n  histogram[i] = 0L;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tomekl007/openMp/Simulation/4"}
{"code": "for (int step = 0; step < num_subintervals; ++step)\n{\n  const double x1 = a + (step * width);\n  const double x2 = a + ((step + 1) * width);\n  trapezoidal_integral += (0.5 * (x2 - x1)) * (f(x1) + f(x2));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kr0nverk/Hello_Parallel_OpenMP/Integration/Integration/2"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  for (j = i + 1; j < n; j++)\n  {\n    double temp = A[(j * n) + i] / A[(i * n) + i];\n    for (k = i; k < n; k++)\n    {\n      A[(j * n) + k] -= temp * A[(i * n) + k];\n    }\n\n    b[j] -= temp * b[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/18"}
{"code": "for (int i = 0; i < size; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/29"}
{"code": "for (int w = 0; w < 100000; w++)\n{\n  Centers_matchings[Class_of_Vec[w]]++;\n  for (int j = 0; j < 1000; j++)\n    Centers[Class_of_Vec[w]][j] += Vectors[w][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/2. K-means with OpenMP/kmeans12/8"}
{"code": "for (k = 0; k <= (nz - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = -frct[i][j][k][m];\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/85"}
{"code": "for (int i = 0; i < L; ++i)\n{\n  for (int j = 0; j < C; ++j)\n  {\n    if (matrix[i][j] == 0)\n      fprintf(file, \". \");\n    else\n      fprintf(file, \"X \");\n\n  }\n\n  fprintf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cristof17/Game-of-Life-OpenMP/g_omp/9"}
{"code": "for (long idx = 0; idx < NUM_SLICES; idx++)\n{\n  tmp = idx;\n  {\n    res += tmp;\n    printf(\"tmp = %ld\\r\\n\", tmp);\n  }\n}\n\n", "pragma": "\t\t#pragma omp for ordered reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex4_5_ordered/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    expected_x += a[j];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n  expected_x = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/scan/test_scan/4"}
{"code": "for (size_t i = 0; i < SSIZE; i++)\n  spline->coefs[i] = sqrt(0.22 + (i * 1.0)) * sin(i * 1.0);\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Platforms/OMPTarget/main/3"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  velDivergence[i] = 0.0;\n  if (particleType[i] == fluid)\n  {\n    double DivV = 0.0;\n    double ni = pndi[i];\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double MC[9];\n    MC[0] = correcMatrixRow1[i * 3];\n    MC[1] = correcMatrixRow1[(i * 3) + 1];\n    MC[2] = correcMatrixRow1[(i * 3) + 2];\n    MC[3] = correcMatrixRow2[i * 3];\n    MC[4] = correcMatrixRow2[(i * 3) + 1];\n    MC[5] = correcMatrixRow2[(i * 3) + 2];\n    MC[6] = correcMatrixRow3[i * 3];\n    MC[7] = correcMatrixRow3[(i * 3) + 1];\n    MC[8] = correcMatrixRow3[(i * 3) + 2];\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n            {\n              if (j != i)\n              {\n                double vijx = vel[j * 3] - velXi;\n                double vijy = vel[(j * 3) + 1] - velYi;\n                double vijz = vel[(j * 3) + 2] - velZi;\n                double dst = sqrt(dstij2);\n                double wS = weight(dst, reS, weightType);\n                if (gradientCorrection == false)\n                {\n                  if (ni > 1.0e-8)\n                  {\n                    DivV += ((((dim / pndSmallZero) * (pndi[j] / ni)) * (((vijx * v0ij) + (vijy * v1ij)) + (vijz * v2ij))) * wS) / dstij2;\n                  }\n\n                }\n                else\n                {\n                  double v0ijC = ((v0ij * MC[0]) + (v1ij * MC[1])) + (v2ij * MC[2]);\n                  double v1ijC = ((v0ij * MC[3]) + (v1ij * MC[4])) + (v2ij * MC[5]);\n                  double v2ijC = ((v0ij * MC[6]) + (v1ij * MC[7])) + (v2ij * MC[8]);\n                  DivV += (((dim / pndSmallZero) * (((vijx * v0ijC) + (vijy * v1ijC)) + (vijz * v2ijC))) * wS) / dstij2;\n                }\n\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    velDivergence[i] = DivV;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/53"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = nxhd * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    t2 = conjf(f[(nxh - j) + joff]);\n    t1 = f[j + joff] + t2;\n    t2 = (f[j + joff] - t2) * t3;\n    f[j + joff] = t1 + t2;\n    f[(nxh - j) + joff] = conjf(t1 - t2);\n  }\n\n  f[nxhh + joff] = 2.0 * conjf(f[nxhh + joff]);\n  f[joff] = (crealf(f[joff]) + cimagf(f[joff])) + ((crealf(f[joff]) - cimagf(f[joff])) * _Complex_I);\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[j1 + joff];\n      f[j1 + joff] = f[j + joff];\n      f[j + joff] = t1;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = conjf(sct[kmr * j]);\n        t2 = t1 * f[j2 + joff];\n        f[j2 + joff] = f[j1 + joff] - t2;\n        f[j1 + joff] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,j1,j2,joff,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/15"}
{"code": "for (i = 0; i < size; i++)\n{\n  fprintf(f, \"%lf %lf\\n\", &allClusters[i].x, &allClusters[i].y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Cluster/2"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int jj = this->mat_.row_offset[i];\n  for (int j = tmp.mat_.row_offset[i]; j < tmp.mat_.row_offset[i + 1]; ++j)\n  {\n    if ((abs(tmp.mat_.val[j]) > drop_off) || (tmp.mat_.col[j] == i))\n    {\n      this->mat_.col[jj] = tmp.mat_.col[j];\n      this->mat_.val[jj] = tmp.mat_.val[j];\n      ++jj;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/65"}
{"code": "for (i = 0; i < n; i++)\n{\n  double tmp = x[i * inc_x];\n  x[i * inc_x] = (H[0] * x[i * inc_x]) + (H[1] * y[i * inc_y]);\n  y[i * inc_y] = (H[2] * tmp) + (H[3] * y[i * inc_y]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/13"}
{"code": "for (int i = a - minRange; i < ((b - minRange) + 1); i++)\n{\n  if (resultMatrix[i] == true)\n  {\n    primes_num++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jedrzej-put/PUT-OpenMP/modulo-parallel/1"}
{"code": "for (i = 0; i < sz; i++)\n{\n  if (maxlab[klabels[i]] < distlab[i])\n    maxlab[klabels[i]] = distlab[i];\n\n  if (maxxy[klabels[i]] < distxy[i])\n    maxxy[klabels[i]] = distxy[i];\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/8"}
{"code": "for (i = 0; i < 100000000; ++i)\n{\n  tmp = a[i] / b[i];\n  c[i] = tmp * tmp;\n}\n\n", "pragma": "omp parallel for private(tmp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonywyb/Lab-on-Parallel-and-Distributed-Computing/HW1/squareofHadamardProduct/1"}
{"code": "for (int i = 0; i < 210; i++)\n{\n  result += (i * 2) + 1;\n}\n\n", "pragma": "        #pragma omp for reduction(+ : result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task14/0"}
{"code": "for (unsigned int g = 0; g < ng; g++)\n{\n  for (unsigned int l = 0; l < (cmom - 1); l++)\n  {\n    for (unsigned int i = 0; i < nx; i++)\n    {\n      for (unsigned int j = 0; j < ny; j++)\n      {\n        for (unsigned int k = 0; k < nz; k++)\n        {\n          out_scalar_moments[(((l + ((cmom - 1) * i)) + (((cmom - 1) * nx) * j)) + ((((cmom - 1) * nx) * ny) * k)) + (((((cmom - 1) * nx) * ny) * nz) * g)] = scalar_mom(g, l, i, j, k);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_core/2"}
{"code": "for (i = 0; i <= 2; i += 1)\n{\n  logd[i] = ilog2(d[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/26"}
{"code": "for (i = 0; i < dev_num; i++)\n{\n  err = clFlush(command_queue[i]);\n  checkError(err, 331);\n  err = clFinish(command_queue[i]);\n  checkError(err, 333);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/B/photomosaic/4"}
{"code": "for (int j = 0; j < 75; j++)\n{\n  printf(\"%d ->\", j);\n  for (i = 0; i < 4; i++)\n  {\n    printf(\"%f, \", test_data[j][i]);\n  }\n\n  printf(\" -> \");\n  for (i = 0; i < n_estimators; i++)\n  {\n    predictions[i] = predict(rf[i], test_data[j]);\n    printf(\"%.5f,\", predictions[i]);\n  }\n\n  printf(\"-> %f \\n\", majority_vote_predict(predictions, n_estimators));\n  results_serial[j] = majority_vote_predict(predictions, n_estimators);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/4"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n  omp_destroy_lock(&locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/3"}
{"code": "for (i = 0; i < ORD; i++)\n{\n  dotp = dotp + (v1[i] * v2[i]);\n}\n\n", "pragma": "        #pragma omp for reduction(+:dotp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/babreu-ncsa/IntroToOpenMP/Ex3_Reductions/dotprod/cpp/solution/dotprod_omp/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  pagRank = ((double) topFive[i]) / ((double) (nSize * K));\n  fprintf(outFile, \"%d,%d,%lf\\n\", topNodes[i], topFive[i], pagRank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManuelBerrueta/cpts411_PageRankEstimator/pagerankestimator/5"}
{"code": "for (i = 0; i < 3000; i++)\n  for (j = 0; j < 3000; j++)\n  result_image[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/7"}
{"code": "for (int it = 0; it <= 5; it++)\n{\n  start = omp_get_wtime();\n  sparsematrix_mult(c3, a2, b, n);\n  end = omp_get_wtime();\n  if (it)\n    printf(\"sparsemult: %lf\\n\", end - start);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/mm/main/7"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[index], (16 * 2) * 2);\n  MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/0"}
{"code": "for (i = 0; i < height; ++i)\n{\n  for (j = 0; j < width; ++j)\n  {\n    fread(&image->pixel[(i * width) + j].grs.i, 1, 1, fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WalrusNine/Trab02-Grupo01-B/Trab02-Grupo01-B/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 3; k <= (grid_points[2] - 4); k += 1)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/77"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (index[i] == 1)\n  {\n    comp[new_index[i]] = data[i];\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nasaa0528/compactAndSparceMatrix/compact/compact_parallel/0"}
{"code": "for (int i = start; i <= mid; i++)\n{\n  arr1[i - start] = arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab5-Binary_Search/binary_search/1"}
{"code": "for (index = 0; index < tot_todo; index += 1)\n{\n  union xx\n  {\n    unsigned char c[BINARY_SIZE];\n    long a[BINARY_SIZE / (sizeof(long))];\n  } u;\n  unsigned char *temp_result = u.c;\n  SHA256_CTX ctx;\n  SHA256_CTX alt_ctx;\n  size_t cnt;\n  int idx;\n  char *cp;\n  char p_bytes[35 + 1];\n  char s_bytes[35 + 1];\n  char tmp_cls[(sizeof(cryptloopstruct)) + MEM_ALIGN_SIMD];\n  cryptloopstruct *crypt_struct;\n  crypt_struct = (cryptloopstruct *) mem_align(tmp_cls, MEM_ALIGN_SIMD);\n  for (idx = 0; idx < 1; ++idx)\n  {\n    SHA256_Init(&ctx);\n    SHA256_Update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA256_Update(&ctx, cur_salt->salt, cur_salt->len);\n    SHA256_Init(&alt_ctx);\n    SHA256_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA256_Update(&alt_ctx, cur_salt->salt, cur_salt->len);\n    SHA256_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA256_Final((unsigned char *) crypt_out[MixOrder[index + idx]], &alt_ctx);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > BINARY_SIZE; cnt -= BINARY_SIZE)\n      SHA256_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], BINARY_SIZE);\n\n    SHA256_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], cnt);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 0; cnt >>= 1)\n      if ((cnt & 1) != 0)\n      SHA256_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], BINARY_SIZE);\n    else\n      SHA256_Update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n\n    SHA256_Final((unsigned char *) crypt_out[MixOrder[index + idx]], &ctx);\n    SHA256_Init(&alt_ctx);\n    for (cnt = 0; cnt < saved_len[MixOrder[index + idx]]; ++cnt)\n      SHA256_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n    SHA256_Final(temp_result, &alt_ctx);\n    cp = p_bytes;\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt >= BINARY_SIZE; cnt -= BINARY_SIZE)\n      cp = ((char *) memcpy(cp, temp_result, BINARY_SIZE)) + BINARY_SIZE;\n\n    memcpy(cp, temp_result, cnt);\n    SHA256_Init(&alt_ctx);\n    for (cnt = 0; cnt < (16 + ((unsigned char *) crypt_out[MixOrder[index + idx]])[0]); ++cnt)\n      SHA256_Update(&alt_ctx, cur_salt->salt, cur_salt->len);\n\n    SHA256_Final(temp_result, &alt_ctx);\n    cp = s_bytes;\n    for (cnt = cur_salt->len; cnt >= BINARY_SIZE; cnt -= BINARY_SIZE)\n      cp = ((char *) memcpy(cp, temp_result, BINARY_SIZE)) + BINARY_SIZE;\n\n    memcpy(cp, temp_result, cnt);\n    LoadCryptStruct(crypt_struct, MixOrder[index + idx], idx, p_bytes, s_bytes);\n  }\n\n  idx = 0;\n  SHA256_Init(&ctx);\n  for (cnt = 1;; ++cnt)\n  {\n    SHA256_Update(&ctx, crypt_struct->bufs[0][idx], crypt_struct->datlen[idx]);\n    if (cnt == cur_salt->rounds)\n      break;\n\n    memcpy(crypt_struct->cptr[0][idx], ctx.h, BINARY_SIZE);\n    if ((++idx) == 42)\n      idx = 0;\n\n    memcpy(ctx.h, ctx_init, sizeof(ctx_init));\n  }\n\n  memcpy(crypt_out[MixOrder[index]], ctx.h, BINARY_SIZE);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sha256crypt_fmt_plug/0"}
{"code": "for (int i = 0; i < blockSize; i++)\n{\n  A[i] += B[i] + C[i];\n  Inner = 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_loop_trunk/nested_loop/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n    printf(\"%2d \", matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw4/matrix/3"}
{"code": "for (x = 0; x < 40000; ++x)\n  total += relRot(puzzle, x * 10, 9);\n\n", "pragma": "omp parallel for reduction (+:total) num_threads(c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blu-J/sudoku-openmp/sudoku/12"}
{"code": "for (j = 1; j < HEAVY; j++)\n{\n  value = (i + 1) * (j % 10);\n  result += cos(value);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranzxc/Exam3_Parallal_OpenMP_MPI_CUDA/Exam3_Parallel_CUDA_MPI_OPENMP/MainProgram/2"}
{"code": "for (int i = 0; i < subsize; i++)\n{\n  for (int j = 0; j < subsize; j++)\n    printf(\"%f \", get(mat, size, v[j], h[i]));\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/mpi-openmp-sparse-matrix/mpi-openmp-sparse-matrix/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  eigenvalues[i] = right_boundary;\n  lowerbounds[i] = left_boundary;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/Bisection/5"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = (alpha * this->vec_[i]) + (beta * cast_x->vec_[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/15"}
{"code": "for (int i = 0; i < R; i++)\n{\n  printf(\"|\");\n  for (int j = 0; j < C; j++)\n  {\n    printf(\"%c\", getMinName(getType(oldWorld[i][j].type)));\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arcmarqs/EcosystemSim/src/util/6"}
{"code": "for (i2 = 1; i2 <= ((n2 - 1) - 1); i2 += 1)\n{\n  u[i3][i2][n1 - 1] = u[i3][i2][1];\n  u[i3][i2][0] = u[i3][i2][n1 - 2];\n}\n\n", "pragma": "omp parallel for private (i2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/3"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (!data->present)\n    continue;\n\n  data->r = randnum();\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mis/0"}
{"code": "for (istep = 0; istep < nstep; istep++)\n{\n  step_kernel_cpu(ni + 2, nj + 2, tfac, temp1_h, temp2_h);\n  temp_tmp = temp1_h;\n  temp1_h = temp2_h;\n  temp2_h = temp_tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcarter108/cisc372_proj/heat_omp/4"}
{"code": "for (int i = 0; i < (num_linhas * num_colunas); i++)\n{\n  if (vetor_de_distancias[i] < menor_distancia)\n  {\n    menor_distancia = vetor_de_distancias[i];\n    menor_index_x = i / num_colunas;\n    menor_index_y = i % num_colunas;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruteee/Kohhonen/Rede/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  mk = (sk = 0);\n  for (k = 0; k < l; k++)\n  {\n    dk = d[(i * l) + k];\n    h = dk - mk;\n    mk += h / (k + 1);\n    sk += h * (dk - mk);\n  }\n\n  m[i] = mk;\n  s[i] = sqrt(sk / (l - 1));\n}\n\n", "pragma": "omp parallel for private(i, k, h, mk, sk, dk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UP-RS-ESP/CorrCoef/CorrCoef/0"}
{"code": "for (int i = 2; i <= limit; i++)\n{\n  if (mark[i] == true)\n  {\n    primes.push_back(i);\n    for (int j = i; j <= limit; j += i)\n    {\n      mark[j] = false;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wszymkowski/large-scale-computing-course/primes_domenowe/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = 0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_dist_schedule_codegen/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  amt_a += a[i];\n  amt_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: amt_a) reduction(+: amt_b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw6/main/0"}
{"code": "for (int i = 0; i < geom1->n_grid_r; i++)\n  j_phi[i][geom1->n_grid_z - 1] = 0.;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/current/3"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%f \", (float) concentration[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/132"}
{"code": "for (int i = 1; i < (points.size() * N_ORIENTATION_BIN); i++)\n{\n  prefix[i] = prefix[i - 1] + candidate[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wu-yuhui/Sift_OpenMP/sift_tryOrient/1"}
{"code": "for (size_t i = 0; i < n_basis; ++i)\n{\n  for (size_t j = 0; j < n_basis; ++j)\n  {\n    for (size_t k = 0; k < n_basis; ++k)\n    {\n      for (size_t l = 0; l < n_basis; ++l)\n      {\n        v_ao[(((i * n_basis_cub) + (j * n_basis_sq)) + (k * n_basis)) + l] = two_elec_int(i, j, k, l);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philljj/ghf/src/g_matrix/0"}
{"code": "for (int i = 0; i < omp_get_thread_num(); i++)\n{\n  printf(\"First Loop, Thread: #(%d), Iteration: #(%d)\", omp_get_thread_num(), i);\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StephanPirnbaum/insieme-examples/exp8/exp8/0"}
{"code": "for (size_t space_point = 0; space_point < parameters->space_points; ++space_point)\n{\n  const real_type space = lerp((real_type) space_point, 0.0, (real_type) (mesh->space_points - 1), 0.0, parameters->space_max);\n  const real_type temperature = mesh_Get(mesh, time_point, space_point);\n  fprintf(output, \"%.*f %.*f\\n\", DECIMAL_DIG, space, DECIMAL_DIG, temperature);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/4"}
{"code": "for (unsigned int i = 0; i < a.n_elem; i++)\n{\n  if (a[i] != b[i])\n  {\n    re = FALSE;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/0"}
{"code": "for (l = 0; l < D3; l++)\n{\n  double count;\n  __sumskipnan2w__(LInput + (l * D2), D2, LOutputSum + l, &count, &flag_isNaN, W);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/sumskipnan_mex/8"}
{"code": "for (i = 0; i < num_ts; i++)\n{\n  for (j = 0; j < my_house->num_plug; j++)\n  {\n    line_to_send = (plug_before + j) + (i * total_plug);\n    send_message(group_lines[line_to_send], dest, tag);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/17"}
{"code": "for (uint32_t i = 0; i < numKeys; i++)\n{\n  total_length += length[i];\n  d_length[i + 1] = total_length;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/3"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  drand48_r(&drand_buf, &x);\n  drand48_r(&drand_buf, &y);\n  if (((x * x) + (y * y)) <= 1.0)\n    count++;\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/notTyche/various-openMP-program/src/ex3/3"}
{"code": "for (int j = 0; j < size; j++)\n{\n  weights[j] = otherweights[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/16"}
{"code": "for (ri = vr.begin(); ri != vr.end(); ri++)\n{\n  n_count = 0;\n  if (((*ri)->IsAromatic() && (*ri)->IsMember(&(*atom))) && ((*ri)->Size() == 5))\n  {\n    for (rj = (*ri)->_path.begin(); rj != (*ri)->_path.end(); rj++)\n      if (_mol.GetAtom(*rj)->IsNitrogen())\n      n_count++;\n\n\n    if (n_count > 1)\n      atom->SetPartialCharge((-1.0) / n_count);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/24"}
{"code": "for (i = 0; i < (nSize + 1); i++)\n{\n  myGraph[i].pagerank = 0;\n  for (j = 0; j < 3600; j++)\n  {\n    myGraph[i].hyperlinks[j] = -1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManuelBerrueta/cpts411_PageRankEstimator/pagerankestimator/1"}
{"code": "for (j = 3; j <= ((grid_points[1] - 3) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/104"}
{"code": "for (i = 0; i < rows; i++)\n{\n  matrix.rows[i] = matrix.data + (i * cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuguangMeng/MPI-and-OpenMP-Codes/openmpge/1"}
{"code": "for (j = i; j <= (maxN + i); j++)\n  scoringMatrix[i][j] = computePairwiseComparison(seq1[j - 1], seq2[i - 1], weights);\n\n", "pragma": "omp parallel for num_threads(maxN)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/ompFunctions/2"}
{"code": "for (int ii = 0; ii < OutputMatrix2D->GetX(); ii++)\n{\n  for (int jj = 0; jj < OutputMatrix2D->GetY(); jj++)\n  {\n    if (OutputMatrix2D->GetValue(ii, jj).isCond2D(NT_FARFIELD_2D))\n    {\n      nr_nodes++;\n      if (((((ii > 0) && OutputMatrix2D->GetValue(ii - 1, jj).isCond2D(CT_NODE_IS_SET_2D)) && (!OutputMatrix2D->GetValue(ii - 1, jj).isCond2D(CT_WALL_NO_SLIP_2D))) && (!OutputMatrix2D->GetValue(ii - 1, jj).isCond2D(CT_SOLID_2D))) && (!OutputMatrix2D->GetValue(ii - 1, jj).isCond2D(NT_FC_2D)))\n      {\n        OutputMatrix2D->GetValue(ii - 1, jj).SetCond2D(CT_NONREFLECTED_2D);\n        nr_nodes++;\n      }\n\n      if (((((ii < (OutputMatrix2D->GetX() - 1)) && OutputMatrix2D->GetValue(ii + 1, jj).isCond2D(CT_NODE_IS_SET_2D)) && (!OutputMatrix2D->GetValue(ii + 1, jj).isCond2D(CT_WALL_NO_SLIP_2D))) && (!OutputMatrix2D->GetValue(ii + 1, jj).isCond2D(CT_SOLID_2D))) && (!OutputMatrix2D->GetValue(ii + 1, jj).isCond2D(NT_FC_2D)))\n      {\n        OutputMatrix2D->GetValue(ii + 1, jj).SetCond2D(CT_NONREFLECTED_2D);\n        nr_nodes++;\n      }\n\n      if (((((jj > 0) && OutputMatrix2D->GetValue(ii, jj - 1).isCond2D(CT_NODE_IS_SET_2D)) && (!OutputMatrix2D->GetValue(ii, jj - 1).isCond2D(CT_WALL_NO_SLIP_2D))) && (!OutputMatrix2D->GetValue(ii, jj - 1).isCond2D(CT_SOLID_2D))) && (!OutputMatrix2D->GetValue(ii, jj - 1).isCond2D(NT_FC_2D)))\n      {\n        OutputMatrix2D->GetValue(ii, jj - 1).SetCond2D(CT_NONREFLECTED_2D);\n        nr_nodes++;\n      }\n\n      if (((((jj < (OutputMatrix2D->GetY() - 1)) && OutputMatrix2D->GetValue(ii, jj + 1).isCond2D(CT_NODE_IS_SET_2D)) && (!OutputMatrix2D->GetValue(ii, jj + 1).isCond2D(CT_WALL_NO_SLIP_2D))) && (!OutputMatrix2D->GetValue(ii, jj + 1).isCond2D(CT_SOLID_2D))) && (!OutputMatrix2D->GetValue(ii, jj + 1).isCond2D(NT_FC_2D)))\n      {\n        OutputMatrix2D->GetValue(ii, jj + 1).SetCond2D(CT_NONREFLECTED_2D);\n        nr_nodes++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/22"}
{"code": "for (int o = 1; o < 4; o++)\n  for (int p = 1; p < 4; p++)\n  for (int q = 1; q < 4; q++)\n  A[i][j][k][l][m][n][o][p][q] = A[i][j][k][l][m][n][o][p][q];\n\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/4.norace2/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  sum += a[i] + b[i];\n  printf(\"%d\\n\", sum);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Sum_of_arrays_using_reduction/0"}
{"code": "for (int i = 1; i < Nthr; i++)\n  suma.col(i) += suma.col(i - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/reverseCummulativeSum/2"}
{"code": "for (i = 1; i < 100; i++)\n{\n  for (j = 1; j < 100; j++)\n  {\n    my_islarger = check_i_islarger(i) && my_islarger;\n  }\n\n}\n\n", "pragma": "omp for private(i,j) schedule(static,1) collapse(2) ordered", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_collapse/0"}
{"code": "for (c2 = nl; c2 <= (nm + (-1)); c2++)\n{\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/85"}
{"code": "for (i2 = 0; i2 < (mm2 - 1); i2++)\n{\n  for (i1 = 0; i1 < (mm1 - 1); i1++)\n  {\n    ou[((((2 * i3) * n2) * n1) + (((2 * i2) + 1) * n1)) + (2 * i1)] = ou[((((2 * i3) * n2) * n1) + (((2 * i2) + 1) * n1)) + (2 * i1)] + (0.5 * z1[(((i3 * mm2) * mm1) + (i2 * mm1)) + i1]);\n    ou[((((2 * i3) * n2) * n1) + (((2 * i2) + 1) * n1)) + ((2 * i1) + 1)] = ou[((((2 * i3) * n2) * n1) + (((2 * i2) + 1) * n1)) + ((2 * i1) + 1)] + (0.25 * (z1[(((i3 * mm2) * mm1) + (i2 * mm1)) + i1] + z1[(((i3 * mm2) * mm1) + (i2 * mm1)) + (i1 + 1)]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i2,i1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/8"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n  for (int k = 1; k < (grid->getNZC() - 1); k++)\n{\n  const double q = q_factor * EMf->getRHOcs(i, j, k, 0);\n  for (int ii = 0; ii < npcelx; ii++)\n    for (int jj = 0; jj < npcely; jj++)\n    for (int kk = 0; kk < npcelz; kk++)\n  {\n    const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n    const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n    const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n    p0 = sqrt(((energy + 1) * (energy + 1)) - 1);\n    const double w = p0 * cos(pitch_angle);\n    pperp0 = p0 * sin(pitch_angle);\n    gyro_phase = ((2 * M_PI) * rand()) / ((double) RAND_MAX);\n    const double u = pperp0 * cos(gyro_phase);\n    const double v = pperp0 * sin(gyro_phase);\n    counter++;\n    create_new_particle(u, v, w, q, x, y, z);\n  }\n\n\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/9"}
{"code": "for (i = 0; i < L; i++)\n  for (k = 0; k < ((250 * 1024) / 256); k++)\n  C[(i * ((250 * 1024) / 256)) + k] = ((-((float) L)) * ((250 * 1024) / 256)) * ((250 * 1024) / 256);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/13"}
{"code": "for (i = 0; i < numtasks; i++)\n{\n  num_lines_to_send = (Nconsidered / numtasks) + 2;\n  if (rem > 0)\n  {\n    num_lines_to_send++;\n    rem--;\n  }\n\n  end_line = start_line + (num_lines_to_send - 1);\n  num_data_to_send = num_lines_to_send * 3000;\n  sendcounts[i] = num_data_to_send;\n  if (0)\n    printf(\"----> taskid = %d\\tworker%d\\trem = %d\\tnum_lines_to_send=%d\\tnum_data_to_send=%d\\tNconsidered=%d\\tstart_line=%d\\tend_line=%d\\n\", taskid, i, rem, num_lines_to_send, num_data_to_send, Nconsidered, start_line, end_line);\n\n  displs[i] = start_line * 3000;\n  start_line = end_line - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/18"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericContinuumParticles[i]->ContactAreaWeighting();\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/16"}
{"code": "for (int i = 0; i < a; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    suma = 0;\n    for (int k = 0; k < b; k++)\n    {\n      suma = suma + (vector[i][k] * matriz[k][j]);\n    }\n\n    resultado[i][j] = suma;\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejovanihh191197/MatrizXmatrizOpenMP/matrizxmatriz/1"}
{"code": "for (size_t i = 0; i < m; i++)\n{\n  ((f << \"\\tVector \") << i) << \" [ \";\n  for (size_t j = 0; j < n; j++)\n    (f << vectors[(i * n) + j]) << \" \";\n\n  (f << \"]\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ladislus/m2_php_mpi-project/omp/4"}
{"code": "for (i = 1; i < f; i++)\n{\n  for (j = 1; j < e; j++)\n  {\n    M[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  perm.push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pradyumnameena/COL380-Parallel-Programming/A1/openmp/5"}
{"code": "for (i = 1; i <= n; i++)\n{\n  X_Original[i] = (rand() % 10) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Pipelined Gaussian Elimination/MPI_OpenMp/18"}
{"code": "for (i = 2; i <= n; i++)\n{\n  prime = 1;\n  for (j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      prime = 0;\n      break;\n    }\n\n  }\n\n  total = total + prime;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/prime_local/0"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  w[j] = d;\n}\n\n", "pragma": "\t#pragma omp for private(d, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/13"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  double *X = X0 + ((i % cX) * rX);\n  double *Y = Y0 + ((i / cX) * rY);\n  double cc = 0.0;\n  double rc = 0.0;\n  size_t nn = 0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double t;\n    double y;\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    y = z - rc;\n    t = cc + y;\n    rc = (t - cc) - y;\n    cc = t;\n    nn++;\n  }\n\n  CC[i] = cc;\n  if (NN != NULL)\n    NN[i] = (double) nn;\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = rand() % range;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/Intel Vtune Amplifier and histogram/cat/0"}
{"code": "for (i = 0; i < m->size; i++)\n{\n  if ((maxIndexA[i] > value_max) && (value == m->tab[maxIndexA[i]]))\n  {\n    value_max = maxIndexA[i];\n  }\n\n  if ((minIndexA[i] < value_min) && (value == m->tab[minIndexA[i]]))\n  {\n    value_min = minIndexA[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(max: value_max) reduction(min: value_min)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/14"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    u[m][i][j][k] = u[m][i][j][k] + rhs[m][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/2"}
{"code": "for (i_imopVarPre77 = 1; i_imopVarPre77 <= n; i_imopVarPre77++)\n{\n  colidx[n + i_imopVarPre77] = 0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/0"}
{"code": "for (i = 0; i < 1024; i += BS)\n{\n  int j;\n  for (j = i; j < (i + BS); j++)\n  {\n    a[j] = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_15/0"}
{"code": "for (j = 0; j < d2; j++)\n{\n  for (ii = 0; ii <= (d1 - fftblock); ii += fftblock)\n  {\n    for (k = 0; k < d3; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        ty1[k][i] = x[k][j][i + ii];\n      }\n\n    }\n\n    cfftz(is, logd3, d3, ty1, ty2);\n    for (k = 0; k < d3; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        xout[k][j][i + ii] = ty1[k][i];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,ii)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/6"}
{"code": "for (k = 0; k <= (d[2] - 1); k += 1)\n{\n  for (i = 0; i <= (fftblock - 1); i += 1)\n  {\n    y0[k][i].real = x[k][j][i + ii].real;\n    y0[k][i].imag = x[k][j][i + ii].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/13"}
{"code": "for (i = 0; i < 21; i++)\n{\n  lsum += i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenCMISS-Dependencies/opari2/doc/example/example/0"}
{"code": "for (int k = 0; k < IMAGE_HEIGHT; ++k)\n{\n  img_lbp[k][0] = 0;\n  img_lbp[k][IMAGE_WIDTH - 1] = 0;\n  hist[img[k][IMAGE_WIDTH - 1]]++;\n  hist[img[k][0]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/egebasturk/Parallel-Computing-Projects/Project3/cs426_project3_code/lbp_omp/6"}
{"code": "for (k = 0; k <= dim_k; k++)\n{\n  for (j = 0; j <= dim_j; j++)\n  {\n    for (i = 0; i <= dim_i; i++)\n    {\n      int ijk = ((i + ghosts) + ((j + ghosts) * jStride)) + ((k + ghosts) * kStride);\n      double x = hLevel * (((double) (i + level->my_boxes[box].low.i)) + 0.5);\n      double y = hLevel * (((double) (j + level->my_boxes[box].low.j)) + 0.5);\n      double z = hLevel * (((double) (k + level->my_boxes[box].low.k)) + 0.5);\n      double A;\n      double Bi;\n      double Bj;\n      double Bk;\n      A = 1.0;\n      Bi = 1.0;\n      Bj = 1.0;\n      Bk = 1.0;\n      double F = evaluateF(x, y, z, hLevel, 1, 1, 1);\n      level->my_boxes[box].vectors[VECTOR_ALPHA][ijk] = A;\n      level->my_boxes[box].vectors[VECTOR_BETA_I][ijk] = Bi;\n      level->my_boxes[box].vectors[VECTOR_BETA_J][ijk] = Bj;\n      level->my_boxes[box].vectors[VECTOR_BETA_K][ijk] = Bk;\n      level->my_boxes[box].vectors[VECTOR_F][ijk] = F;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k,j,i) collapse(3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/problem.fv/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  buffer[i] = i;\n  buffer_values[i] = v_scores[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/21"}
{"code": "for (int k = 0; k < np; k++)\n{\n  amp_right[k] = complex(0., 0.);\n  amp_left[k] = complex(0., 0.);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/45"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i + 1;\n  b[i] = i + 2;\n  validate[i] = sqrt(a[i]) * sqrt(b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/math_sqrt_float/math_sqrt_float/1"}
{"code": "for (int k_iter = 0; k_iter < n_iter; k_iter++)\n{\n  if (rank != SERIAL_NO_RANK)\n  {\n    double l_recv_buf;\n    double r_recv_buf;\n    l_recv_buf = 0.0;\n    r_recv_buf = 0.0;\n    MPI_Request recv_reqs_lhs[2];\n    MPI_Request send_reqs_lhs[2];\n    PARALLEL_MPI_exchange_boundaries(rank, num_mpi_ranks, &l_recv_buf, &r_recv_buf, &z_psi_iter_l[0], &z_psi_iter_l[num_x_pts - 1], 1, recv_reqs_lhs, send_reqs_lhs);\n    build_new_main_diag(za_main_diag_l, z_psi_iter_l, num_x_pts, x_left, dx, g_coeff, z_alpha, z_beta, potential_scaling, dimensional_frequency);\n    PARALLEL_MPI_check_waits(recv_reqs_lhs, rank, num_mpi_ranks);\n    z_psi_explicit_l[0] = z_explicit_top_elem + (z_alpha * l_recv_buf);\n    z_psi_explicit_l[num_x_pts - 1] = z_explicit_bottom_elem + (z_alpha * r_recv_buf);\n    PARALLEL_MPI_check_waits(send_reqs_lhs, rank, num_mpi_ranks);\n  }\n  else\n  {\n    build_new_main_diag(za_main_diag_l, z_psi_iter_l, num_x_pts, x_left, dx, g_coeff, z_alpha, z_beta, potential_scaling, dimensional_frequency);\n  }\n\n  int ierr = tridag_cplx(za_main_diag_l, za_lower_diag_l, za_upper_diag_l, z_psi_explicit_l, z_psi_implicit_l, num_x_pts, z_workspace_vec_l);\n  if (ierr != 0)\n  {\n    printf(\"Matrix inversion failed. Exiting\\n\");\n    MPI_Finalize();\n    exit(1);\n  }\n\n  double *z_psi_temp = z_psi_iter_l;\n  z_psi_iter_l = z_psi_implicit_l;\n  z_psi_implicit_l = z_psi_temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-richards/HPC_Code/3d_hybrid/11"}
{"code": "for (int i = 0; i < data_size; i++)\n{\n  myFile >> data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abitha-thankaraj/tsm-parallel/tsm-parallel-scratch/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double *f = spheres[i].color;\n  if ((f[0] > f[1]) && (f[0] > f[2]))\n    spheres[i].max_reflexivity = f[0];\n  else\n  {\n    if (f[1] > f[2])\n      spheres[i].max_reflexivity = f[1];\n    else\n      spheres[i].max_reflexivity = f[2];\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_omp/pathtracer_omp/0"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n{\n  Movers[ip]->put(qmcNode);\n  Movers[ip]->resetRun(branchClones[ip], estimatorClones[ip], traceClones[ip]);\n  if (QMCDriverMode[QMC_UPDATE_MODE])\n    Movers[ip]->initWalkersForPbyP(W.begin() + wPerNode[ip], W.begin() + wPerNode[ip + 1]);\n  else\n    Movers[ip]->initWalkers(W.begin() + wPerNode[ip], W.begin() + wPerNode[ip + 1]);\n\n  for (int prestep = 0; prestep < nWarmupSteps; ++prestep)\n    Movers[ip]->advanceWalkers(W.begin() + wPerNode[ip], W.begin() + wPerNode[ip + 1], true);\n\n  if (nWarmupSteps && QMCDriverMode[QMC_UPDATE_MODE])\n    Movers[ip]->updateWalkers(W.begin() + wPerNode[ip], W.begin() + wPerNode[ip + 1]);\n\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/VMC/VMCSingleOMP/0"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  uint32_t localEdgesPlus_idx = 0;\n  uint32_t localEdgesMinus_idx = 0;\n  src = graph->sorted_edges_array->edges_array_src[e];\n  dest = graph->sorted_edges_array->edges_array_dest[e];\n  if (src <= dest)\n  {\n    localEdgesPlus_idx = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_src[localEdgesPlus_idx] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_dest[localEdgesPlus_idx] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (src > dest)\n  {\n    localEdgesMinus_idx = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_src[localEdgesMinus_idx] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_dest[localEdgesMinus_idx] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,src,dest) shared(edgesMinus_idx,edgesPlus_idx, edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/4"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (NX / 2)) % NX) - (NX / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (NY / 2)) % NY) - (NY / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (NZ / 2)) % NZ) - (NZ / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i ,j ,k ,ii ,ii2 ,jj ,ij2 ,kk )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/FT/ft/0"}
{"code": "for (i = 0; i < n; ++i)\n  temp += x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/main/0"}
{"code": "for (int i = 0; i < nthreads; i++)\n  seeds[i] = random();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aswild/omp-randarray/randarray/1"}
{"code": "for (int cx = 0; cx < nxc; cx++)\n  for (int cy = 0; cy < nyc; cy++)\n  for (int cz = 0; cz < nzc; cz++)\n{\n  (*bucket_offset)[cx][cy][cz] = accpcls;\n  accpcls += (*numpcls_in_bucket)[cx][cy][cz];\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3Dcomm/6"}
{"code": "for (i = 4; i < 11; i++)\n{\n  matrix_size = pow(2, i);\n  A = malloc_matrix(matrix_size);\n  B = malloc_matrix(matrix_size);\n  C = malloc_matrix(matrix_size);\n  init_matrix(A, B, matrix_size);\n  for (j = 0; j < numreps; j++)\n  {\n    gettimeofday(&tv1, &tz);\n    multiply_matrix_omp_dynamic(A, B, C, matrix_size);\n    one_norm_omp_dynamic = matrix_one_norm_omp(C, matrix_size);\n    gettimeofday(&tv2, &tz);\n    elapsed = ((double) (tv2.tv_sec - tv1.tv_sec)) + (((double) (tv2.tv_usec - tv1.tv_usec)) * 1.e-6);\n    average += elapsed;\n    printf(\"matrix size %d, matrix_one_norm_omp takes %lf sec \\n\", matrix_size, elapsed);\n  }\n\n  average = average / 3;\n  WriteData(\"out_omp_dynamic.csv\", matrix_size, average);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/s27y/openmp_matrixmultip/openmp_matrixmultip/6"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    x = ((((double) (j - 1)) * x_max) + (((double) (m - j)) * x_min)) / ((double) (m - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (n - i)) * y_min)) / ((double) (n - 1));\n    count[i][j] = 0;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if ((count[i][j] % 2) == 1)\n    {\n      r[i][j] = 255;\n      g[i][j] = 255;\n      b[i][j] = 255;\n    }\n    else\n    {\n      c = (int) (255.0 * sqrt(sqrt(sqrt(((double) count[i][j]) / ((double) count_max)))));\n      r[i][j] = (3 * c) / 5;\n      g[i][j] = (3 * c) / 5;\n      b[i][j] = c;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/mandelbrot_openmp/0"}
{"code": "for (i = 0; i < samples; i++)\n{\n  x = (((double) rand_r(&seed)) / 32767) - 0.5;\n  y = (((double) rand_r(&seed)) / 32767) - 0.5;\n  z = (x * x) + (y * y);\n  if (z <= 0.25)\n  {\n    count += 1;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jillmao/pthread-and-openmp/openmp/0"}
{"code": "for (long i = 0; i < nC1; i++)\n{\n  commPtr1[i] = 0;\n  commAdded1[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/4"}
{"code": "for (int k = 0; k < width; k++)\n{\n  double x = a[(i * width) + k];\n  double y = b[(k * width) + j];\n  sum += x * y;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa04/mm/1"}
{"code": "for (col = 0; col < P; col++)\n{\n  memcpy(v_col, A_T + (col * P), (sizeof(float)) * P);\n  for (row = 0; row < col; row++)\n  {\n    result = 0.0;\n    for (row_ = 0; row_ < P; row_++)\n    {\n      result += Q_current[(row_ * P) + row] * A_T[(col * P) + row_];\n    }\n\n    R_current[(row * P) + col] = result;\n    for (row_ = 0; row_ < P; row_++)\n    {\n      v_col[row_] -= R_current[(row * P) + col] * Q_current[(row_ * P) + row];\n    }\n\n  }\n\n  R_current[(col * P) + col] = l2_norm(v_col, P);\n  for (row = 0; row < P; row++)\n  {\n    Q_current[(row * P) + col] = v_col[row] / R_current[(col * P) + col];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/10"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    (cout << result2[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ladalada/OpenMP/task_4/4/3"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  if (i == (iter / 2))\n  {\n    time1_local = omp_get_wtime();\n  }\n\n  evolve(u, w, h);\n  if (i == (iter / 2))\n  {\n    time2_local = omp_get_wtime();\n    elapsed_local = time2_local - time1_local;\n    printf(\"Evolve function time > %f \\n\", elapsed_local);\n  }\n\n  usleep(200000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task3_gameoflife/gameoflife_omp/gameoflife/1"}
{"code": "for (i = 0; i < leaf_counter; i++)\n{\n  for (j = 0; j < leaf[i].n; j++)\n  {\n    x = fabs(leaf[i].center[0] - A[leaf[i].points[j]][0]);\n    y = fabs(leaf[i].center[1] - A[leaf[i].points[j]][1]);\n    z = fabs(leaf[i].center[2] - A[leaf[i].points[j]][2]);\n    if (((x < (leaf[i].length / 2)) && (y < (leaf[i].length / 2))) && (z < (leaf[i].length / 2)))\n    {\n      points_counter++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikos912000/octree-partitioning/octree_openmp/octree_openmp/11"}
{"code": "for (int j = 2; j < (number + 1); j++)\n{\n  if (A[j] != 0)\n  {\n    L[i] = A[j];\n    i = i + 1;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/4"}
{"code": "for (j = 0; i >= 0; ++j, --i)\n  buf[j] = temp[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaodao90/wrapper/OpenMP/OMP_wrapper/1"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  c[i] = 0;\n  for (int j = 0; j < 5; j++)\n  {\n    if ((a[i] > a[j]) || ((i < j) && (a[i] == a[j])))\n      c[i] += 1;\n    else\n      c[i] += 0;\n\n  }\n\n  b[c[i]] = a[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Srinidi-V/openmp/enumeration/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = ky - 1;\n  if (kl < 0)\n    kl += my1;\n\n  kl = kl * mx1;\n  kr = ky + 1;\n  if (kr >= my1)\n    kr -= my1;\n\n  kr = kr * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = kxr + kk;\n  ks[1] = kxl + kk;\n  ks[2] = kx + kr;\n  ks[3] = kxr + kr;\n  ks[4] = kxl + kr;\n  ks[5] = kx + kl;\n  ks[6] = kxr + kl;\n  ks[7] = kxl + kl;\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 8; ii++)\n  {\n    nboff = (idimp * npbmx) * ks[ii];\n    if (ii > 0)\n      ncoff = ncl[(ii - 1) + (8 * ks[ii])];\n\n    ip = ncl[ii + (8 * ks[ii])] - ncoff;\n    ipp = ip / 16;\n    for (m = 0; m < ipp; m++)\n    {\n      joff = 16 * m;\n      for (j = 0; j < 16; j++)\n      {\n        if ((j + ih) < nh)\n        {\n          j1 = ihole[2 * (((j + ih) + 1) + ((ntmax + 1) * k))] - 1;\n        }\n        else\n        {\n          j1 = ((npp + j) + ih) - nh;\n        }\n\n        n[j] = j1;\n      }\n\n      for (i = 0; i < idimp; i++)\n      {\n        for (j = 0; j < 16; j++)\n        {\n          j1 = n[j];\n          if (j1 < nppmx)\n          {\n            ppart[(j1 + (nppmx * i)) + npoff] = ppbuff[(((j + joff) + ncoff) + (npbmx * i)) + nboff];\n          }\n          else\n          {\n            ist = 1;\n          }\n\n        }\n\n      }\n\n      ih += 16;\n    }\n\n    nps = 16 * ipp;\n    for (j = nps; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        j1 = ((npp + ih) - nh) - 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j1 + (nppmx * i)) + npoff] = ppbuff[((j + ncoff) + (npbmx * i)) + nboff];\n        }\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ih > nh)\n    npp = (npp + ih) - nh;\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    ii = nh;\n    ipp = ip / 16;\n    for (m = 0; m < ipp; m++)\n    {\n      joff = 16 * m;\n      for (j = 0; j < 16; j++)\n      {\n        n[j + 16] = ihole[2 * (((ih + j) + 1) + ((ntmax + 1) * k))] - 1;\n        n[j + (2 * 16)] = ihole[2 * ((ii - j) + ((ntmax + 1) * k))] - 1;\n      }\n\n      in = 0;\n      mm = 0;\n      nn = n[in + (2 * 16)];\n      for (j = 0; j < 16; j++)\n      {\n        j1 = ((npp - j) - joff) - 1;\n        n[j] = n[mm + 16];\n        if (j1 == nn)\n        {\n          in += 1;\n          nn = n[in + (2 * 16)];\n          n[j] = -1;\n        }\n        else\n        {\n          mm += 1;\n        }\n\n      }\n\n      for (i = 0; i < idimp; i++)\n      {\n        #pragma ivdep\n        for (j = 0; j < 16; j++)\n        {\n          j1 = ((npp - j) - joff) - 1;\n          j2 = n[j];\n          if (j2 >= 0)\n          {\n            ppart[(j2 + (nppmx * i)) + npoff] = ppart[(j1 + (nppmx * i)) + npoff];\n          }\n\n        }\n\n      }\n\n      ii -= in;\n      ih += mm;\n    }\n\n    nps = 16 * ipp;\n    nn = ihole[2 * (ii + ((ntmax + 1) * k))] - 1;\n    ih += 1;\n    j2 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n    for (j = nps; j < ip; j++)\n    {\n      j1 = (npp - j) - 1;\n      if (j1 == nn)\n      {\n        ii -= 1;\n        nn = ihole[2 * (ii + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j2 + (nppmx * i)) + npoff] = ppart[(j1 + (nppmx * i)) + npoff];\n        }\n\n        ih += 1;\n        j2 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n\n    }\n\n    npp -= ip;\n  }\n\n  kpic[k] = npp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ii,kk,in,npp,npoff,nboff,ipp,joff,nps,kx,ky,kl,kr,kxl, kxr,ih,nh,nn,mm,ncoff,ist,j1,j2,ip,ks,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/14"}
{"code": "for (k = 0; k < d3; k++)\n{\n  for (ii = 0; ii <= (d1 - FFTBLOCK); ii += FFTBLOCK)\n  {\n    for (j = 0; j < d2; j++)\n    {\n      for (i = 0; i < FFTBLOCK; i++)\n      {\n        y1[j][i] = x[k][j][i + ii];\n      }\n\n    }\n\n    cfftz(is, logd2, d2, y1, y2);\n    for (j = 0; j < d2; j++)\n    {\n      for (i = 0; i < FFTBLOCK; i++)\n      {\n        xout[k][j][i + ii] = y1[j][i];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    vijk = vs[i][j][k];\n    vp1 = vs[i][j + 1][k];\n    vm1 = vs[i][j - 1][k];\n    rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n    rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n    rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n    rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n    rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,vijk ,vp1 ,vm1 ,ty2 ,dy1ty1 ,yycon2 ,dy2ty1 ,c2 ,dy3ty1 ,con43 ,dy4ty1 ,c1 ,yycon5 ,yycon3 ,dy5ty1 ,yycon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/113"}
{"code": "for (j = 0; j < N; j++)\n{\n  b[j] = c[j];\n}\n\n", "pragma": "omp parallel for shared(b) firstprivate(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/twoRegions/0"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    tmp[i] += mat[i][j] * src[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IacopomC/openMp-CUDA-Image-Processing/image_openmp/4"}
{"code": "for (i = 0; i < 500; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/FDTD2D/fdtd2d/4"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  for (wJ = 0; wJ < BIGN_MATR; wJ += 2)\n  {\n    wV1 = _mm_load_pd(&aMatr1[wI][wJ]);\n    wV2 = _mm_load_pd(&aMatr2[wI][wJ]);\n    wV3 = _mm_add_pd(wV1, wV2);\n    _mm_store_pd(&aMatr3[wI][wJ], wV3);\n  }\n\n}\n\n", "pragma": "omp parallel for private(wI, wJ, wV1, wV2, wV3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/1"}
{"code": "for (i = 521; i <= 2025; ++i)\n{\n  printf(\"%f  \", base[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB052-indirectaccesssharebase-orig-no/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (flag[i] == 1)\n  {\n    if (prev[i] >= 0)\n      next[prev[i]] = next[i];\n\n    if (next[i] >= 0)\n    {\n      data[next[i]] += data[i];\n      prev[next[i]] = prev[i];\n    }\n\n    chkdata[i] = data[i];\n    chkprev[i] = prev[i];\n    chknext[i] = next[i];\n    data[i] = -1;\n    chkidx[i] = idx;\n    count--;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(-:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/independentSet/ind_set/4"}
{"code": "for (j = 0; j < (nrows + 1); j++)\n{\n  rowstr[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nctu-homeworks/PP-hw2/cg/11"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp9un1h2qc.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/llvm-openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (i = 0; i < n_blocks; ++i)\n  for (j = 0; j < n_blocks; ++j)\n  for (k = 0; k < n_blocks; ++k)\n  matrixMultiplication(*((*(matrixA + i)) + k), *((*(matrixB + k)) + j), *((*(matrixC + i)) + j), ((i == (n_blocks - 1)) && ((2048 % ((int) floor(sqrt(16)))) != 0)) ? (2048 % ((int) floor(sqrt(16)))) : ((int) floor(sqrt(16))), ((k == (n_blocks - 1)) && ((2048 % ((int) floor(sqrt(16)))) != 0)) ? (2048 % ((int) floor(sqrt(16)))) : ((int) floor(sqrt(16))), ((j == (n_blocks - 1)) && ((2048 % ((int) floor(sqrt(16)))) != 0)) ? (2048 % ((int) floor(sqrt(16)))) : ((int) floor(sqrt(16))));\n\n\n\n", "pragma": "omp parallel for default(none) shared(n_blocks, matrixA, matrixB, matrixC) private(i,j,k) num_threads(NUM_THREADS[num_threads_index]) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-2/codes/with-openmp/blockordermultiply/0"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  out3[i] = sigmoid(in3[i]);\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/7"}
{"code": "for (i = 0; i < num_steps; i += 1)\n{\n  double x = (i - 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/figgefred/OpenMP-Pi-Sample/src/pi_3/0"}
{"code": "for (index = 0; index < count; index++)\n  if (!strcmp((char *) binary, crypt_out[index]))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/c3_fmt/0"}
{"code": "for (int i = 0; i < maxThreads; i++)\n{\n  vertexSetClear(&threadFrontiers[i]);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/0"}
{"code": "for (i = 0; i < K; i++)\n{\n  clusters[i].centerX = clusters[i].sumX / clusters[i].counter;\n  clusters[i].centerY = clusters[i].sumY / clusters[i].counter;\n  clusters[i].centerZ = clusters[i].sumZ / clusters[i].counter;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SlavKhizverg/Parallel-Computation---written-in-C-using-openMP-and-MPI/ParallelProject/Source/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"#\");\n  for (int j = 0; j < N; j++)\n    printf(\"%.2f \", m1[i][j]);\n\n  printf(\"#\");\n  if (i == (N - 1))\n    printf(\"* #%.2f# = #%.3f#\\n\", v2[i], v3[i]);\n  else\n    printf(\"  #%.2f# = #%.3f#\\n\", v2[i], v3[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer8/pmtv-OpenMP/4"}
{"code": "for (int i = 0; i < ((int) mSwimmingSphereElementPointers.size()); ++i)\n{\n  weighing_function.ComputeWeights(mVectorsOfDistances[i], mVectorsOfRadii[i], mMaxNodalAreaInv, mVectorsOfDistances[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/SwimmingDEMApplication/custom_utilities/binbased_DEM_fluid_coupled_mapping/0"}
{"code": "for (i = 0; i < order; i++)\n{\n  if (i != (order - 1))\n    printf(\"%dx\", dimensionality[i]);\n  else\n    printf(\"%d\\t\", dimensionality[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/7"}
{"code": "for (ii = (ii * 10) + 25; ii < ((ii / ii) - 23); ii += 1)\n  ;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/test/OpenMP/for_loop_messages/3"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + .5) * step;\n  tab[id] += 4.0 / (1. + (x * x));\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritaly/OWS/pi_tab/0"}
{"code": "for (i = 0; i < (NumberofReaderThread + NumberofWriterThread); i++)\n{\n  int tid = omp_get_thread_num();\n  val = rand() % 20;\n  if (i < NumberofReaderThread)\n    sleep(val);\n\n  if (i < NumberofReaderThread)\n  {\n    printf(\"Reader thread\\n\");\n    while (1)\n    {\n      if (omp_test_lock(&writelock))\n      {\n        omp_unset_lock(&writelock);\n        printf(\"Value read is:%d\\n\", global_var);\n        break;\n      }\n\n    }\n\n  }\n  else\n  {\n    printf(\"Writer thread\\n\");\n    while (1)\n    {\n      printf(\"%d writer trying for lock\", i - NumberofReaderThread);\n      if (omp_test_lock(&writelock))\n      {\n        global_var++;\n        printf(\"Value incremented, lock held by writer %d\\n\", i - NumberofReaderThread);\n        sleep(0.1);\n        omp_unset_lock(&writelock);\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/suparna-ghanvatkar/Concurrent-Reader-Writer-/readwrite/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  printf(\"%f\\t\", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/25"}
{"code": "for (i = 0; i <= 999; i += 1)\n{\n  for (j = 0; j <= 999; j += 1)\n  {\n    printf(\"%lf\\n\", a[i][j]);\n  }\n\n  printf(\"%lf\\n\", v_out[i]);\n  printf(\"%lf\\n\", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB062-matrixvector2-orig-no/3"}
{"code": "for (int j = 0; j < n; j++)\n{\n  A[j][0] = 1.0;\n  Anew[j][0] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbertDeFusco/openmp-workshop/src/laplace2d/laplace2d/0"}
{"code": "for (int py = 0; py < nPixX; py++)\n{\n  for (int px = 0; px < nPixY; px++)\n  {\n    const int pos = (((nPixX * nPixY) * nz) + (py * nPixY)) + px;\n    int coordA = (py * nPixYMap) + px;\n    int coordB = ((py + 1) * nPixYMap) + px;\n    int coordC = coordA + 1;\n    int coordD = coordB + 1;\n    double gamma = atan(((d_pObjX[py] + (dx / 2.0)) - tubeX) / (rtubeZ - d_pObjZ[nz]));\n    double alpha = atan(((d_pObjY[px] + (dy / 2.0)) - rtubeY) / (rtubeZ - d_pObjZ[nz]));\n    double dA;\n    double dB;\n    double dC;\n    double dD;\n    dA = d_sliceI[coordA];\n    dB = d_sliceI[coordB];\n    dC = d_sliceI[coordC];\n    dD = d_sliceI[coordD];\n    if ((dC == 0) && (dD == 0))\n    {\n      dC = dA;\n      dD = dB;\n    }\n\n    d_pVolume[pos] += (((dD - dC) - dB) + dA) * (((du * dv) * dz) / (((cos(alpha) * cos(gamma)) * dx) * dy));\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/7"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpyiw12lxx.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)];\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/3"}
{"code": "for (v = size_k - topk; v < size_k; v++)\n{\n  if (array2[array1[v]] >= (size_k - topk))\n    intersection++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/13"}
{"code": "for (i = 1; i < (NI - 1); ++i)\n{\n  for (j = 1; j < (NJ - 1); ++j)\n  {\n    B[(i * NJ) + j] = ((((((((c11 * A[((i - 1) * NJ) + (j - 1)]) + (c12 * A[((i + 0) * NJ) + (j - 1)])) + (c13 * A[((i + 1) * NJ) + (j - 1)])) + (c21 * A[((i - 1) * NJ) + (j + 0)])) + (c22 * A[((i + 0) * NJ) + (j + 0)])) + (c23 * A[((i + 1) * NJ) + (j + 0)])) + (c31 * A[((i - 1) * NJ) + (j + 1)])) + (c32 * A[((i + 0) * NJ) + (j + 1)])) + (c33 * A[((i + 1) * NJ) + (j + 1)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  *(result + (j + (i * n))) = 0;\n  for (k = 0; k < n; k++)\n    *(result + (j + (i * n))) += (*(A + (k + (i * n)))) * (*(B + (j + (k * n))));\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_7/QUESTION_7-b/TD_OPENMP_07b/1"}
{"code": "for (i = 0; i < n; ++i)\n  tab[i] = rand() % 100;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_9/a/TD_OPENMP_09/1"}
{"code": "for (i = 0; i < DIM; i++)\n  mins_seq[i] = m[i][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/min_max_matrix_element/4"}
{"code": "for (i = 0; i < num_init_infected; i++)\n{\n  states[i] = INFECTED;\n  num_infected++;\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:num_infected)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-omp-exercise-solns/pandemic/0"}
{"code": "for (int i = 0; i < arg; i++)\n  ;\n\n", "pragma": "omp for reduction(+: a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/target_vla_messages/0"}
{"code": "for (i = ((pad_size_X * pad_size_Y) / 4) * 4; i < (pad_size_X * pad_size_Y); i++)\n{\n  padin[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hyeminchocho/ImageProcessingOptimization/part2/4"}
{"code": "for (int i = 0; i < num_input_samples; i++)\n{\n  inputAF.samples[0][i] = inputAF.samples[0][i] * 2;\n  if (inputAF.samples[0][i] >= 1)\n    inputAF.samples[0][i] = .99;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tristanelma/reverb_parallelization/project/impulse_parallel/2"}
{"code": "for (i = 0; i < prob->l; i++)\n  if (fabs(f.alpha[i]) > 0)\n  ++nSV;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/52"}
{"code": "for (i = 0; i < numClusters; i++)\n{\n  for (j = 0; j < numCoords; j++)\n  {\n    if (newClusterSize[i] > 1)\n      clusters[i][j] = newClusters[i][j] / newClusterSize[i];\n\n    newClusters[i][j] = 0.0;\n  }\n\n  newClusterSize[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/9"}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  omp_destroy_lock(&lock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/04_locks/2"}
{"code": "for (int s = 11; s >= 0; s--)\n{\n  for (int i = (nRows / 2) - s; i < ((nRows / 2) + s); i++)\n  {\n    size_t offset = i * nCols;\n    for (int k = (nCols / 2) - s; k < ((nCols / 2) + s); k++)\n    {\n      ptr_prev[offset + k] = wavelet[s];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/iso2dfd-omp/iso2dfd/1"}
{"code": "for (i = 0; i < total_elems; i++)\n{\n  total_input[i] = rand();\n  if (verbose)\n    printf(\"%d\\n\", total_input[i]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mantri/parallel_algorithms/sample_sort/2"}
{"code": "for (int i = 1; i < (n + 1); i++)\n{\n  for (int j = 1; j < (n + 1); j++)\n  {\n    suma += i * j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/prob_2/1"}
{"code": "for (long pidx_darts_counter_temp1218 = *pidx; (pidx_darts_counter_temp1218 < endRange) && (pidx_darts_counter_temp1218 < this->inputsTPParent->lastIteration1218); pidx_darts_counter_temp1218++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1218], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/48"}
{"code": "for (unsigned int var = 2; var < chrmsm.size(); ++var)\n{\n  int tc = (var - 2) * chrmsm[var].size();\n  for (unsigned int var2 = 0; var2 < chrmsm[var].size(); var2++)\n  {\n    Lastst = Lastet + 1;\n    taskList[tc].setStarttime(Lastst);\n    Lastet = Lastst + ((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    taskList[tc].setEndtime(Lastet);\n    taskList[tc].setExectime((1000 * ((long) ((taskList[tc].getVal() / processors[chrmsm[var].at(var2)].getSpeed()) * 10000))) / 10000);\n    taskListNoDup.push_back(taskList[tc]);\n    tc++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/19"}
{"code": "for (int fcnt = threadID; fcnt < fifo_curr_size(masterQueue); fcnt += numThreads)\n{\n  unsigned int initID;\n  fifo_idx_read(masterQueue, fcnt, &initID);\n  fifo_write(localQueue, initID);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apollo12221/Parallel-AG-Gen-Docker/c_bfs/9"}
{"code": "for (int i = 0; i < _bondcalculations.size(); ++i)\n{\n  if (gradients)\n  {\n    AddGradient(_bondcalculations[i].force_a, _bondcalculations[i].idx_a);\n    AddGradient(_bondcalculations[i].force_b, _bondcalculations[i].idx_b);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/0"}
{"code": "for (i = 0; i < 180; i++)\n{\n  xnew_ptr[i] = xnew[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/2"}
{"code": "for (iter = 0; iter < iterations; iter++)\n{\n  omp_set_lock(counter_lock[my_ID]);\n  (*pcounter1[my_ID])++;\n  (*pcounter2[my_ID])++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/RefCount_private/private/3"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((((m != centre) && (m != near_ind[0])) && (m != near_ind[1])) && (m != near_ind[2]))\n  {\n    if ((min4 == (-1.0)) || (dist_list[m] < min4))\n    {\n      min4 = dist_list[m];\n      near_ind[3] = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/14"}
{"code": "for (i = 0; i < NN; i++)\n{\n  Alin[i] = ((float) rand()) / ((float) RAND_MAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/matrix_multiplication/dense_algebra_omp/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  adjacent_processes[i]->cells_buffer_send = 0;\n  adjacent_processes[i]->cells_buffer_recv = 0;\n  adjacent_processes[i]->length_send_buffer = 0;\n  adjacent_processes[i]->sent = 0;\n  adjacent_processes[i]->received = 0;\n  adjacent_processes[i]->index = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/13"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (!test_omp_for_schedule_guided())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_guided/4"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  sum_a += a[i];\n  sum_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task6/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    d[(nab * i) + j] = d_input[(n * i) + j];\n    t[(nab * i) + j] = d_input[(n * j) + i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallel-rust-cpp/shortcut-comparison/src/cpp/v2_instr_level_parallelism/step/0"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  c[j] += a[i] * b[i];\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB111-linearmissing-orig-yes/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpf3xlahq5.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/affinity/format/affinity_values/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (cout << adj_matrix[0][i]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_multithread/0"}
{"code": "for (j_it = 0; j_it < size; j_it++)\n{\n  for (k_it = 0; k_it < size; k_it++)\n  {\n    if ((((((i_it == 0) || (i_it == (((1 << 6) + 2) - 1))) || (j_it == 0)) || (j_it == (((1 << 6) + 2) - 1))) || (k_it == 0)) || (k_it == (((1 << 6) + 2) - 1)))\n    {\n      matrix[j_it][k_it] = 0.;\n    }\n    else\n    {\n      matrix[j_it][k_it] = ((4. + i_it) + j_it) + k_it;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GetsuDer/Sor3D/Source/openmp_code/4"}
{"code": "for (inemo = 0; inemo <= nemo[imor]; inemo++)\n{\n  ie = emo[imor][inemo][0];\n  sizei = size_e[ie];\n  cornernumber = emo[imor][inemo][1];\n  sface = 0;\n  sedge = 0;\n  for (iiface = 0; iiface < 3; iiface++)\n  {\n    iface = f_c[cornernumber][iiface];\n    if (cbc[ie][iface] == 3)\n    {\n      sface = sface + 1;\n    }\n\n  }\n\n  for (iiedge = 0; iiedge < 3; iiedge++)\n  {\n    iedge = e_c[cornernumber][iiedge];\n    if (ncon_edge[ie][iedge])\n      sedge = sedge + 1;\n\n  }\n\n  if (sface == 0)\n  {\n    if (sedge == 0)\n    {\n      n = 7;\n    }\n    else\n      if (sedge == 1)\n    {\n      n = 0;\n    }\n    else\n      if (sedge == 2)\n    {\n      n = 1;\n    }\n    else\n      if (sedge == 3)\n    {\n      n = 2;\n    }\n\n\n\n\n  }\n  else\n    if (sface == 1)\n  {\n    if (sedge == 1)\n    {\n      n = 4;\n    }\n    else\n    {\n      n = 3;\n    }\n\n  }\n  else\n    if (sface == 2)\n  {\n    n = 5;\n  }\n  else\n    if (sface == 3)\n  {\n    n = 6;\n  }\n\n\n\n\n  tmortemp = tmortemp + pcmor_cor[sizei][n];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/precond/9"}
{"code": "for (int i = 0; i < arrayLength; i++)\n{\n  intArray[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/allywarner/HPC_OpenMP/Quicksort/main/4"}
{"code": "for (j = 0; j < tmp; j++)\n  genOrders();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/main/2"}
{"code": "for (int i = 0; i < 10; i |= 2)\n  ++i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/5"}
{"code": "for (i = 1; i < dims[0]; i++)\n{\n  coord_buffer[i] = coord_buffer[0] + (i * dims[1]);\n  block_sz_buffer[i] = block_sz_buffer[0] + (i * 2);\n  node_buffer[i] = node_buffer[0] + i;\n  vel_x_buffer[i] = vel_x_buffer[0] + (((i * 1) * 8) * 8);\n  vel_y_buffer[i] = vel_y_buffer[0] + (((i * 1) * 8) * 8);\n  dens_buffer[i] = dens_buffer[0] + (((i * 1) * 8) * 8);\n  pres_buffer[i] = pres_buffer[0] + (((i * 1) * 8) * 8);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/2"}
{"code": "for (row = 0; row < n; row++)\n{\n  x[row] = b[row];\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) private(row) shared(x, b, n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-4col/0"}
{"code": "for (i = 0; i < mat1_1d; i++)\n{\n  result_matr[i] = malloc(mat2_2d * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/6"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) II[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/113"}
{"code": "for (i = 0; i < (((2048 / NODESX) + 2) / 2); i++)\n{\n  for (j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    if (whites[i][j].isGhost == 1)\n    {\n      spin = whites[i][j].data;\n      spin_neigh_n = blacks[i][j].data;\n      spin_neigh_e = blacks[i][j + 1].data;\n      spin_neigh_w = blacks[i][j - 1].data;\n      spin_neigh_s = blacks[i + ((2 * (j % 2)) - 1)][j].data;\n      E += (((spin == spin_neigh_n) + (spin == spin_neigh_e)) + (spin == spin_neigh_w)) + (spin == spin_neigh_s);\n      Mt[spin] += 1;\n      spin = blacks[i][j].data;\n      Mt[spin] += 1;\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:E) schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/96"}
{"code": "for (int i = 0; i < iterations; i++)\n  AIDW_Kernel_Tiled(d_dx, d_dy, d_dz, dnum, d_ix, d_iy, d_iz, inum, area, d_avg_dist);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aidw-omp/main/4"}
{"code": "for (i = 0; i < 10; i++)\n{\n  ival = (int) sample(arr[i]);\n  hist[ival]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram/1"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  if (products[i].currentCluster != products[i].prevCluster)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MichaelSabbah/K-MEANS-parallel-project/K-MEANS_Parallel/K-MEANS/6"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    for (k = 0; k < N; k++)\n    {\n      res[(i * N) + j] += mat1[(i * N) + k] * mat2[(k * N) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-HW/4/code/q1/2"}
{"code": "for (j = 0; j < N; j++)\n{\n  colSum[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/20"}
{"code": "for (k = 0; k < nz; k++)\n{\n  z = zlo + (k * dz);\n  for (j = 0; j < ny; j++)\n  {\n    y = ylo + (j * dy);\n    for (i = 0; i < nx; i++)\n    {\n      x = xlo + (i * dx);\n      f[(i + (j * nx)) + ((k * nx) * ny)] = (uxx_exact(x, y, z) + uyy_exact(x, y, z)) + uzz_exact(x, y, z);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nx, ny, nz, dx, dy, dz, u, f, xlo, ylo, zlo) private(i, j, k, z, y, x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilmerhenao/Poisson-OpenMP/serial_hw2/3"}
{"code": "for (i = 0; i < (source->size / 2); i++)\n{\n  destination->tab[(destination->size / 2) + i] = source->tab[(source->size - i) - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/6"}
{"code": "for (i = rb; i < re; i++)\n  p_zd[i] = p_zd[i] + (beta * p_d[iter - j][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/25"}
{"code": "for (size_t index = fluidStartIndex; index < fluidEndIndex; index++)\n{\n  size_t rnuSz = 0;\n  size_t rsuSz = 0;\n  size_t rndSz = 0;\n  size_t rsdSz = 0;\n  size_t lnuSz = 0;\n  size_t lsuSz = 0;\n  size_t lndSz = 0;\n  size_t lsdSz = 0;\n  size_t nruSz = 0;\n  size_t nluSz = 0;\n  size_t nrdSz = 0;\n  size_t nldSz = 0;\n  size_t sruSz = 0;\n  size_t sluSz = 0;\n  size_t srdSz = 0;\n  size_t sldSz = 0;\n  size_t urnSz = 0;\n  size_t ulnSz = 0;\n  size_t ursSz = 0;\n  size_t ulsSz = 0;\n  size_t drnSz = 0;\n  size_t dlnSz = 0;\n  size_t drsSz = 0;\n  size_t dlsSz = 0;\n  size_t neiListStartIndex = index * maxNeiNum;\n  size_t neiListEndIndex = neiListStartIndex + neighbourListSize[index];\n  double x0 = positionX[index];\n  double y0 = positionY[index];\n  double z0 = positionZ[index];\n  for (size_t i = neiListStartIndex; i < neiListEndIndex; i++)\n  {\n    size_t neiIndex = neighbourList[i];\n    double x1 = positionX[neiIndex];\n    double y1 = positionY[neiIndex];\n    double z1 = positionZ[neiIndex];\n    setListInOneDir3D(neiIndex, x0, x1, y0, y1, z0, z1, rnu, rnuSz, rnd, rndSz, rsu, rsuSz, rsd, rsdSz, lnu, lnuSz, lnd, lndSz, lsu, lsuSz, lsd, lsdSz);\n    setListInOneDir3D(neiIndex, y0, y1, x0, x1, z0, z1, nru, nruSz, nrd, nrdSz, nlu, nluSz, nld, nldSz, sru, sruSz, srd, srdSz, slu, sluSz, sld, sldSz);\n    setListInOneDir3D(neiIndex, z0, z1, x0, x1, y0, y1, urn, urnSz, urs, ursSz, uln, ulnSz, uls, ulsSz, drn, drnSz, drs, drsSz, dln, dlnSz, dls, dlsSz);\n  }\n\n  setListInOneDir3D(index, maxNeiNumInOneDir, rnu, rnuSz, rsu, rsuSz, rnd, rndSz, rsd, rsdSz, neighbourListRight, neighbourListRightSize);\n  setListInOneDir3D(index, maxNeiNumInOneDir, lnu, lnuSz, lsu, lsuSz, lnd, lndSz, lsd, lsdSz, neighbourListLeft, neighbourListLeftSize);\n  setListInOneDir3D(index, maxNeiNumInOneDir, nru, nruSz, nlu, nluSz, nrd, nrdSz, nld, nldSz, neighbourListNorth, neighbourListNorthSize);\n  setListInOneDir3D(index, maxNeiNumInOneDir, sru, sruSz, slu, sluSz, srd, srdSz, sld, sldSz, neighbourListSouth, neighbourListSouthSize);\n  setListInOneDir3D(index, maxNeiNumInOneDir, urn, urnSz, uln, ulnSz, urs, ursSz, uls, ulsSz, neighbourListUp, neighbourListUpSize);\n  setListInOneDir3D(index, maxNeiNumInOneDir, drn, drnSz, dln, dlnSz, drs, drsSz, dls, dlsSz, neighbourListDown, neighbourListDownSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/14"}
{"code": "for (int i = 1; i < N; i++)\n{\n  double kv = 0.0;\n  if ((space_der == 0) && (i >= r))\n    break;\n\n  if ((space_der == 1) && (i == r))\n    continue;\n\n  if (A != 0.0)\n  {\n    if (i < r)\n      kv = Dg * kb(1 - A, i - 1, i, r, points, NULL);\n    else\n      kv = Dg * kb(1 - A, i, i + 1, r, points, NULL);\n\n  }\n\n  if (equation == 0)\n    kv *= iw;\n\n  if ((space_der == 1) && (i >= r))\n    kv *= -1;\n\n  if (equation == 0)\n  {\n    R[i + 1] += kv * (KK(i) / (dL[i] * dL[i]));\n    R[i] -= kv * ((KK(i) / (dL[i] * dL[i])) + (KK(i - 1) / (dL[i] * dL[i - 1])));\n    R[i - 1] += kv * (KK(i - 1) / (dL[i] * dL[i - 1]));\n  }\n\n  if (equation == 1)\n  {\n    R[i + 1] += (kv * (D / sigma)) * (1.0 / (dL[i] * dL[i]));\n    R[i] -= (kv * (D / sigma)) * ((1.0 / (dL[i] * dL[i - 1])) + (1.0 / (dL[i] * dL[i])));\n    R[i - 1] += (kv * (D / sigma)) * (1.0 / (dL[i] * dL[i - 1]));\n  }\n\n  if (equation == 2)\n  {\n    R[i + 1] += (kv * (lambda / Ct)) * (1.0 / (dL[i] * dL[i]));\n    R[i] -= (kv * (lambda / Ct)) * ((1.0 / (dL[i] * dL[i - 1])) + (1.0 / (dL[i] * dL[i])));\n    R[i - 1] += (kv * (lambda / Ct)) * (1.0 / (dL[i] * dL[i - 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/89"}
{"code": "for (i = 0; i < maxNodesTree[k]; i++)\n{\n  for (j = 0; j < colsTree; j++)\n  {\n    treeRF[k][i][j] = csv[k][i][j];\n    if (verbose)\n      printf(\"treeRF = %f \\n\", treeRF[k][i][j]);\n\n  }\n\n  if (verbose)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/13"}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 28))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/skein_fmt_plug/2"}
{"code": "for (k = 0; k < layer_size; k++)\n{\n  printf(\"%10.4f |\", layer[k]);\n  int ticks = (int) ((60 * layer[k]) / maximos[num_storms - 1]);\n  for (i = 0; i < (ticks - 1); i++)\n    printf(\"o\");\n\n  if ((((k > 0) && (k < (layer_size - 1))) && (layer[k] > layer[k - 1])) && (layer[k] > layer[k + 1]))\n    printf(\"x\");\n  else\n    printf(\"o\");\n\n  for (i = 0; i < num_storms; i++)\n    if (posiciones[i] == k)\n    printf(\" M%d\", i);\n\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bayons/OpenMP/Practica/energy_v2/2"}
{"code": "for (int i = 1; i < (nOfLayers - 1); i++)\n{\n  for (j = 0; j < copys[n][i].nOfNeurons; j++)\n  {\n    copys[n][i].neurons[j].net = 0;\n    copys[n][i].neurons[j].net += copys[n][i].neurons[j].w[0];\n    for (int k = 1; k < (copys[n][i - 1].nOfNeurons + 1); k++)\n    {\n      copys[n][i].neurons[j].net += copys[n][i].neurons[j].w[k] * copys[n][i - 1].neurons[k - 1].out;\n    }\n\n    copys[n][i].neurons[j].out = 1 / (1 + exp(-copys[n][i].neurons[j].net));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/9"}
{"code": "for (int j = present_ele; j < (n - 1); j += 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    swap(arr[j], arr[j + 1]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided,granularity) ,shared(arr,present_ele, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Katamreddys/OpenMpTaskFInal/5.assignment-openmp-advanced/5.assignment-openmp-advanced/bubblesort/bubblesort/0"}
{"code": "for (int i = 1; i < np; ++i)\n{\n  MPI_Send(&pixel_value_min, 1, MPI_DOUBLE, i, i + 200, MPI_COMM_WORLD);\n  MPI_Send(&pixel_value_max, 1, MPI_DOUBLE, i, i + 210, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jianxuecn/cccourse-examples/src/sobel_mpi_omp/1"}
{"code": "for (t = 0; t < n; t++)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current[index].S, BF_init_state.S, sizeof(BF_current[index].S));\n    memcpy(BF_current[index].P, BF_init_key[index], sizeof(BF_current[index].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_current[index].P[i] = L0;\n      BF_current[index].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[index].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[index].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[index].S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current[index].P[0] ^= BF_exp_key[index][0];\n      BF_current[index].P[1] ^= BF_exp_key[index][1];\n      BF_current[index].P[2] ^= BF_exp_key[index][2];\n      BF_current[index].P[3] ^= BF_exp_key[index][3];\n      BF_current[index].P[4] ^= BF_exp_key[index][4];\n      BF_current[index].P[5] ^= BF_exp_key[index][5];\n      BF_current[index].P[6] ^= BF_exp_key[index][6];\n      BF_current[index].P[7] ^= BF_exp_key[index][7];\n      BF_current[index].P[8] ^= BF_exp_key[index][8];\n      BF_current[index].P[9] ^= BF_exp_key[index][9];\n      BF_current[index].P[10] ^= BF_exp_key[index][10];\n      BF_current[index].P[11] ^= BF_exp_key[index][11];\n      BF_current[index].P[12] ^= BF_exp_key[index][12];\n      BF_current[index].P[13] ^= BF_exp_key[index][13];\n      BF_current[index].P[14] ^= BF_exp_key[index][14];\n      BF_current[index].P[15] ^= BF_exp_key[index][15];\n      BF_current[index].P[16] ^= BF_exp_key[index][16];\n      BF_current[index].P[17] ^= BF_exp_key[index][17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current[index].P[0] ^= u1;\n      BF_current[index].P[1] ^= u2;\n      BF_current[index].P[2] ^= u3;\n      BF_current[index].P[3] ^= u4;\n      BF_current[index].P[4] ^= u1;\n      BF_current[index].P[5] ^= u2;\n      BF_current[index].P[6] ^= u3;\n      BF_current[index].P[7] ^= u4;\n      BF_current[index].P[8] ^= u1;\n      BF_current[index].P[9] ^= u2;\n      BF_current[index].P[10] ^= u3;\n      BF_current[index].P[11] ^= u4;\n      BF_current[index].P[12] ^= u1;\n      BF_current[index].P[13] ^= u2;\n      BF_current[index].P[14] ^= u3;\n      BF_current[index].P[15] ^= u4;\n      BF_current[index].P[16] ^= u1;\n      BF_current[index].P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[index].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[index].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[index].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[index].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/28"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  for (k = 10; k < 100; k++)\n  for (l = 10; l < 100; l++)\n  arr[i][j][k][l] = (i + (j * 2)) + arr[i][j][k - 10][l];\n\n\n\n\n", "pragma": "\t\t#pragma omp for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhinav-vaishya/Parallel-Computing---MPI-OpenMP-CUDA/codes/Q2/0"}
{"code": "for (unsigned int k = 0; k < numNodes; ++k)\n{\n  for (unsigned int y = 0; y < numNodes; ++y)\n  {\n    yXwidth = y * numNodes;\n    for (unsigned int x = 0; x < numNodes; ++x)\n    {\n      distanceYtoX = pathDistanceMatrix[yXwidth + x];\n      distanceYtoK = pathDistanceMatrix[yXwidth + k];\n      distanceKtoX = pathDistanceMatrix[(k * width) + x];\n      indirectDistance = distanceYtoK + distanceKtoX;\n      if (indirectDistance < distanceYtoX)\n      {\n        pathDistanceMatrix[yXwidth + x] = indirectDistance;\n        pathMatrix[yXwidth + x] = k;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/floydwarshall-omp/main/0"}
{"code": "for (i = 0; i < 1024; i = i + 1)\n{\n  r = 0.0;\n  for (j = 0; j <= i; j = j + 1)\n  {\n    r += M[i][j] * b[j];\n  }\n\n  c[i] = r;\n}\n\n", "pragma": "omp parallel for schedule (static) private (i,j,r)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/triangular_matrix/0"}
{"code": "for (int real = 0; real <= num; real++)\n{\n  if (zero_case)\n  {\n    count += inset(x_min + (real * real_step), 0, maxiter);\n  }\n\n  for (int img = 0; img <= i_num; img++)\n  {\n    count += n * inset(x_min + (real * real_step), i_min + (img * img_step), maxiter);\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:count) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajmorton/prog_parallelisation/mandelbrot_omp/code/final_w_symm/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (percentDiff(y[i], y_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/GESUMMV/gesummv/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  int aux = rand() % 4;\n  if (aux == 0)\n    b[i] = 'A';\n  else\n    if (aux == 2)\n    b[i] = 'C';\n  else\n    if (aux == 3)\n    b[i] = 'G';\n  else\n    b[i] = 'T';\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PARCO-LDRD/benchmarks/gpu_cpu/smith-waterman/smithw-omp-offload-optimized-inlined/3"}
{"code": "for (int i = 1; i < p; i++)\n{\n  if (!conv[i])\n  {\n    converged = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_openmp/3"}
{"code": "for (i = 0; i < n; i++)\n  sum += a[i];\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/computingSum/1"}
{"code": "for (i = 0; i < (1 << 20); i++)\n{\n  x = randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/41"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (A[i] > avg)\n  {\n    counter++;\n  }\n\n}\n\n", "pragma": "omp for reduction(+:counter) nowait", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMParrayAvg/1"}
{"code": "for (int w = 0; w < 100000; w++)\n{\n  float min_dist = 1e30;\n  int temp_class = -1;\n  for (int i = 0; i < 100; i++)\n  {\n    float dist = 0;\n    for (int j = 0; j < 1000; j++)\n      dist += (Vectors[w][j] - Centers[i][j]) * (Vectors[w][j] - Centers[i][j]);\n\n    if (dist < min_dist)\n    {\n      temp_class = i;\n      min_dist = dist;\n    }\n\n  }\n\n  Class_of_Vec[w] = temp_class;\n  tot_min_distances += sqrt(min_dist);\n}\n\n", "pragma": "omp parallel for reduction(+:tot_min_distances) schedule(static, 1000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/2. K-means with OpenMP/kmeans12/0"}
{"code": "for (i = 0; i < SIZE; i++)\n  for (j = 0; j < SIZE; j++)\n  random[i][j] = rand() % range;\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/moltiplicazione/non_parallelized_AB/0"}
{"code": "for (int i = 0; i < 30; i++)\n{\n  a[i] = rand() % 30;\n  if ((a[i] % 9) == 0)\n  {\n    basic_counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxinspace/OpenMP/omp11/0"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.m; j++)\n  {\n    dataSet.C[(i * dataSet.m) + j] = dataSet.A[(i * dataSet.m) + j] + dataSet.B[(i * dataSet.m) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alty-ir/openmp/openmp/matadd/5"}
{"code": "for (int i = 0; i < (W + 1); i++)\n{\n  data[i] = 0;\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bruno-26/Parallel-knapsack-C-OpenMP-MPI/knapSack/1"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  int i;\n  double time1;\n  double time2;\n  double sum = 0;\n  double x;\n  time1 = omp_get_wtime();\n  for (i = 0; i < num_steps; i++)\n  {\n    x = (i + 0.5) * step;\n    sum += 4.0 / (1.0 + (x * x));\n  }\n\n  time2 = omp_get_wtime();\n  pi = sum * step;\n  avg_time += time2 - time1;\n}\n\n", "pragma": "omp parallel for reduction (+:avg_time) schedule(auto) num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeSchreiber/openMP/areaUnderCurve3/0"}
{"code": "for (i = 0; i < dataset->dim; i++)\n{\n  for (j = 0; j < dataset->atts; j++)\n  {\n    if (i == 0)\n    {\n      max[j] = 0;\n    }\n\n    if (max[j] < dataset->data[i][j])\n      max[j] = dataset->data[i][j];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/14"}
{"code": "for (j = 1; j < m; j++)\n{\n  printf(\"%lf\\n\", b[i][j]);\n}\n\n", "pragma": "omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB037-truedepseconddimension-orig-yes/2"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      if (betay[pp] > 0.0)\n      {\n        Dyu[pp] = ((((((-3.0) * u[pp - nx]) - (10.0 * u[pp])) + (18.0 * u[pp + nx])) - (6.0 * u[pp + (2 * nx)])) + u[pp + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp] = (((((-u[pp - (3 * nx)]) + (6.0 * u[pp - (2 * nx)])) - (18.0 * u[pp - nx])) + (10.0 * u[pp])) + (3.0 * u[pp + nx])) * idy_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/29"}
{"code": "for (int i = 0; i < rank; i++)\n  printf(\"%.2f \", b_hat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/8"}
{"code": "for (i = 0; i < bands; i++)\n{\n  if ((zTz[i] = calloc(bands, sizeof(double))) == 0)\n  {\n    puts(\"Error in zTz[i] Memory Allocation.\");\n    exit(-1);\n  }\n\n  if ((zTz_inv[i] = malloc(bands * (sizeof(double)))) == 0)\n  {\n    puts(\"Error in zTz_inv[i] Memory Allocation.\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/MNF/21"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  T1D[i] = ((double) rand()) / 3.33;\n  somme += T1D[i];\n  printf(\"Thread number %d , somme = [%d]  \\n\", omp_get_thread_num(), somme);\n}\n\n", "pragma": "omp for reduction(+:somme)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.2/0"}
{"code": "for (i = 0; i < 2400; i++)\n{\n  for (j = 1; j < 2400; j++)\n  {\n    ex[(i * (2400 + 1)) + j] = ex[(i * (2400 + 1)) + j] - (0.5 * (hz[(i * 2400) + j] - hz[(i * 2400) + (j - 1)]));\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/11"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    mass_flux_x[FTNREF2D(j, 1 - k, x_max + 5, x_min - 2, y_min - 2)] = mass_flux_x[FTNREF2D(j, 1 + k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/48"}
{"code": "for (row = 0; row < rows; row++)\n{\n  for (col = 0; col < cols; col++)\n    edited_image[(row * rows) + col] = (unsigned char) new_gray_level[image[(row * rows) + col]];\n\n}\n\n", "pragma": "omp parallel for shared(row, edited_image) private(col)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/9"}
{"code": "for (int j = 0; j < ndr; j++)\n  for (int i = 0; i < P; i++)\n{\n  double temp = B(i, j);\n  NewB(i, j) = B(i, j) + epsilon;\n  G(i, j) = (direct_pt_f(NewB, X, A, a_seq, R, bw, W, ncore) - F0) / epsilon;\n  NewB(i, j) = temp;\n}\n\n\n", "pragma": "#pragma omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/direct_pt_solver/5"}
{"code": "for (i = 0; i <= (2048 - 1); i++)\n  for (j = 0; j <= (2048 - 1); j++)\n{\n  if ((((i == 0) || (i == (2048 - 1))) || (j == 0)) || (j == (2048 - 1)))\n    A[i][j] = 0.;\n  else\n    A[i][j] = (1. + i) + j;\n\n}\n\n\n", "pragma": "omp parallel for private(j) shared(A)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AVasK/SuperPCs_OpenMP/redb_2d_parallel_final/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i].arrival_time = arr[i];\n  p[i].burst_time = bur[i];\n  p[i].pid = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/fcfs_parallel/0"}
{"code": "for (unsigned i = 0, e = Node->getNumInits(); i != e; ++i)\n{\n  if (i)\n    OS << \", \";\n\n  if (Node->getInit(i))\n    PrintExpr(Node->getInit(i));\n  else\n    OS << \"0\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/AST/StmtPrinter/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = (i * j) * s;\n    b[i][j] = (i + j) + s;\n    s = -s;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/examples-4/simd-5/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/134"}
{"code": "for (int i = 0; i < loopValue; i++)\n{\n  double temp1;\n  cout << \"Please choose a number: \";\n  cin >> temp1;\n  b[i] = temp1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dab2013/OpenMP/OpenMP/IntroductionToOMP/2"}
{"code": "for (begin = begin0; begin < end; ++begin)\n  ++begin;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/47"}
{"code": "for (i = 0; i < cache->numPropertyRegions; i++)\n{\n  cache->regions_avgDegrees[i] = (uint64_t *) my_malloc((sizeof(uint64_t)) * (cache->num_buckets + 1));\n  for (j = 0; j < (cache->num_buckets + 1); j++)\n  {\n    cache->regions_avgDegrees[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/0"}
{"code": "for (int i = 0; i < len; i++)\n  input[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/mul_omp/2"}
{"code": "for (int i = 0; i < 11000; i++)\n  input[i] = malloc((sizeof(char)) * 1001);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par2/3"}
{"code": "for (int i = 0; i < ((local_workload + 1) * room_size); i++)\n{\n  reference_data[i] = data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArthurLCW/Heat-Simulation/codes/csc4005-assignment-4-bonus/csc4005-imgui/src/main/6"}
{"code": "for (int h = 0; h < numHalfEdges; ++h)\n{\n  float n = valence(h);\n  if (n > 0)\n  {\n    interiorVertexPoint(mesh, h, n);\n  }\n  else\n    if (twin(h) < 0)\n  {\n    boundaryVertexPoint(mesh, h);\n  }\n\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BugelNiels/parallel-cpu-catmull-clark-subdivision/src/meshSubdivision/3"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  (cout << ans[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/reduction_temp/2"}
{"code": "for (i = 0; i < numthreads; i++)\n{\n  Y[i] = (xyz *) malloc(numf2s * (sizeof(xyz)));\n  if (Y[i] == 0)\n  {\n    fprintf(stderr, \"malloc error in init_net\\n\");\n  }\n\n  Y[i][0].y = 0.0;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/3"}
{"code": "for (int i = 0; i < (n * n); i++)\n  c_plus_ident[i] = c[i] + ident[i];\n\n", "pragma": "#pragma omp  for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/opencl-char-pol/main/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  cnt = 0;\n  val = a[i];\n  for (j = 0; j < size; j++)\n  {\n    if (val > a[j])\n      cnt++;\n\n  }\n\n  b[cnt] = val;\n}\n\n", "pragma": "omp parallel for num_threads (thread_count) default(none) private(j,cnt,val) shared(size,a,b)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/isutanto/OpenMPsort/ranksort/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  result += x[i] * y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gtrabes/OpenMPExample/openmp_example/2"}
{"code": "for (j = jbeg; j <= jfin; j += 1)\n{\n  jglob = j;\n  k = ki1;\n  phi1[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n  k = ki2;\n  phi2[i][j] = 0.40e+00 * (u[i][j][k][4] - ((0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0]));\n}\n\n", "pragma": "omp parallel for private (k,jglob,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/68"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\"a[%d] = %d    \", i, a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter3/fl/2"}
{"code": "for (i_iter = 0; i_iter < MAX_MATRIX_LENGTH; i_iter++)\n{\n  for (j_iter = 0; j_iter < MAX_MATRIX_LENGTH; j_iter++)\n  {\n    matrix_0[i_iter][j_iter] = 1.0;\n    matrix_1[i_iter][j_iter] = 1.0;\n    matrix_final[i_iter][j_iter] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiippu/MSMPI-and-OpenMP/M3.T1P/Source/0"}
{"code": "for (int i = 0; i < MAX_N; i++)\n{\n  a[i] = (a_h[i] = i);\n  b[i] = i * 2;\n  c[i] = i - 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-distribute-parallel-for-back2back/test/0"}
{"code": "for (int ii = 0; ii < nbx; ii++)\n  for (int jj = 0; jj < nby; jj++)\n  for (int i = 1 + (ii * bx); i <= ((((ii + 1) * bx) < (sizex - 2)) ? ((ii + 1) * bx) : (sizex - 2)); i++)\n  for (int j = 1 + (jj * by); j <= ((((jj + 1) * by) < (sizey - 2)) ? ((jj + 1) * by) : (sizey - 2)); j++)\n{\n  unew = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n  diff = unew - u[(i * sizey) + j];\n  sum += diff * diff;\n  u[(i * sizey) + j] = unew;\n}\n\n\n\n\n", "pragma": "omp parallel for reduction(+:sum) private(diff)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaomlneto/cpds-heat/omp/solver-omp/3"}
{"code": "for (int ii = 0; ii < maxTotalAtoms; ii++)\n{\n  for (int m = 0; m < 3; m++)\n    f[(ii * 3) + m] = 0.;\n\n  U[ii] = 0.;\n  dfEmbed[ii] = 0.;\n  rhobar[ii] = 0.;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/comd-mp4/src-omp/eam/0"}
{"code": "for (j = 1; j < num_angles; j++)\n{\n  *(thread_theta + j) = (*(thread_theta + (j - 1))) + delta_theta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mcrat/0"}
{"code": "for (int ig = 1; ig < nspecies; ig++)\n  SameMass &= mySpecies(massind, ig) == m0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/7"}
{"code": "for (unsigned int i = 0; i < size; i++)\n{\n  m_particles.push_back(Particle(lmap));\n  m_particles.back().pose = initialPose;\n  m_particles.back().previousPose = initialPose;\n  m_particles.back().setWeight(0);\n  m_particles.back().previousIndex = 0;\n  m_particles.back().node = node;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/gmapping/gridfastslam/gridslamprocessor/4"}
{"code": "for (i = 0; i < m; i++)\n{\n  ((cin >> u) >> v) >> w;\n  adj[u][v] = w;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishal-2504/Parallelization-of-Floyd-Warshall-Algorithm/floyd_naive_dynamic_scheduling/3"}
{"code": "for (int j = 1; j < (2000 - 1); j++)\n{\n  int ind = (i * 2000) + j;\n  int ip = ((i + 1) * 2000) + j;\n  int im = ((i - 1) * 2000) + j;\n  int jp = ((i * 2000) + j) + 1;\n  int jm = ((i * 2000) + j) - 1;\n  unew[ind] = factor * (((((u[ip] - (2.0 * u[ind])) + u[im]) + u[jp]) - (2.0 * u[ind])) + u[jm]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/gpu-openmp/jacobi/solution/jacobi/0"}
{"code": "for (int i = 0; i < M; i++)\n  Num[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/1"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[m][k][1][i] = frct[m][k][1][i] - (dssp * ((((+5.0) * rsd[m][k][1][i]) - (4.0 * rsd[m][k][2][i])) + rsd[m][k][3][i]));\n      frct[m][k][2][i] = frct[m][k][2][i] - (dssp * (((((-4.0) * rsd[m][k][1][i]) + (6.0 * rsd[m][k][2][i])) - (4.0 * rsd[m][k][3][i])) + rsd[m][k][4][i]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/LU-HP/erhs/13"}
{"code": "for (int i = 0; i < system_size; i++)\n  if (!isEqual(validation_matrix[i], variable_value_prev_t[i]))\n{\n  system_is_valid = false;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.1/system_solver/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  r[i] = s->Mat_3d[1][i] * x[i];\n  if (sN > 2)\n  {\n    if ((i - 1) >= 0)\n      r[i] += s->Mat_3d[5][i] * x[i - 1];\n\n    if ((i + 1) < N)\n      r[i] += s->Mat_3d[6][i] * x[i + 1];\n\n  }\n\n  if (_M > 2)\n  {\n    if ((i - (sN + 2)) >= 0)\n      r[i] += s->Mat_3d[3][i] * x[i - (sN + 2)];\n\n    if ((i + (sN + 2)) < N)\n      r[i] += s->Mat_3d[4][i] * x[i + (sN + 2)];\n\n  }\n\n  if (K > 2)\n  {\n    if ((i - ((sN + 2) * (_M + 2))) >= 0)\n      r[i] += s->Mat_3d[0][i] * x[i - ((sN + 2) * (_M + 2))];\n\n    if ((i + ((sN + 2) * (_M + 2))) < N)\n      r[i] += s->Mat_3d[2][i] * x[i + ((sN + 2) * (_M + 2))];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/136"}
{"code": "for (i = 0; i < nb_thread; i++)\n{\n  args[i].candidates = numbers[i];\n  args[i].truth_value = prime[i];\n  args[i].tab_size = tabsizes[i];\n  thread_is_prime(&args[i]);\n}\n\n", "pragma": "            #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AdrienTurchini/OpenMP/main/3"}
{"code": "for (i = 0; i < 20; i++)\n{\n  for (j = 0; j < 20; j++)\n  {\n    hz[(i * 20) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / 20;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/49"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  expect_total += a[x] + b[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_add/3"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  Beta_x_la = 0;\n  for (int j = 0; j < Ndim; j++)\n  {\n    Beta_x_la += Beta.nM[i][j] * la.nV[j];\n  }\n\n  Beta_norm_la += la.nV[i] * Beta_x_la;\n  la_x_lambda += la.nV[i] * lambda.nV[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/11"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    if (cellMatrix[i][j] == 0)\n      count++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelhuntermoore/OpenMP-ConwaysGameOfLife/ParallelGameofLifeVer1/1"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA512)\n{\n  pbkdf2_sha512((const unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, cur_salt->length, cur_salt->rounds, (unsigned char *) crypt_out[index], PBKDF2_SHA512_BINARY_SIZE, 0);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pbkdf2-hmac-sha512_fmt_plug/1"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  s += A[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nghialuffy/OpenMP-Exercises/Bai3/Bai3_Function_OpenMP/1"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleType[i] == fluid) && (particleNearWall[i] == true))\n  {\n    double meu_i = MEU[i];\n    double accX = 0.0;\n    double accY = 0.0;\n    double accZ = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double Rref_i[9];\n    double normaliw[3];\n    double normalMod2;\n    normaliw[0] = 0.5 * (posXi - posMirrorXi);\n    normaliw[1] = 0.5 * (posYi - posMirrorYi);\n    normaliw[2] = 0.5 * (posZi - posMirrorZi);\n    normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n    if (normalMod2 > 1.0e-8)\n    {\n      double normalMod = sqrt(normalMod2);\n      normaliw[0] = normaliw[0] / normalMod;\n      normaliw[1] = normaliw[1] / normalMod;\n      normaliw[2] = normaliw[2] / normalMod;\n    }\n    else\n    {\n      normaliw[0] = 0;\n      normaliw[1] = 0;\n      normaliw[2] = 0;\n    }\n\n    Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n    Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n    Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n    Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n    Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n    Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n    Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n    Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n    Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n    double velMirrorXi = ((Rref_i[0] * velXi) + (Rref_i[1] * velYi)) + (Rref_i[2] * velZi);\n    double velMirrorYi = ((Rref_i[3] * velXi) + (Rref_i[4] * velYi)) + (Rref_i[5] * velZi);\n    double velMirrorZi = ((Rref_i[6] * velXi) + (Rref_i[7] * velYi)) + (Rref_i[8] * velZi);\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if (((dstij2 < reL2) && (dstimj2 < reL2)) && (dstij2 < dstimj2))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstimj2);\n                double wL = weight(dst, reL, weightType);\n                double neu_ij;\n                if ((meu_i + MEU[j]) > 1.0e-8)\n                  neu_ij = ((2.0 * meu_i) * MEU[j]) / (meu_i + MEU[j]);\n                else\n                  neu_ij = 0.0;\n\n                if (PTYPE[i] == 1)\n                  neu_ij = neu_ij / DNS_FL1;\n                else\n                  neu_ij = neu_ij / DNS_FL2;\n\n                accX += ((vel[j * 3] - velMirrorXi) * wL) * neu_ij;\n                accY += ((vel[(j * 3) + 1] - velMirrorYi) * wL) * neu_ij;\n                accZ += ((vel[(j * 3) + 2] - velMirrorZi) * wL) * neu_ij;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    double v0imi;\n    double v1imi;\n    double v2imi;\n    double dstimi2;\n    sqrDistBetweenParticles(i, posMirrorXi, posMirrorYi, posMirrorZi, v0imi, v1imi, v2imi, dstimi2);\n    if (dstimi2 < reL2)\n    {\n      double dst = sqrt(dstimi2);\n      double wL = weight(dst, reL, weightType);\n      double neu_ij;\n      if (meu_i > 1.0e-8)\n        neu_ij = ((2.0 * meu_i) * meu_i) / (meu_i + meu_i);\n      else\n        neu_ij = 0.0;\n\n      if (PTYPE[i] == 1)\n        neu_ij = neu_ij / DNS_FL1;\n      else\n        neu_ij = neu_ij / DNS_FL2;\n\n      accX += ((velXi - velMirrorXi) * wL) * neu_ij;\n      accY += ((velYi - velMirrorYi) * wL) * neu_ij;\n      accZ += ((velZi - velMirrorZi) * wL) * neu_ij;\n    }\n\n    acc[i * 3] += (((Rref_i[0] * accX) + (Rref_i[1] * accY)) + (Rref_i[2] * accZ)) * coeffViscMultiphase;\n    acc[(i * 3) + 1] += (((Rref_i[3] * accX) + (Rref_i[4] * accY)) + (Rref_i[5] * accZ)) * coeffViscMultiphase;\n    acc[(i * 3) + 2] += (((Rref_i[6] * accX) + (Rref_i[7] * accY)) + (Rref_i[8] * accZ)) * coeffViscMultiphase;\n    forceWall[i * 3] += (((-(((Rref_i[0] * accX) + (Rref_i[1] * accY)) + (Rref_i[2] * accZ))) * coeffViscMultiphase) * VolumeForce) * RHO[i];\n    forceWall[(i * 3) + 1] += (((-(((Rref_i[3] * accX) + (Rref_i[4] * accY)) + (Rref_i[5] * accZ))) * coeffViscMultiphase) * VolumeForce) * RHO[i];\n    forceWall[(i * 3) + 2] += (((-(((Rref_i[6] * accX) + (Rref_i[7] * accY)) + (Rref_i[8] * accZ))) * coeffViscMultiphase) * VolumeForce) * RHO[i];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/73"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (graph->vertices->out_degree[v])\n    stats->vector_input[v] = 1.0f / graph->vertices->out_degree[v];\n  else\n    stats->vector_input[v] = 0.001f;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", a[i]);\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ponsheng/OpenMPRewriter/test/offload_array/3"}
{"code": "for (int i = 0; i < n; i++)\n  scanf(\"%d\", &ar[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gunjapandey/Introduction-to-OpenMP/l2_prog4/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  c[i] = a[i] * b[i];\n}\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/samples/vmul/vmul/0"}
{"code": "for (int i = 0; i < 5000; i++)\n{\n  X[i] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n}\n\n", "pragma": "omp for schedule(runtime) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice8/0"}
{"code": "for (i = start; i <= end; i++)\n{\n  int j;\n  int s = S[i];\n  int e = C[i];\n  for (j = s; j <= e; j++)\n    B[j] = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/counting/8"}
{"code": "for (long i = 0; i < m; ++i)\n{\n  for (long j = 0; j < n; ++j)\n  {\n    result += i + j;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/j-haj/collapse-test/main/1"}
{"code": "for (int i = 0; i < destination.rows; i++)\n{\n  for (int j = 0; j < destination.cols; j++)\n  {\n    destination(i, j) = scaling(source, scaleFactor, i, j);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/scalingOMP/1"}
{"code": "for (pivot = 0; pivot < (3000 - 1); pivot++)\n{\n  max = matrix[pivot][pivot];\n  maxRow = pivot;\n  for (i = pivot + 1; i < 3000; i++)\n  {\n    temp = matrix[i][pivot];\n    if (temp > max)\n    {\n      max = temp;\n      maxRow = i;\n    }\n\n  }\n\n  swapRows(pivot, maxRow);\n  for (row = pivot + 1; row < 3000; row++)\n  {\n    ratio = matrix[row][pivot] / matrix[pivot][pivot];\n    for (i = pivot; i < (3000 + 1); i++)\n    {\n      matrix[row][i] -= ratio * matrix[pivot][i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/sequential/0"}
{"code": "formula.append(number(b) + \"x^6 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/12"}
{"code": "for (int i = 0; i < (num_procs - 1); ++i)\n{\n  int nextNumberOfItem = countsA[((rank - (i + 1)) + num_procs) % num_procs];\n  if ((rank % 2) == 0)\n  {\n    MPI_Send(sub_a->tab, numberOfItem, (MPI_Datatype) 0x4c000405, suivant, 0, (MPI_Comm) 0x44000000);\n    if (numberOfItem != nextNumberOfItem)\n    {\n      free(sub_a->tab);\n      free(sub_a);\n      sub_a = allocateMatrix(nextNumberOfItem / N, N);\n    }\n\n    MPI_Recv(sub_a->tab, nextNumberOfItem, (MPI_Datatype) 0x4c000405, precedent, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n  }\n  else\n  {\n    int *value_to_receive = malloc(nextNumberOfItem * (sizeof(int)));\n    MPI_Recv(value_to_receive, nextNumberOfItem, (MPI_Datatype) 0x4c000405, precedent, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    MPI_Send(sub_a->tab, numberOfItem, (MPI_Datatype) 0x4c000405, suivant, 0, (MPI_Comm) 0x44000000);\n    if (numberOfItem != nextNumberOfItem)\n    {\n      free(sub_a);\n      sub_a = allocateMatrix(nextNumberOfItem / N, N);\n    }\n\n    free(sub_a->tab);\n    sub_a->tab = value_to_receive;\n  }\n\n  currentIndice = displsB[((rank - (i + 1)) + num_procs) % num_procs];\n  numberOfItem = nextNumberOfItem;\n  multMatrix(sub_a, sub_b, c, currentIndice);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aurelienspnll/matrix-mult-ring-rotation/matrix-mult-ring-rotation/4"}
{"code": "for (int j = 0; j <= _M; j++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (_M / mpi_size)\n    bi = j / (_M / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = (bj + bi) % mpi_size;\n  st = ((mpi_size + st) - mpi_rank) % mpi_size;\n  s->rb = st * (sN / mpi_size);\n  s->re = s->rb + (sN / mpi_size);\n  if (st == 0)\n    s->rb = 1;\n\n  if (st == (mpi_size - 1))\n    s->re = sN;\n\n  s->Bt = s->sBt;\n  for (int i = s->rb; i < s->re; i++)\n  {\n    s->Bt[idx(i, j, k)] = s->Mcoefs_3d[0][1][idx(i, j, k)] * x[idx(i, j, k)];\n    s->Bt[idx(i, j, k)] += s->Mcoefs_3d[0][0][idx(i, j, k)] * x[idx(i - 1, j, k)];\n    s->Bt[idx(i, j, k)] += s->Mcoefs_3d[0][2][idx(i, j, k)] * x[idx(i + 1, j, k)];\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/155"}
{"code": "for (i = 0; i < N; i++)\n{\n  fprintf(fout, \"%d %d %d %d\\n\", *(cluster_pts + (i * 4)), *((cluster_pts + (i * 4)) + 1), *((cluster_pts + (i * 4)) + 2), *((cluster_pts + (i * 4)) + 3));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/12"}
{"code": "for (int j = 0; j < ((int) pJ->GetY()); j++)\n{\n  is_node = 0;\n  for (int i = 0; i < ((int) pJ->GetX()); i++)\n  {\n    if (((((pJ->GetValue(i, j).isCond2D(CT_WALL_LAW_2D) || pJ->GetValue(i, j).isCond2D(CT_WALL_NO_SLIP_2D)) && (i >= ((int) (((x0 / FlowNode2D) < FP, dx))))) && (i <= ((int) ((((x0 + dx) / FlowNode2D) < FP, dx))))) && (j >= ((int) (((y0 / FlowNode2D) < FP, dy))))) && (j <= ((int) ((((y0 + dy) / FlowNode2D) < FP, dy)))))\n    {\n      is_node = 1;\n    }\n\n  }\n\n  if (is_node)\n  {\n    if (FlowNode2D < FP, FT == FT_FLAT)\n    {\n      Fmid += FlowNode2D < FP, dy;\n    }\n    else\n    {\n      Fmid += (((2 * M_PI) * (j + 0.5)) * FlowNode2D) < FP, (dy * FlowNode2D) < FP, dy;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:Fmid)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libOutCFD/out_cfd_param/2"}
{"code": "for (size_t i = 0; i < cameras.size(); ++i)\n  rmats.push_back(cameras[i].R.clone());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Abylay019/stitching_omp/stitching_omp/stitching_omp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      b[i] = rand() % (n + 1);\n      A[i][j] = 1;\n    }\n    else\n    {\n      A[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/10"}
{"code": "for (int i = 0; i < 1000000000; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/medasuryatej/advanced_parallel_computation/sum_of_n_numbers/compute_sum/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/in-droid/image-compression-k-means/src/k-means-omp/3"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    result(i, j) = this->operator()(j, i);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/8"}
{"code": "for (int fiberNo = 0; fiberNo < nFibersToCompute; fiberNo++)\n{\n  for (int instanceNo = 0; instanceNo < nInstancesPerFiber; instanceNo++)\n  {\n    int instanceToComputeNo = (fiberNo * nInstancesPerFiber) + instanceNo;\n    for (int stateNo = 1; stateNo < nStates; stateNo++)\n    {\n      states[(stateNo * nInstancesToCompute) + instanceToComputeNo] = statesOneInstance[stateNo];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/breyerml/OpenMP_Offloading_to_SYCL_mwe/hodgkin_huxley_1952_gpu_fast_monodomain.0/8"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  at1 = ci2 * crealf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  at1 = at1 * cimagf(ffc[kk]);\n  zt1 = (-cimagf(cu[2 + (4 * kj)])) + (crealf(cu[2 + (4 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(cu[4 * kj])) + (crealf(cu[4 * kj]) * _Complex_I);\n  bxyz[4 * kj] = at3 * zt1;\n  bxyz[1 + (4 * kj)] = zero;\n  bxyz[2 + (4 * kj)] = (-at3) * zt3;\n  bxyz[4 * k1] = zero;\n  bxyz[1 + (4 * k1)] = zero;\n  bxyz[2 + (4 * k1)] = zero;\n  bxyz[4 * (kj + l1)] = zero;\n  bxyz[1 + (4 * (kj + l1))] = zero;\n  bxyz[2 + (4 * (kj + l1))] = zero;\n  bxyz[4 * (k1 + l1)] = zero;\n  bxyz[1 + (4 * (k1 + l1))] = zero;\n  bxyz[2 + (4 * (k1 + l1))] = zero;\n  at1 = at1 * (((cu[4 * kj] * conjf(cu[4 * kj])) + (cu[1 + (4 * kj)] * conjf(cu[1 + (4 * kj)]))) + (cu[2 + (4 * kj)] * conjf(cu[2 + (4 * kj)])));\n  wp += (double) at1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/48"}
{"code": "for (uint32_t i = 0; i != StitchRelation.size(); i++)\n{\n  TSE += StitchRelation[i].size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/1"}
{"code": "for (int j = row_start[taskid]; j < row_end[taskid]; j++)\n  qsort((buffer_row + rowPrefixSum[j]) - rowPrefixSum[row_start[taskid]], row_count[j], 12, cmpfunc1);\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/18"}
{"code": "for (double E = eval_min; E < eval_max; E += 1e-3)\n{\n  gsl_matrix_complex_set_all(G, GSL_COMPLEX_ZERO);\n  for (int n = 0; n < ((N * 2) * 6); n++)\n    for (i = 0; i < NL; i++)\n    for (j = 0; j < NL; j++)\n    for (int k0 = 0; k0 < (2 * 6); k0++)\n  {\n    for (int k1 = 0; k1 < (2 * 6); k1++)\n    {\n      gsl_complex in = gsl_matrix_complex_get(evec, n, ((list[i] * 2) * 6) + k0);\n      gsl_complex nj = gsl_matrix_complex_get(evec, n, ((list[j] * 2) * 6) + k1);\n      double En = gsl_vector_get(eval, n);\n      gsl_complex eta = gsl_complex_rect(0, 5e-3);\n      gsl_complex num = gsl_complex_mul(in, gsl_complex_conjugate(nj));\n      gsl_complex den = gsl_complex_add_real(eta, E - En);\n      gsl_complex Gij = gsl_complex_div(num, den);\n      gsl_complex tmp = gsl_matrix_complex_get(G, ((i * 2) * 6) + k0, ((j * 2) * 6) + k1);\n      gsl_complex sum = gsl_complex_add(tmp, Gij);\n      gsl_matrix_complex_set(G, ((i * 2) * 6) + k0, ((j * 2) * 6) + k1, sum);\n    }\n\n  }\n\n\n\n\n  dos = 0;\n  for (int i = 0; i < ((NL * 2) * 6); i++)\n    dos += GSL_IMAG(gsl_matrix_complex_get(G, i, i));\n\n  printf(\"%.3g %g\\n\", E, (-dos) / 3.1415926538);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/graguirre/tight-binding/src/tight-binding/5"}
{"code": "for (int currentRow = 0; currentRow < totalRows; ++currentRow)\n{\n  for (int currentColumn = 0; currentColumn < totalColumns; ++currentColumn)\n  {\n    printf(\"%.1f\\t\", grid[currentRow][currentColumn]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/12"}
{"code": "for (j = eme - 2; j > 1; j--)\n{\n  z = ((((((-(h * h)) * g(x[1], y[j])) + fa(a, y[j])) + (lambda * omega[1][j + 1])) + (lambda * omega[1][j - 1])) + omega[2][j]) * mi;\n  if (fabs(omega[1][j] - z) > (*Norma))\n    *Norma = fabs(omega[1][j] - z);\n\n  omega[1][j] = z;\n  for (i = 2; i <= (ene - 2); i++)\n  {\n    z = ((((((-(h * h)) * g(x[i], y[j])) + omega[i - 1][j]) + (lambda * omega[i][j + 1])) + omega[i + 1][j]) + (lambda * omega[i][j - 1])) * mi;\n    if (fabs(omega[i][j] - z) > (*Norma))\n      *Norma = fabs(omega[i][j] - z);\n\n    omega[i][j] = z;\n  }\n\n  z = ((((((-(h * h)) * g(x[760 - 1], y[j])) + fb(b, y[j])) + omega[760 - 2][j]) + (lambda * omega[760 - 1][j + 1])) + (lambda * omega[760 - 1][j - 1])) * mi;\n  if (fabs(omega[760 - 1][j] - z) > (*Norma))\n    *Norma = fabs(omega[760 - 1][j] - z);\n\n  omega[760 - 1][j] = z;\n}\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/0"}
{"code": "for (int i = 1; i < (domain.ni - 1); i++)\n  ef[i] = (-(phi[i + 1] - phi[i - 1])) / (2 * domain.dx);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sheath-omp/main/13"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k < (nz - 1); k++)\n  {\n    flux[i][j][k][0] = rsd[i][j][k][1];\n    u21 = rsd[i][j][k][1] / rsd[i][j][k][0];\n    q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n    flux[i][j][k][1] = (rsd[i][j][k][1] * u21) + (C2 * (rsd[i][j][k][4] - q));\n    flux[i][j][k][2] = rsd[i][j][k][2] * u21;\n    flux[i][j][k][3] = rsd[i][j][k][3] * u21;\n    flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u21;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(L2 ,nx ,j ,k ,u21 ,q ,nz ,jst ,jend ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/16"}
{"code": "for (int x = x_m; x <= x_M; x++)\n{\n  for (int y = y_m; y <= y_M; y++)\n  {\n    for (int z = z_m; z <= z_M; z++)\n    {\n      u[t][x][y][z] = u[t][x][y][z] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/devito_prob1/devito_prob1/0"}
{"code": "for (i = 0; i < length; i++)\n{\n  if (array[i] == 3)\n  {\n    count_p++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charbelhayek-cs/openMp-parallel/count3s/0"}
{"code": "for (i; i < (513 * 4); i++)\n{\n  glColor3f(1.0f, 0.0f, 0.0f);\n  glVertex3f(Shuffled_galaxysParticles[i].position_x, Shuffled_galaxysParticles[i].position_y, Shuffled_galaxysParticles[i].position_z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnouarWalziki/Galaxeirb/4096_particles_OpenMP/src/main/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = i;\n  b[i] = i;\n  printf(\"num_threads = %d; id = %d; a,b[%d] = %d \\n\", omp_get_num_threads(), omp_get_thread_num(), i, a[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 3) num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LiyaSharipova/OpenMP-Tasks/task7/0"}
{"code": "for (i = 1; i <= T_max; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/FT/ft/8"}
{"code": "for (x = 0; x < size; x++)\n{\n  grid[x] = malloc(size * (sizeof(int)));\n  for (y = 0; y < size; y++)\n  {\n    grid[x][y] = f(size, x, y);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SgtSwagrid/supercomputing/02 - Conway+RDF/life/2"}
{"code": "for (int it = 0; it < iter; it++)\n{\n  for (int i = 0; i < destination.rows; i++)\n  {\n    for (int j = 0; j < destination.cols; j++)\n    {\n      destination(i, j) = scaling(source, scaleFactor, i, j);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/scalingOMP/0"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  assignew = DoptBCDOne(data_proc.rows(0, cov_num - 1), n, cov_num);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Lp;\n  TL = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (diff_data - Lp);\n  mupdate = ((diff_data - Lp) > (2 * (diff_data - Lm))) || ((diff_data - Lp) < ((diff_data - Lm) * 0.5));\n  Lp = (TL < (diff_data - ((Lp * n1c) / n))) ? (Lp + ((c * alpha) / m)) : (Lp - ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Lm = (mupdate) ? (Lp) : (Lm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/31"}
{"code": "for (int i = 0; i < ((maxRange - minRange) + 1); i++)\n{\n  resultMatrix[i] = true;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jedrzej-put/PUT-OpenMP/modulo-parallel/2"}
{"code": "for (i = begin; i < mid; i++)\n{\n  globB[i] = bot[i - begin];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = bt * r3;\n    t2 = 0.5 * (r4 + r5);\n    rhs[0][i][j][k] = -r2;\n    rhs[1][i][j][k] = r1;\n    rhs[2][i][j][k] = bt * (r4 - r5);\n    rhs[3][i][j][k] = (-t1) + t2;\n    rhs[4][i][j][k] = t1 + t2;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,r1 ,r2 ,r3 ,r4 ,r5 ,t1 ,t2 ,bt ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/83"}
{"code": "for (int j = stride; j < n; j += stride)\n{\n  double key = pData[j];\n  int i = j - stride;\n  while ((i >= 0) && (pData[i] > key))\n  {\n    pData[i + stride] = pData[i];\n    i -= stride;\n  }\n\n  pData[i + stride] = key;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/sort/7"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (d = 0; d < NDIM; d++)\n  {\n    veltmp = cell(ci).cvel(d);\n    aold = cell(ci).vacc(0, d);\n    anew = cell(ci).cforce(d) / cell(ci).getNV();\n    veltmp += (0.5 * dt) * (anew + aold);\n    cell(ci).setCVel(d, veltmp);\n    for (vi = 0; vi < cell(ci).getNV(); vi++)\n      cell(ci).setVAcc(vi, d, anew);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/117"}
{"code": "for (int i = nthreads - 1; i >= 0; i--)\n{\n  {\n    ((cout << \"thread \") << i) << endl;\n  }\n}\n\n", "pragma": "#pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/9th/9th/10"}
{"code": "for (i = 0; i < this->weights.get_size(0); i++)\n{\n  T result = this->bias;\n  for (int r = 0; r < this->weights.get_size(1); r++)\n  {\n    result += in_vec[i + r] * this->weights(i, r);\n  }\n\n  out_vec[i] = sigmoid(result);\n}\n\n", "pragma": "#pragma omp parallel for shared(in_vec, out_vec) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/claudio-bon/sparse-net/impl/openmp/src/sparselayer/2"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char PswCheckValue[SHA256_DIGEST_SIZE];\n  unsigned char PswCheck[SIZE_PSWCHECK];\n  int i;\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, SIZE_SALT50, cur_salt->iterations + 32, PswCheckValue, SHA256_DIGEST_SIZE, 0);\n  memset(PswCheck, 0, sizeof(PswCheck));\n  for (i = 0; i < SHA256_DIGEST_SIZE; i++)\n    PswCheck[i % SIZE_PSWCHECK] ^= PswCheckValue[i];\n\n  memcpy((void *) crypt_out[index], PswCheck, SIZE_PSWCHECK);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/rar5_fmt_plug/1"}
{"code": "for (int tid = 0; tid < nthreads; tid++)\n{\n  for (int u = csrSplitter[tid]; u < csrSplitter[tid + 1]; u++)\n  {\n    int res = _mm256_setzero_ps();\n    float sum = 0;\n    int dif = RowPtr[u + 1] - RowPtr[u];\n    int nloop = dif / 8;\n    int remainder = dif % 8;\n    for (int li = 0; li < nloop; li++)\n    {\n      int j = RowPtr[u] + (li * 8);\n      int vecv = _mm256_loadu_ps(&Val[j]);\n      int veci = _mm256_loadu_si256((int *) (&ColIdx[j]));\n      int vecx = _mm256_i32gather_ps(X, veci, 4);\n      res = _mm256_fmadd_ps(vecv, vecx, res);\n    }\n\n    sum += hsum_avx(res);\n    for (int j = RowPtr[u] + (nloop * 8); j < RowPtr[u + 1]; j++)\n    {\n      sum += Val[j] * X[ColIdx[j]];\n    }\n\n    Y[u] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiaosongAI/Parallel-SpMV/spmv_avx2/1"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  exec_begin = clock();\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/29"}
{"code": "for (size_t i = 0; i < ((maRows * maColumns) - 1); i++)\n{\n  file1 >> valueFromFile1;\n  file2 >> valueFromFile2;\n  if (!((valueFromFile1 == valueFromFile2) && (abs(valueFromFile1 - valueFromFile2) <= 0.0001)))\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/7"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  for (int j = 0; j < _cols; j++)\n  {\n    res(i, j) = this->mat[i][j] + obj(i, j);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/3"}
{"code": "for (k = 0; k < nrows; k++)\n{\n  i = clusterid[k];\n  for (j = 0; j < ncolumns; j++)\n  {\n    if (mask[k][j] != 0)\n    {\n      cdata[i][j] += data[k][j];\n      cmask[i][j]++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/52"}
{"code": "for (j = 0; j < n; j++)\n{\n  if ((arr2[j] = (char *) malloc(l * (sizeof(char)))) == 0)\n    printf(\"malloc error\\n\");\n\n  for (i = 0; i < l; i++)\n    arr2[j][i] = ' ' + (rand() % 94);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eseisaki/concurrent-system-with-openMP-and-POSIX/hamming_omp_a/2"}
{"code": "for (size_t i = 0; i < g->nr_vertices; ++i)\n  g->weights[i][i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimosr/Parallel_Programming/Project3/graph/5"}
{"code": "for (int i = 0; i < walkers; i++)\n{\n  double ak = wlkrs[i][0];\n  double bk = wlkrs[i][1];\n  post0[i] = ln_posterior(ak, bk, xmod, ymod, yerr, beta2, npts);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/sample_posterior_c_omp/8"}
{"code": "for (i = 2147483647; i >= (-2000000000); i -= 50000000)\n{\n  b++;\n}\n\n", "pragma": "omp for schedule(MY_SCHEDULE) reduction(+:b)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/exaloop/openmp/runtime/test/worksharing/for/omp_for_bigbounds/1"}
{"code": "for (int i = 0; i < height; ++i)\n{\n  for (int j = 0; j < width; ++j)\n  {\n    (ofs << (rand() % 1000)) << endl;\n  }\n\n  (cout << (((float) (i * 100)) / height)) << \"%\\r\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/korgan00/openmpi-and-openmp-project/ConcurrenteMPI_PracticaFinal/ConcurrenteMPI_PracticaFinal/main/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    matrix[i][j] = rand() % 99;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hannesrabo/concurrent-programming/hw2/matrixSum-openmp-new/1"}
{"code": "for (int exp = 1; (m / exp) > 0; exp *= 10)\n{\n  countSortAll(iArray, exp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/28"}
{"code": "for (int i = coord_y; i < (coord_y + 3); i++)\n{\n  for (int j = coord_x; j < (coord_x + 3); j++)\n  {\n    int temp_index = ((*sudoku_grid[i][j]) - '0') - 1;\n    if (mapped_matrix[temp_index] == 1)\n    {\n      printf(\"repetead value, index %d \\n\", temp_index);\n    }\n\n    mapped_matrix[temp_index] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(mapped_matrix)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidator/2"}
{"code": "for (i = 0; i < s; ++i)\n{\n  memcpy(mat[i], matrix[i], s * sizeOfCell);\n}\n\n", "pragma": "omp parallel for private(i) shared(mat, matrix, s, sizeOfCell)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/matrix/4"}
{"code": "for (int i = 0; i < out->N; ++i)\n  out->p[i] += in->p[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_07/2"}
{"code": "for (i = 0; i < matrixA->nb_rows; i++)\n{\n  for (j = 0; j < matrixB->nb_cols; j++)\n  {\n    setElemToMatrix(i + 1, j + 1, matrixResult, 0);\n    for (k = 0; k < matrixA->nb_rows; k++)\n      setElemToMatrix(i + 1, j + 1, matrixResult, getElemFromMatrix(i + 1, j + 1, matrixResult) + (getElemFromMatrix(i + 1, k + 1, matrixA) * getElemFromMatrix(k + 1, j + 1, matrixB)));\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/7"}
{"code": "for (size_t codeletsCounter = 0; codeletsCounter < myTP->numThreads; codeletsCounter++)\n{\n  myTP->checkInCodelets1336[codeletsCounter].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/55"}
{"code": "for (int y = 0; y < resolution.height; ++y)\n{\n  for (int x = 0; x < resolution.width; ++x)\n  {\n    data[(width * y) + x] = camera.getPixelColor(x, y);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apardyl/raytracer/CUDA-RayTracer/backends/ray_tracing/RayTracingOpenMP/0"}
{"code": "for (int i = from; i <= to; i++)\n  call(i, 0, elements->structure[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/MeshingApplication/custom_external_libraries/tetMeshOpt/u_ParallelFunctions/0"}
{"code": "for (iter = nthread; iter < iterations; iter++)\n{\n  omp_set_lock(&counter_lock);\n  (*pcounter1)++;\n  (*pcounter2)++;\n  omp_unset_lock(&counter_lock);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/RefCount_shared/shared/0"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    MatrixA[i][j] = 0.0;\n    MatrixB[i][j] = 0.0;\n    ResultMat[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lamyaraed/Parallel-Processing/MatrixAddition(OMP)/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] += alpha * P[i];\n}\n\n", "pragma": "#pragma omp parallel for shared(P, alpha, x, n) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/13"}
{"code": "for (i = 0; i < (SIMD_COEF_32 * SIMD_PARA_SHA1); i++)\n{\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((20 & (0xffffffff - 3)) * SIMD_COEF_32)) + (20 & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0;\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((21 & (0xffffffff - 3)) * SIMD_COEF_32)) + (21 & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0;\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((22 & (0xffffffff - 3)) * SIMD_COEF_32)) + (22 & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0;\n  keys[((((i & (SIMD_COEF_32 - 1)) * 4) + ((23 & (0xffffffff - 3)) * SIMD_COEF_32)) + (23 & 3)) + ((((((uint32_t) i) / SIMD_COEF_32) * SHA_BUF_SIZ) * SIMD_COEF_32) * 4)] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/16"}
{"code": "for (i = 0; i < 100; ++i)\n  for (j = 0; j < 100; ++j)\n{\n}\n\n\n", "pragma": "omp parallel for ordered(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/sink-1/1"}
{"code": "for (k = ki1; k <= ki2; k += 1)\n{\n  phi2[j][k] = 0.40e+00 * (u[ifin][j][k][4] - ((0.50 * (((u[ifin][j][k][1] * u[ifin][j][k][1]) + (u[ifin][j][k][2] * u[ifin][j][k][2])) + (u[ifin][j][k][3] * u[ifin][j][k][3]))) / u[ifin][j][k][0]));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (ifin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/80"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_merge_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/10"}
{"code": "for (j = 0; j < nx; j++)\n{\n  bxy[(3 * j) + ((3 * nxe) * ny)] = bxy[3 * j];\n  bxy[(1 + (3 * j)) + ((3 * nxe) * ny)] = bxy[1 + (3 * j)];\n  bxy[(2 + (3 * j)) + ((3 * nxe) * ny)] = bxy[2 + (3 * j)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/31"}
{"code": "for (i = 0; i < stats->num_vertices; i++)\n{\n  if (stats->counts[i])\n    numComp++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/21"}
{"code": "for (i = 1; i < 20; i++)\n{\n  Delta = (int) (1.0E6 * (timesfound[i] - timesfound[i - 1]));\n  minDelta = (minDelta < MAX(Delta, 0)) ? (minDelta) : (MAX(Delta, 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/13"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  result[i] += 1.0;\n  for (j = 0; j < i; j++)\n  {\n    const double distance = metric(ndata, data, data, mask, mask, weights, i, j, transpose);\n    if (distance < cutoff)\n    {\n      const double dweight = exp(exponent * log(1 - (distance / cutoff)));\n      result[i] += dweight;\n      result[j] += dweight;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/74"}
{"code": "for (i = 0; i < n3local; i++)\n{\n  if ((i % 3) == 0)\n  {\n    x[i / 3] += dt1 * v[i];\n  }\n  else\n    if ((i % 3) == 1)\n  {\n    y[i / 3] += dt1 * v[i];\n  }\n  else\n  {\n    z[i / 3] += dt1 * v[i];\n  }\n\n\n}\n\n", "pragma": "#pragma omp parallel for private(i) schedule(static) default(none) shared(x,y,z,v)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apawloski/miniMD-omp/integrate/1"}
{"code": "for (j = i * i; j <= S; j += i)\n  if (mas[j])\n  mas[j] = false;\n\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/df7734/OpenMPI/OpenMPI/OpenMPI/main/2"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  for (int j = 729 - 1; j > i; j--)\n  {\n    a[i][j] += cos(b[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), schedule(runtime), shared(a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/0"}
{"code": "for (; i < ie; i++)\n{\n  Fma(y.data()[i], y.data()[i], 0.0, alpha, 0.0, x.hi[i], x.lo[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/blas/axpy/6"}
{"code": "for (jj = 0; jj < params.nx; jj++)\n{\n  {\n    if ((((!obstacles[(ii * params.nx) + jj]) && ((cells[(ii * params.nx) + jj].speeds[3] - w3) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[6] - w4) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[7] - w4) > 0.0))\n    {\n      {\n        {\n          cells[(ii * params.nx) + jj].speeds[1] += w3;\n          cells[(ii * params.nx) + jj].speeds[5] += w4;\n          cells[(ii * params.nx) + jj].speeds[8] += w4;\n        }\n        {\n          cells[(ii * params.nx) + jj].speeds[3] -= w3;\n          cells[(ii * params.nx) + jj].speeds[6] -= w4;\n          cells[(ii * params.nx) + jj].speeds[7] -= w4;\n        }\n      }\n    }\n\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ellenshin/UoB_OpenMP/d2q9-bgk/3"}
{"code": "for (i = 0; i < 9; i++)\n{\n  printf(\"%d \", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Arrays/array_min_max/1"}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = j + (((k + depth) - 1) * depth);\n    right_snd_buffer[FTNREF1D(index, 1)] = field[FTNREF2D((x_max + 1) - j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/pack_kernel_c/1"}
{"code": "for (int i = 0; i < ROWA; i++)\n  for (int j = 0; j < COLB; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/morris821028/hw-OpenMP-practice/offical/omp_mm/2"}
{"code": "for (unsigned int i = 1; i < np; i++)\n{\n  info_mit[0] = np;\n  MPI_Send(info_mit, 5, MPI_UNSIGNED, i, TAG_CLUSTER_1, MPI_COMM_WORLD);\n  MPI_Send(info_mit, 5, MPI_UNSIGNED, i, TAG_CLUSTER_1, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/1"}
{"code": "for (int i = 0; i < TRIALS; ++i)\n{\n  runtimeI_FFT = omp_get_wtime();\n  a = fft_iterative(a, 0);\n  runtimeI_FFT = omp_get_wtime() - runtimeI_FFT;\n  avg1 += runtimeI_FFT;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Fast Fourier Transform/fft_parallel/3"}
{"code": "for (i = 0; i < newsize; i++)\n{\n  memOne[i] = (double *) malloc((sizeof(double)) * newsize);\n  memTwo[i] = (double *) malloc((sizeof(double)) * newsize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/praveenChauhan686/Strassen-Algorithm-Java-And-OpenMp/Assignment 2_21261912/Source Code/OpenMp C/strassens_algorithm/7"}
{"code": "for (i = 0; i < 100; i++)\n{\n  boolean = (A[i] >= number) ? (1) : (0);\n  printf(\"A[%d]: %d,\\tA[%d] >= 500: %d\\n\", i, A[i], i, boolean);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gapgag55/OpenMP-Excercise/4.FindNumber/openmp/0"}
{"code": "for (int t = 0; t < nt; t++)\n{\n  spPosVerlet();\n  resetContacts();\n  spForces(lenscales);\n  spVelVerlet(lenscales);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/79"}
{"code": "for (i = 0; i < c; i++)\n{\n  e[2][i] = a1[2][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/5"}
{"code": "for (p = 0; p < k; p++)\n{\n  L[i][k] -= L[i][p] * U[p][k];\n  U[k][i] -= L[k][p] * U[p][i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/numeric/solve-sec/ver-2.0/crout-omp/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  u[m][i][j][k] = u[m][i][j][k] + rhs[m][i][j][k];\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/3"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  old2NewMap[commIndex[i]] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForMatrixReordering/1"}
{"code": "for (i = 0; i < 16; i++)\n  free((void *) args[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/7"}
{"code": "for (n = 0; n < threads_num; n++)\n{\n  sumX[n] = 0;\n  sumY[n] = 0;\n  for (m = 0; m < all_centroid_size[n]; m++)\n  {\n    sumX[n] += nearestx[n][m];\n    sumY[n] += nearesty[n][m];\n  }\n\n  meanX[n] = sumX[n] / all_centroid_size[n];\n  centroidX[n] = meanX[n];\n  meanY[n] = sumY[n] / all_centroid_size[n];\n  centroidY[n] = meanX[n];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oshaesam1/K-means-Clustering-using-openMp-FCAI-/main/1"}
{"code": "for (int i = 1; i < (k + 1); i++)\n{\n  name = bookList[nearest_neighbor[i].comm_rank];\n  next_loc = nearest_neighbor[i].comm_rank;\n  next = nearest_neighbor[i].number;\n  label = class_labels[nearest_neighbor[i].comm_rank];\n  (((((cout << \"nearest neighbor \") << i) << \"\\n\\t| Rank \") << next_loc) << \" = \") << next;\n  (((((cout << \"\\n\\t| Book (\") << name) << \") has label \") << label) << endl) << endl;\n  class_count[label]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/madisonjordan/KNN_Parallelized/main/4"}
{"code": "for (j = 0; j <= (n - 1); ++j)\n{\n  for (i = 0; i <= (n - 1); ++i)\n  {\n    if (A[i] < A[j])\n    {\n      R[(i + n) - 1][j] = 1;\n    }\n    else\n    {\n      R[(i + n) - 1][j] = 0;\n    }\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgrigoras/parallel_algorithms/Lab 7/Lab7_p1_openmp/Hello_parallel/main/5"}
{"code": "for (int i = 0; i < 150000; i++)\n{\n  a *= 0.5;\n}\n\n", "pragma": "omp parallel for schedule(static,chunk_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/Parallel-and-Distributed-Programming-Lab3/lab3/0"}
{"code": "for (int i = 0; i <= count; i++)\n{\n  fprintf(fw, \"%c\", BESTD[count - i]);\n  if (((i + 1) % 100) == 0)\n    fputs(\"\\n\\t  \", fw);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z1skgr/OpenMP-pthreads-parallelComputing/OMPa/3"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    for (i = 0; i < 3; i++)\n    {\n      fxy[(i + (3 * j)) + (3 * kj)] = exy[(i + (3 * j)) + (3 * kj)] * at1;\n      fxy[(i + (3 * j)) + (3 * k1)] = exy[(i + (3 * j)) + (3 * k1)] * at1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,k1,kk,kj,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/13"}
{"code": "for (uint8_t current_repeat = 0; current_repeat != repeat_count; ++current_repeat)\n{\n  reset_input(input_graph_filename, individual_count, location_count, edge_count, individual_graph, individuals);\n  time_start = omp_get_wtime();\n  simulate_parallel(individual_count, total_epochs, individual_graph, individuals, epoch_statistics);\n  time_end = omp_get_wtime() - time_start;\n  total_time += time_end;\n  if (!assert_epidemic_results(individual_count, epoch_statistics))\n    (cout << \"Error.\") << endl;\n\n  cout << \".\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/temp3rr0r/InfectiousDiseaseModelling/InfectiousDiseaseModeling/InfectiousDiseaseModeling/2"}
{"code": "for (int i = 1; i < graph->num_nodes; i++)\n{\n  if (sol->distances[i] == 0)\n    sol->distances[i] = -1;\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tim00631/OpenMP-Programming/part2/breadth_first_search/bfs/1"}
{"code": "for (i = 0; i < 9; i++)\n{\n  for (j = 0; j < 9; j++)\n  {\n    new_table[i][j] = last_table[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/2"}
{"code": "for (int j = 0; j < i; j += 2)\n{\n  merge(&sortedAll[(j * MAX_ELEMENTS) / i], MAX_ELEMENTS / i, &sortedAll[((j + 1) * MAX_ELEMENTS) / i], MAX_ELEMENTS / i, &sortedAllOutput[(MAX_ELEMENTS / i) * j]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for schedule(dynamic, 1) shared(sortedAll, sortedAllOutput) firstprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BlurEffect/OpenMP/OpenMPAssignment/02_Sortout_Parallel_For/4"}
{"code": "for (int ill = 1; ill < weightLength; ill++)\n{\n  transferParentsOneGeneration();\n  FWOneStep();\n  hdf_WGT_data.openFile();\n  hdf_WGT_data.addFW(ill);\n  for (int i = 0; i < Weights.size(); i++)\n    hdf_WGT_data.addStep(i, Weights[i]);\n\n  hdf_WGT_data.closeFW();\n  hdf_WGT_data.closeFile();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FRSingleOMP/3"}
{"code": "for (int32_t i = 0; i < 10; i++)\n  sum[i].x += i;\n\n", "pragma": "\t\t#pragma omp for reduction(my_add : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_09/1"}
{"code": "for (unsigned int i = 0; i < ((sizeof(__m256i)) / (sizeof(T))); i++)\n{\n  (sstr << values[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-neumann/versalignLib/src/Kernels/AVX-SSE/AVXKernel/1"}
{"code": "for (int thread = 0; thread < threads; thread++)\n{\n  int startRow = (height / threads) * thread;\n  startRow += min(thread, height % threads);\n  BradleyThreshold(image + startRow, res + startRow, width, (height / threads) + (thread < (height % threads)));\n}\n\n", "pragma": "#pragma omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adalbert44/OpenMP/PictureBinarizationOpenMP/PictureBinarizationOpenMP/3"}
{"code": "for (int step_Idx = start_step; step_Idx < (start_step + offset_step); step_Idx++)\n{\n  double x = delta_x * step_Idx;\n  loc_sum += (4.0 * delta_x) / (1. + (x * x));\n  if (x > (1 + tol))\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mirzawd/openMP_tutorials/numerical_integration/main__/0"}
{"code": "for (i = 0; i <= (nx - 1); i += 1)\n{\n  for (j = 0; j <= (ny - 1); j += 1)\n  {\n    for (k = 0; k <= (nz - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        rsd[i][j][k][m] = -frct[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/83"}
{"code": "for (i = 0; i < maxgrid; i++)\n  for (j = 0; j < maxgrid; j++)\n{\n  fprintf(stderr, DATA_PRINTF_MODIFIER, path[i][j]);\n  if ((((i * maxgrid) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/medley/reg_detect/reg_detect/5"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  if (percentDiff(A[i], A_outputFromGpu[i]) > 0.05)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/vector-product/src/vector-product_gpu/2"}
{"code": "for (i = 0; i < 4; i++)\n{\n  c_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog5_PointsClassify_openmp/1"}
{"code": "for (unsigned int i = 0; pairs[i].name != NULL; i++)\n{\n  if (string(pairs[i].name) == strtolower(args[0].c_str()))\n  {\n    return pairs[i].data_attr;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/src/tl/omp/core/tl-omp-core/1"}
{"code": "for (i = 0; i < 100; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp_orphan/1"}
{"code": "for (int i = 0; i < fullLen; i++)\n{\n  tmpSum = 0;\n  for (int j = 0; j < threadLenDivision; j++)\n  {\n    tmpSum += tmpResMatrix[j]->getMatrixElement(i);\n  }\n\n  resMatrix->matrixPush(tmpSum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nablax/OpenMP-CUDA-Matrix-Multiplication/QtMatrixOpenMP/MatrixCalculation/7"}
{"code": "for (int i = 0; i < 10; i++)\n  ++i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/0"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  double f = (fractions[i] * 100) / ((double) P);\n  printf(\" (%.2f - %.2f) -> %.2f%%\\n\", i / 100.0, (i / 100.0) + 0.01, f);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aliardaeker/High-Dimensional-Space-Characteristics-using-OpenMP-and-SIMD/openmp/1"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/52"}
{"code": "for (i = 0; i < nrows; i++)\n  maxlen = gk_max(maxlen, rowptr[i + 1] - rowptr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/22"}
{"code": "for (int i = 0; i <= (end - start); i++)\n{\n  tab[i] = value;\n  value++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wszymkowski/large-scale-computing-course/primes_domenowe/0"}
{"code": "for (int ix = 0; ix < (_M + 2); ix++)\n  for (int iy = 0; iy < (K + 2); iy++)\n  spr[ix][iy] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/68"}
{"code": "for (int i = 1; i < num_threads; ++i)\n{\n  for (int j = 0; j < numBuckets; ++j)\n  {\n    local_histogram_final[(i * numBuckets) + j] = local_histogram_final[((i - 1) * numBuckets) + j] + local_histogram[((i - 1) * numBuckets) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  graph->nodes[i] = (Node *) malloc(sizeof(Node));\n  graph->nodes[i]->label = i + 1;\n  graph->nodes[i]->inQueue = 0;\n  graph->nodes[i]->inArray = 0;\n  graph->nodes[i]->degree = 0;\n  graph->nodes[i]->neighbours = (Node **) malloc(n * (sizeof(Node *)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z3y50n/ReverseCuthillMcKee/src/functions/2"}
{"code": "for (i = 0; i < ng; i++)\n  for (j = 0; j < ng; j++)\n  for (k = 0; k < ng; k++)\n{\n  kx = k_base * (i - (ng / 2));\n  ky = k_base * (j - (ng / 2));\n  kz = k_base * (k - (ng / 2));\n  pfft(p_theta, i, j, k)->Re = ((kx * pfft(p_vel_x, i, j, k)->Im) + (ky * pfft(p_vel_y, i, j, k)->Im)) + (kz * pfft(p_vel_z, i, j, k)->Im);\n  pfft(p_theta, i, j, k)->Im = (-1.0) * (((kx * pfft(p_vel_x, i, j, k)->Re) + (ky * pfft(p_vel_y, i, j, k)->Re)) + (kz * pfft(p_vel_z, i, j, k)->Re));\n  pfft(p_theta, i, j, k)->Re = (pfft(p_theta, i, j, k)->Re / normal_hubble_param) / f;\n  pfft(p_theta, i, j, k)->Im = (pfft(p_theta, i, j, k)->Im / normal_hubble_param) / f;\n}\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/window_function/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*cclass) == 'U')\n  {\n    printf(\"          %2d%20.13e\\n\", m, xce[m]);\n  }\n  else\n    if (xcedif[m] > epsilon)\n  {\n    *verified = FALSE;\n    printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, xce[m], xceref[m], xcedif[m]);\n  }\n  else\n  {\n    printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, xce[m], xceref[m], xcedif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/60"}
{"code": "for (long i = 0; i < final_num; i++)\n{\n  if (i < infection_num)\n  {\n    people.at(i).setStatus(1);\n  }\n  else\n  {\n    people.at(i).setStatus(-2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rskim47/disease-propagation/simulation/6"}
{"code": "for (size_t i = 0; i < difdit.N; ++i)\n  A[i] *= conj(B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shuibitianantian/Arbitrary-FFT/openmp/fft/9"}
{"code": "for (i = 1; i < (subprob_size - 1); i++)\n{\n  j = subprob_size - 1;\n  b[i][j] = 0.2 * ((((a[i][j] + a[i - 1][j]) + a[i + 1][j]) + a[i][j - 1]) + rlcbuff[i]);\n  if (fabs(b[i][j] - a[i][j]) > maxdiff)\n    maxdiff = fabs(b[i][j] - a[i][j]);\n\n}\n\n", "pragma": "omp parallel for reduction(max:maxdiff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/11"}
{"code": "for (i = 0; i < N; i++)\n{\n  double temp = fabs(yerr[i] / yscal[i]);\n  if (temp > errmax)\n    errmax = temp;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/grrt-omp/kernels/6"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB045-doall1-orig-no/0"}
{"code": "for (i = jstart; i < jstop; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < col; j++)\n  {\n    if (j != i)\n      sum = sum + (A[i][j] * x[j]);\n\n  }\n\n  xPrime[i] = (1 / A[i][i]) * (b[i] - sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/9"}
{"code": "for (int64_t i = c; i < pi_sqrtx; i++)\n{\n  int64_t x2 = fast_div(x, primes_[i + 1]);\n  if (is_pix(x2, i))\n    sum += ((pi_[x2] - i) + 1) * (-SIGN);\n  else\n    sum += (phi < (-SIGN)) > ((x2, i));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primesum/src/phi/0"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n  Sorted[rank[i]] = A[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-fig/CISC-4335-OpenMP-Rank-Sort/rank_sort/3"}
{"code": "for (int i = 1, j = 0; i < n; ++i)\n{\n  int bit = n >> 1;\n  for (; j >= bit; bit >>= 1)\n    j -= bit;\n\n  j += bit;\n  if (i < j)\n    swap(a[i], a[j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mlchkhn/parallel_algorithms/multiplication/5"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  for (size_t n = 0; n < this_nodes; n++)\n  {\n    double z = bias[n];\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      z += prev_outputs[(s * prev_nodes) + prev_n] * weight[(prev_n * this_nodes) + n];\n    }\n\n    this_outputs[(s * this_nodes) + n] = 1 / (1 + exp(-z));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU8/0"}
{"code": "for (int i = 0; i < (*numOfSequences); i++)\n{\n  fscanf(file, \"%s\", charBuffer);\n  (*Seq2)[i] = (char *) calloc(strlen(charBuffer), sizeof(char));\n  strcpy((*Seq2)[i], charBuffer);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MatanF5/Sequence_Allignment_Parllel/functions/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  if (line[i] < mn)\n    mn = line[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/maxmin/0"}
{"code": "for (int i = 0; i < numBucketsXYZ; i++)\n{\n  firstParticleInBucket[i] = -1;\n  lastParticleInBucket[i] = -1;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/22"}
{"code": "for (int i = 0; i < n; i++)\n{\n  resurse[i] = (int *) malloc(n * (sizeof(int)));\n  preturi[i] = (int *) malloc(n * (sizeof(int)));\n  bugete[i] = (int *) malloc(n * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PetcuAlexandru/OpenMP_parallelization/parallel/1"}
{"code": "for (int row = 0; row < height; row++)\n{\n  for (int col = 0; col < width; col++)\n  {\n    for (int i = 0; i < widthA; i++)\n    {\n      result[(row * width) + col] += a[(row * widthA) + i] * b[(i * width) + col];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/epoell/openMP_examples_and_Matrix-Matrix-Multiplication/matmult_parallel/10"}
{"code": "for (int i = 0; i < _N; i++)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhston02/PthreadComparisonToOpenMP/main/3"}
{"code": "for (int i = 0; i < length; i++)\n{\n  printf(\"%.3f \", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/12"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  if ((x[i] > 0.5) && (x[i] < 1.0))\n  {\n    u[i] = 2.0;\n    u_new[i] = 2.0;\n  }\n  else\n  {\n    u[i] = 1.0;\n    u_new[i] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Linear Convection/main/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  arr[i] = 1 + (rand() % 10000);\n  arr2[i] = arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/oddEventSortParallel/1"}
{"code": "for (i = 0; i < numOfPoints; i++)\n{\n  minCluster = 0;\n  minDistance = distance(clusters[0].center, points[i].coordinations, dimension);\n  for (j = 1; j < numOfClusters; j++)\n  {\n    distanceTemp = distance(clusters[j].center, points[i].coordinations, dimension);\n    if (distanceTemp < minDistance)\n    {\n      minDistance = distanceTemp;\n      minCluster = j;\n    }\n\n  }\n\n  if (points[i].belongTo != minCluster)\n    changeTemp = 1;\n\n  points[i].belongTo = minCluster;\n}\n\n", "pragma": "#pragma omp parallel for private(j,minCluster,minDistance,distanceTemp) reduction(| :changeTemp)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/orog/KmeansParallelImpl/KmeansParallelSol/KmeansParallel/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  destination[i] = source[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i) shared(source, destination, n) schedule(guided)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/N-Body-Simulation/final-version/nbody/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (strcmp(qs.solutions[i], qs.answers[i]) == 0)\n  {\n    answerResults[i] = \"Correct \";\n    nCorrectAnswers++;\n    studentPoints += qs.ratings[i];\n  }\n  else\n    answerResults[i] = \"Incorrect \";\n\n  totalRating += qs.ratings[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ricardoreais/exam-evaluator/exam-evaluator/1"}
{"code": "for (int i = maxOfStrip; i < inputData.numDataPoints; i++)\n{\n  int d = calcDirectBin(inputData.windDir[i]);\n  int s = calcSpeedsBin(inputData.windSpd[i]);\n  if (((d < NUM_OF_SECTORS) && (d >= 0)) && ((s < NUM_OF_SPEED) && (s >= 0)))\n  {\n    localOutData[d][s]++;\n    print++;\n  }\n  else\n    noPrint++;\n\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/WindRosePOC/src_OpenMP/Parallel01_03/0"}
{"code": "for (int mat = 0; mat < Nmats; mat++)\n{\n  for (int j = 0; j < sizey; j++)\n  {\n    for (int i = 0; i < sizex; i++)\n    {\n      double nm = n[mat];\n      if (Vf[((ncells * mat) + i) + (sizex * j)] > 0.0)\n      {\n        p[((ncells * mat) + i) + (sizex * j)] = ((nm * rho[((ncells * mat) + i) + (sizex * j)]) * t[((ncells * mat) + i) + (sizex * j)]) / Vf[((ncells * mat) + i) + (sizex * j)];\n      }\n      else\n      {\n        p[((ncells * mat) + i) + (sizex * j)] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/7"}
{"code": "for (i = 1; i <= n; i++)\n{\n  colidx[n + i] = 0;\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/16"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at1 = ci2 * crealf(ffc[j]);\n  at2 = (at1 * dnx) * ((float) j);\n  at1 = at1 * cimagf(ffc[j]);\n  zt1 = (-cimagf(cu[2 + (3 * j)])) + (crealf(cu[2 + (3 * j)]) * _Complex_I);\n  zt2 = (-cimagf(cu[1 + (3 * j)])) + (crealf(cu[1 + (3 * j)]) * _Complex_I);\n  bxyz[3 * j] = zero;\n  bxyz[1 + (3 * j)] = (-at2) * zt1;\n  bxyz[2 + (3 * j)] = at2 * zt2;\n  bxyz[3 * (j + k1)] = zero;\n  bxyz[1 + (3 * (j + k1))] = zero;\n  bxyz[2 + (3 * (j + k1))] = zero;\n  bxyz[3 * (j + l1)] = zero;\n  bxyz[1 + (3 * (j + l1))] = zero;\n  bxyz[2 + (3 * (j + l1))] = zero;\n  bxyz[3 * ((j + k1) + l1)] = zero;\n  bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n  bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n  wp += at1 * (((cu[3 * j] * conjf(cu[3 * j])) + (cu[1 + (3 * j)] * conjf(cu[1 + (3 * j)]))) + (cu[2 + (3 * j)] * conjf(cu[2 + (3 * j)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/48"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    arr1[i][j] = j;\n    arr2[i][j] = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/matrix_matrix_openmp/0"}
{"code": "for (chunk = 0; chunk < num_chunk; ++chunk)\n{\n  int r_start = BLOCK_SIZE_R * (chunk / chunks_in_col);\n  int c_start = BLOCK_SIZE_C * (chunk % chunks_in_row);\n  int r_end = ((r_start + BLOCK_SIZE_R) > row) ? (row) : (r_start + BLOCK_SIZE_R);\n  int c_end = ((c_start + BLOCK_SIZE_C) > col) ? (col) : (c_start + BLOCK_SIZE_C);\n  if ((((r_start == 0) || (c_start == 0)) || (r_end == row)) || (c_end == col))\n  {\n    for (r = r_start; r < (r_start + BLOCK_SIZE_R); ++r)\n    {\n      for (c = c_start; c < (c_start + BLOCK_SIZE_C); ++c)\n      {\n        if ((r == 0) && (c == 0))\n        {\n          delta = Cap_1 * (((power[0] + ((temp[1] - temp[0]) * Rx_1)) + ((temp[col] - temp[0]) * Ry_1)) + ((amb_temp - temp[0]) * Rz_1));\n        }\n        else\n          if ((r == 0) && (c == (col - 1)))\n        {\n          delta = Cap_1 * (((power[c] + ((temp[c - 1] - temp[c]) * Rx_1)) + ((temp[c + col] - temp[c]) * Ry_1)) + ((amb_temp - temp[c]) * Rz_1));\n        }\n        else\n          if ((r == (row - 1)) && (c == (col - 1)))\n        {\n          delta = Cap_1 * (((power[(r * col) + c] + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) * Rx_1)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) * Ry_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n        }\n        else\n          if ((r == (row - 1)) && (c == 0))\n        {\n          delta = Cap_1 * (((power[r * col] + ((temp[(r * col) + 1] - temp[r * col]) * Rx_1)) + ((temp[(r - 1) * col] - temp[r * col]) * Ry_1)) + ((amb_temp - temp[r * col]) * Rz_1));\n        }\n        else\n          if (r == 0)\n        {\n          delta = Cap_1 * (((power[c] + (((temp[c + 1] + temp[c - 1]) - (2.0 * temp[c])) * Rx_1)) + ((temp[col + c] - temp[c]) * Ry_1)) + ((amb_temp - temp[c]) * Rz_1));\n        }\n        else\n          if (c == (col - 1))\n        {\n          delta = Cap_1 * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.0 * temp[(r * col) + c])) * Ry_1)) + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) * Rx_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n        }\n        else\n          if (r == (row - 1))\n        {\n          delta = Cap_1 * (((power[(r * col) + c] + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.0 * temp[(r * col) + c])) * Rx_1)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) * Ry_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n        }\n        else\n          if (c == 0)\n        {\n          delta = Cap_1 * (((power[r * col] + (((temp[(r + 1) * col] + temp[(r - 1) * col]) - (2.0 * temp[r * col])) * Ry_1)) + ((temp[(r * col) + 1] - temp[r * col]) * Rx_1)) + ((amb_temp - temp[r * col]) * Rz_1));\n        }\n\n\n\n\n\n\n\n\n        result[(r * col) + c] = temp[(r * col) + c] + delta;\n      }\n\n    }\n\n    continue;\n  }\n\n  for (r = r_start; r < (r_start + BLOCK_SIZE_R); ++r)\n  {\n    for (c = c_start; c < (c_start + BLOCK_SIZE_C); ++c)\n    {\n      result[(r * col) + c] = temp[(r * col) + c] + (Cap_1 * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.f * temp[(r * col) + c])) * Ry_1)) + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.f * temp[(r * col) + c])) * Rx_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1)));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LLNL/AutoParBench/benchmarks/original/rodinia_3.1/openmp/hotspot/hotspot_openmp/0"}
{"code": "for (i = 0; i < count; i++)\n  processwork(parr[i]);\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_omp25/0"}
{"code": "for (i = 0; i < n_cell; i++)\n{\n  v_array[(step * n_cell) + i] = calc_iz_c_core(v_array - n_cell, &u_array[i], const_table);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DaisukeMiyamoto/android-neuron-simulator/app/src/main/cpp/benchmark_iz/0"}
{"code": "for (int u = 0; u < n; u++)\n{\n  for (int v = 0; v < n; v++)\n  {\n    int weight = mat[convert_dimension_2D_1D(u, v, n)];\n    if (weight < INF)\n    {\n      if ((dist[u] + weight) < dist[v])\n      {\n        *has_negative_cycle = true;\n        return;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zslwyuan/Parallel-Computing-Tutorials-OMP-MPI-CUDA/openmp_bellman_ford/0"}
{"code": "for (i = 1; i < num_procs; i++)\n{\n  key_buff1_aptr[i] = (INT_TYPE *) alloc_mem((sizeof(INT_TYPE)) * MAX_KEY);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/4"}
{"code": "for (j = 0; j < n; j++)\n  if (a[j] < a[i])\n  count++;\nelse\n  if ((a[j] == a[i]) && (j < i))\n  count++;\n\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adrianoferruzzi/SD-OpenMP-MPI/Parallel_2/sort_parallel/1"}
{"code": "for (int i = 0; i < 10; i++)\n  for (int j = 0; j < 10; j++)\n  A[i][j] = i * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nithinmanne/openmp/collapsereduce/Source/0"}
{"code": "for (int i = 1; i < d; i++)\n{\n  a[i] = rand() % Ns;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/1"}
{"code": "for (int i = 0; i < treeNumber; i++)\n  for (int j = 0; j < treeSize; j++)\n  reference[i] += (i * treeSize) + j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/layout-omp/main/0"}
{"code": "for (i = 0; i < numOfProcesses; i++)\n{\n  localPoints[i] = numOfPoints / numOfProcesses;\n  if (rem > 0)\n  {\n    localPoints[i]++;\n    rem--;\n  }\n\n  displacements[i] = sum;\n  sum += localPoints[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariamAboAyla/Histogram-by-MPI---C-language/file/3"}
{"code": "for (; br != end_input; tl++, tc++, tr++, cl++, cc++, cr++, bl++, bc++, br++, result++)\n  *result = ((((((((*tl) | (*tc)) | (*tr)) | (*cl)) | (*cc)) | (*cr)) | (*bl)) | (*bc)) | (*br);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/15"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    C[(i * p) + j] = 0.0;\n    for (int k = 0; k < n; k++)\n    {\n      C[(i * p) + j] += A[(i * n) + k] * B[(k * p) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/0"}
{"code": "for (i = 0; i < (8 * 20); i += 8)\n{\n  y += res[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/ece563/hw2/B/reduction/0"}
{"code": "for (int i = 0; i < no_clauses; i++)\n{\n  if ((equation[i][rand_var] == (-1)) && (assignment == 0))\n  {\n    assgn[i][rand_var] = 1;\n  }\n  else\n    if ((equation[i][rand_var] == 1) && (assignment == 1))\n  {\n    assgn[i][rand_var] = 1;\n  }\n  else\n  {\n    assgn[i][rand_var] = 0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdkul22/satsolve/satool_omp/10"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"i = %d, thread id = %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest03/simple_test_03/2"}
{"code": "for (i = 0; i < K; i++)\n  mid_array[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  c += a[i] * b[i];\n}\n\n", "pragma": "    #pragma omp for reduction(+:c) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/VecDotPro/0"}
{"code": "for (int i = 0; i < An; i++)\n{\n  int nnzpv = nnzcum;\n  Crow[i] = nnzcum;\n  if ((nnzcum + An) > (*Csize))\n  {\n    *Csize += (An > ((*Csize) / 4)) ? (An) : ((*Csize) / 4);\n    *Ccol = realloc(*Ccol, (*Csize) * (sizeof(int)));\n  }\n\n  for (int jj = Frow[i]; jj < Frow[i + 1]; jj++)\n  {\n    xb[Fcol[jj]] = 0;\n  }\n\n  for (int jj = Arow[i]; jj < Arow[i + 1]; jj++)\n  {\n    int j = Acol[jj];\n    for (int kp = Brow[j]; kp < Brow[j + 1]; kp++)\n    {\n      int k = Bcol[kp];\n      if (!xb[k])\n      {\n        xb[k] = 1;\n        (*Ccol)[nnzcum] = k;\n        nnzcum++;\n      }\n\n    }\n\n  }\n\n  if (nnzcum > nnzpv)\n  {\n    quickSort(*Ccol, nnzpv, nnzcum - 1);\n    for (int p = nnzpv; p < nnzcum; p++)\n    {\n      xb[(*Ccol)[p]] = 0;\n    }\n\n  }\n\n  for (int jj = Frow[i]; jj < Frow[i + 1]; jj++)\n  {\n    xb[Fcol[jj]] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/final/SpGEMM_mpi_omp/9"}
{"code": "for (k = 0; k < npy; k++)\n{\n  k1 = (idimp * npx) * k;\n  at3 = edgely + (at2 * (((float) k) + 0.5));\n  for (j = 0; j < npx; j++)\n  {\n    part[(idimp * j) + k1] = edgelx + (at1 * (((float) j) + 0.5));\n    part[(1 + (idimp * j)) + k1] = at3;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/22"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"thread %d ejecuta la iteraci\u00f3n %d del bucle\\n\", omp_get_thread_num(), i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P1/1/bucle-for-modificado/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"row[%d] sum = %d \\t col[%d] sum = %d \\n\", i, rowSum[i], i, colSum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Department-Labs/Parallel-Computing-Lab/Lab2/rowcolsum/3"}
{"code": "for (int i = (rang * n) / nbp; i < (((rang + 1) * n) / nbp); i++)\n  sum += x[i] * y[i];\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/1"}
{"code": "for (int i = 0; i < nr_dimensions; i++)\n{\n  norm += (v1[i] - v2[i]) * (v1[i] - v2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/8"}
{"code": "for (int I = 0; I < NumberOfDevices; ++I)\n  MemoryManagers.emplace_back((make_unique < MemoryManagerTy) > ((DeviceAllocators[I], MemoryManagerThreshold)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/libomptarget/plugins/cuda/src/rtl/1"}
{"code": "for (i = 0; i < (series->count - lag); i++)\n{\n  numerator += (series->data[i] - mean1) * (series->data[i + lag] - mean2);\n}\n\n", "pragma": "omp parallel for reduction (+: numerator)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/pseries/5"}
{"code": "for (i = 0; i < array_num; i++)\n{\n  is_in_block = checkInBlock(i, ph_x, ph_y, ph_z, x, y, z, szx, szy, dim_switch_3d, riken_switch);\n  if (is_in_block)\n  {\n    within_block_index = i;\n    i = array_num;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/13"}
{"code": "for (i = 0; i < n; ++i)\n{\n  total += f(get_double(0.0, 1.0, &seed), get_double(0.0, 1.0, &seed), get_double(0.0, 1.0, &seed), get_double(0.0, 1.0, &seed), get_double(0.0, 1.0, &seed));\n}\n\n", "pragma": "omp parallel for reduction (+:total) private(i) shared(n) num_threads(nprocs)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/asad-iqbal-ali/OpenMP-vs-CUDA-Integration/omp/mc_omp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (map[i] == 0)\n    continue;\n  else\n  {\n    for (int j = 31; j >= 0; j--)\n    {\n      if (map[i] & (1 << j))\n        return (32 * ((size - i) - 1)) + j;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/Grobner/3"}
{"code": "for (int i = 0; i < objs; i++)\n{\n  for (int j = 0; j < objs; j++)\n  {\n    if (i != j)\n      points[i].addForce(points[j]);\n\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/AosSimulator/3"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  n_c += cInfo[i].size * cInfo[i].size;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:n_c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/BasicCommunitiesDetection/parallelLouvainMethodFastTrackResistance/0"}
{"code": "for (int i = 0; i < 60000; i++)\n{\n  double *input = data[i];\n  activateNN(input);\n  int result = readNNOutput();\n  if (result == cat[i])\n    correct++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/NN/fashion-NN/6"}
{"code": "for (int i = 0; i < nsegments; i++)\n{\n  fscanf(fp, \"%d\", &ilvecshare[i]);\n  printf(\"ilvecshare[%d] = %d\\n\", i, ilvecshare[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdafibuzzaman/openmp-task-distributed/lobpcg_dist/7"}
{"code": "for (i = iters->begin(); i != iters->end(); ++i)\n  if (!strcmp((char *) (*i), (char *) pv->symbol->name_str))\n  break;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/PolyOpt2/polyopt/PastToSage/1"}
{"code": "for (r = 0; r < ROWS; r++)\n{\n  for (c = 0; c < COLUMNS; c++)\n  {\n    sum += getVal(cells, r, c);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum) private(c)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IsaacLehman/Game-of-Life/GameOfLife/2"}
{"code": "for (int i = 0; i < trace_size; i++)\n{\n  int offset = ((positions_y[i] * wnz_wnx) + std_offset) + positions_x[i];\n  values[(trace_step * trace_size) + i] = pressure[offset];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/trace-writers/SeismicTraceWriter/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i + 1;\n  for (int j = 0; j < (N - i); j++)\n  {\n    b[j] = j + 2;\n    validate[(i * N) + j] = a[i] * b[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/collapse-nonrectangle/collapse-nonrectangle/1"}
{"code": "for (int i = 0; i < alignedN; i += 8)\n  _mm256_storeu_ps(&in[i], scalar);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/23"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (data->committee >= g->N)\n  {\n    correct = 0;\n    WARN(\"%d apparently belongs to a non-existant committee %d\\n\", i, data->committee);\n    goto end;\n  }\n\n  committee_count[data->committee]++;\n  1(\"%d->committee = %d\\n\", i, data->committee);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/8"}
{"code": "for (int i = number_frst; i < (number_lst + 1); i++)\n{\n  count = 0;\n  for (int j = 2; j < sqrt(i); j++)\n  {\n    if ((i % j) == 0)\n    {\n      count++;\n    }\n\n    if (count > 0)\n      break;\n\n  }\n\n  if (count == 0)\n  {\n    printf(\"%d  \", i);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(count) schedule(dynamic, 5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block4/task15/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  sum += a[i] * b[i];\n  partialSum = sum;\n}\n\n", "pragma": "omp for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/benjamintli/openmp_assignment/src/openmp_thread/0"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      rho_inv = 1.0 / u[i][j][k][0];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[i][j][k][1] * rho_inv;\n      vs[i][j][k] = u[i][j][k][2] * rho_inv;\n      ws[i][j][k] = u[i][j][k][3] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/18"}
{"code": "for (ii = 0; ii < nlocalverts; ii += ulong_bits)\n{\n  size_t i;\n  size_t i_end = ii + ulong_bits;\n  if (i_end > nlocalverts)\n    i_end = nlocalverts;\n\n  for (i = ii; i < i_end; ++i)\n  {\n    if (!((visited[i / ulong_bits] & (1UL << (i % ulong_bits))) != 0))\n    {\n      size_t j;\n      size_t j_end = rowstarts[i + 1];\n      for (j = rowstarts[i]; j < j_end; ++j)\n      {\n        int64_t v1 = column[j];\n        int64_t v1_swizzled = (((int64_t) VERTEX_OWNER(v1)) << lg_local_queue_size) | ((int64_t) VERTEX_LOCAL(v1));\n        if (((in_queue_summary[(v1_swizzled / ulong_bits) / ulong_bits] & (1UL << ((v1_swizzled / ulong_bits) % ulong_bits))) != 0) && ((in_queue[v1_swizzled / ulong_bits] & (1UL << (v1_swizzled % ulong_bits))) != 0))\n        {\n          pred[i] = (v1 & INT64_C(0xFFFFFFFFFFFF)) | (((int64_t) cur_level) << 48);\n          not_done |= 1;\n          do\n          {\n            size_t word_idx = i / ulong_bits;\n            int bit_idx = i % ulong_bits;\n            unsigned long mask = 1UL << bit_idx;\n            visited[word_idx] |= mask;\n            out_queue[word_idx] |= mask;\n          }\n          while (0);\n          break;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(|:not_done)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/topanitanw/graph500_openmp/mpi/bfs_replicated/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (j == (N - 1))\n    {\n      (out << C_n[i][j]) << \"\\n\";\n    }\n    else\n    {\n      (out << C_n[i][j]) << \" \";\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/milestone-2/advection_simulation/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  char buffer[genes_length[i] + 1];\n  MPI_Bcast(buffer, genes_length[i], MPI_CHAR, root, comm);\n  buffer[genes_length[i]] = '\\0';\n  genes[i] = string(buffer, genes_length[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/5"}
{"code": "for (p = 0; p < M; p++)\n{\n  temp[(1 * M) + p] = Board(0, p);\n  temp2[(1 * M) + p] = Board(N - 1, p);\n}\n\n", "pragma": "omp parallel for private(p) shared(temp,board) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/2"}
{"code": "for (i = 0; i < nsites; i++)\n{\n  for (k = 0; k < nfields; k++)\n  {\n    tmpbuf2[(k * nsites) + i] = tmpbuf[(i * nfields) + k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/Ludwig/targetDP/targetDP_C/7"}
{"code": "for (bid = 0; bid < count; bid++)\n{\n  for (i = 0; i < maxheight; i++)\n  {\n    for (thid = 0; thid < threadsPerBlock; thid++)\n    {\n      if ((knodes[currKnode[bid]].keys[thid] <= start[bid]) && (knodes[currKnode[bid]].keys[thid + 1] > start[bid]))\n      {\n        if (knodes[currKnode[bid]].indices[thid] < knodes_elem)\n        {\n          offset[bid] = knodes[currKnode[bid]].indices[thid];\n        }\n\n      }\n\n      if ((knodes[lastKnode[bid]].keys[thid] <= end[bid]) && (knodes[lastKnode[bid]].keys[thid + 1] > end[bid]))\n      {\n        if (knodes[lastKnode[bid]].indices[thid] < knodes_elem)\n        {\n          offset_2[bid] = knodes[lastKnode[bid]].indices[thid];\n        }\n\n      }\n\n    }\n\n    currKnode[bid] = offset[bid];\n    lastKnode[bid] = offset_2[bid];\n  }\n\n  for (thid = 0; thid < threadsPerBlock; thid++)\n  {\n    if (knodes[currKnode[bid]].keys[thid] == start[bid])\n    {\n      recstart[bid] = knodes[currKnode[bid]].indices[thid];\n    }\n\n  }\n\n  for (thid = 0; thid < threadsPerBlock; thid++)\n  {\n    if (knodes[lastKnode[bid]].keys[thid] == end[bid])\n    {\n      reclength[bid] = (knodes[lastKnode[bid]].indices[thid] - recstart[bid]) + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i, thid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/openmp/b+tree/kernel/kernel_cpu_2/0"}
{"code": "for (i = 0; i < dimensions; i++)\n{\n  distance += (p1->coordinates[i] - p2->coordinates[i]) * (p1->coordinates[i] - p2->coordinates[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/12"}
{"code": "for (unsigned int u = 0; u < m_uNumberOfGridPoints1D; ++u)\n{\n  m_gridHeat[u][0] = 0.0;\n  m_gridHeat[u][m_uNumberOfGridPoints1D - 1] = 0.0;\n  m_gridHeat[0][u] = 0.0;\n  m_gridHeat[m_uNumberOfGridPoints1D - 1][u] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/schdomin/diffusion_openmp/src/CDomain/5"}
{"code": "for (int i = 0; i < 10; ++i)\n  rand();\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BloodyRainRage/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (j_imopVarPre84 = 1; j_imopVarPre84 <= (naa + 1); j_imopVarPre84++)\n{\n  q[j_imopVarPre84] = 0.0;\n  z[j_imopVarPre84] = 0.0;\n  r[j_imopVarPre84] = x[j_imopVarPre84];\n  p[j_imopVarPre84] = r[j_imopVarPre84];\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  scanf(\"%d\", &a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment1/lab1_10/0"}
{"code": "for (int i = 0; i < grid_size; i++)\n{\n  adjacent_cells[i] = &adjacent_cells_rows[i * grid_size];\n  for (int j = 0; j < grid_size; j++)\n  {\n    adjacent_cells[i][j] = &adjacent_cells_chunk[((i * grid_size) + j) * ADJACENT_CELLS_NUMBER];\n    int index_adjacent_cells = 0;\n    cell_t **adjacent_cell = adjacent_cells[i][j];\n    for (int x = -1; x <= 1; x++)\n    {\n      for (int y = -1; y <= 1; y++)\n      {\n        adjacent_cell[index_adjacent_cells] = &cells_threads[0][((i + x) + grid_size) % grid_size][((j + y) + grid_size) % grid_size];\n        index_adjacent_cells++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/openmp/simpar-omp/5"}
{"code": "for (i = 0; i < size; i++)\n  if (vec[i] < minValue)\n  minValue = vec[i];\n\n\n", "pragma": "omp parallel for reduction(min:minValue)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AdoniasAlcantara/project4-omp/src/parallel/1"}
{"code": "for (unsigned i = 0; i < num_h_neurons; ++i)\n{\n  for (unsigned j = 0; j < num_v_neurons; ++j)\n  {\n    modelRBM.dW.at(i).at(j) = modelRBM.dW.at(i).at(j) + (((dataRBM.H[i] * dataRBM.V[j]) - (modelRBM.Hp[i] * modelRBM.Vp[j])) / (1E-8 + RATE));\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/15"}
{"code": "for (int j = i; j < result2.width; j++)\n{\n  tmpSumLocal += tmp2.data[i][j] * result2.data[0][j];\n}\n\n", "pragma": "            #pragma omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PiotrMydlowski/Gauss-Elimination/main/5"}
{"code": "for (int row = 0; row < n; row++)\n{\n  for (int col = 0; col < ms; col++)\n    row_mult_col(arr1, arr2, m, row, col, res);\n\n}\n\n", "pragma": "omp parallel for shared(res)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  prod *= arr[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niteshmrh/OpenMP-program-to-demonstrate-the-use-of-for-clause./parallelSum/2"}
{"code": "for (int i = 0; i < point_count; i++)\n  clustered_pnts_mask[i] = 0;\n\n", "pragma": "#pragma omp target teams distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qtclustering-omp/QTC/1"}
{"code": "for (i = 0; i < 2400; i++)\n{\n  for (j = 0; j < 2400; j++)\n  {\n    if (percentDiff(C[(i * 2400) + j], C_outputFromGpu[(i * 2400) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/9"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    a[i][j] = random() % 10;\n    b[i][j] = random() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/matrix_sum/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  xcrdif[m] = fabs((xcr[m] - xcrref[m]) / xcrref[m]);\n  xcedif[m] = fabs((xce[m] - xceref[m]) / xceref[m]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/58"}
{"code": "for (int i = 0; i <= N; i++)\n  if (log_file)\n  fprintf(log_file, \"%d - Z %g dZ %g\\n\", i, Z[i], dL[i]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/50"}
{"code": "for (int j = 0; j < (width * gray_channels); j += gray_channels)\n{\n  unsigned char *dir_sobel_pixel = (sobel_img + (i * width)) + j;\n  unsigned char *dir_gray_pixel = (gray_img + (i * width)) + j;\n  int sum = 0;\n  if ((((i == 0) || (i == ((height - 1) * gray_channels))) || (j == 0)) || (j == ((width - 1) * gray_channels)))\n  {\n    *dir_sobel_pixel = (uint8_t) sum;\n  }\n  else\n  {\n    for (int k = -1; k <= 1; ++k)\n    {\n      for (int l = -1; l <= 1; ++l)\n      {\n        unsigned char *dir_n_pixel = (dir_gray_pixel + (k * width)) + l;\n        sum += (*dir_n_pixel) * conv[k + 1][l + 1];\n      }\n\n    }\n\n    sum = (sum < 0) ? (0) : (sum);\n    *dir_sobel_pixel = (uint8_t) sum;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlejandroUN/ParallelComputing/omp/sobel/sobel_image_test_omp/1"}
{"code": "for (i = 0; i < n_images; i++)\n{\n  if (g->SavedImages[i].ImageDesc.ColorMap)\n  {\n    fprintf(stderr, \"Error: application does not support local colormap\\n\");\n    ok = 0;\n    if (ok)\n      colmap = g->SavedImages[i].ImageDesc.ColorMap;\n\n  }\n\n  for (j = 0; (j < (width[i] * height[i])) && ok; j++)\n  {\n    int c;\n    c = g->SavedImages[i].RasterBits[j];\n    p[i][j].r = colmap->Colors[c].Red;\n    p[i][j].g = colmap->Colors[c].Green;\n    p[i][j].b = colmap->Colors[c].Blue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/load_pixels/2"}
{"code": "for (uint i = 0; i < nBonds; ++i)\n{\n  GenerateAnglesNew(newMol, molIndex, angleKinds[i][i], nTrials, i);\n  double stepWeight = accumulate(data->angleWeights, data->angleWeights + nTrials, 0.0);\n  uint winner = data->prng.PickWeighted(data->angleWeights, nTrials, stepWeight);\n  theta[i] = data->angles[winner];\n  bendEnergy += data->angleEnergy[winner];\n  oneThree += data->nonbonded_1_3[winner];\n  thetaWeight[i] = stepWeight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedron/8"}
{"code": "for (i = 0; i < n1; i++)\n{\n  for (j = 0; j < m2; j++)\n  {\n    res[i][j] = 0;\n    for (k = 0; k < m1; k++)\n    {\n      res[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/matrix/matrix/5"}
{"code": "for (int i = 0; i < len; ++i)\n{\n  if (currentWeek[i / size][i % size] == k)\n  {\n    sum = sum + 1;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/15"}
{"code": "for (int i = 0; i < Rh.size(); i++)\n{\n  for (int j = 0; j < Rh[0].size(); j++)\n  {\n    Rh[i][j] = Rh_temp[k];\n    k++;\n  }\n\n}\n\n", "pragma": "    \t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_4_final/6"}
{"code": "for (int j = 1 << l; j < step_max; j++)\n{\n  tablo->tab[2 * j] = tablo->tab[(2 * j) + 1] + tablo->tab[j];\n  tablo->tab[(2 * j) + 1] = tablo->tab[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/8"}
{"code": "for (i = splitPoint; i < num_particles; i++)\n{\n  child.person[i].x_pos = parentTwo.person[i].x_pos;\n  child.person[i].y_pos = parentTwo.person[i].y_pos;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/5"}
{"code": "for (i = 0; i < i_end; i++)\n{\n  Csr2_row_ptr[i] = row_ptr[i] / mtx_width;\n}\n\n", "pragma": "                #pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nulidangxueshen/CSR2/CSR2_SPMV/2"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (i = ist; i <= iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n    }\n\n  }\n\n  L2 = nx - 1;\n  for (i = ist; i <= L2; i++)\n  {\n    tmp = 1.0 / u[i][j][k][0];\n    u21i = tmp * u[i][j][k][1];\n    u31i = tmp * u[i][j][k][2];\n    u41i = tmp * u[i][j][k][3];\n    u51i = tmp * u[i][j][k][4];\n    tmp = 1.0 / u[i - 1][j][k][0];\n    u21im1 = tmp * u[i - 1][j][k][1];\n    u31im1 = tmp * u[i - 1][j][k][2];\n    u41im1 = tmp * u[i - 1][j][k][3];\n    u51im1 = tmp * u[i - 1][j][k][4];\n    flux[i][j][k][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n    flux[i][j][k][2] = tx3 * (u31i - u31im1);\n    flux[i][j][k][3] = tx3 * (u41i - u41im1);\n    flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * (((pow2(u21i) + pow2(u31i)) + pow2(u41i)) - ((pow2(u21im1) + pow2(u31im1)) + pow2(u41im1)))) + (((1.0 / 6.0) * tx3) * (pow2(u21i) - pow2(u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n  }\n\n  for (i = ist; i <= iend; i++)\n  {\n    rsd[i][j][k][0] = rsd[i][j][k][0] + ((dx1 * tx1) * ((u[i - 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i + 1][j][k][0]));\n    rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((u[i - 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i + 1][j][k][1]));\n    rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((u[i - 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i + 1][j][k][2]));\n    rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((u[i - 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i + 1][j][k][3]));\n    rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((u[i - 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i + 1][j][k][4]));\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[1][j][k][m] = rsd[1][j][k][m] - (dssp * ((((+5.0) * u[1][j][k][m]) - (4.0 * u[2][j][k][m])) + u[3][j][k][m]));\n    rsd[2][j][k][m] = rsd[2][j][k][m] - (dssp * (((((-4.0) * u[1][j][k][m]) + (6.0 * u[2][j][k][m])) - (4.0 * u[3][j][k][m])) + u[4][j][k][m]));\n  }\n\n  ist1 = 3;\n  iend1 = nx - 4;\n  for (i = ist1; i <= iend1; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n    }\n\n  }\n\n  for (m = 0; m < 5; m++)\n  {\n    rsd[nx - 3][j][k][m] = rsd[nx - 3][j][k][m] - (dssp * (((u[nx - 5][j][k][m] - (4.0 * u[nx - 4][j][k][m])) + (6.0 * u[nx - 3][j][k][m])) - (4.0 * u[nx - 2][j][k][m])));\n    rsd[nx - 2][j][k][m] = rsd[nx - 2][j][k][m] - (dssp * ((u[nx - 4][j][k][m] - (4.0 * u[nx - 3][j][k][m])) + (5.0 * u[nx - 2][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, u21i, u31i, u41i, u51i, u21im1, u31im1, u41im1, u51im1, ist1, iend1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/38"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericContinuumParticles[i]->MarkNewSkinParticlesDueToBreakage();\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/2"}
{"code": "for (int i = 0; i < 100; i++)\n  if (a[i] != (((-1) + i) + (2 * i)))\n{\n  printf(\"Error at %d: device = %d, host = %d\\n\", i, a[i], ((-1) + i) + (2 * i));\n  fail = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/4"}
{"code": "for (j = 1; j < (64 - 1); ++j)\n{\n  for (i = 1; i < (64 - 1); ++i)\n  {\n    int k;\n    for (k = 1; k < (64 - 1); ++k)\n    {\n      B[((i * (64 * 64)) + (j * 64)) + k] = ((((((((((((((c11 * A[(((i - 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)]) + (c13 * A[(((i + 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)])) + (c21 * A[(((i - 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)])) + (c23 * A[(((i + 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)])) + (c31 * A[(((i - 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)])) + (c33 * A[(((i + 1) * (64 * 64)) + ((j - 1) * 64)) + (k - 1)])) + (c12 * A[(((i + 0) * (64 * 64)) + ((j - 1) * 64)) + (k + 0)])) + (c22 * A[(((i + 0) * (64 * 64)) + ((j + 0) * 64)) + (k + 0)])) + (c32 * A[(((i + 0) * (64 * 64)) + ((j + 1) * 64)) + (k + 0)])) + (c11 * A[(((i - 1) * (64 * 64)) + ((j - 1) * 64)) + (k + 1)])) + (c13 * A[(((i + 1) * (64 * 64)) + ((j - 1) * 64)) + (k + 1)])) + (c21 * A[(((i - 1) * (64 * 64)) + ((j + 0) * 64)) + (k + 1)])) + (c23 * A[(((i + 1) * (64 * 64)) + ((j + 0) * 64)) + (k + 1)])) + (c31 * A[(((i - 1) * (64 * 64)) + ((j + 1) * 64)) + (k + 1)])) + (c33 * A[(((i + 1) * (64 * 64)) + ((j + 1) * 64)) + (k + 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3DCONV/3DConvolution/9"}
{"code": "for (unsigned int i = 0; i < prtls->number; i++)\n{\n  unsigned int r_i = CELL_NUMBER(prtls->pos[i][0], geom->dr);\n  unsigned int z_k = CELL_NUMBER(prtls->pos[i][2], geom->dz);\n  vel_r = prtls->vel[i][0];\n  vel_phi = prtls->vel[i][1];\n  vel_z = prtls->vel[i][2];\n  vel = sq_rt(((vel_r * vel_r) + (vel_phi * vel_phi)) + (vel_z * vel_z));\n  inc_tmpr(r_i, z_k, vel);\n  inc_vec_r(r_i, z_k, vel_r);\n  inc_vec_phi(r_i, z_k, vel_phi);\n  inc_vec_z(r_i, z_k, vel_z);\n  inc_count(r_i, z_k, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/temperatureClassic/1"}
{"code": "for (size_t i = size - sample_length; i < size; i++)\n  printf(\"%g \", tab[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fritschnils/tp-parallelisation/tp2/tp2_3_enumeration_sort/6"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  for (h = 0; h < n; h++)\n{\n  resultado[i][j] += m1[i][h] * m1[h][j];\n}\n\n\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp3/ejer9/pmm-OpenMP/1"}
{"code": "for (i = 0; i < nd; i++)\n{\n  last_x1[i] = x1[i];\n  x1[i] = 0;\n}\n\n", "pragma": "omp parallel for default(none) shared(x1,last_x1,nd) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/girihemant19/Pagerank-serial-C-and-parallel-openMp-/pagerank_openMp/6"}
{"code": "for (i = BLOWFISH_ROUNDS + 1; i > 1; --i)\n{\n  Xl = Xl ^ P[i];\n  Xr = F(S, Xl) ^ Xr;\n  temp = Xl;\n  Xl = Xr;\n  Xr = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zagorskid/blowfish-omp/blowfish-omp/blowfish-omp/1"}
{"code": "for (xv_it = xv_in->begin(); xv_it != xv_in->end(); ++xv_it)\n{\n  n += xv_it->second * xv_it->second;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/2"}
{"code": "for (i = 0; i < length_of_array; i++)\n{\n  sum_of_sqrd_a_a_bar += (a[i] - mean_of_a) * (a[i] - mean_of_a);\n  sum_of_sqrd_b_b_bar += (b[i] - mean_of_b) * (b[i] - mean_of_b);\n  sum_of_a_times_b += (a[i] - mean_of_a) * (b[i] - mean_of_b);\n}\n\n", "pragma": "omp parallel for default(none) shared(length_of_array, a, mean_of_a, b, mean_of_b) private(i) reduction(+:sum_of_sqrd_a_a_bar, sum_of_sqrd_b_b_bar, sum_of_a_times_b)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luketowell/openMP_PCC/parallel/parallel-pinit-mean/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  D[0][i] = (t[i] == a[0]) ? (1) : (0);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranshumaheshwari/Parallel-String-Matching/parallel_shift_and/1"}
{"code": "for (i = observrows - 1; i > 0; i--)\n{\n  if (i != 1)\n  {\n    findPath[end] = parent;\n    end--;\n    parent = trellis[i - 1][parent].parent;\n  }\n  else\n  {\n    parent = trellis[i][parent].parent;\n    findPath[end] = parent;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/22"}
{"code": "for (i = 2; i < (N - 2); ++i)\n{\n  cur[i] = ((((prev[i - 2] + prev[i - 1]) + prev[i]) + prev[i + 1]) + prev[i + 2]) / 5;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshtburris/CS-475-PA1/stencil_1D/0"}
{"code": "for (i = 0; i < (len - 1); i++)\n  task(&a[0], i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB114-if-orig-yes/0"}
{"code": "for (i = 0; i < Core_N; i++)\n{\n  CoreTensor[i] = frand(0, 1);\n  if (i == 0)\n  {\n    for (j = 0; j < order; j++)\n      CorePermu[j] = 0;\n\n  }\n  else\n  {\n    for (j = 0; j < order; j++)\n    {\n      CorePermu[(i * order) + j] = CorePermu[((i - 1) * order) + j];\n    }\n\n    CorePermu[((i * order) + order) - 1]++;\n    k = order - 1;\n    while (CorePermu[(i * order) + k] >= Core_size[k])\n    {\n      CorePermu[(i * order) + k] -= Core_size[k];\n      CorePermu[((i * order) + k) - 1]++;\n      k--;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/9"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  for (int j = 0; j < cols; ++j)\n  {\n    res_vec[i] += mat[i][j] * vec[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/matrice_vector/src/main/2"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  totalEdgeWeightTwice += vDegree[i];\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:totalEdgeWeightTwice)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusteringFunctions/1"}
{"code": "for (i = 0; i < 1536; i++)\n{\n  for (j = 0; j < 1536; j++)\n  {\n    for (k = 0; k < 1536; k++)\n    {\n      C[(i * 1536) + j] += (12435 * A[(i * 1536) + k]) * B[(j * 1536) + k];\n      C[(i * 1536) + j] += (12435 * B[(i * 1536) + k]) * A[(j * 1536) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYR2K/syr2k_cpu/0"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  {\n    x++;\n  }\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB110-ordered-orig-no/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    D[(i * M) + j] *= beta;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk/4"}
{"code": "for (i = 0; i < len; i++)\n  printf(\"%d\\n\", a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB002-antidep1-var-yes/0"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  if ((score_new[i] - solution[i]) < 0.0)\n  {\n    global_diff -= score_new[i] - solution[i];\n  }\n  else\n  {\n    global_diff += score_new[i] - solution[i];\n  }\n\n  solution[i] = score_new[i];\n  score_new[i] = 0.0;\n}\n\n", "pragma": "        #pragma omp for reduction(+:global_diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank/page_rank/1"}
{"code": "for (b = 0; b < iter; b++)\n{\n  printf(\"imprimindo valor de b: %d \\n\", b);\n  matriz_seq(A, B, C);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/7"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%d \", numNeigh[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/104"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double temp = 0;\n    for (int k = 0; k < N; ++k)\n    {\n      temp += a[(i * N) + k] * b[(k * N) + j];\n    }\n\n    c[(i * N) + j] = temp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(ThreadNumber)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZeyuuOne/Lab_1_OpenMP/Lab_1_OpenMP/main/1"}
{"code": "for (i = 1; i < M; i++)\n{\n  mark[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA2/sieve2/0"}
{"code": "for (i = 0; i <= (public.allPoints - 1); i += 1)\n{\n  private[i].d_in_mod = (float *) malloc(public.in_mod_mem);\n  private[i].d_in_sqr = (float *) malloc(public.in_mod_mem);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/5"}
{"code": "for (int y = 0; y < dim_y; y++)\n{\n  for (int x = 0; x < dim_x; x++)\n  {\n    omp_init_lock(&costs->board[(y * dim_y) + x].lock);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/5"}
{"code": "for (i = tid; i < dataSizeY; i += numthreads)\n{\n  rowMax = i + kCenterY;\n  rowMin = (i - dataSizeY) + kCenterY;\n  for (j = 0; j < dataSizeX; ++j)\n  {\n    colMax = j + kCenterX;\n    colMin = (j - dataSizeX) + kCenterX;\n    sum = 0;\n    for (m = 0; m < kernelSizeY; ++m)\n    {\n      if ((m <= rowMax) && (m > rowMin))\n      {\n        for (n = 0; n < kernelSizeX; ++n)\n        {\n          if ((n <= colMax) && (n > colMin))\n            sum += (*(inPtr - n)) * (*kPtr);\n\n          ++kPtr;\n        }\n\n      }\n      else\n        kPtr += kernelSizeX;\n\n      inPtr -= dataSizeX;\n    }\n\n    if (sum >= 0)\n      *outPtr = (int) (sum + 0.5f);\n    else\n      *outPtr = (int) (sum - 0.5f);\n\n    kPtr = kernel;\n    inPtr2 = inPtr2 + numthreads;\n    inPtr = inPtr2;\n    outPtr = outPtr + numthreads;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/malerax213/OpenMP-Project/convolution/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  vet[i] = a[i][i];\n}\n\n", "pragma": "omp parellel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/Esercizio1/0"}
{"code": "for (int k = 0; k < n; k += 2 * level)\n{\n  int initial = k;\n  int center = k + (level - 1);\n  int rear = k + ((2 * level) - 1);\n  if (center >= n)\n  {\n    center = ((k + n) - 1) / 2;\n    rear = n - 1;\n  }\n  else\n    if (rear >= n)\n  {\n    rear = n - 1;\n  }\n\n\n  merge(arr, initial, center, rear);\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/mergesort/mergesort/2"}
{"code": "for (t = 0; t < 1000; t++)\n{\n  for (j = 0; j < 4096; j++)\n  {\n    ey[(0 * 4096) + j] = _fict_[t];\n  }\n\n  for (i = 1; i < 4096; i++)\n  {\n    for (j = 0; j < 4096; j++)\n    {\n      ey[(i * 4096) + j] = ey[(i * 4096) + j] - (0.5 * (hz[(i * 4096) + j] - hz[((i - 1) * 4096) + j]));\n    }\n\n  }\n\n  for (i = 0; i < 4096; i++)\n  {\n    for (j = 1; j < 4096; j++)\n    {\n      ex[(i * (4096 + 1)) + j] = ex[(i * (4096 + 1)) + j] - (0.5 * (hz[(i * 4096) + j] - hz[(i * 4096) + (j - 1)]));\n    }\n\n  }\n\n  for (i = 0; i < 4096; i++)\n  {\n    for (j = 0; j < 4096; j++)\n    {\n      hz[(i * 4096) + j] = hz[(i * 4096) + j] - (0.7 * (((ex[(i * (4096 + 1)) + (j + 1)] - ex[(i * (4096 + 1)) + j]) + ey[((i + 1) * 4096) + j]) - ey[(i * 4096) + j]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/FDTD-2D/fdtd2d_cpu/8"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  zeta = ((double) k) * dnzm1;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    eta = ((double) j) * dnym1;\n    for (i = 0; i <= (grid_points[0] - 1); i++)\n    {\n      xi = ((double) i) * dnxm1;\n      exact_solution(xi, eta, zeta, dtemp);\n      for (m = 0; m < 5; m++)\n      {\n        ue[m][i] = dtemp[m];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m = 1; m < 5; m++)\n      {\n        buf[m][i] = dtpp * dtemp[m];\n      }\n\n      cuf[i] = buf[1][i] * buf[1][i];\n      buf[0][i] = (cuf[i] + (buf[2][i] * buf[2][i])) + (buf[3][i] * buf[3][i]);\n      q[i] = 0.5 * (((buf[1][i] * ue[1][i]) + (buf[2][i] * ue[2][i])) + (buf[3][i] * ue[3][i]));\n    }\n\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      im1 = i - 1;\n      ip1 = i + 1;\n      forcing[k][j][i][0] = (forcing[k][j][i][0] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n      forcing[k][j][i][1] = ((forcing[k][j][i][1] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n      forcing[k][j][i][2] = ((forcing[k][j][i][2] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n      forcing[k][j][i][3] = ((forcing[k][j][i][3] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n      forcing[k][j][i][4] = ((((forcing[k][j][i][4] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = 1;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((5.0 * ue[m][i]) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      i = 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((((-4.0) * ue[m][i - 1]) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n    }\n\n    for (i = 3; i <= (grid_points[0] - 4); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      i = grid_points[0] - 3;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * (((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])));\n      i = grid_points[0] - 2;\n      forcing[k][j][i][m] = forcing[k][j][i][m] - (dssp * ((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (5.0 * ue[m][i])));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/19"}
{"code": "for (int i = 1; i < 4; i++)\n{\n  (cout << \",\") << mean[index].elements[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/5"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_bitonic_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bitonicsort/5"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  if (a[i] < min)\n    min = a[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/3"}
{"code": "for (size_t j = 0; j < arg_len; j++)\n  printf(\"%zu, \", ((size_t *) dimensions)[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Python-for-HPC/numbaWithOpenmp/numba/np/ufunc/omppool/0"}
{"code": "for (lev = nlev; lev >= 0; lev--)\n{\n  relax(phi[lev], res[lev], lev, n_per_lev, p);\n  if (lev > 0)\n    inter_add(phi[lev - 1], phi[lev], lev, p);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/serial_mg/1"}
{"code": "for (int i = 0; i < w; i++)\n{\n  for (int j = 0; j < h; j++)\n  {\n    if (fabs(sequential[i][j] - parallel[i][j]) > ACCURACY)\n    {\n      failed = 1;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/za_predaju/dz1z4/3"}
{"code": "for (i = iLeft; i <= iRightTemp; i++)\n{\n  for (j = 1; j <= jmax; j++)\n  {\n    if ((flag[i][j] & C_F) && (flag[i + 1][j] & C_F))\n    {\n      du2dx = (((((u[i][j] + u[i + 1][j]) * (u[i][j] + u[i + 1][j])) + ((gamma * fabs(u[i][j] + u[i + 1][j])) * (u[i][j] - u[i + 1][j]))) - ((u[i - 1][j] + u[i][j]) * (u[i - 1][j] + u[i][j]))) - ((gamma * fabs(u[i - 1][j] + u[i][j])) * (u[i - 1][j] - u[i][j]))) / (4.0 * delx);\n      duvdy = (((((v[i][j] + v[i + 1][j]) * (u[i][j] + u[i][j + 1])) + ((gamma * fabs(v[i][j] + v[i + 1][j])) * (u[i][j] - u[i][j + 1]))) - ((v[i][j - 1] + v[i + 1][j - 1]) * (u[i][j - 1] + u[i][j]))) - ((gamma * fabs(v[i][j - 1] + v[i + 1][j - 1])) * (u[i][j - 1] - u[i][j]))) / (4.0 * dely);\n      laplu = ((((u[i + 1][j] - (2.0 * u[i][j])) + u[i - 1][j]) / delx) / delx) + ((((u[i][j + 1] - (2.0 * u[i][j])) + u[i][j - 1]) / dely) / dely);\n      f[i][j] = u[i][j] + (del_t * (((laplu / Re) - du2dx) - duvdy));\n    }\n    else\n    {\n      f[i][j] = u[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(du2dx,duvdy,laplu)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chigbojk/CS922-High-Performance-Computing-Assignment-2/cfd/simulation/0"}
{"code": "for (int i = 0; i < 2000000; i++)\n{\n  if (isprime(i) == 1)\n  {\n    tmpsum += i;\n  }\n\n  if ((i % 50000) == 0)\n  {\n    printf(\"we are at this point %d id :: %d\\n\", i, omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex10projecteuler/0"}
{"code": "for (i = k1; i >= j1; --i)\n{\n  if ((i < j2) || (i > k2))\n    ++e;\n\n  ++c;\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr29947-1/1"}
{"code": "for (i = 0; i < ni; i++)\n  for (j = 0; j < nj; j++)\n{\n  C[i][j] = (((DATA_TYPE) i) * j) / ni;\n  B[i][j] = (((DATA_TYPE) i) * j) / ni;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/symm/symm/1"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  vaik = _mm256_set1_ps(a[i][k]);\n  t2 = a[i][k];\n  for (j = k + 1; (j + 8) < n; j += 8)\n  {\n    vakj = _mm256_loadu_ps(&a[k][j]);\n    vaij = _mm256_loadu_ps(&a[i][j]);\n    vx = _mm256_mul_ps(vakj, vaik);\n    vaij = _mm256_sub_ps(vaij, vx);\n    _mm256_storeu_ps(&a[i][j], vaij);\n  }\n\n  for (j; j < n; j++)\n  {\n    a[i][j] -= t2 * a[k][j];\n  }\n\n  a[i][k] = 0;\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_x86_linux/0"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  A[i][j] = relu_prime(A[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/10"}
{"code": "for (i = 0; i < NoofCols; i = i + 1)\n  for (j = 0; j < NoofRows; j = j + 1)\n  if (Checkoutput[i][j] == Trans[i][j])\n  continue;\nelse\n{\n  printf(\"There Is A Difference From Serial And Parallel Calculation \\n\");\n  exit(1);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/4"}
{"code": "for (int ii = 1; ii < nR; ++ii)\n{\n  real_t r = x0 + (ii * dR);\n  buf[ii] /= r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task/eam/5"}
{"code": "for (size_t i = 0; i < k; i++)\n{\n  *((*bloc1) + i) = *(new_bloc + i);\n  *((*bloc2) + i) = *((new_bloc + i) + k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/7"}
{"code": "for (i = middle_filter; i < core_matrix; i++)\n{\n  for (j = middle_filter; j < core_matrix; j++)\n  {\n    sum = 0;\n    for (p = 0; p < s_filter; p++)\n    {\n      for (q = 0; q < s_filter; q++)\n      {\n        sum += filter[p][q] * matrix_o[(i - middle_filter) + p][(j - middle_filter) + q];\n      }\n\n    }\n\n    matrix_d[i][j] = sum / complete_filter;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ichaparroc/convolution-matrix-filter-openmp/convolution-2/0"}
{"code": "for (int i = batch_start; i < batch_end; i++)\n{\n  int column_index = x_col_array[i];\n  for (int k = 0; k < K_count; ++k)\n  {\n    R_table_ind[(i * K_count) + k] = R_table[(column_index * K_count) + k];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gthparch/stale_workload/MAT_FACT/kernel/0"}
{"code": "for (n = 0; n < Nmat; n++)\n  b = b / (1.f + (delta * L[n]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/8"}
{"code": "for (i = 0; i < 3072; i++)\n{\n  for (j = 0; j < 3072; j++)\n  {\n    C[(i * 3072) + j] = ((((DATA_TYPE) i) * j) + 2) / 3072;\n    C_OMP[(i * 3072) + j] = ((((DATA_TYPE) i) * j) + 2) / 3072;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/GEMM/gemm_cpu/7"}
{"code": "for (int j = 0; j < COLUMNS; j++)\n  for (int k = 0; k < COLUMNS; k++)\n  for (int i = 0; i < ROWS; i++)\n  matrix_r[i][j] += matrix_a[i][k] * matrix_b[k][j];\n\n\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Piotrekf3/PR---OpenMP/ProjektPR/Main/5"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < len; j++)\n    u[i][j] = 0.5;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB021-reductionmissing-orig-yes/0"}
{"code": "for (int i = 0; i < N2; i++)\n{\n  for (int j = 0; j < N2; j++)\n  {\n    (cout << table[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnstephenson39/gameoflife_openmp/gol/0"}
{"code": "for (; (p < Size) && (InitData32[p - 1] <= InitData32[p]); p++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/16"}
{"code": "for (i = 0; i < 100; i++)\n{\n  index[i] = i % 5;\n  y[i] = index[i] / 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/OpenMP/atomic/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  if (0 != e[i])\n  {\n    for (j = 0; j < n; j++)\n    {\n      v[j] = v[j] * pow(x[i + (j * m)], e[i]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task2_simplex/simplex_modified_for_omp/simplex/3"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  r[i] = i * 3.14159;\n  for (j = 0; j < 8192; j++)\n  {\n    A[(i * 8192) + j] = (((DATA_TYPE) i) * j) / 8192;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/BICG/src/bicg/0"}
{"code": "for (int i = 0; i < POP_SIZE; i++)\n{\n  if (population[i].fitness > maxFitness)\n  {\n    maxFitness = population[i].fitness;\n    bestGenes = population[i].genes;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Storn5/genetic-parallelization/GeneticAlgorithms/ParallelOpenMP/ParallelOpenMP/7"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  put = put_price(vars[i][0], vars[i][1], vars[i][2], vars[i][3], vars[i][4]);\n  if (minPut > put)\n    minPut = put;\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(min: minPut)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JHeisey/Option-Pricer/optionPriceOpenMP/2"}
{"code": "for (int i = 0; i < (arr->size() / 2); i++)\n{\n  T temp = (*arr)[i];\n  (*arr)[i] = (*arr)[(arr->size() - 1) - i];\n  (*arr)[(arr->size() - 1) - i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/melugoyal/parallel_sort/psort/1"}
{"code": "for (int r = 0; r < bmp->height; r++)\n{\n  for (int c = 0; c < bmp->width; c++)\n  {\n    bmp->pixels[(r * bmp->width) + c].r = 255 - bmp->copy_pixels[(r * bmp->width) + c].r;\n    bmp->pixels[(r * bmp->width) + c].g = 255 - bmp->copy_pixels[(r * bmp->width) + c].g;\n    bmp->pixels[(r * bmp->width) + c].b = 255 - bmp->copy_pixels[(r * bmp->width) + c].b;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Victohu1/ParallelImageProcessor/openmp_image_processor/2"}
{"code": "for (int i = 0; i <= (20 + 1); i++)\n{\n  for (int j = 0; j <= (20 + 1); j++)\n  {\n    if ((((i == 0) || (j == 0)) || (i == (20 + 1))) || (j == (20 + 1)))\n      x[i][j] = 0;\n    else\n      x[i][j] = input[i - 1][j - 1];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gokaytitrek/openmp-gameoflife/main/3"}
{"code": "for (size_t i = 0; i < pixVol; i++)\n  h_pVolume[i] = ((double) rand()) / ((double) RAND_MAX);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/17"}
{"code": "for (int i = 0; i < nProcessors; i++)\n{\n  sum[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/Proj/ompdice/6"}
{"code": "for (i = 1; i < tam; ++i)\n{\n  vet[i] = rand() % 32767;\n  if ((*max) < vet[i])\n  {\n    *max = vet[i];\n  }\n\n  if ((*min) > vet[i])\n  {\n    *min = vet[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeovanaS/Concurrent-Programming/bucketOpenmp/2"}
{"code": "for (c1 = nk; c1 <= (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nk; c2 <= (((nl + (-1)) < (nm + (-1))) ? (nl + (-1)) : (nm + (-1))); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nk > nl) ? (nk) : (nl); c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/10"}
{"code": "for (int i = 0; i < vertSeamCount; i++)\n{\n  energyAlg(imageMap, energyMap, width, height);\n  GenerateCumalativeEnergyMap(energyMap, width, height);\n  RemoveVertSeam(imageMap, energyMap, width, height);\n  --width;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tjp77/Seam-Carver/Seam Carver/0"}
{"code": "for (int i = 0; i < 8; ++i)\n{\n  sleep_for(seconds(1));\n  fprintf(stdout, \"counter = %d, thread id = %d\\n\", increment_counter(), omp_get_thread_num());\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/13"}
{"code": "for (k = 0; k < (chunksize / 2); k++)\n{\n  fscanf(file, \"%d\", &temp);\n  for (j = 0; j < Number_Subjects; j++)\n  {\n    fscanf(file, \"%lf\", &doc[k][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/7"}
{"code": "for (i = 0; i < (point.k - 1); i++)\n  printf(\"%f \", point.inputs[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorelShoshany/Perceptron-Algorithm/hw4/work/0"}
{"code": "for (int i = 0; i <= lastNode; i++)\n{\n  if (finalDepth[i] != (-10000))\n    ((((cout << \"Node # \") << i) << \" Depth : \") << finalDepth[i]) << endl;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac3/EulerTour_EREW_OpenMP/4"}
{"code": "for (int i = 0; i < m->order; i++)\n{\n  for (int j = 0; j < m->order; j++)\n  {\n    temp[i][j] = FindElement_Inverse_O(m, i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(m->order)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/experiment-6/MatrixInverse_Parallel_Omp1/0"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n  work_buff[key_buff_ptr2[i]]++;\n\n", "pragma": "        #pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/14"}
{"code": "for (int j = (y1 + n1) + 1; j < (y2 + 1); ++j)\n{\n  for (int i = x1; i < ((x1 + n1) + 1); ++i)\n  {\n    mRes[i - x1] = 0;\n    for (int k = 0; k < (n1 + 1); ++k)\n    {\n      mRes[i - x1] += ((-1) * Mat[i][y1 + k]) * Mat[x1 + k][j];\n    }\n\n  }\n\n  for (int l = 0; l < (n1 + 1); ++l)\n  {\n    Mat[x1 + l][j] = mRes[l];\n  }\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thesaurabhkumar/ParallelInverseUpperTriangleMatrixOpenMP/inverse/5"}
{"code": "for (int i = 0; i < min(g->n, omp_get_num_threads()); i++)\n{\n  int startVx;\n  int endVx;\n  if (g->n < omp_get_num_threads())\n  {\n    startVx = i;\n    endVx = i + 1;\n  }\n  else\n  {\n    int gap = g->n / omp_get_num_threads();\n    startVx = i * gap;\n    endVx = startVx + gap;\n    if (i == (omp_get_num_threads() - 1))\n    {\n      endVx = g->n;\n    }\n\n  }\n\n  while (netFlowOutS != netFlowInT)\n  {\n    for (int u = startVx; u < endVx; u++)\n    {\n      if ((u == s) || (u == t))\n        continue;\n\n      while (excessFlow[u] > 0)\n      {\n        int curExcess = excessFlow[u];\n        int curLowestNeighbor = -1;\n        int neighborMinHeight = max();\n        for (int v = 0; v < g->n; v++)\n        {\n          if (u == v)\n            continue;\n\n          if (residualFlow[IDX(u, v, g->n)] > 0)\n          {\n            int tempHeight = height[v];\n            if (tempHeight < neighborMinHeight)\n            {\n              curLowestNeighbor = v;\n              neighborMinHeight = tempHeight;\n            }\n\n          }\n\n        }\n\n        if (height[u] > neighborMinHeight)\n        {\n          int delta = min(curExcess, residualFlow[IDX(u, curLowestNeighbor, g->n)]);\n          __sync_fetch_and_add(&residualFlow[IDX(u, curLowestNeighbor, g->n)], -delta);\n          __sync_fetch_and_add(&residualFlow[IDX(curLowestNeighbor, u, g->n)], delta);\n          __sync_fetch_and_add(&excessFlow[u], -delta);\n          __sync_fetch_and_add(&excessFlow[curLowestNeighbor], delta);\n          if (curLowestNeighbor == s)\n          {\n            __sync_fetch_and_add(&netFlowOutS, -delta);\n          }\n          else\n            if (curLowestNeighbor == t)\n          {\n            __sync_fetch_and_add(&netFlowInT, delta);\n          }\n\n\n        }\n        else\n        {\n          height[u] = neighborMinHeight + 1;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/8"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n  a[i] = rand() % 10;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture15/globalSum_reductionClause/globalSum_reductionClause/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  swap(vect[i][0], vect[i][1]);\n}\n\n", "pragma": "\t\t\t\t#pragma omp for ordered\t\t\t\t\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/B23579/Kd-tree-implementation/Kd_tree_MPI_openmp/0"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"iter = %d, thread id = %d, out of %d c[%d] = %d\\n\", i, omp_get_thread_num(), omp_get_num_threads(), i, c[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task7/1"}
{"code": "for (int i = 0; i < (num + 2); i++)\n{\n  free(curr[i]);\n  free(next[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarpenterD/parallel-game-of-life/gofl/5"}
{"code": "for (i = 0; i < _PB_NI; i++)\n  for (j = 0; j < _PB_NJ; j++)\n{\n  tmp[i][j] = 0;\n  for (k = 0; k < _PB_NK; ++k)\n    tmp[i][j] += (alpha * A[i][k]) * B[k][j];\n\n}\n\n\n", "pragma": "omp for private (j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/2mm/2mm/0"}
{"code": "for (int ill = 0; ill < weightLength; ill++)\n{\n  Dimensions[0] = ill;\n  Dimensions[1] = nprops;\n  Dimensions[2] = numSteps;\n  Dimensions[3] = startStep;\n  Estimators->startBlock(1);\n  Estimators->accumulate(hdf_OBS_data, hdf_WGT_data, Dimensions);\n  Estimators->stopBlock(getNumberOfSamples(ill));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/ForwardWalking/FWSingleOMP/0"}
{"code": "for (i = 0; i < bands; i++)\n{\n  fprintf(report, \"Band %d : %10.5lf\\n\", i + 1, mean[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dkefalos/Spectral-Unmixing/ODM/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  b = 100;\n  d = 10;\n  printf(\"Thread %d, iteration %d: b = %d, c = %d, d = %d, m = %d\\n\", omp_get_thread_num(), i, b, c, d, m);\n  a[i] = omp_get_thread_num();\n  b = omp_get_thread_num();\n  c = omp_get_thread_num();\n  d = omp_get_thread_num();\n  m = omp_get_thread_num();\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i,b) firstprivate(c) lastprivate(d) shared(a,m) schedule(dynamic, 3) num_threads(1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jeesooxkim/parallel-programming/main/1"}
{"code": "for (j = 0; j < nn; j++)\n{\n  if (c_mat[(i * nn) + j] != 0)\n    dist_mat[(i * nn) + j] = c_mat[(i * nn) + j];\n  else\n    dist_mat[(i * nn) + j] = H_VAL;\n\n  if (i == j)\n    dist_mat[(i * nn) + j] = 0;\n\n  if ((dist_mat[(i * nn) + j] > 0) && (dist_mat[(i * nn) + j] < H_VAL))\n    pred_mat[(i * nn) + j] = i;\n\n}\n\n", "pragma": "    #pragma omp parallel for                                ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TransientObject/ParallelizeAlgos/lib/floyd_warshall/floyd/1"}
{"code": "for (int i = 0; i < m->order; i++)\n{\n  m->SquareMatrix[i] = (double *) malloc((sizeof(double)) * m->order);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/Parallel_1.0/1"}
{"code": "for (c1 = (((((((8 * c0) + ((-1) * tsteps)) + 1) * 8) < 0) ? (-((-(((8 * c0) + ((-1) * tsteps)) + 1)) / 8)) : ((8 < 0) ? ((((-(((8 * c0) + ((-1) * tsteps)) + 1)) + (-8)) - 1) / (-8)) : ((((((8 * c0) + ((-1) * tsteps)) + 1) + 8) - 1) / 8))) > ((((8 * c0) * 9) < 0) ? (-((-(8 * c0)) / 9)) : ((9 < 0) ? ((((-(8 * c0)) + (-9)) - 1) / (-9)) : ((((8 * c0) + 9) - 1) / 9)))) ? ((((((8 * c0) + ((-1) * tsteps)) + 1) * 8) < 0) ? (-((-(((8 * c0) + ((-1) * tsteps)) + 1)) / 8)) : ((8 < 0) ? ((((-(((8 * c0) + ((-1) * tsteps)) + 1)) + (-8)) - 1) / (-8)) : ((((((8 * c0) + ((-1) * tsteps)) + 1) + 8) - 1) / 8))) : ((((8 * c0) * 9) < 0) ? (-((-(8 * c0)) / 9)) : ((9 < 0) ? ((((-(8 * c0)) + (-9)) - 1) / (-9)) : ((((8 * c0) + 9) - 1) / 9))); c1 <= (((((((((n + (2 * tsteps)) + (-3)) * 2) < 0) ? ((2 < 0) ? (-((((-((n + (2 * tsteps)) + (-3))) + 2) + 1) / 2)) : (-((((-((n + (2 * tsteps)) + (-3))) + 2) - 1) / 2))) : (((n + (2 * tsteps)) + (-3)) / 2)) < ((((((16 * c0) + n) + 13) * 18) < 0) ? ((18 < 0) ? (-((((-(((16 * c0) + n) + 13)) + 18) + 1) / 18)) : (-((((-(((16 * c0) + n) + 13)) + 18) - 1) / 18))) : ((((16 * c0) + n) + 13) / 18))) ? (((((n + (2 * tsteps)) + (-3)) * 2) < 0) ? ((2 < 0) ? (-((((-((n + (2 * tsteps)) + (-3))) + 2) + 1) / 2)) : (-((((-((n + (2 * tsteps)) + (-3))) + 2) - 1) / 2))) : (((n + (2 * tsteps)) + (-3)) / 2)) : ((((((16 * c0) + n) + 13) * 18) < 0) ? ((18 < 0) ? (-((((-(((16 * c0) + n) + 13)) + 18) + 1) / 18)) : (-((((-(((16 * c0) + n) + 13)) + 18) - 1) / 18))) : ((((16 * c0) + n) + 13) / 18))) < c0) ? (((((((n + (2 * tsteps)) + (-3)) * 2) < 0) ? ((2 < 0) ? (-((((-((n + (2 * tsteps)) + (-3))) + 2) + 1) / 2)) : (-((((-((n + (2 * tsteps)) + (-3))) + 2) - 1) / 2))) : (((n + (2 * tsteps)) + (-3)) / 2)) < ((((((16 * c0) + n) + 13) * 18) < 0) ? ((18 < 0) ? (-((((-(((16 * c0) + n) + 13)) + 18) + 1) / 18)) : (-((((-(((16 * c0) + n) + 13)) + 18) - 1) / 18))) : ((((16 * c0) + n) + 13) / 18))) ? (((((n + (2 * tsteps)) + (-3)) * 2) < 0) ? ((2 < 0) ? (-((((-((n + (2 * tsteps)) + (-3))) + 2) + 1) / 2)) : (-((((-((n + (2 * tsteps)) + (-3))) + 2) - 1) / 2))) : (((n + (2 * tsteps)) + (-3)) / 2)) : ((((((16 * c0) + n) + 13) * 18) < 0) ? ((18 < 0) ? (-((((-(((16 * c0) + n) + 13)) + 18) + 1) / 18)) : (-((((-(((16 * c0) + n) + 13)) + 18) - 1) / 18))) : ((((16 * c0) + n) + 13) / 18))) : (c0)); c1++)\n{\n  for (c2 = ((((16 * c0) + ((-16) * c1)) + 1) > (((2 * c1) + ((-1) * n)) + 3)) ? (((16 * c0) + ((-16) * c1)) + 1) : (((2 * c1) + ((-1) * n)) + 3); c2 <= (((((((2 * c1) + n) + (-2)) < ((n + (2 * tsteps)) + (-3))) ? (((2 * c1) + n) + (-2)) : ((n + (2 * tsteps)) + (-3))) < ((((16 * c0) + ((-16) * c1)) + n) + 13)) ? (((((2 * c1) + n) + (-2)) < ((n + (2 * tsteps)) + (-3))) ? (((2 * c1) + n) + (-2)) : ((n + (2 * tsteps)) + (-3))) : ((((16 * c0) + ((-16) * c1)) + n) + 13)); c2++)\n  {\n    if ((c0 <= (((((((16 * c1) + c2) + ((-1) * n)) + 1) * 16) < 0) ? ((16 < 0) ? (-((((-((((16 * c1) + c2) + ((-1) * n)) + 1)) + 16) + 1) / 16)) : (-((((-((((16 * c1) + c2) + ((-1) * n)) + 1)) + 16) - 1) / 16))) : (((((16 * c1) + c2) + ((-1) * n)) + 1) / 16))) && (c1 <= ((((c2 + (-1)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-1))) + 2) + 1) / 2)) : (-((((-(c2 + (-1))) + 2) - 1) / 2))) : ((c2 + (-1)) / 2))))\n    {\n      if ((((c2 + n) + 1) % 2) == 0)\n      {\n        for (c4 = 2 * c1; c4 <= ((2 * c1) + 1); c4++)\n        {\n          A[((((-1) * c2) + c4) + n) + (-2)][n + (-2)] = B[((((-1) * c2) + c4) + n) + (-2)][n + (-2)];\n        }\n\n      }\n\n    }\n\n    if ((c0 <= ((((((18 * c1) + ((-1) * n)) + 1) * 16) < 0) ? ((16 < 0) ? (-((((-(((18 * c1) + ((-1) * n)) + 1)) + 16) + 1) / 16)) : (-((((-(((18 * c1) + ((-1) * n)) + 1)) + 16) - 1) / 16))) : ((((18 * c1) + ((-1) * n)) + 1) / 16))) && (c1 >= (((c2 * 2) < 0) ? (-((-c2) / 2)) : ((2 < 0) ? ((((-c2) + (-2)) - 1) / (-2)) : (((c2 + 2) - 1) / 2)))))\n    {\n      if (((n + 1) % 2) == 0)\n      {\n        A[n + (-2)][((((-2) * c1) + c2) + n) + (-2)] = B[n + (-2)][((((-2) * c1) + c2) + n) + (-2)];\n      }\n\n    }\n\n    for (c3 = (((((((((2 * c1) + ((-1) * n)) + 2) * 2) < 0) ? (-((-(((2 * c1) + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-(((2 * c1) + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : ((((((2 * c1) + ((-1) * n)) + 2) + 2) - 1) / 2))) > (((((c2 + ((-1) * n)) + 2) * 2) < 0) ? (-((-((c2 + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-((c2 + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : (((((c2 + ((-1) * n)) + 2) + 2) - 1) / 2)))) ? ((((((2 * c1) + ((-1) * n)) + 2) * 2) < 0) ? (-((-(((2 * c1) + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-(((2 * c1) + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : ((((((2 * c1) + ((-1) * n)) + 2) + 2) - 1) / 2))) : (((((c2 + ((-1) * n)) + 2) * 2) < 0) ? (-((-((c2 + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-((c2 + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : (((((c2 + ((-1) * n)) + 2) + 2) - 1) / 2)))) > ((8 * c0) + ((-8) * c1))) ? ((((((((2 * c1) + ((-1) * n)) + 2) * 2) < 0) ? (-((-(((2 * c1) + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-(((2 * c1) + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : ((((((2 * c1) + ((-1) * n)) + 2) + 2) - 1) / 2))) > (((((c2 + ((-1) * n)) + 2) * 2) < 0) ? (-((-((c2 + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-((c2 + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : (((((c2 + ((-1) * n)) + 2) + 2) - 1) / 2)))) ? ((((((2 * c1) + ((-1) * n)) + 2) * 2) < 0) ? (-((-(((2 * c1) + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-(((2 * c1) + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : ((((((2 * c1) + ((-1) * n)) + 2) + 2) - 1) / 2))) : (((((c2 + ((-1) * n)) + 2) * 2) < 0) ? (-((-((c2 + ((-1) * n)) + 2)) / 2)) : ((2 < 0) ? ((((-((c2 + ((-1) * n)) + 2)) + (-2)) - 1) / (-2)) : (((((c2 + ((-1) * n)) + 2) + 2) - 1) / 2)))) : ((8 * c0) + ((-8) * c1)); c3 <= ((((((((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) < (c1 + (-1))) ? ((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) : (c1 + (-1))) < (tsteps + (-1))) ? ((((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) < (c1 + (-1))) ? ((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) : (c1 + (-1))) : (tsteps + (-1))) < (((8 * c0) + ((-8) * c1)) + 7)) ? ((((((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) < (c1 + (-1))) ? ((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) : (c1 + (-1))) < (tsteps + (-1))) ? ((((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) < (c1 + (-1))) ? ((((c2 + (-2)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-2))) + 2) + 1) / 2)) : (-((((-(c2 + (-2))) + 2) - 1) / 2))) : ((c2 + (-2)) / 2)) : (c1 + (-1))) : (tsteps + (-1))) : (((8 * c0) + ((-8) * c1)) + 7)); c3++)\n    {\n      for (c4 = 2 * c1; c4 <= ((((2 * c1) + 1) < (((2 * c3) + n) + (-2))) ? ((2 * c1) + 1) : (((2 * c3) + n) + (-2))); c4++)\n      {\n        A[(((-2) * c3) + c4) + (-1)][(c2 + ((-2) * c3)) + (-1)] = B[(((-2) * c3) + c4) + (-1)][(c2 + ((-2) * c3)) + (-1)];\n        B[((-2) * c3) + c4][c2 + ((-2) * c3)] = 0.2 * ((((A[((-2) * c3) + c4][c2 + ((-2) * c3)] + A[((-2) * c3) + c4][(c2 + ((-2) * c3)) - 1]) + A[((-2) * c3) + c4][1 + (c2 + ((-2) * c3))]) + A[1 + (((-2) * c3) + c4)][c2 + ((-2) * c3)]) + A[(((-2) * c3) + c4) - 1][c2 + ((-2) * c3)]);\n      }\n\n      if ((2 * c1) == (((2 * c3) + n) + (-2)))\n      {\n        if ((n % 2) == 0)\n        {\n          A[n + (-2)][((((-2) * c1) + c2) + n) + (-3)] = B[n + (-2)][((((-2) * c1) + c2) + n) + (-3)];\n        }\n\n      }\n\n    }\n\n    if (((c0 >= ((((((16 * c1) + c2) + (-15)) * 16) < 0) ? (-((-(((16 * c1) + c2) + (-15))) / 16)) : ((16 < 0) ? ((((-(((16 * c1) + c2) + (-15))) + (-16)) - 1) / (-16)) : ((((((16 * c1) + c2) + (-15)) + 16) - 1) / 16)))) && (c1 >= ((((c2 + 1) * 2) < 0) ? (-((-(c2 + 1)) / 2)) : ((2 < 0) ? ((((-(c2 + 1)) + (-2)) - 1) / (-2)) : ((((c2 + 1) + 2) - 1) / 2))))) && (c2 <= ((2 * tsteps) + (-1))))\n    {\n      if (((c2 + 1) % 2) == 0)\n      {\n        for (c4 = 2 * c1; c4 <= ((((2 * c1) + 1) < ((c2 + n) + (-3))) ? ((2 * c1) + 1) : ((c2 + n) + (-3))); c4++)\n        {\n          B[(((-1) * c2) + c4) + 1][1] = 0.2 * ((((A[(((-1) * c2) + c4) + 1][1] + A[(((-1) * c2) + c4) + 1][1 - 1]) + A[(((-1) * c2) + c4) + 1][1 + 1]) + A[1 + ((((-1) * c2) + c4) + 1)][1]) + A[((((-1) * c2) + c4) + 1) - 1][1]);\n        }\n\n      }\n\n    }\n\n    if ((c0 >= (((((9 * c1) + (-7)) * 8) < 0) ? (-((-((9 * c1) + (-7))) / 8)) : ((8 < 0) ? ((((-((9 * c1) + (-7))) + (-8)) - 1) / (-8)) : (((((9 * c1) + (-7)) + 8) - 1) / 8)))) && (c1 <= ((((((c2 + (-1)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-1))) + 2) + 1) / 2)) : (-((((-(c2 + (-1))) + 2) - 1) / 2))) : ((c2 + (-1)) / 2)) < (tsteps + (-1))) ? ((((c2 + (-1)) * 2) < 0) ? ((2 < 0) ? (-((((-(c2 + (-1))) + 2) + 1) / 2)) : (-((((-(c2 + (-1))) + 2) - 1) / 2))) : ((c2 + (-1)) / 2)) : (tsteps + (-1)))))\n    {\n      B[1][((-2) * c1) + c2] = 0.2 * ((((A[1][((-2) * c1) + c2] + A[1][(((-2) * c1) + c2) - 1]) + A[1][1 + (((-2) * c1) + c2)]) + A[1 + 1][((-2) * c1) + c2]) + A[1 - 1][((-2) * c1) + c2]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c4, c3, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/polyopt/jacobi-2d-imper_orig_tileonly_size16_tile_8_2_1/0"}
{"code": "for (int i = K; i < N; i++)\n{\n  for (int j = 1; j < (i + N); j++)\n  {\n    tmpsum2 += (j + log((1 + x) + j)) / (((2 * i) * j) - 1);\n  }\n\n  sum += 1 / tmpsum2;\n  tmpsum2 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/9"}
{"code": "for (int i = 0; i < (N - 2); i++)\n{\n  for (int j = i + 1; j < (N - 1); j++)\n  {\n    for (int k = j + 1; k < N; k++)\n    {\n      a[u] = i;\n      b[u] = j;\n      c[u] = k;\n      u++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kirillston/OpenMP-MPI/7_2/7_2/2"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  for (int j = 0; j < 3; ++j)\n  {\n    sum[i] += data1[j];\n    sum[i] += data2[j];\n    sum[i] += data3[j];\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom : sum) firstprivate(data1, data2, data3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/mapping/private_mapping/0"}
{"code": "for (i = 0; i < MAX; i++)\n  Data[i] = sqrt(Data[i]);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kjisu96/OpenMP_examples/01_Loop/01_Loop_correct/0"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vthanos/Parallel-Computing/OpenMP/matrix-calc-p/1"}
{"code": "for (size_t i = 0; i < bin_size; ++i)\n{\n  for (size_t j = 0; j < random_num; ++j)\n  {\n    size_t bin = (size_t) (nums[j] / ((double) nums_bin));\n    if (bin == i)\n    {\n      histogram[bin] += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(bin_size, random_num, nums, nums_bin, histogram)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Alva112358/multicore-openmp/lab1/jl11998/0"}
{"code": "for (i = 0; i < col; i++)\n{\n  printf(\"%0.15f\\n\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/11"}
{"code": "for (m = 3; m < 5; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      n = ((m - 3) + 1) * 5;\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,i1 ,i ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/167"}
{"code": "for (i = 0; i < num; i++)\n{\n  sum = 0;\n  aii = fabsf(a[i][i]);\n  for (j = 0; j < num; j++)\n    if (j != i)\n    sum += fabsf(a[i][j]);\n\n\n  if (aii < sum)\n  {\n    printf(\"The matrix will not converge.\\n\");\n    exit(1);\n  }\n\n  if (aii > sum)\n    bigger++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arnav-kansal/parallel_linsolver/source/gs/0"}
{"code": "for (int i = 2; i <= N; i++)\n{\n  arr[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nesmabelkhodja/Parallel-Computing/Lab 2/genprimes/3"}
{"code": "for (i = sqrt_of_proc; i < comm_sz; i++)\n{\n  if ((comm_sz % i) == 0)\n  {\n    dim_size[0] = i;\n    dim_size[1] = comm_sz / i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TeodStm/Parallel-Prog-Mpi-OpenMP/mpi_omp_hybrid/3"}
{"code": "for (i = 1; i < (mysize + 1); i++)\n{\n  left_send[i - 1] = matrix[i][1];\n  right_send[i - 1] = matrix[i][mysize];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Koutoulakis/Parallel_Programming/MPI/5"}
{"code": "for (dimension = 0; dimension < N; dimension++)\n{\n  dur = 0.0;\n  for (i = 0; i < VECES; i++)\n  {\n    tini = omp_get_wtime();\n    sumSecuencial = 0;\n    for (j = 0; j < n[dimension]; j++)\n    {\n      sumSecuencial += 4 * (pow(-1, j) / ((2 * j) + 1));\n    }\n\n    dur += omp_get_wtime() - tini;\n  }\n\n  sumPromSecuencial[dimension] = sumSecuencial;\n  durSecuencial[dimension] = dur / VECES;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HaslerUNMSM/PI-OpenMP/CalculoPI/0"}
{"code": "for (int p = 0; p < ((dx * dy) * dz); p++)\n{\n  int i = p % dx;\n  int j = (p / dx) % dy;\n  int k = ((p / dx) / dy) % dz;\n  if ((i == 0) || (i == (dx - 1)))\n    continue;\n\n  if ((j == 0) || (j == (dy - 1)))\n    continue;\n\n  if ((k == 0) || (k == (dz - 1)))\n    continue;\n\n  if ((is_first[0] && (i == 1)) || (((border_conditions[0] != 2) && is_last[0]) && (i == (dx - 2))))\n    continue;\n\n  if ((is_first[1] && (j == 1)) || (((border_conditions[1] != 2) && is_last[1]) && (j == (dy - 2))))\n    continue;\n\n  if ((is_first[2] && (k == 1)) || (((border_conditions[2] != 2) && is_last[2]) && (k == (dz - 2))))\n    continue;\n\n  if (n == 1)\n  {\n    double f_value = f_func(x((i_min + i) - 1), y((j_min + j) - 1), z((k_min + k) - 1), 0);\n    u_data[n][p] = u_data[n - 1][p] + (((0.5 * tau) * tau) * (laplace(u_data[n - 1], i, j, k) + f_value));\n  }\n  else\n  {\n    double f_value = f_func(x((i_min + i) - 1), y((j_min + j) - 1), z((k_min + k) - 1), (n - 1) * tau);\n    u_data[n % LAYERS][p] = ((2 * u_data[(n - 1) % LAYERS][p]) - u_data[(n - 2) % LAYERS][p]) + ((tau * tau) * (laplace(u_data[(n - 1) % LAYERS], i, j, k) + f_value));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vbugaevskii/msu.supercomputers.course/parallel-hw2-03/parallel-mpi-omp/main/6"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n  mat[i][j] = sin((i + j) + 1.);\n\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HPC-lab-ITIS/OpenMP-and-MPI/materials/lec_1/code/test_3/0"}
{"code": "for (int process_id = 1; process_id < process_count; process_id++)\n{\n  MPI_Send(&VERTEX_COUNT, 1, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  MPI_Send(&EDGE_COUNT, 1, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  for (int i = 0; i < EDGE_COUNT; i++)\n  {\n    size_t length = sizeof(Edge);\n    int pos = 0;\n    char buffer[length];\n    MPI_Pack(&EDGES[i].begin, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Pack(&EDGES[i].end, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Pack(&EDGES[i].value, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Send(buffer, pos, (MPI_Datatype) 0x4c00010f, process_id, 1, (MPI_Comm) 0x44000000);\n  }\n\n  MPI_Send(EDGE_INDICES, VERTEX_COUNT * VERTEX_COUNT, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  MPI_Send(VALUE_LEFT, EDGE_COUNT, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/20"}
{"code": "for (t = 0; t < 1500; t++)\n{\n  kernel_1(_fict_, ey, t);\n  kernel_2(ey, hz);\n  kernel_3(ex, hz);\n  kernel_4(ex, ey, hz);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/FDTD-2D/fdtd2d_cpu_kernel/2"}
{"code": "for (int i = 0; i < instance.dimension; i++)\n{\n  for (int j = i + 1; j < instance.dimension; j++)\n  {\n    length_table[i][j] = distance(coord[i].x, coord[i].y, coord[j].x, coord[j].y);\n    length_table[j][i] = length_table[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebaMederos/TSP-OpenMP/sim-ann/SA/11"}
{"code": "for (i = 0; i <= (nx - 1); i += 1)\n{\n  for (j = 0; j <= (ny - 1); j += 1)\n  {\n    for (k = 0; k <= (nz - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        frct[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/9"}
{"code": "for (int i = 0; i < 19; i++)\n{\n  do_step(spins, neighs, tstar, N, h, energy, gen, ran_u, ran_pos, m);\n  w_output(output, tstar, N, m);\n  (cout << tstar) << endl;\n  tstar -= deltat;\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic) num_threads(4) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/2"}
{"code": "for (int i = 0; i < n; i++)\n  pri[i] = (shr[i] = 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/006_data_race_condition_compute/3"}
{"code": "for (int i = 0; i < tamanho; i++)\n{\n  aux += \"\uffec\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/10"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  local_sum += i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/sum/sum/0"}
{"code": "for (i = 0; i < 24; i++)\n{\n  for (j = 0; j < 24; j++)\n  {\n    for (k = 0; k < 24; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/ArithmeticMeasureTool/test/bt_single/0"}
{"code": "for (i = k - 1; i > (-1); i--)\n{\n  y[i] -= x[k] * U[(i * n) + k];\n}\n\n", "pragma": "omp parallel for schedule(static) num_threads(thread_count) default(none) private(i) shared(n, U, x, y, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumasandesu/comp3046_proj2_ec/src/gaussian_omp/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  if (check_password(index, cur_salt))\n  {\n    cracked[index] = 1;\n    any_cracked |= 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/andotp_fmt_plug/3"}
{"code": "for (i = 0; i < tnum; i++)\n{\n  list_array[i] = init_list();\n  r_mask_array[i] = (int *) malloc(m_size * (sizeof(int)));\n  c_mask_array[i] = (int *) malloc(m_size * (sizeof(int)));\n  b_mask_array[i] = (int *) malloc(m_size * (sizeof(int)));\n  cp_sudokus_array[i] = (int *) malloc(v_size * (sizeof(int)));\n  init_masks(sudoku, r_mask_array[i], c_mask_array[i], b_mask_array[i]);\n  for (j = 0; j < v_size; j++)\n  {\n    if (sudoku[j])\n      cp_sudokus_array[i][j] = -1;\n    else\n    {\n      cp_sudokus_array[i][j] = 0;\n      if (!flag_start)\n      {\n        flag_start = !flag_start;\n        start_pos = j;\n      }\n\n    }\n\n  }\n\n  terminated[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/omp/sudoku-omp/0"}
{"code": "for (i = 0; i < g_psf_extent; i++)\n{\n  for (j = 0; j < g_psf_extent; j++)\n  {\n    (*g_psf_high_res)(i, j) = psf_totale(((g_extended_image_dim_y - g_psf_extent) / 2) + i, ((g_extended_image_dim_x - g_psf_extent) / 2) + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/15"}
{"code": "for (i = rb; i < re; i++)\n  beta -= p_q[0][i] * p_r[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/35"}
{"code": "for (i = iend; i >= ist; i += -1)\n{\n  for (j = jend; j >= jst; j += -1)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i + 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tx1) * dx1;\n    a[i][j][0][1] = dt * tx2;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = 0.0;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = ((dt * tx2) * (((-(u[i + 1][j][k][1] * tmp1)) * (u[i + 1][j][k][1] * tmp1)) + (((0.40e+00 * 0.50) * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i + 1][j][k][1]));\n    a[i][j][1][1] = (((dt * tx2) * ((2.0 - 0.40e+00) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    a[i][j][1][2] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][2] * tmp1));\n    a[i][j][1][3] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][3] * tmp1));\n    a[i][j][1][4] = (dt * tx2) * 0.40e+00;\n    a[i][j][2][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][2]));\n    a[i][j][2][1] = (dt * tx2) * (u[i + 1][j][k][2] * tmp1);\n    a[i][j][2][2] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    a[i][j][2][3] = 0.0;\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][3]));\n    a[i][j][3][1] = (dt * tx2) * (u[i + 1][j][k][3] * tmp1);\n    a[i][j][3][2] = 0.0;\n    a[i][j][3][3] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    a[i][j][3][4] = 0.0;\n    a[i][j][4][0] = ((dt * tx2) * ((((0.40e+00 * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2) - (1.40e+00 * (u[i + 1][j][k][4] * tmp1))) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i + 1][j][k][1] * u[i + 1][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][2] * u[i + 1][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) - ((c1345 * tmp2) * u[i + 1][j][k][4])));\n    a[i][j][4][1] = ((dt * tx2) * ((1.40e+00 * (u[i + 1][j][k][4] * tmp1)) - ((0.50 * 0.40e+00) * (((((3.0 * u[i + 1][j][k][1]) * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i + 1][j][k][1]);\n    a[i][j][4][2] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][2] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][2]);\n    a[i][j][4][3] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][3] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][3]);\n    a[i][j][4][4] = (((dt * tx2) * (1.40e+00 * (u[i + 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n    tmp1 = 1.0 / u[i][j + 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = dt * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = ((dt * ty2) * ((-(u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][1]));\n    b[i][j][1][1] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = (dt * ty2) * (u[i][j + 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = ((dt * ty2) * (((-(u[i][j + 1][k][2] * tmp1)) * (u[i][j + 1][k][2] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j + 1][k][2]));\n    b[i][j][2][1] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][1] * tmp1));\n    b[i][j][2][2] = (((dt * ty2) * ((2.0 - 0.40e+00) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][3] * tmp1));\n    b[i][j][2][4] = (dt * ty2) * 0.40e+00;\n    b[i][j][3][0] = ((dt * ty2) * ((-(u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = (dt * ty2) * (u[i][j + 1][k][3] * tmp1);\n    b[i][j][3][3] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = ((dt * ty2) * ((((0.40e+00 * (((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) * tmp2) - (1.40e+00 * (u[i][j + 1][k][4] * tmp1))) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j + 1][k][1] * u[i][j + 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j + 1][k][2] * u[i][j + 1][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) - ((c1345 * tmp2) * u[i][j + 1][k][4])));\n    b[i][j][4][1] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][1]);\n    b[i][j][4][2] = ((dt * ty2) * ((1.40e+00 * (u[i][j + 1][k][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + ((3.0 * u[i][j + 1][k][2]) * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j + 1][k][2]);\n    b[i][j][4][3] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][3]);\n    b[i][j][4][4] = (((dt * ty2) * (1.40e+00 * (u[i][j + 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i][j][k + 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tz1) * dz1;\n    c[i][j][0][1] = 0.0;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = dt * tz2;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = ((dt * tz2) * ((-(u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][1]));\n    c[i][j][1][1] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    c[i][j][1][2] = 0.0;\n    c[i][j][1][3] = (dt * tz2) * (u[i][j][k + 1][1] * tmp1);\n    c[i][j][1][4] = 0.0;\n    c[i][j][2][0] = ((dt * tz2) * ((-(u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][2]));\n    c[i][j][2][1] = 0.0;\n    c[i][j][2][2] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    c[i][j][2][3] = (dt * tz2) * (u[i][j][k + 1][2] * tmp1);\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = ((dt * tz2) * (((-(u[i][j][k + 1][3] * tmp1)) * (u[i][j][k + 1][3] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k + 1][3]));\n    c[i][j][3][1] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][1] * tmp1));\n    c[i][j][3][2] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][2] * tmp1));\n    c[i][j][3][3] = ((((dt * tz2) * (2.0 - 0.40e+00)) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    c[i][j][3][4] = (dt * tz2) * 0.40e+00;\n    c[i][j][4][0] = ((dt * tz2) * ((((0.40e+00 * (((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) * tmp2) - (1.40e+00 * (u[i][j][k + 1][4] * tmp1))) * (u[i][j][k + 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k + 1][1] * u[i][j][k + 1][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k + 1][2] * u[i][j][k + 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) - ((c1345 * tmp2) * u[i][j][k + 1][4])));\n    c[i][j][4][1] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][1]);\n    c[i][j][4][2] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][2]);\n    c[i][j][4][3] = ((dt * tz2) * ((1.40e+00 * (u[i][j][k + 1][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + ((3.0 * u[i][j][k + 1][3]) * u[i][j][k + 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k + 1][3]);\n    c[i][j][4][4] = (((dt * tz2) * (1.40e+00 * (u[i][j][k + 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n  }\n\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,i,j) firstprivate (ist,jst,jend)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/59"}
{"code": "for (NUM_THREADS = 8; NUM_THREADS <= 8; NUM_THREADS++)\n{\n  cout << \"\u6734\u7d20\u5206\u9664\uff1a\";\n  timing(ver2);\n  cout << \"SIMD\u5206\u9664\uff1a\";\n  timing(ver3);\n  cout << \"auto simd horizontal\uff1a\";\n  timing(ver6);\n  cout << \"auto simd vertical\uff1a\";\n  timing(ver10);\n  cout << \"dynamic\uff1a\";\n  timing(ver8);\n  cout << \"guided\uff1a\";\n  timing(ver9);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ching-Yee-Chan/openMP/arm/4"}
{"code": "for (int k = 0; k < 5; k++)\n{\n  printf(\"%d \\n\", result[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block2/task8/1"}
{"code": "for (unsigned f = 0; f < raw_feat_frequency_creation_thread_lock.size(); ++f)\n  omp_destroy_lock(&raw_feat_frequency_creation_thread_lock[f]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/3"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (d = 0; d < NDIM; d++)\n  {\n    cell(ci).setL(d, L.at(d));\n    cell(ci).setpbc(d, 1);\n  }\n\n  if (ci < ntumor)\n  {\n    cell(ci).setNV(tumorNV);\n    cell(ci).initializeVertices();\n    cell(ci).initializeCell();\n    cell(ci).setAsphericity(tumorCalA);\n  }\n  else\n  {\n    cell(ci).setNV(adiposeNV);\n    cell(ci).initializeVertices();\n    cell(ci).initializeCell();\n    cell(ci).setAsphericity(adiposeCalA);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/4"}
{"code": "for (int i = 0; i < argc; i++)\n{\n  if ((argv[i] == i_flag) && (i < (argc - 1)))\n  {\n    input_file = argv[i + 1];\n  }\n  else\n    if ((argv[i] == o_flag) && (i < (argc - 1)))\n  {\n    out_file_name = argv[i + 1];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FreddyManston/HPC-Module-Assignment/serial/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  #pragma ivdep\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxy[(2 * j) + (2 * kj)] = at2 * zt1;\n    fxy[(1 + (2 * j)) + (2 * kj)] = at3 * zt1;\n    fxy[(2 * j) + (2 * k1)] = at2 * zt2;\n    fxy[(1 + (2 * j)) + (2 * k1)] = (-at3) * zt2;\n    at1 = at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n    wp += (double) at1;\n  }\n\n  at1 = crealf(ffc[kk]) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = cimagf(q[kj]) - (crealf(q[kj]) * _Complex_I);\n  fxy[2 * kj] = zero;\n  fxy[1 + (2 * kj)] = at3 * zt1;\n  fxy[2 * k1] = zero;\n  fxy[1 + (2 * k1)] = zero;\n  at1 = at1 * (q[kj] * conjf(q[kj]));\n  wp += (double) at1;\n  sum1 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/4"}
{"code": "for (L = 0; L < N; L++)\n{\n  termo_linha[L] = A[(L * N) + 0] * A[(L * N) + 1];\n  for (K = 1; K < P; K++)\n    termo_linha[L] += A[(L * N) + (2 * K)] * A[((L * N) + (2 * K)) + 1];\n\n}\n\n", "pragma": "omp parallel for default(none) private(L,K,P) shared(N,A,termo_linha)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cleversonledur/ParallelMPIcode/winogradPar/1"}
{"code": "for (int jj = 0; jj < size; jj++)\n  for (int kk = 0; kk < size; kk++)\n  *((colo + (jj * size)) + kk) = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cheshie/ParallelComputing/mandelbrot_omp/0"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  for (j = 1; j < (m - 1); j++)\n  {\n    resid = ((((ax * (uold[i - 1][j] + uold[i + 1][j])) + (ay * (uold[i][j - 1] + uold[i][j + 1]))) + (b * uold[i][j])) - f[i][j]) / b;\n    u[i][j] = uold[i][j] - (omega * resid);\n    error = error + (resid * resid);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j ,resid ) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB058-jacobikernel-orig-no/2"}
{"code": "for (int i = 1; i < (g_populationSize / 2); i++)\n{\n  selectParents(&fatherIndex, &motherIndex);\n  spawn = performCrossover(fatherIndex, motherIndex);\n  mutate(spawn);\n  newPopulation[i * 2] = spawn[0];\n  newPopulation[(i * 2) + 1] = spawn[1];\n  spawn.empty();\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jontelarsson94/OpenMPGeneticAlgorithm/MainWithOpenMP/main/6"}
{"code": "for (i = 0; i < 600; i++)\n  a[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Task/checking_scope_of_variables_inside_task/0"}
{"code": "for (int y = 0; y < dim_y; y++)\n{\n  for (int x = 0; x < dim_x; x++)\n  {\n    omp_destroy_lock(&costs->board[(y * dim_y) + x].lock);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/11"}
{"code": "for (i = high - 1; i > low; i--)\n{\n  j = perm[i];\n  for (k = i + 1; k <= high; k++)\n    h[k][i] = mat[k][i - 1];\n\n  if (i != j)\n  {\n    for (k = i; k <= high; k++)\n    {\n      h[i][k] = h[j][k];\n      h[j][k] = 0.;\n    }\n\n    h[j][i] = 1.;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/14"}
{"code": "for (int k = 0; k < (blockN * blockN); k++)\n{\n  int k1 = k / blockN;\n  int k2 = k % blockN;\n  for (int i = 0; i < blockSize; i++)\n  {\n    for (int j = 0; j < blockSize; j++)\n    {\n      int iLocal = (k1 * blockSize) + i;\n      int jLocal = (k2 * blockSize) + j;\n      tempMat[iLocal][k2] += Mat[iLocal][jLocal] * Vec[jLocal];\n    }\n\n  }\n\n  if (k2 == (blockN - 1))\n  {\n    for (int i = 0; i < blockSize; i++)\n    {\n      for (int j = 0; j < tailSize; j++)\n      {\n        int iLocal = (k1 * blockSize) + i;\n        int jLocal = (blockN * blockSize) + j;\n        tempMat[iLocal][blockN] += Mat[iLocal][jLocal] * Vec[jLocal];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/4/4/5"}
{"code": "for (i = 0; i < N; i++)\n  matriz[i] = (int *) malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio9/4"}
{"code": "for (unsigned int elem_index = 0; elem_index < obj_scaled_add_x.vector_dimension; elem_index++)\n{\n  obj_scaled_add_y.values[elem_index] = obj_scaled_add_y.values[elem_index] + (scaling_factor_add * obj_scaled_add_x.values[elem_index]);\n}\n\n", "pragma": "      #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shreyas-Gururaj/HPC_PNLA_Library_OpenMP/src/vector_omp/5"}
{"code": "for (i = 0; i < 4; i++)\n{\n  v[i] = a + v[i];\n  a = a + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/cc-examples/parallel/openmp/uva/proof2/1"}
{"code": "for (; (last_i + 31) < n; last_i += 32)\n{\n  _mm256_store_ps(&y[last_i + 0], _mm256_load_ps(&x[last_i + 0]));\n  _mm256_store_ps(&y[last_i + 8], _mm256_load_ps(&x[last_i + 8]));\n  _mm256_store_ps(&y[last_i + 16], _mm256_load_ps(&x[last_i + 16]));\n  _mm256_store_ps(&y[last_i + 24], _mm256_load_ps(&x[last_i + 24]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/15"}
{"code": "for (int i = 0; i < 26; i++)\n{\n  printf(\"%d \", count[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/mapreduce-openmp/4"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  free(grid[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patricia-souza/JogoVidaOpenMP/Critical/6"}
{"code": "for (int i = 1; i < (1000000 + 1); i++)\n{\n  C[i] = C[i] + C[i - 1];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feperessim/counting-sort-parallel-openmp/counting_sort_serial_and_parallel/1"}
{"code": "for (long i = 0; i < numUniqueClusters; i++)\n{\n  omp_destroy_lock(&nlocks[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/buildNextPhase/5"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericContinuumParticles[i]->GetStressTensorFromNeighbourStep1();\n}\n\n", "pragma": "                #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/18"}
{"code": "for (int i = 0; i < 12; ++i)\n{\n  for (int j = 0; j < 5; ++j)\n  {\n    a[i][j] = rand() % 12;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/khaledbendia/matrice_openmp/khaled_bendia_matrice_openmp/2"}
{"code": "for (i = 0; i < bufferSize; i++)\n{\n  if (finalReduceBuf[i] != correctReduce)\n  {\n    testFlag = FALSE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/collective_reduction/3"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n{\n  mat_1[i][j] = rand() % 10;\n  mat_2[i][j] = rand() % 10;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment2/0"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  sum += i;\n  printf(\"%d:calculation of the iteration number %d.\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "#pragma omp for reduction(+:sum) schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jake33rus/MPI-OpenMP-labs-and-CursProject/lab2Parallels/lab2Parallels/lab2Parallels/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (check[i] == array[i])\n    continue;\n  else\n  {\n    cout << \"There is a difference in the parallel and serial calculation \\n\";\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/prgm5/3"}
{"code": "for (i = 0; i < 5; i++)\n  switch (CLASS)\n{\n  case 'S':\n    test_index_array[i] = S_test_index_array[i];\n    test_rank_array[i] = S_test_rank_array[i];\n    break;\n\n  case 'A':\n    test_index_array[i] = A_test_index_array[i];\n    test_rank_array[i] = A_test_rank_array[i];\n    break;\n\n  case 'W':\n    test_index_array[i] = W_test_index_array[i];\n    test_rank_array[i] = W_test_rank_array[i];\n    break;\n\n  case 'B':\n    test_index_array[i] = B_test_index_array[i];\n    test_rank_array[i] = B_test_rank_array[i];\n    break;\n\n  case 'C':\n    test_index_array[i] = C_test_index_array[i];\n    test_rank_array[i] = C_test_rank_array[i];\n    break;\n\n  case 'D':\n    test_index_array[i] = D_test_index_array[i];\n    test_rank_array[i] = D_test_rank_array[i];\n    break;\n\n  case 'E':\n    test_index_array[i] = E_test_index_array[i];\n    test_rank_array[i] = E_test_rank_array[i];\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/17"}
{"code": "for (int i = j; i < n; i++)\n{\n  double sum = 0;\n  for (int k = 0; k < j; k++)\n  {\n    sum = sum + (L[i][k] * U[k][j]);\n  }\n\n  L[i][j] = A[i][j] - sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/1"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  y[i] = x[i] + y[i];\n}\n\n", "pragma": "   #pragma omp target teams distribute parallel for if(target:use_device)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-273738/clang-273738/1"}
{"code": "for (j = RADIUS; j < (n - RADIUS); j++)\n  for (i = RADIUS; i < (n - RADIUS); i++)\n  out[i + (j * n)] = (float) 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Stencil/stencil/1"}
{"code": "for (j = 0; j < 4; j++)\n{\n  avgtime[j] = avgtime[j] / ((double) (NTIMES - 1));\n  if (label[j][0] != 'i')\n  {\n    printf(\"%s%12.1f  %11.6f  %11.6f  %11.6f\\n\", label[j], (1.0E-06 * bytes[j]) / mintime[j], avgtime[j], mintime[j], maxtime[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-4/stream-gpu/stream/2"}
{"code": "for (i = 0; i < L; i++)\n{\n  printf(\"%g\", C[i * ((250 * 1024) / 256)]);\n  for (k = 1; k < ((250 * 1024) / 256); k++)\n  {\n    printf(\" %g\", C[(i * ((250 * 1024) / 256)) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/15"}
{"code": "for (int i = 0; i < 24; i++)\n{\n  __android_log_print(ANDROID_LOG_DEBUG, __FUNCTION__, \"idx %02d thread %02d\", i, omp_get_thread_num());\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paleozogt/OpenMPAndroidTest/app/src/main/cpp/Bar/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  u000ijk[m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (xi,eta,zeta)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/56"}
{"code": "for (j = 0; j <= yres; j++)\n{\n  for (i = 0; i < xres; i++)\n  {\n    xi = x[0] + (x_array[i] * xgap);\n    yi = y[0] + (y_array[j] * ygap);\n    savex = (flag * c[0]) + ((1 - flag) * xi);\n    savey = (flag * c[1]) + ((1 - flag) * yi);\n    radius = 0.0;\n    count = 0;\n    xisq = xi * xi;\n    yisq = yi * yi;\n    while ((radius <= 4.0) && (count < maxIterations))\n    {\n      savex2 = xi;\n      xi = (xisq - yisq) + savex;\n      yi = ((2.0f * savex2) * yi) + savey;\n      xisq = xi * xi;\n      yisq = yi * yi;\n      radius = xisq + yisq;\n      count++;\n    }\n\n    if (count > maxIterationCount)\n    {\n      maxIterationCount = count;\n    }\n\n    int *p = (iterations + (y_array[j] * xres)) + x_array[i];\n    if (radius <= 4.0)\n    {\n      assert(count == maxIterations);\n      *p = 0;\n    }\n    else\n    {\n      *p = count;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EvanSkeete/ParallelJulia/julia_omp/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  result += x[i] + y[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_ompss.dg/cxx/success_task_13/0"}
{"code": "for (i = 0; i < nlocalverts; ++i)\n  pred[i] = -1;\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_replicated/0"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    b[i][j] = 0.0;\n    if ((i == abs(0.25 * x_points)) && (j == abs(0.25 * y_points)))\n    {\n      b[i][j] = 100;\n    }\n\n    if ((i == abs(0.75 * x_points)) && (j == abs(0.75 * y_points)))\n    {\n      b[i][j] = -100;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Poissons Equation/2-D_Poissons_Equation/main/0"}
{"code": "for (int k = 0; k < 10000; k++)\n{\n  for (i = 0; i < ((int) in_image.size()); i = i + 4)\n  {\n    bw_image[i] = ((in_image[i] * 0.299) + (in_image[i + 1] * 0.587)) + (in_image[i + 2] * 0.114);\n    bw_image[i + 1] = ((in_image[i] * 0.299) + (in_image[i + 1] * 0.587)) + (in_image[i + 2] * 0.114);\n    bw_image[i + 2] = ((in_image[i] * 0.299) + (in_image[i + 1] * 0.587)) + (in_image[i + 2] * 0.114);\n    bw_image[i + 3] = in_image[i];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2) firstprivate(in_image) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/edge_detection/OpenMP/prewittOpenMP/1"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  x_init[i] = ((((r1 * stride1) + (r2 * stride2)) + i) + 0.5) * dx;\n  x_n[i] = x_init[i];\n}\n\n", "pragma": "#pragma omp for simd schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/0"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  for (j = 0; j <= (len - 1); j += 1)\n  {\n    u[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB021-reductionmissing-orig-yes/0"}
{"code": "for (int thread_count = 1; thread_count <= threads; thread_count++)\n{\n  for (int n = 10000; n < ((work * 10000) + 1); n += 10000)\n  {\n    int in[n];\n    for (int i = 0; i < n; i++)\n    {\n      in[i] = rand();\n    }\n\n    int out[n];\n    struct timeval start;\n    struct timeval stop;\n    struct timeval diff;\n    gettimeofday(&start, 0);\n    count_sort_inner(n, in, out, thread_count);\n    gettimeofday(&stop, 0);\n    timeval_diff(&diff, &stop, &start);\n    for (int i = 0; i < n; i++)\n    {\n    }\n\n    resultsInner[thread_count][n / 10000] = diff;\n    gettimeofday(&start, 0);\n    count_sort_outer(n, in, out, thread_count);\n    gettimeofday(&stop, 0);\n    timeval_diff(&diff, &stop, &start);\n    for (int i = 0; i < n; i++)\n    {\n    }\n\n    resultsOuter[thread_count][n / 10000] = diff;\n  }\n\n  printf(\"Did Done it for %d threads\\n\", thread_count);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Johnstedt/Parallel_Computing/OpenMP/count_sort/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (graph[i][j] != (9223372036854775807L - 101))\n    {\n      fprintf(out, \"%ld \", graph[i][j]);\n    }\n    else\n    {\n      fprintf(out, \"X \");\n    }\n\n  }\n\n  fprintf(out, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avisenna01/Djikstra-OpenMP/src/dijkstra_omp/1"}
{"code": "for (int rw = 0; rw < m_nRows; rw++)\n{\n  switch (m_AggregationType)\n  {\n    case AT_Average:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = 0.f;\n      }\n\n      m_1DData[rw] = ((m_1DData[rw] * m_Counter) + data[rw]) / (m_Counter + 1.f);\n    }\n\n      break;\n\n    case AT_Sum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = 0.f;\n      }\n\n      m_1DData[rw] += data[rw];\n    }\n\n      break;\n\n    case AT_Minimum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = MAXIMUMFLOAT;\n      }\n\n      if (m_1DData[rw] >= data[rw])\n      {\n        m_1DData[rw] = data[rw];\n      }\n\n    }\n\n      break;\n\n    case AT_Maximum:\n      if (!FloatEqual(data[rw], NODATA_VALUE))\n    {\n      if (FloatEqual(m_1DData[rw], NODATA_VALUE))\n      {\n        m_1DData[rw] = MISSINGFLOAT;\n      }\n\n      if (m_1DData[rw] <= data[rw])\n      {\n        m_1DData[rw] = data[rw];\n      }\n\n    }\n\n      break;\n\n    default:\n      break;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/7"}
{"code": "for (j = 1; j < barsNum; j++)\n{\n  lowRange[j] = highRange[j - 1];\n  highRange[j] = lowRange[j] + barRange;\n  if (remainder > 0)\n  {\n    highRange[j]++;\n    remainder--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlaaElattar/MPI_openmp/main/2"}
{"code": "for (i = 0; i < 3; i++)\n{\n  init_random_seq[i] = (unsigned short) atoi(argv[7 + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HylianPablo/Paralela2020/PRACTICA1 - OPENMP/OpenMP - Version final/backup/5"}
{"code": "for (int i = 0; i < N; ++i)\n  b[i] = cos((i * 1.0) / 200);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDX-Math-HSAP/openmp_intro/example codes/impls/8"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  Friend = Cur->Friends[i];\n  if ((Friend != (-1)) && (Maze->Connected[Friend] != 1))\n  {\n    Maze->Edges[Cur->EdgeTo[i]].Out = Friend;\n    HeapEnqueue1(Queue, Maze->Edges[Cur->EdgeTo[i]].Weight, &Maze->Edges[Cur->EdgeTo[i]]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/25"}
{"code": "for (i = 1; i < (30 - 1); i++)\n{\n  for (j = 1; j < (30 - 1); j++)\n  {\n    int thread = calc_thread(30, 30, i, j);\n    printf(\"%d L: %p\\n\", thread, &u[i - 1][j]);\n    printf(\"%d L: %p\\n\", thread, &u[i + 1][j]);\n    printf(\"%d L: %p\\n\", thread, &u[i][j - 1]);\n    printf(\"%d L: %p\\n\", thread, &u[i][j + 1]);\n    printf(\"%d S: %p\\n\", thread, &w[i][j]);\n    w[i][j] = (((u[i - 1][j] + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]) / 4.0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/8"}
{"code": "for (j = 0; j < mxt; ++j)\n{\n  sprintf(s, \"Hello from thread %d of %d\", t, mxt);\n  msgs[j] = s;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rafalcode/openmping/ilyak02/0"}
{"code": "for (int i = 0; i < s; i++)\n{\n  char *tptr;\n  char *pptr;\n  char *text = ttab[i];\n  while ((*text) != NULL)\n  {\n    if ((*text) == (*pattern))\n    {\n      tptr = text + 1;\n      pptr = pattern + 1;\n      while (true)\n      {\n        if ((*pptr) == NULL)\n        {\n          ++n;\n          break;\n        }\n\n        if ((*tptr) != (*pptr))\n        {\n          break;\n        }\n\n        tptr++;\n        pptr++;\n      }\n\n    }\n\n    text++;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static, 1) reduction(+:n)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/micmax93/ParallelPatternMatching/source/main/2"}
{"code": "for (size_t i = 0; i < featureStats.size(); i++)\n{\n  featureInstanceStart[i] = featureStats[i].start;\n  featureInstanceEnd[i] = featureStats[i].end;\n  featureInstanceCount[i] = featureStats[i].count;\n  if (featureInstanceCount[i] > MaxCount)\n  {\n    MaxCount = featureInstanceCount[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/1"}
{"code": "for (i = nT - 1; i >= 0; i--)\n{\n  memset(yi, 0, (sizeof(double)) * wT);\n  for (j = nT - 1; j > i; j--)\n  {\n    cblas_dgemv(CblasRowMajor, CblasTrans, wT, wT, -1.0, L[j][i], wT, &y[j * wT], 1, 1.0, yi, 1);\n  }\n\n  cblas_daxpy(wT, 1.0, yi, 1, &y[i * wT], 1);\n  cblas_dtrsv(CblasRowMajor, CblasLower, CblasTrans, CblasNonUnit, wT, L[i][i], wT, &y[i * wT], 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhyuchao123/OpenMP-and-CUDA-for-matrix-decomposition/openmp/checkCholesky/5"}
{"code": "for (nncols = 0, i = 0; i < ncols; i++)\n{\n  if (clens[i].key > 0)\n  {\n    colmap[clens[i].val] = nncols++;\n  }\n  else\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/44"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[2 * (i + (mxv * j))] = fxy[2 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (2 * (i + (mxv * j)))] = fxy[1 + (2 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nn = 2 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dx = amy * ((dxp * sfxy[nn + 2]) + dx);\n    dy = amy * ((dxp * sfxy[nn + 3]) + dy);\n    nn += 2 * mxv;\n    vx = amx * sfxy[nn];\n    vy = amx * sfxy[nn + 1];\n    dx += dyp * ((dxp * sfxy[nn + 2]) + vx);\n    dy += dyp * ((dxp * sfxy[nn + 3]) + vy);\n    dxp = ppart[(j + (2 * nppmx)) + npoff];\n    dyp = ppart[(j + (3 * nppmx)) + npoff];\n    vx = dxp + (qtm * dx);\n    vy = dyp + (qtm * dy);\n    dxp += vx;\n    dyp += vy;\n    sum1 += (dxp * dxp) + (dyp * dyp);\n    dx = x + (vx * dt);\n    dy = y + (vy * dt);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,ih,nh,x,y,dxp,dyp,amx,amy, dx,dy,vx,vy,edgelx,edgely,edgerx,edgery,sum1,sfxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/vmpush2/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  REAL *tmp_uold = &uold[((i + uold_0_offset) * uold_m) + uold_1_offset];\n  REAL *tmp_u = &u[i * m];\n  for (j = 0; j < m; j++)\n  {\n    *tmp_uold = *tmp_u;\n    tmp_uold++;\n    tmp_u++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) shared(m,n,uold,u,uold_0_offset,uold_1_offset, uold_m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_itlmic_kernel/0"}
{"code": "for (uint32_t i = 0; i < rect_list.size(); i++)\n{\n  for (uint32_t j = i + 1; j < rect_list.size(); j++)\n  {\n    if ((rect_list[i].second == rect_list[j].second) && (distance(*rect_list[i].first, *rect_list[j].first) == 0))\n    {\n      stitch_list[new_polygon_id_list[i] - start].push_back(new_polygon_id_list[j]);\n      stitch_list[new_polygon_id_list[j] - start].push_back(new_polygon_id_list[i]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/10"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  mult(600, 3000, 400, 3, eventSet, i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danfergo/cpar/assignment/cpp/matrixprod/8"}
{"code": "for (i = mm - 1; i >= m1; i--)\n{\n  i3 = jg[3][i][1];\n  i2 = jg[2][i][1];\n  i1 = jg[1][i][1];\n  oz[(((i3 * n2) * n1) + (i2 * n1)) + i1] = +1.0;\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom: oz[0:n3*n2*n1]) map(to: jg[0:4][0:mm][0:2])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_microbench/benchmarks/NAS_SHOC_OpenACC_2.5/NAS-OMP-OFFLOADING/MG/mg/23"}
{"code": "for (i = 0; i < n_points; i++)\n{\n  fprintf(stdout, \"%f\\n\", x[i]);\n}\n\n", "pragma": "omp parallel for shared(x)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juandapradam12/JuanPrada_Ejercicio30/walkOPEN/1"}
{"code": "for (i = 0; i < num_elements; i++)\n  vector_a[i] = vector_a[i] + vector_b[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Vector sum/vector_sum/0"}
{"code": "for (int i = p; i < stroka.length(); i++)\n{\n  line.Data += stroka[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shcherbakov-Mikhail/Task3-sem4/functions/2"}
{"code": "for (int j = 0; j < lda; j += LARGE_N)\n{\n  int N = (LARGE_N < (lda - j)) ? (LARGE_N) : (lda - j);\n  {\n    for (int k = 0; k < lda; k += LARGE_K)\n    {\n      int K = (LARGE_K < (lda - k)) ? (LARGE_K) : (lda - k);\n      divide_into_small_blocks(weird_A + ((i * lda) + (k * STRIDE)), B + ((j * lda) + k), C + ((j * lda) + i), M, N, K, lda);\n    }\n\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/20"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    double cellVol = volume[index];\n    double cellMass = cellVol * density[index];\n    vol += cellVol;\n    mass += cellMass;\n    ie += cellMass * energy0[index];\n    temp += cellMass * u[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:vol,ie,temp,mass)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_field_summary/0"}
{"code": "for (int k = 0; k < c1; ++k)\n{\n  result[i][j] += first[i][k] * second[k][j];\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eliah7/OpenMP-Intro/mat_mul_parallel/6"}
{"code": "for (int i = 1; i < (geom1->n_grid_r - 1); i++)\n  for (int k = 1; k < (geom1->n_grid_z - 1); k++)\n{\n  double epsilonx2 = (2 * geom1->epsilon[i][k]) * EPSILON0;\n  double sigma_t = geom1->sigma[i][k] * time1->delta_t;\n  double koef_e = (epsilonx2 - sigma_t) / (epsilonx2 + sigma_t);\n  double koef_h = (2 * time1->delta_t) / (epsilonx2 + sigma_t);\n  field_r[i][k] = (field_r[i][k] * koef_e) - ((j_r[i][k] + ((h_phi[i][k] - h_phi[i][k - 1]) / dz)) * koef_h);\n  field_phi[i][k] = (field_phi[i][k] * koef_e) - (((j_phi[i][k] - ((h_r[i][k] - h_r[i][k - 1]) / dz)) + ((h_z[i][k] - h_z[i - 1][k]) / dr)) * koef_h);\n  field_z[i][k] = (field_z[i][k] * koef_e) - (((j_z[i][k] - ((h_phi[i][k] - h_phi[i - 1][k]) / dr)) - ((h_phi[i][k] + h_phi[i - 1][k]) / ((2.0 * dr) * i))) * koef_h);\n}\n\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/7"}
{"code": "for (int i = 1; i < K; i++)\n  mid_array[i] += mid_array[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/5"}
{"code": "for (int i = 2; i <= bound; i++)\n{\n  if (isprime(i))\n  {\n    checkingPrimes.push_back(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/macluczak/Primes-OpenMP/sito-domen/2"}
{"code": "for (int i = 1; i <= N; ++i)\n{\n  n = i;\n  sum = sum + (1 / n);\n  printf(\"[%d/%d]: %f\\n\", num, num_threads, sum);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/warm_up_tasks/2/0"}
{"code": "for (uint i = 0; i < size; ++i)\n{\n  res[i] = distribution(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chizhang529/cme213/HW1/hw1/main_q1/1"}
{"code": "for (int i = 0; i < nr_centroids; i++)\n{\n  points_accumulator[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/6"}
{"code": "for (round = 0; round < 2; round++)\n{\n  for (j = 0; j < my_starts; j++)\n  {\n    ran[j] = PRK_starts(834568137686317453L + ((nupdate / nstarts) * (j + offset)));\n  }\n\n  for (j = 0; j < my_starts; j++)\n  {\n    for (i = 0; i < (nupdate / (nstarts * 2)); i++)\n    {\n      ran[j] = (ran[j] << 1) ^ ((((s64Int) ran[j]) < 0) ? (0x0000000000000007UL) : (0));\n      index = ran[j] & (tablesize - 1);\n      Table[index] ^= ran[j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Random/random/7"}
{"code": "for (int i = 1; i < (SIZE_X - 1); i++)\n  for (int j = 0; j < SIZE_Y; j++)\n{\n  if (NULL == m_Mesh[i][j])\n    continue;\n\n  switch (m_Mesh[i][j]->GetType())\n  {\n    case HUMAN:\n      nHuman++;\n      if (FEMALE == m_Mesh[i][j]->GetGender())\n      nFemale++;\n    else\n      nMale++;\n\n      break;\n\n    case ZOMBIE:\n      nZambie++;\n      break;\n\n    case INFECTED:\n      nInfected++;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/6"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/60"}
{"code": "for (int i = 0; i < size; i++)\n{\n  arr[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alb3rtov/ARCO/lab3/results/task1/src/maxmin_parallel/0"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.p; j++)\n  {\n    sum = 0;\n    for (k = 0; k < dataSet.m; k++)\n    {\n      sum += dataSet.A[(i * dataSet.m) + k] * dataSet.B[(k * dataSet.p) + j];\n    }\n\n    dataSet.C[(i * dataSet.p) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 40)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fatemehNe/openmp-lab/matrix multiplication/matmulA/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  int *s = mat[i];\n  int res = 0;\n  for (int j = 0; j < SIZE; j++)\n  {\n    res += s[j] * vec[j];\n  }\n\n  resultVector[i] = res;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gerrytty/parallel-programming-course/openMP/task8/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  v[i] = v[i] / norm_val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/9"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  queuelist *recv = new_queuelist(N, sizeof(message));\n  queuelist *send = new_queuelist(N, sizeof(message));\n  begin_timer();\n  init_energy_measure();\n  initialize_graph(g);\n  root_message(g, recv);\n  while (messages_in_queue(g->N, recv))\n  {\n    recv_and_send(g, recv, send);\n    propagate_messages(g, recv, send);\n  }\n\n  total_energy += total_energy_used();\n  duration += time_elapsed();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/bellman_ford/6"}
{"code": "for (i = 0; i < 512; i++)\n  for (j = 0; j < 512; j++)\n{\n  if (((i + j) % 7) == 0)\n    a[i][j] = 2.;\n  else\n    a[i][j] = 0.;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohinarora/OpenMP/Sparse_MatMul_OpenMP/M-M_omp_sparse/1"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  if (a[i] == c)\n  {\n    find2[0] = i;\n    i = 1000;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/search-vector/src/search-vector_gpu/0"}
{"code": "for (int32_t i = 0; i < 10; i++)\n{\n  assert(sum[i].x == 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/cxx/success_for_reduction_10/2"}
{"code": "for (i = 0; i < N; i++)\n  array[i] = malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1a/code/Game_Of_Life/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, cur_salt->salt, cur_salt->length);\n  MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  MD5_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/tcp_md5_fmt_plug/0"}
{"code": "for (int i = 0; i < (w * h); ++i)\n{\n  img[i] = rgb_to_ycbcr(img[i][0], img[i][1], img[i][2]);\n  mx = max(mx, img[i][0]);\n  mn = min(mn, img[i][0]);\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sw1tcherrr/OpenMP-Luma-Normalizer/normalizer/0"}
{"code": "for (int i = 0; i < size_matrix; i++)\n{\n  int adder = 0;\n  for (int j = 0; j < size_matrix; j++)\n  {\n    adder += matrix_A[i][j] * matrix_B[j][a];\n  }\n\n  matrix_Out[i][a] = adder;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/6"}
{"code": "for (size_t i = 0; i < 10; i++)\n{\n  printf(\"\\t\");\n  for (size_t j = 0; j < 10; j++)\n  {\n    printf(\" %d \", B[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/djaliiil/OpenMP/omp_tp1_exo3/3"}
{"code": "for (int i = (rang * n) / nbp; i < (((rang + 1) * n) / nbp); i++)\n  b[i] = PRF(i, seed);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/MPI+OMP+Vect/cg/5"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ++)\n  {\n    if (scanf(\"%f\", &aMatr[wI][wJ]) != 1)\n    {\n      fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d%d\\n\", wI, wJ);\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/12"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i][j - 2][k][m] - (4. * u[i][j - 1][k][m])) + (5. * u[i][j][k][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/112"}
{"code": "for (int i = 0; i < (room_size * room_size); i++)\n{\n  data[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArthurLCW/Heat-Simulation/codes/csc4005-assignment-4-bonus/csc4005-imgui/src/main/2"}
{"code": "for (i = 0; i < num_alive; i++)\n{\n  coordinate x = vector[i]->x;\n  coordinate y = vector[i]->y;\n  coordinate z = vector[i]->z;\n  coordinate x1;\n  coordinate x2;\n  coordinate y1;\n  coordinate y2;\n  coordinate z1;\n  coordinate z2;\n  x1 = (x + 1) % cube_size;\n  x2 = ((x - 1) < 0) ? (cube_size - 1) : (x - 1);\n  y1 = (y + 1) % cube_size;\n  y2 = ((y - 1) < 0) ? (cube_size - 1) : (y - 1);\n  z1 = (z + 1) % cube_size;\n  z2 = ((z - 1) < 0) ? (cube_size - 1) : (z - 1);\n  coordinate c[6][3] = {{x1, y, z}, {x2, y, z}, {x, y1, z}, {x, y2, z}, {x, y, z1}, {x, y, z2}};\n  GraphNode *ptr;\n  for (j = 0; j < 6; j++)\n  {\n    if (graphNodeAddNeighbour(&graph[c[j][X]][c[j][Y]], c[j][Z], &ptr, &graph_lock[c[j][X]][c[j][Y]]))\n    {\n      neighbour_vector[i][j] = nodeInsert(0, c[j][X], c[j][Y], c[j][Z], ptr);\n    }\n    else\n    {\n      neighbour_vector[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/par_grid_hash/par_grid_hash/1"}
{"code": "for (i = 0; i < (dp->dim - 2); i++)\n  fputc('(', fphost);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/21"}
{"code": "for (j = 0; j < N; j++)\n{\n  for (i = 0; i < M; i++)\n    V(u, i, j) += ((-dtdy) * (((V(ut, i + 1, j + 1) + V(ut, i + 1, j)) - V(ut, i, j)) - V(ut, i, j + 1))) - (dtdx * (((V(ut, i + 1, j + 1) + V(ut, i, j + 1)) - V(ut, i, j)) - V(ut, i + 1, j)));\n\n}\n\n", "pragma": "omp parallel for schedule(static) default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongbozhang85/openmp-cuda-advection-solver/openmp/parAdvect/5"}
{"code": "for (i = 0; i < simu_opts->numDE; i++)\n{\n  if (simu_opts->DEID[i] <= topoinfo->numG)\n  {\n    tmprlt->paras[simu_opts->DEID[i] - 1] = tmprlt->paras[simu_opts->DEID[i] - 1] / simu_opts->DEFD[i];\n  }\n  else\n  {\n    printf(\"### Wrong: no gene (#%d) is selected for overexpression.\\n\", simu_opts->DEID[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/81"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n    A[i][j] = rand() % n;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw8/main/3"}
{"code": "for (i = 0; i < 8; ++i)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETLM_fmt_plug/3"}
{"code": "for (i = 3; i <= (grid_points[0] - 4); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/53"}
{"code": "for (int b = 0; b < numBC; b++)\n{\n  bucketTypeBC[b] = domainTypeBC;\n  periodicDirection[b * 3] = periodicDirectionX;\n  periodicDirection[(b * 3) + 1] = periodicDirectionY;\n  periodicDirection[(b * 3) + 2] = periodicDirectionZ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/7"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  phi = pseudo_K0RS[(nuc * input.numL) + i] * sqrt(E);\n  if (i == 1)\n    phi -= -atan(phi);\n  else\n    if (i == 2)\n    phi -= atan((3.0 * phi) / (3.0 - (phi * phi)));\n  else\n    if (i == 3)\n    phi -= atan((phi * (15.0 - (phi * phi))) / (15.0 - ((6.0 * phi) * phi)));\n\n\n\n  phi *= 2.0;\n  sigTfactors[i].r = cos(phi);\n  sigTfactors[i].i = -sin(phi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/rsbench-omp/simulation/6"}
{"code": "for (i = 0; i < _PB_N; i++)\n  for (j = 0; j < _PB_N; j++)\n  A[i][j] = (A[i][j] + (u1[i] * v1[j])) + (u2[i] * v2[j]);\n\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/gemver/gemver/0"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  if (x[i] > mval)\n  {\n    mval = x[i];\n    mloc = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_non_critical/3"}
{"code": "for (i_imopVarPre76 = 0; i_imopVarPre76 < (1 << 11); i_imopVarPre76++)\n{\n  key_buff1[i_imopVarPre76] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/12"}
{"code": "for (int i = 0; i < total_images; ++i)\n{\n  char image_name[256];\n  sprintf(image_name, \"%s%d%s\", image_prefix, i, image_suffix);\n  rc = lodepng_save_file(encoded_images[i], encoded_images_sz[i], image_name);\n  if (rc)\n  {\n    printf(\"save error: %s\\n\", lodepng_error_text(rc));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/9"}
{"code": "for (int i = MAX_ROWS - 1; i >= 0; --i)\n{\n  for (int j = MAX_COLS - 1; j >= 0; --j)\n  {\n    int index = output[(iArray[i][j] / iExp) % 10] - 1;\n    _allData[index / MAX_COLS][index % MAX_COLS] = iArray[i][j];\n    output[(iArray[i][j] / iExp) % 10]--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/26"}
{"code": "for (int i = 0; i < 2000; i++)\n{\n  for (int j = 0; j < 2000; j++)\n  {\n    A[i][j] = j * 1;\n    B[i][j] = (i * j) + 2;\n    C[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KunxiSun/matrix_multiplication_and_openmp_in_c_2/src/q1-avg/2"}
{"code": "for (i = 0; i < l; i++)\n  if (labels[i] > 0)\n  prior1 += 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/39"}
{"code": "for (unsigned int j = 0; j < y_size; j++)\n{\n  b[0][j] = 0;\n  b[1][j] = 0;\n  b[x_size - 1][j] = 0;\n  b[x_size - 2][j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/lib/4"}
{"code": "for (int k = 0; k < M; k++)\n{\n  tmp_edge_list[k].x += pow_2(ib - 1) * ii_bit[k];\n  tmp_edge_list[k].y += pow_2(ib - 1) * jj_bit[k];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/7"}
{"code": "for (j = 1; j < (sizeA + 1); j++)\n{\n  if (seqA[j - 1] == seqB[i - 1])\n  {\n    scoreMatrix[i][j] = scoreMatrix[i - 1][j - 1] + 1;\n  }\n  else\n    if (pMatrix[c_i][j] == 0)\n  {\n    scoreMatrix[i][j] = (scoreMatrix[i - 1][j] > 0) ? (scoreMatrix[i - 1][j]) : (0);\n  }\n  else\n  {\n    scoreMatrix[i][j] = (scoreMatrix[i - 1][j] > (scoreMatrix[i - 1][pMatrix[c_i][j] - 1] + 1)) ? (scoreMatrix[i - 1][j]) : (scoreMatrix[i - 1][pMatrix[c_i][j] - 1] + 1);\n  }\n\n\n}\n\n", "pragma": "omp parallel for num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giov8/lcs-openmp/openmp/lcs/0"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    u[index] += (*alpha) * p[index];\n    r[index] -= (*alpha) * w[index];\n    rrnTemp += r[index] * r[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:rrnTemp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_cg_kernel/5"}
{"code": "for (step = 1; step <= step_num; step++)\n{\n  compute(np, nd, nppadded, pos, vel, mass, force, &potential, &kinetic);\n  if (step == step_print)\n  {\n    printf(\"  %8d  %14f  %14f  %14e\\n\", step, potential, kinetic, ((potential + kinetic) - e0) / e0);\n    step_print_index = step_print_index + 1;\n    step_print = (step_print_index * step_num) / step_print_num;\n  }\n\n  update(np, nd, nppadded, pos, vel, force, acc, mass, dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MD/md_openmp/2"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    A[i][j] = 0.05;\n    B[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Canario0/Openmp/Ejercicio1/Ejercicio1/2"}
{"code": "for (size_t i = 1; i < ((size_t) DARTS_CODELETS_MULT); i++)\n{\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)] = _checkInCodelets872(2, 1, this, localID + (this->baseNumThreads * i));\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)].setID(codeletID);\n  this->checkInCodelets872[localID + (this->baseNumThreads * i)].decDep();\n  this->firstCodelet[localID + (this->baseNumThreads * i)].decDep();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/15"}
{"code": "for (int r = 0; r < bmp->height; r++)\n{\n  for (int c = 0; c < bmp->width; c++)\n  {\n    unsigned char gray = ((bmp->copy_pixels[(r * bmp->width) + c].r * 0.3) + (bmp->copy_pixels[(r * bmp->width) + c].g * 0.59)) + (bmp->copy_pixels[(r * bmp->width) + c].b * 0.11);\n    bmp->pixels[(r * bmp->width) + c].r = gray;\n    bmp->pixels[(r * bmp->width) + c].g = gray;\n    bmp->pixels[(r * bmp->width) + c].b = gray;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Victohu1/ParallelImageProcessor/openmp_image_processor/1"}
{"code": "for (int i = 0; i < source1.rows; i++)\n  for (int j = 0; j < source1.cols; j++)\n  destination(i, j) = mult(source1(i, j), source2(i, j));\n\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/arithOMP/3"}
{"code": "for (i = 0; i < (num_rows * num_vectors); i++)\n  y_data[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/tests/applications/amgmk/amgmk-v1.0_orig/csr_matvec/2"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; ++j)\n  {\n    for (k = 0; k < s; ++k)\n    {\n      m[i][j] += m_1[i][k] * m_2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(m,m_1,m_2) private(i,j,k), schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/matrix/6"}
{"code": "for (int j = 0; j < numHidden2Nodes; ++j)\n{\n  double err = 0.0;\n  for (int k = 0; k < numOutputs; ++k)\n  {\n    err -= out_err[k] * output_weights[k][j];\n  }\n\n  h2_err[j] = err * act_d(layer2[j]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/9"}
{"code": "for (i = 0; i < res; i++)\n{\n  MPval = erf(MP);\n  if (randomNum < MPval)\n  {\n    UB = MP;\n    MP = (LB + UB) / 2.0;\n  }\n  else\n  {\n    LB = MP;\n    MP = (LB + UB) / 2.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/20"}
{"code": "for (i = 0; i < FrontierBitmap->size; i++)\n{\n  if (getBit(FrontierBitmap, i))\n    graphGridSetActivePartitionsMap(graph->grid, i);\n\n}\n\n", "pragma": "omp parallel for default(none) shared(graph,FrontierBitmap) private(i) schedule(dynamic,1024)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/13"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/11"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  Aik = _mm_set1_epi32(A[i][k]);\n  Ai1k = _mm_set1_epi32(A[i + 1][k]);\n  Ai2k = _mm_set1_epi32(A[i + 2][k]);\n  Ai3k = _mm_set1_epi32(A[i + 3][k]);\n  for (j = 0; j < N; j += 4)\n  {\n    Akj = _mm_load_si128((int *) (&A[k][j]));\n    if (i != k)\n    {\n      p = (int *) (&A[i][j]);\n      Aij = _mm_load_si128(p);\n      comp = _mm_add_epi32(Aik, Akj);\n      Aij = _mm_min_epi32(Aij, comp);\n      _mm_store_si128(p, Aij);\n    }\n\n    p = (int *) (&A[i + 1][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai1k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n    p = (int *) (&A[i + 2][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai2k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n    p = (int *) (&A[i + 3][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai3k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1b/part1/codes/fw/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  prev[i] = prev_old[i];\n  data[i] = data_old[i];\n}\n\n", "pragma": "     \t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/scan/lab_scan_link/scan_link/2"}
{"code": "for (int i = partition_start; i < next_partition_start; i++)\n{\n  double row_sum = 0;\n  for (int j = 0; j < matrix_size; j++)\n  {\n    for (int k = 0; k < matrix_size; k++)\n    {\n      row_sum += (*((matrix_a + (i * matrix_size)) + k)) * (*((matrix_b + (j * matrix_size)) + k));\n    }\n\n  }\n\n  if (local_max_sum < row_sum)\n  {\n    local_max_sum = row_sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/malogulko/matrix_norm_omp/matrix_norm_omp/2"}
{"code": "for (int i = 0; i < count; i++)\n{\n  segmentByDistance(in_cloud_ptr[i], cloud_size[i], &out_cloud_ptr[i], &out_boundingbox_array[i], &out_centroids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/14"}
{"code": "for (i = 0; i < (1 << 19); i++)\n{\n  key_buff1[i] += prv_buff1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/8"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if ((((((((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || isnan(mat17[rowcol])) || (mat17[rowcol] <= 0.0)) || (mat16[rowcol] <= 0.0)) || (mat14[rowcol] <= (-100.0))) || (mat14[rowcol] > 9000.0)) || ((mat8[rowcol] * 0.02) <= 250.0))\n  {\n    matOut4[rowcol] = -28768;\n    matOut5[rowcol] = -28768;\n    matOut6[rowcol] = -28768;\n    matOut7[rowcol] = -28768;\n  }\n  else\n    if (((mat8[rowcol] * 0.02) <= 273.15) && ((mat8[rowcol] * 0.02) > 250.0))\n  {\n    matOut4[rowcol] = 0.01;\n    score = score + 1.0;\n    matOut5[rowcol] = et_a(mat15[rowcol], matOut4[rowcol], mat8[rowcol] * 0.02);\n    score_max++;\n    matOut6[rowcol] = -28768;\n    matOut7[rowcol] = -28768;\n  }\n  else\n  {\n    h0 = sensi_h(iteration, (mat8[rowcol] * 0.02) + (0.00627 * mat14[rowcol]), mat1[rowcol] * 0.0001, ndvi_max, mat14[rowcol], Rn_dry, g0_dry, t0dem_dry, t0dem_wet, u2m, dem_dry, doy, &dt);\n    matOut6[rowcol] = dt;\n    matOut4[rowcol] = evap_fr(mat16[rowcol], mat17[rowcol], h0);\n    matOut5[rowcol] = et_a(mat15[rowcol], matOut4[rowcol], mat8[rowcol] * 0.02);\n    matOut7[rowcol] = soilmoisture(matOut4[rowcol]);\n    if ((matOut4[rowcol] < 1.0) && (matOut4[rowcol] > 0.0))\n      score = score + 1.0;\n\n    score_max++;\n  }\n\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol, h0, dt) shared (N,iteration,ndvi_max,Rn_dry,g0_dry,score,score_max, t0dem_wet,t0dem_dry,u2m,doy,dem_dry, mat1,mat2,mat8,mat14,mat15,mat16,mat17, matOut4,matOut5,matOut6,matOut7)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/2"}
{"code": "for (k = 1; k <= (nz - 1); k++)\n{\n  tmp = 1.0 / u[i][j][k][0];\n  u21k = tmp * u[i][j][k][1];\n  u31k = tmp * u[i][j][k][2];\n  u41k = tmp * u[i][j][k][3];\n  u51k = tmp * u[i][j][k][4];\n  tmp = 1.0 / u[i][j][k - 1][0];\n  u21km1 = tmp * u[i][j][k - 1][1];\n  u31km1 = tmp * u[i][j][k - 1][2];\n  u41km1 = tmp * u[i][j][k - 1][3];\n  u51km1 = tmp * u[i][j][k - 1][4];\n  flux[i][j][k][1] = tz3 * (u21k - u21km1);\n  flux[i][j][k][2] = tz3 * (u31k - u31km1);\n  flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * (((pow2(u21k) + pow2(u31k)) + pow2(u41k)) - ((pow2(u21km1) + pow2(u31km1)) + pow2(u41km1)))) + (((1.0 / 6.0) * tz3) * (pow2(u41k) - pow2(u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n}\n\n", "pragma": "omp parallel for firstprivate(nz ,ist ,jst ,u21k ,u31k ,u41k ,u51k ,tmp ,u21km1 ,u31km1 ,u41km1 ,u51km1 ,tz3 ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/87"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    Q[j + (n * (i + (m * 0)))] = 4.0 + (epsi * exp((-(pow(x[i] - (4.0 / 4.0), 2) + pow(y[j] - (4.0 / 4.0), 2))) / pow(delta, 2)));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eduardlopez/swallow-water-simulation-parallel-multiprocessing/swater2D-omp/12"}
{"code": "for (j = i; j < (N - 1); j += 1)\n{\n  if (A[j] > A[j + 1])\n  {\n    swap(&A[j], &A[j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none),shared(A,i,N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denispostilnyak/OpenMP_MPI/OpenMP/main/0"}
{"code": "for (int j = data.iRowFirst + 1; j <= (data.iRowLast - 1); j++)\n{\n  for (int i = 1; i < (data.iCols - 1); i++)\n  {\n    fLRes = ((((ax * (UOLD(j, i - 1) + UOLD(j, i + 1))) + (ay * (UOLD(j - 1, i) + UOLD(j + 1, i)))) + (b * UOLD(j, i))) - F(j, i)) / b;\n    U(j, i) = UOLD(j, i) - (data.fRelax * fLRes);\n    residual += fLRes * fLRes;\n  }\n\n}\n\n", "pragma": "#pragma omp for reduction(+:residual)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenCMISS-Dependencies/opari2/test/data/jacobi/C++/jacobi/1"}
{"code": "for (int i = 0; i < vectorSize; i++)\n  sum += pVector[i];\n\n", "pragma": "#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/VectorSum/VectorSum/1"}
{"code": "for (int i = 0; i < leng; i++)\n  v[i] = (double) (i + 1);\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc2n/OpenMP-Collaboration/Templates/Day_4/Orphaning_Nowait/SampleSolution/C/vectorNormModularOrphanNowait/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    sum = 0;\n    for (k = 0; k < n; k++)\n    {\n      sum += arr1[0][k] * arr2[k][j];\n    }\n\n    result[0][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/vector_matrix_multiplication_openp/1"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValueY = (pixelValueX = 0);\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = qBlue(srcImage->pixel(jj + j, ii + i));\n        pixelValueY += weight_y[i + 1][j + 1] * blue;\n        pixelValueX += weight_x[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    gradient = sqrt(pow(pixelValueY, 2) + pow(pixelValueX, 2));\n    int newPixel = gradient;\n    if (newPixel > 255)\n      newPixel = 255;\n\n    if (newPixel < 0)\n      newPixel = 0;\n\n    dstImage->setPixel(jj, ii, QColor(newPixel, newPixel, newPixel).rgba());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/sobel/sobel2/2"}
{"code": "for (int i = 0; i < npoint; i++)\n{\n  x1[i] = (LCG_random(states + i) - HALF) * FOUR;\n  y1[i] = (LCG_random(states + i) - HALF) * FOUR;\n  z1[i] = (LCG_random(states + i) - HALF) * FOUR;\n  x2[i] = (LCG_random(states + i) - HALF) * FOUR;\n  y2[i] = (LCG_random(states + i) - HALF) * FOUR;\n  z2[i] = (LCG_random(states + i) - HALF) * FOUR;\n  psi[i] = wave_function(x1[i], y1[i], z1[i], x2[i], y2[i], z2[i]);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(NTHR_PER_BLK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vmc-omp/vmc/1"}
{"code": "for (int i = 0; i < num_layers; i++)\n  layer_gconv[i].update_weight(opt);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    printf(\"%.2f, \", matrix[(i * N) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ric0rdanza/HPC_Openmp_GEMV/gemv/2"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  if (percentDiff(z[i], z_outputFromGpu[i]) > 0.5)\n  {\n    fail++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/ATAX/atax/10"}
{"code": "for (int i = 0; i < (Size - 1); i++)\n  for (int j = 1; j < (Size - i); j++)\n  if (pData[j - 1] > pData[j])\n  swap(pData[j - 1], pData[j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/sort/2"}
{"code": "for (int i = 0; i < nnz; ++i)\n{\n  if (cast_map->vec_[i] < 0)\n  {\n    continue;\n  }\n\n  this->mat_.col[row_buffer[cast_map->vec_[i]]] = i;\n  this->mat_.val[i] = (static_cast < ValueType) > 1;\n  row_buffer[cast_map->vec_[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/84"}
{"code": "for (int i = 122; i < 146; ++i)\n{\n  w[i] *= C1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/18"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < M; j++)\n  ref[i][j] = 0.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/7"}
{"code": "for (i = 0; i < 5; i++)\n  a[i] = i * i;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/master/0"}
{"code": "for (int k = 0; k < num_threads; k++)\n{\n  prime.insert(prime.end(), p_n[k].start(), p_n[k].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/prime/prime0/prime/0"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    fread(&target[x][y], sizeof(pixel), 1, image_file);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tino415/papp-openmp/main_mpi/2"}
{"code": "for (i = 0; i < dim; i++)\n  for (j = 0; j < dim; j++)\n  for (k = i + 1; k < dim; k++)\n  C[(i * dim) + j] += A[(i * dim) + k] * B[j + (k * dim)];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZdravkoDimitrovArnaudov/PPCTR/p3/src/matmul/7"}
{"code": "for (j = 0; j < n; j++)\n{\n  y[j] = y[j] / a[j + (j * n)];\n  for (i = j + 1; i < n; i++)\n  {\n    y[i] -= a[i + (j * n)] * y[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/12"}
{"code": "for (i = 1; i < (1 << 16); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/5"}
{"code": "for (int i = 0; i < m_cellSize; i++)\n{\n  m_PE[i] = 0.0f;\n  m_INFIL[i] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SUR_GA/SUR_GreenAmpt/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[iy] = y[iy] + (a * x[ix]);\n  ix = ix + incx;\n  iy = iy + incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/9"}
{"code": "for (int j = i; j < end; j++)\n{\n  if ((contents[j] == '\"') && (r == 1))\n  {\n    end = j;\n    break;\n  }\n\n  if (contents[j] == '\"')\n    r++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Po-Y-H/Parallel-Web-Crawler-by-OpenMP/03_ps/Crawler/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"[\");\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d, \", mat[i][j]);\n  }\n\n  printf(\"], \\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q1/3"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    if (percentDiff(G[(i * 2048) + j], G_outputFromGpu[(i * 2048) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/3MM/3mm/11"}
{"code": "for (i = 0; i < n1; i++)\n  L[i] = arr[l + i];\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/egeigel/advanced-openmp/Downloads/assignment-advanced-openmp/mergesort/0"}
{"code": "for (int ci = 1; ci < NCELLS; ci++)\n  cell(ci).printVertexPositions(packingPrintObject, ci);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/80"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB001-antidep1-orig-yes/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    lhs[1][i + 1][j][k] = lhs[1][i + 1][j][k] - comz4;\n    lhs[2][i + 1][j][k] = lhs[2][i + 1][j][k] + comz6;\n    lhs[3][i + 1][j][k] = lhs[3][i + 1][j][k] - comz4;\n    lhs[4][i + 1][j][k] = lhs[4][i + 1][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/5"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    Dxu[IDX(3, j, k)] = ((((-3.0) * u[IDX(3, j, k)]) + (4.0 * u[IDX(4, j, k)])) - u[IDX(5, j, k)]) * idx_by_2;\n    if (betax[IDX(4, j, k)] > 0.0)\n    {\n      Dxu[IDX(4, j, k)] = ((((-3.0) * u[IDX(4, j, k)]) + (4.0 * u[IDX(5, j, k)])) - u[IDX(6, j, k)]) * idx_by_2;\n    }\n    else\n    {\n      Dxu[IDX(4, j, k)] = ((-u[IDX(3, j, k)]) + u[IDX(5, j, k)]) * idx_by_2;\n    }\n\n    if (betax[IDX(5, j, k)] > 0.0)\n    {\n      Dxu[IDX(5, j, k)] = ((((((-3.0) * u[IDX(4, j, k)]) - (10.0 * u[IDX(5, j, k)])) + (18.0 * u[IDX(6, j, k)])) - (6.0 * u[IDX(7, j, k)])) + u[IDX(8, j, k)]) * idx_by_12;\n    }\n    else\n    {\n      Dxu[IDX(5, j, k)] = ((u[IDX(3, j, k)] - (4.0 * u[IDX(4, j, k)])) + (3.0 * u[IDX(5, j, k)])) * idx_by_2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/26"}
{"code": "for (i = 1; i <= 4; i++)\n{\n  for (j = 1; j <= 4; j++)\n  {\n    if (j == i)\n    {\n      costarr[i][j] = 0;\n      continue;\n    }\n    else\n    {\n      printf(\"Enter path cost between path %d and path %d : \", i, j);\n      scanf(\"%d\", &costarr[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/tsp_ppt/5"}
{"code": "for (int i = 0; i < 8; i++)\n  for (int j = 0; j < 8; j++)\n  a[i][j] = b[i][j];\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cppxaxa/openmp_heat_equation/OMP_Heat_Equation/Source/4"}
{"code": "for (int i = 0; i < (total_threads + 1); i++)\n{\n  offset += aux_arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarshiniKoduru/OpenMp/prefixsum/prefixsum/0"}
{"code": "for (long i = 0; i < vecsize; ++i)\n{\n  rsp[i] = func(srcp1[i], srcp2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hfxunlp/pamath/double_math_core/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  dky2 = dky * dky;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    at1 = 1. / ((dkx * dkx) + dky2);\n    zt1 = at1 * ((dkx * cu[(3 * j) + (3 * kj)]) + (dky * cu[(1 + (3 * j)) + (3 * kj)]));\n    cu[(3 * j) + (3 * kj)] -= dkx * zt1;\n    cu[(1 + (3 * j)) + (3 * kj)] -= dky * zt1;\n    zt1 = at1 * ((dkx * cu[(3 * j) + (3 * k1)]) - (dky * cu[(1 + (3 * j)) + (3 * k1)]));\n    cu[(3 * j) + (3 * k1)] -= dkx * zt1;\n    cu[(1 + (3 * j)) + (3 * k1)] += dky * zt1;\n  }\n\n  cu[1 + (3 * kj)] = zero;\n  cu[3 * k1] = zero;\n  cu[1 + (3 * k1)] = zero;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kj,dky,dky2,dkx,at1,zt1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/9"}
{"code": "for (k = 0; k <= (nz - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    frct[i][j][k][m] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/11"}
{"code": "for (v = 0; v < num_vertices; v++)\n{\n  pageRanksFP[v] = FloatToFixed32SORT(pageRanks[v]);\n  pageRanksFPTemp[v] = 0;\n  labelsTemp[v] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/0"}
{"code": "for (int i = 0; i < length; i++)\n{\n  a[i] = i;\n  b[i] = i * ((double) 2);\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosepb/BLAS_LAPACK__MPI_OpenMP_CUDA/MNC/Entrega8/Practica1/Main/0"}
{"code": "for (int i = 0; i < dim; i++)\n  for (int k = i; k < dim; k++)\n  kadane(i, k);\n\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/max/1"}
{"code": "for (i = 0; i < nout; i++)\n  _hull.push_back(data0[hullbuf[i]]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/3"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  if (abs(((c * a[i].v_) + verification[i].v_) - b[i].v_) >= 1e-6)\n  {\n    ((((((cout << \"Failed index: \") << i) << \". \") << ((c * a[i].v_) + verification[i].v_)) << \" =! \") << b[i].v_) << endl;\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_saxpy/run_padding_struct/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (tryNewQueen(queenPlaced, currentRow, i))\n  {\n    newQueenPlaced[currentRow] = i;\n    subResult += search(newQueenPlaced, N, currentRow + 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ValentinDeguil/n-queen-OpenMP/queenParallel/3"}
{"code": "for (int it = 0; it < iter; it++)\n{\n  for (int i = 0; i < source.rows; i++)\n  {\n    for (int j = 0; j < source.cols; j++)\n    {\n      destination(i, j) = knn(i, j, source, ksize, percent);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/knnOMP/2"}
{"code": "for (int ix = 2; ix < (nx + 2); ix++)\n{\n  for (int iy = 2; iy < (ny + 2); iy++)\n  {\n    for (int iz = 2; iz < (nz + 2); iz++)\n    {\n      int s = columnMajorLinearIndex(ix, iy, iz, nx + 4, ny + 4, nz + 4);\n      energy_density_evoution[0][ix - 2][iy - 2][iz - 2] = energy_density_evoution[1][ix - 2][iy - 2][iz - 2];\n      for (int ivar = 0; ivar < 16; ivar++)\n      {\n        hydrodynamic_evoution[ivar][0][ix - 2][iy - 2][iz - 2] = hydrodynamic_evoution[ivar][1][ix - 2][iy - 2][iz - 2];\n      }\n\n      energy_density_evoution[1][ix - 2][iy - 2][iz - 2] = (double) e[s];\n      hydrodynamic_evoution[0][1][ix - 2][iy - 2][iz - 2] = (double) u->ux[s];\n      hydrodynamic_evoution[1][1][ix - 2][iy - 2][iz - 2] = (double) u->uy[s];\n      hydrodynamic_evoution[2][1][ix - 2][iy - 2][iz - 2] = (double) u->un[s];\n      hydrodynamic_evoution[3][1][ix - 2][iy - 2][iz - 2] = (double) e[s];\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/freezeout/FreezeOut/1"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  for (i = 0; i < 1; ++i)\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    cracked[index + i] = vmx_decrypt(cur_salt, master[i], cur_salt->blob);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vmx_fmt_plug/0"}
{"code": "for (int i = 0; i < (N_POINTS - 1); i += 1)\n{\n  long double min_val = infinity();\n  int min_idx = -1;\n  for (int j = i + 1; j < N_POINTS; j += 1)\n  {\n    long double cost = tsp_hop_cost(cities.at(i), cities.at(j)).second;\n    if (cost < min_val)\n    {\n      min_idx = j;\n      min_val = cost;\n    }\n\n  }\n\n  swap(cities.at(i + 1), cities.at(min_idx));\n  if (TEST_MODE)\n  {\n    ((cout << \"[ITERATION \") << i) << \"]\";\n    print_tsp_tour_cost(tsp_tour_cost(cities));\n    export_graph_newtork_array(cities, \"graph\" + to_string(i));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/tsp/tsp/Utilities/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  fprintf(file, \"%0.16lf\\n\", (double) array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task10/main/9"}
{"code": "for (int I = 0; I < 10; ++I)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_reduction_codegen_UDR/0"}
{"code": "for (int i = 1; i <= n; ++i)\n{\n  double l = leftIndex + ((i - 1) * h);\n  double r = leftIndex + (i * h);\n  area += (f1(l) + f1(r)) / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/parallelFor/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  info(\"OpenMP thread: {0}\", getThreadNumber());\n  result[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soerenPeters/cpp_start/src/openmp_example/OpenMP_example/0"}
{"code": "for (i = 0; i < f; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    m[(i * ld) + j] = (double) (i + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muriloboratto/hands-on-supercomputing-with-parallel-computing/Hands-On-5-Basic-Hybrid-Application-MPI+OpenMP/material/mm-mpi+openmp/1"}
{"code": "for (int i = 3; i <= sqr; i += 2)\n{\n  if ((x % i) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/labs/Lab6/Software/OpenMP/next_prime/1"}
{"code": "for (row = 0; row < N; row++)\n{\n  for (col = 0; col < N; col++)\n  {\n    printf(\"%.1lf%s\", B[row][col], (col < (N - 1)) ? (\",\") : (\";\\n\\t\"));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixcpy/5"}
{"code": "for (i = 0; i < Entries_N; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    k = Indices[pos++];\n    int now = tempX[(j * max_dim) + k];\n    WhereX[now] = i;\n    tempX[(j * max_dim) + k]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/3"}
{"code": "for (j = 0; j < np; j++)\n{\n  for (i = 0; i < nd; i++)\n  {\n    vel[i + (j * nd)] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/md/3"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleType[i] == fluid) && (particleNearWall[i] == true))\n  {\n    double sum1 = 0.0;\n    double sum2 = 0.0;\n    double sum3 = 0.0;\n    double sum4 = 0.0;\n    double sum5 = 0.0;\n    double sum6 = 0.0;\n    double sum7 = 0.0;\n    double sum8 = 0.0;\n    double sum9 = 0.0;\n    double sum10 = 0.0;\n    double posXi = pos[i * 3];\n    double posYi = pos[(i * 3) + 1];\n    double posZi = pos[(i * 3) + 2];\n    double velXi = vel[i * 3];\n    double velYi = vel[(i * 3) + 1];\n    double velZi = vel[(i * 3) + 2];\n    double posMirrorXi = mirrorParticlePos[i * 3];\n    double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n    double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n    double Rref_i[9];\n    double Rinv_i[9];\n    double normaliw[3];\n    double normalMod2;\n    normaliw[0] = 0.5 * (posXi - posMirrorXi);\n    normaliw[1] = 0.5 * (posYi - posMirrorYi);\n    normaliw[2] = 0.5 * (posZi - posMirrorZi);\n    normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n    if (normalMod2 > 1.0e-8)\n    {\n      double normalMod = sqrt(normalMod2);\n      normaliw[0] = normaliw[0] / normalMod;\n      normaliw[1] = normaliw[1] / normalMod;\n      normaliw[2] = normaliw[2] / normalMod;\n    }\n    else\n    {\n      normaliw[0] = 0;\n      normaliw[1] = 0;\n      normaliw[2] = 0;\n    }\n\n    Rinv_i[0] = -1.0;\n    Rinv_i[1] = 0.0;\n    Rinv_i[2] = 0.0;\n    Rinv_i[3] = 0.0;\n    Rinv_i[4] = -1.0;\n    Rinv_i[5] = 0.0;\n    Rinv_i[6] = 0.0;\n    Rinv_i[7] = 0.0;\n    Rinv_i[8] = -1.0;\n    Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n    Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n    Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n    Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n    Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n    Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n    Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n    Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n    Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n    double viwall[3];\n    double vtil[3];\n    viwall[0] = (viwall[1] = (viwall[2] = 0.0));\n    if (nearMeshType[i] == FORCED)\n    {\n      viwall[0] = velVWall[0];\n      viwall[1] = velVWall[1];\n      viwall[2] = velVWall[2];\n    }\n\n    double dotnv = ((normaliw[0] * viwall[0]) + (normaliw[1] * viwall[1])) + (normaliw[2] * viwall[2]);\n    vtil[0] = velXi - (2.0 * (viwall[0] - (dotnv * normaliw[0])));\n    vtil[1] = velYi - (2.0 * (viwall[1] - (dotnv * normaliw[1])));\n    vtil[2] = velZi - (2.0 * (viwall[2] - (dotnv * normaliw[2])));\n    double velMirrorXi = ((Rinv_i[0] * vtil[0]) + (Rinv_i[1] * vtil[1])) + (Rinv_i[2] * vtil[2]);\n    double velMirrorYi = ((Rinv_i[3] * vtil[0]) + (Rinv_i[4] * vtil[1])) + (Rinv_i[5] * vtil[2]);\n    double velMirrorZi = ((Rinv_i[6] * vtil[0]) + (Rinv_i[7] * vtil[1])) + (Rinv_i[8] * vtil[2]);\n    int ix;\n    int iy;\n    int iz;\n    bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n    int minZ = (iz - 1) * ((int) (dim - 2.0));\n    int maxZ = (iz + 1) * ((int) (dim - 2.0));\n    for (int jz = minZ; jz <= maxZ; jz++)\n    {\n      for (int jy = iy - 1; jy <= (iy + 1); jy++)\n      {\n        for (int jx = ix - 1; jx <= (ix + 1); jx++)\n        {\n          int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n          int j = firstParticleInBucket[jb];\n          if (j == (-1))\n            continue;\n\n          double plx;\n          double ply;\n          double plz;\n          getPeriodicLengths(jb, plx, ply, plz);\n          while (true)\n          {\n            double v0ij;\n            double v1ij;\n            double v2ij;\n            double v0imj;\n            double v1imj;\n            double v2imj;\n            double dstij2;\n            double dstimj2;\n            sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n            sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n            if (((dstij2 < reS2) && (dstimj2 < reS2)) && (dstij2 < dstimj2))\n            {\n              if (j != i)\n              {\n                double dst = sqrt(dstimj2);\n                double wS = weight(dst, reS, weightType);\n                double vec_mijx = vel[j * 3] - velMirrorXi;\n                double vec_mijy = vel[(j * 3) + 1] - velMirrorYi;\n                double vec_mijz = vel[(j * 3) + 2] - velMirrorZi;\n                sum1 += ((vec_mijx * v0imj) * wS) / dstimj2;\n                sum2 += ((vec_mijx * v1imj) * wS) / dstimj2;\n                sum3 += ((vec_mijx * v2imj) * wS) / dstimj2;\n                sum4 += ((vec_mijy * v0imj) * wS) / dstimj2;\n                sum5 += ((vec_mijy * v1imj) * wS) / dstimj2;\n                sum6 += ((vec_mijy * v2imj) * wS) / dstimj2;\n                sum7 += ((vec_mijz * v0imj) * wS) / dstimj2;\n                sum8 += ((vec_mijz * v1imj) * wS) / dstimj2;\n                sum9 += ((vec_mijz * v2imj) * wS) / dstimj2;\n                sum10 += press[j] * wS;\n              }\n\n            }\n\n            j = nextParticleInSameBucket[j];\n            if (j == (-1))\n              break;\n\n          }\n\n        }\n\n      }\n\n    }\n\n    Uxx = coeffPressGrad * (((sum1 * Rref_i[0]) + (sum2 * Rref_i[3])) + (sum3 * Rref_i[6]));\n    Uxy = coeffPressGrad * (((sum1 * Rref_i[1]) + (sum2 * Rref_i[4])) + (sum3 * Rref_i[7]));\n    Uxz = coeffPressGrad * (((sum1 * Rref_i[2]) + (sum2 * Rref_i[5])) + (sum3 * Rref_i[8]));\n    Uyx = coeffPressGrad * (((sum4 * Rref_i[0]) + (sum5 * Rref_i[3])) + (sum6 * Rref_i[6]));\n    Uyy = coeffPressGrad * (((sum4 * Rref_i[1]) + (sum5 * Rref_i[4])) + (sum6 * Rref_i[7]));\n    Uyz = coeffPressGrad * (((sum4 * Rref_i[2]) + (sum5 * Rref_i[5])) + (sum6 * Rref_i[8]));\n    Uzx = coeffPressGrad * (((sum7 * Rref_i[0]) + (sum8 * Rref_i[3])) + (sum9 * Rref_i[6]));\n    Uzy = coeffPressGrad * (((sum7 * Rref_i[1]) + (sum8 * Rref_i[4])) + (sum9 * Rref_i[7]));\n    Uzz = coeffPressGrad * (((sum7 * Rref_i[2]) + (sum8 * Rref_i[5])) + (sum9 * Rref_i[8]));\n    p_smooth[i] += sum10 / pndGradientZero;\n    if (p_smooth[i] < 1.0e-8)\n      p_smooth[i] = 0.0;\n\n    S11[i] = 0.5 * (Uxx + Uxx);\n    S12[i] = 0.5 * (Uxy + Uyx);\n    S13[i] = 0.5 * (Uxz + Uzx);\n    S22[i] = 0.5 * (Uyy + Uyy);\n    S23[i] = 0.5 * (Uyz + Uzy);\n    S33[i] = 0.5 * (Uzz + Uzz);\n    II[i] += 0.5 * ((((((S11[i] * S11[i]) + ((2.0 * S12[i]) * S12[i])) + ((2.0 * S13[i]) * S13[i])) + (S22[i] * S22[i])) + ((2.0 * S23[i]) * S23[i])) + (S33[i] * S33[i]));\n    if ((II[i] < 1.0e-8) || ((II[i] * 0) != 0))\n      II[i] = 0.0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic,64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/72"}
{"code": "for (int proc = 0; proc < num_procs; proc++)\n{\n  if ((proc != rank) && (sendTo[proc] == 1))\n  {\n    MPI_Isend(sendBuf[proc], n, (MPI_Datatype) 0x4c000405, proc, 1, (MPI_Comm) 0x44000000, &request);\n    sendTo[proc] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/12"}
{"code": "for (uint32_t px = 0; px < (pOutImage->width * pOutImage->height); px++)\n{\n  unNormalizedGradient.data[px] = norm2(pInMatrixX->data[px], pInMatrixY->data[px]);\n}\n\n", "pragma": "omp parallel for shared(unNormalizedGradient)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ricordel/parallel-sobel/sobel/implem_omp/4"}
{"code": "for (int i = -2; i <= 2; i++)\n{\n  for (int j = -2; j <= 2; j++)\n  {\n    double temp_res = 1 / (((((5 * (i + 2)) + j) + 3) + pow(x - (16 * j), 6)) + pow(y - (16 * i), 6));\n    result += abs(temp_res);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dubovyk/OpenMP_integrate/main/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  sum_local[m] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/l2norm/1"}
{"code": "for (int ii = 1; ii < (siz - 1); ii++)\n{\n  for (int j = 1; j < (siz - 1); j++)\n  {\n    grid_n[ii][j] = grid[ii][j] + (((kappa * dt) * ((((grid[ii - 1][j] + grid[ii + 1][j]) + grid[ii][j - 1]) + grid[ii][j + 1]) - (4 * grid[ii][j]))) / sq(dx));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(nthreads) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/2"}
{"code": "for (int i = 1; i < (nx + 1); i++)\n{\n  int j = 1;\n  for (; j < end_ny_V_2; j += VECTOR_LENGTH)\n  {\n    float maxEdgeSpeed;\n    wavePropagationSolver.computeNetUpdates_SIMD(&h[i][j - 1], &h[i][j], &hv[i][j - 1], &hv[i][j], &b[i][j - 1], &b[i][j], &hNetUpdatesBelow[i - 1][j - 1], &hNetUpdatesAbove[i - 1][j - 1], &hvNetUpdatesBelow[i - 1][j - 1], &hvNetUpdatesAbove[i - 1][j - 1], maxEdgeSpeed);\n    l_maxWaveSpeed = max(l_maxWaveSpeed, maxEdgeSpeed);\n    maxWaveSpeed = max(maxWaveSpeed, maxEdgeSpeed);\n  }\n\n  #pragma simd\n  for (; j < end_ny_1_2; j++)\n  {\n    float maxEdgeSpeed;\n    wavePropagationSolver.computeNetUpdates(h[i][j - 1], h[i][j], hv[i][j - 1], hv[i][j], b[i][j - 1], b[i][j], hNetUpdatesBelow[i - 1][j - 1], hNetUpdatesAbove[i - 1][j - 1], hvNetUpdatesBelow[i - 1][j - 1], hvNetUpdatesAbove[i - 1][j - 1], maxEdgeSpeed);\n    l_maxWaveSpeed = max(l_maxWaveSpeed, maxEdgeSpeed);\n    maxWaveSpeed = max(maxWaveSpeed, maxEdgeSpeed);\n  }\n\n  assert(j = ny + 2);\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_WavePropagationBlockSIMD/1"}
{"code": "for (iY = 0; iY < size; iY++)\n{\n  Cy = CyMin + (iY * PixelHeight);\n  if (fabs(Cy) < (PixelHeight / 2))\n    Cy = 0.0;\n\n  for (iX = 0; iX < size; iX++)\n  {\n    iter++;\n    Cx = CxMin + (iX * PixelWidth);\n    Zx = 0.0;\n    Zy = 0.0;\n    Zx2 = Zx * Zx;\n    Zy2 = Zy * Zy;\n    for (Iteration = 0; (Iteration < IterationMax) && ((Zx2 + Zy2) < ER2); Iteration++)\n    {\n      Zy = ((2 * Zx) * Zy) + Cy;\n      Zx = (Zx2 - Zy2) + Cx;\n      Zx2 = Zx * Zx;\n      Zy2 = Zy * Zy;\n    }\n\n    if (Iteration != IterationMax)\n    {\n      *((colo + (xc * size)) + yc) = 1;\n    }\n\n    xc++;\n  }\n\n  xc = 0;\n  yc++;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cheshie/ParallelComputing/mandelbrot_omp/3"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->fvsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n      }\n\n      if (graph->ivsizes[i] < 0)\n      {\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n      }\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = strtof(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n        }\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n        {\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n        }\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = (float) strtod(head, &tail);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n        {\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n        }\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/30"}
{"code": "for (i = 0; (i + 63) < n; i += 64)\n{\n  _mm_prefetch((const char *) (&x[i + 16]), _MM_HINT_T0);\n  xv[0] = _mm256_loadu_pd(&x[i + 0]);\n  xv[1] = _mm256_loadu_pd(&x[i + 4]);\n  xv[2] = _mm256_loadu_pd(&x[i + 8]);\n  xv[3] = _mm256_loadu_pd(&x[i + 12]);\n  xv[4] = _mm256_loadu_pd(&x[i + 16]);\n  _mm_prefetch((const char *) (&x[i + 32]), _MM_HINT_T0);\n  xv[5] = _mm256_loadu_pd(&x[i + 20]);\n  xv[6] = _mm256_loadu_pd(&x[i + 24]);\n  xv[7] = _mm256_loadu_pd(&x[i + 28]);\n  xv[8] = _mm256_loadu_pd(&x[i + 32]);\n  _mm_prefetch((const char *) (&x[i + 48]), _MM_HINT_T0);\n  xv[9] = _mm256_loadu_pd(&x[i + 36]);\n  xv[10] = _mm256_loadu_pd(&x[i + 40]);\n  xv[11] = _mm256_loadu_pd(&x[i + 44]);\n  xv[12] = _mm256_loadu_pd(&x[i + 48]);\n  _mm_prefetch((const char *) (&x[i + 64]), _MM_HINT_T0);\n  xv[13] = _mm256_loadu_pd(&x[i + 52]);\n  xv[14] = _mm256_loadu_pd(&x[i + 56]);\n  xv[15] = _mm256_loadu_pd(&x[i + 60]);\n  _mm256_storeu_pd(&y[i + 0], xv[0]);\n  _mm256_storeu_pd(&y[i + 4], xv[1]);\n  _mm256_storeu_pd(&y[i + 8], xv[2]);\n  _mm256_storeu_pd(&y[i + 12], xv[3]);\n  _mm256_storeu_pd(&y[i + 16], xv[4]);\n  _mm256_storeu_pd(&y[i + 20], xv[5]);\n  _mm256_storeu_pd(&y[i + 24], xv[6]);\n  _mm256_storeu_pd(&y[i + 28], xv[7]);\n  _mm256_storeu_pd(&y[i + 32], xv[8]);\n  _mm256_storeu_pd(&y[i + 36], xv[9]);\n  _mm256_storeu_pd(&y[i + 40], xv[10]);\n  _mm256_storeu_pd(&y[i + 44], xv[11]);\n  _mm256_storeu_pd(&y[i + 48], xv[12]);\n  _mm256_storeu_pd(&y[i + 52], xv[13]);\n  _mm256_storeu_pd(&y[i + 56], xv[14]);\n  _mm256_storeu_pd(&y[i + 60], xv[15]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/19"}
{"code": "for (int i = 0; i < nrow; ++i)\n{\n  for (int j = src.row_offset[i]; j < src.row_offset[i + 1]; ++j)\n  {\n    if (i == src.col[j])\n    {\n      ++diag_entries;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_conversion/0"}
{"code": "for (j = 0; j < (*(nb_spqx + i)); j++)\n{\n  int x;\n  int y;\n  int p;\n  int iam2;\n  double sumBlock;\n  iam2 = omp_get_thread_num();\n  p = j / (z * v);\n  y = (j % (z * v)) / z;\n  x = (j % (z * v)) % z;\n  sumBlock = 0;\n  sumBlock = SummatoryBlock3D(x, y, p, z, v, w, matrixdata, divider);\n  for (int r = 0; r < NumQs; r++)\n    if (sumBlock != 0)\n    *((SPQxThrdvsNumQ + r) + (iam2 * NumQs)) += pow(sumBlock / totalsum, *(qval + r));\n\n\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/22"}
{"code": "for (i = lastRow - 1; i >= 0; i--)\n{\n  if (i == 0)\n    parent = parent * (-1);\n\n  pathArr[i] = parent;\n  parent = subMat[i][parent].nodeParent;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagishoffer/Parallel-Computing/MPI_CUDA_OPENMP/MPI_CUDA_OPENMP/main/16"}
{"code": "for (it = 0; it < num_its; it++)\n{\n  if ((devtype == OMP_DEVICE_THSIM) || (devtype == OMP_DEVICE_HOSTCPU))\n  {\n    BEGIN_SERIALIZED_PRINTF(off->devseqid);\n    printf(\"udev: dev: %d, %dX%d\\n\", off->devseqid, n, m);\n    print_array_dev(\"udev\", off->devseqid, \"u\", (REAL *) u, n, m, k);\n    printf(\"uolddev: dev: %d, %dX%d\\n\", off->devseqid, uold_0_length, uold_1_length);\n    print_array_dev(\"uolddev\", off->devseqid, \"uold\", (REAL *) uold, uold_0_length, uold_1_length);\n    printf(\"i_start: %d, j_start: %d, n: %d, m: %d, k: %d, uold_0_offset: %d, uold_1_offset: %d\\n\", i_start, j_start, n, m, k, uold_0_offset, uold_1_offset);\n    END_SERIALIZED_PRINTF();\n    int ix;\n    int iy;\n    int iz;\n    int ir;\n    for (ix = start; ix < (start + len); ix++)\n    {\n      REAL *temp_u = &u[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n      REAL *temp_uold = &uold[(((ix + radius) * u_dimY) * u_dimZ) + radius];\n      for (iy = 0; iy < m; iy++)\n      {\n        for (iz = 0; iz < k; iz++)\n        {\n          REAL result = temp_uold[0] * coeff[0];\n          for (ir = 1; ir <= radius; ir++)\n          {\n            result += coeff[ir] * temp_uold[ir];\n            result += coeff[-ir] * temp_uold[-ir];\n            result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n            result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n            result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimZ];\n            result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimZ];\n          }\n\n          *temp_u = result / count;\n          temp_u++;\n          temp_uold++;\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"device type is not supported for this call\\n\");\n  }\n\n  pthread_barrier_wait(&off->off_info->inter_dev_barrier);\n  if ((it % 2) == 0)\n    omp_halo_region_pull(map_u, 0, OMP_DATA_MAP_EXCHANGE_FROM_LEFT_RIGHT);\n  else\n    omp_halo_region_pull(map_uold, 0, OMP_DATA_MAP_EXCHANGE_FROM_LEFT_RIGHT);\n\n  REAL *tmp = uold;\n  uold = u;\n  u = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/stencil3d/kernel_launcher/2"}
{"code": "for (int j = 1; j < (ny - 1); j++)\n  for (int k = 1; k < (nz - 1); k++)\n{\n  imageX[0][j][k] = vectorX[0][j][k] - injE[0];\n  imageY[0][j][k] = vectorY[0][j][k] - injE[1];\n  imageZ[0][j][k] = vectorZ[0][j][k] - injE[2];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/105"}
{"code": "for (int i = 1; i < (SIZE - 1); i++)\n{\n  b[i] = ((a[i - 1] + a[i]) + a[i + 1]) / 3.0;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task8/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpbmr7_ij0.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"i : %d \\t THREAD : %d\\n\", i, omp_get_thread_num());\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/Praveen/codes/parallel/DIRECTIVE/ordered/0"}
{"code": "for (int curr_index = 0; curr_index < uLens[i]; curr_index += 16)\n{\n  AddRoundKey(uData[i] + curr_index, expandedKey);\n  for (int n_rounds = 1; n_rounds <= 10; ++n_rounds)\n    Round(uData[i] + curr_index, expandedKey + (n_rounds * 16), n_rounds == 10);\n\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurupunskill/parallel-aes/src/cnc/cnc-encrypt/0"}
{"code": "for (int i = sx; i <= ex; i++)\n  for (int j = sy; j <= ey; j++)\n  for (int k = sz; k <= ez; k++)\n  get(next, i, j, k) = phi(L_X, L_Y, L_Z, H_X * i, H_Y * j, H_Z * k);\n\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haalon-old/parallel2020/block/1"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  cursum += a[i];\n  printf(\"Thread no : %d\\t i = %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aadhityasw/VIT-Labs/Parallel_Distributed_Computing_CSE_4001/OpenMP_Constructs_Lab_2/array_sum/0"}
{"code": "for (size_t l = 1; l < MAX_THREADS; l++)\n{\n  sum_val += suminfo[l].val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m7azeem/HPC-OpenMP/part3/1.5/remove_false_sharing_sum/1"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  if (adjacent_processes[i] != 0)\n  {\n    continue;\n  }\n\n  adjacent_processes[i] = (node_t *) calloc(1, sizeof(node_t));\n  adjacent_processes[i]->rank = adjacent_processes_rank[i];\n  for (int j = i + 1; j < 8; j++)\n  {\n    if (adjacent_processes_rank[j] == adjacent_processes_rank[i])\n    {\n      adjacent_processes[j] = adjacent_processes[i];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/mpi/simpar-mpi/2"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    a[i][j] = rand() % 10;\n    printf(\"%d \", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IvanOnJava/OpenMP_examples/OpenMP_example_SortMatrixColumns_one/0"}
{"code": "for (int i = 0; i < N; ++i)\n  sum += a[i];\n\n", "pragma": "        #pragma omp parallel for schedule(static) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pchenik/OpenMP_Tasks/Task11/main/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = rand() % (n * 100);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/santaboi/hw5-openmp-/hw5_problem1/0"}
{"code": "for (int i = 0; i < tasks; i++)\n{\n  if (!task_done[i])\n  {\n    for (int j = 0; j < (level - 1); j++)\n    {\n      fprintf(cp, \"%d \", options[i][j]);\n    }\n\n    fprintf(cp, \"%d\\n\", options[i][level - 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/25"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < rows; j++)\n    mu[i][j] = 0.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-Kmeans/k_means/8"}
{"code": "for (j = 0; j < length; ++j)\n  tab[j] = first_char + ((loop_size / omp_get_num_threads()) * omp_get_thread_num());\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Yulypso/Richarallele/OpenMp/Ex3/breaker_for/1"}
{"code": "for (c = 0; c < m; c++)\n{\n  for (d = 0; d < n; d++)\n  {\n    first[c][d] = (c + d) / 2;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javierchacon262/IntroPP2160044_1/omp_matrixMultiplication/0"}
{"code": "for (i = 0; i < imageHeight; i++)\n{\n  for (j = 0; j < imageWidth; j++)\n  {\n    int index = (i * imageWidth) + j;\n    PPMPixel *tem = output->data + index;\n    Iterations[i][j] = findIterations(convertedX(j), convertedY(i));\n    long int tem2 = Iterations[i][j];\n    tem2 = 255.0 - ((tem2 * 255.0) / ((double) maxIteration));\n    tem->red = tem2;\n    tem->green = tem2 * 8;\n    tem->blue = tem2 * 4;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Meet-Rayvadera/Parallelization-of-Plotting-The-Fractal-Structure-Mandelbrot-Set/Codes_serial_parallel/parallel_measurement_Approach_Rowwise/0"}
{"code": "for (long i = 0; i < 10; i++)\n{\n  for (int u = 0; u < 100000000; u++)\n  {\n    result++;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/test_loopx2/0"}
{"code": "for (numOfThreads = 1; numOfThreads <= 16; ++numOfThreads)\n{\n  C = ProductLine(A, B, heightA, size, lengthB, true);\n  printf(\"%f\\n\", runtime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task4test/0"}
{"code": "for (i = 0; i < numbers_to_show; i++)\n  printf(\"%d - \", a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vcpablo/cefet-openmp/odd-even/parallel/2"}
{"code": "for (i = 0; i < numfiles; i++)\n{\n  for (j = 0; j < 160; j++)\n  {\n    if ((wavelen[j] < 7.) || (wavelen[j] > 15))\n    {\n      bbPlanck[(i * 160) + j] = 0.;\n      continue;\n    }\n\n    if (j < startwave)\n      startwave = j;\n\n    if (j > stopwave)\n      stopwave = j;\n\n    bbPlanck[(i * 160) + j] = bb2rad(tempList[i], wavelen[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/2"}
{"code": "for (i = 0; i < G->N; i++)\n{\n  aN = nextAN[1];\n  G->D[aN] = nextAN[0];\n  G->visited[aN] = VISITED;\n  if (debug)\n  {\n    printf(\"[%d] It[%d] aN [%d]\\n\", rank, i, aN);\n    printStatus(G);\n    printf(\"\\n\");\n  }\n\n  for (j = nStart; j < nEnd; j++)\n  {\n    if (G->node[aN][j] != NO_CONN)\n    {\n      if ((G->D[aN] + G->node[aN][j]) < G->D[j])\n      {\n        G->D[j] = G->D[aN] + G->node[aN][j];\n      }\n\n    }\n\n  }\n\n  nextAN[1] = par_NextNode(G, nStart, nEnd);\n  if (nextAN[1] == (-1))\n  {\n    nextAN[0] = INF;\n    nextAN[1] = 0;\n  }\n  else\n  {\n    nextAN[0] = G->D[nextAN[1]];\n  }\n\n  MPI_Allreduce(nextAN, nextAN, 1, (MPI_Datatype) 0x4c000816, (MPI_Op) 0x5800000b, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vikky92/HPC/Dijkstra_Algorithm/Dijkstra_OMPMPI/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  ((((((fout << \"[\") << i) << \"]\") << \" = \") << vector[i]) << \"; \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serhii1savchenko/openmpVectorSmoothing/Lab3_OpenMP/1"}
{"code": "for (k = ki1; k < ki2; k++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    phi2[k][i] = C2 * (u[k][jfin - 1][i][4] - ((0.50 * (((u[k][jfin - 1][i][1] * u[k][jfin - 1][i][1]) + (u[k][jfin - 1][i][2] * u[k][jfin - 1][i][2])) + (u[k][jfin - 1][i][3] * u[k][jfin - 1][i][3]))) / u[k][jfin - 1][i][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/23"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  for (j = 0; j <= (len - 1); j += 1)\n  {\n    a[i][j] = ((double) i) / 2.0;\n    b[i][j] = ((double) i) / 3.0;\n    c[i][j] = ((double) i) / 7.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB098-simd2-orig-no/0"}
{"code": "for (f = 1; f < 33; f++)\n{\n  if (fabs(x[f + 10000] - x[10000]) < eps)\n  {\n    return f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rcv911/Henon-map/henon_omp/3"}
{"code": "for (j = 1; j < (n - 1); j++)\n{\n  for (i = 1; i < (m - 1); i++)\n  {\n    x = ((double) (((2 * i) - m) + 1)) / ((double) (m - 1));\n    y = ((double) (((2 * j) - n) + 1)) / ((double) (n - 1));\n    f[i + (j * m)] = ((-uxx_exact(x, y)) - uyy_exact(x, y)) + (alpha * u_exact(x, y));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_host/helmholtz/10"}
{"code": "for (i = 0; i < dim; i++)\n{\n  tx[i] = ty[i] / mat[i][i];\n  for (j = 0; j < dim; j++)\n    if (j != i)\n    tx[i] -= (mat[i][j] / mat[i][i]) * xn_1[j];\n\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jr/jacobi_omp/4"}
{"code": "for (i = 0; i < N; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "   #pragma omp for schedule(dynamic,chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gboncoraglio/Parallel-computing-OpenMP-OpenACC-MPI/OpenMP/Exploring concepts/schedule_example/0"}
{"code": "for (j = 0; j < (strp_rows * ncols); j++)\n{\n  strp_buffer[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/1"}
{"code": "for (int depth = start_y; depth < end_y; depth++)\n{\n  for (int row = 0; row < boundary_length; row++)\n  {\n    for (int column = start_x; column < end_x; column++)\n    {\n      property_array[((depth * nz_nx) + ((start_z + row) * nx)) + column] = property_array[((depth * nz_nx) + ((start_z + boundary_length) * nx)) + column];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp  parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/HomogenousExtension/4"}
{"code": "for (i = 0; i < image->row; i++)\n{\n  for (j = 0; j < image->col; j++)\n  {\n    private_histo[image->content[i][j]]++;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative/0"}
{"code": "for (int i = size / 2; i < size; i++)\n{\n  mult[i] = vect1[i] * vect2[i];\n  printf(\"[Proceso %d] (Multiplicacion) He calculado %f (indice=%d)\\n\", id, mult[i], i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/12"}
{"code": "for (c = 0; c < k; c++)\n{\n  m = 0;\n  n = 0;\n  for (i = 0; i < k; i++)\n  {\n    for (j = 0; j < k; j++)\n    {\n      b[i][j] = 0;\n      if ((i != 0) && (j != c))\n      {\n        b[m][n] = a[i][j];\n        if (n < (k - 2))\n          n++;\n        else\n        {\n          n = 0;\n          m++;\n        }\n\n      }\n\n    }\n\n  }\n\n  det = det + (s * (a[0][c] * determinant(b, k - 1)));\n  s = (-1) * s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/8"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k + 1][j][i][m])) + u[k + 2][j][i][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/9"}
{"code": "for (n = 0; n < 150; n++)\n{\n  theta[n] = ((((double) n) * 2.0) * PI) / ((double) 150);\n  sin_angle[n] = sin(theta[n]);\n  cos_angle[n] = cos(theta[n]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/4"}
{"code": "for (int k = 0; k < n; k++)\n{\n  for (int i = 0; i < (n * n); i++)\n    c[i] = b[i];\n\n  float p = (-trace(c, n)) / (k + 1);\n  pol[(n - k) - 1] = p;\n  fill_identity(ident, n, p);\n  for (int i = 0; i < (n * n); i++)\n    c_plus_ident[i] = c[i] + ident[i];\n\n  mult_matrix(mat, c_plus_ident, b, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/opencl-char-pol/main/5"}
{"code": "for (i = 0; i < hist_size; i++)\n  histogram[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/histogram_2D/openmp_histogram/1"}
{"code": "for (int tid = 0; tid < output_size; tid++)\n{\n  int C = nChanels;\n  int B = N * C;\n  int A = N * B;\n  int Y = nChanels * nContractions;\n  int f = (tid % Y) % nChanels;\n  int Case = ((tid % Y) / nChanels) + 1;\n  int y = (tid / Y) % N;\n  int x = (tid / Y) / N;\n  int a;\n  int b;\n  int c;\n  int d;\n  int e;\n  T adj_value;\n  T sum = (T) 0;\n  if (Case == 1)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 2)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 3)\n  {\n    b = x;\n    c = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          for (a = 0; a < N; ++a)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 4)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (a = 0; a < N; ++a)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 5)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (a = 0; a < N; ++a)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          for (c = 0; c < N; ++c)\n          {\n            sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 6)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        c = d;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 7)\n  {\n    a = x;\n    b = y;\n    for (d = 0; d < N; ++d)\n    {\n      e = d;\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 8)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (b = 0; b < N; ++b)\n        {\n          c = b;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 9)\n  {\n    a = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        b = e;\n        for (c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 10)\n  {\n    b = x;\n    c = y;\n    for (d = 0; d < N; ++d)\n    {\n      for (e = 0; e < N; ++e)\n      {\n        adj_value = adj[(d * N) + e];\n        if (adj_value > 0)\n        {\n          a = d;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 11)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        for (a = 0; a < N; ++a)\n        {\n          c = a;\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 12)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        a = e;\n        for (int c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 13)\n  {\n    b = x;\n    d = y;\n    for (e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        c = e;\n        for (int a = 0; a < N; ++a)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 14)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int a = 0; a < N; ++a)\n      {\n        b = a;\n        for (int c = 0; c < N; ++c)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 15)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int b = 0; b < N; ++b)\n      {\n        c = b;\n        for (int a = 0; a < N; ++a)\n        {\n          sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (Case == 16)\n  {\n    a = x;\n    d = y;\n    for (int e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        b = e;\n        c = e;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 17)\n  {\n    b = x;\n    d = y;\n    for (int e = 0; e < N; ++e)\n    {\n      adj_value = adj[(d * N) + e];\n      if (adj_value > 0)\n      {\n        a = e;\n        c = e;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  if (Case == 18)\n  {\n    d = x;\n    e = y;\n    adj_value = adj[(d * N) + e];\n    if (adj_value > 0)\n    {\n      for (int a = 0; a < N; ++a)\n      {\n        b = a;\n        c = a;\n        sum += tensor[(((a * A) + (b * B)) + (c * C)) + f] * adj_value;\n      }\n\n    }\n\n  }\n\n  value[tid] = sum;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/contract-omp/main/0"}
{"code": "for (int i = width + 1; i < virtualsize; i += width)\n  for (int j = i; j < ((i + width) - 1); j++)\n{\n  edge_hor[j] = ((((intensityBuffer[(j + width) - 1] + (2 * intensityBuffer[j + width])) + intensityBuffer[(j + width) + 1]) - intensityBuffer[(j - width) - 1]) - (2 * intensityBuffer[j - width])) - intensityBuffer[(j - width) + 1];\n  edge_ver[j] = (((((-intensityBuffer[(j + width) - 1]) + intensityBuffer[(j + width) + 1]) - (2 * intensityBuffer[j - 1])) + (2 * intensityBuffer[j + 1])) - intensityBuffer[(j + width) - 1]) + intensityBuffer[(j + width) + 1];\n  if (edge_ver[j] != 0)\n    angles[j] = (atan2((float) edge_hor[j], edge_ver[j]) * 180) / PI;\n  else\n    angles[j] = (atan2((float) edge_hor[j], 1) * 180) / PI;\n\n  if (angles[j] < 0)\n    angles[j] = 360 + angles[j];\n\n  sum[j] = (int) sqrt(pow((double) edge_hor[j], 2) + pow((double) edge_ver[j], 2));\n  if (sum[j] > biggest)\n    biggest = sum[j];\n\n}\n\n\n", "pragma": "\t#pragma omp for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moreflexible/openMpi/filter/6"}
{"code": "for (;;)\n{\n  for (;;)\n  {\n  }\n\n}\n\n", "pragma": "    #pragma omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/cancel_messages/0"}
{"code": "for (layer7_index = 0; layer7_index < Layer_CH_Num; layer7_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (layer6_index = 0; layer6_index < Layer_CH_Num; layer6_index++)\n  {\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n      }\n\n    }\n\n    for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n    {\n      for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n      {\n        for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n        {\n          for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n          {\n            temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv6_data[(((layer6_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv7[(((((layer7_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer6_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data7[(((layer6_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv7[layer7_index];\n      if (conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n        conv7_data[(((layer7_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/33"}
{"code": "for (n = 0; n < Nmat; n++)\n{\n  L_b[n] = ((-v) * delta) / (1.f + (delta * L[n]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    Z[i][j] = 0;\n    for (int k = 0; k < n; k++)\n    {\n      Z[i][j] += X[i][k] * Y[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yarensonmez/Seri-ve-Paralel-Matris-Carpimi/paralelproje/paralelproje/1"}
{"code": "for (int i = 0; i < ((int) centers.size()); i++)\n{\n  for (int j = 0; j < ((int) centers[i].size()); j++)\n  {\n    centers[i][j] /= center_counts[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par1/6"}
{"code": "for (int e = 0; e < G->numEdges; e++)\n{\n  if (num_matches[e] > 0)\n    non_zero++;\n\n  histogram[(int) ((num_matches[e] * 10.0) / NUM_FILES)] += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/driverForGraphClusteringApprox/2"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[4 * (i + (mxv * j))] = fxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (4 * (i + (mxv * j)))] = fxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[2 + (4 * (i + (mxv * j)))] = fxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[4 * (i + (mxv * j))] = bxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[1 + (4 * (i + (mxv * j)))] = bxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[2 + (4 * (i + (mxv * j)))] = bxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * mxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * mxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,ih,nh,x,y,vx,vy,vz,dxp,dyp, amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1, rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely,edgerx,edgery,p2, gami,qtmg,dtg,sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/5"}
{"code": "for (size_t i = 0; i < difdit.N; ++i)\n  A[i] *= B[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shuibitianantian/Arbitrary-FFT/openmp/fft/6"}
{"code": "for (int i = 0; i < numOfAOs; ++i)\n{\n  const double aoi = AO_values[i];\n  const double dxi = dAO_dx_values[i];\n  const double dyi = dAO_dy_values[i];\n  const double dzi = dAO_dz_values[i];\n  {\n    double v = (coef1_A * aoi) * aoi;\n    v += (aoi * (((coef2_AX * dxi) + (coef2_AY * dyi)) + (coef2_AZ * dzi))) * 2.0;\n    pF_A->add(i, i, v);\n  }\n  for (int j = 0; j < i; ++j)\n  {\n    const double aoj = AO_values[j];\n    const double dxj = dAO_dx_values[j];\n    const double dyj = dAO_dy_values[j];\n    const double dzj = dAO_dz_values[j];\n    double v = (coef1_A * aoi) * aoj;\n    v += aoi * (((coef2_AX * dxj) + (coef2_AY * dyj)) + (coef2_AZ * dzj));\n    v += aoj * (((coef2_AX * dxi) + (coef2_AY * dyi)) + (coef2_AZ * dzi));\n    pF_A->add(i, j, v);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCalcGridX/8"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  DEFINE_idx;\n  printf(\"- idx is %d, i is %d, total thread num is %d\\n\", idx, i, _ROWS);\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(3) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tlqtangok/openmp_demo/04_get_idx/main/0"}
{"code": "for (i = 0; i < bucket->current_size; i++)\n{\n  printf(\"%d\\n\", bucket->tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Wicz3k/MPR_OpenMP/zad_2/main/3"}
{"code": "for (i = 4; i < 11; i++)\n{\n  matrix_size = pow(2, i);\n  A = malloc_matrix(matrix_size);\n  B = malloc_matrix(matrix_size);\n  C = malloc_matrix(matrix_size);\n  init_matrix(A, B, matrix_size);\n  for (j = 0; j < numreps; j++)\n  {\n    gettimeofday(&tv1, &tz);\n    multiply_matrix_omp_static(A, B, C, matrix_size);\n    one_norm_omp_static = matrix_one_norm_omp(C, matrix_size);\n    gettimeofday(&tv2, &tz);\n    elapsed = ((double) (tv2.tv_sec - tv1.tv_sec)) + (((double) (tv2.tv_usec - tv1.tv_usec)) * 1.e-6);\n    average += elapsed;\n    printf(\"matrix size %d, matrix_one_norm_omp takes %lf sec \\n\", matrix_size, elapsed);\n  }\n\n  average = average / 3;\n  WriteData(\"out_omp_static.csv\", matrix_size, average);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/s27y/openmp_matrixmultip/openmp_matrixmultip/5"}
{"code": "for (unsigned i = 0; i < capa.node; ++i)\n  sync.tags[i] = unset;\n\n", "pragma": "#pragma omp for schedule(static, chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/mesh/8"}
{"code": "for (j = 0; j < num_bodies; j++)\n{\n  vhs.x = vel[j].x + ((force[j].x * time_step) / (2 * body_mass));\n  vhs.y = vel[j].y + ((force[j].y * time_step) / (2 * body_mass));\n  vhs.z = vel[j].z + ((force[j].z * time_step) / (2 * body_mass));\n  pos[j].x += vhs.x * time_step;\n  pos[j].y += vhs.y * time_step;\n  pos[j].z += vhs.z * time_step;\n  if ((pos[j].x - body_radius) < 0)\n    pos[j].x = body_radius;\n  else\n    if ((pos[j].x + body_radius) > length)\n    pos[j].x = length - body_radius;\n\n\n  if ((pos[j].y - body_radius) < 0)\n    pos[j].y = body_radius;\n  else\n    if ((pos[j].y + body_radius) > width)\n    pos[j].y = width - body_radius;\n\n\n  if ((pos[j].z - body_radius) < 0)\n    pos[j].z = body_radius;\n  else\n    if ((pos[j].z + body_radius) > depth)\n    pos[j].z = depth - body_radius;\n\n\n  vel[j].x = vhs.x + ((force[j].x * time_step) / (2 * body_mass));\n  vel[j].y = vhs.y + ((force[j].y * time_step) / (2 * body_mass));\n  vel[j].z = vhs.z + ((force[j].z * time_step) / (2 * body_mass));\n  if (((pos[j].x - body_radius) <= 0) || ((pos[j].x + body_radius) >= length))\n  {\n    vel[j].x = -vel[j].x;\n  }\n\n  if (((pos[j].y - body_radius) <= 0) || ((pos[j].y + body_radius) >= width))\n  {\n    vel[j].y = -vel[j].y;\n  }\n\n  if (((pos[j].z - body_radius) <= 0) || ((pos[j].z + body_radius) >= depth))\n  {\n    vel[j].z = -vel[j].z;\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejasPote/N-Body-OpenMP/many_body_sim_program/1"}
{"code": "for (i = Sigma_size - 1; i >= 0; --i)\n{\n  sum += Sigma[i] * Sigma[i];\n  if (sum < epsqr)\n    --cutoff.s;\n  else\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/9"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      printf(\"hello\\n\");\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp metadirective when(user={condition(OMP_MODEL_TARGET)}: target teams distribute parallel for simd collapse(3))       \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-meta2/clang-meta/0"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  int *arr = get_reversed(size);\n  start();\n  parallel_linear_search(arr, size, item);\n  times[i] = end();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blottn/openmp-assignment/parallel_search/3"}
{"code": "for (i = 0; i < 3; i++)\n{\n  if (!(ptr = strtok(0, \" \\t\\n\")))\n    break;\n\n  *(((double *) (&col.x)) + i) = atof(ptr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/c-ray/c-ray/8"}
{"code": "for (m = c + 1; m <= sqrtN; m++)\n{\n  if ((m % c) == 0)\n  {\n    list1[m] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/sieve/2"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  dkx = dnx * ((float) j);\n  afdt = adt * cimagf(ffc[j]);\n  zt1 = (-cimagf(exy[2 + (4 * j)])) + (crealf(exy[2 + (4 * j)]) * _Complex_I);\n  zt2 = (-cimagf(exy[1 + (4 * j)])) + (crealf(exy[1 + (4 * j)]) * _Complex_I);\n  zt5 = bxy[1 + (4 * j)] + (dth * (dkx * zt1));\n  zt6 = bxy[2 + (4 * j)] - (dth * (dkx * zt2));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n  zt8 = (exy[1 + (4 * j)] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * j)]);\n  zt9 = (exy[2 + (4 * j)] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (4 * j)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n  exy[4 * j] = zero;\n  exy[1 + (4 * j)] = zt8;\n  exy[2 + (4 * j)] = zt9;\n  at1 = anorm * ((zt8 * conjf(zt8)) + (zt9 * conjf(zt9)));\n  ws += (double) at1;\n  zt5 += dth * (dkx * zt1);\n  zt6 -= dth * (dkx * zt2);\n  bxy[4 * j] = zero;\n  bxy[1 + (4 * j)] = zt5;\n  bxy[2 + (4 * j)] = zt6;\n  at1 = anorm * ((zt5 * conjf(zt5)) + (zt6 * conjf(zt6)));\n  wp += (double) at1;\n  bxy[(4 * j) + k1] = zero;\n  bxy[(1 + (4 * j)) + k1] = zero;\n  bxy[(2 + (4 * j)) + k1] = zero;\n  exy[(4 * j) + k1] = zero;\n  exy[(1 + (4 * j)) + k1] = zero;\n  exy[(2 + (4 * j)) + k1] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/34"}
{"code": "for (i = 0; i < m; i++)\n{\n  y[i] = 0.0;\n  for (j = 0; j < n; j++)\n    y[i] += A[(i * n) + j] * x[j];\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) shared(A,x,y,m,n) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaoziyu/Parallel-Programming/OpenMP/omp_mat_vect_mult/0"}
{"code": "for (int i = 0; i < p; i++)\n{\n  for (int j = 0; j < n; j++)\n    matrix_B[i][j] = rand() % 100000;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wyh0655/OpenMP_EXA/exa4/1"}
{"code": "for (i = 0; i < taille; i++)\n{\n  somme += tab[i];\n}\n\n", "pragma": "omp parallel for reduction(+:somme)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex5-2/0"}
{"code": "for (i = 1; i < n; i++)\n  for (j = 1; j < m; j++)\n  b[i][j] = b[i - 1][j - 1];\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/truedepfirstdimension-orig-yes/0"}
{"code": "for (i = 0; i <= ((len - 1) - 1); i += 1)\n{\n  a[i + 1] = a[i] * b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB025-simdtruedep-var-yes/0"}
{"code": "for (long int z_test = 0; z_test < snpCount; z_test++)\n{\n  double test_x = 1;\n  if (configure[z_test] == 1)\n  {\n    test_x = test_x;\n  }\n  else\n  {\n    test_x = 1 - test_x;\n  }\n\n  prior_x = prior_x * test_x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/12"}
{"code": "for (k = 0; k < 256; k++)\n{\n}\n\n", "pragma": "omp for schedule(static,1) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dumitrux/Parallelism-FIB/Laboratorio/Lab1/Material-lab1/lab1/3dfft/3dfft_omp/1"}
{"code": "for (int jj = HALO_PAD; jj < (_chunk.y - HALO_PAD); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n  {\n    int index = (jj * _chunk.x) + kk;\n    normTemp += buffer[index] * buffer[index];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:normTemp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_solver_methods/2"}
{"code": "for (int h = q + 1; h < (y - x); h++)\n  c.route[h] = a.route[h];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/7"}
{"code": "for (i = 1; i < (n - 1); i++)\n  if (curr_thread != iters[i])\n{\n  printf(\"%d\\n\", i - 1);\n  printf(\"  %d  \\t  %d -- \", iters[i], i);\n  curr_thread = iters[i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miguelrochajr/ParallelProgramming/BookExercises/Chapter5/Question9/q9/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = 0;\n    for (k = 0; k < p; k++)\n    {\n      a[i][j] += b[i][k] * c[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aadhityasw/VIT-Labs/Parallel_Distributed_Computing_CSE_4001/OpenMP_Constructs_Lab_2/matrix_multiply/0"}
{"code": "for (k = 0; k < level->boxes_in.k; k++)\n{\n  for (j = 0; j < level->boxes_in.j; j++)\n  {\n    for (i = 0; i < level->boxes_in.i; i++)\n    {\n      int jStride = level->boxes_in.i;\n      int kStride = level->boxes_in.i * level->boxes_in.j;\n      int b = (i + (j * jStride)) + (k * kStride);\n      if (level->rank_of_box[b] == level->my_rank)\n      {\n        if (level->numVectors > 0)\n          free(level->my_boxes[box].vectors);\n\n        level->my_boxes[box].vectors = (double **) malloc(numVectors * (sizeof(double *)));\n        if ((numVectors > 0) && (level->my_boxes[box].vectors == 0))\n        {\n          fprintf(stderr, \"malloc failed - level->my_boxes[box].vectors\\n\");\n          exit(0);\n        }\n\n        uint64_t c;\n        for (c = 0; c < numVectors; c++)\n        {\n          level->my_boxes[box].vectors[c] = level->vectors[c] + (((uint64_t) box) * level->box_volume);\n        }\n\n        level->my_boxes[box].numVectors = numVectors;\n        level->my_boxes[box].dim = level->box_dim;\n        level->my_boxes[box].ghosts = level->box_ghosts;\n        level->my_boxes[box].jStride = level->box_jStride;\n        level->my_boxes[box].kStride = level->box_kStride;\n        level->my_boxes[box].volume = level->box_volume;\n        level->my_boxes[box].low.i = i * level->box_dim;\n        level->my_boxes[box].low.j = j * level->box_dim;\n        level->my_boxes[box].low.k = k * level->box_dim;\n        level->my_boxes[box].global_box_id = b;\n        box++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/26"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  if (costarr[i] >= COST_OBS)\n    ntot++;\n\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:ntot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/9"}
{"code": "for (j = 1; j <= i__1; ++j)\n{\n  i__2 = j - 1;\n  ajj = a[j + (j * a_dim1)] - sdot_(&i__2, &a[j + a_dim1], lda, &a[j + a_dim1], lda);\n  if (ajj <= 0.f)\n  {\n    a[j + (j * a_dim1)] = ajj;\n    goto L30;\n  }\n\n  ajj = sqrt(ajj);\n  a[j + (j * a_dim1)] = ajj;\n  if (j < (*n))\n  {\n    i__2 = (*n) - j;\n    i__3 = j - 1;\n    sgemv_((char *) \"No transpose\", &i__2, &i__3, &c_b10, &a[(j + 1) + a_dim1], lda, &a[j + a_dim1], lda, &c_b12, &a[(j + 1) + (j * a_dim1)], &c__1);\n    i__2 = (*n) - j;\n    r__1 = 1.f / ajj;\n    sscal_(&i__2, &r__1, &a[(j + 1) + (j * a_dim1)], &c__1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hassansalehe/DFinspec/src/tests/adf_benchmarks/dwarfs/dense_algebra/dense_algebra_omp/49"}
{"code": "for (i = 0; i < Y2->dim; i++)\n  v_set_val(Y2, i, v_get_val(Y, i) + (delta * v_get_val(Ny, i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/26"}
{"code": "for (i = 0; i < 4; i++)\n  avgtime[i] = (mintime[i] = (maxtime[i] = times[i][1]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/7"}
{"code": "for (int i = low; i <= high; i++)\n{\n  array[i] = aux[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Mergesort_Serial_Parallel/4"}
{"code": "for (size_t longlong_index = my_min_longlong; longlong_index <= my_max_longlong; longlong_index++)\n{\n  const unsigned long long new_val = last_marked[longlong_index];\n  if (new_val)\n  {\n    marked[longlong_index] |= new_val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/6"}
{"code": "for (int i = 0; i < nRows; i++)\n{\n  for (int j = 0; j < nCols; j++)\n  {\n    arrayC[i][j] = 0.0f;\n    for (int k = 0; k < nCols; k++)\n    {\n      arrayC[i][j] += arrayA[i][k] * arrayB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/MatrixOperations/MatrixOperations/MatrixMult/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    c[i][j] = 0.0;\n    sum = _mm_setzero_ps();\n    for (int k = n - 4; k >= 0; k -= 4)\n    {\n      t1 = _mm_loadu_ps(a[i] + k);\n      t2 = _mm_loadu_ps(b[j] + k);\n      t1 = _mm_mul_ps(t1, t2);\n      sum = _mm_add_ps(sum, t1);\n    }\n\n    sum = _mm_hadd_ps(sum, sum);\n    sum = _mm_hadd_ps(sum, sum);\n    _mm_store_ss(c[i] + j, sum);\n    for (int k = (n % 4) - 1; k >= 0; --k)\n    {\n      c[i][j] += a[i][k] * b[j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huxiaotaostasy/OpenMP/code_OpenMP/main/4"}
{"code": "for (int i = 3; i < 32; i += 5)\n{\n  a[i] = (b[i] * c[i]) * d[i];\n}\n\n", "pragma": "  #pragma omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = 0;\n  b[i] = 0;\n  c[i] = i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/clone_array/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 1; j < n; ++j)\n  {\n    if (A[j] < A[j - 1])\n    {\n      int temp = A[j];\n      A[j] = A[j - 1];\n      A[j - 1] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/bubblesort/0"}
{"code": "for (int i = 0; i < x_mi_length; i++)\n{\n  fill_n(mImage[i], y_mi_length, 0);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_count) shared(mImage)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/Filter/Filter/1"}
{"code": "for (int i = 0; i < data.width(); i++)\n{\n  for (int j = 0; j < data.height(); j++)\n  {\n    double tmpR = 0;\n    double tmpG = 0;\n    double tmpB = 0;\n    for (int m = 0; m < kernel.height; m++)\n    {\n      int ii = j + (m - kCenter1);\n      if (ii < 0)\n        ii = 0;\n      else\n        if (ii >= data.height())\n        ii = data.height() - 1;\n\n\n      tmpR += tempResult[i + (data.width() * (ii + (data.height() * 0)))] * kernel2[m];\n      tmpG += tempResult[i + (data.width() * (ii + (data.height() * 1)))] * kernel2[m];\n      tmpB += tempResult[i + (data.width() * (ii + (data.height() * 2)))] * kernel2[m];\n    }\n\n    if (tmpR > 255)\n      tmpR = 255;\n    else\n      if (tmpR < 0)\n      tmpR = 0;\n\n\n    if (tmpG > 255)\n      tmpG = 255;\n    else\n      if (tmpG < 0)\n      tmpG = 0;\n\n\n    if (tmpB > 255)\n      tmpB = 255;\n    else\n      if (tmpB < 0)\n      tmpB = 0;\n\n\n    v(i, j)[0] = tmpR;\n    v(i, j)[1] = tmpG;\n    v(i, j)[2] = tmpB;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for collapse(2) schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/6"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    u[i][j] = uo[i][j] + (nu * ((((uo[i - 1][j] + uo[i + 1][j]) + uo[i][j - 1]) + uo[i][j + 1]) - (4.0 * uo[i][j])));\n  }\n\n}\n\n", "pragma": "omp parallel for default (none) shared (u,uo) private (i,j) firstprivate (nx,ny, nu) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcduta/programming/heat/python/src/c_stepper/0"}
{"code": "for (col = 0; col < LX1; col++)\n{\n  temp[col] = tx[0][0][col];\n  for (i = 1; i < (LX1 - 1); i++)\n  {\n    temp[col] = temp[col] + (qbnew[0][0][i - 1] * tx[0][i][col]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/11"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int *rank = quickargsort(distances[i], n, 20);\n  mean_outcome[i] = 0.0;\n  for (int j = 0; j < k; j++)\n    mean_outcome[i] += outcome_points[rank[j]];\n\n  mean_outcome[i] /= (double) k;\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/knn_parallel/0"}
{"code": "for (i = 0; i < 5; i++)\n{\n  switch ('S')\n  {\n    case 'S':\n      test_index_array[i] = S_test_index_array[i];\n      test_rank_array[i] = S_test_rank_array[i];\n      break;\n\n    case 'A':\n      test_index_array[i] = A_test_index_array[i];\n      test_rank_array[i] = A_test_rank_array[i];\n      break;\n\n    case 'W':\n      test_index_array[i] = W_test_index_array[i];\n      test_rank_array[i] = W_test_rank_array[i];\n      break;\n\n    case 'B':\n      test_index_array[i] = B_test_index_array[i];\n      test_rank_array[i] = B_test_rank_array[i];\n      break;\n\n    case 'C':\n      test_index_array[i] = C_test_index_array[i];\n      test_rank_array[i] = C_test_rank_array[i];\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/10"}
{"code": "for (int i = 0; i < m; i++)\n{\n  swap(vect[i][0], vect[i][1]);\n}\n\n", "pragma": "\t\t\t\t#pragma omp for ordered ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/B23579/Kd-tree-implementation/Kd_tree_MPI_openmp/1"}
{"code": "for (size_t i = 0; i < C_len; i++)\n{\n  size_t start = (i != 0) ? (C[i - 1]) : (0);\n  for (size_t j = start; j < C[i]; j++)\n  {\n    A[j] = i + min;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) firstprivate(A, C, C_len, min) num_threads(threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pepealessio/countingsort_openmp/source/counting_sort/2"}
{"code": "for (size_t i = 0; (i = text.find(substring, i)) != npos; num++, i++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Storn5/genetic-parallelization/GeneticAlgorithms/ParallelOpenMP/ParallelOpenMP/1"}
{"code": "for (i = 1; i < numClusters; i++)\n  clusters[i] = clusters[i - 1] + numFea;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/7"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n    playerShootMap[i][j] = (npcShootMap[i][j] = (playerShips[i][j] = 0));\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/7"}
{"code": "for (int y = 0; y < DIM; y += TILE_SIZE)\n  changement += do_tile_unstable(1, y + (y == 0), DIM - 2, TILE_SIZE - (((y + TILE_SIZE) == DIM) + (y == 0)), omp_get_thread_num());\n\n", "pragma": "omp for reduction (+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/4"}
{"code": "for (int j = real_subarray_size - 1; j >= 0; j--)\n{\n  sub_tablo->tab[j + real_subarray_size] = tab[((size - offset) - real_subarray_size) + j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/2"}
{"code": "for (i = 11 - 1; i >= 0; i--)\n{\n  for (j = 0; j < 11; j++)\n  {\n    if (j < i)\n      dist[i][j] = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2));\n    else\n      if (j == i)\n      dist[i][j] = 0.0;\n    else\n      dist[i][j] = dist[j][i];\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rawal-p/HPC-OpenMP-Assignment/rawalp_tsp_omp/1"}
{"code": "for (jj = 1; jj <= RADIUS; jj++)\n{\n  for (ii = (-jj) + 1; ii < jj; ii++)\n  {\n    weight[ii + RADIUS][jj + RADIUS] = (float) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * RADIUS));\n    weight[ii + RADIUS][(-jj) + RADIUS] = -((float) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * RADIUS)));\n    weight[jj + RADIUS][ii + RADIUS] = (float) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * RADIUS));\n    weight[(-jj) + RADIUS][ii + RADIUS] = -((float) (1.0 / (((4.0 * jj) * ((2.0 * jj) - 1)) * RADIUS)));\n  }\n\n  weight[jj + RADIUS][jj + RADIUS] = (float) (1.0 / ((4.0 * jj) * RADIUS));\n  weight[(-jj) + RADIUS][(-jj) + RADIUS] = -((float) (1.0 / ((4.0 * jj) * RADIUS)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/Stencil/stencil/5"}
{"code": "for (int i = 0; i < dataset.n; i++)\n{\n  for (int j = 0; j < dataset.n; j++)\n  {\n    for (int k = 0; k < dataset.n; k++)\n    {\n      for (int l = 0; l < dataset.n; l++)\n      {\n        dataset.C[i][j][k] += dataset.A[i][j][l] * dataset.B[i][l][k];\n      }\n\n    }\n\n  }\n\n  printf(\"thread: %d, i = %d done.\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW3/3DMatMul/6"}
{"code": "for (int i = 0; i < infoNum; i++)\n{\n  if ((tgt_min <= diff[i][9].toDouble()) && (diff[i][9].toDouble() <= tgt_max))\n  {\n    if ((bolo_min <= diff[i][4].toDouble()) && (diff[i][4].toDouble() <= bolo_max))\n    {\n      if ((pkg_min <= diff[i][5].toDouble()) && (diff[i][5].toDouble() <= pkg_max))\n      {\n        if ((case_min <= diff[i][6].toDouble()) && (diff[i][6].toDouble() <= case_max))\n        {\n          if ((sh_min <= diff[i][7].toDouble()) && (diff[i][7].toDouble() <= sh_max))\n          {\n            if ((lens_min <= diff[i][8].toDouble()) && (diff[i][8].toDouble() <= lens_max))\n            {\n              tmp.clear();\n              for (int j = 0; j < 25; j++)\n              {\n                tmp.append(diff[i][j]);\n              }\n\n              replot.append(tmp);\n              count++;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/47"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (5.0 * u[m][i][j][k])));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/149"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i].arrival_time = arr[i];\n  p[i].burst_time = bur[i];\n  p[i].priority = pri[i];\n  p[i].pid = i + 1;\n  burst_remaining[i] = p[i].burst_time;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/prio_pre_parallel/0"}
{"code": "for (i = 0; i < num_elem; i++)\n{\n  struct number *new = malloc(sizeof(struct number));\n  new->numb = A[i];\n  new->next = 0;\n  putinbucket(new, (int) (new->numb / bucketsize), ptr_table, buckets);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hkominos/OpenMp_Lab/Pragma_Schedule/4"}
{"code": "for (int iy = 0; iy < (K + 2); iy++)\n{\n  spr[1][iy] += spr[0][iy];\n  spr[_M - 1][iy] += spr[_M + 1][iy] + spr[_M][iy];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/71"}
{"code": "for (int i = 0; i < m; ++i)\n{\n  for (int j = 0; j < m; ++j)\n  {\n    if (i != 0)\n      adj[j + (m * i)].push_back(j + (m * (i - 1)));\n\n    if (i != (m - 1))\n      adj[j + (m * i)].push_back(j + (m * (i + 1)));\n\n    if (j != 0)\n      adj[j + (m * i)].push_back((j - 1) + (m * i));\n\n    if (j != (m - 1))\n      adj[j + (m * i)].push_back((j + 1) + (m * i));\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/bfs/bfs/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int label = labels[(i * width) + j];\n    seg_data[(((i * width) + j) * 3) + 0] = (char) red[label];\n    seg_data[(((i * width) + j) * 3) + 1] = (char) blue[label];\n    seg_data[(((i * width) + j) * 3) + 2] = (char) green[label];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(numThreads) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mebegu/Parallel-Image-Segmentation/imseg_serial/8"}
{"code": "for (int i = 0; i < object.size(); i++)\n{\n  if ((object[i].getRow() == row) && (object[i].getColumn() == col))\n    object[i].setText(text, true);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/inirion/MpiIndexowanie/Source/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ric0rdanza/HPC_Openmp_GEMV/gemv/4"}
{"code": "for (int k = 0; k <= floor(n / 2); k++)\n{\n  if (out[k] != 0)\n    printf(\"%d \", out[k]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luisfrt/openmp-primenumbers/main/0"}
{"code": "for (int i = 0; i < x; i++)\n  for (int i = 0; i < y; i++)\n  ;\n\n\n", "pragma": "omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/tools/clang/test/AST/ast-dump-openmp-distribute-parallel-for-simd/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  factor = ((k % 2) == 0) ? (1.0) : (-1.0);\n  sum += factor / ((2 * k) + 1);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+:sum) firstprivate(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jskankurgarg/Multicore_OpenMP_CUDA/openMP/pi_1/0"}
{"code": "for (int i = 0; i < argc; i++)\n{\n  if (0 == strcmp(argv[i], \"-nx\"))\n  {\n    nx = atoi(argv[i + 1]);\n  }\n  else\n    if (0 == strcmp(argv[i], \"-ny\"))\n  {\n    ny = atoi(argv[i + 1]);\n  }\n  else\n    if (0 == strcmp(argv[i], \"-eps\"))\n  {\n    eps = (double) atof(argv[i + 1]);\n  }\n  else\n    if (0 == strcmp(argv[i], \"-fx\"))\n  {\n    fx = atoi(argv[i + 1]);\n  }\n  else\n    if (0 == strcmp(argv[i], \"-fy\"))\n  {\n    fy = atoi(argv[i + 1]);\n  }\n  else\n    if (0 == strcmp(argv[i], \"-fg\"))\n  {\n    fg = atoi(argv[i + 1]);\n  }\n\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joshuaburkhart/laplace/laplace/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/11"}
{"code": "for (iteration = 1; iteration <= 10; iteration++)\n{\n  if (CLASS != 'S')\n    printf(\"        %d\\n\", iteration);\n\n  rank(iteration);\n  nthreads = omp_get_num_threads();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/IS/is/1"}
{"code": "for (i = 0; i < K; i++)\n{\n  for (j = 0; j < K; j++)\n    if (i != j)\n  {\n    devidedDistances += clusters[i].diameter / sqrt((pow(clusters[i].centerX - clusters[j].centerX, 2) + pow(clusters[i].centerY - clusters[j].centerY, 2)) + pow(clusters[i].centerZ - clusters[j].centerZ, 2));\n  }\n\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SlavKhizverg/Parallel-Computation---written-in-C-using-openMP-and-MPI/ParallelProject/Source/7"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"Thread %d sees \\\"val\\\" = %d at iteration %d.\\n\", omp_get_thread_num(), val, i);\n}\n\n", "pragma": "omp parallel for linear(val:2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rookiehpc/rookiehpc.github.io/openmp/docs/linear/example_1/0"}
{"code": "for (int i = 1; i <= Q; i++)\n  arr[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tratitude/eight-queen-problem/eight_queen/2"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dEo1[col] = dEo11[col] * dneto11[col];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/19"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = -frct[k][j][i][m];\n      }\n\n      tmp = 1.0 / u[k][j][i][0];\n      rho_i[k][j][i] = tmp;\n      qs[k][j][i] = (0.50 * (((u[k][j][i][1] * u[k][j][i][1]) + (u[k][j][i][2] * u[k][j][i][2])) + (u[k][j][i][3] * u[k][j][i][3]))) * tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/rhs/0"}
{"code": "for (int k = 0; k < geom1->n_grid_z; k++)\n{\n  field_phi[0][k] = 0;\n  field_phi[geom1->n_grid_r - 1][k] = 0;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/2"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  PyList_Append(list, PyFloat_FromDouble(arr[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilev4ik/openmp/main/0"}
{"code": "for (i = 0; i < 500; i++)\n  if (arr[i] < min)\n  min = arr[i];\n\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IT-Dept-Labs/Parallel-Computing/Lab5/smallest/0"}
{"code": "for (i = 0; i < count; i += inner_batch_size)\n{\n  unsigned char keys[SSE_GROUP_SZ_SHA512][64];\n  int lens[SSE_GROUP_SZ_SHA512];\n  int j;\n  for (j = 0; j < inner_batch_size; ++j)\n  {\n    lens[j] = strlen((char *) key_buffer[i + j]);\n    strncpy((char *) keys[j], (char *) key_buffer[i + j], 64);\n    if (psalt->nkeyfiles)\n    {\n      int t;\n      for (t = 0; t < 64; t++)\n        keys[j][t] += psalt->kpool[t];\n\n      lens[j] = 64;\n    }\n\n  }\n\n  if (psalt->hash_type == 1)\n  {\n    unsigned char *pin[SSE_GROUP_SZ_SHA512];\n    unsigned char *pout[SSE_GROUP_SZ_SHA512];\n    for (j = 0; j < SSE_GROUP_SZ_SHA512; ++j)\n    {\n      pin[j] = keys[j];\n      pout[j] = keys[j];\n    }\n\n    pbkdf2_sha512_sse((const unsigned char **) pin, lens, psalt->salt, 64, psalt->num_iterations, pout, sizeof(keys[0]), 0);\n  }\n  else\n    if ((psalt->hash_type == 2) || (psalt->hash_type == 4))\n    pbkdf2_ripemd160((const unsigned char *) keys[0], lens[0], psalt->salt, 64, psalt->num_iterations, keys[0], sizeof(keys[0]), 0);\n  else\n    pbkdf2_whirlpool((const unsigned char *) keys[0], lens[0], psalt->salt, 64, psalt->num_iterations, keys[0], sizeof(keys[0]), 0);\n\n\n  for (j = 0; j < inner_batch_size; ++j)\n  {\n    cracked[i + j] = 0;\n    if ((decrypt_and_verify(keys[j], 0) || decrypt_and_verify(keys[j], 1)) || decrypt_and_verify(keys[j], 2))\n      cracked[i + j] = 1;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/truecrypt_fmt_plug/9"}
{"code": "for (int j = 0; j < 64; j++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/distribute-1/2"}
{"code": "for (j = 1; j <= nh; j++)\n{\n  h = hidden[j];\n  sum = 0.0;\n  for (k = 1; k <= no; k++)\n  {\n    sum += delta_o[k] * who[j][k];\n  }\n\n  delta_h[j] = (h * (1.0 - h)) * sum;\n  errsum += ABS(delta_h[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/9"}
{"code": "for (i = 1; i < commSize; i++)\n{\n  MPI_Recv(tempMSet, chunkSize, (MPI_Datatype) 0x4c000405, -2, 3, 1, &status);\n  sender = status.MPI_SOURCE;\n  printf(\"Recieved chunk from %d\\n\", sender);\n  memcpy(MSet + (chunkSize * (sender - 1)), tempMSet, chunkSize * (sizeof(int)));\n  printf(\"Memcpy'd data from rank %d into MSet\\n\", sender);\n  sender = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JRWynneIII/Mandelbrot/openmp_mpi_mandelbrot/2"}
{"code": "for (uint64_t i = 0; i < thread_num; i++)\n  count += counts_[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primecount/src/PiTable/2"}
{"code": "for (int itr = 0; itr < num_itrs; itr++)\n{\n  for (int i = 1; i < (y_points - 1); i++)\n  {\n    for (int j = 1; j < (x_points - 1); j++)\n    {\n      u_new[idx(i, j)] = (((u[idx(i, j)] + (((nu * del_t) / (del_x * del_x)) * ((u[idx(i, j + 1)] + u[idx(i, j - 1)]) - (2 * u[idx(i, j)])))) + (((nu * del_t) / (del_y * del_y)) * ((u[idx(i + 1, j)] + u[idx(i - 1, j)]) - (2 * u[idx(i, j)])))) - (((del_t / del_x) * u[idx(i, j)]) * (u[idx(i, j)] - u[idx(i, j - 1)]))) - (((del_t / del_y) * v[idx(i, j)]) * (u[idx(i, j)] - u[idx(i - 1, j)]));\n      v_new[idx(i, j)] = (((v[idx(i, j)] + (((nu * del_t) / (del_x * del_x)) * ((v[idx(i, j + 1)] + v[idx(i, j - 1)]) - (2 * v[idx(i, j)])))) + (((nu * del_t) / (del_y * del_y)) * ((v[idx(i + 1, j)] + v[idx(i - 1, j)]) - (2 * v[idx(i, j)])))) - (((del_t / del_x) * u[idx(i, j)]) * (v[idx(i, j)] - v[idx(i, j - 1)]))) - (((del_t / del_y) * v[idx(i, j)]) * (v[idx(i, j)] - v[idx(i - 1, j)]));\n    }\n\n  }\n\n  for (int i = 0; i < x_points; i++)\n  {\n    u_new[idx(0, i)] = 1.0;\n    v_new[idx(0, i)] = 1.0;\n    u_new[idx(y_points - 1, i)] = 1.0;\n    v_new[idx(y_points - 1, i)] = 1.0;\n  }\n\n  for (int j = 0; j < y_points; j++)\n  {\n    u_new[idx(j, 0)] = 1.0;\n    v_new[idx(j, 0)] = 1.0;\n    u_new[idx(j, x_points - 1)] = 1.0;\n    v_new[idx(j, x_points - 1)] = 1.0;\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    for (int j = 0; j < x_points; j++)\n    {\n      u[idx(i, j)] = u_new[idx(i, j)];\n      v[idx(i, j)] = v_new[idx(i, j)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/burger-omp/main/7"}
{"code": "for (unsigned int i = 0; i < node_no; ++i)\n{\n  float *cv = coordinateVectors + (i * dimension_no);\n  float *fv = forceVectors + (i * dimension_no);\n  float *node_i = mappedNodes + (i * dimension_no);\n  for (unsigned int j = 0; j < node_no; ++j)\n  {\n    float *node_j = mappedNodes + (j * dimension_no);\n    memset((void *) cv, 0, (sizeof(float)) * dimension_no);\n    float f_distance = node_distances[(i * node_no) + j];\n    float r_distance = 0;\n    for (unsigned int k = 0; k < dim_no; ++k)\n    {\n      cv[k] = dimFactors[k] * (node_i[k] - node_j[k]);\n      r_distance += cv[k] * cv[k];\n    }\n\n    r_distance = sqrt(r_distance);\n    float error = f_distance - r_distance;\n    node_stress[i] = fabs(error);\n    if (r_distance > 0)\n    {\n      for (unsigned int k = 0; k < dimension_no; ++k)\n        fv[k] += (error * cv[k]) / r_distance;\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for if (useOpenMP)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/4"}
{"code": "for (int p = 0; p < nproc; p++)\n{\n  gl_number_of_centers_to_close += (int) work_mem[(p * stride) + K];\n  gl_cost_of_opening_x += work_mem[((p * stride) + K) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/14"}
{"code": "for (c2 = (nj > nl) ? (nj) : (nl); c2 <= (nm + (-1)); c2++)\n{\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/67"}
{"code": "for (idx_t m = 0; m < ngraphs; ++m)\n{\n  nvtxs += graphs[m]->nvtxs;\n  ncon += graphs[m]->nedges;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/7"}
{"code": "for (int i = k; i < n; i++)\n{\n  if (pair.val < abs(data[i][k]))\n  {\n    pair.val = abs(data[i][k]);\n    pair.pos = i;\n  }\n\n  printf(\"i'm ID %d i find max row %d, %f\\n\", omp_get_thread_num(), pair.pos, pair.val);\n}\n\n", "pragma": "\t \t \t#pragma omp parallel for reduction(max:pair) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmwu/Matrix-LU-decomposition/luDecomp/1"}
{"code": "for (int i = 0; i < proteinas.size(); i++)\n{\n  (cout << proteinas[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/13"}
{"code": "for (i = lb; i < ub; i += st)\n{\n  work(i);\n}\n\n", "pragma": "omp for ordered schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny10/ocl_tiny10/tiny10/0"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t k;\n  uint32_t src;\n  uint32_t dest;\n  float weight = 0.0001f;\n  struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n  for (k = 0; k < partition->num_edges; ++k)\n  {\n    src = partition->edgeList->edges_array_src[k];\n    dest = partition->edgeList->edges_array_dest[k];\n    weight = partition->edgeList->edges_array_weight[k];\n    stats->vector_output[dest] += weight * stats->vector_input[src];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/22"}
{"code": "for (i = 0; i < 3; i++)\n  a[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/009_firstprivate_clause/1"}
{"code": "for (i = 1; i < matrix_size; i++)\n{\n  m[i] = m[0] + (i * matrix_size);\n  if (!m[i])\n  {\n    printf(\"memory failed \\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/s27y/openmp_matrixmultip/openmp_matrixmultip/0"}
{"code": "for (i = 1; i < (size - 1); i++)\n{\n  for (j = 1; j < (size - 1); j++)\n  {\n    int sum = ((((((A[i + 1][j] + A[i][j + 1]) + A[i - 1][j]) + A[i][j - 1]) + A[i - 1][j - 1]) + A[i - 1][j + 1]) + A[i + 1][j - 1]) + A[i + 1][j + 1];\n    B[i][j] = Populate(i, j, sum, A);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taggelos/GameOfLife/Paradoteo/mpi_openmp/functions/0"}
{"code": "for (i = leftRange; i < rightRange; i++)\n{\n  tmp = A[i] + B[i];\n  LOG(\"c tmp[%d] = %d\", i, tmp);\n  if (tmp != 0)\n  {\n    omp_set_lock(&lock);\n    res *= tmp;\n    omp_unset_lock(&lock);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mr-KRAX/labs_OpenMP/Lab6/main/1"}
{"code": "for (int i = 0; i < (dim * gene); i++)\n{\n  ex_a[i] = distribution(generator);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnikChaudhuri/Variational-Bayes-with-OpenMP/VB1/0"}
{"code": "for (int j = 0; j < x_size; j++)\n{\n  for (int k = 0; k < y_size; k++)\n  {\n    printf(\"%.7f \", u[(j * x_size) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/wave_propagation/1"}
{"code": "for (int idx = 0; idx < N; idx++)\n{\n  C[idx] = A[idx] + B[idx];\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Masa-731/OpenMP-vs-OpenACC/vectoradd/openmp-cpu/0"}
{"code": "for (int i = 10000 / 4; i < (10000 / 2); i++)\n{\n  task1(gl_taskData.intArrays[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/p1/task/3"}
{"code": "for (i = 0; i < NUM_OF_NODES; i++)\n{\n  double sum = 0;\n  for (j = 0; j < NUM_OF_NODES; j++)\n  {\n    sum += E[i][j];\n  }\n\n  if (sum > 0)\n  {\n    for (j = 0; j < NUM_OF_NODES; j++)\n    {\n      E[i][j] /= sum;\n    }\n\n    d[i] = 0;\n  }\n  else\n    if (sum == 0)\n  {\n    d[i] = 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anapt/PageRank/src/parallel/6"}
{"code": "for (int i = 0; i < (N + 1); i++)\n  if (Z[i] <= v)\n{\n  if (linear_avg)\n    sum += (0.5 * (wetness(i) + wetness(i + 1))) * sdL[i];\n  else\n    sum += wetness(i) * sdL[i];\n\n  n += sdL[i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/63"}
{"code": "for (i = 0; i < 100; i++)\n{\n  buckets[i].elems = (int *) malloc((sizeof(int)) * buckets[i].len);\n  buckets[i].len = 0;\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg2/2"}
{"code": "for (int i = 1; i < vec.size(); i++)\n{\n  if (vec[i] < min)\n    min = vec[i];\n\n}\n\n", "pragma": "        #pragma omp for schedule(dynamic, threadChunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelaziz321/hybrid-mpi-openmp-example/main/7"}
{"code": "for (i = 0; i < 32; i++)\n  for (j = 0; j < 32; ++j)\n  a[(i * 32) + j] += b[(i * 32) + j] * 2;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/simd-1/5"}
{"code": "for (i = 0; i < P; i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    Q_T[(j * P) + i] = Q_[(i * P) + j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp_orig/4"}
{"code": "for (int i = 0; i < 100; i++)\n  processImageSmoothFilter(bmp, width, height, radius, resultBmp);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlukyanets/parallel-computing-project/smooth_filter_openmp/3"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  rv[i] = 1;\n  cv[i] = 1;\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(ntInt)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buraksekili/Sinkhorn-Knopp-scaling/cpu/main/0"}
{"code": "for (j = i + 1; j < 3; j++)\n{\n  {\n    ratio = matrix[j][i] / matrix[i][i];\n    for (k = 0; k < (3 + 1); k++)\n    {\n      matrix[j][k] = matrix[j][k] - (ratio * matrix[i][k]);\n    }\n\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jasha16/HPC/gaussOMP/0"}
{"code": "for (int h = 0; h < 4; h++)\n  for (int w = 0; w < 4; w++)\n{\n  output_file.read((char *) (&goldenResult->final_transformation.data[h][w]), sizeof(float));\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/1"}
{"code": "for (i = 0; i < 1; i++)\n{\n  b = a;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_cv_qualifier_01/0"}
{"code": "for (uint64_t i = 0; i < (size / 8); i++)\n{\n  tmp = data_64[i];\n  hist[(tmp >> 0) & 0xFF]++;\n  hist[(tmp >> 8) & 0xFF]++;\n  hist[(tmp >> 16) & 0xFF]++;\n  hist[(tmp >> 24) & 0xFF]++;\n  hist[(tmp >> 32) & 0xFF]++;\n  hist[(tmp >> 40) & 0xFF]++;\n  hist[(tmp >> 48) & 0xFF]++;\n  hist[(tmp >> 56) & 0xFF]++;\n}\n\n", "pragma": "omp for reduction(+:hist[:1<<8])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/0"}
{"code": "for (i = 1; i < n; i++)\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n\n", "pragma": " #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/nowait/0"}
{"code": "for (j = 0; j < M; j++)\n  temp += A_row[j] * x[j];\n\n", "pragma": "omp parallel for reduction(+:temp) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Hybrid/mxvnm_OMPI/0"}
{"code": "for (k = 0; k < (1024 - 4); k++)\n{\n  printf(\"Thread %d working on %d row\\n\", thread_id, k);\n  for (m = 0; m < (1024 - 4); m++)\n  {\n    sum = 0;\n    mean = 0;\n    for (i = 0; i < 5; i++)\n    {\n      for (j = 0; j < 5; j++)\n        sum += A[i + k][j + m];\n\n    }\n\n    mean = sum / (5 * 5);\n    B[k + 2][m + 2] = mean;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RachanaRajSunku/Image-Processing-Algorithm-Implementation-in-MPI-and-OpenMP/omp_mean_window5x5/omp_mean_w5/0"}
{"code": "for (int x = 0; x < k; x++)\n{\n  pointsInCluster[x] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/loremacchia/kMeans/omp/main/0"}
{"code": "for (index = 0; index < count; index += 3)\n{\n  int i;\n  int j;\n  if (keys_changed)\n  {\n    char *k0 = saved_key[index];\n    char *k1 = saved_key[index + 1];\n    char *k2 = saved_key[index + 2];\n    unsigned char digest16[3][16];\n    domino_big_md_3((unsigned char *) k0, strlen(k0), (unsigned char *) k1, strlen(k1), (unsigned char *) k2, strlen(k2), digest16[0], digest16[1], digest16[2]);\n    for (i = 0, j = 6; i < 14; i++, j += 2)\n    {\n      const char *hex2 = hex_table[ARCH_INDEX(digest16[0][i])];\n      digest34[index][j] = hex2[0];\n      digest34[index][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[1][i])];\n      digest34[index + 1][j] = hex2[0];\n      digest34[index + 1][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[2][i])];\n      digest34[index + 2][j] = hex2[0];\n      digest34[index + 2][j + 1] = hex2[1];\n    }\n\n  }\n\n  if (salt_changed)\n  {\n    digest34[index + 2][0] = (digest34[index + 1][0] = (digest34[index][0] = cur_salt->salt[0]));\n    digest34[index + 2][1] = (digest34[index + 1][1] = (digest34[index][1] = cur_salt->salt[1]));\n    digest34[index + 2][2] = (digest34[index + 1][2] = (digest34[index][2] = cur_salt->salt[2]));\n    digest34[index + 2][3] = (digest34[index + 1][3] = (digest34[index][3] = cur_salt->salt[3]));\n    digest34[index + 2][4] = (digest34[index + 1][4] = (digest34[index][4] = cur_salt->salt[4]));\n    digest34[index + 2][5] = (digest34[index + 1][5] = (digest34[index][5] = '('));\n  }\n\n  domino_big_md_3_34(digest34[index], digest34[index + 1], digest34[index + 2], (unsigned char *) crypt_out[index], (unsigned char *) crypt_out[index + 1], (unsigned char *) crypt_out[index + 2]);\n  for (i = 0; i < 3; i++)\n  {\n    unsigned char buffer[22 + 1] = {0};\n    unsigned char tmp_hash[(22 + 1) + 3] = {0};\n    memcpy(tmp_hash, cur_salt->salt, 5);\n    memcpy(tmp_hash + 5, crypt_out[index + i], 16);\n    domino_encode(tmp_hash, buffer);\n    sprintf((char *) tmp_hash, \"(G%s)\", buffer);\n    pbkdf2_sha1(tmp_hash, 22, cur_salt->salt, 16, cur_salt->iterations, (unsigned char *) crypt_out_real[index + i], 8, 0);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/0"}
{"code": "for (uint64_t i = 0; i < (NI / 204); i++)\n{\n  data_out[i * 188] = data_in[i * 204];\n  rsdec_204(((unsigned char *) data_out) + (i * 188), ((unsigned char *) data_in) + (i * 204));\n}\n\n", "pragma": "  #pragma omp parallel for use(hrw) module(reed_solomon_decoder)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/reed_solomon_decoder/sw/src/main/1"}
{"code": "for (int i = 5000001; i <= 7500000; i++)\n  funcsum[2] += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PatrickHee/OpenMP/OpenMP functions and clauses/OMPAddup/2"}
{"code": "for (i = myoffset; i < (myoffset + chunk); i++)\n{\n  data[i] = data[i] + 0.5f;\n}\n\n", "pragma": "omp parallel for shared(data)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/batux/hybrid_high_performance_parallel_computing/sample_array_processing_01/main/0"}
{"code": "for (int jj = 0; jj < (N + 2); jj++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    fill_array3d(buffer, N, ii, jj, 0, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for nowait ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/smoother7p/6"}
{"code": "for (i = xadj[v]; i < xadj[v + 1]; i++)\n{\n  u = adjncy[i];\n  if (inqueue[u] == 2)\n    continue;\n\n  if ((sps[u] < 0) || ((sps[v] + adjwgt[i]) < sps[u]))\n  {\n    sps[u] = sps[v] + adjwgt[i];\n    if (inqueue[u])\n      gk_i32pqUpdate(queue, u, -sps[u]);\n    else\n    {\n      gk_i32pqInsert(queue, u, -sps[u]);\n      inqueue[u] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/11"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if ((((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || (mat16[rowcol] == (-28768))) || (mat17[rowcol] == (-28768)))\n  {\n  }\n  else\n  {\n    tempk = mat8[rowcol] * 0.02;\n    dem = mat14[rowcol];\n    temp = (int) (tempk + (0.00627 * dem));\n    if (temp > 250)\n    {\n      histogramT[temp] = histogramT[temp] + 1.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/3"}
{"code": "for (i = 0; i < 100; i++)\n  aa[i] = 2 * i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-parallel-for-simd-clauses/test/7"}
{"code": "for (index = 0; index < count; index++)\n{\n  sph_whirlpool1_context ctx;\n  sph_whirlpool1_init(&ctx);\n  sph_whirlpool1(&ctx, saved_key[index], strlen(saved_key[index]));\n  sph_whirlpool1_close(&ctx, (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/whirlpool_fmt_plug/1"}
{"code": "for (int i = 0; i < Max; i++)\n{\n  for (int j = 0; j < Max; j++)\n  {\n    int c_index = (i * Max) + j;\n    int a_index = (i * Max) + 0;\n    int b_index = (0 * Max) + j;\n    C[c_index] = 0;\n    for (int k = 0; k < Max; k++)\n    {\n      C[c_index] += A[a_index] * B[b_index];\n      a_index += 1;\n      b_index += Max;\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JanetLau0310/Parallel_computing/OpenMP/SGEMM/w4_3/1"}
{"code": "for (size_t i = 0; i < n1; i++)\n{\n  for (size_t j = 0; j < m2; j++)\n  {\n    #pragma novector\n    for (size_t k = 0; k < m1; k++)\n    {\n      resultMatrix[i][j] += ma[i][k] * mb[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/6"}
{"code": "for (jj = 0; jj < dim3; jj++)\n{\n  for (ii = 0; ii < dim3; ii++)\n    C[ii + (jj * dim1)] = 0.;\n\n  for (kk = 0; kk < dim2; kk++)\n    for (ii = 0; ii < dim1; ii++)\n    C[ii + (jj * dim1)] += A[ii + (kk * dim1)] * B[kk + (jj * dim2)];\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/OpenMP---Examples/openmp/example4/omp_naive_mm/0"}
{"code": "for (i = 0; i < num_batches; i++)\n{\n  int result = samples_inside_circle(&buffer, num_trials / num_batches);\n  count += result;\n}\n\n", "pragma": "omp parallel for private(buffer) reduction(+: count)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philipaconrad/openmp-talk-code/solutions/monte-carlo-pi-batched/main/0"}
{"code": "for (int i = 0; i < nb_nodes; ++i)\n{\n  if (__builtin_expect(mesh->isCorner(i), 0))\n    sync.activ[i] = -1;\n  else\n    sync.activ[i] = (char) ((mesh->topo.stenc[i].empty()) ? (0) : (1));\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/0"}
{"code": "for (x = 1; x < (PROBLEMSIZE + 1); x++)\n{\n  for (y = 1; y < (PROBLEMSIZE + 1); y++)\n  {\n    (cout << cur_gen[x][y]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nilayladke/Game-Of-Life-Project/omp/2"}
{"code": "for (k = 0, K = 0; k < n; k += bs, K++)\n{\n  kl = k + bs;\n  if (kl > n)\n  {\n    kl = n;\n    strK = kl - k;\n  }\n  else\n  {\n    strK = bs;\n  }\n\n  diagowner = BlockOwner(K, K);\n  if (diagowner == MyNum)\n  {\n    A = a[K + (K * nblocks)];\n    lu0(A, strK, strK);\n  }\n\n  D = a[K + (K * nblocks)];\n  for (i = kl, I = K + 1; i < n; i += bs, I++)\n  {\n    if (BlockOwner(I, K) == MyNum)\n    {\n      il = i + bs;\n      if (il > n)\n      {\n        il = n;\n        strI = il - i;\n      }\n      else\n      {\n        strI = bs;\n      }\n\n      A = a[I + (K * nblocks)];\n      bdiv(A, D, strI, strK, strI, strK);\n    }\n\n  }\n\n  for (j = kl, J = K + 1; j < n; j += bs, J++)\n  {\n    if (BlockOwner(K, J) == MyNum)\n    {\n      jl = j + bs;\n      if (jl > n)\n      {\n        jl = n;\n        strJ = jl - j;\n      }\n      else\n      {\n        strJ = bs;\n      }\n\n      A = a[K + (J * nblocks)];\n      bmodd(D, A, strK, strJ, strK, strK);\n    }\n\n  }\n\n  for (i = kl, I = K + 1; i < n; i += bs, I++)\n  {\n    il = i + bs;\n    if (il > n)\n    {\n      il = n;\n      strI = il - i;\n    }\n    else\n    {\n      strI = bs;\n    }\n\n    A = a[I + (K * nblocks)];\n    for (j = kl, J = K + 1; j < n; j += bs, J++)\n    {\n      jl = j + bs;\n      if (jl > n)\n      {\n        jl = n;\n        strJ = jl - j;\n      }\n      else\n      {\n        strJ = bs;\n      }\n\n      if (BlockOwner(I, J) == MyNum)\n      {\n        B = a[K + (J * nblocks)];\n        C = a[I + (J * nblocks)];\n        bmod(A, B, C, strI, strJ, strK, strI, strK, strI);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexandrehsd/splash2-lu_cb/src/lu/7"}
{"code": "for (int i = 1; i < length; i++)\n{\n  temp = distance(x1, y1, h_array[i].x, h_array[i].y);\n  if (temp < smallest)\n  {\n    smallest = temp;\n    tempStruct = h_array[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alibozkurtkyrd/OpenMP-C/q4/v7/3"}
{"code": "for (int i = 0; i < PHILOSOPHERS; i++)\n{\n  let_them_eat();\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(PHILOSOPHERS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_philosophers/Q3/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  (x_file << \"  \") << x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/heat-mpi/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  a[i] = i;\n  printf(\"%d\", i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zlinwei/hpc/main/0"}
{"code": "for (int j = 0, jn = counts_per.size(); j < jn; j++)\n{\n  if (cc_we_want[j] == true)\n  {\n    number_selected++;\n    ((((outwrite << \"Component selected \") << j) << \" with volume \") << counts_per[j]) << endl;\n    if (counts_per[j] > max_cc)\n    {\n      max_cc = counts_per[j];\n      index_biggest_cc = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/5"}
{"code": "for (c2 = nm; c2 <= (nk + (-1)); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/56"}
{"code": "for (m = 0; m < 1000; ++m)\n  switch (p[m])\n{\n  case 1:\n    p[m] = 2;\n    break;\n\n  default:\n    p[m] = 3;\n    break;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/block-11/0"}
{"code": "for (int i = 0; i < (height + 2); i++)\n  cout << \"o\";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/1/console/GameOfLife/5"}
{"code": "for (c = 2; c <= sqrtN; c++)\n{\n  if (list1[c] == 0)\n  {\n    if (is_printing)\n    {\n      printf(\"%d \", c);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/sieve/4"}
{"code": "for (i = 0; i < nColumns; i++)\n{\n  nTotalZero += cM->nZero[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mapa17/teacup/teacup_tools/13"}
{"code": "for (size_t idx = 0; idx < size; ++idx)\n{\n  if (ref[idx] != data[idx])\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-2/03-cut-offs/mergesort-co/mergesort-solved/0"}
{"code": "for (int j = 0; j < m; j++)\n{\n  array[j] = matrix[row][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/24"}
{"code": "for (int64_t r = lev_beg; r < lev_end; ++r)\n{\n  order[r] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/4"}
{"code": "for (int i = 0; i < omp_get_max_threads(); ++i)\n{\n  int tRank = omp_get_thread_num();\n  srand(((i + 1) * (pRank + 1)) * time(NULL));\n  int num = rand() % 1000;\n  ((((((cout << \"I am \") << i) << \" thread from \") << pRank) << \" process, my random number = \") << num) << endl;\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaidertw/2.MPI-OpenMP_Random/main/1"}
{"code": "for (int i = 0; i < (nSegments - 1); i++)\n{\n  oldPositions[i] = i;\n  if (i >= xMax)\n  {\n    oldPositions[i]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/Bucket/2"}
{"code": "for (i = 0; i < MyLawn.m; i++)\n{\n  for (j = 0; j < MyLawn.m; j++)\n  {\n    double val = MyLawn.number_of_ants_in_cell(i, j);\n    if (val > maxinfo[id].val)\n    {\n      maxinfo[id].val = val;\n      maxinfo[id].loc1 = i;\n      maxinfo[id].loc2 = j;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhsu32/OpenMP/anthill/10"}
{"code": "for (ssize_t i = 0; i < ax.nbins; ++i)\n{\n  values[i] += values_ot[i];\n  variances[i] += variances_ot[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/11"}
{"code": "for (int i = 0; i < (*num_data); i++)\n{\n  (*ser_data)[i] = rand() % 101;\n  (*par_data)[i] = (*ser_data)[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_histogram/4"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"%f \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HectorMontillo/OpenMP/test/0"}
{"code": "for (h = (i = 0); i < nclusters; h += width / nclusters, i++)\n{\n  for (j = 0; j < nchannels; j++)\n  {\n    c[i][j] = data[h / width][h % width][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kyeongan/k-means-function/omp/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  m[i] = (int *) calloc(cols, sizeof(int *));\n  for (int j = 0; j < cols; j++)\n  {\n    m[i][j] = getRandomNumber();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/als-movie-recommender/main/2"}
{"code": "for (int i = 0; i < nnz; ++i)\n{\n  fprintf(file, \"%d %d \", row[i] + 1, col[i] + 1);\n  write_value(file, val[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_io/9"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  xvel = us[i][j][k];\n  yvel = vs[i][j][k];\n  zvel = ws[i][j][k];\n  ac = speed[i][j][k];\n  acinv = ainv[i][j][k];\n  ac2u = ac * ac;\n  r1 = rhs[0][i][j][k];\n  r2 = rhs[1][i][j][k];\n  r3 = rhs[2][i][j][k];\n  r4 = rhs[3][i][j][k];\n  r5 = rhs[4][i][j][k];\n  uzik1 = u[0][i][j][k];\n  btuz = bt * uzik1;\n  t1 = (btuz * acinv) * (r4 + r5);\n  t2 = r3 + t1;\n  t3 = btuz * (r4 - r5);\n  rhs[0][i][j][k] = t2;\n  rhs[1][i][j][k] = ((-uzik1) * r2) + (xvel * t2);\n  rhs[2][i][j][k] = (uzik1 * r1) + (yvel * t2);\n  rhs[3][i][j][k] = (zvel * t2) + t3;\n  rhs[4][i][j][k] = (((uzik1 * (((-xvel) * r2) + (yvel * r1))) + (qs[i][j][k] * t2)) + ((c2iv * ac2u) * t1)) + (zvel * t3);\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,xvel ,yvel ,zvel ,ac ,acinv ,r1 ,r2 ,r3 ,r4 ,r5 ,uzik1 ,btuz ,t1 ,t2 ,t3 ,bt ,c2iv ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/159"}
{"code": "for (bar = 0; bar < 3; bar++)\n{\n  switch (foo)\n  {\n    case 1:\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(foo)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr38676/0"}
{"code": "for (i = 0; i < iSize; ++i)\n{\n  ComputeAndSaveBlendColor(C1, C2, Blend, i, C);\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i) shared( C1, C2, C, iSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adammaj1/Mandelbrot-set-with-blended-gradients/src/d/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  fscanf(fptr, \"%f\", &m);\n  b[i] = m;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_1/3"}
{"code": "for (j = 0; j < (n - 1); j++)\n{\n  if (vet[j] > vet[j + 1])\n  {\n    swap(&vet[j], &vet[j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Karnopp/parallel-vector-ordering/ordena/0"}
{"code": "for (int i = 0; i < dim; ++i)\n{\n  for (int j = 0; j < dim; ++j)\n  {\n    result[j][i] = matrix[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OC-ComputerScience/matrix/matrix/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  char str_buffer[genes_length[i]];\n  memcpy(str_buffer, genes[i].c_str(), genes_length[i]);\n  MPI_Bcast(str_buffer, genes_length[i], MPI_CHAR, root, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/submit/xuliny-seqalkway/3"}
{"code": "for (int q = 0; q < N; q++)\n  A[q] = (double *) calloc(N, sizeof(double *));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-5/1"}
{"code": "for (j = start; j < end; j++)\n{\n  {\n    vx[j] = vx[j] + dax[j];\n    vy[j] = vy[j] + day[j];\n    x[j] = x[j] + dvx[j];\n    y[j] = y[j] + dvy[j];\n  }\n}\n\n", "pragma": "omp for schedule(dynamic) num_threads(t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/assignment3_5/0"}
{"code": "for (i = 0; i < r; i++)\n{\n  srand(13 + i);\n  data[i] = populateDataArray(c, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/httpsal/Parallel-Computing/Prodotto Matrice Vettore - MIMD-SM/Elaborato2_Workspace/main/3"}
{"code": "for (j = 2; j <= differences; j++)\n{\n  max_size = max_size - lag;\n  for (i = 0; i < max_size; i++)\n  {\n    y[i] = y[i + lag] - y[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Laurae2/LauraeCpp/src/Rcpp_diffLp_int/1"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    density0[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = density0[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/1"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (int i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp target teams distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_test_out/1"}
{"code": "for (trial = my_first; trial < my_last; trial++)\n{\n  for (i = 0; i < nvars; i++)\n  {\n    startpt[i] = (4.0 * drand48()) - 4.0;\n  }\n\n  jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);\n  fx = f(endpt, nvars);\n  if (fx < best_fx)\n  {\n    best_trial = trial;\n    best_jj = jj;\n    best_fx = fx;\n    for (i = 0; i < nvars; i++)\n      best_pt[i] = endpt[i];\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/katderv/Parallel-Programming/MPI_openMP/0"}
{"code": "for (i = 0; i < 1000000000; i++)\n  pi += f(i * h);\n\n", "pragma": "omp parallel for schedule(static) reduction(+:pi) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture13/pi_omp/0"}
{"code": "for (int i = 0; i < (size - 1); i++)\n{\n  for (int j = i + 1; j < size; j++)\n  {\n    double k = (-M[(j * size) + i]) / M[(i * size) + i];\n    b[j] += b[i] * k;\n    for (int l = i; l < size; l++)\n    {\n      M[(j * size) + l] += M[(i * size) + l] * k;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LukasZahradnik/cpp-gauss/main/0"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  sequential_bitonic_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bitonicsort/8"}
{"code": "for (i = 0; i < 250; i++)\n{\n  for (j = 0; j < 250; j++)\n  {\n    hz[(i * 250) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / 250;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/31"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  double mi;\n  if (PTYPE[i] == 1)\n    mi = DNS_FL1;\n  else\n    mi = DNS_FL2;\n\n  double pressure = 0.0;\n  if (particleBC[i] == inner)\n  {\n    pressure = ((pndi[i] - pndSmallZero) * coeffPressEMPS) * mi;\n  }\n\n  if (pressure < 0.0)\n  {\n    pressure = 0.0;\n  }\n\n  press[i] = pressure;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/49"}
{"code": "for (i = 0; i < 3; i++)\n  printf(\"Before : a[%d] = %d\\n\", i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/009_firstprivate_clause/2"}
{"code": "for (int i = 0; i < p_len; i++)\n{\n  float dist = getDist(p_list[i], center);\n  (((((((((cout << \"|    \") << i) << \"  \\t|   \") << old_dist[i]) << \"    \\t|   \") << dist) << \"    \\t| \") << (old_dist[i] - dist)) << \" \\t| \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lewis98/OpenMP_Tasks/parallelism/main/6"}
{"code": "for (int i = 0; i < moves.size(); i++)\n  free(moves[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlSaeed/15618-Final-Project/mcts_player/3"}
{"code": "for (uint32_t i = 0; i < nTrainingPoints; i++)\n{\n  for (uint32_t j = 0; j < nTrainingPoints; j++)\n  {\n    double xDistancePart = trainPointX[i] - trainPointX[j];\n    xDistancePart = xDistancePart * xDistancePart;\n    xDistancePart /= L1SquareMulti2;\n    double yDistancePart = trainPointY[i] - trainPointY[j];\n    yDistancePart = yDistancePart * yDistancePart;\n    yDistancePart /= L2SquareMulti2;\n    double totalDistance = yDistancePart + xDistancePart;\n    double kValue = exp(-totalDistance) * oneOverSqrt2Pi;\n    trainingK[(i * nTrainingPoints) + j] = kValue;\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogether/4"}
{"code": "for (arrayCounter = 0; arrayCounter < numberOfArrays; arrayCounter = arrayCounter + numOfTransferedArrays)\n{\n  mainTimer.Start();\n  MergeOnMic(array, arrayCounter, arraySize, numOfTransferedArrays, numberOfArrays);\n  mainTimer.Stop();\n  medianTimer.PushTime(mainTimer.Get());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/ClientServer/main/7"}
{"code": "for (i = 0; i < nthr; i++)\n  pi += sums[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DanielMChaves/CAR_OpenMP/sesion_1/src/ejemplo5_pi/pi_omp_spmd/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  if (testhash[i] != buffer[(sz - 20) + i])\n  {\n    return -2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/kwallet_fmt_plug/5"}
{"code": "for (i = 1; i < 2048; i++)\n  newgrid[i] = newgrid[0] + (i * 2048);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DAToneli/highlife/golomp/4"}
{"code": "for (i = 0; i < encrypted_messages.size(); ++i)\n{\n  decrypted_messages[i] = XOR(aes.encrypt(ctrs[i]), encrypted_messages[i]);\n}\n\n", "pragma": "\t\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/franneck94/CUDA-AES/AES OpenMP/Mode/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    aDual[i][j] = -1;\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trannguyendev/transportation-problem/ss/1"}
{"code": "for (chunk = 0; chunk < actual_num_workers; chunk++)\n{\n  const int start_index = chunk * max_chunks;\n  int * restrict my_local_key_counts_1D = my_local_key_counts[chunk];\n  const int * restrict const my_bucket_keys_1D = &my_bucket_keys[start_index];\n  for (int i = 0; i < max_chunks; i++)\n  {\n    const unsigned int key_index = my_bucket_keys_1D[i] - my_min_key;\n    assert(my_bucket_keys_1D[i] >= my_min_key);\n    assert(key_index < BUCKET_WIDTH);\n    my_local_key_counts_1D[key_index]++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(chunk) schedule (static,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/4"}
{"code": "for (int i = 0; i < elements.size(); i++)\n{\n  if (isTransValid(*elements[i], L) == true)\n  {\n  }\n  else\n  {\n    mtx.lock();\n    elements[i] = C.erase(elements[i]);\n    mtx.unlock();\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BaoVo96/Apriori/apriori_v2_omp_final/7"}
{"code": "for (uint32_t i = 0; i < new_polygon_id_list.size(); i++)\n{\n  new_polygon_id_list[i] += start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/13"}
{"code": "for (j = 0; j < N; ++j)\n  sum += Matr[i][j] * vect[j];\n\n", "pragma": "    #pragma omp paralell for redunction(+ : sum)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/3/3/2"}
{"code": "for (i = 1; i < n; i += 2)\n{\n  if (j > i)\n  {\n    tempr = data[j];\n    data[j] = data[i];\n    data[i] = tempr;\n    tempr = data[j + 1];\n    data[j + 1] = data[i + 1];\n    data[i + 1] = tempr;\n  }\n\n  m = n >> 1;\n  while ((m >= 2) && (j > m))\n  {\n    j -= m;\n    m >>= 1;\n  }\n\n  j += m;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP2.2/Shashank_CP2.2_11110094_Report+Codes/Shashank_CP2.2_11110094_Report+Codes/Codes for OpenMP_Shashank/Q4/fft_parallel/6"}
{"code": "for (i = 0; i < (c_n * c_m); i++)\n{\n  C[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/14"}
{"code": "for (int i = 0; i < camera.getFilmWidth(); ++i)\n{\n  for (int j = 0; j < camera.getFilmHeight(); ++j)\n  {\n    data.raw[byte++] = r;\n    data.raw[byte++] = g;\n    data.raw[byte++] = b;\n    data.raw[byte++] = a;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/debowin/fray-tracer/Scene/0"}
{"code": "for (int i = 0; i < (inds_per_mpi_task.quot + inds_per_mpi_task.rem); i++)\n{\n  if (i < inds_per_mpi_task.quot)\n  {\n    evaluate_ind(i, &pop->ind[i]);\n  }\n  else\n  {\n    int start = (mpiProcessors * inds_per_mpi_task.quot) + (i - inds_per_mpi_task.quot);\n    evaluate_ind(start, &pop->ind[start]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydroCouple/ParallelNSGAII/eval/1"}
{"code": "for (long i = G.in_row[v]; i < G.in_row[v + 1]; i++)\n{\n  R.I_src.push_back(G.out_col[i]);\n  R.I_dst.push_back(v);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RickyDevMJ/Decremental-SCC/decremental_cpu/5"}
{"code": "for (int i = 0; i < h; i++)\n{\n  a = pow(-1.0, i);\n  int b = a;\n  for (int j = 0; j < w; j++)\n  {\n    outFrame->imageData[(3 * ((i * w) + j)) + 0] = (char) (b * inpB[2 * ((i * w) + j)]);\n    outFrame->imageData[(3 * ((i * w) + j)) + 1] = (char) (b * inpG[2 * ((i * w) + j)]);\n    outFrame->imageData[(3 * ((i * w) + j)) + 2] = (char) (b * inpR[2 * ((i * w) + j)]);\n    b *= -1;\n  }\n\n  a *= -1;\n}\n\n", "pragma": "  #pragma omp parallel for private(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/13. filter (full parallel)/filter/20"}
{"code": "for (int i = 1; i < 10000; i++)\n{\n  if (vec[i] < vec[i - 1])\n  {\n    printf(\"Vectorul nu este ordonat!\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/florin-alistar/AlistarSerbanFlorin_Tema1_OpenMP/radix/4"}
{"code": "for (int proc = 0; proc < p; proc++)\n{\n  if (proc == rank)\n  {\n    MPI_Cart_coords(cartcomm, rank, 2, coord);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rachnasidana28/ParallelProcessing/Cannon's Algorithm/MPI_OpenMp/8"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    fprintf(output, \"%d \", matrix[i][j]);\n  }\n\n  fprintf(output, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sonamt731/PrimeNumbersParallel/primes/2"}
{"code": "for (i = rb; i < re; i++)\n  p_zw[i] = p_zw[i] + (beta * p_w[iter - j][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/27"}
{"code": "for (int n = 0; n < 10; n++)\n{\n  for (int i = 0; i < (100 + 1); i++)\n  {\n    WL2[n][i] += 0.2 * WL2delta[n][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn07/9"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = ((((double) ((n - i) - 1)) * a) + (((double) i) * b)) / ((double) (n - 1));\n  total = total + f(x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh543/openmp-programs/quad_openmp/0"}
{"code": "for (int j = 2; j < ncy; ++j)\n{\n  for (int k = 2; k < ncz; ++k)\n  {\n    iBC = 2;\n    for (int i = 0; i <= 1; ++i)\n    {\n      s = columnMajorLinearIndex(i, j, k, ncx, ncy);\n      sBC = columnMajorLinearIndex(iBC, j, k, ncx, ncy);\n      setGhostCellVars(q, e, p, u, s, sBC);\n    }\n\n    iBC = nx + 1;\n    for (int i = nx + 2; i <= (nx + 3); ++i)\n    {\n      s = columnMajorLinearIndex(i, j, k, ncx, ncy);\n      sBC = columnMajorLinearIndex(iBC, j, k, ncx, ncy);\n      setGhostCellVars(q, e, p, u, s, sBC);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/rhic/jail/rhic-trunk/src/main/cpp/edu/osu/rhic/trunk/hydro/DynamicalVariables/0"}
{"code": "for (int n_thread = 1; n_thread <= 16; n_thread *= 2)\n{\n  omp_set_num_threads(n_thread);\n  parallelFilterFirst(((512 * 512) * 128) * n_thread, input_array, output_array, filter_len, filter_list);\n  memset(output_array, 0, ((512 * 512) * 128) * 16);\n  parallelDataFirst(((512 * 512) * 128) * n_thread, input_array, output_array, filter_len, filter_list);\n  memset(output_array, 0, ((512 * 512) * 128) * 16);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adiggo/openmp/source/filterScaleUp/3"}
{"code": "for (int i = 0; i < Nt; i++)\n{\n  del = Randint();\n  rho = 1.0;\n  for (int j = 0; j < Ns; j++)\n  {\n    x[0] = i;\n    x[1] = j;\n    shiftx(x_, x, -1, 1);\n    if (del > 0)\n    {\n      if (k[i][j][1] >= 0)\n        rho *= 1.0 / ((k[i][j][1] + 1) + a[i][j][1]);\n      else\n        rho *= abs(k[i][j][1]) + a[i][j][1];\n\n      if ((k[x[0]][x[1]][1] >= 0) && (k[x_[0]][x_[1]][1] >= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][1] < 0) && (k[x_[0]][x_[1]][1] < 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n    }\n    else\n    {\n      if (k[i][j][1] > 0)\n        rho *= k[i][j][1] + a[i][j][1];\n      else\n        rho *= 1.0 / ((abs(k[i][j][1]) + a[i][j][1]) + 1);\n\n      if ((k[x[0]][x[1]][1] <= 0) && (k[x_[0]][x_[1]][1] <= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][1] > 0) && (k[x_[0]][x_[1]][1] > 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n    }\n\n  }\n\n  if (Rand() < rho)\n  {\n    for (int j = 0; j < Ns; j++)\n    {\n      k[i][j][1] += del;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(rho, del, x, x_)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/8"}
{"code": "for (i = 1; i < (400 - 1); ++i)\n{\n  for (j = 1; j < (400 - 1); ++j)\n  {\n    B[(i * 400) + j] = ((((((((c11 * A[((i - 1) * 400) + (j - 1)]) + (c12 * A[((i + 0) * 400) + (j - 1)])) + (c13 * A[((i + 1) * 400) + (j - 1)])) + (c21 * A[((i - 1) * 400) + (j + 0)])) + (c22 * A[((i + 0) * 400) + (j + 0)])) + (c23 * A[((i + 1) * 400) + (j + 0)])) + (c31 * A[((i - 1) * 400) + (j + 1)])) + (c32 * A[((i + 0) * 400) + (j + 1)])) + (c33 * A[((i + 1) * 400) + (j + 1)]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/2DCONV/2DConvolution/15"}
{"code": "for (i = 0; i < N; i++)\n{\n  last_v[i][0] = v[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/10"}
{"code": "for (i = 0; i < 7; i++)\n  printf(\"%d\", i);\n\n", "pragma": "omp for schedule(static, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E2/1/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,k ,m ,dt ,nz ,jst ,jend ,i ,istep )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/100"}
{"code": "for (i = 0; i < 20; i++)\n{\n  a[i] = i;\n  b[i] = 2 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/courspolytech/Presentation-exemplesOMP/sources/parallelfor+/1"}
{"code": "for (size_t i = 0; i < Drawings.size(); i++)\n{\n  Drawings[i].Update();\n}\n\n", "pragma": "#pragma omp parallel for num_threads(Params.Simulator.NumThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/FourierDraw/Source/FourierDraw/3"}
{"code": "for (i = 1; i < (30 - 1); i++)\n{\n  int thread_1 = calc_thread(30, 30, i, 0);\n  int thread_2 = calc_thread(30, 30, i, 30 - 1);\n  printf(\"%d L: %p\\n\", thread_1, &w[i][0]);\n  printf(\"%d L: %p\\n\", thread_2, &w[i][30 - 1]);\n  mean = (mean + w[i][0]) + w[i][30 - 1];\n}\n\n", "pragma": "omp for reduction ( + : mean )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/4"}
{"code": "for (int i = 0; i < get_npart(); ++i)\n{\n  particles_[i].mass = n * unif_d(gen);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nbody-omp/GSimulation/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (i == 0)\n  {\n    file << \"[\";\n  }\n  else\n  {\n    file << \", [\";\n  }\n\n  for (int j = 0; j < N; j++)\n  {\n    if (j == (N - 1))\n    {\n      file << C_n[i][j];\n    }\n    else\n    {\n      (file << C_n[i][j]) << \", \";\n    }\n\n  }\n\n  file << \"]\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/final-version/advection_simulation/0"}
{"code": "for (i = 0; i < n; i++)\n  y[i] = (a[i] * x[i]) + b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/daxpy/0"}
{"code": "for (i = 0; i < N; ++i)\n{\n  c[i] = a[i] * b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saitotm/openmp_exercise/06array_mul/1"}
{"code": "for (int i = 0; i < (this->nrow_ + 1); ++i)\n{\n  this->mat_.row_offset[i] = cast_mat->mat_.row_offset[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/5"}
{"code": "for (i = 0; i < size; i++)\n{\n  printf(\"%d \\t\", m3[i][0]);\n  for (j = 1; j < size; j++)\n  {\n    printf(\"%d \\t\", m3[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mahmoud-elzorkany/Open_Mp/Matrix Multiplication/Matrix Multiplication/3"}
{"code": "for (register int idx = 1; idx <= max_iter_times; idx += 2)\n{\n  cur_pi += ((idx >> 1) & 1) ? ((-4.) / idx) : (4. / idx);\n}\n\n", "pragma": "omp parallel for reduction(+:cur_pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/pi/my_pi/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  int _imopVarPre250;\n  int _imopVarPre251;\n  _imopVarPre250 = d[i];\n  _imopVarPre251 = ilog2(_imopVarPre250);\n  logd[i] = _imopVarPre251;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/17"}
{"code": "for (i = 0; i <= ((len / 2) - 1); i += 1)\n{\n  a[(2 * i) + 1] = a[i] + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB034-truedeplinear-var-yes/0"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  finalRightBuf[i] = leftRecvBuf[i];\n  finalLeftBuf[i] = rightRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(leftRecvBuf,rightRecvBuf,dataSize,sizeofBuffer) shared(finalLeftBuf,finalRightBuf) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_haloexchange/2"}
{"code": "for (int k = 0; k < n; k++)\n{\n  int begin = (k + 1) + ((*threadid) * (((n - k) - 1) / thread_count));\n  int end = begin + (((n - k) - 1) / thread_count);\n  if (end > n)\n    end = n;\n\n  for (int i = begin; i < end; i++)\n  {\n    for (int j = k + 1; j < n; j++)\n    {\n      A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n    }\n\n    A[i][k] = 0;\n  }\n\n  sem_post(&sem_parent);\n  pthread_barrier_wait(&childbarrier_row);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/2"}
{"code": "for (size_t i = 0; i < n; i++)\n  dot += a[i] * b[i];\n\n", "pragma": "\t#pragma omp parallel for reduction(+: dot) schedule(dynamic,10000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/dot_pdt/1"}
{"code": "for (int i = 0; i < 250; i++)\n{\n  for (int j = 0; j < 250; j++)\n  {\n    printf(\"%d \", E[j][i]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-HW/3/code/1.2/1"}
{"code": "for (j_imopVarPre78 = nrows; j_imopVarPre78 >= 1; j_imopVarPre78--)\n{\n  rowstr[j_imopVarPre78 + 1] = rowstr[j_imopVarPre78];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/26"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    omp_destroy_lock(&locks[x][y]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbsousa01/Game-of-Life3D/life3d-omp/7"}
{"code": "for (int i = 0; i < cloud_size; ++i)\n{\n  bool found = false;\n  for (int seed_point_index = start_index; seed_point_index < search_points; ++seed_point_index)\n  {\n    if (i == queue[seed_point_index])\n    {\n      found = true;\n    }\n    else\n    {\n      int array_index = (queue[seed_point_index] * aligned_length) + i;\n      if (sqr_distances[array_index])\n      {\n        found = true;\n      }\n\n    }\n\n  }\n\n  indices[i] = found;\n}\n\n", "pragma": "        #pragma omp target teams distribute parallel for simd \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/5"}
{"code": "for (i = 0; i < 115; i++)\n{\n  distance_2 = distance_2 + pow(point.coordinate[i] - cluster.coordinate[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolas-carolo/K-means/kmeans_parallel/10"}
{"code": "for (int i = 0; i < 20; i++)\n  for (int j = 0; j < 20; j++)\n  A[i][j] = ((((B[i][j] + A[i - 1][j]) + B[i + 1][j]) + B[i][j - 1]) + B[i][j + 1]) * 0.2;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/6.race2/0"}
{"code": "for (int i = 0; i < dict_get_word_count(passwords); i++)\n{\n  char *encrypted = dict_get_word(passwords, i);\n  int success = pthread_try_crack(encrypted, dicts, dicts_len, 0, buf, buflen, 0);\n  if (success == 1)\n  {\n    printf(\"%3d: SUCCES: %s <-- %s\\n\", i, encrypted, buf);\n    successes++;\n  }\n  else\n  {\n    printf(\"%3d: FAILED: %s <-- %s\\n\", i, encrypted, \"???\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mnahmad12/PasswordCracking-PThreads-OpenMP/pthread_passcrack/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  a[i] = -10;\n  b[i] = -10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter3/fl/1"}
{"code": "for (int i = 0; i < n; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/unified_address/unified_address/0"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  if (distance[i] == level)\n  {\n    for (int j = row[i]; j < row[i + 1]; j++)\n    {\n      int u = col[j];\n      if (distance[u] < 0)\n      {\n        mf -= distance[u];\n        distance[u] = level + 1;\n        improvement = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for reduction(-:mf) reduction(||:improvement) schedule(guided, 32)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/hybrid/1"}
{"code": "for (int j = x_min - 2; j <= (x_max + 3); j++)\n{\n  vertexx[FTNREF1D(j, x_min - 2)] = min_x + (d_x * ((double) (j - x_min)));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/4"}
{"code": "for (int i = 0; i < ds.size(); ++i)\n{\n  for (int j = 0; j < (cnames.size() + 1); ++j)\n  {\n    (out << ds[i][j]) << ((j == cnames.size()) ? (\"\\n\") : (\",\"));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FieryCod/openmp-class-bench/src/knn/1"}
{"code": "for (unsigned int j = 0; j < (N / 12); ++j)\n  sketch[i].emplace_back(0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esalini22/gene-hll/HyperLogLog/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if (result_2[i] != i)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/tests/openmp/unit/for_dynamic/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  for (int j = 0; j < 100; j++)\n  {\n    a[i][j] = 1;\n    b[i][j] = 2;\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(a,b,c)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/noah-vaati/OpenMP-Matrix-Multiplier/OpenMP Matrix Multiplication/q2/0"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  a[i] = a[i] + a[i];\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-17-ParForLoopNoWaitBarrier/0"}
{"code": "for (i = 0; i <= N; i++)\n{\n  if (i == 0)\n    res[i] = forward(x, step, i);\n  else\n    if (i < N)\n    res[i] = central(x, step, i);\n  else\n    res[i] = backward(x, step, i);\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe3/Tsouros_num_diff/1"}
{"code": "for (j = 0; j < size2; j++)\n{\n  accelx[j] = 0;\n  accely[j] = 0;\n  accelz[j] = 0;\n  glColor3f(0.0f, 1.0f, 0.0f);\n  glVertex3f(posx[j], posy[j], posz[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  tmpi = DSECND();\n  while ((DSECND() - tmpi) < 0.25)\n    ;\n\n  if (((me == 0) && (size > 1)) && (i != 0))\n  {\n    MPI_Send(&itmp, 0, MPI_BYTE, i, i, 1);\n  }\n\n  if (((me == i) && (size > 1)) && (i != 0))\n  {\n    MPI_Recv(&itmp, 0, MPI_BYTE, 0, i, 1, &status);\n  }\n\n  if (me == i)\n  {\n    fflush(0);\n    printf(\"(%d of %d): \", me, size);\n    printf(\"%c%c lda=%4d ldb=%4d ldc=%4d %1d %1d %1d %08.3f \", transa, transb, lda, ldb, ldc, iaoff, iboff, icoff, high / (1000000.0 * t1));\n    fflush(0);\n    printf(\"LIB2: %08.3f Number of errors=%d Total Error detected=%g \", high / (1000000.0 * t2), nerrs, derr);\n    fflush(0);\n    char hostname[MPI_MAX_PROCESSOR_NAME];\n    int namelen;\n    if (MPI_Get_processor_name(hostname, &namelen) == MPI_SUCCESS)\n      printf(\"%-.*s\\n\", namelen, hostname);\n\n    fflush(0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/20"}
{"code": "for (int i = 0; i < m_nRows; i++)\n{\n  for (int j = 0; j < m_nLayers; j++)\n  {\n    if (!FloatEqual(data[i][j], NODATA_VALUE))\n    {\n      if (FloatEqual(m_2DData[i][j], NODATA_VALUE))\n      {\n        m_2DData[i][j] = MISSINGFLOAT;\n      }\n\n      if (data[i][j] >= m_2DData[i][j])\n      {\n        m_2DData[i][j] = data[i][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/6"}
{"code": "for (i = 0; i < num_levels; i++)\n  hist[i] = 0;\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/workout_2_histogram_equalization/workout2_16EE30025/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  fprintf(fp, \"\\nPosititon of body %d: (%.20lf,%.20lf,%.20lf)\", i, position[i].x, position[i].y, position[i].z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/roy-1996/Many-Body-Problem/many_body_problem/3"}
{"code": "for (i = 1; i <= S; i++)\n  if (mas[i])\n  count++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/df7734/OpenMPI/OpenMPI/OpenMPI/main/3"}
{"code": "for (j = 1; j < (((L / NODESY) + 2) - 1); j++)\n{\n  i = 0;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = grn[j];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = grn[j];\n\n  i = ((L / 1) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    whites[ii][j].data = grs[j];\n  else\n    blacks[ii - (((L / 1) + 2) / 2)][j].data = grs[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/90"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][1024];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha1((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), (unsigned char *) cur_salt->salt, 8, 1000, master[i], 1024, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    SHA512_CTX ctx;\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, master[i], 1024);\n    SHA512_Final((unsigned char *) crypt_out[index + i], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/solarwinds_fmt_plug/0"}
{"code": "for (j = 0; j < M; j++)\n{\n  Board(0, j) = NewBoard(0, j);\n  Board(N - 1, j) = NewBoard(N - 1, j);\n}\n\n", "pragma": "omp parallel for private(j) shared(board,newboard) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/9"}
{"code": "for (k = 0; k < b; k++)\n{\n  for (i = 0; i < b; i++)\n    for (j = 0; j < b; j++)\n    if ((A[b_row + i][b_col + k] < INT_MAX) && (A[c_row + k][c_col + j] < INT_MAX))\n    A[a_row + i][a_col + j] = min(A[a_row + i][a_col + j], A[b_row + i][b_col + k] + A[c_row + k][c_col + j]);\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BineshTharikoppula/Parallel-Tiled-Floyd-Warshall/FinalAPSP/0"}
{"code": "for (int i = 0; i < (64 * 5000); i++)\n{\n  if (A[i] != 600)\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, ((double) (2.0 + 3.0)) * 600, A[i]);\n    fail = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/issue_001/issue_001/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    printf(\"%lf \", phi[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiackAloZ/OPoly/benchmarks/src/omp-gauss-seidel-2d/3"}
{"code": "for (i = 0; i < tamanho; i++)\n{\n  if (vetor[i] > maior)\n    maior = vetor[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/radixsort/7"}
{"code": "for (i = 0; i < 128; i++)\n{\n  for (j = 0; j < 128; j++)\n  {\n    x1[i] = x1[i] + (a[(i * 128) + j] * y1[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/MVT/mvt/27"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  topoinfo->Gname[i] = (char *) calloc(100, sizeof(char));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/46"}
{"code": "for (int j = startInd; j <= endInd; j++)\n  c[j] += a[j] + (alpha * b[j]);\n\n", "pragma": "#pragma omp target teams distribute parallel for device(dev) map(alloc: c[0:arrSize], a[0:arrSize], b[0:arrSize], numBlocks, ndevs, ctaskwork) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/ecp-omp/Stream/bench/3"}
{"code": "for (i = 0; i < y_point_n; ++i)\n{\n  ++job_n;\n  for (j = 0; j < x_point_n; ++j)\n  {\n    z.real = 0.0;\n    z.imag = 0.0;\n    c.real = x_left + (((double) j) * ((x_right - x_left) / ((double) x_point_n)));\n    c.imag = y_lower + (((double) i) * ((y_upper - y_lower) / ((double) y_point_n)));\n    repeats = 0;\n    lengthsq = 0.0;\n    while ((repeats < 10000) && (lengthsq < 4.0))\n    {\n      temp = ((z.real * z.real) - (z.imag * z.imag)) + c.real;\n      z.imag = ((2 * z.real) * z.imag) + c.imag;\n      z.real = temp;\n      lengthsq = (z.real * z.real) + (z.imag * z.imag);\n      repeats++;\n    }\n\n    canvas[j][i] = (1024 * 1024) * (repeats % 256);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kjs1095/PP/mandelbrot-set/MS_OpenMP_dynamic_col/0"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  SHA512_CTX ctx;\n  memcpy(saved_key[index] + saved_len[index], cursalt, 4);\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, saved_key[index], saved_len[index] + 4);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mssql12_fmt_plug/0"}
{"code": "for (size_t i = 0; i < (*output_position).size(); i++)\n{\n  int digitsAfterDecimal = 5;\n  int width = digitsAfterDecimal + string(\"-0.e+00\").length();\n  ((((((((((((cout << type[i]) << \",\") << scientific) << setprecision(digitsAfterDecimal)) << setw(width)) << (*output_position)[i].s[0]) << \",\") << setw(width)) << (*output_position)[i].s[1]) << \",\") << setw(width)) << (*output_position)[i].s[2]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jm3zhang/Programming-for-Performance/Improve Performance using OpenCL/Simulate Coulomb\u2019s Law Problem using OpenCL/src/Simulation/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  {\n    for (j = 0; j < 10; j++)\n      sum += j;\n\n  }\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49898-1/0"}
{"code": "for (l = starti; l < finishi; l++)\n{\n  int cost[3];\n  int tmp;\n  cost[0] = prev[l] + 1;\n  cost[1] = pprev[l] + (a[q_i] != b[p_i]);\n  cost[2] = prev[l + 1] + 1;\n  tmp = (cost[0] < cost[1]) ? (cost[0]) : (cost[1]);\n  tmp = (tmp < cost[2]) ? (tmp) : (cost[2]);\n  act[l] = tmp;\n  p_i++;\n  q_i--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/11"}
{"code": "for (i = 0; i < id; i++)\n{\n  offset += carrier[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/OpenMP_examples/prefixsum/1"}
{"code": "for (size_t index = ghostStartIndex; index < ghostEndIndex; index++)\n{\n  size_t neiListStartIndex = index * maxNeiNum;\n  m_pNeighbourSearcher->searchNeighbour(positionX[index], positionY[index], positionZ[index], m_fNeiSearchRadius, neighbourList + neiListStartIndex, neiListDist, numNeiFound, index);\n  neighbourListSize[index] = numNeiFound;\n  changeNeighbourhoodToIncludeOnlyFluidNei(index, numNeiFound);\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/9"}
{"code": "for (i = 0; i < numdims; i++)\n  result += (coord1[i] - coord2[i]) * (coord1[i] - coord2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/conganh1991999/OpenMpKmeans/omp_kmeans/0"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    neighborAlive = getNeighbors(grid, i, j);\n    if (grid[i][j] == 0)\n    {\n      if ((neighborAlive == 3) || (neighborAlive == 6))\n        newGrid[i][j] = 1;\n      else\n        newGrid[i][j] = 0;\n\n    }\n    else\n    {\n      if ((neighborAlive != 2) && (neighborAlive != 3))\n        newGrid[i][j] = 0;\n      else\n        newGrid[i][j] = 1;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,neighborAlive)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alvaro-cardoso/Jogo_da_Vida_MultiThread/HighLife/0"}
{"code": "for (j = 0; j < len; j++)\n{\n  temp = u[i][j];\n  sum = sum + (temp * temp);\n}\n\n", "pragma": "omp parallel for private(j, temp) reduction(+: sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB021-reductionmissing-orig-yes/3"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  foo();\n  goto L2;\n  {\n    L2:\n    foo();\n\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/ordered_messages/7"}
{"code": "for (int i = 0; i < size; i++)\n  (solution_output << solution[i]) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaempunk/linear-equations-solution-openmp/linear_equations/4"}
{"code": "for (int iter = 0; iter < iters; iter++)\n{\n  #pragma acc parallel loop gang vector collapse(2)\n  for (int i = 0; i < len; i++)\n  {\n    for (int j = 0; j < len; j++)\n    {\n      float t = 0;\n      for (int k = 0; k < len; k++)\n        t += a[k + (j * len)] * b[i + (k * len)];\n\n      x[i + (j * len)] = t;\n    }\n\n  }\n\n  #pragma acc parallel loop gang vector\n  for (int i = 0; i < (len * len); i++)\n  {\n    a[i] = x[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/acc/matmul/4"}
{"code": "for (int x = 0; x < total_de_palavras_chaves; x++)\n{\n  num_ocorrencias(palavras_chaves[x]);\n}\n\n", "pragma": "omp parallel for num_threads(total_de_palavras_chaves)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ViniciusmDias/contador-de-palavras/paralelo/contadorDePalavras/0"}
{"code": "for (i = 0; i < tam_vetor; i++)\n{\n  if (i == (tam_vetor - 1))\n    printf(\"%d.\", vetor[i]);\n  else\n    printf(\"%d, \", vetor[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aulospl/TrabConcorrente/PRSR/3"}
{"code": "for (int dest = 1; dest < numtasks; dest++)\n{\n  MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, dest, 0, 1);\n  offset += chunksize;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP2/MPI+OMP/mandelbrot_openmpi+omp/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  error += (b[i] - a[i]) * (b[i] - a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex3/ex3/18"}
{"code": "for (y = 2; y < (in->y - 2); y++)\n{\n  for (x = 2; x < (in->x - 2); x++)\n  {\n    int gridCounter = 0;\n    int finalR = 0;\n    int finalG = 0;\n    int finalB = 0;\n    for (y2 = -2; y2 <= 2; y2++)\n    {\n      for (x2 = -2; x2 <= 2; x2++)\n      {\n        finalR += in->data[((y + y2) * width) + (x + x2)].red * filter[gridCounter];\n        finalG += in->data[((y + y2) * width) + (x + x2)].green * filter[gridCounter];\n        finalB += in->data[((y + y2) * width) + (x + x2)].blue * filter[gridCounter];\n        gridCounter++;\n      }\n\n    }\n\n    finalR /= div;\n    finalG /= div;\n    finalB /= div;\n    out->data[(y * width) + x].red = finalR;\n    out->data[(y * width) + x].green = finalG;\n    out->data[(y * width) + x].blue = finalB;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Oneloves/Introduction-to-OpenMP/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (i = 0; i < orderOfMatrix; i++)\n  matrixAux[i] = malloc(orderOfMatrix * (sizeof(*matrixAux[i])));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/10"}
{"code": "for (m = 0; m < 5; m++)\n{\n  k = 1;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((5.0 * ue[m][k]) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n  k = 2;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((((-4.0) * ue[m][k - 1]) + (6.0 * ue[m][k])) - (4.0 * ue[m][k + 1])) + ue[m][k + 2]));\n}\n\n", "pragma": "omp parallel for firstprivate(dssp ,m ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/32"}
{"code": "for (i = 0; i < n; i++)\n  length[i] = 10 * (i + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/021_threadprivate_example/1"}
{"code": "for (i = 1; i < (pcinfo.x_cells_num - 1); i++)\n{\n  int index_i = pcinfo.x_cell_pos + i;\n  int index_j = pcinfo.y_cell_pos + j;\n  df[(j * pcinfo.x_cells_num) + i] = ((((f[(j * pcinfo.x_cells_num) + i] - f[((j * pcinfo.x_cells_num) + i) - 1]) / hx_(index_i - 1)) - ((f[((j * pcinfo.x_cells_num) + i) + 1] - f[(j * pcinfo.x_cells_num) + i]) / hx_(index_i))) / hhx_(index_i)) + ((((f[(j * pcinfo.x_cells_num) + i] - f[((j - 1) * pcinfo.x_cells_num) + i]) / hy_(index_j - 1)) - ((recv_message_bu[i] - f[(j * pcinfo.x_cells_num) + i]) / hy_(index_j))) / hhy_(index_j));\n}\n\n", "pragma": "                #pragma omp for schedule (static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/9"}
{"code": "for (int i = 0; i < bsz; ++i)\n  for (int j = 0; j < bsz; ++j)\n  for (int k = 0; k < bsz; ++k)\n  C[IDX(i, j)] -= A[IDX(i, k)] * B[IDX(k, j)];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zooltd/LU-decomposition/lu/6"}
{"code": "for (r = 1; r < (ROWS - 1); r++)\n{\n  for (c = 1; c < (COLUMNS - 1); c++)\n  {\n    setVal(cells, r, c, rand() % 2);\n    setVal(tempCells, r, c, getVal(cells, r, c));\n  }\n\n}\n\n", "pragma": "omp parallel for private(c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IsaacLehman/Game-of-Life/GameOfLife/0"}
{"code": "for (int i = 1; i <= wf.n1; i++)\n{\n  for (int j = 0; j < (wf.n2 + 2); j++)\n  {\n    const int index = wf.in2(j, i);\n    d.v_1D[j] = p.ABV_V[index];\n    d.wf_1D[j] = wf.wave[index];\n  }\n\n  for (int j = 1; j <= wf.n2; j++)\n  {\n    arg_V = (idt * .5) * d.v_1D[j];\n    d.tridag_mid[j] = (1. - (2. * arg_A)) + arg_V;\n    d.wf_1D_rightside[j] = (((-tridag_low_Fast) * d.wf_1D[j - 1]) + (((1. + (2. * arg_A)) - arg_V) * d.wf_1D[j])) - (tridag_upp_Fast * d.wf_1D[j + 1]);\n    if (j == 1)\n    {\n      if (wf.symmetry_x2 == 1)\n      {\n        d.tridag_mid[j] = ((1. - arg_A) - arg_B) + arg_V;\n        d.wf_1D_rightside[j] = (((-tridag_low_Fast) * d.wf_1D[j - 1]) + ((((1. + arg_A) + arg_B) - arg_V) * d.wf_1D[j])) - (tridag_upp_Fast * d.wf_1D[j + 1]);\n      }\n\n      if (wf.symmetry_x2 == (-1))\n      {\n        d.tridag_mid[j] = ((1. - (3. * arg_A)) + arg_B) + arg_V;\n        d.wf_1D_rightside[j] = (((-tridag_low_Fast) * d.wf_1D[j - 1]) + ((((1. + (3. * arg_A)) - arg_B) - arg_V) * d.wf_1D[j])) - (tridag_upp_Fast * d.wf_1D[j + 1]);\n      }\n\n    }\n\n  }\n\n  Tridag_Fast(tridag_low_Fast, d.tridag_mid, tridag_upp_Fast, d.wf_1D_rightside, d.wf_1D_solution, d.gam);\n  for (int j = 1; j <= wf.n2; j++)\n  {\n    wf.wave[wf.in2(j, i)] = d.wf_1D_solution[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/2"}
{"code": "for (int j = 0; j < numOutputs; ++j)\n{\n  double a = output_bias[j];\n  for (int k = 0; k < numHidden2Nodes; ++k)\n  {\n    a += layer2[k] * output_weights[j][k];\n  }\n\n  output[j] = act(a);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/7"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (i = grid_points[0] - 3; i >= 0; i--)\n  {\n    i1 = i + 1;\n    i2 = i + 2;\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k])) - (lhs[n + 4][i][j][k] * rhs[m][i2][j][k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,m ,n )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/173"}
{"code": "for (i = 0; i < 750; i++)\n{\n  for (j = 0; j < 750; j++)\n  {\n    C[(i * 750) + j] = (((DATA_TYPE) i) * (j + 3)) / 750;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/2MM/2mm_cpu/4"}
{"code": "for (i = 1; i < (L - 1); i++)\n{\n  for (j = 1; j < (L - 1); j++)\n  {\n    double r;\n    int index = getIndex(i, j, L);\n    int pos_l = getIndex(i - 1, j, L);\n    int pos_r = getIndex(i + 1, j, L);\n    int pos_u = getIndex(i, j + 1, L);\n    int pos_d = getIndex(i, j - 1, L);\n    r = ((((-1.0) * p.alpha) * phi[index]) + ((p.alpha / 4.0) * (((phi[pos_l] + phi[pos_r]) + phi[pos_u]) + phi[pos_d]))) + res[index];\n    residual += r * r;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) shared(phi, res, p, L) reduction(+:residual)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/parallel_mg/6"}
{"code": "for (i = 0; i < 1048576; i++)\n{\n  sum += h_c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-omp-parallel-for-combined-schedule-dynamic-chunk-value/3"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n}\n\n", "pragma": "#pragma omp for reduction(- : fl)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/taskloop_in_reduction_messages/0"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner < rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner < theta_max))\n  {\n    el_dens = hydro_data->dens[i] / M_P;\n    b_field = calcB(el_dens, hydro_data->temp[i]);\n    nu_c = calcCyclotronFreq(b_field);\n    dimlesstheta = calcDimlessTheta(hydro_data->temp[i]);\n    params[0] = hydro_data->temp[i];\n    params[1] = dimlesstheta;\n    params[2] = el_dens;\n    F.params = &params;\n    status = gsl_integration_qags(&F, 10, nu_c, 0, 1e-2, 10000, w, &ph_dens_calc, &error);\n    ph_dens_calc *= hydroElementVolume(hydro_data, i) / ph_weight_adjusted;\n    *(ph_dens + j) = gsl_ran_poisson(rand, ph_dens_calc);\n    ph_tot += *(ph_dens + j);\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/13"}
{"code": "for (i = 0; i < TOTAL_THREADS; i++)\n{\n  threadDataCount[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/6"}
{"code": "for (int i = nel; i < nelr; i++)\n{\n  h_areas[i] = h_areas[last];\n  for (int j = 0; j < NNB; j++)\n  {\n    h_elements_surrounding_elements[i + (j * nelr)] = h_elements_surrounding_elements[last + (j * nelr)];\n    for (int k = 0; k < NDIM; k++)\n      h_normals[last + ((j + (k * NNB)) * nelr)] = h_normals[last + ((j + (k * NNB)) * nelr)];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cfd-omp/euler3d/7"}
{"code": "for (int j = 0; j < ndr; j++)\n  for (int i = 0; i < P; i++)\n{\n  double temp = B(i, j);\n  NewB(i, j) = B(i, j) + epsilon;\n  G(i, j) = (surv_dn_f(NewB, X, Phit, Fail_Ind, bw, 1) - F0) / epsilon;\n  NewB(i, j) = temp;\n}\n\n\n", "pragma": "#pragma omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/surv_dn_solver/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      DzDzu[pp] = (((((-u[pp - (2 * n)]) + (16.0 * u[pp - n])) - (30.0 * u[pp])) + (16.0 * u[pp + n])) - u[pp + (2 * n)]) * idz_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/21"}
{"code": "for (size_t i = 0; i < n; ++i)\n  (((((file << i) << \"\\t\") << u[i]) << \"\\t\") << rho[i]) << '\\n';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex8-poisson-openmp/4"}
{"code": "for (int i = 0; i < row1; i++)\n{\n  for (int k = 0; k < col1; k++)\n  {\n    for (int j = 0; j < col2; j++)\n    {\n      matrix3[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/MatrixMultiplication/1"}
{"code": "for (int i = mid + 1; i < end; i++)\n  if (compare((void *) (&data[i]), (void *) (&data[mid])) < 0)\n  fail++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/08_quicksort.v0/3"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  if ((cityTaken[ant][i] == 0) && (i != city))\n  {\n    tempScore = cityScore(city, i);\n    if (tempScore > bestScore)\n    {\n      bestScore = tempScore;\n      bestCity = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/3"}
{"code": "for (int bz = offset; bz < nzEnd; bz += block_z)\n{\n  for (int bx = offset; bx < nxEnd; bx += block_x)\n  {\n    int izEnd = fmin(bz + block_z, nzEnd);\n    int ixEnd = fmin(block_x, nxEnd - bx);\n    for (int iz = bz; iz < izEnd; ++iz)\n    {\n      uint b_offset = (iz * wnx) + bx;\n      src_ptr = source_base + b_offset;\n      rec_ptr = receiver_base + b_offset;\n      correlation_output = corr_base + b_offset;\n      source_i = source_illumination_base + b_offset;\n      receive_i = receiver_illumination_base + b_offset;\n      #pragma vector aligned\n      #pragma ivdep\n      for (int ix = 0; ix < ixEnd; ix++)\n      {\n        float value;\n        value = src_ptr[ix] * rec_ptr[ix];\n        correlation_output[ix] += value;\n        if (_COMPENSATION_TYPE == COMBINED_COMPENSATION)\n        {\n          source_i[ix] += src_ptr[ix] * src_ptr[ix];\n          receive_i[ix] += rec_ptr[ix] * rec_ptr[ix];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(static, 1) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp/migration-accommodators/CrossCorrelationKernel/0"}
{"code": "for (int i = 0; i < nntDev; i++)\n{\n  h_ct[i] = (h_ct_gold[i] = 0);\n  h_ctprev[i] = rand() / ((float) RAND_MAX);\n  h_qt[i] = rand() / ((float) RAND_MAX);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/tissue-omp/main/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  c[i] = (x[i] = ((DATA_TYPE) i) / n);\n  for (j = 0; j < n; j++)\n    A[i][j] = (((DATA_TYPE) i) * j) / n;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/simple-omp-hook/tests/PolyBench-ACC/OpenMP/linear-algebra/kernels/trisolv/trisolv/1"}
{"code": "for (int i = 0; i < num_ranges; i++)\n{\n  if (scan.ranges[i] < scan.range_min)\n    ranges_double[i] = (double) scan.range_max;\n  else\n    ranges_double[i] = (double) scan.ranges[(num_ranges - i) - 1];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/gmapping-openmp/src/slam_gmapping/0"}
{"code": "for (i = 0; i < (2 * N); i++)\n  printf(\"%.2f, %.2f, %.2f\\n\", matrix[i][0], matrix[i][1], matrix[i][2]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/2"}
{"code": "for (i = 0; i < numDivs; i++)\n{\n  if (Sel == 0)\n    *(bc + i) = (*(vNNMM + i)) - (*(reglin + i));\n  else\n    *(bc + i) = (*((vNNMM + i) + numDivs)) - (*(reglin + i));\n\n  *(m1 + i) = (*(bc + i)) * (*(bc + i));\n  Sum2 += *(m1 + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    a[i][j] = (T) 0;\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_collapse_codegen/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = grid_points[2] - 2; k >= 0; k--)\n    {\n      for (m = 0; m < BLOCK_SIZE; m++)\n      {\n        for (n = 0; n < BLOCK_SIZE; n++)\n        {\n          rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][CC][m][n] * rhs[i][j][k + 1][n]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/137"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    u[i3][i2][n1 - 1] = u[i3][i2][1];\n    u[i3][i2][0] = u[i3][i2][n1 - 2];\n  }\n\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    u[i3][n2 - 1][i1] = u[i3][1][i1];\n    u[i3][0][i1] = u[i3][n2 - 2][i1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i1 ,i2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/15"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 0; k <= (grid_points[2] - 3); k++)\n      {\n        k1 = k + 1;\n        k2 = k + 2;\n        fac1 = 1. / lhs[n + 2][i][j][k];\n        lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n        lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n        rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n        lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n        lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n        lhs[n + 1][i][j][k2] = lhs[n + 1][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 3][i][j][k]);\n        lhs[n + 2][i][j][k2] = lhs[n + 2][i][j][k2] - (lhs[n + 0][i][j][k2] * lhs[n + 4][i][j][k]);\n        rhs[m][i][j][k2] = rhs[m][i][j][k2] - (lhs[n + 0][i][j][k2] * rhs[m][i][j][k]);\n      }\n\n    }\n\n  }\n\n  k = grid_points[2] - 2;\n  k1 = grid_points[2] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n      rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n      fac2 = 1. / lhs[n + 2][i][j][k1];\n      rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/34"}
{"code": "for (int i = 0; i < cloud_size; ++i)\n{\n  processedStorage[i] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(cloud_size, processedStorage)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload/euclidean_cluster/kernel/3"}
{"code": "for (int ii = 0; ii < sizearray3d; ii++)\n{\n  array3d[ii] = value;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/10"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (L * L)) * SAMPLES), stat[i].e2 / ((((double) (L * L)) * (L * L)) * SAMPLES), stat[i].e4 / ((((((double) (L * L)) * (L * L)) * (L * L)) * (L * L)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/48"}
{"code": "for (int i = 0; i < vec.size(); i++)\n{\n  (cout << vec[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/scan/lab_scan_frag/scan_frag/0"}
{"code": "for (int i = 0; i < bHeight; i++)\n  for (int j = 0; j < bWidth; j++)\n  scanf(\"%d\", &B[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/ImageMatch/main/2"}
{"code": "for (int c = 0; c < kn.cols; c++)\n{\n  for (int r = 0; r < kn.rows; r++)\n  {\n    kn_data[(r * kn.cols) + c] = (float) gaussian2D((float) (c - (kn.cols / 2)), (float) (r - (kn.rows / 2)), sigma);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kka-na/parallel_image_processing/hw7/src/myOpenMP/0"}
{"code": "for (int i = 1; i < x_points; i++)\n{\n  temp = u[i - 1];\n  u_new[i] = u[i] - (((u[i] * del_t) / del_x) * (u[i] - temp));\n}\n\n", "pragma": "omp for private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D NonLinear Convection/main/0"}
{"code": "for (int i = 1; i < 15999; i++)\n{\n  b[i] = ((a[i] + a[i - 1]) + a[i + 1]) / 3.0;\n}\n\n", "pragma": "#pragma omp schedule(static) for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/altzii/parallel-programming/OpenMP/task8/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n    b[i][j] = (double) (i * j);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB054-inneronly2-orig-no/0"}
{"code": "for (i = 0; i < row; ++i)\n{\n  for (j = 0; j < col; ++j)\n  {\n    res[i] += vector[j] * matrix[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlaaMensh/openMPI-with-files/OMP/Matrix-vector multiplication&20160060/3"}
{"code": "for (int i_dest = 1; i_dest < comm_size; i_dest++)\n{\n  MPI_Send(shared_params, SHARED_PARAMS_SIZE, MPI_INT, i_dest, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/4"}
{"code": "for (n_threads = 2; n_threads <= NUM_MAX_THREADS; n_threads = +2)\n{\n  srand(time(0));\n  double init_time;\n  double end_time = 0;\n  int nthreads;\n  int tid;\n  int nprocs;\n  int vector_size;\n  int i;\n  double no_parallel_sum;\n  double parallel_sum = 0.0;\n  double *vector;\n  vector_size = 100000000;\n  vector = (double *) malloc(vector_size * (sizeof(double)));\n  initVector(vector, vector_size, &no_parallel_sum);\n  init_time = current_time();\n  parallel_sum = addition(vector, vector_size, n_threads);\n  end_time = current_time();\n  printf(\"Result->[%.4f], Time->[%f], Num threads->[%d]\\n\", no_parallel_sum, parallel_sum, end_time - init_time, n_threads);\n  free(vector);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/sum_vector/1"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < (width * 3); j += 3)\n  {\n    int x1 = 0;\n    int x2 = 0;\n    int x3 = 0;\n    for (int s = -2; s <= 2; s++)\n    {\n      for (int t = -2; t <= 2; t++)\n      {\n        if (padding == 0)\n        {\n          if ((((((((i + s) * (width * 3)) + j) + (t * 3)) < ((height * width) * 3)) && ((((((i + s) * (width * 3)) + j) + (t * 3)) + first_byte_old) >= first_byte_old)) && ((j + (t * 3)) < (width * 3))) && ((j + (t * 3)) >= 0))\n          {\n            x1 += m[s + 2][t + 2] * ((unsigned char) file_buffer[((((i + s) * (width * 3)) + j) + (t * 3)) + first_byte_old]);\n            x2 += m[s + 2][t + 2] * ((unsigned char) file_buffer[(((((i + s) * (width * 3)) + j) + (t * 3)) + first_byte_old) + 1]);\n            x3 += m[s + 2][t + 2] * ((unsigned char) file_buffer[(((((i + s) * (width * 3)) + j) + (t * 3)) + first_byte_old) + 2]);\n          }\n\n        }\n        else\n        {\n          if ((((((((i + s) * ((width * 3) + padding)) + j) + (t * 3)) < (height * ((width * 3) + (padding * height)))) && ((((((i + s) * ((width * 3) + padding)) + j) + (t * 3)) + first_byte_old) >= first_byte_old)) && ((j + (t * 3)) < (width * 3))) && ((j + (t * 3)) >= 0))\n          {\n            x1 += m[s + 2][t + 2] * ((unsigned char) file_buffer[((((i + s) * ((width * 3) + padding)) + j) + (t * 3)) + first_byte_old]);\n            x2 += m[s + 2][t + 2] * ((unsigned char) file_buffer[(((((i + s) * ((width * 3) + padding)) + j) + (t * 3)) + first_byte_old) + 1]);\n            x3 += m[s + 2][t + 2] * ((unsigned char) file_buffer[(((((i + s) * ((width * 3) + padding)) + j) + (t * 3)) + first_byte_old) + 2]);\n          }\n\n        }\n\n      }\n\n    }\n\n    if (padding == 0)\n    {\n      res[(((i * width) * 3) + j) + first_byte_old] = x1 / w;\n      res[((((i * width) * 3) + j) + first_byte_old) + 1] = x2 / w;\n      res[((((i * width) * 3) + j) + first_byte_old) + 2] = x3 / w;\n    }\n    else\n    {\n      if (((j + (i * padding)) == 0) && (i > 0))\n      {\n      }\n      else\n      {\n        if (((((((i * width) * 3) + j) + first_byte_old) + 2) + (i * 3)) < file_size_int)\n        {\n          res[((((i * width) * 3) + j) + first_byte_old) + (i * 3)] = x1 / w;\n          res[(((((i * width) * 3) + j) + first_byte_old) + 1) + (i * 3)] = x2 / w;\n          res[(((((i * width) * 3) + j) + first_byte_old) + 2) + (i * 3)] = x3 / w;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tastypeanut/uc3m-ca-openmp/threads_test/0"}
{"code": "for (j = 0; j < N; ++j)\n{\n  tavg += j;\n}\n\n", "pragma": "omp parallel for reduction(+:tavg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/avrage-reduction/C/main/0"}
{"code": "for (int i = 0; i < num_pixels; i++)\n{\n  fitness += (abs(objetivo[i].r - individuo->imagen[i].r) + abs(objetivo[i].g - individuo->imagen[i].g)) + abs(objetivo[i].b - individuo->imagen[i].b);\n}\n\n", "pragma": "omp parallel for reduction(+:fitness)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      temp_mat[(i * n) + j] = 0;\n    }\n    else\n    {\n      value = 1 + (rand() % MAX);\n      if (value > density)\n      {\n        temp_mat[(i * n) + j] = INF;\n      }\n      else\n      {\n        temp_mat[(i * n) + j] = value;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/hybrid/1"}
{"code": "for (i = 0; i < 4; i++)\n  local_sum[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_synchronization_constructs/5"}
{"code": "for (int i = 0; i < taille; i++)\n{\n  printf(\"%d \", tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex6/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  sumcol = 0;\n  for (j = 0; j < n; j++)\n  {\n    sumcol = sumcol + mat1[j][i];\n  }\n\n  printf(\"Sum of column[%d] = %d \\n\", i, sumcol);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohit-gupta3/Parallel_and_DistributiveComputing-PDC-/Matrix_Operations/SumOf_rows_and_Columns_OpenMp/1"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  for (int j = 0; j < 5; j++)\n  {\n    printf(\"%d\\t\", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/flush1/7"}
{"code": "for (iz = 0; iz < nzl; iz++)\n{\n  for (iy = 0; iy < nyl; iy++)\n  {\n    for (ix = 0; ix < nxl; ix++)\n    {\n      tvar[CELTNDX(ix, iy, iz)] = tvar_sav[CELTNDX(ix, iy, iz)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(ix, iy, iz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/PF3DK/init/0"}
{"code": "for (int i = j; i < N; i++)\n  a[i] += b[i - j];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/forestdan/OpenMPLearn/src/09_scan/2"}
{"code": "for (i = 0; i < nRows; ++i)\n{\n  for (int j = 0; j < nCols; ++j)\n  {\n    outVec->data[i] = outVec->data[i] + (mat->data[(i * nCols) + j] * inVec->data[j]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uscheedella/Image-Interpolation/labs/lab05_sol/code/Matrix/0"}
{"code": "for (int i = 0; i < klength; i++)\n{\n  for (int j = 0; j < klength; j++)\n  {\n    mkernel[i][j] = kernel[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/Filter/Filter/0"}
{"code": "for (n = 1; n < 1000000000; n++)\n{\n  sum += 1.0 / ((double) n);\n}\n\n", "pragma": "omp for private(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iPogot/Parallel-Programming/term_2/harmonic_row/prog/0"}
{"code": "for (j = i + 1; j < n; j++)\n{\n  if (v[j] < v[min_local])\n    min_local = j;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/MC-SD02-I/SelectionSort/0"}
{"code": "for (i = 1; i < s; ++i)\n{\n  for (j = 0; j < i; ++j)\n  {\n    m_dest[i][j] = m_src[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j) shared(s, m_dest, m_src)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/lu/0"}
{"code": "for (int i = 0; i < getVertexNumberMatrix(gr); i++)\n{\n  for (int j = 0; j < getVertexNumberMatrix(gr); j++)\n  {\n    result[i][j] = min(result[i][j], result[i][k] + result[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/3"}
{"code": "for (i = 0; i < 100000; i++)\n  if (Sellers[i].quantityHeld == 0)\n  numberSold++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp2/4"}
{"code": "for (int i = 0; i < nproc; i++)\n{\n  hiz += hizs[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/22"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double n;\n  double m;\n  double l;\n  fscanf(fp_cell, \"%lf %lf %lf\", &n, &m, &l);\n  coordinateMatrix[i][0] = n;\n  coordinateMatrix[i][1] = m;\n  coordinateMatrix[i][2] = l;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PerJNilsson/C---OpenMP/cell_distance/1"}
{"code": "for (int i = 0; i < Nc; ++i)\n{\n  for (int j = 0; j < corrs[i]->get_Np(); ++j)\n  {\n    int this_p = get_pidx(i, j);\n    for (unsigned int k = 0; k < fc.p_bindings.size(); ++k)\n    {\n      if ((fc.p_bindings[k][0] == i) && (fc.p_bindings[k][1] == j))\n      {\n        int bind_to = get_pidx(fc.p_bindings[k][2], fc.p_bindings[k][3]);\n        bind_map[this_p].push_back(bind_to);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/3"}
{"code": "for (int pos = 0; pos < N; pos++)\n{\n  const int stride = N / 4;\n  int lo = pos & (stride - 1);\n  int i0 = ((pos - lo) << 2) + lo;\n  int i1 = i0 + stride;\n  int i2 = i1 + stride;\n  int i3 = i2 + stride;\n  float D0 = d_Kernel[i0];\n  float D1 = d_Kernel[i1];\n  float D2 = d_Kernel[i2];\n  float D3 = d_Kernel[i3];\n  float T;\n  T = D0;\n  D0 = D0 + D2;\n  D2 = T - D2;\n  T = D1;\n  D1 = D1 + D3;\n  D3 = T - D3;\n  T = D0;\n  d_Kernel[i0] = D0 + D1;\n  d_Kernel[i1] = T - D1;\n  T = D2;\n  d_Kernel[i2] = D2 + D3;\n  d_Kernel[i3] = T - D3;\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fwt-omp/main2/3"}
{"code": "for (i = 1; i < (bitmask + 1); ++i)\n{\n  vertex_count[digits / granularity][i] += vertex_count[digits / granularity][i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/15"}
{"code": "for (i = 0; i < (mid - begin); i++)\n{\n  if ((j < mid) && ((globC[j] < globC[k]) || (k >= end)))\n  {\n    bot[i] = globC[j];\n    j++;\n  }\n  else\n  {\n    bot[i] = globC[k];\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/8"}
{"code": "for (i = 0; i < 2000000; i++)\n{\n  psum += arr[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GUPTASHUBH057/openmp-programs/openmp_prog1/0"}
{"code": "for (int ColIdx = 0; ColIdx < Cols; ColIdx++)\n{\n  Mat->At(RowIdx, ColIdx) = RowV[ColIdx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/113"}
{"code": "for (int k = 0; k < n; k++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (output[(i * n) + j] > (output[(i * n) + k] + output[(k * n) + j]))\n      {\n        output[(i * n) + j] = output[(i * n) + k] + output[(k * n) + j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/floyd_warshall/2"}
{"code": "for (int p = 0; p < (k - 1); p++)\n{\n  sum += L[i - 1][p] * U[p][k - 1];\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/croutMethod/1"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  if (i != me)\n    MPI_Sendrecv(scdata.data() + spos, ssizes[i], MPI_GRAPH_TYPE, i, CommunityTag, rcdata.data() + rpos, rsizes[i], MPI_GRAPH_TYPE, i, CommunityTag, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);\n\n  spos += ssizes[i];\n  rpos += rsizes[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/6"}
{"code": "for (int gene = 0; gene < (500 - 1); gene++)\n{\n  acc += (1.0 * scores[gene]) / sum_score;\n  ADD_FITNESS[gene] = acc;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.0/5"}
{"code": "for (int i = 0; i < mat_size; i++)\n{\n  for (int j = 0; j < mat_size; j++)\n  {\n    fprintf(file, \"%lf \", u_mat[i][j]);\n  }\n\n  fprintf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp_latest/2"}
{"code": "for (tid = 0; tid < nthreads; ++tid)\n{\n  fprintf(stdout, \"%d: \", tid);\n  for (i = 0; i < N; ++i)\n  {\n    if (a[i] == tid)\n      fprintf(stdout, \"*\");\n    else\n      fprintf(stdout, \" \");\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/Parallel_progr/Day2/ex2/loop_schedule/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  uplus[i] = (u[i] + c1) - (dt * u[i]);\n  sum = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    sum += sigma[(i * n) + j] * u[j];\n  }\n\n  uplus[i] += c2 * (sum - (u[i] * temp_vec[i]));\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kpetrakis/OpenMP-Project/lif1d_omp1/0"}
{"code": "for (i = 0; i < (n / 2); i++)\n{\n  for (j = 0; j < (n / 2); j++)\n    masC[i][j] = masA[i][j] + masB[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/9"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  reverse_result += smo[0].getP(i) * smo[1].getP(n - i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Evgentus0/ParallelProgrmming/NormilizingFactor/NormilizingFactor/0"}
{"code": "for (l = 0; l < num_tasks; l++)\n{\n  for (i = 0; i < n_p; i++)\n  {\n    for (j = 0; j < n_p; j++)\n    {\n      for (k = 0; k < n; k++)\n      {\n        C[(j * n) + k] += A[((j * n) + i) + currentRow] * B[(i * n) + k];\n      }\n\n    }\n\n  }\n\n  if (num_tasks > 1)\n  {\n    if (rank == 0)\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, num_tasks - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, rank + 1, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n    else\n      if (rank == (num_tasks - 1))\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, rank - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, 0, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n    else\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, rank - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, rank + 1, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n\n\n    if (currentRow == (n - n_p))\n    {\n      currentRow = 0;\n    }\n    else\n    {\n      currentRow += n_p;\n    }\n\n  }\n  else\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW3/matmul1d/3"}
{"code": "for (int myrow = 0; myrow < SIZE; myrow++)\n{\n  if (myrow != row)\n    possiblevalues[myrow][uniquecol][num] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/7"}
{"code": "for (int i = 0; i < 300; i++)\n{\n  a[i] = rand() % 300;\n  if (((a[i] % 7) == 0) && (base_max < a[i]))\n  {\n    base_max = a[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxinspace/OpenMP/omp12/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  matriz[i] = (float *) malloc((sizeof(float)) * N);\n  for (j = 0; j < N; j++)\n  {\n    matriz[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaquinVillagra/Laboratorio_2_HPC/wave/3"}
{"code": "for (i = 0; i < pdf->total_size; i++)\n  total_vol += pdf->PDF[i];\n\n", "pragma": "omp for reduction(+:total_vol)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/4"}
{"code": "for (i = 0; i < v_size; i++)\n{\n  cp_sudokus_array[tid][i] = cp_sudokus_array[receive_from_th][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/omp/sudoku-omp/4"}
{"code": "for (size_t i = 0; i < n; i++)\n  sum += a[i];\n\n", "pragma": "    #pragma omp parralel for reduction(+: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/sum_array/1"}
{"code": "for (size_t whichPt = 0; whichPt < N_value; whichPt++)\n{\n  dis_min = FLT_MAX;\n  for (size_t count_k = 0; count_k < K_value; count_k++)\n  {\n    if (dis_min > dis[whichPt][count_k])\n    {\n      dis_min = dis[whichPt][count_k];\n      data.group[whichPt] = count_k;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) default(none) firstprivate(N_value,K_value,dis_min) shared(data,dis)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jimmy3769tw/K-meansClusteringAlgorithm_OpenCLandOpenMP/src/kmeansAOSp/3"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    if (cellMatrix[i][j] > 0)\n      count++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelhuntermoore/OpenMP-ConwaysGameOfLife/ParallelGameofLifeVer1/0"}
{"code": "for (i = 0; i <= q_len; i++)\n{\n  array[i][0] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkasfikis/Smith-Waterman-/myProj_OMP_FG/5"}
{"code": "for (source = 1; source < grid->p; source++)\n{\n  MPI_Recv(temp_mat, 1, local_matrix_mpi_t, source, 0, grid->comm, &status);\n  MPI_Cart_coords(grid->comm, source, 2, coords);\n  fprintf(fp, \"Process %d > grid_row = %d, grid_col = %d\\n\", source, coords[0], coords[1]);\n  for (i = 0; i < temp_mat->n_bar; i++)\n  {\n    for (j = 0; j < temp_mat->n_bar; j++)\n      fprintf(fp, \"%20.15E \", *((temp_mat->entries + (temp_mat->n_bar * j)) + i));\n\n    fprintf(fp, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/24"}
{"code": "for (int h = 0; h < NumQs; h++)\n  *(tmpSPQx + h) = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/36"}
{"code": "for (npy_intp i = 0; i < xsize; ++i)\n{\n  xdata[i] = op->apply(xdata[i]);\n}\n\n", "pragma": "  #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gregvw/mpops/operations/0"}
{"code": "for (int i = 1; i < N; i++)\n{\n  double v = 0.0;\n  for (int j = 1; j <= i; j++)\n    v += s->Bt[j] * s->Tm[s->m3d_c][(i - j) + 1];\n\n  if (space_der == 1)\n    for (int j = i + 1; j < N; j++)\n    v -= s->Bt[j] * s->Tm[s->m3d_c][(j - i) + 1];\n\n\n  if (implicit_row_scaling == 1)\n    v /= s->RS[i];\n\n  r[i] += v;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/132"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sort(adjacency_list[i].begin(), adjacency_list[i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/12"}
{"code": "for (i = 0; i < (life->ncols + 2); i++)\n{\n  for (j = 0; j < (life->nrows + 2); j++)\n  {\n    life->grid[i][j] = DEAD;\n    life->next_grid[i][j] = DEAD;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iliasmentz/Game-of-Life/GoF-openmp/LifeFunctions/6"}
{"code": "for (int i = top, k = 0; i <= bottom; i++, k++)\n{\n  for (int j = left, l = 0; j <= right; j++, l++)\n  {\n    outmat[k][l] = mat[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/max/9"}
{"code": "for (j = 0; j < npp; j++)\n{\n  n = part[idimp * j];\n  m = part[1 + (idimp * j)];\n  n = n / mx;\n  m = (m - mnoff) / my;\n  m = n + (mx1 * m);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[i + (idimp * (ip + (nppmx * m)))] = part[i + (idimp * j)];\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/31"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    ResultMat[i][j] = MatrixA[i][j] + MatrixB[i][j];\n    printf(\"in thread %d result[%d][%d] = %d \\n\", omp_get_thread_num(), i, j, ResultMat[i][j]);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lamyaraed/Parallel-Processing/MatrixAddition(OMP)/0"}
{"code": "for (int i = 0; i < firsttable->size; i++)\n{\n  finalresult->current[i] = descent->current[i + firsttable->size];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/3"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  int idx = (c0 * index) + (c1 * i);\n  int slice_idx = i * M;\n  for (int j = 0; j < M; ++j)\n  {\n    raw[idx] = slice[slice_idx];\n    ++slice_idx;\n    idx += c2;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/Grid3D/1"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (tx2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/23"}
{"code": "for (int number_of_threads = 2; number_of_threads <= max_number_of_threads; ++number_of_threads)\n{\n  omp_set_num_threads(number_of_threads);\n  cout << endl;\n  cout << endl;\n  ((cout << \"  number of threads = \") << number_of_threads) << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"                        Riemann Integral                       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"         i  |       times        |    s   |      results       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  for (int i = 2; i <= num_subintervals; i *= 2)\n  {\n    start = omp_get_wtime();\n    result = RiemannIntegral(a, b, i);\n    end = omp_get_wtime();\n    time = end - start;\n    start_parallel = omp_get_wtime();\n    result_parallel = RiemannIntegralParallel(a, b, i);\n    end_parallel = omp_get_wtime();\n    time_parallel = end_parallel - start_parallel;\n    ((((((((((((((((((((((((cout << setw(10)) << right) << i) << \"  |  \") << fixed) << setprecision(4)) << time) << \"    \") << fixed) << setprecision(4)) << time_parallel) << \"  | \") << setw(5)) << fixed) << setprecision(2)) << (time / time_parallel)) << \"  |  \") << fixed) << setprecision(4)) << result) << \"    \") << fixed) << setprecision(4)) << result_parallel) << endl;\n  }\n\n  cout << endl;\n  (cout << \"                      Trapezoidal Integral                     \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"         i  |       times        |    s   |      results       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  for (int i = 2; i <= num_subintervals; i *= 2)\n  {\n    start = omp_get_wtime();\n    result = TrapezoidalIntegral(a, b, i);\n    end = omp_get_wtime();\n    time = end - start;\n    start_parallel = omp_get_wtime();\n    result_parallel = TrapezoidalIntegralParallel(a, b, i);\n    end_parallel = omp_get_wtime();\n    time_parallel = end_parallel - start_parallel;\n    ((((((((((((((((((((((((cout << setw(10)) << right) << i) << \"  |  \") << fixed) << setprecision(4)) << time) << \"    \") << fixed) << setprecision(4)) << time_parallel) << \"  | \") << setw(5)) << fixed) << setprecision(2)) << (time / time_parallel)) << \"  |  \") << fixed) << setprecision(4)) << result) << \"    \") << fixed) << setprecision(4)) << result_parallel) << endl;\n  }\n\n  cout << endl;\n  (cout << \"                        Simpson Integral                       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  (cout << \"         i  |       times        |    s   |      results       \") << endl;\n  (cout << \"  -------------------------------------------------------------\") << endl;\n  for (int i = 2; i <= num_subintervals; i *= 2)\n  {\n    start = omp_get_wtime();\n    result = SimpsonIntegral(a, b, i);\n    end = omp_get_wtime();\n    time = end - start;\n    start_parallel = omp_get_wtime();\n    result_parallel = SimpsonIntegralParallel(a, b, i);\n    end_parallel = omp_get_wtime();\n    time_parallel = end_parallel - start_parallel;\n    ((((((((((((((((((((((((cout << setw(10)) << right) << i) << \"  |  \") << fixed) << setprecision(4)) << time) << \"    \") << fixed) << setprecision(4)) << time_parallel) << \"  | \") << setw(5)) << fixed) << setprecision(2)) << (time / time_parallel)) << \"  |  \") << fixed) << setprecision(4)) << result) << \"    \") << fixed) << setprecision(4)) << result_parallel) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kr0nverk/Hello_Parallel_OpenMP/Integration/Integration/6"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    (cout << ((int) imageData[i][j])) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MUKUL821/Picturesque--Image-Processing/imageold/1"}
{"code": "for (int fil_img = 0; fil_img < ((21696 - 3) + 1); fil_img++)\n{\n  for (int col_img = 0; col_img < ((21696 - 3) + 1); col_img++)\n  {\n    for (int fil_kernel = 0; fil_kernel < 3; fil_kernel++)\n    {\n      for (int col_kernel = 0; col_kernel < 3; col_kernel++)\n      {\n        salida[(fil_img * ((21696 - 3) + 1)) + col_img] += dato_entrada[((fil_img + fil_kernel) * 21696) + (col_img + col_kernel)] * kernel[fil_kernel][col_kernel];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfdavid/SO2_TP2/src/main/0"}
{"code": "for (i = 0; i < 20; i++)\n{\n  for (j = 0; j < 20; j++)\n  {\n    matrix[i][j] = rand() % 2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) shared(matrix) num_threads(NUM_OF_THREADS) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Assignment-2/parallel_v3/0"}
{"code": "for (d = 0; d < n_pr; d++)\n  MPI_Bcast(buffers[d], 2, MPI_DOUBLE, d, 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelMpi/grid/10"}
{"code": "for (int i = 1; i <= V; i++)\n{\n  u = i;\n  k = offset[u];\n  while (k < offset[u + 1])\n  {\n    v = edges[k];\n    int wt = 1;\n    if ((dist[u] != INT_MAX) && ((dist[u] + wt) < dist[v]))\n    {\n      dist[v] = dist[u] + wt;\n      change = true;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(E,V,dist,change,offset,edges,cout) private(u,v,tid) firstprivate(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Deeps-01/openMp/ssspTopologyDriven/3"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double sumRealNew = 0.0;\n  double sumImaginaryNew = 0.0;\n  for (uint p = 0; p < length; ++p)\n  {\n    unsigned long currentAtom = startAtom + p;\n    if (particleHasNoCharge[currentAtom])\n    {\n      continue;\n    }\n\n    double dotProductNew = Dot(p, kxRef[box][i], kyRef[box][i], kzRef[box][i], molCoords);\n    sumRealNew += thisKind.AtomCharge(p) * cos(dotProductNew);\n    sumImaginaryNew += thisKind.AtomCharge(p) * sin(dotProductNew);\n  }\n\n  sumRnew[box][i] = sumRref[box][i] - sumRealNew;\n  sumInew[box][i] = sumIref[box][i] - sumImaginaryNew;\n  energyRecipNew += ((sumRnew[box][i] * sumRnew[box][i]) + (sumInew[box][i] * sumInew[box][i])) * prefactRef[box][i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(length, molCoords, startAtom, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/14"}
{"code": "for (int i = 0; i < min_size; ++i)\n{\n  if (string_a[i] != string_b[i])\n    ++mismatch;\n\n  printf(\"%c : %c : thread = %i\\n\", string_a[i], string_b[i], omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/itomilin/openmp_mpi_labs/lab_6/main/0"}
{"code": "formula.append(number(c) + \"x^5 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/15"}
{"code": "for (k = sk; k <= ek; k++)\n  for (l = sl; l <= el; l++)\n  count += board[k][l];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/jogo_da_vida/paralell_life/5"}
{"code": "for (unsigned i = 0; i < xCoordinates.size(); i++)\n{\n  xCoordinates[i] = xCoordinates[i] * scale;\n  yCoordinates[i] = yCoordinates[i] * scale;\n  zCoordinates[i] = zCoordinates[i] * scale;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/operators/mesh/2"}
{"code": "for (y = 0; y < ksize; y++)\n  kernel[y] *= scale;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/11"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  printf(\"\\t de=%f \\n\", de[col]);\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/9"}
{"code": "for (j = 0; j < 10; j++)\n{\n  mean[j] = xx[j] + cc[j];\n  for (i = 0; i < 10; i++)\n  {\n    data[i] = mean[j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/demo/demo/0"}
{"code": "for (unsigned int p = 0; p < number; p++)\n{\n  double therm_vel_el = sq_rt(((2 * EL_CHARGE) * energies[p]) / mass);\n  double norm = 0.74;\n  therm_vel_el *= norm;\n  double rnd_0;\n  double rnd_1;\n  double rnd_2;\n  rnd_0 = random_reverse(p, 3);\n  rnd_1 = random_reverse(p, 5);\n  rnd_2 = random_reverse(p, 7);\n  double k0 = random_reverse(p, 4);\n  double k1 = random_reverse(p, 6);\n  double k2 = random_reverse(p, 8);\n  if (k0 > 0.5)\n    rnd_0 = -rnd_0;\n\n  if (k1 > 0.5)\n    rnd_1 = -rnd_1;\n\n  if (k2 > 0.5)\n    rnd_2 = -rnd_2;\n\n  rnd_0 = uniform2();\n  rnd_1 = uniform2();\n  rnd_2 = uniform2();\n  vel[p][0] = rnd_0 * therm_vel_el;\n  vel[p][1] = rnd_1 * therm_vel_el;\n  vel[p][2] = rnd_2 * therm_vel_el;\n  vel[p][0] *= get_gamma_inv(vel[p][0] * vel[p][0]);\n  vel[p][1] *= get_gamma_inv(vel[p][1] * vel[p][1]);\n  vel[p][2] *= get_gamma_inv(vel[p][2] * vel[p][2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/2"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((mat2[rowcol] == (-28768)) || (mat8[rowcol] == (-28768))) || (mat2[rowcol] <= 0.001))\n  {\n    matOut3[rowcol] = 0.0;\n    matdtdry[rowcol] = -28768;\n  }\n  else\n  {\n    if (((mat1[rowcol] * 0.0001) > ndvi_max) && ((mat1[rowcol] * 0.0001) < 0.98))\n      ndvi_max = mat1[rowcol] * 0.0001;\n\n    if (((mat2[rowcol] * 0.001) > albedo_max) && ((mat2[rowcol] * 0.001) < 0.9))\n      albedo_max = mat2[rowcol] * 0.001;\n\n    if (((mat2[rowcol] * 0.001) < albedo_min) && ((mat2[rowcol] * 0.001) > 0.001))\n      albedo_min = mat2[rowcol] * 0.001;\n\n    tempk = mat8[rowcol] * 0.02;\n    dem = mat14[rowcol];\n    t0dem = tempk + (0.00627 * dem);\n    if ((t0dem > t0dem_max) && (t0dem > 274))\n      t0dem_max = t0dem;\n\n    if ((t0dem < t0dem_min) && (t0dem > 274))\n      t0dem_min = t0dem;\n\n    etpotd = et_pot_day(mat15[rowcol], tempk, roh_w);\n    matOut3[rowcol] = etpotd;\n    Rn = mat16[rowcol];\n    g0 = mat17[rowcol];\n    matdtdry[rowcol] = (0.2 * (Rn - g0)) / u2m;\n    if (matdtdry[rowcol] > 100)\n      matdtdry[rowcol] = 0;\n\n    if (matdtdry[rowcol] > dtdry_max)\n      dtdry_max = matdtdry[rowcol];\n\n    if (matdtdry[rowcol] < dtdry_min)\n      dtdry_min = matdtdry[rowcol];\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, tempk, etpotd, Rn, g0, dem, t0dem,) shared(N, nX, nY, roh_w, tsw, doy, u2m, t0dem_min,t0dem_max,dtdry_min,dtdry_max, ndvi_max,albedo_min,albedo_max, mat1,mat2,mat8,mat14, mat15,mat16, mat17, matdtdry, matOut3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBAL/gdal_sebal_eta_new/0"}
{"code": "for (int row = 0; row < rows; row++)\n{\n  for (int col = 0; col < columns; col++)\n  {\n    double value = (dataset->at(row)->getFeatures()->at(col) - mean[col]) / std[col];\n    dataset->at(row)->getFeatures()->at(col) = value;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(mean, std, columns, dataset)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-Hybrid-OpenMP-MPI/OpenMP/StandardScaler/1"}
{"code": "for (j = 1; j <= (naa + 1); j++)\n{\n  double xj = x[j];\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = xj;\n  p[j] = xj;\n  w[j] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/CG/cg/3"}
{"code": "for (i = 0; i < seqLength; ++i)\n{\n  nextHiddenState(input_t, h_tminus1, c_tminus1, hiddenSize, miniBatch, W_i_trans, W_f_trans, W_o_trans, W_g_trans, R_i_trans, R_f_trans, R_o_trans, R_g_trans);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_4_final/7"}
{"code": "for (size_t i = 0; i < val.size(); i++)\n{\n  val[i] = value;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/utils/dense_constructor/1"}
{"code": "for (int j = 0; j < ENCRYPTEDLEN; ++j)\n  encryptedMap[j] = ENCRYPTED_T[j] - 'a';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/columnarSolver-omp/main/2"}
{"code": "for (int i = 0; i < size; i++)\n  for (int j = 0; j < size; j++)\n  mat[i][j] = ((float) ((rand() % 10) + 1)) / 100;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW4/det/3"}
{"code": "for (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n  f >> a[(i * n) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GandharvJain/OpenMP/Matrix Multiplication/matrix_mul_parallel/0"}
{"code": "for (int k = 0; k < N; k++)\n{\n  MatrixAssign(At + (k * N), u + (k * N), 1, N);\n  for (int j = 0; j < k; j++)\n  {\n    double uNorm = VectorNorm(u + (j * N), N);\n    if (uNorm < epsilon)\n    {\n      continue;\n    }\n\n    MatrixProj(At + (k * N), u + (j * N), p, N);\n    MatrixSubtract(u + (k * N), p, u + (k * N), 1, N);\n  }\n\n  double uNorm = VectorNorm(u + (k * N), N);\n  double factor;\n  if (uNorm < epsilon)\n  {\n    factor = 0;\n  }\n  else\n  {\n    factor = 1 / uNorm;\n  }\n\n  ScalarMultiply(u + (k * N), e + (k * N), 1, N, factor);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/10"}
{"code": "for (int i = 0; i < 10; ++i)\n  a += 8;\n\n", "pragma": "    #pragma omp target parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen_registration/1"}
{"code": "for (i = 1; i < (m - 1); i++)\n  for (j = 1; j < (n - 1); j++)\n  B1[(i * n) + j] = maximo_local(A, i, j, n);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rescurib/Notas_Computo_Paralelo/MemoriaCompartida/Sec_03/Ejemplo_3_3_OpenMP/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d \", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgrigoras/parallel_algorithms/Lab 7/Lab7_p1_openmp/Hello_parallel/main/0"}
{"code": "for (int idx = 0; idx < len; ++idx)\n{\n  in[idx] = val;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/map_reduce/map_reduce/0"}
{"code": "for (int ii = 0; ii < NY; ii++)\n{\n  int part = ii * NX;\n  #pragma simd\n  for (int jj = 0; jj < NX; jj++)\n  {\n    int pos = part + jj;\n    double *ts = tmp_cells[pos].speeds;\n    double *s = cells[pos].speeds;\n    if (!obstacles[pos])\n    {\n      double local_density = (((((((ts[0] + ts[1]) + ts[2]) + ts[3]) + ts[4]) + ts[5]) + ts[6]) + ts[7]) + ts[8];\n      double u_x = (((ts[1] + ts[5]) + ts[8]) - ((ts[3] + ts[6]) + ts[7])) / local_density;\n      double u_y = (((ts[2] + ts[5]) + ts[6]) - ((ts[4] + ts[7]) + ts[8])) / local_density;\n      double u_sq = (u_x * u_x) + (u_y * u_y);\n      double u[9];\n      u[1] = u_x;\n      u[2] = u_y;\n      u[3] = -u_x;\n      u[4] = -u_y;\n      u[5] = u_x + u_y;\n      u[6] = (-u_x) + u_y;\n      u[7] = (-u_x) - u_y;\n      u[8] = u_x - u_y;\n      double d_equ[9];\n      d_equ[0] = ((4.0 / 9.0) * local_density) * (1.0 - (u_sq / (2.0 * (1.0 / 3.0))));\n      double partial = (1.0 / 9.0) * local_density;\n      double par = u_sq / (2.0 * (1.0 / 3.0));\n      d_equ[1] = partial * (((1.0 + (u[1] / (1.0 / 3.0))) + ((u[1] * u[1]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[2] = partial * (((1.0 + (u[2] / (1.0 / 3.0))) + ((u[2] * u[2]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[3] = partial * (((1.0 + (u[3] / (1.0 / 3.0))) + ((u[3] * u[3]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[4] = partial * (((1.0 + (u[4] / (1.0 / 3.0))) + ((u[4] * u[4]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      partial = (1.0 / 36.0) * local_density;\n      d_equ[5] = partial * (((1.0 + (u[5] / (1.0 / 3.0))) + ((u[5] * u[5]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[6] = partial * (((1.0 + (u[6] / (1.0 / 3.0))) + ((u[6] * u[6]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[7] = partial * (((1.0 + (u[7] / (1.0 / 3.0))) + ((u[7] * u[7]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      d_equ[8] = partial * (((1.0 + (u[8] / (1.0 / 3.0))) + ((u[8] * u[8]) / ((2.0 * (1.0 / 3.0)) * (1.0 / 3.0)))) - par);\n      s[0] = ts[0] + (omega * (d_equ[0] - ts[0]));\n      s[1] = ts[1] + (omega * (d_equ[1] - ts[1]));\n      s[2] = ts[2] + (omega * (d_equ[2] - ts[2]));\n      s[3] = ts[3] + (omega * (d_equ[3] - ts[3]));\n      s[4] = ts[4] + (omega * (d_equ[4] - ts[4]));\n      s[5] = ts[5] + (omega * (d_equ[5] - ts[5]));\n      s[6] = ts[6] + (omega * (d_equ[6] - ts[6]));\n      s[7] = ts[7] + (omega * (d_equ[7] - ts[7]));\n      s[8] = ts[8] + (omega * (d_equ[8] - ts[8]));\n      tot_u += sqrt(u_sq);\n      ++tot_cells;\n    }\n    else\n    {\n      s[1] = ts[3];\n      s[2] = ts[4];\n      s[3] = ts[1];\n      s[4] = ts[2];\n      s[5] = ts[7];\n      s[6] = ts[8];\n      s[7] = ts[5];\n      s[8] = ts[6];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:tot_u,tot_cells) schedule(static) nowait", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/noobcode/High-Performance-Computing/Src_OpenMP/d2q9-bgk/1"}
{"code": "for (unsigned int i = 0; i < dimension; ++i)\n{\n  for (unsigned int j = 0; j < dimension; ++j)\n  {\n    mJ(i, j) = rVertices[i + 1][j] - rVertices[0][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/15"}
{"code": "for (int64_t i = 0; i < n; i++)\n{\n  double X = 0;\n  for (int64_t j = Lptr[i], e = Lptr[i + 1]; j < e; ++j)\n    X += Lval[j] * x[Lcol[j]];\n\n  x[i] -= X;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/0"}
{"code": "for (i = 3; i <= end; i += 2)\n{\n  if ((num % i) == 0)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bscheibe/OpenMP-lab/isprime/1"}
{"code": "for (int i = 1; i < N; i++)\n  vec.col(i) += vec.col(i - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/reverseCummulativeSum/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (5.0 * u[i][j][k][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,k ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/129"}
{"code": "for (j = 1; j < (4096 + 1); j++)\n{\n  mean[j] = 0.0;\n  for (i = 1; i < (4096 + 1); i++)\n  {\n    mean[j] += data[(i * (4096 + 1)) + j];\n  }\n\n  mean[j] /= 3214212.01;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/COVAR/covariance_cpu/6"}
{"code": "for (int ii = 0; ii < npcelx; ii++)\n  for (int jj = 0; jj < npcely; jj++)\n  for (int kk = 0; kk < npcelz; kk++)\n{\n  double u;\n  double v;\n  double w;\n  double q;\n  double x;\n  double y;\n  double z;\n  sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n  x = ((ii + sample_u_double()) * dx_per_pcl) + cell_low_x;\n  y = ((jj + sample_u_double()) * dy_per_pcl) + cell_low_y;\n  z = ((kk + sample_u_double()) * dz_per_pcl) + cell_low_z;\n  create_new_particle(u, v, w, q_per_particle, x, y, z);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/12"}
{"code": "for (i = 0; i < X2->dim; i++)\n  v_set_val(X2, i, v_get_val(X, i) - (delta * v_get_val(Nx, i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/25"}
{"code": "for (i = 0; i < 10; i++)\n{\n  {\n    sum = intermediate + sum;\n  }\n}\n\n", "pragma": "omp parallel for ordered private(intermediate)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/directives/ordered/0"}
{"code": "for (i = 0; i < size; i++)\n  for (j = 0; j < size; j++)\n  if (i == j)\n  I[i][j] = 1;\nelse\n  I[i][j] = 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/13"}
{"code": "for (int i = 0; i < 150; i++)\n{\n  results[0] = svm_compute_parallel(samples[i], 2, set_vers_svs, set_vers_alphas, set_vers_bias);\n  results[1] = svm_compute_parallel(samples[i], 2, set_virg_svs, set_virg_alphas, set_virg_bias);\n  results[2] = svm_compute_parallel(samples[i], 16, versi_virg_svs, versi_virg_alphas, versi_virg_bias);\n  printf(\"%3d: \", i);\n  printf(\"%5f, \", results[0]);\n  printf(\"%5f, \", results[1]);\n  printf(\"%5f\\n\", results[2]);\n  printf(\"Final class -> %d\\n\", classify(results));\n  vresult_parallel[i] = classify(results);\n}\n\n", "pragma": "omp parallel for shared(vresult_parallel) private(results) firstprivate(samples, set_vers_svs, set_vers_alphas, set_vers_bias, set_virg_svs, set_virg_alphas, set_virg_bias, versi_virg_svs, versi_virg_alphas, versi_virg_bias)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/SVM/1"}
{"code": "for (i = 0; i < 1000000; i++)\n  arr[i] = rand() % 50;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rnikhori/OpenMP/histogram/0"}
{"code": "for (i = 0; i < n; ++i)\n{\n  printf(\"%d\\n\", c[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Matrix/Vector/main/3"}
{"code": "for (int i = 0; i < NUM_DIGITS_P; i++)\n{\n  if (prime_test != 0)\n    continue;\n\n  mpz_urandomm(a, state, b);\n  mpz_gcd(gcd, a, b);\n  int result = mpz_cmp_ui(gcd, 1);\n  if (result != 0)\n  {\n    prime_test |= 1 << i;\n    continue;\n  }\n\n  int j = mpz_jacobi(a, b);\n  mpz_set_ui(jacobi_sym, j);\n  mpz_set(exp, b);\n  mpz_sub_ui(exp, exp, 1);\n  mpz_cdiv_q_ui(exp, exp, 2);\n  mpz_powm(j_ab, a, exp, b);\n  result = mpz_cmp(jacobi_sym, j_ab);\n  if (result != 0)\n  {\n    prime_test |= 1 << i;\n    continue;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/rsa/1"}
{"code": "for (i = 0; i < (1 << NUM_BUCKETS_LOG_2); i++)\n  for (k = myid + 1; k < num_threads; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/14"}
{"code": "for (j = nStart; j < nEnd; j++)\n{\n  if (G->node[aN][j] != NO_CONN)\n  {\n    if ((G->D[aN] + G->node[aN][j]) < G->D[j])\n    {\n      G->D[j] = G->D[aN] + G->node[aN][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vikky92/HPC/Dijkstra_Algorithm/Dijkstra_OMPMPI/1"}
{"code": "for (unsigned int i = 0; i < son.size(); ++i)\n{\n  if (son.at(i) == \" \")\n    unused_daddy_genes.push_back(parents.at(1).at(i));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/11"}
{"code": "for (int i = 0; i < num_bin; i++)\n{\n  histogram[i] = 0;\n  omp_init_lock(&hist_lock[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ebi84/Histogram_OpenMP/Histogram/functions/5"}
{"code": "for (i = 0; i < (M * 2); i += incX + 1)\n{\n  r.REEL = 0;\n  r.IMAG = 0;\n  indice = i * M;\n  for (j = 0; j < (M * 2); j += incY + 1)\n  {\n    r.IMAG += (AP[indice + j] * (*((XP + i) + 1))) + ((*(XP + i)) * AP[(indice + j) + 1]);\n    r.REEL += (AP[indice + j] * (*(XP + i))) - (AP[(indice + j) + 1] * (*((XP + i) + 1)));\n  }\n\n  vcomplexe temp;\n  temp.REEL = *(YP + i);\n  temp.IMAG = *((YP + i) + 1);\n  *(YP + i) = ((temp.REEL * bv->REEL) - (temp.IMAG * bv->IMAG)) + ((av->REEL * r.REEL) - (av->IMAG * r.IMAG));\n  *((YP + i) + 1) = ((temp.REEL * bv->IMAG) + (temp.IMAG * bv->REEL)) + ((av->REEL * r.IMAG) + (av->IMAG * r.REEL));\n}\n\n", "pragma": "omp for schedule(static) private(i, j, r, indice)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemv/1"}
{"code": "for (i = 0; i < used_matrix_size; i++)\n{\n  for (j = 0; j < used_matrix_size; j++)\n  {\n    matB_trans[j][i] = matB[(i * used_matrix_size) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abodh/Parallel_matrix_mutiplication/mat_mat_parallel/3"}
{"code": "for (int j = 0; j < trees; ++j)\n{\n  ProjColX.pb(tp);\n  ProjSignX.pb(tp);\n  ProjColY.pb(tp);\n  ProjSignY.pb(tp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallelised-CRAFTML/CRAFTML_parallel_large/2"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  d_A[i] = (d_B[i] + d_C[i]) + 1;\n}\n\n", "pragma": "omp parallel for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/libomptarget/test/unified_shared_memory/api/0"}
{"code": "for (int i = 0; i < numThreads; i++)\n  fifo_init(&threadQueues[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apollo12221/Parallel-AG-Gen-Docker/c_bfs/7"}
{"code": "for (int n = 0; n < num_points; ++n)\n{\n  char msg[50];\n  sprintf(msg, \"Point %d\", n);\n  omp_debug(msg);\n  double min_distance = DBL_MAX;\n  int closest_cluster = -1;\n  for (int k = 0; k < num_clusters; ++k)\n  {\n    double distance_from_centroid = euclidean_distance(&dataset[n], &centroids[k]);\n    if (distance_from_centroid < min_distance)\n    {\n      min_distance = distance_from_centroid;\n      closest_cluster = k;\n    }\n\n  }\n\n  if (dataset[n].cluster != closest_cluster)\n  {\n    dataset[n].cluster = closest_cluster;\n    cluster_changes++;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/5"}
{"code": "for (int i = 0; i < nT; i++)\n{\n  SameSame += tSameSame[i];\n  SameDiff += tSameDiff[i];\n  DiffSame += tDiffSame[i];\n  Agree += nAgree[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:SameSame) reduction(+:SameDiff) \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/compare/1"}
{"code": "for (uint8_t i = 1; i < nLevels; i++)\n  downsampleConvolve_parallel(outPyr[i + 1], outPyr[i], &width, &height, filter, nThreads);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stranck/RealTimeLLF/src/OpenMP/openmp/5"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  addBorders();\n  applyAlgorithm();\n  copyGeneration();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rzaaeeff/GameofLife-OpenMP/GoLParallel/8"}
{"code": "for (unsigned char it = 'z'; it >= 'a'; it += -1)\n{\n  a += 1;\n  b[2] += 1.0;\n  bn[3] += 1.0;\n  c[1][2] += 1.0;\n  cn[1][3] += 1.0;\n  d.X += 1;\n  d.Y += 1;\n}\n\n", "pragma": "  #pragma omp target parallel for if(target: n>20) schedule(static, a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/4"}
{"code": "for (long i = 2; i <= max_num_threads; i *= 2)\n{\n  res[i] = piParallel(i);\n  printf(\"#threads: %ld time: %lf\\n\", i, res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q6/q6/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d\\t\", graf[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/7"}
{"code": "for (k2 = 0; k2 < N2; k2++)\n{\n  free(rows[k2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulises-jeremias/fft-parallel/fft/src/openmp/fft/8"}
{"code": "for (int t = 0; t < steps; t++)\n{\n  for (int i = 0; i < len; i++)\n  {\n    c = a[i] * b[i];\n    a[i] = c * ((double) t);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ujjwalx/gpu-prog/OpenMP/main/2"}
{"code": "for (i = 0; i < count; i++)\n{\n  strcpy(a, token);\n  stringsize = strlen(a);\n  test[i] = (char *) malloc(stringsize + 1);\n  strcpy(test[i], a);\n  token = strtok(0, \" \");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/10"}
{"code": "for (int j = 0; j < 1000; j++)\n  for (int i = 0; i < 1000; i++)\n  for (int m = 0; m < nmats; m++)\n{\n  double volfrac;\n  status = fscanf(fp, \"%lf\", &volfrac);\n  if (status < 0)\n  {\n    printf(\"error in read at line %d\\n\", 10);\n    exit(1);\n  }\n\n  if (volfrac > 0.0)\n  {\n    for (int jj = 0; jj < sy; jj++)\n      for (int ii = 0; ii < sx; ii++)\n    {\n      cc.Vf[((((i * sx) + ii) + (sizex * ((j * sy) + jj))) * Nmats) + m] = volfrac;\n      cc.rho[((((i * sx) + ii) + (sizex * ((j * sy) + jj))) * Nmats) + m] = 1.0;\n      cc.t[((((i * sx) + ii) + (sizex * ((j * sy) + jj))) * Nmats) + m] = 1.0;\n      cc.p[((((i * sx) + ii) + (sizex * ((j * sy) + jj))) * Nmats) + m] = 1.0;\n    }\n\n\n  }\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/10"}
{"code": "for (i = 512; i < 617; i++)\n{\n  glColor3f(0.5625f, 0.92f, 0.5625f);\n  glVertex3f(Shuffled_galaxysParticles[i].position_x, Shuffled_galaxysParticles[i].position_y, Shuffled_galaxysParticles[i].position_z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnouarWalziki/Galaxeirb/1024_particles_OpenMP/src/main/6"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  (SaveOut << (SumABParallelForTime[i] / 20)) << endl;\n  (SaveOut << (SumABParallelSectionTime[i] / 20)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 2/5"}
{"code": "for (int i = 0; i < image.rows; ++i)\n{\n  for (int j = 0; j < image.cols; ++j)\n  {\n    pixels[i][j] = (image.at < uchar) > ((i, j));\n  }\n\n  for (int i = 0; i < image.rows; i++)\n  {\n    fin[i] = encode((unsigned char *) pixels[i]);\n  }\n\n  for (int i = 0; i < image.rows; i++)\n    (file << fin[i]) << endl;\n\n  file.close();\n  gettimeofday(&end, NULL);\n  double delta = ((((end.tv_sec - start.tv_sec) * 1000000u) + end.tv_usec) - start.tv_usec) / 1.e6;\n  (((cout << \"Execution time :\") << delta) << \" seconds.\") << endl;\n  return 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Justmalhar/Parallelized-Image-Compression/imagecompression/1"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  x[i] = (((((double) rand()) / 32767) * (((double) rand()) / 32767)) * (((double) rand()) / 32767)) * 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_non_critical/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  u = SDGdata->startVertex[i];\n  j = numEdges[u] + pos[i];\n  endV[j] = SDGdata->endVertex[i];\n  w[j] = SDGdata->weight[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rinriko/OpenMPI_SSCA2.2/computeGraph/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int rootIndex = (i * N) / n;\n  for (int j = 1; j < (N / n); j++)\n  {\n    T[rootIndex] += T[rootIndex + j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/martamorg/PPAR_openmp/aggregation-openmp/2"}
{"code": "for (i = 0; i < 100000000; i++)\n  array[i] = (rand() % 10) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training4/b0521229-train4/0"}
{"code": "for (int row = 1; row < (Ny - 1); ++row)\n{\n  for (int inner_node = (row * Nx) + 1; inner_node < (((row + 1) * Nx) - 1); ++inner_node)\n  {\n    dU[inner_node] = (((((-4.0) * U[inner_node]) + U[inner_node - 1]) + U[inner_node + 1]) + U[inner_node - Nx]) + U[inner_node + Nx];\n    dV[inner_node] = (((((-4.0) * V[inner_node]) + V[inner_node - 1]) + V[inner_node + 1]) + V[inner_node - Nx]) + V[inner_node + Nx];\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raihaan123/HPC/CPP/src/ReactionDiffusion/1"}
{"code": "for (int i = 0; i < BLOCK_LINE_SIZE; i++)\n{\n  int pStart = M->cscp[(colBegin + 2) - i];\n  int pEnd = M->cscp[((colBegin + 2) - i) + 1] - 1;\n  if (pStart > pEnd)\n  {\n    continue;\n  }\n\n  _a = BinarySearch(M->csci, pStart, pEnd, linBegin);\n  if (_a == (-1))\n  {\n    _b = BinarySearch(M->csci, pStart, pEnd, linBegin + 1);\n    if (_b == (-1))\n    {\n      if (BinarySearch(M->csci, pStart, pEnd, linBegin + 2) == (-1))\n      {\n        continue;\n      }\n      else\n      {\n        value |= B001 << (i * 3);\n        continue;\n      }\n\n    }\n    else\n    {\n      if (((_b + 1) <= pEnd) && (M->csci[_b + 1] == (linBegin + 2)))\n      {\n        value |= B011 << (i * 3);\n        continue;\n      }\n\n    }\n\n  }\n  else\n  {\n    if (((_a + 1) <= pEnd) && (M->csci[_a + 1] == (linBegin + 1)))\n    {\n      if (((_a + 2) <= pEnd) && (M->csci[_a + 2] == (linBegin + 2)))\n      {\n        value |= B111 << (i * 3);\n        continue;\n      }\n      else\n      {\n        value |= B110 << (i * 3);\n        continue;\n      }\n\n    }\n    else\n    {\n      if (((_a + 1) <= pEnd) && (M->csci[_a + 1] == (linBegin + 2)))\n      {\n        value |= B101 << (i * 3);\n        continue;\n      }\n      else\n      {\n        value |= B100 << (i * 3);\n        continue;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kostascc/PDS-Project-4/src/CSCBlocking9/0"}
{"code": "for (int i = 0; i < n; ++i)\n  printf(\"%d \\t\\t %ld\\n\", i, dist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/argha072k/openmp/path/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  n = fscanf(arq, \"%lf %lf %lf %lf %lf\", &mass[i], &x[i], &y[i], &u[i], &v[i]);\n  if (n != 5)\n  {\n    printf(\"Error: Some reading won't work at line %d (%d).\\n\", i + 1, n);\n    fclose(arq);\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OsvaldoBecker/BarnesHut-OpenMP/barnes_hut/0"}
{"code": "for (s = 0; s < sz; s++)\n{\n  klabels[s] = -1;\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/13"}
{"code": "for (int i = 0; i < lhs.Size(); ++i)\n{\n  res += lhs[i] * rhs[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/8"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    forcing[i][j][k][m] = (-1.0) * forcing[i][j][k][m];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/38"}
{"code": "for (int i = 0; i < end; ++i)\n{\n  pthread_mutex_lock(&pivot_mutex);\n  count_threads++;\n  if (i == thread_end[interval_pointer])\n  {\n    WORKING_THREADS--;\n    interval_pointer++;\n  }\n\n  if (count_threads == WORKING_THREADS)\n  {\n    condition_pivot(i, n);\n    count_threads = 0;\n    pthread_cond_broadcast(&cd);\n  }\n  else\n  {\n    pthread_cond_wait(&cd, &pivot_mutex);\n  }\n\n  pthread_mutex_unlock(&pivot_mutex);\n  for (int j = start; j < end; ++j)\n    if (j > i)\n  {\n    double fac = a[id[j]][i] / a[id[i]][i];\n    for (int k = i + 1; k < n; ++k)\n    {\n      a[id[j]][k] -= a[id[i]][k] * fac;\n    }\n\n    a[id[j]][i] = 0;\n    b[id[j]] -= b[id[i]] * fac;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/gauss_elim/1"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  if (contadores[i] > 0)\n  {\n    mergesort(&buckets[i * sizeInput], contadores[i]);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule (static,nBuckets/numThreads) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raphael28/cp2018/Trabalho/Codigo/src/bucketSortPrl/2"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n  for (j = 1; j < (_PB_N - 1); j++)\n  B[i][j] = SCALAR_VAL(0.2) * ((((A[i][j] + A[i][j - 1]) + A[i][1 + j]) + A[1 + i][j]) + A[i - 1][j]);\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/jacobi-2d/jacobi-2d/0"}
{"code": "for (int j = 0; j < n; ++j)\n{\n  double y = ((double) (j + 1)) * dx;\n  double x = dx;\n  for (int i = 0; i < n; ++i)\n  {\n    u[i + (j * n)] = sin((acos(-1.0) * x) / length) * sin((acos(-1.0) * y) / length);\n    x += dx;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/heat_sycl/heat/0"}
{"code": "for (int i = 0; i < num_local_points; i++)\n{\n  int p_id = localDataset[i].id;\n  int c_id = memberships[i];\n  localMem[p_id] = c_id;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/17"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * (((u[i][j - 2][k][m_imopVar133] - (4.0 * u[i][j - 1][k][m_imopVar133])) + (6.0 * u[i][j][k][m_imopVar133])) - (4.0 * u[i][j + 1][k][m_imopVar133])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/68"}
{"code": "for (int itr1 = 0; itr1 < row; itr1++)\n{\n  for (int itr2 = 0; itr2 < col; itr2++)\n  {\n    printf(\"%d  \", matrix[itr1][itr2]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/OpenMP-and-MPI-Assignment/assignmnet2_MPI_implementation/2"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  strip[i][rc] = rbuf[tid][i];\n  strip[i][lc] = lbuf[tid][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vignesh-raghavan/Parallel-Programming/TempDistribution/3/8"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = xvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/reset_field_kernel_c/2"}
{"code": "for (int i = 0; i < ITER; i++)\n{\n  divideImageDataWithParam(src.data(), width, dst.data(), width, size, PARAM);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tb45/OpenMP-Strange-Behavior/test/test/8"}
{"code": "for (i = 0; i < 40; i++)\n{\n  _fict_[i] = (DATA_TYPE) i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/acc/FDTD-2D/fdtd2d/38"}
{"code": "for (unsigned int pos = 0; pos < pathN; pos++)\n{\n  unsigned int d = (pos + 1) * distance;\n  output[pos] = MoroInvCNDgpu(d);\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(szWgXDim)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qrg-omp/main/1"}
{"code": "for (i = 1; i < (my_grid->dimension - 1); i++)\n{\n  for (j = ((i + k) % 2) + 1; j < (my_grid->dimension - 1); j += 2)\n  {\n    temp = my_grid->element[(i * my_grid->dimension) + j];\n    my_grid->element[(i * my_grid->dimension) + j] = 0.20 * ((((my_grid->element[(i * my_grid->dimension) + j] + my_grid->element[((i - 1) * my_grid->dimension) + j]) + my_grid->element[((i + 1) * my_grid->dimension) + j]) + my_grid->element[(i * my_grid->dimension) + (j + 1)]) + my_grid->element[(i * my_grid->dimension) + (j - 1)]);\n    diff = diff + fabs(my_grid->element[(i * my_grid->dimension) + j] - temp);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) default(none) private(i, j, temp) shared(k, my_grid) reduction( + : diff)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mklobukov/Parallel-Programming/Cholesky/solver/solverr/0"}
{"code": "for (int k = 0; k < s.a.a; ++k)\n  ++s.a.a;\n\n", "pragma": "#pragma omp for private(a) private(this->a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_ast_print/1"}
{"code": "for (int x = 0; x < N; x++)\n{\n  for (int y = 0; y < N; y++)\n  {\n    matA[x][y] = rand();\n    matB[x][y] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/5"}
{"code": "for (i = 0; i < size; i++)\n{\n  fprintf(pWrite, \"%d\\n\", labels[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yq314/k-means/k-means-openmp/kmeans/8"}
{"code": "for (int k = 0; k < num_elements; k++)\n{\n  Final[rows_per_block - 1][(cols_per_block - 1) * num_elements] = ((unsigned char) ceil(((((((((h[0][0] * Table[rows_per_block - 2][((cols_per_block - 2) * num_elements) + k]) + (h[0][1] * Table[rows_per_block - 2][((cols_per_block - 1) * num_elements) + k])) + (h[0][2] * halo_p->East[k - num_elements])) + (Table[rows_per_block - 1][((cols_per_block - 2) * num_elements) + k] * h[1][0])) + (h[1][1] * Table[rows_per_block - 1][((cols_per_block - 1) * num_elements) + k])) + (h[1][2] * halo_p->East[((cols_per_block - 1) * num_elements) + k])) + (h[2][0] * Table[1][((cols_per_block - 2) * num_elements) + k])) + (h[2][1] * Table[1][((cols_per_block - 1) * num_elements) + k])) + (h[2][2] * halo_p->South_East[k]))) % 256;\n  if (!(Final[0][0] == Table[0][0]))\n    changes++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisKarampas/Image_Convolution/src/main/13"}
{"code": "for (i = 0; i < (rows + 2); i++)\n{\n  if ((i == 0) || (i == (rows + 1)))\n  {\n    for (j = 0; j < size; j++)\n    {\n      local_data[i][j] = 0;\n    }\n\n  }\n  else\n  {\n    for (j = 0; j < size; j++)\n    {\n      local_data[i][j] = data[(offset + i) - 1][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaaasonwu/HeatDistribution/mpi_heat_distribution/4"}
{"code": "for (int j = 0; j < (n / 2); j++)\n{\n  compare_exchange(&a[(2 * j) + 1], &a[(2 * j) + 2]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/exam-prep/exam16/0"}
{"code": "for (int j = 0; j < layer.size(); j++)\n{\n  output_holder(j) = layer.at(j).feedforward(input_holder);\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xbassi/dl-space/graph/0"}
{"code": "for (l = 0; l < nz; l++)\n{\n  ll = nnxye * l;\n  for (k = 0; k < ny; k++)\n  {\n    cu[((4 * nxe) * k) + ll] += cu[(4 * (nx + (nxe * k))) + ll];\n    cu[(1 + ((4 * nxe) * k)) + ll] += cu[(1 + (4 * (nx + (nxe * k)))) + ll];\n    cu[(2 + ((4 * nxe) * k)) + ll] += cu[(2 + (4 * (nx + (nxe * k)))) + ll];\n    cu[(4 * (nx + (nxe * k))) + ll] = 0.0;\n    cu[(1 + (4 * (nx + (nxe * k)))) + ll] = 0.0;\n    cu[(2 + (4 * (nx + (nxe * k)))) + ll] = 0.0;\n  }\n\n  for (j = 0; j < nx; j++)\n  {\n    cu[(4 * j) + ll] += cu[(4 * (j + (nxe * ny))) + ll];\n    cu[(1 + (4 * j)) + ll] += cu[(1 + (4 * (j + (nxe * ny)))) + ll];\n    cu[(2 + (4 * j)) + ll] += cu[(2 + (4 * (j + (nxe * ny)))) + ll];\n    cu[(4 * (j + (nxe * ny))) + ll] = 0.0;\n    cu[(1 + (4 * (j + (nxe * ny)))) + ll] = 0.0;\n    cu[(2 + (4 * (j + (nxe * ny)))) + ll] = 0.0;\n  }\n\n  cu[ll] += cu[(4 * (nx + (nxe * ny))) + ll];\n  cu[1 + ll] += cu[(1 + (4 * (nx + (nxe * ny)))) + ll];\n  cu[2 + ll] += cu[(2 + (4 * (nx + (nxe * ny)))) + ll];\n  cu[(4 * (nx + (nxe * ny))) + ll] = 0.0;\n  cu[(1 + (4 * (nx + (nxe * ny)))) + ll] = 0.0;\n  cu[(2 + (4 * (nx + (nxe * ny)))) + ll] = 0.0;\n}\n\n", "pragma": "omp for private(j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/24"}
{"code": "for (j = 0; j < k; j++)\n{\n  if (!(neighbors[j].dist == 10000))\n    fprintf(stderr, \"%s --> %f\\n\", neighbors[j].entry, neighbors[j].dist);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nn/nn_hsa/4"}
{"code": "for (int i = upXstart; i <= xend; i++)\n  for (int j = ybeg; j <= yend; j++)\n  for (int k = zbeg; k <= zend; k++)\n{\n  populate_cell_with_particles(i, j, k, q_per_particle, dx_per_pcl, dy_per_pcl, dz_per_pcl);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/14"}
{"code": "for (int i = 1; i < 15; ++i)\n{\n  if (stat <= critical_values[i])\n  {\n    pval = probas[i - 1] + (((stat - critical_values[i - 1]) * (probas[i] - probas[i - 1])) / (critical_values[i] - critical_values[i - 1]));\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olmallet81/URT/R/RcppURT/src/UnitRoot/1"}
{"code": "for (unsigned int i = 0; i < numTrees; i++)\n  treeBuilder.DestroyNode(rootArr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YSZhuoyang/parallel-random-forests/Classifier/0"}
{"code": "for (int j = 0; j < pcinfo.y_cells_num; j++)\n{\n  f[(j * pcinfo.x_cells_num) + (pcinfo.x_cells_num - 1)] = 0;\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/13"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  wijk = ws[i][j][k];\n  wp1 = ws[i][j][k + 1];\n  wm1 = ws[i][j][k - 1];\n  rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n  rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n  rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n  rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n  rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n}\n\n", "pragma": "omp parallel for private (wm1,wijk,wp1,k) firstprivate (tz2,zzcon2,zzcon3,zzcon4,zzcon5,dz1tz1,dz2tz1,dz3tz1,dz4tz1,dz5tz1,c1,c2,con43)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/134"}
{"code": "for (i = 0; i < n; i++)\n{\n  p[i] = 1.0 / n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leankyr/Parallel_Pagerank/Final/Implementation_2/main2/7"}
{"code": "for (i = 0; i < 4096; i++)\n{\n  for (j = 0; j < 4096; j++)\n  {\n    A[(i * 4096) + j] = (((DATA_TYPE) i) * j) / 4096;\n  }\n\n  for (j = 0; j < 4096; j++)\n  {\n    C[(i * 4096) + j] = ((((DATA_TYPE) i) * j) + 2) / 4096;\n    D[(i * 4096) + j] = ((((DATA_TYPE) i) * j) + 2) / 4096;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ruixueqingyang/OAO-Translator/benchmarks/PolyBench/plain/SYRK/syrk/2"}
{"code": "for (int row = 0; row < n; row++)\n  if (degree[row] < degree[perm[0]])\n  perm[0] = row;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manolismih/sparseMatPerm/parallel/4"}
{"code": "for (unsigned c = 0, c4 = 0; c < n3size; c++)\n{\n  totnrf += ResultAux[c4++];\n  totnrb += ResultAux[c4++];\n  totncf += ResultAux[c4++];\n  totncb += ResultAux[c4++];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsPips/2"}
{"code": "for (mat_row = 0; mat_row < n; mat_row++)\n{\n  grid_row = mat_row / local_A->n_bar;\n  coords[0] = grid_row;\n  for (grid_col = 0; grid_col < grid->q; grid_col++)\n  {\n    coords[1] = grid_col;\n    MPI_Cart_rank(grid->comm, coords, &dest);\n    if (dest == 0)\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        fscanf(fp, \"%lf\", (local_A->entries + (mat_row * local_A->n_bar)) + mat_col);\n\n    }\n    else\n    {\n      for (mat_col = 0; mat_col < local_A->n_bar; mat_col++)\n        fscanf(fp, \"%lf\", temp + mat_col);\n\n      MPI_Send(temp, local_A->n_bar, (MPI_Datatype) 0x4c00080b, dest, 0, grid->comm);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/4"}
{"code": "for (i = 0; i < x_points; i++)\n{\n  x_i = x_b + (i * x_ofst);\n  y_i = y_b;\n  for (j = 0; j < y_points; j++)\n  {\n    A(i, j) = ((2. * x_i) * x_i) + (y_i * y_i);\n    y_i += y_ofst;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(A, x_b, y_b, x_ofst, y_ofst, x_points, y_points) private(i, j, x_i, y_i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarceloFCandido/PIC02/src/openMP/fc-openmp-parabolloid/src/solver/0"}
{"code": "for (i = tstart; i < tend; i++)\n  psum2 += func(from + (h * i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Simpson/11"}
{"code": "for (i = 0; i < numpoints; i++)\n{\n  for (j = 0; j < numpoints; j++)\n  {\n    utmp[i][j] = 0;\n    u[i][j] = 0;\n    f[i][j] = ((((-2.) * 100.) * (pi * pi)) * sin(((10. * pi) * i) * h)) * sin(((10. * pi) * j) * h);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/federhub/HPC-MPI-OpenMP-/Code/Solutions/poisson_omp/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = bt * r1;\n      t2 = 0.5 * (r4 + r5);\n      rhs[0][i][j][k] = bt * (r4 - r5);\n      rhs[1][i][j][k] = -r3;\n      rhs[2][i][j][k] = r2;\n      rhs[3][i][j][k] = (-t1) + t2;\n      rhs[4][i][j][k] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i ,j ,k ,r1 ,r2 ,r3 ,r4 ,r5 ,t1 ,t2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/85"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if (pop[i][j] == Exposed)\n      pop[i][j] = Infected;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(pop) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elc139/t4-pangolim/omp_virus/Population/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%d \\n\", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPreductionClause/1"}
{"code": "for (i = 0; i <= (10000 + 1); i++)\n{\n  Temperature_last[i][0] = 0.0;\n  Temperature_last[i][10000 + 1] = (100.0 / 10000) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bakitybacon/parallelprogramming/Exercises/OpenMP/laplace_10k/3"}
{"code": "for (int i = 0; i < length; ++i)\n{\n  if ((data[i] > 1000000000000.0) || (data[i] < (-1000000000000.0)))\n    continue;\n\n  tmp = data[i] - avg;\n  sum += tmp * tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/5"}
{"code": "for (o = 0; o < l; o++)\n  sum += (((d[(i * l) + o] - mi) * (d[(k * l) + o] - mk)) / si) / sk;\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UP-RS-ESP/CorrCoef/CorrCoef/2"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  minn = (float) 2147483647;\n  d = 0;\n  for (int j = 0; j < 8; ++j)\n  {\n    float temp1[4];\n    res = _mm_setzero_ps();\n    for (int k = 4 - 4; k >= 0; k -= 4)\n    {\n      int t1;\n      int t2;\n      t1 = _mm_loadu_ps(point[i].elements + k);\n      t2 = _mm_loadu_ps(mean[j].elements + k);\n      t2 = _mm_sub_ps(t1, t2);\n      t2 = _mm_mul_ps(t2, t2);\n      res = _mm_add_ps(res, t2);\n    }\n\n    _mm_storeu_ps(temp1, res);\n    for (int k = (4 % 4) - 1; k >= 0; --k)\n    {\n      d += (point[i].elements[k] - mean[j].elements[k]) * (point[i].elements[k] - mean[j].elements[k]);\n    }\n\n    d += ((temp1[0] + temp1[1]) + temp1[2]) + temp1[3];\n    if (d < minn)\n    {\n      minn = d;\n      center[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(minn,d,res),schedule(dynamic,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+SSE+kmeans/2"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (graph->grid->out_degree[v])\n    riDividedOnDiClause[v] = DoubleToFixed64(stats->pageRanks[v] / graph->grid->out_degree[v]);\n  else\n    riDividedOnDiClause[v] = 0.0f;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/7"}
{"code": "for (vertex_id = 0; vertex_id < stats->num_vertices; vertex_id++)\n{\n  stats->distances[vertex_id] = UINT32_MAX;\n  stats->dependency[vertex_id] = 0.0f;\n  stats->sigma[vertex_id] = 0;\n  stats->stack->nodes[vertex_id] = 0;\n  stats->predecessors[vertex_id].degree = 0;\n  stats->parents[vertex_id] = -1;\n}\n\n", "pragma": "omp parallel for default(none) private(vertex_id) shared(stats)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/betweennessCentrality/1"}
{"code": "for (j = jb * Bsize; j < ((jb + 1) * Bsize); j++)\n{\n  for (k = kb * Bsize; k < ((kb + 1) * Bsize); k++)\n  {\n    Bwrk[((k % Bsize) * Bsize) + (j % Bsize)] = B[(k * Mdim) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/mm_gpu_block/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    int converges = 0;\n    x = ((((double) (j - 1)) * x_max) + (((double) (rows - j)) * x_min)) / ((double) (rows - 1));\n    y = ((((double) (i - 1)) * y_max) + (((double) (cols - i)) * y_min)) / ((double) (cols - 1));\n    count[i][j] = -1;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    int idx;\n    idx = (rows * i) + j;\n    PPMPixel *temp = output->data + idx;\n    color *c = getColour(count[i][j]);\n    temp->red = c->r;\n    temp->green = c->g;\n    temp->blue = c->b;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Unnati-P/Plotting-the-fractal-structure-Mandelbrot-Set/parallel_measurement/0"}
{"code": "for (i = 0; i < 6; i += 2)\n{\n  L = BF_out[index][i];\n  R = BF_out[index][i + 1];\n  L ^= BF_current[index].P[0];\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[0 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[1 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[2 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[3 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[4 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[5 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[6 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[7 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[8 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[9 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[10 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[11 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[12 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[13 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u1 = L & 0xFF;\n  u1 <<= 2;\n  u2 = L >> 6;\n  u2 &= 0x3FC;\n  u3 = L >> 14;\n  u3 &= 0x3FC;\n  u4 = L >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  R ^= BF_current[index].P[14 + 1];\n  u3 += u1;\n  R ^= u3;\n  ;\n  u1 = R & 0xFF;\n  u1 <<= 2;\n  u2 = R >> 6;\n  u2 &= 0x3FC;\n  u3 = R >> 14;\n  u3 &= 0x3FC;\n  u4 = R >> 22;\n  u4 &= 0x3FC;\n  u1 = *((BF_word *) (((unsigned char *) BF_current[index].S[3]) + u1));\n  u2 = *((BF_word *) (((unsigned char *) BF_current[index].S[2]) + u2));\n  u3 = *((BF_word *) (((unsigned char *) BF_current[index].S[1]) + u3));\n  u3 += *((BF_word *) (((unsigned char *) BF_current[index].S[0]) + u4));\n  u3 ^= u2;\n  L ^= BF_current[index].P[15 + 1];\n  u3 += u1;\n  L ^= u3;\n  ;\n  u4 = R;\n  R = L;\n  L = u4 ^ BF_current[index].P[16 + 1];\n  ;\n  BF_out[index][i] = L;\n  BF_out[index][i + 1] = R;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/6"}
{"code": "for (int i = 0; i < N; i++)\n  execution_state[i] = UNDEFINED;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/15"}
{"code": "for (j = n - 1; j >= 0; j--)\n{\n  for (i = 0; i < j; i++)\n  {\n    y[i] -= a[i + (j * n)] * y[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/13"}
{"code": "for (unsigned int i_node = 0; i_node < pts_number; ++i_node)\n{\n  if (rNodalDistances[i_node] > 0.0)\n    n_pos++;\n  else\n    n_neg++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/FluidDynamicsApplication/custom_processes/embedded_skin_visualization_process/1"}
{"code": "for (j = 0; j < n2; j++)\n{\n  v = 0;\n  for (k = 0; k < dim; k++)\n    v += ((X1[(n1 * k) + i] - X2[(n2 * k) + j]) * (X1[(n1 * k) + i] - X2[(n2 * k) + j])) / max(X1[(n1 * k) + i] + X2[(n2 * k) + j], 1e-20);\n\n  K[(n1 * j) + i] = v;\n}\n\n", "pragma": "        #pragma omp parallel for private(j) reduction(+:v) num_threads(nthread)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fangzheng354/chi2-openmp-matlab/chi2_float/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  z[i] = (a * x[i]) + y[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Daedgomez/CE-4302-TallerOpenMP/saxpy_par/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  km1 = k - 1;\n  kp1 = k + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tz2 * (ue[3][kp1] - ue[3][km1]))) + (dz1tz1 * ((ue[0][kp1] - (2.0 * ue[0][k])) + ue[0][km1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tz2 * ((ue[1][kp1] * buf[3][kp1]) - (ue[1][km1] * buf[3][km1])))) + (zzcon2 * ((buf[1][kp1] - (2.0 * buf[1][k])) + buf[1][km1]))) + (dz2tz1 * ((ue[1][kp1] - (2.0 * ue[1][k])) + ue[1][km1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tz2 * ((ue[2][kp1] * buf[3][kp1]) - (ue[2][km1] * buf[3][km1])))) + (zzcon2 * ((buf[2][kp1] - (2.0 * buf[2][k])) + buf[2][km1]))) + (dz3tz1 * ((ue[2][kp1] - (2.0 * ue[2][k])) + ue[2][km1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tz2 * (((ue[3][kp1] * buf[3][kp1]) + (c2 * (ue[4][kp1] - q[kp1]))) - ((ue[3][km1] * buf[3][km1]) + (c2 * (ue[4][km1] - q[km1])))))) + (zzcon1 * ((buf[3][kp1] - (2.0 * buf[3][k])) + buf[3][km1]))) + (dz4tz1 * ((ue[3][kp1] - (2.0 * ue[3][k])) + ue[3][km1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tz2 * ((buf[3][kp1] * ((c1 * ue[4][kp1]) - (c2 * q[kp1]))) - (buf[3][km1] * ((c1 * ue[4][km1]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[0][kp1] - (2.0 * buf[0][k])) + buf[0][km1]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[4][kp1] - (2.0 * buf[4][k])) + buf[4][km1]))) + (dz5tz1 * ((ue[4][kp1] - (2.0 * ue[4][k])) + ue[4][km1]));\n}\n\n", "pragma": "omp parallel for firstprivate(dz1tz1 ,tz2 ,dz2tz1 ,zzcon2 ,dz3tz1 ,dz4tz1 ,zzcon1 ,c2 ,dz5tz1 ,zzcon5 ,zzcon4 ,zzcon3 ,c1 ,k ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/31"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  (((((((((cout << \"CELLP\\t\") << \": NV = \") << cell(ci).getNV()) << setw(6)) << \"; cx = \") << cell(ci).cpos(0)) << setw(6)) << \"; cy = \") << cell(ci).cpos(1)) << endl;\n  for (vi = 0; vi < cell(ci).getNV(); vi++)\n  {\n    cout << \"VERTP\\t\";\n    (cout << cell(ci).vpos(vi, 0)) << \"; \";\n    (cout << cell(ci).vpos(vi, 1)) << \"; \";\n    (cout << cell(ci).vvel(vi, 0)) << \"; \";\n    (cout << cell(ci).vvel(vi, 1)) << \"; \";\n    (cout << cell(ci).vforce(vi, 0)) << \"; \";\n    cout << cell(ci).vforce(vi, 1);\n    cout << endl;\n  }\n\n  ((cout << endl) << endl) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/7"}
{"code": "for (uint64_t i = n - k; i < n; i++)\n{\n  m += (uint64_t) buffer[i];\n  for (uint64_t j = 0; j < (n - i); j++)\n  {\n    rk[j] += ((uint64_t) buffer[i]) * ((uint64_t) buffer[i + j]);\n  }\n\n}\n\n", "pragma": "omp for reduction(+:m), reduction(+:rk[:k])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/autocorrelation/autocorrelation/1"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  if (jouer_coup(cs, &newPos, pos, joueur, i))\n  {\n    const int val = valeur_minimaxAB(cs, &newPos, !joueur, alpha, beta, pmax - 1, gagne);\n    if (val > alpha)\n    {\n      alpha = val;\n    }\n\n    if (alpha >= beta)\n    {\n      return alpha;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/16"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    h[next][i][j] = 0.25 * (((h[current][i - 1][j] + h[current][i + 1][j]) + h[current][i][j - 1]) + h[current][i][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/parallelx/0"}
{"code": "for (i = 0; i < nelem; i++)\n{\n  closest = FLT_MAX;\n  for (n = 0; n < NGROUPS; n++)\n  {\n    dist = gendist(elem[i], cent[n]);\n    if (dist < closest)\n    {\n      closest = dist;\n      grind[i] = n;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(nelem, elem, cent, grind) private(i, n, dist, closest) num_threads(NUM_THREADS) schedule(dynamic, 3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Asiern/Genetics/Source/fungg_p/0"}
{"code": "for (i = 0; i < messages.size(); ++i)\n{\n  encrypted_messages[i] = XOR(aes.encrypt(ctrs[i]), messages[i]);\n}\n\n", "pragma": "\t\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/franneck94/CUDA-AES/AES OpenMP/Mode/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  *(idx + i) = i;\n  for (int j = 0; j < d; j++)\n    *((X_copy + (i * d)) + j) = *((X + (i * d)) + j);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angrammenos97/VP_Tree/vptree/src/vptree_openmp/4"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (cj = ci + 1; cj < NCELLS; cj++)\n  {\n    if (contacts(ci, cj) > 0)\n      nc++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/35"}
{"code": "for (i = 0; i < N; i++)\n{\n  P_a = particles + i;\n  P_a->x = P_a->x_n;\n  P_a->y = P_a->y_n;\n}\n\n", "pragma": "omp parallel for private(P_a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nexuslrf/Parallelizable_Particle_Collision_Simulation/collision_seq_p1/2"}
{"code": "for (int j = 0; j < rectangles.size(); j++)\n{\n  for (int i = 0; i < 4; i++)\n  {\n    box.min[0] = min(rectangles[j].x[i], box.min[0]);\n    box.min[1] = min(rectangles[j].y[i], box.min[1]);\n    box.min[2] = min(rectangles[j].z[i], box.min[2]);\n    box.max[0] = max(rectangles[j].x[i], box.max[0]);\n    box.max[1] = max(rectangles[j].y[i], box.max[1]);\n    box.max[2] = max(rectangles[j].z[i], box.max[2]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmrHMorsy/Raytracer/src/Scene/1"}
{"code": "for (dest = 1; dest < proc_n; dest++)\n{\n  MPI_Send(&kill_flag, 1, MPI_INT, dest, mtype, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Diogo45/OpenMPI/mandelbrot/1"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  int *arr = get_ordered(size);\n  start();\n  parallel_linear_search(arr, size, item);\n  times[i] = end();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blottn/openmp-assignment/parallel_search/1"}
{"code": "for (int i = 1; i < my_vec.size(); i++)\n{\n  if (my_vec[i] < min)\n  {\n    min = my_vec[i];\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/skynet118/openmp/min_max/0"}
{"code": "for (uint i = 0; i < nBonds; ++i)\n{\n  bonded[i] = onFocus[i].a1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedron/0"}
{"code": "for (int i = 0; i < numTests; ++i)\n{\n  free(test[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/17"}
{"code": "for (int ii = 0; ii < n; ii++)\n{\n  vec[ii] = (iter + ii) + x;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for map( \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-5.0.0/llvm/tools/clang/test/OpenMP/report_default_DSA/0"}
{"code": "for (uint i = 0; i < input_vec.size(); ++i)\n{\n  score[i] = (sin((1 / per1) * (i + 1)) * uni1) + (sin((1 / per2) * (i + 1)) * uni2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/1"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  qa = mod09GQa(lQC[rowcol]);\n  qa1 = mod09GQc(lQC[rowcol], 1);\n  qa2 = mod09GQc(lQC[rowcol], 2);\n  if (((((qa == 0) && (qa1 == 0)) && (qa2 == 0)) && (l3[rowcol] > 0.18)) && ((l1[rowcol] + l2[rowcol]) != 0.0))\n    lOut[rowcol] = (1000 * (l2[rowcol] - l1[rowcol])) / (l2[rowcol] + l1[rowcol]);\n  else\n    lOut[rowcol] = -28672;\n\n}\n\n", "pragma": "omp parallel for default(none) private (rowcol,qa,qa1,qa2) shared (N, l1, l2, lQC, l3, lOut)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_MOD09GaGq_NDVI/ndvi/0"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  veltmp = cell(ci).angularV;\n  aold = cell(ci).b;\n  ftmp = cell(ci).torque / cell(ci).inertia;\n  dampNum = b * (veltmp - ((0.5 * aold) * dt));\n  dampDenom = 1.0 + ((0.5 * b) * dt);\n  dampUpdate = (ftmp - dampNum) / dampDenom;\n  anew = dampUpdate;\n  veltmp += (0.5 * dt) * (anew + aold);\n  cell(ci).angularV = veltmp;\n  cell(ci).b = anew;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/131"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if (data[i] > max)\n    max = data[i];\n\n  printf(\"now max=%d, and TID=%d\\n\", max, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongrun007/openmp/last/0"}
{"code": "for (j = Neighbors->head; j < Neighbors->tail; j++)\n{\n  uint32_t i = Neighbors->queue[j];\n  uint32_t degreeUout = 0;\n  degreeUout = stats->atom[stats->dest[i]].pair.degree;\n  if (degreeUout != 4294967295U)\n  {\n    deltaQtemp = 2 * ((edgeWeightUV * numEdgesm) - ((float) ((degreeVout * degreeUout) * numEdgesm2)));\n    if (((*deltaQ) < deltaQtemp) && (i != v))\n    {\n      *deltaQ = deltaQtemp;\n      *u = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/6"}
{"code": "for (h = 1; h <= cnt; h++)\n{\n  if (f_sbml == 0)\n  {\n    strcpy(fpname, topoinfo->modelname);\n    if (simu_opts->exts == 0)\n    {\n      if (simu_opts->numKD != 0)\n      {\n        strcat(fpname, \"_KD\");\n        for (i = 0; i < simu_opts->numKD; i++)\n        {\n          sprintf(KDIDname, \"%d\", simu_opts->KDID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, KDIDname);\n        }\n\n      }\n\n      if (simu_opts->numOE != 0)\n      {\n        strcat(fpname, \"_OE\");\n        for (i = 0; i < simu_opts->numOE; i++)\n        {\n          sprintf(OEIDname, \"%d\", simu_opts->OEID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, OEIDname);\n        }\n\n      }\n\n      if (simu_opts->numDE != 0)\n      {\n        strcat(fpname, \"_DE\");\n        for (i = 0; i < simu_opts->numDE; i++)\n        {\n          sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, DEIDname);\n        }\n\n      }\n\n    }\n\n    strcat(fpname, \"_sbml\");\n    sprintf(modelIDname, \"%d\", modelID);\n    strcat(fpname, \"_\");\n    strcat(fpname, modelIDname);\n    sprintf(nstbname, \"%d\", h);\n    strcat(fpname, \"_\");\n    strcat(fpname, nstbname);\n    strcat(fpname, \".xml\");\n    f_sbml = fopen(fpname, \"w\");\n  }\n\n  fprintf(f_sbml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n  fprintf(f_sbml, \"<sbml level=\\\"2\\\" version=\\\"3\\\" xmlns=\\\"http://www.sbml.org/sbml/level2/version3\\\">\\n\");\n  fprintf(f_sbml, \"\\t<model name=\\\"No_%d_model_%d\\\">\\n\", modelID, h);\n  fprintf(f_sbml, \"\\t\\t<listOfFunctionDefinitions>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t<functionDefinition id=\\\"hillfunction\\\">\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\txmlns:sbml=\\\"http://www.sbml.org/sbml/level3/version2/core\\\">\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t<lambda>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> x </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> x0 </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> lamda </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> nx </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<plus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<ci> lamda </ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<minus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lamda</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<plus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<power/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x0</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>nx</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t</lambda>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t</math>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t</functionDefinition>\\n\");\n  fprintf(f_sbml, \"\\t\\t</listOfFunctionDefinitions>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfSpecies>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<species id=\\\"x%d\\\"  initialAmount=\\\"%f\\\"    name=\\\"%s\\\"/>\\n\", i, tmprlt->soln[(topoinfo->numG * (h - 1)) + i], topoinfo->Gname[i]);\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfSpecies>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfParameters>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"g%d\\\"  value=\\\"%f\\\"/>\\n\", i, tmprlt->paras[i]);\n  }\n\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"k%d\\\"  value=\\\"%f\\\"/>\\n\", i, tmprlt->paras[i + topoinfo->numG]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"T%d\\\"  value=\\\"%f\\\"/>\\n\", (3 * i) + (2 * topoinfo->numG), tmprlt->paras[(3 * i) + (2 * topoinfo->numG)]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"n%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 1, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 1]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 1)\n    {\n      fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"lambda%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 2, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 2]);\n    }\n    else\n      if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 2)\n    {\n      fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"lambda%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 2, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 2]);\n    }\n\n\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfParameters>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfReactions>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<reaction id=\\\"eq_%d\\\">\\n\", i + 1);\n    fprintf(f_sbml, \"\\t\\t\\t\\t<listOfProducts>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t<speciesReference species=\\\"x%d\\\" />\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t</listOfProducts>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t<kineticLaw>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\">\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<minus/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>g%d</ci>\\n\", i);\n    for (j = 0; j < topoinfo->numR; j++)\n    {\n      if (topoinfo->TargetG[j] == i)\n      {\n        if (topoinfo->TypeR[j] == 1)\n        {\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>hillfunction</ci>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", topoinfo->SourceG[j]);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>T%d</ci>\\n\", (2 * topoinfo->numG) + (3 * j));\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>n%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 1);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n        }\n        else\n          if (topoinfo->TypeR[j] == 2)\n        {\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>hillfunction</ci>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", topoinfo->SourceG[j]);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>T%d</ci>\\n\", (2 * topoinfo->numG) + (3 * j));\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>n%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 1);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n        }\n\n\n      }\n\n    }\n\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>k%d</ci>\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t</math>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t</kineticLaw>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t</reaction>\\n\");\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfReactions>\\n\");\n  fprintf(f_sbml, \"\\t</model>\\n\");\n  fprintf(f_sbml, \"</sbml>\\n\");\n  fclose(f_sbml);\n  f_sbml = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/65"}
{"code": "for (i = 1; i < (_PB_N - 1); i++)\n  A[i] = 0.33333 * ((B[i - 1] + B[i]) + B[i + 1]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HPCA4SE-UAB/Building-a-dataset-for-classifying-OpenMP-parallelpatterns-via-Machine-Learning/polybench/stencils/jacobi-1d/jacobi-1d/0"}
{"code": "for (next = 0; next < num_vertices; next++)\n{\n  new_dist = node_dist[curr_node] + graph[(curr_node * num_vertices) + next];\n  if (((visited_node[next] != 1) && (graph[(curr_node * num_vertices) + next] != ((data_t) 0))) && (new_dist < node_dist[next]))\n  {\n    node_dist[next] = new_dist;\n    parent_node[next] = curr_node;\n  }\n\n}\n\n", "pragma": "omp for private(new_dist,next)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/1"}
{"code": "for (i = 0; i < n_centroids; i++)\n{\n  centroid_x[i] = centroids[i].x;\n  centroid_y[i] = centroids[i].y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Luca-Ferrera/k-means/app_mp_mpi/3"}
{"code": "for (int i = 0; i < V; i++)\n{\n  arrD[i] = infinity;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ryanmueller28/OpenMP-BellmanFord/bf/0"}
{"code": "for (j = 0; j < max_threads; j++)\n{\n  if (active_threads[j])\n    threadsnum++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_auto/2"}
{"code": "for (int i = 0; i < m_matdim; i++)\n{\n  testaccumulator1 += m_testmatrix->GetElem(0, i);\n  testaccumulator2 += m_testmatrix->GetElem(10, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fpaboim/gpufem/src/Test/SPRmatrixTest/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  x[i] = 1.0;\n  y[i] = 2.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/allgebra/examples/clang_omp_offloading/omp_offloading/0"}
{"code": "for (int i = left; i <= right; i++)\n{\n  if (dist(v[i], target) < b)\n  {\n    index = i;\n    printf(\"index = %d io sono %d \\n\", index, omp_get_thread_num());\n    b = dist(v[index], target);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francesc0rtu/Parallel-kd-tree/test/04-for/1"}
{"code": "for (int i = 0; i < nbthreads; ++i)\n{\n  result[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/reduce/1"}
{"code": "for (i = 0; i < (dimensionSize + 1); i++)\n{\n  AllWeights[myrank][i] = weights[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/7"}
{"code": "for (j = 1; j < (subprob_size - 1); j++)\n{\n  b[i][j] = 0.2 * ((((a[i][j] + rfrbuff[j]) + a[i + 1][j]) + a[i][j - 1]) + a[i][j + 1]);\n  if (fabs(b[i][j] - a[i][j]) > maxdiff)\n    maxdiff = fabs(b[i][j] - a[i][j]);\n\n}\n\n", "pragma": "omp parallel for reduction(max:maxdiff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/9"}
{"code": "for (j = 0; j < (*(nb_spqx + i)); j++)\n{\n  int x;\n  int y;\n  int p;\n  int iam2;\n  double sumBlock;\n  double tmp1;\n  double tmp2;\n  double tmp3;\n  double tmp4;\n  iam2 = omp_get_thread_num();\n  p = j / (z * v);\n  y = (j % (z * v)) / z;\n  x = (j % (z * v)) % z;\n  sumBlock = 0;\n  sumBlock = SummatoryBlock3D(x, y, p, z, v, w, matrixdata, divider);\n  for (int r = 0; r < NumQs; r++)\n    if (sumBlock != 0)\n  {\n    tmp1 = pow(sumBlock / totalsum, *(qval + r));\n    tmp2 = tmp1 / (*((spqxdvsn + r) + (i * NumQs)));\n    tmp3 = log(sumBlock / totalsum);\n    if (isnan(tmp2))\n      tmp2 = 0;\n\n    if (isnan(tmp3))\n      tmp3 = 0;\n\n    if (tmp2 > 0)\n      tmp4 = log(tmp2);\n    else\n      tmp4 = 0;\n\n    *((MiQxThrdvsNumQ_NN + r) + (iam2 * NumQs)) += tmp2 * tmp4;\n    *((MiQxThrdvsNumQ_MM + r) + (iam2 * NumQs)) += tmp2 * tmp3;\n  }\n\n\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/14"}
{"code": "for (j = i + 1; j <= n; j++)\n{\n  if (L[i] > L[j])\n  {\n    win[i] = win[i] + 1;\n  }\n  else\n  {\n    win[j] = win[j] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoCRCW/2"}
{"code": "for (i = 0; i < validationDataset->nOfPatterns; i++)\n{\n  validationDataset->inputs[i] = trainDataset->inputs[randomVector[i]];\n  validationDataset->outputs[i] = trainDataset->outputs[randomVector[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/32"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum += arr[i];\n  prefixArray[i + 1] = sum;\n}\n\n", "pragma": "#pragma omp for schedule(static)  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhavya2711/Prefix_Sum_OpenMP/prefixsum/0"}
{"code": "for (i = PosB - 1; i > relmaxpos[1]; --i)\n{\n  MaxA[MaxAcounter] = dash;\n  ++MaxAcounter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/7"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"Resp[%d] = %d\\n\", i, resp[i]);\n  aux += resp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/matrix/3"}
{"code": "for (int i = YlowerLimit; i <= YupperLimit; i++)\n{\n  for (int j = XlowerLimit; j <= XupperLimit; j++)\n  {\n    ans += rgb_image[i][j][color];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/boxFilterOpenMP/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  int plen = strlen(saved_key[index]);\n  unsigned char key[64];\n  unsigned char out[64];\n  if (cur_salt->type == 1)\n  {\n    SHA_CTX ctx;\n    if (plen < 20)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 20 - plen);\n    }\n    else\n      if (plen == 20)\n    {\n      memcpy(key, saved_key[index], 20);\n    }\n    else\n    {\n      SHA1_Init(&ctx);\n      SHA1_Update(&ctx, saved_key[index], plen);\n      SHA1_Final(key, &ctx);\n    }\n\n\n    hmac_sha1(key, 20, cur_salt->salt, cur_salt->salt_length + 20, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    SHA256_CTX ctx;\n    if (plen < SHA256_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, SHA256_DIGEST_LENGTH - plen);\n    }\n    else\n      if (plen == SHA256_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], SHA256_DIGEST_LENGTH);\n    }\n    else\n    {\n      SHA256_Init(&ctx);\n      SHA256_Update(&ctx, saved_key[index], plen);\n      SHA256_Final(key, &ctx);\n    }\n\n\n    hmac_sha256(key, 32, cur_salt->salt, cur_salt->salt_length + SHA256_DIGEST_LENGTH, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 3)\n  {\n    SHA512_CTX ctx;\n    if (plen < SHA384_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, SHA384_DIGEST_LENGTH - plen);\n    }\n    else\n      if (plen == SHA384_DIGEST_LENGTH)\n    {\n      memcpy(key, saved_key[index], SHA384_DIGEST_LENGTH);\n    }\n    else\n    {\n      SHA384_Init(&ctx);\n      SHA384_Update(&ctx, saved_key[index], plen);\n      SHA384_Final(key, &ctx);\n    }\n\n\n    hmac_sha384(key, 48, cur_salt->salt, cur_salt->salt_length + SHA384_DIGEST_LENGTH, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n  else\n    if (cur_salt->type == 4)\n  {\n    SHA512_CTX ctx;\n    if (plen < 64)\n    {\n      memcpy(key, saved_key[index], plen);\n      memset(key + plen, 0, 64 - plen);\n    }\n    else\n      if (plen == 64)\n    {\n      memcpy(key, saved_key[index], 64);\n    }\n    else\n    {\n      SHA512_Init(&ctx);\n      SHA512_Update(&ctx, saved_key[index], plen);\n      SHA512_Final(key, &ctx);\n    }\n\n\n    hmac_sha512(key, 64, cur_salt->salt, cur_salt->salt_length + 64, out, 16);\n    memcpy((unsigned char *) crypt_out[index], out, 16);\n  }\n\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ospf_fmt_plug/3"}
{"code": "for (int i = 0; i < N; i++)\n  graf[i] = (int *) malloc(N * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lydiaastrella/Parallel-Dijkstra-OpenMP/src/paralel_dijkstra/2"}
{"code": "for (int i = 0; i < (n * n); ++i)\n  *(C + i) = (*(A + i)) + (*(B + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/3"}
{"code": "for (i = 0; i < nl; i++)\n{\n  for (j = 0; j < nc; j++)\n  {\n    somme = 0;\n    for (k = 0; k < nl; k++)\n    {\n      somme += A[i][k] * B[k][j];\n    }\n\n    (*C)[i][j] = somme;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex7/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  free(unew[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/13"}
{"code": "for (i = 0; i < num_rows; ++i)\n{\n  getline(&str_srr2[i], &n, f);\n}\n\n", "pragma": "omp parallel for num_threads(n_thread) default(none), shared(num_rows, str_srr2, n, f)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/test/0"}
{"code": "for (c = 0; c < size; ++c)\n{\n  if (outgoing_reqs_active[c])\n  {\n    int flag;\n    MPI_Test(&outgoing_reqs[c], &flag, (MPI_Status *) 1);\n    if (flag)\n      outgoing_reqs_active[c] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_simple/3"}
{"code": "for (i = 0; i < 20; i++)\n  a[i] = (b[i] = 1.0 * i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/omp_orphan/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  result += w[i + 1] * (x[i] + (iddT * velp[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/15"}
{"code": "for (j = 0; j < m; j++)\n{\n  b[i][j] = i + j;\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB037-truedepseconddimension-orig-yes/1"}
{"code": "for (i = 1; i < (128 + 1); i++)\n{\n  for (j = 1; j < (128 + 1); j++)\n  {\n    data[(i * (128 + 1)) + j] -= mean[j];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/COVAR/covariance/13"}
{"code": "for (i = 0; i < Size; i++)\n{\n  Max = (Max > pArray[i]) ? (Max) : (pArray[i]);\n}\n\n", "pragma": "        #pragma omp for reduction(max : Max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Bonus Problems/P01/P01/2"}
{"code": "for (i = 0; i < 768; i++)\n{\n  for (j = 0; j < 768; j++)\n  {\n    printf(\"%f \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iakovts/openMP_set_2021_Tsouros/exe2/matmul_omp_tsouros/3"}
{"code": "for (unsigned int i = 0; i < number; i++)\n{\n  double norm;\n  if (pos[i][0] > (dr / 2))\n    norm = ((((2 * PI) * pos[i][0]) * dr) * dz) / v_avg;\n  else\n    norm = ((PI * (((pos[i][0] * pos[i][0]) + (pos[i][0] * dr)) + ((dr * dr) / 4))) * dz) / v_avg;\n\n  double n_per_macro = n_per_macro_avg * norm;\n  charge_array[i] = charge * n_per_macro;\n  mass_array[i] = mass * n_per_macro;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/bunch/1"}
{"code": "for (k = 0; k < ((sizej * numOfProcesses) / dimj); k++)\n{\n  for (i = 0; i < sizei; i++)\n  {\n    for (j = 0; j < dimj; j++)\n      printf(\"%c\", matrix[i][(k * dimj) + j]);\n\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/petros-ioannidis/parallel_CGOL/OPENMP_CGOL/graph_main_openmp/7"}
{"code": "for (int i = 1; i < s.length(); i++)\n{\n  int j = pi[i - 1];\n  while ((j > 0) && (s[i] != s[j]))\n  {\n    j = pi[j - 1];\n  }\n\n  if (s[i] == s[j])\n  {\n    pi[i] = j + 1;\n  }\n  else\n  {\n    pi[i] = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rudione/kmp_openmp/main/0"}
{"code": "for (sii = 0; sii < 10; sii++)\n  c[sii] = a[sii];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_teams_distribute_loop_messages/0"}
{"code": "for (int i = 0; i < n; ++i)\n  U[i] = (double *) malloc(n * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/21"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    printf(\"%f \", A[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/openmp/1"}
{"code": "for (int i = 0; i < mNumberOfThreads; i++)\n{\n  total_contacts = 0;\n  total_sum = 0;\n  neighbour_counter[i] = 0;\n  sum[i] = 0;\n  number_of_non_skin_particles[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/7"}
{"code": "for (int j = pow(2, l); j < max; j++)\n{\n  if ((j % 2) == 0)\n  {\n    descent->current[j] = descent->current[j / 2];\n  }\n  else\n  {\n    descent->current[j] = descent->current[j / 2] + climbing->current[j - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/1"}
{"code": "for (int i = 0; i < N_b; ++i)\n{\n  printf(\"%c\", seq_b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/3"}
{"code": "for (i = 0; i <= (grid_points[0] - 3); i++)\n{\n  i1 = i + 1;\n  i2 = i + 2;\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      fac1 = 1. / lhs[n + 2][i][j][k];\n      lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n      lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n      for (m = 0; m < 3; m++)\n      {\n        rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n      }\n\n      lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n      lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n      }\n\n      lhs[n + 1][i2][j][k] = lhs[n + 1][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 3][i][j][k]);\n      lhs[n + 2][i2][j][k] = lhs[n + 2][i2][j][k] - (lhs[n + 0][i2][j][k] * lhs[n + 4][i][j][k]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[m][i2][j][k] = rhs[m][i2][j][k] - (lhs[n + 0][i2][j][k] * rhs[m][i][j][k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/22"}
{"code": "for (size_t i = 0; i < n; ++i)\n  sum += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex7-imbalance-openmp/0"}
{"code": "for (i = 0, x = 1; i < Size; ++i, ++x)\n{\n  k = 0;\n  for (j = 0; j < Size; ++j)\n  {\n    n = puzzle[(j * Size) + i];\n    if ((((n == x) || (n == (x + Size))) || (n == (x + (Size * 2)))) || (n == (x + (Size * 3))))\n    {\n      temp[k++] = n;\n    }\n\n  }\n\n  md = GetDistance(temp, md, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohadesehjm/Multicore-Npuzzle/15p/6"}
{"code": "for (i = 0; i < N; i++)\n  if (a[i] != b[i])\n{\n  rc++;\n  printf(\"Wrong varlue: a[%d]=%d\\n\", i, a[i]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/requires_directive/requires_directive/0"}
{"code": "for (i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(x) reduction (+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deborasetton/cpar-openmp-mpi-examples/openmp/pi_omp_v3_reduction/0"}
{"code": "for (i = 0; i < 20; i++)\n  cs.HASHKEY[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/nukedclan_fmt_plug/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double xval = i * dx;\n  double h = sqrt(1 - pow(xval, 2));\n  sum += h * dx;\n}\n\n", "pragma": "omp parallel for num_threads(nthreads) reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-7-openmp/omp-pi/0"}
{"code": "for (i = 0; i < num_buckets; ++i)\n{\n  Access_percentage = 100 * ((float) (thresholds_totalAccesses[i] / ((float) thresholds_totalAccess)));\n  Count_percentage = 100 * ((float) (thresholds_count[i] / ((float) num_vertices)));\n  printf(\"| %-15lu , %-15.2f , %-15lu , %-15.2f , %-15.2f , %-15.2f , %-15.2f , %-15.2f |\\n\", thresholds[i], Count_percentage, thresholds_totalAccesses[i], Access_percentage, thresholds_avgDegrees[i], thresholds_avgReuses[i], thresholds_avgReuses_region[i], thresholds_avgMisses[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/49"}
{"code": "for (;;)\n{\n  mpz_powm_ui(y, q, 2, p);\n  mpz_mul(y, y, n_inv);\n  mpz_mod(y, y, p);\n  i = 0;\n  while (mpz_cmp_ui(y, 1) != 0)\n  {\n    i++;\n    mpz_powm_ui(y, y, 2, p);\n  }\n\n  if (i == 0)\n  {\n    return 1;\n  }\n\n  if ((s - i) == 1)\n  {\n    mpz_mul(q, q, w);\n  }\n  else\n  {\n    mpz_powm_ui(y, w, 1 << ((s - i) - 1), p);\n    mpz_mul(q, q, y);\n  }\n\n  mpz_mod(q, q, p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_gmp/0"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  Res[RowIdx] = Mat->At(RowIdx, ColIdx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/112"}
{"code": "for (int i = 1; i < (((int) iters.size()) - 1); i++)\n{\n  out += (((((((((\"const int \" + iter_i(i)) + \" = (\") + temp_var) + \" -= \") + iter_i(i - 1)) + \"*_N\") + N_strs[i]) + \")/_N\") + N_strs[i + 1]) + \";\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/einsxiao/evawiz/evawiz/src/evacc/syntax_launch_kernel/9"}
{"code": "for (unsigned ck = 0; ck < Nkeys; ck++)\n{\n  if (makeindex)\n  {\n    SortStepIndex(ck, PrevData32, Data32, PrevIndex, Index);\n    swap(PrevIndex, Index);\n  }\n  else\n    SortStep(ck, PrevData32, Data32);\n\n  swap(PrevData32, Data32);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/12"}
{"code": "for (int dest = 0; dest < new_no; ++dest)\n{\n  int src = code_map[dest];\n  const double *src_data = (src >= 0) ? (old_wf[src]) : (means.data());\n  memcpy(wf_[dest], src_data, ni * (sizeof(*src_data)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/0"}
{"code": "for (j = 0; j < 8192; j++)\n  for (i = 0; i < 8192; i++)\n{\n  {\n    y[j] = y[j] + (A[(i * 8192) + j] * tmp[i]);\n  }\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Polybench/ATAX/src/atax/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  pops[i] = rand() % 256;\n  totalPop += pops[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/5"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  h_c[i] = h_a[i] + h_b[i];\n}\n\n", "pragma": "omp parallel for num_threads (4) schedule (dynamic, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/vectoradd-multiple-omp-parallel-for-combined-schedule-dynamic-chunk-value/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    s = 0;\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[j][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/chunk/0"}
{"code": "for (i = 0; i < nd; i++)\n{\n  x1[i] = (alpha * x1[i]) + teleport;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/girihemant19/Pagerank-serial-C-and-parallel-openMp-/pagerank_openMp/8"}
{"code": "for (i = 0; i < simu_opts->numOE; i++)\n{\n  fscanf(fcfg, \"%lf\", &simu_opts->OEFD[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/43"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar18 = 0; m_imopVar18 < 5; m_imopVar18++)\n    {\n      rhs[i][j][k][m_imopVar18] = rhs[i][j][k][m_imopVar18] - (dssp * (((u[i - 2][j][k][m_imopVar18] - (4.0 * u[i - 1][j][k][m_imopVar18])) + (6.0 * u[i][j][k][m_imopVar18])) - (4.0 * u[i + 1][j][k][m_imopVar18])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/BT/bt-long/18"}
{"code": "for (j = 0; j < nc; j++)\n{\n  for (i = 0; i < nr; i++)\n  {\n    y[i + (j * n)] += a[j * n] * x[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    mat1[i][j] = ((rand() % 50) + (rand() % 40)) % 20;\n    printf(\"%d\\t\", mat1[i][j]);\n    if (j == (n - 1))\n      printf(\"\\n\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohit-gupta3/Parallel_and_DistributiveComputing-PDC-/Matrix_Operations/Matrix_Multiplication_OpenMp/1"}
{"code": "for (i = 0; i < 1200; i++)\n{\n  for (j = 0; j < 1200; j++)\n  {\n    C[(i * 1200) + j] *= 4546;\n    for (k = 0; k < 1200; k++)\n    {\n      C[(i * 1200) + j] += ((12435 * A[(i * 1200) + k]) * B[(j * 1200) + k]) + ((12435 * B[(i * 1200) + k]) * A[(j * 1200) + k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/Polybench/base/omp/SYR2K/syr2k/10"}
{"code": "for (int i = 0; i < CLUSTER_NUM; i++)\n{\n  clusters[i][1] = 0;\n  clusters[i][2] = 0;\n  clusters[i][3] = 0;\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(clusters) num_threads(NUM_THREAD)     ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Raydar32/cKmeans/OpenMP_source/main/1"}
{"code": "for (i = 4; i >= 0; i--)\n{\n  for (j = 4; j >= 0; j--)\n  {\n    result_3[i][j] = (i * 10) + j;\n    printf(\"%d, %d\\n\", i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/tests/openmp/unit/for_decrement/2"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  Y[i * incY] = (alpha * X[i * incX]) + Y[i * incY];\n  Y[(i + 1) * incY] = (alpha * X[(i + 1) * incX]) + Y[(i + 1) * incY];\n  Y[(i + 2) * incY] = (alpha * X[(i + 2) * incX]) + Y[(i + 2) * incY];\n  Y[(i + 3) * incY] = (alpha * X[(i + 3) * incX]) + Y[(i + 3) * incY];\n}\n\n", "pragma": "omp parallel for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/axpy/1"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  best_of_each_thread[i].score = -5000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saloelia/Parallel-Sequence-Aligment/calculation/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < 1100; j++)\n  {\n    flip_spin(spins, neighs, h, energy, gen, ran_u, ran_pos);\n  }\n\n  sum = abs(magnetization(spins));\n  chi = sum * sum;\n  heat = energy * energy;\n  m[MAG] += sum;\n  m[MAG2] += chi;\n  m[MAG4] += chi * chi;\n  m[ENE] += energy;\n  m[ENE2] += heat;\n  m[ENE4] += heat * heat;\n  m[MAGERR] += old_sum * sum;\n  m[SUSERR] += old_chi * chi;\n  m[ENERR] += old_energy * energy;\n  m[CHERR] += old_heat * heat;\n  old_sum = sum;\n  old_energy = energy;\n  old_chi = chi;\n  old_heat = heat;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/8"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/4"}
{"code": "for (int i = 0; i < 26; ++i)\n{\n  alphabets[i] = c;\n  ++c;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Napier-JP/LearnC/C++/threads_count/0"}
{"code": "for (int i = 0; i < amount; i++)\n{\n  Point *p = points + i;\n  sum_x += p->axis_location.x;\n  sum_y += p->axis_location.y;\n  sum_z += p->axis_location.z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/assaft753/Parallel-K-Means/Parallel/Main/13"}
{"code": "for (i = 0; i < omp_get_max_threads(); ++i)\n{\n  result += res;\n}\n\n", "pragma": "omp for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_ompss.dg/c/success_task_16/0"}
{"code": "for (int t = 0; t < TIMER_NTIMERS; ++t)\n{\n  printf(\"%.3f\\t\", (TIMES[t] / NUM_PES) * 1000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/20"}
{"code": "for (size_t j = cIdx; j < cLen; j += 2)\n  simdMergeUnit(block, start, end, j, cIdx, selector);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/22"}
{"code": "for (n = 1; n < N; n++)\n{\n  A_min = INFINITY;\n  A_max = 0;\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    buffer = log_add(A0[rsctrellis.prevStates[k] + ((n - 1) * rsctrellis.numStates)], A1[rsctrellis.prevStates[k + rsctrellis.numStates] + ((n - 1) * rsctrellis.numStates)]);\n    A0[k + (rsctrellis.numStates * n)] = (Lc2I[n] * rsctrellis.PARout[k]) + buffer;\n    A1[k + (rsctrellis.numStates * n)] = ((Lc1I[n] + apriori_data[n]) + (Lc2I[n] * rsctrellis.PARout[k + rsctrellis.numStates])) + buffer;\n    A_min = min(A_min, A0[k + (rsctrellis.numStates * n)]);\n    A_max = max(A_max, A0[k + (rsctrellis.numStates * n)]);\n  }\n\n  A_mid[n] = (A_min + A_max) / 2;\n  if (isinf(A_mid[n]))\n  {\n    continue;\n  }\n\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    A0[k + (rsctrellis.numStates * n)] -= A_mid[n];\n    A1[k + (rsctrellis.numStates * n)] -= A_mid[n];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[nx - 3][j][k][m] = frct[nx - 3][j][k][m] - (dsspm * (((rsd[nx - 5][j][k][m] - (4.0 * rsd[nx - 4][j][k][m])) + (6.0 * rsd[nx - 3][j][k][m])) - (4.0 * rsd[nx - 2][j][k][m])));\n  frct[nx - 2][j][k][m] = frct[nx - 2][j][k][m] - (dsspm * ((rsd[nx - 4][j][k][m] - (4.0 * rsd[nx - 3][j][k][m])) + (5.0 * rsd[nx - 2][j][k][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dsspm)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/29"}
{"code": "for (i = 0; i < (len * threads); i++)\n{\n  sum += a[i] * b[i];\n  psum = sum;\n}\n\n", "pragma": "#pragma omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vlkale/lw-sched/share/ukernels/dotProd/1"}
{"code": "for (int i = 0; i < n; i++)\n  array[i] = drand48();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShihengJiang666/ThreadParallelism/dotp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  fscanf(fp1, \"%lf\", &point[0][i]);\n  fscanf(fp1, \"%lf\", &point[1][i]);\n  fscanf(fp1, \"%lf\", &point[2][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/core/io/read/0"}
{"code": "for (int i = 0; i < image_dim_y; i++)\n  for (int j = 0; j < image_dim_x; j++)\n  output_image(i, j) += total;\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/24"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"iteration %d\\n\", i);\n  printf(\"Bienvenue le monde depuis le thread numero %d\\n\", omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_1_1/TP_OPENMP_01/0"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  integers[i] = rnd->getInteger(512);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dgquintas/libmpplas/src/sources/tests/units/OpenMPTest/0"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  theta3[i] = (out3[i] * (1 - out3[i])) * (expected[i] - out3[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/9"}
{"code": "for (i = 0; i < k; i++)\n{\n  a[i] = ((float) rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/vector_add/1"}
{"code": "for (int i = 0; i < COLS; i++)\n{\n  minMaxNormalization(i, array, normalizedArray);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(NUM_THREADS) shared(normalizedArray)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michal-dom/knn_with_openMP/main/0"}
{"code": "for (int i = 2; i <= n; i++)\n{\n  if (primes[i] == 0)\n  {\n    continue;\n  }\n\n  fprintf(fp, \"%d %d\\n\", order, i);\n  order += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dizys/nyu-multicore-lab-2/genprime/2"}
{"code": "for (i = 1; i < nthreads; i++)\n  partial_new_centers[i] = partial_new_centers[i - 1] + nclusters;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_kmeans_openmp/kmeans_clustering/8"}
{"code": "for (int j = 0; j < width; ++j)\n{\n  out.emplace_back();\n  out[j].reserve(height);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muji-4ok/pixel-sort-qt5/sorter/4"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n  cell(ci).verletVelocityUpdate(dt);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/48"}
{"code": "for (int i = 0; i < DistTables.size(); i++)\n  DistTables[i]->evaluate(*this);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/16"}
{"code": "for (int i = 1; i < k; i++)\n{\n  displ[i] = displ[i - 1] + recv_counts[i - 1];\n  sum += recv_counts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ManaswitaDatta/Convex-Hull-Using-K-Means-Clustering-in-Hybrid-MPI-OpenMP-Environment/hybrid/pc/0"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/1/shared-clause/1"}
{"code": "for (long i = 0; i < NUM_SLICES; i++)\n{\n  B[i] = big_calc2(C, i);\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DF4IAH/OpenMP/Ex4_2_barrier_wait-nowait/1"}
{"code": "for (i = 0; i < (num_particles / 512); ++i)\n{\n  int j;\n  for (j = 0; j < 512; j++)\n  {\n    forces[i].x[j] = 0;\n    forces[i].y[j] = 0;\n    forces[i].z[j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_39_nbody/5"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  row[i] = this->mat_.row[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/3"}
{"code": "for (v = 0; v < 256; v++)\n{\n  if (hist_R[v] > 0)\n  {\n    for (k = v; k < 256; k++)\n      cdf_R[k] += hist_R[v];\n\n  }\n\n  if (hist_G[v] > 0)\n  {\n    for (k = v; k < 256; k++)\n      cdf_G[k] += hist_G[v];\n\n  }\n\n  if (hist_B[v] > 0)\n  {\n    for (k = v; k < 256; k++)\n      cdf_B[k] += hist_B[v];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/minyaho/Histogram-Equalization-by-OpenMP-and-OpenCL/code_files/code_file/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  b[i] = 0;\n  for (int j = 0; j < N; ++j)\n    b[i] += A[(i * N) + j] * true_x[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elyaishere/sk_high_performance_computing/openmp/Axisb/4"}
{"code": "for (j = Jmin; j <= Jmax; j++)\n{\n  for (i = Imin; i <= Imax; i++)\n  {\n    ftmp = ((float) Node(idx(j, i), iTime)) / 60;\n    fwrite(&ftmp, sizeof(float), 1, fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/23"}
{"code": "for (nx = 0; nx < n; nx++)\n{\n  for (ny = 0; ny < n; ny += 2)\n  {\n    int x = _mm_load_pd(zero_v);\n    _mm_store_pd(&fx[(nx * n) + ny], x);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abu-abraham/open-MP/examples/Cloth Simulation/kernel_main_omp/10"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/116"}
{"code": "for (i = 1; i < ((int) n); i++)\n  sum += 2.0 * func(from + (i * h));\n\n", "pragma": "omp parallel for reduction(+:sum) shared(h,i)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Trapezium/0"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int k = 0; k < nzn; k++)\n{\n  Bxn[i][nyn - 1][k] = B0x * tanh((grid->getYC(i, nyc - 1, k) - (Ly / 2)) / delta);\n  Bxn[i][nyn - 2][k] = Bxn[i][nyn - 1][k];\n  Bxn[i][nyn - 3][k] = Bxn[i][nyn - 1][k];\n  Byn[i][nyn - 1][k] = B0y;\n  Bzn[i][nyn - 1][k] = B0z;\n  Bzn[i][nyn - 2][k] = B0z;\n  Bzn[i][nyn - 3][k] = B0z;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/30"}
{"code": "for (i = 0; i < threadNumber; i++)\n{\n  total += pStrips[i].UpdatePotentialSpillandPushToPQ_OtherTimes(pStrips);\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction (+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallelfilling/openmp/parallel_priorityflooding/4"}
{"code": "for (int i = 0; i < (n + 2); ++i)\n{\n  for (int j = 0; j < (n + 2); ++j)\n  {\n    if ((((i <= n) & (j <= n)) & (i > 0)) & (j > 0))\n    {\n      if ((((i == 1) | (i == n)) | (j == 1)) | (j == n))\n      {\n        input_temp[i][j] = 100;\n        output_temp[i][j] = 100;\n      }\n      else\n      {\n        input_temp[i][j] = -100;\n        output_temp[i][j] = -100;\n      }\n\n    }\n    else\n    {\n      input_temp[i][j] = 0;\n      output_temp[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jinjiel1994/CIS431-LabAssignment3/omp_heat_equation_solver/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  double a;\n  double b;\n  (fin >> a) >> b;\n  points.push_back(make_pair(a, b));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanRadulescu962/ProjectAPP/OpenMP/tema/0"}
{"code": "for (i = 0; i < yres; i++)\n{\n  y_array[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EvanSkeete/ParallelJulia/julia_omp/3"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n    {\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n    }\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = strtof(head, &tail);\n    if (tail == head)\n    {\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n    }\n\n    if (mat->rsizes[i] < 0)\n    {\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = strtof(head, &tail);\n      if (tail == head)\n      {\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n      }\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n      {\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n    {\n      break;\n    }\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n    {\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n    }\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = strtof(head, &tail);\n      if (tail == head)\n      {\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n      }\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/29"}
{"code": "for (i = 0; i < 10; i++)\n{\n  {\n  }\n}\n\n", "pragma": "omp cancel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/cancel-1/2"}
{"code": "for (int x = 0; x < mask->size; x++)\n{\n  free(mask->values[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vdrg/openmp-image-masking/src/masker/3"}
{"code": "for (i = 0; i < size; ++i)\n{\n  sum += arr[i];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum) shared(arr) default(none)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zsxoff/course-parallel-programming/task-2/src/omp/0"}
{"code": "for (i = 0; i < n; i++)\n  mat[i] = (float *) malloc(n * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/priyanka2802/ParallelLUFactorization/RBParLU/3"}
{"code": "for (int f = 0; f < feat4; f++)\n{\n  for (int i = 0; i < feat3; i++)\n  {\n    for (int j = 0; j < 3; j++)\n    {\n      for (int k = 0; k < 3; k++)\n      {\n        kernel41[f][i][j][k] = distr(gen);\n        kernel42[f][i][j][k] = distr(gen);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"thread %d ejecuta la iteraci\u00f3n %d del bucle\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica1/bucle-for/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] = (a * x[i]) + y[i];\n}\n\n", "pragma": "omp parallel for simd schedule(simd:static) default(none) shared(a, n, x, y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/saxpy-ompt-cuda/hsaxpy/0"}
{"code": "for (i = 0; i < 3; i++)\n  fprintf(fp, \" %10.8f\", TIS_surface_roughness_center_FOV[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  result = result + (a[i] * b[i]);\n  printf(\"iteration number %d\\n\", i);\n  printf(\"result = %f\\t tid=%d\\t\", result, omp_get_thread_num());\n  printf(\" a[i] = %f\\t\", a[i]);\n  printf(\"b[i]= %f\\n\\n\", b[i]);\n}\n\n", "pragma": "omp parallel for default(shared) schedule(static,chunk) reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/shared/0"}
{"code": "for (i2 = 0; i2 < n2; i2++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    u[0][i2][i1] = u[n3 - 2][i2][i1];\n    u[n3 - 1][i2][i1] = u[1][i2][i1];\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/2"}
{"code": "for (i = 1; i <= N; i++)\n{\n  roots[i] = sqrt(i * scale);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/practicas/p3/e2/paralelo-modificado/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  result += v1[i] * v2[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dross0/Parallel-Programming-Labs/Lab2/var1/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  free(buckets[i].elems);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg1/9"}
{"code": "for (int n = 0; n < V; n++)\n  c.route[n] = '0';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize_tsp_ga/2"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  for (int j = 0; j < 1000; j++)\n  {\n    C[(i * 1000) + j] = 0.0;\n    for (int k = 0; k < 1000; ++k)\n    {\n      C[(i * 1000) + j] += A[(i * 1000) + k] * B[(k * 1000) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  temp = 0;\n  for (int j = size - 1; j > i; j--)\n    if (Arr[(size * i) + j] != 0)\n  {\n    temp = j - i;\n    break;\n  }\n  else\n    continue;\n\n\n  if (temp > high)\n    high = temp;\n\n  temp = 0;\n  for (int j = 0; j < i; j++)\n    if (Arr[(size * i) + j] != 0)\n  {\n    temp = i - j;\n    break;\n  }\n  else\n    continue;\n\n\n  if (temp > low)\n    low = temp;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/12"}
{"code": "for (i = 0; i < b_r; i++)\n{\n  for (j = 0; j < b_c; j++)\n  {\n    printf(\"B[%d][%d]\", i, j);\n    scanf(\"%d\", &b[i][j]);\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejaswiParuchuri/ParalleProcessing/addmp/2"}
{"code": "for (uint64_t i = size - (size % 8); i < size; i++)\n{\n  hist[(data1[i] << 8) + data2[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JeanOlivier/Histograms-OTF/histograms/13"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j += 1)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k += 1)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  r[j] = d;\n}\n\n", "pragma": "omp parallel for private (d,j,k) firstprivate (firstrow,lastrow)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/12"}
{"code": "for (int i = 0; i < w; i++)\n{\n  for (int j = 0; j < h; j++)\n  {\n    d[i][j] = (rand() % 90) + 10;\n    printf(\"%d \", d[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Karantir73/OpenMP-lab/task10/0"}
{"code": "for (;;)\n{\n  XEvent e;\n  XNextEvent(display, &e);\n  if (e.type == MapNotify)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leo-ventura/parallel-computing-openmp/src/mandel_omp_x_dynamic_256/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    matvec_sub(lhs[i][j][k][0], rhs[i - 1][j][k], rhs[i][j][k]);\n    matmul_sub(lhs[i][j][k][0], lhs[i - 1][j][k][2], lhs[i][j][k][1]);\n    binvcrhs(lhs[i][j][k][1], lhs[i][j][k][2], rhs[i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for private ( k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/8"}
{"code": "for (int i = 0; i < qseq_size; i++)\n  query_sequence[i] = seq[rand() % 4];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ga-omp/main/2"}
