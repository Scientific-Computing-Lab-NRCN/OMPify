{"code": "for (i = 0; i < 100000; i++)\n{\n  for (j = 0; j < 100000; j++)\n  {\n    if ((arr[j] > arr[i]) || ((arr[j] == arr[i]) && (j < i)))\n    {\n      rank[i]++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tebesfinwo/CISC-4335-OpenMP-Rank-Sort-/Parallel Rank Sort/main/0"}
{"code": "for (int i = 0; i < number_of_processes; i++)\n{\n  recvcounts[i] /= M;\n  displs[i] /= M;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Hybrid/mxvnm_OMPI/5"}
{"code": "for (int c = 1 + low; c <= high; c++)\n{\n  d = c;\n  while ((d > low) && (array[d - 1] > array[d]))\n  {\n    t = array[d];\n    array[d] = array[d - 1];\n    array[d - 1] = t;\n    d--;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SayaliThorat17/TimSort-Algorithm-Using-OpenMP/timsort/1"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  for (subcycle = 0; subcycle < 10; subcycle++)\n  {\n    partArray[0]->update_count = 1;\n    partArray[0]->firstZone->value = calc_deposit();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/7"}
{"code": "for (int i = 0; i < HEIGHT; ++i)\n{\n  free(field_backup[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task7/main/11"}
{"code": "for (int row = 0; row < numOfPoints; row++)\n{\n  for (int col = 0; col < weightsVectorSize; col++)\n  {\n    points_1d[(row * weightsVectorSize) + col] = points[row][col];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SagivAsraf/Parallel-implementation-of-Binary-Classification/MainApp/4"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 3; j++)\n{\n  A[i][j] = 2;\n  B[i][j] = 2;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/product of 2 matrix/1"}
{"code": "for (int i = 0; i < w; i++)\n{\n  for (int j = 0; j < h; j++)\n  {\n    map[i][j] = stats[i][j];\n    if (map[i][j] == 1)\n    {\n      image.setPixel(i, j, Blue);\n    }\n    else\n    {\n      image.setPixel(i, j, Black);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SamaiMed/Cellular-Automata-SFML-OpenMP/ConsoleApplication/textures/2"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if ((m_frgmax[i] > 0.f) && (m_vpdfr[i] > 0.f))\n  {\n    m_vpd2[i] = (1.f - m_frgmax[i]) / (m_vpdfr[i] - 1.f);\n  }\n  else\n  {\n    m_vpd2[i] = 0.f;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/PET_PM/PETPenmanMonteith/0"}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw(A * pow(rho, x), parm);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/PIC/pic/3"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n  status[i] = distances[i];\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/karta134033/OpenMP_programming/part2/breadth_first_search/bfs/2"}
{"code": "for (int j = 0; j < 2; ++j)\n{\n  start = currentSeconds();\n  for (int i = 0; i < 10000; ++i)\n  {\n    updatePhysics(i * 100);\n  }\n\n  end = currentSeconds();\n  minParallel = min(minParallel, end - start);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rpandya1990/Parallel-N-Body-Problem/openMp/n_body_omp/1"}
{"code": "for (int i = 0; i < c; i++)\n{\n  histogram[i] = 0;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlosColnaghi/openmp/openmp/1"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  timeStart = omp_get_wtime();\n  PiParallelForReductor();\n  timeEnd = omp_get_wtime();\n  time += timeEnd - timeStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/pi/7"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < dim2; k++)\n    {\n      for (l = 0; l < dim3; l++)\n      {\n        long long rand = random();\n        int reduced_range = rand % range;\n        result[i][j][k][l] = reduced_range + bias;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/3"}
{"code": "for (i = 0; i < public.in_mod_elem; i++)\n{\n  in_final_sum = in_final_sum + d_in[i];\n}\n\n", "pragma": "omp parallel for reduction(+: in_final_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/0"}
{"code": "for (i = 0; i < num_ph; i++)\n{\n  if ((ph + i)->weight != 0)\n  {\n    p0[count] = (ph + i)->p0;\n    p1[count] = (ph + i)->p1;\n    p2[count] = (ph + i)->p2;\n    p3[count] = (ph + i)->p3;\n    r0[count] = (ph + i)->r0;\n    r1[count] = (ph + i)->r1;\n    r2[count] = (ph + i)->r2;\n    {\n      comv_p0[count] = (ph + i)->comv_p0;\n      comv_p1[count] = (ph + i)->comv_p1;\n      comv_p2[count] = (ph + i)->comv_p2;\n      comv_p3[count] = (ph + i)->comv_p3;\n    }\n    {\n      s0[count] = (ph + i)->s0;\n      s1[count] = (ph + i)->s1;\n      s2[count] = (ph + i)->s2;\n      s3[count] = (ph + i)->s3;\n    }\n    num_scatt[count] = (ph + i)->num_scatt;\n    weight[count] = (ph + i)->weight;\n    if (frame == frame_last)\n    {\n      global_weight[count] = (ph + i)->weight;\n    }\n\n    *(ph_type + count) = (ph + i)->type;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mcrat_io/1"}
{"code": "for (int u = 0; u < (W - 1); u++)\n{\n  ch_image[0 + u] = BLACKPIXEL;\n  ch_image[((H - 1) * W) + u] = BLACKPIXEL;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filipe3x/esqueletizacao_openmp/skeletonize/5"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/66"}
{"code": "for (i = 0; i < count; i++)\n{\n  if (strcmp(G1, topoinfo->Gname[i]) == 0)\n  {\n    matchnum = matchnum + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/17"}
{"code": "for (int i = 0; i < scalar_mom_len; ++i)\n{\n  scalar_mom[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/8"}
{"code": "for (l = 0; l < nz; l++)\n{\n  ll = nxye3 * l;\n  for (k = 0; k < ny; k++)\n  {\n    for (j = 0; j < nx; j++)\n    {\n      for (i = 0; i < 3; i++)\n      {\n        dcu[(i + (3 * (j + (nxe * k)))) + ll] -= q2m0 * cus[(i + (3 * (j + (nxe * k)))) + ll];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/2"}
{"code": "for (int i = 0; i < 64; i++)\n{\n  (is1 >> key) >> value;\n  m1[key] = value;\n  (is2 >> key) >> value2;\n  m2[key] = value2;\n  (is3 >> key) >> value;\n  m3[key] = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/be320/OpenMP-DNA-Translator/DNA-Transaltor/DNA-Transaltor/DNA-Transaltor/0"}
{"code": "for (int i = 0; i < l; i++)\n{\n  printf(\"%d \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/massiv/task/2"}
{"code": "for (p = 0; p < length; p++)\n{\n  atom = startAtom + p;\n  atomC = currentCoords.Get(atom);\n  currentAxes.UnwrapPBC(atomC, box, comC);\n  diffC = atomC - comC;\n  thisBoxCoords.Set(atomIndex, atomC);\n  thisBoxCOMDiff.Set(atomIndex, diffC);\n  chargeBox.push_back(particleCharge[atom] * lambdaCoef);\n  atomIndex++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/23"}
{"code": "for (n = 0; n < N; ++n)\n{\n  fprintf(f, \"%f \", x[n]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erhnam/Transformada-Discreta-de-Fourier/dft_OpenMp/3"}
{"code": "for (int I = 0; I < Dimension; I++)\n{\n  double Sum = 0;\n  for (int J = 0; J < Dimension; J++)\n  {\n    if (I != J)\n    {\n      A[(I * Dimension) + J] = (rand() % 18) - 9;\n      Sum += this->Absolute(A[(I * Dimension) + J]);\n    }\n\n  }\n\n  int sign;\n  if (rand() > 16000)\n    sign = 1;\n  else\n    sign = -1;\n\n  A[(I * Dimension) + I] = (Sum * ((rand() / 32767.0) + 1)) * sign;\n  B[I] = (rand() % 18) - 9;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Parallel-Programming/Jacobi_openMP/EquationsLinearSystem/0"}
{"code": "for (k = 0; k < (m * n); k++)\n{\n  c[k] = r8_uniform_01(&seed);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_host/mxm/2"}
{"code": "for (int ip = 0; ip < nthreads; ip++)\n  (o << setw(12)) << myprimes[ip];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/OhmmsApp/RandomNumberControl/2"}
{"code": "for (int i = k1; i < k2; i++)\n{\n  if (is_center[i])\n  {\n    center_table[i] = count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/9"}
{"code": "for (i = 0; i < dim0; i++)\n{\n  printf(\"Outer dimension number %d\\n\", i);\n  for (j = 0; j < dim1; j++)\n  {\n    for (k = 0; k < (dim2 - 1); k++)\n    {\n      printf(\"%d, \", a[i][j][k]);\n    }\n\n    printf(\"%f\\n\", a[i][j][dim2 - 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/1"}
{"code": "for (int i = 0; i < len; i++)\n{\n  vector[i] = rand() & 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/17"}
{"code": "for (i = 20; i <= max; i += 20)\n{\n  reset(matrix, i, seed);\n  stime = serial(matrix, i);\n  reset(matrix, i, seed);\n  mptime = mp(matrix, i, max_procs);\n  fprintf(plot, \"%d %lf\\n\", i, stime / mptime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/2"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  cudaStatus = cudaMalloc(&coordsCluster, allClusters[i].virutalCenter.dimensions * (sizeof(double)));\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaClusters);\n  cudaStatus = cudaMemcpy(coordsCluster, allClusters[i].virutalCenter.coordinates, allClusters[i].virutalCenter.dimensions * (sizeof(double)), cudaMemcpyHostToDevice);\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaClusters);\n  cudaStatus = cudaMemcpy(&cudaClusters[i].virutalCenter.coordinates, &coordsCluster, sizeof(double *), cudaMemcpyHostToDevice);\n  handleErrors(cudaStatus, \"cudaMalloc failed!\", cudaClusters);\n}\n\n", "pragma": "#pragma omp parallel for private(coordsCluster)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/17"}
{"code": "for (size_t i = 0; i < 10; i++)\n{\n  pourcentage = (((double) (non_optim_exec_time - methods[i].exec_time)) / ((double) non_optim_exec_time)) * 100;\n  printf(\"| %40s | %10f | %11.2f |\\n\", methods[i].name, methods[i].exec_time, pourcentage);\n  for (size_t j = 0; j < 71; j++)\n  {\n    printf(\"-\");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AYaddaden/matrix-multiplication/main/15"}
{"code": "for (i = 0; i < n; i++)\n{\n  C[i] = (double *) malloc((sizeof(double)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aman-1701/Tiled_Matrix_Multiplication_OpenMP/TiledMatrixMultiplication/4"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  printf(\"\\r> Progress: %.2f%%\", (100 * (i + 1)) / ((float) 10000));\n  for (int j = i + 1; j < 10000; j++)\n  {\n    double temp = Distance(i, j);\n    double temp_to_mBETA = pow(temp, -2.00);\n    CalculatedDistances_to_mBETA[i][j] = temp_to_mBETA;\n    CalculatedDistances_to_mBETA[j][i] = temp_to_mBETA;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_ant05/8"}
{"code": "for (int i = 0; i < V; i++)\n  dist[i] = 2147483647, sptSet[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/2"}
{"code": "for (unsigned short i = 0; i < dim; i++)\n{\n  row[i] = nnzAssigned;\n  for (unsigned short j = 0; j < dim; j++)\n  {\n    int numEntriesLeft = (dim * dim) - ((i * dim) + j);\n    int needToAssign = n - nnzAssigned;\n    if (numEntriesLeft <= needToAssign)\n    {\n      fillRemaining = true;\n    }\n\n    if (((nnzAssigned < n) && (drand48() <= prob)) || fillRemaining)\n    {\n      col[nnzAssigned] = j;\n      data[nnzAssigned] = 1;\n      nnzAssigned++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JanetLau0310/Parallel_computing/OpenMP/SpMV/h5/0"}
{"code": "for (k = 0; k < d3; k++)\n{\n  for (ii = 0; ii <= (d1 - FFTBLOCK); ii += FFTBLOCK)\n  {\n    for (j = 0; j < d2; j++)\n    {\n      for (i = 0; i < FFTBLOCK; i++)\n      {\n        y1[j][i] = x[k][j][i + ii];\n      }\n\n    }\n\n    cfftz(is, logd2, d2, y1, y2);\n    for (j = 0; j < d2; j++)\n    {\n      for (i = 0; i < FFTBLOCK; i++)\n      {\n        xout[k][j][i + ii] = y1[j][i];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  x *= x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/breyerml/OpenMP_Offloading_to_SYCL_mwe/hodgkin_huxley_1952_gpu_fast_monodomain.0/0"}
{"code": "for (int i = 0; i < 10; ++i)\n  rand();\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BloodyRainRage/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  printf(\"%d \", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/13"}
{"code": "for (int i = 0; i < numberOfThreadsOnPhi; ++i)\n{\n  InitImage(outputImagesPhi + i, height, width);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/5"}
{"code": "for (size_t i = 0; i < AllBoids.size(); i++)\n{\n  AllBoids[i].SenseAndPlan(omp_get_thread_num(), AllFlocks);\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/2"}
{"code": "for (int i = 0; i < 30000000; ++i)\n{\n  x.push_back(rand() % 20000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jonahkall/JBParallel/ptest/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  v[i] = ((i % 2) == 0) ? (up--) : (down++);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/omp-odd-even/2"}
{"code": "for (int i = 1; i < (this->nrow_ - idx); ++i)\n{\n  cast_vec->vec_[i] *= aii;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dz1tz1 * ((u[0][i][j][k + 1] - (2.0 * u[0][i][j][k])) + u[0][i][j][k - 1]))) - (tz2 * (u[3][i][j][k + 1] - u[3][i][j][k - 1]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dz2tz1 * ((u[1][i][j][k + 1] - (2.0 * u[1][i][j][k])) + u[1][i][j][k - 1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[1][i][j][k + 1] * wp1) - (u[1][i][j][k - 1] * wm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dz3tz1 * ((u[2][i][j][k + 1] - (2.0 * u[2][i][j][k])) + u[2][i][j][k - 1]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[2][i][j][k + 1] * wp1) - (u[2][i][j][k - 1] * wm1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dz4tz1 * ((u[3][i][j][k + 1] - (2.0 * u[3][i][j][k])) + u[3][i][j][k - 1]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[3][i][j][k + 1] * wp1) - (u[3][i][j][k - 1] * wm1)) + ((((u[4][i][j][k + 1] - square[i][j][k + 1]) - u[4][i][j][k - 1]) + square[i][j][k - 1]) * c2)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dz5tz1 * ((u[4][i][j][k + 1] - (2.0 * u[4][i][j][k])) + u[4][i][j][k - 1]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[4][i][j][k + 1] * rho_i[i][j][k + 1]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j][k - 1] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[4][i][j][k + 1]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[4][i][j][k - 1]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (wm1,wijk,wp1,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/132"}
{"code": "for (int j = 0; j < N; ++j)\n{\n  dtau[i][j] = min((CFL * (1 / J[i][j])) / max(rho1[i][j], rho2[i][j]), (Re * VN) / max(g11[i][j], g22[i][j]));\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/Backward-Facing-Step/C++/src/main/3"}
{"code": "for (j = m - 1; j >= 0; j--)\n{\n  for (i = 0; i < n; i++)\n    printf(\"%lf \", grid[j][i]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/97amarnathk/steadyStateHeat/src/steadyStateHeat/8"}
{"code": "for (int i = 0; i < reps; i++)\n{\n  MPI_Isend(&initial_buffer[0], 3, MPI_CHAR, array_ranks[NORTHWEST], NORTHWEST, cart, &send_request[NORTHWEST]);\n  MPI_Isend(&initial_buffer[0], block_img_width, MPI_CHAR, array_ranks[NORTH], NORTH, cart, &send_request[NORTH]);\n  MPI_Isend(&initial_buffer[0], 1, type_column_rgb, array_ranks[WEST], WEST, cart, &send_request[WEST]);\n  MPI_Isend(&initial_buffer[block_img_width - 3], 3, MPI_CHAR, array_ranks[NORTHEAST], NORTHEAST, cart, &send_request[NORTHEAST]);\n  MPI_Isend(&initial_buffer[block_img_width - 3], 1, type_column_rgb, array_ranks[EAST], EAST, cart, &send_request[EAST]);\n  MPI_Isend(&initial_buffer[(block_img_height - 1) * block_img_width], 3, MPI_CHAR, array_ranks[SOUTHWEST], SOUTHWEST, cart, &send_request[SOUTHWEST]);\n  MPI_Isend(&initial_buffer[(block_img_height - 1) * block_img_width], block_img_width, MPI_CHAR, array_ranks[SOUTH], SOUTH, cart, &send_request[SOUTH]);\n  MPI_Isend(&initial_buffer[(block_img_height * block_img_width) - 3], 3, MPI_CHAR, array_ranks[SOUTHEAST], SOUTHEAST, cart, &send_request[SOUTHEAST]);\n  send_request[CENTER] = MPI_REQUEST_NULL;\n  MPI_Irecv(&northwest_corner, 3, MPI_CHAR, array_ranks[NORTHWEST], SOUTHEAST, cart, &receive_request[NORTHWEST]);\n  MPI_Irecv(north_row, block_img_width, MPI_CHAR, array_ranks[NORTH], SOUTH, cart, &receive_request[NORTH]);\n  MPI_Irecv(west_column, block_img_height * 3, MPI_CHAR, array_ranks[WEST], EAST, cart, &receive_request[WEST]);\n  MPI_Irecv(&northeast_corner, 3, MPI_CHAR, array_ranks[NORTHEAST], SOUTHWEST, cart, &receive_request[NORTHEAST]);\n  MPI_Irecv(east_column, block_img_height * 3, MPI_CHAR, array_ranks[EAST], WEST, cart, &receive_request[EAST]);\n  MPI_Irecv(&southwest_corner, 3, MPI_CHAR, array_ranks[SOUTHWEST], NORTHEAST, cart, &receive_request[SOUTHWEST]);\n  MPI_Irecv(south_row, block_img_width, MPI_CHAR, array_ranks[SOUTH], NORTH, cart, &receive_request[SOUTH]);\n  MPI_Irecv(&southeast_corner, 3, MPI_CHAR, array_ranks[SOUTHEAST], NORTHWEST, cart, &receive_request[SOUTHEAST]);\n  receive_request[CENTER] = MPI_REQUEST_NULL;\n  for (int i = 1; i < (block_img_height - 1); i++)\n  {\n    for (int l = 3; l < (block_img_width - 3); l++)\n    {\n      unsigned int offset_current_pixel = (i * block_img_width) + l;\n      unsigned int pixels_sum = northern_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += center_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += southern_row(offset_current_pixel, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum /= final_filter;\n      final_buffer[offset_current_pixel] = ((char) pixels_sum) & 0xFF;\n    }\n\n  }\n\n  MPI_Waitall(8, receive_request, MPI_STATUSES_IGNORE);\n  for (int i = 3; i < (block_img_width - 3); i++)\n  {\n    unsigned int pixels_sum = center_row(i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += southern_row(i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += north_row[i - 3] * filter[SOUTHEAST];\n    pixels_sum += north_row[i] * filter[SOUTH];\n    pixels_sum += north_row[i + 3] * filter[SOUTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[i] = ((char) pixels_sum) & 0xFF;\n  }\n\n  unsigned int last_line = (block_img_height - 1) * block_img_width;\n  for (int i = 3; i < (block_img_width - 3); i++)\n  {\n    unsigned int pixels_sum = northern_row(last_line + i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += center_row(last_line + i, 3, block_img_width, block_img_height, filter, initial_buffer);\n    pixels_sum += south_row[i - 3] * filter[NORTHEAST];\n    pixels_sum += south_row[i] * filter[NORTH];\n    pixels_sum += south_row[i + 3] * filter[NORTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[last_line + i] = ((char) pixels_sum) & 0xFF;\n  }\n\n  unsigned int cursor = 0;\n  unsigned int pixels_sum = 0;\n  for (unsigned char rgb_current_color = 0; rgb_current_color < 3; rgb_current_color++)\n  {\n    for (unsigned int i = 1; i < (block_img_height - 1); i++)\n    {\n      cursor = (i * block_img_width) + rgb_current_color;\n      pixels_sum = center_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += eastern_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += west_column[((i - 1) * 3) + rgb_current_color] * filter[SOUTHEAST];\n      pixels_sum += west_column[(i * 3) + rgb_current_color] * filter[EAST];\n      pixels_sum += west_column[((i + 1) * 3) + rgb_current_color] * filter[NORTHEAST];\n      pixels_sum /= final_filter;\n      final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    }\n\n    for (unsigned int i = 1; i < (block_img_height - 1); i++)\n    {\n      cursor = (((i + 1) * block_img_width) - 3) + rgb_current_color;\n      pixels_sum = center_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      pixels_sum += western_column(cursor, 3, block_img_width, block_img_height, filter, initial_buffer);\n      ;\n      pixels_sum += east_column[((i - 1) * 3) + rgb_current_color] * filter[SOUTHWEST];\n      pixels_sum += east_column[(i * 3) + rgb_current_color] * filter[WEST];\n      pixels_sum += east_column[((i + 1) * 3) + rgb_current_color] * filter[NORTHWEST];\n      pixels_sum /= final_filter;\n      final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    }\n\n    pixels_sum = initial_buffer[rgb_current_color] * filter[CENTER];\n    pixels_sum += initial_buffer[rgb_current_color + 3] * filter[WEST];\n    pixels_sum += initial_buffer[rgb_current_color + block_img_width] * filter[NORTH];\n    pixels_sum += initial_buffer[(rgb_current_color + block_img_width) + 3] * filter[NORTHWEST];\n    pixels_sum += north_row[rgb_current_color] * filter[SOUTH];\n    pixels_sum += north_row[rgb_current_color + 3] * filter[SOUTHWEST];\n    pixels_sum += west_column[rgb_current_color] * filter[EAST];\n    pixels_sum += west_column[rgb_current_color + 3] * filter[NORTHEAST];\n    pixels_sum += northwest_corner[rgb_current_color] * filter[SOUTHEAST];\n    pixels_sum /= final_filter;\n    final_buffer[rgb_current_color] = ((char) pixels_sum) & 0xFF;\n    cursor = (block_img_width + rgb_current_color) - 3;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor - 3] * filter[EAST];\n    pixels_sum += initial_buffer[cursor + block_img_width] * filter[NORTH];\n    pixels_sum += initial_buffer[(cursor + block_img_width) - 3] * filter[NORTHEAST];\n    pixels_sum += north_row[cursor] * filter[SOUTH];\n    pixels_sum += north_row[cursor - 3] * filter[SOUTHEAST];\n    pixels_sum += east_column[rgb_current_color] * filter[WEST];\n    pixels_sum += east_column[rgb_current_color + 3] * filter[NORTHWEST];\n    pixels_sum += northeast_corner[rgb_current_color] * filter[SOUTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    cursor = ((block_img_height - 1) * block_img_width) + rgb_current_color;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor + 3] * filter[WEST];\n    pixels_sum += initial_buffer[cursor - block_img_width] * filter[SOUTH];\n    pixels_sum += initial_buffer[(cursor - block_img_width) + 3] * filter[SOUTHWEST];\n    pixels_sum += south_row[rgb_current_color] * filter[NORTH];\n    pixels_sum += south_row[rgb_current_color + 3] * filter[NORTHWEST];\n    pixels_sum += west_column[(block_img_height + rgb_current_color) - 3] * filter[EAST];\n    pixels_sum += west_column[(block_img_height + rgb_current_color) - 6] * filter[SOUTHEAST];\n    pixels_sum += southwest_corner[rgb_current_color] * filter[NORTHEAST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n    cursor = ((block_img_height * block_img_width) + rgb_current_color) - 3;\n    pixels_sum = initial_buffer[cursor] * filter[CENTER];\n    pixels_sum += initial_buffer[cursor - 3] * filter[EAST];\n    pixels_sum += initial_buffer[cursor - block_img_width] * filter[SOUTH];\n    pixels_sum += initial_buffer[(cursor - block_img_width) - 3] * filter[SOUTHEAST];\n    pixels_sum += south_row[(block_img_width + rgb_current_color) - 3] * filter[NORTH];\n    pixels_sum += south_row[(block_img_width + rgb_current_color) - 6] * filter[NORTHEAST];\n    pixels_sum += east_column[(block_img_height + rgb_current_color) - 3] * filter[WEST];\n    pixels_sum += east_column[(block_img_height + rgb_current_color) - 6] * filter[SOUTHWEST];\n    pixels_sum += southeast_corner[rgb_current_color] * filter[NORTHWEST];\n    pixels_sum /= final_filter;\n    final_buffer[cursor] = ((char) pixels_sum) & 0xFF;\n  }\n\n  MPI_Waitall(8, send_request, MPI_STATUSES_IGNORE);\n  unsigned char *temp_buffer = final_buffer;\n  final_buffer = initial_buffer;\n  initial_buffer = temp_buffer;\n  if (((i + 1) % 20) == 0)\n  {\n    unsigned char rank_contrast;\n    unsigned char pixel_contrast = 0;\n    for (int i = 0; i < (block_img_width * block_img_height); i++)\n    {\n      if (initial_buffer[i] != final_buffer[i])\n      {\n        pixel_contrast = 1;\n        break;\n      }\n\n    }\n\n    MPI_Reduce(&pixel_contrast, &rank_contrast, 1, MPI_CHAR, MPI_MAX, 0, cart);\n    MPI_Bcast(&rank_contrast, 1, MPI_CHAR, 0, cart);\n    if (rank_contrast == 0)\n    {\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ApChris/Image-Convolution/convolution/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  mass[i] = rand() % 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrtinPaler/openmp/lab_5/omp_lab_5/0"}
{"code": "for (int i = 2; i < size; i++)\n{\n  for (int j = 2; j <= sqrt((double) i); j++)\n  {\n    if (primesSet.test(j) && (!(i % j)))\n    {\n      primes[i] = false;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fizyk93/OpenMP/main/7"}
{"code": "for (i = 0; i < used_matrix_size; i++)\n{\n  matB_trans[i] = (double *) calloc(used_matrix_size * used_matrix_size, sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abodh/Parallel_matrix_mutiplication/mat_mat_parallel/2"}
{"code": "for (int ai = 0; ai < cast_mat->nrow_; ++ai)\n{\n  for (int aj = cast_mat->mat_.row_offset[ai]; aj < cast_mat->mat_.row_offset[ai + 1]; ++aj)\n  {\n    for (int ajj = this->mat_.row_offset[ai]; ajj < this->mat_.row_offset[ai + 1]; ++ajj)\n    {\n      if (cast_mat->mat_.col[aj] == this->mat_.col[ajj])\n      {\n        val[aj] = this->mat_.val[ajj];\n        levels[aj] = 0;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/51"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    double suma_parcial = 0;\n    index = ((i + offset) * N) + j;\n    if (B[index] < minB)\n      minB = B[index];\n\n    if (B[index] > maxB)\n      maxB = B[index];\n\n    totalB += B[index];\n    if (A[(i * N) + j] < minA)\n      minA = A[(i * N) + j];\n\n    if (A[(i * N) + j] > maxA)\n      maxA = A[(i * N) + j];\n\n    totalA += A[(i * N) + j];\n    for (k = 0; k < N; k++)\n    {\n      suma_parcial += A[(i * N) + k] * B[(j * N) + k];\n    }\n\n    AB[(i * N) + j] = suma_parcial;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k,index) reduction(+:totalA, totalB) reduction(max:maxA, maxB) reduction(min:minA, minB) nowait", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/0"}
{"code": "for (i = 0; i < SLICE_SIZE; i++)\n{\n  if (points[i + (nslice * SLICE_SIZE)].ID != dataSlice[i].ID)\n  {\n    *unConverged = 1;\n  }\n\n  points[i + (nslice * SLICE_SIZE)].ID = dataSlice[i].ID;\n  points[i + (nslice * SLICE_SIZE)].dist = dataSlice[i].dist;\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mkdan91/ParallelKmeans/Kmeans/Main/6"}
{"code": "for (int to = 0; to < vertices; to++)\n{\n  if (((from != to) && (from != via)) && (to != via))\n  {\n    omp_set_lock(&dist_locks[from][to]);\n    dist[from][to] = min(dist[from][to], dist[from][via] + dist[via][to]);\n    omp_unset_lock(&dist_locks[from][to]);\n  }\n\n}\n\n", "pragma": "                  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahzebp/floyd_warshall_parallel/openmp/iterative/2"}
{"code": "for (i = 0; i < size; ++i)\n  for (j = 0; j < size; ++j)\n  sum_par += M[i][j];\n\n\n", "pragma": "omp parallel for shared(M) private(i, j) reduction(+:sum_par)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab3/lab3_z3_compare/0"}
{"code": "for (int j = start; j <= (end - 1); j++)\n{\n  if (arrWrite[j] < pivot)\n  {\n    i++;\n    int temp = arrWrite[i];\n    arrWrite[i] = arrWrite[j];\n    arrWrite[j] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AniMahajan20/Parallel-Computing/HyperQuickSort using OpenMP/hyperquicksort_openmp/3"}
{"code": "for (int i = 0; i < size; i++)\n  a[i] = (rand() % 150) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VladislavSmekhnov/OpenMP_tasks/openmp_11/0"}
{"code": "for (int i = 1; i < (geom1->n_grid_r - 1); i++)\n  for (int k = 1; k < (geom1->n_grid_z - 1); k++)\n{\n  double epsilonx2 = (2 * geom1->epsilon[i][k]) * EPSILON0;\n  double sigma_t = geom1->sigma[i][k] * time1->delta_t;\n  double koef_e = (epsilonx2 - sigma_t) / (epsilonx2 + sigma_t);\n  double koef_h = (2 * time1->delta_t) / (epsilonx2 + sigma_t);\n  field_r[i][k] = (field_r[i][k] * koef_e) - ((j_r[i][k] + ((h_phi[i][k] - h_phi[i][k - 1]) / dz)) * koef_h);\n  field_phi[i][k] = (field_phi[i][k] * koef_e) - (((j_phi[i][k] - ((h_r[i][k] - h_r[i][k - 1]) / dz)) + ((h_z[i][k] - h_z[i - 1][k]) / dr)) * koef_h);\n  field_z[i][k] = (field_z[i][k] * koef_e) - (((j_z[i][k] - ((h_phi[i][k] - h_phi[i - 1][k]) / dr)) - ((h_phi[i][k] + h_phi[i - 1][k]) / ((2.0 * dr) * i))) * koef_h);\n}\n\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (i == 0)\n    printf(\"[%d, \", arr[i]);\n  else\n    if (i == (size - 1))\n    printf(\"%d]\\n\", arr[i]);\n  else\n    printf(\"%d, \", arr[i]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lewisc4/Parallel-Sorting-Algorithms/Odd Even Sort/oddEvenParallel/3"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  a[i] = (rand() % 10) + 1;\n  b[i] = (rand() % 10) + 1;\n  printf(\"number of threads: %d, thread number: %d, \u043d\u043e\u043c\u0435\u0440 \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0438: %d\\n\", omp_get_num_threads(), omp_get_thread_num(), i);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(3) schedule (static, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VladislavSmekhnov/OpenMP_tasks/openmp_7/1"}
{"code": "for (i = 0; i < (1024 * 1024); i++)\n  res[i] = sin((double) (rand_r(seed) / 1000)) + cos((double) (rand_r(seed) / 10000));\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawseySC/oar/examples/hello/0"}
{"code": "for (int i = 0; i < threadCount; i++)\n  pthread_join(arr[i], nullptr);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilya1032/Multithread-course-work-Java-threads-pthreads-OpenMP-/pthreads_OpenMP/src/sources/Matrix/2"}
{"code": "for (i = 0; i < nrows; ++i)\n{\n  for (j = 0; j < ncols; ++j)\n  {\n    result += (double) (mal[i][j] * val[j]);\n  }\n\n  r[i] = result;\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/dense/2"}
{"code": "for (int j = 0; j < 8; ++j)\n{\n  sleep_for(seconds(1));\n  fprintf(stdout, \"j = %d, thread id = %d\\n\", j, omp_get_thread_num());\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/1"}
{"code": "for (int i = 0; i < ((nx * ny) / 2); i++)\n{\n  naivesum += lattice_b[i];\n  naivesum += lattice_w[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ising-omp/main/5"}
{"code": "for (long i = 0; i < N1; i++)\n{\n  __sync_fetch_and_add(&commPtr1[((long) C1[i]) + 1], 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/19"}
{"code": "for (int i = 0; i < p; i++)\n{\n  local_start[i] = ave * i;\n  local_end[i] = ave * (i + 1);\n  if (i == (p - 1))\n  {\n    local_end[i] = n;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sunnlo/BellmanFord/openmp_bellman_ford/2"}
{"code": "for (j = 0; j < Block_order; j += Tile_order)\n  for (i = 0; i < order; i += Tile_order)\n  for (jt = j; jt < MIN(Block_order, j + Tile_order); jt++)\n  for (it = i; it < MIN(order, i + Tile_order); it++)\n{\n  A_p[(it + istart) + (order * jt)] = (double) ((order * (jt + colstart)) + it);\n  B_p[(it + istart) + (order * jt)] = 0.0;\n}\n\n\n\n\n", "pragma": "omp parallel for private (i,it,jt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Transpose/transpose/0"}
{"code": "for (i = ibeg; i <= ifin1; i++)\n{\n  for (k = ki1; k <= (ki2 - 1); k++)\n  {\n    frc2 = frc2 + (((((((phi1[i][k] + phi1[i + 1][k]) + phi1[i][k + 1]) + phi1[i + 1][k + 1]) + phi2[i][k]) + phi2[i + 1][k]) + phi2[i][k + 1]) + phi2[i + 1][k + 1]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/40"}
{"code": "for (i = 0; i < array_size; i++)\n{\n  Array[i] = i * 5;\n  Check[i] = Array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ksheeraj1161/OpenMP-MPI/OpenMP/program5/0"}
{"code": "for (int ii = (z - HALO_PAD) - depth; ii < (z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD; jj < (y - HALO_PAD); ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX)) + (((ii - ((z - HALO_PAD) - depth)) * _chunk.innerX) * _chunk.innerY);\n      buffer[bufIndex] = field[(((ii * y) * x) + (jj * x)) + kk];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/4"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    a[i][j] = compute(i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/simoatze/archer_race_examples/data-race04/0"}
{"code": "for (i = 0; i < sample_count; i++)\n{\n  samples[i] = numbers[j];\n  j += offset;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/3"}
{"code": "for (unsigned int i = 0; i < SIZE; i++)\n{\n  a[i] = distribution(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Armagetron/omp-demo/examp1/0"}
{"code": "for (i = 0; i < (1 << 20); i++)\n  omp_init_lock(&lock[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Locks_critical_sections_omp-atomic/atomic_sec/0"}
{"code": "for (k = 0; k < (n - 1); k++)\n{\n  if (fabs(a[k][k]) >= 1.e-6)\n  {\n    for (i = k + 1; i < n; i++)\n    {\n      x = a[i][k] / a[k][k];\n      for (j = k + 1; j < n; j++)\n        a[i][j] = a[i][j] - (a[k][j] * x);\n\n      b[i] = b[i] - (b[k] * x);\n    }\n\n  }\n  else\n  {\n    cout << \"zero pivot element found.\\n\";\n    exit(1);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kielfriedt/Multithreading/OpenMP/MatSolv/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (strcmp(qs.solutions[i], qs.answers[i]) == 0)\n  {\n    answerResults[i] = \"Correct \";\n    nCorrectAnswers++;\n    studentPoints += qs.ratings[i];\n  }\n  else\n    answerResults[i] = \"Incorrect \";\n\n  totalRating += qs.ratings[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ricardoreais/exam-evaluator/exam-evaluator/1"}
{"code": "for (int i = 0; i < nSegments; i++)\n{\n  ((((cout << \"segments[\") << i) << \"] = \\\"\") << segments[i]) << \"\\\"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/Bucket/3"}
{"code": "for (i = 0; i < num_threads; i++)\n{\n  if (trie_list[i]->children[alpha])\n  {\n    if (!g_trie->children[alpha])\n      g_trie->children[alpha] = get_Node();\n\n    g_trie->children[alpha] = merge_trie(g_trie->children[alpha], trie_list[i]->children[alpha]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svaderia/ParallelDF/driver/3"}
{"code": "for (j = 0; j < (N + 1); j++)\n{\n  for (i = 0; i < (M + 1); i++)\n    V(ut, i, j) = (0.25 * (((V(u, i, j) + V(u, i - 1, j)) + V(u, i, j - 1)) + V(u, i - 1, j - 1))) - ((0.5 * dt) * ((sy * (((V(u, i, j) + V(u, i, j - 1)) - V(u, i - 1, j)) - V(u, i - 1, j - 1))) + (sx * (((V(u, i, j) + V(u, i - 1, j)) - V(u, i, j - 1)) - V(u, i - 1, j - 1)))));\n\n}\n\n", "pragma": "omp parallel for schedule(static) default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongbozhang85/openmp-cuda-advection-solver/openmp/parAdvect/4"}
{"code": "for (i = usedSymbols.begin(); i != usedSymbols.end(); ++i)\n  _usedSymbols.push_back(string((*i)->get_name().str()));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/PolyOpt/polyopt/PastToSage/7"}
{"code": "for (i = 1; i < f; i++)\n{\n  for (j = 1; j < e; j++)\n  {\n    M[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/M-MSilva/PDE-OpenMP/PDE_MM_OpenMPCode/3"}
{"code": "for (index = 0; index < count; index++)\n{\n  SHA512_CTX ctx;\n  unsigned char km[64];\n  AES_KEY aes_decrypt_key;\n  unsigned char out[1024];\n  unsigned char iv[16] = {0};\n  if (cur_salt->type == 0)\n  {\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, saved_key[index], saved_len[index]);\n    SHA512_Final(km, &ctx);\n    AES_set_decrypt_key(km, 256, &aes_decrypt_key);\n    AES_cbc_encrypt((cur_salt->ct + cur_salt->ctlen) - 32, out, 32, &aes_decrypt_key, iv, AES_DECRYPT);\n    if (memcmp(out + 16, \"\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\\x10\", 16) == 0)\n    {\n      cracked[index] = 1;\n      any_cracked |= 1;\n    }\n\n  }\n  else\n  {\n    secp256k1_context *ctxs;\n    secp256k1_pubkey pubkey;\n    SHA256_CTX sctx;\n    unsigned char output[128];\n    size_t outlen = 33;\n    int padbyte;\n    int dlen = cur_salt->ctlen - outlen;\n    SHA256_Init(&sctx);\n    SHA256_Update(&sctx, saved_key[index], saved_len[index]);\n    SHA256_Final(km, &sctx);\n    ctxs = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n    secp256k1_ec_pubkey_parse(ctxs, &pubkey, cur_salt->ct, 33);\n    secp256k1_ec_pubkey_tweak_mul(ctxs, &pubkey, km);\n    secp256k1_ec_pubkey_serialize(ctxs, output, &outlen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n    secp256k1_context_destroy(ctxs);\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, output + 1, 32);\n    SHA512_Final(km, &ctx);\n    hex_encode(km, 64, output);\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, output, 128);\n    SHA512_Final(km, &ctx);\n    AES_set_decrypt_key(km, 256, &aes_decrypt_key);\n    AES_cbc_encrypt(cur_salt->ct + 33, out, dlen, &aes_decrypt_key, km + 32, AES_DECRYPT);\n    padbyte = out[dlen - 1];\n    if (padbyte <= 16)\n    {\n      if (check_pkcs_pad(out, dlen, 16) >= 0)\n      {\n        SHA256_Init(&sctx);\n        SHA256_Update(&sctx, out + 4, (dlen - 4) - padbyte);\n        SHA256_Final(km, &sctx);\n        if (memcmp(km, out, 4) == 0)\n        {\n          cracked[index] = 1;\n          any_cracked |= 1;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/bitshares_fmt_plug/2"}
{"code": "for (q = 8; q < 16; q++)\n{\n  for (r = 40; r < 80; r++)\n  {\n    for (n = 0; n < 313; n++)\n    {\n      for (m = 0; m < 173; m++)\n      {\n        for (l = 0; l < 5; l++)\n        {\n          for (k = 0; k < 5; k++)\n          {\n            y[(((r * 173) * 313) + (m * 313)) + n] += in_layer[((((q * 177) * 317) + ((m + k) * 317)) + n) + l] * weight[(((((r * 8) + q) - 8) * 25) + (k * 5)) + l];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-tavana/CNN_OPENMP/conv_layer4/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  Q(i, 0) = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/82"}
{"code": "for (i = 0; i < m->size; i++)\n{\n  if ((maxIndexA[i] > value_max) && (value == m->tab[maxIndexA[i]]))\n  {\n    value_max = maxIndexA[i];\n  }\n\n  if ((minIndexA[i] < value_min) && (value == m->tab[minIndexA[i]]))\n  {\n    value_min = minIndexA[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(max: value_max) reduction(min: value_min)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/14"}
{"code": "for (int i = 0; i < (geom1->n_grid_r - 1); i++)\n  for (int k = 0; k < (geom1->n_grid_z - 1); k++)\n{\n  field_r[i][k] = E_r;\n  field_phi[i][k] = E_phi;\n  field_z[i][k] = E_z;\n}\n\n\n", "pragma": "#pragma omp parallel for shared (E_r, E_phi, E_z)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/eField/0"}
{"code": "for (lo = 0; lo <= hi; lo++)\n{\n  if (!flag)\n  {\n    temp = ((float) (lo + hi)) / 2;\n    mid = floor(temp);\n    if (localList[mid] > target)\n    {\n      if ((mid - 1) < 0)\n      {\n        *count = 0;\n        flag = 1;\n      }\n      else\n      {\n        if (localList[mid - 1] <= target)\n        {\n          *count = mid;\n          flag = 1;\n        }\n\n      }\n\n    }\n\n    if ((mid + 1) == n)\n    {\n      *count = n;\n      flag = 1;\n    }\n\n    if (localList[mid] <= target)\n    {\n      lo = mid + 1;\n    }\n    else\n    {\n      hi = mid - 1;\n    }\n\n    lo = lo - 1;\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/swapnilushinde/OpenMP_MPI_Sample_sort_algorithm/Source code/SSHINDE2/sampleSortOpenMP/1"}
{"code": "for (int i = 0; i < N2; ++i)\n{\n  if (C[i] != 2)\n  {\n    fprintf(stderr, \"wrong result \");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-tracekernel/clangtrace/3"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n    for (int k = 0; k < nzn; k++)\n  {\n    Jzs[is][i][j][k] += invVOL * moments[i][j][k][3];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = h * (((double) i) - 0.5);\n  sumpi = f(x);\n  pi = pi + (sumpi * h);\n}\n\n", "pragma": "omp for reduction(+:pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_11/PI_MPI_OMP/piOMP/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  prod += u[i] * v[i];\n  printf(\"Thread in use: %d\\n\", thread_id);\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/dot_product/0"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  a[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/metadirective/test_metadirective_arch_nvidia_or_amd/0"}
{"code": "for (x = 0; x < rows; x++)\n{\n  for (y = 0; y < cols; y++)\n  {\n    int idx = (x * cols) + y;\n    double red_old = (double) (im->data + idx)->red;\n    double grn_old = (double) (im->data + idx)->green;\n    double blu_old = (double) (im->data + idx)->blue;\n    unsigned char red_new = (unsigned char) abs((red_old - red_mean) / red_std_dev);\n    unsigned char grn_new = (unsigned char) abs((grn_old - grn_mean) / grn_std_dev);\n    unsigned char blu_new = (unsigned char) abs((blu_old - blu_mean) / blu_std_dev);\n    (im2->data + idx)->red = red_new;\n    (im2->data + idx)->green = grn_new;\n    (im2->data + idx)->blue = blu_new;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chahak13/HPC/Lab5/201501005-201501422-image_warping-collapsed_directive/parallel_measurement/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < coulmns; j++)\n  {\n    mul[i][j] = 0;\n    for (k = 0; k < coulmns; k++)\n    {\n      mul[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for private(i,j,k) shared(mul,a,b) num_threads(number_of_threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yousaf2018/OpenMP-programming-/mulitplication_using_omp/2"}
{"code": "for (int i = 0; i < getVertexNumberMatrix(gr); i++)\n{\n  result[i] = malloc((sizeof(int)) * getVertexNumberMatrix(gr));\n  memcpy(result[i], gr->W_ma[i], (sizeof(int)) * getVertexNumberMatrix(gr));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/7"}
{"code": "for (i = 0; i < (1 << 16); i++)\n  prv_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/45"}
{"code": "for (int i = 0; i < tasks.size(); i++)\n{\n  if (tasks[i]->type == GPU)\n  {\n    dealloc_cuda(tasks[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rickyboy320/hpc_bench/dynamic/vector/6"}
{"code": "for (unsigned i = 0; i < 5; ++i)\n{\n  in[i] = crc64_load_le32_(&((const uint32_t *) data)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/crc64-omp/CRC64/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < b[i].size(); j++)\n  {\n    b[i][j].push_back(rand() % 10);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnomDevgun/ParallelComputing/openMP/cp/1"}
{"code": "for (i = 0; i < 12; i++)\n  cs.iv[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/andotp_fmt_plug/0"}
{"code": "for (int i = 0; i < total_elements; i++)\n{\n  int *p;\n  p = (int *) (buffer_col + cur);\n  R2C_mapping[*p] = i;\n  C2R_mapping[i] = *p;\n  cur += 12;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/16"}
{"code": "for (i = 0; i < cd->n; i++)\n  *(renumber_community + i) = -1;\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(dynamic,50)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/community-computation-weighted/1"}
{"code": "for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  const double yM = grid->getYC(i, j, k) - (.5 * Ly);\n  Bxc[i][j][k] = B0x * tanh(yM / delta);\n  const double xM = grid->getXC(i, j, k) - (.5 * Lx);\n  Bxc[i][j][k] -= (((B0x / 10.0) * (M_PI / Ly)) * cos(((2 * M_PI) * xM) / Lx)) * sin((M_PI * yM) / Ly);\n  Byc[i][j][k] = B0y + ((((B0x / 10.0) * ((2 * M_PI) / Lx)) * sin(((2 * M_PI) * xM) / Lx)) * cos((M_PI * yM) / Ly));\n  Bzc[i][j][k] = B0z;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/68"}
{"code": "for (it = neighbours.begin(); it != neighbours.end(); ++it)\n{\n  if (it->second.size() < minSize)\n  {\n    minSize = it->second.size();\n    it1 = it;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/14"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  b[i] = x;\n  x += a[i];\n}\n\n", "pragma": "omp parallel for simd reduction(inscan, +: x) num_threads(OMPVV_NUM_THREADS_HOST)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/scan/test_scan/1"}
{"code": "for (int j = 0; j < n; j++)\n{\n  if ((j % 2) == 0)\n  {\n    rowsort(j, a, n);\n  }\n  else\n  {\n    rowrevsort(j, a, n);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcordero26/parallel-computing/hw3/shear/3"}
{"code": "for (int i = 1; i <= N; i++)\n  sum += i;\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task2/main/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  result[i] = i;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/tests/openmp/unit/par_for/0"}
{"code": "for (int i = 0; i < in.lookups; i++)\n{\n  int *num_nucs = SD.num_nucs;\n  double *concs = SD.concs;\n  double *unionized_energy_array = SD.unionized_energy_array;\n  int *index_grid = SD.index_grid;\n  NuclideGridPoint *nuclide_grid = SD.nuclide_grid;\n  uint64_t seed = STARTING_SEED;\n  seed = fast_forward_LCG(seed, 2 * i);\n  double p_energy = LCG_random_double(&seed);\n  int mat = pick_mat(&seed);\n  double macro_xs_vector[5] = {0};\n  calculate_macro_xs(p_energy, mat, in.n_isotopes, in.n_gridpoints, num_nucs, concs, unionized_energy_array, index_grid, nuclide_grid, SD.mats, macro_xs_vector, in.grid_type, in.hash_bins, SD.max_num_nucs);\n  double max = -1.0;\n  int max_idx = 0;\n  for (int j = 0; j < 5; j++)\n  {\n    if (macro_xs_vector[j] > max)\n    {\n      max = macro_xs_vector[j];\n      max_idx = j;\n    }\n\n  }\n\n  verification += max_idx + 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,100) reduction(+:verification)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/XSBench/openmp-threading/Simulation/0"}
{"code": "for (i = *myPointsSize; i < n; i++)\n{\n  if (counterPointProcess == div)\n  {\n    currentProcess++;\n    counterPointProcess = 0;\n  }\n\n  MPI_Send(&arrPoints[i], 1, MPI_POINT_TYPE, currentProcess, 0, MPI_COMM_WORLD);\n  counterPointProcess++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liran4200/kmeans-parallel/Kmeans_Parallel_liran/kmeans/1"}
{"code": "for (i = windowStart; i < windowLen; i++)\n{\n  double xt = xcorr[i] - mean_x;\n  double xi = i - mean_i;\n  b += xt * xi;\n  div += xi * xi;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/BPMDetect/8"}
{"code": "for (i = 0; i < m; i++)\n  F[i] = malloc(n * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/acenet-arc/ACENET_Summer_School_OpenMP_ACC/code/laplace2d_omp_acc/2"}
{"code": "for (j = 0; j < 2048; j++)\n  for (k = i; k < 2048; k++)\n  B[i][j] += A[i][k] * B[k][j];\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP1/PA2-Prob1/0"}
{"code": "for (int i = 0; i < m; i++)\n  depths[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/bc/omp_target/2"}
{"code": "for (i = 1; i <= toDo; ++i)\n{\n  if (displ[i] == 0)\n  {\n    res1 = (*_ptrToSeq1)[i1];\n    res2 = (*_ptrToSeq2)[i2];\n    if (((res1 != userParameters->getGapPos1()) && (res2 != userParameters->getGapPos2())) && (res1 == res2))\n    {\n      count++;\n    }\n\n    ++i1;\n    ++i2;\n    ++pos;\n  }\n  else\n  {\n    if ((k = displ[i]) > 0)\n    {\n      i2 += k;\n      pos += k;\n    }\n    else\n    {\n      i1 -= k;\n      pos -= k;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HPCTUSofiaOrg/clustalw2/src/pairwise/FullPairwiseAlign/0"}
{"code": "for (j = 0; j < 10; j++)\n  sum += j;\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49898-1/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpnxca05ew.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MJChku/openmp_source/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (i = 0; i < NO_OF_BITS; i++)\n{\n  temp = num & (1 << i);\n  if (temp == 1)\n    reverse_num |= 1 << ((NO_OF_BITS - 1) - i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gemarela/fft_openmp/openmp_fft/4"}
{"code": "for (i = 0; i < 16; i++)\n  ;\n\n", "pragma": "omp parallel for simd if (a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/if-1/0"}
{"code": "for (j = data->iRowFirst + 1; j <= (data->iRowLast - 1); j++)\n{\n  for (i = 0; i < data->iCols; i++)\n  {\n    uold[((j - data->iRowFirst) * data->iCols) + i] = afU[((j - data->iRowFirst) * data->iCols) + i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KevinMTO/Helmholtz-ACC/just openmp+mpi/oldJ/0"}
{"code": "for (; i < (mpi_size - 1); ++i)\n  MPI_Send(&ii, 1, (MPI_Datatype) 0x4c000405, i + 1, 0, (MPI_Comm) 0x44000000);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gmcgarragh/divvy/divvy/6"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      uijk = us[k][j][i];\n      up1 = us[k][j][i + 1];\n      um1 = us[k][j][i - 1];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dx1tx1 * ((u[k][j][i + 1][0] - (2.0 * u[k][j][i][0])) + u[k][j][i - 1][0]))) - (tx2 * (u[k][j][i + 1][1] - u[k][j][i - 1][1]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dx2tx1 * ((u[k][j][i + 1][1] - (2.0 * u[k][j][i][1])) + u[k][j][i - 1][1]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[k][j][i + 1][1] * up1) - (u[k][j][i - 1][1] * um1)) + ((((u[k][j][i + 1][4] - square[k][j][i + 1]) - u[k][j][i - 1][4]) + square[k][j][i - 1]) * c2)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dx3tx1 * ((u[k][j][i + 1][2] - (2.0 * u[k][j][i][2])) + u[k][j][i - 1][2]))) + (xxcon2 * ((vs[k][j][i + 1] - (2.0 * vs[k][j][i])) + vs[k][j][i - 1]))) - (tx2 * ((u[k][j][i + 1][2] * up1) - (u[k][j][i - 1][2] * um1)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dx4tx1 * ((u[k][j][i + 1][3] - (2.0 * u[k][j][i][3])) + u[k][j][i - 1][3]))) + (xxcon2 * ((ws[k][j][i + 1] - (2.0 * ws[k][j][i])) + ws[k][j][i - 1]))) - (tx2 * ((u[k][j][i + 1][3] * up1) - (u[k][j][i - 1][3] * um1)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dx5tx1 * ((u[k][j][i + 1][4] - (2.0 * u[k][j][i][4])) + u[k][j][i - 1][4]))) + (xxcon3 * ((qs[k][j][i + 1] - (2.0 * qs[k][j][i])) + qs[k][j][i - 1]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[k][j][i + 1][4] * rho_i[k][j][i + 1]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k][j][i - 1][4] * rho_i[k][j][i - 1])))) - (tx2 * ((((c1 * u[k][j][i + 1][4]) - (c2 * square[k][j][i + 1])) * up1) - (((c1 * u[k][j][i - 1][4]) - (c2 * square[k][j][i - 1])) * um1)));\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    i = 1;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n    }\n\n    i = 2;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((((-4.0) * u[k][j][i - 1][m]) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 3; i <= (nx2 - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])) + u[k][j][i + 2][m]));\n      }\n\n    }\n\n  }\n\n  for (j = 1; j <= ny2; j++)\n  {\n    i = nx2 - 1;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j][i + 1][m])));\n    }\n\n    i = nx2;\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((u[k][j][i - 2][m] - (4.0 * u[k][j][i - 1][m])) + (5.0 * u[k][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/rhs/2"}
{"code": "for (i = lo; i <= hi; i++)\n  printf(\"%d \", a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dianchengwangCHN/ParallelComputingLab/PA2/PA2-p1/pa2-p1/6"}
{"code": "for (int i = 0, cumsum = 0; i < n; i++)\n{\n  int temp = col[i];\n  col[i] = cumsum;\n  cumsum += temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v4/v4_omp/3"}
{"code": "for (col = 0; col < NColsPlusBounds; col++)\n{\n  Trees[(recvRow * NColsPlusBounds) + col] = RecvBuf[col];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/fire/6"}
{"code": "for (; it < 100; it++)\n{\n  if (!working_iterations[it])\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GetsuDer/Sor3D/Source/openmp_code/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  host_arr[i].val = i;\n  host_arr[i].arr = (int *) malloc(sz_inner);\n  for (int j = 0; j < N; j++)\n  {\n    host_arr[i].arr[j] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/mixed_mapper/main/0"}
{"code": "for (i = 0; i < chunksize; i++)\n{\n  fscanf(file, \"%d\", &temp);\n  for (j = 0; j < Number_Subjects; j++)\n  {\n    fscanf(file, \"%lf\", &doc[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/6"}
{"code": "for (long i = 0; i < s1_n; i++)\n{\n  for (long j = 0; j < mr_m; j++)\n  {\n    long sum = 0;\n    for (long k = 0; k < s2_n; k++)\n    {\n      sum += (*mat1)[i][k] * (*mat2)[k][j];\n    }\n\n    (*m_res)[i][j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/base_mul_matrix/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxyz[4 * (j + kj)] = at2 * zt1;\n    fxyz[1 + (4 * (j + kj))] = at3 * zt1;\n    fxyz[2 + (4 * (j + kj))] = zero;\n    fxyz[4 * (j + k1)] = at2 * zt2;\n    fxyz[1 + (4 * (j + k1))] = (-at3) * zt2;\n    fxyz[2 + (4 * (j + k1))] = zero;\n    fxyz[4 * ((j + kj) + l1)] = zero;\n    fxyz[1 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[2 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[4 * ((j + k1) + l1)] = zero;\n    fxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    fxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    at1 = at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n    wp += (double) at1;\n  }\n\n  sum2 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic3/kncmpush3/2"}
{"code": "for (int iatom = 0; iatom < natom; iatom++)\n{\n  float dist = sqrtf((((gx[igrid] - ax[iatom]) * (gx[igrid] - ax[iatom])) + ((gy[igrid] - ay[iatom]) * (gy[igrid] - ay[iatom]))) + ((gz[igrid] - az[iatom]) * (gz[igrid] - az[iatom])));\n  sum += ((pre1 * (charge[iatom] / dist)) * expf((-xkappa) * (dist - size[iatom]))) / (1 + (xkappa * size[iatom]));\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/mdh-omp/main/3"}
{"code": "for (i = 0; i < (N * nThreads); ++i)\n{\n  double r = sqr(((double) rand_r(&seed)) / 32767) + sqr(((double) rand_r(&seed)) / 32767);\n  sum += r <= 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dmitriyklebanov/made_2020_hpc/3/src/omp_pi_calc/1"}
{"code": "for (i = 0; i < size; i++)\n  array1[i] = C[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i * 3.14;\n  b[i] = i * 6.67;\n  results[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulasthi/KmeansC-OpenMP/1/1"}
{"code": "for (int i = 0; i < len_c; i++)\n{\n  for (int j = 2; j < (len_b + 1); j++)\n  {\n    if (b[j - 2] == c[i])\n    {\n      P[i][j] = j - 1;\n    }\n    else\n    {\n      P[i][j] = P[i][j - 1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v1/row_wise_v1/0"}
{"code": "for (int i = 0; i < sim->N; i++)\n{\n  gap = gapAhead(cars, i, new_grid, sim);\n  if (cars[i].v < cars[i].v_d)\n  {\n    cars[i].v++;\n  }\n\n  if (cars[i].v > gap)\n  {\n    cars[i].v = gap;\n  }\n\n  if ((cars[i].v > 0) && (erand48(xsubi[omp_get_thread_num()]) < sim->p_brake))\n  {\n    cars[i].v--;\n  }\n\n}\n\n", "pragma": "omp for private(gap)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scimas/traffic-ca/traffic_parallel/5"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dEo11[col] = dEo111[col] * douto[col];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/17"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  cargarLocal(local, srcImage, ii);\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValue = 0;\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = local[i + 1][j + 1];\n        pixelValue += weight[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    if (pixelValue > 255)\n      pixelValue = 255;\n\n    if (pixelValue < 0)\n      pixelValue = 0;\n\n    dstImage->setPixel(jj, ii, QColor(pixelValue, pixelValue, pixelValue).rgba());\n    if (jj != (srcImage->width() - 2))\n    {\n      desplazarLocal(local, ii, jj, srcImage);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidCarneros/Arco_OpenMP/sobel2/sobel2/1"}
{"code": "for (unsigned int i = 1; i < (nel_parts + 1); i++)\n{\n  int rank2 = (myrank + i) % np;\n  if (myrank < rank2)\n  {\n    print_submatrix(parts[i], local_nel, get_nel_by_rank(rank2, q, r, np));\n  }\n  else\n  {\n    print_submatrix(parts[i], get_nel_by_rank(rank2, q, r, np), local_nel);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/17"}
{"code": "for (i = 0; i < stopLength; i++)\n{\n  printf(\"%s\\n\", stop[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mayankmahavar111/pc/parallel/9"}
{"code": "for (int i = 0; i < threads; i++)\n  binary_search(arr, i * k, min(n, (i * k) + k), key);\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/Parallel_binary_search_openmp/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  sum_a += a[i];\n  sum_b += b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Allem1991/OpenMP/OpenMP/task6/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA512)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA512][G_ELI_USERKEYLEN];\n  unsigned char key[SSE_GROUP_SZ_SHA512][G_ELI_USERKEYLEN];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA512; ++i)\n    pbkdf2_sha512((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->md_salt, G_ELI_SALTLEN, cur_salt->md_iterations, master[i], G_ELI_USERKEYLEN, 0);\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA512; ++i)\n  {\n    JTR_hmac_sha512((const unsigned char *) \"\", 0, master[i], G_ELI_USERKEYLEN, key[i], G_ELI_USERKEYLEN);\n    cracked[index + i] = geli_decrypt_verify(cur_salt, key[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/geli_fmt_plug/1"}
{"code": "for (i = 0; i < pointNum; i++)\n{\n  if (points[i] > max1)\n  {\n    max1 = points[i];\n  }\n  else\n    if (points[i] < min1)\n  {\n    min1 = points[i];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlaaElattar/MPI_openmp/main/1"}
{"code": "for (i = 0; i < numprocs; i++)\n{\n  for (j = 0; j < amounts[i]; j++)\n  {\n    addProduct(productDatabase, &myClusters[productsToReceive[i][j].newClusterId], &productsToReceive[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roiedanino/K-Means-Parallel-Implementation/kMeansRoieDanino/MPI_Functions/5"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  *(d + i) = 0.0;\n  for (int j = 0; j < dim; j++)\n    *(d + i) += pow((*((X + (i * dim)) + j)) - (*((X + ((n - 1) * dim)) + j)), 2);\n\n  *(d + i) = sqrt(*(d + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/angrammenos97/VP_Tree/vptree/0"}
{"code": "for (int c = 0; c < col_c; c++)\n{\n  int w_off = c % f_size;\n  int h_off = (c / f_size) % f_size;\n  int im_chan = c / (f_size * f_size);\n  for (int y = 0; y < col_h; y++)\n  {\n    for (int x = 0; x < col_w; x++)\n    {\n      int im_row = (h_off + (y * stride)) - padd;\n      int im_col = (w_off + (x * stride)) - padd;\n      if ((((im_row < 0) || (im_col < 0)) || (im_row >= in_h)) || (im_col >= in_w))\n      {\n        continue;\n      }\n      else\n      {\n        int im_index = im_col + (in_w * (im_row + (in_h * im_chan)));\n        int col_index = (((c * col_h) + y) * col_w) + x;\n        out[im_index] += cols[col_index];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/machadoprx/CoolConvNN/image/1"}
{"code": "for (i = 0; i < N; i++)\n  a[i] = 2 * i;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mohamed/openmp_mpi_examples/parallel_for/0"}
{"code": "for (i = 0; i < 73; i++)\n{\n  if (l == (-1))\n  {\n    n = 1;\n    c++;\n  }\n  else\n    if (l == (i - 1))\n    n++;\n  else\n    abort();\n\n\n  l = i;\n}\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/monotonic-1/2"}
{"code": "for (v = 0; v < graphAdjArrayList->num_vertices; ++v)\n{\n  pCrawl = &graphAdjArrayList->vertices[v];\n  if (pCrawl->outNodes)\n    freeEdgeList(pCrawl->outNodes);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjArrayList/4"}
{"code": "for (int i = 0; i < mpi_size; i++)\n  if (i != mpi_rank)\n  do_check_and_send(i);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/7"}
{"code": "for (int i = 0; i < matrix_size; i++)\n{\n  cout << \"\\n\";\n  for (int j = 0; j < matrix_size; j++)\n  {\n    (cout << a[i][j]) << \"\\t\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArlindHajdari/StencilCode/StencilCode/stencil/0"}
{"code": "for (i = 0; i < chunksize; i++)\n{\n  int cabinet_num = result[i];\n  for (j = 0; j < Number_Subjects; j++)\n  {\n    cabinet[cabinet_num][j] += doc[i][j];\n  }\n\n  cabinet[cabinet_num][Number_Subjects]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/13"}
{"code": "for (int i = 0; i < max_node; i++)\n{\n  int j = 0;\n  while (j < Outlinks[i].size())\n  {\n    int index = Outlinks[i][j];\n    double outlinksize = Outlinks[index].size();\n    double base = 1 / outlinksize;\n    if (M[i][index] == 0)\n    {\n      M[i][index] = base;\n    }\n\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Riddle4045/OpenMP-PageRank---OpenMPI_reducer/code/task1/0"}
{"code": "for (i = 0; i < (N * NN); i++)\n{\n  Res[i] = -1;\n  CUs[i] = -2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/Threads1xxx/Threads1xxx/2"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int jj = 0; jj < (N + 2); jj++)\n  {\n    for (int ii = 0; ii < (N + 2); ii++)\n    {\n      result = evaluate_array3d(array3d_1, N, ii, jj, kk) + evaluate_array3d(array3d_2, N, ii, jj, kk);\n      fill_array3d(buffer, N, ii, jj, kk, result);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(result)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/22"}
{"code": "for (row = rowStart; row < rowEnd; row++)\n{\n  *(current + (row * 1000)) = 0;\n  *((current + ((row + 1) * 1000)) - 1) = 0;\n  *(next + (row * 1000)) = 0;\n  *((next + ((row + 1) * 1000)) - 1) = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShaunJorstad/Hybrid-parallelized-thermal-conduction/jacobiHybrid/4"}
{"code": "for (int x = 0; x < gridSize; x++)\n{\n  float val = binSize * x;\n  if (x < (gridSize - 1))\n    fprintf(f, \"%f,\", val);\n  else\n    fprintf(f, \"%f\\n\", val);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jarreddebeer/cuda-median-filter/cuda-files/hpc.omp/0"}
{"code": "for (i = 0; i < TERMS; i++)\n{\n  sin += (pow(-1, i) * pow(rad, (2 * i) + 1)) / fact((2 * i) + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/7"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  sum[id].val += x[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/2"}
{"code": "for (i_imopVar110 = 0; i_imopVar110 < grid_points[0]; i_imopVar110++)\n{\n  for (j_imopVar111 = 0; j_imopVar111 < grid_points[1]; j_imopVar111++)\n  {\n    for (k_imopVar112 = 0; k_imopVar112 < grid_points[2]; k_imopVar112++)\n    {\n      rho_inv_imopVar136 = 1.0 / u[i_imopVar110][j_imopVar111][k_imopVar112][0];\n      rho_i[i_imopVar110][j_imopVar111][k_imopVar112] = rho_inv_imopVar136;\n      us[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][1] * rho_inv_imopVar136;\n      vs[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][2] * rho_inv_imopVar136;\n      ws[i_imopVar110][j_imopVar111][k_imopVar112] = u[i_imopVar110][j_imopVar111][k_imopVar112][3] * rho_inv_imopVar136;\n      square[i_imopVar110][j_imopVar111][k_imopVar112] = (0.5 * (((u[i_imopVar110][j_imopVar111][k_imopVar112][1] * u[i_imopVar110][j_imopVar111][k_imopVar112][1]) + (u[i_imopVar110][j_imopVar111][k_imopVar112][2] * u[i_imopVar110][j_imopVar111][k_imopVar112][2])) + (u[i_imopVar110][j_imopVar111][k_imopVar112][3] * u[i_imopVar110][j_imopVar111][k_imopVar112][3]))) * rho_inv_imopVar136;\n      qs[i_imopVar110][j_imopVar111][k_imopVar112] = square[i_imopVar110][j_imopVar111][k_imopVar112] * rho_inv_imopVar136;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/7"}
{"code": "forwardSub(x2, b, lwr, n)\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clamslam12/LUdecomposition/ludecomp/9"}
{"code": "for (size_t i = 0; i < KERNEL_HEIGHT; i++)\n  for (size_t j = 0; j < KERNEL_WIDTH; j++)\n{\n  output.kernel[i][j] = 1.f;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/blurrifier-openmp/main/3"}
{"code": "for (j = 0; j < (seq_num - 1); j++)\n{\n  data[((tid * seq_num) + j) + 1] += data[(tid * seq_num) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle0/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 5))\n    abort();\n\n\n  if (a[i] != (i + 5))\n    abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr39154/8"}
{"code": "for (int pm = 0; pm < NumOptimizables; pm++)\n  URV[pm] *= smpinv;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/3"}
{"code": "for (int u = 0; u < nnz; u++)\n{\n  int i = Ti[u];\n  int j = Tj[u];\n  double x = Tx[u];\n  colIndex[w[i]] = j;\n  values[w[i]] = x;\n  w[i]++;\n  if (i != j)\n  {\n    colIndex[w[j]] = i;\n    values[w[j]] = x;\n    w[j]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/10"}
{"code": "for (int i = 0; i < size; i++)\n{\n  x[i] = min;\n  y[i] = (((((((da * pow(min, 7)) + (db * pow(min, 6))) + (dc * pow(min, 5))) + (dd * pow(min, 4))) + (de * pow(min, 3))) + (df * pow(min, 2))) + (dg * min)) + dh;\n  min += (xRangeMax - xRangeMin) / 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/80"}
{"code": "for (j = ilow; j < ihigh; j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    v[k] = 0.0;\n    iv[k] = -1;\n  }\n\n  nzloc[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/23"}
{"code": "for (int i = 0; i < N; i++)\n{\n  y[i] = (alpha * x[i]) + (beta * z[i]);\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  rowel = row_ptr[i + 1] - row_ptr[i];\n  for (j = 0; j < rowel; j++)\n  {\n    if (p_new[i] == 0)\n    {\n      p_new[col_ind[curcol]] = p_new[col_ind[curcol]] + (val[curcol] * p[i]);\n    }\n    else\n    {\n      p_new[col_ind[curcol]] = p_new[col_ind[curcol]] + (val[curcol] * p_new[i]);\n    }\n\n    curcol++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leankyr/Parallel_Pagerank/Final/Implementation_2/main2/8"}
{"code": "for (int i = 0; i < (V - 1); i++)\n{\n  for (int j = 0; j < E; j++)\n  {\n    int u = graph.edges[j].u;\n    int w = graph.edges[j].w;\n    int v = graph.edges[j].v;\n    if ((arrD[u] != infinity) && (arrD[v] > (arrD[u] + w)))\n    {\n      arrD[v] = arrD[u] + w;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ryanmueller28/OpenMP-BellmanFord/bf/1"}
{"code": "for (register int l = 0; l < (lmax + 1); l++)\n{\n  a1[l + lmax] = (factor / lambda) * bessel_Jn_array[l];\n  a1[l + lmax] *= (double) l;\n  a2[l + lmax] = (factor * I) * bessel_Jn_prime_array[l];\n  a3[l + lmax] = (((kperp / omega) * ((vpar * df0_dvperp(vpar, vperp)) - (vperp * df0_dvpar(vpar, vperp)))) / lambda) * bessel_Jn_array[l];\n  a3[l + lmax] *= (double) l;\n  a3[l + lmax] += df0_dvpar(vpar, vperp) * bessel_Jn_array[l];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/21"}
{"code": "for (i = 0; i < Cx->n; i++)\n  m_set_val(Cx, 0, i, m_get_val(Cx, 1, i) + (dt * v_get_val(dCx, i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/33"}
{"code": "for (i = 0; i <= (grid_points[0] - 1); i += 1)\n{\n  for (j = 0; j <= (grid_points[1] - 1); j += 1)\n  {\n    for (k = 0; k <= (grid_points[2] - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        forcing[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/7"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << 23) - 1)))\n  {\n    switch ('A')\n    {\n      case 'S':\n        if (i <= 2)\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n      else\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n\n        break;\n\n      case 'W':\n        if (i < 2)\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n      else\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n      else\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n      else\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n      else\n      {\n        if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n        {\n          printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n        }\n        else\n        {\n          passed_verification++;\n        }\n\n      }\n\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/9"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&s_fwd, 0);\n  }\n\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_fwd, 0);\n    gettimeofday(&s_bck_out, 0);\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_out, 0);\n    gettimeofday(&s_bck_hid, 0);\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/19"}
{"code": "for (__pyx_t_4 = __pyx_v_src->shape; __pyx_t_4 < __pyx_t_3; __pyx_t_4++)\n{\n  __pyx_t_2 = __pyx_t_4;\n  __pyx_v_shape = __pyx_t_2[0];\n  __pyx_v_size = __pyx_v_size * __pyx_v_shape;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/15"}
{"code": "for (i = 0; i < 100000000; i++)\n  sum += array[i];\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/takashift/experimentB_OpenMP/reduction/0"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  for (size_t j = 0; j < m; j++)\n  {\n    (cout << ptrMatrix[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/2"}
{"code": "for (i = 1; i < (1 << (M - 16)); i++)\n  xx[i] = xx[i - 1] + (2 * (1 << 16));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/EP/ep/3"}
{"code": "for (int i = 0; i < ((N - M) + 1); ++i)\n  stds[i] = ((float) rand()) / ((float) RAND_MAX);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/keogh-omp/main/2"}
{"code": "for (i = 1; i < n; i++)\n  psum2 += func(from + (h * i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Simpson/5"}
{"code": "for (int i = 0; i < 5; i++)\n  arr[i] = 5 - i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/bubble_sort_openmp/1"}
{"code": "for (i = 0; i < (bitmask + 1); ++i)\n{\n  vertex_count[digits / granularity][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\" %f \\t\", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/8"}
{"code": "for (int i = 0; i < 3465; ++i)\n{\n  if (output_occurance[i])\n  {\n    index2str(temp, i);\n    temp[5] = ' ';\n    i2str_count = i2str(&temp[6], output_occurance[i]);\n    memcpy(&out_string[size], temp, 6 + i2str_count);\n    size += 6 + i2str_count;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filhei/OpenMP/cell_distance/7"}
{"code": "for (int i = 0; i < (NODE + 1); i++)\n  free(path[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/actumn/dijkstra-openmp/dijkstra/12"}
{"code": "for (int i = 0; i < (1024 * 1024); ++i)\n{\n  floatvector pixel = {.x = i % 1024, .y = i / 1024};\n  color renderColor = {.red = 0.f, .green = 0.f, .blue = 0.f};\n  float shortestDistance = INFINITY;\n  float weights = 0.f;\n  int hitsSatellite = 0;\n  float red = 0.0f;\n  float green = 0.0f;\n  float blue = 0.0f;\n  for (int j = 0; j < 64; ++j)\n  {\n    floatvector difference = {.x = pixel.x - satelites[j].position.x, .y = pixel.y - satelites[j].position.y};\n    float distance = sqrt((difference.x * difference.x) + (difference.y * difference.y));\n    if (distance < 3.16f)\n    {\n      renderColor.red = 1.0f;\n      renderColor.green = 1.0f;\n      renderColor.blue = 1.0f;\n      hitsSatellite = 1;\n      break;\n    }\n    else\n    {\n      float weight = 1.0f / (((distance * distance) * distance) * distance);\n      weights += weight;\n      if (distance < shortestDistance)\n      {\n        shortestDistance = distance;\n        renderColor = satelites[j].identifier;\n      }\n\n      red += satelites[j].identifier.red * weight;\n      green += satelites[j].identifier.green * weight;\n      blue += satelites[j].identifier.blue * weight;\n    }\n\n  }\n\n  if (!hitsSatellite)\n  {\n    renderColor.red += (red / weights) * 3.0f;\n    renderColor.green += (green / weights) * 3.0f;\n    renderColor.blue += (blue / weights) * 3.0f;\n  }\n\n  pixels[i] = renderColor;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/1"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  for (j = 0; j < NCB; j++)\n  {\n    junction = 0.0;\n    for (k = 0; k < NCA; k++)\n    {\n      junction += a_[(i * NCA) + k] * bT[(j * NCA) + k];\n    }\n\n    c_[(i * NCB) + j] = junction;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/mm_v4/0"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  for (i = 0; i < length; i++)\n  {\n    t_sim[i] = 0.0;\n    t_obs[i] = lOut[i][rowcol];\n  }\n\n  fourier(t_sim, t_obs, length, harmonic_number);\n  for (i = 0; i < length; i++)\n  {\n    lOut[i][rowcol] = t_sim[i];\n  }\n\n  if (rowcol == 538)\n  {\n    printf(\"FourierData,\");\n    for (i = 0; i < length; i++)\n    {\n      printf(\"%f,\", t_sim[i]);\n    }\n\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(l, lOut, length, harmonic_number, N) private (rowcol,t_obs,t_sim,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_fourier_smooth/main_fourier/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = (i + 0.5) * h;\n  integral += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "        #pragma omp for reduction(+:integral) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Homagn/openmp_cpp_course/Homagni_assn5/Task1/OMP_PI/main/1"}
{"code": "for (i = 1; i < n; i++)\n{\n  int k;\n  int rev = 0;\n  int inp = i;\n  for (k = 0; k < log2_of_n; k++)\n  {\n    rev = (rev << 1) | (inp & 1);\n    inp >>= 1;\n  }\n\n  if (rev <= i)\n    continue;\n\n  temp = xReal[i];\n  xReal[i] = xReal[rev];\n  xReal[rev] = temp;\n  temp = xImg[i];\n  xImg[i] = xImg[rev];\n  xImg[rev] = temp;\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i, temp) shared(n, xReal, xImg, log2_of_n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krishnakinnal/FFT-in-Parallel/fft/1"}
{"code": "for (int j = 0; j < rank; j++)\n{\n  for (int i = 0; i < rank; i++)\n    printf(\"%.2f \", A[(i * rank) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/5"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    zero_5d_array_kernel(&((double *) arg0.data)[5 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[1].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/zero_5d_array_kernel_kernel/0"}
{"code": "for (currentRow = 1; currentRow < (sizeUniverseX - 1); currentRow++)\n{\n  for (currentColumn = 1; currentColumn < (sizeUniverseY - 1); currentColumn++)\n  {\n    neighborsAlive = 0;\n    for (tempCounterRow = currentRow - 1; tempCounterRow <= (currentRow + 1); tempCounterRow++)\n    {\n      for (tempCounterColumn = currentColumn - 1; tempCounterColumn <= (currentColumn + 1); tempCounterColumn++)\n      {\n        if ((tempCounterRow == currentRow) && (tempCounterColumn == currentColumn))\n          continue;\n\n        if (master[tempCounterRow][tempCounterColumn] == '#')\n          neighborsAlive++;\n\n      }\n\n    }\n\n    if (master[currentRow][currentColumn] == '.')\n    {\n      if (neighborsAlive == 3)\n        slave[currentRow][currentColumn] = '#';\n      else\n        slave[currentRow][currentColumn] = '.';\n\n    }\n    else\n    {\n      if (neighborsAlive < 2)\n      {\n        slave[currentRow][currentColumn] = '.';\n      }\n      else\n        if (neighborsAlive > 3)\n      {\n        slave[currentRow][currentColumn] = '.';\n      }\n      else\n      {\n        slave[currentRow][currentColumn] = '#';\n      }\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(currentRow, currentColumn, tempCounterRow, tempCounterColumn, neighborsAlive)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YiannisN/GameOfLife_C_Threads_OpenMP/OpenMP/src/angel/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  lhs[0][i][j][k] = 0.0;\n  lhs[1][i][j][k] = ((-dttx2) * cv[i - 1]) - (dttx1 * rhon[i - 1]);\n  lhs[2][i][j][k] = 1.0 + (c2dttx1 * rhon[i]);\n  lhs[3][i][j][k] = (dttx2 * cv[i + 1]) - (dttx1 * rhon[i + 1]);\n  lhs[4][i][j][k] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/4"}
{"code": "for (int i = 0; i < 10000; ++i)\n  printf(\"%d \", v[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elard28/OpenMPparalelos/e3/2"}
{"code": "for (int i = 0; i < matrixN; i++)\n{\n  for (int j = 0; j < matrixN; j++)\n  {\n    Mat[i][j] = pow(-1, rand() % 2) * (rand() % 1000);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/1/1/2"}
{"code": "for (int d = 0; d < D; d++)\n{\n  dim[d] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/4"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jaccoudb/OpenMP/main_1/0"}
{"code": "for (int i = 0; i < ARRAY_ROWS; i++)\n{\n  for (int j = 0; j < ARRAY_COLS; j++)\n  {\n    double comp = 0.;\n    for (int k = 0; k < ARRAY_COLS; k++)\n    {\n      comp += (*((a + (i * ARRAY_COLS)) + k)) * (*((b + (k * ARRAY_COLS)) + j));\n    }\n\n    *((c + (i * ARRAY_COLS)) + j) += comp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/ece563/exam1/OpenMP/seq_mm/0"}
{"code": "for (int i = 0; i < ny; i++)\n{\n  int k = i * nx;\n  for (int j = 0; j < nx; j++, k++, cmap++, cm++)\n  {\n    *cm = COST_OBS;\n    if ((((i < 7) || (i > (ny - 8))) || (j < 7)) || (j > (nx - 8)))\n      continue;\n\n    int v = *cmap;\n    if (v < COST_OBS_ROS)\n    {\n      v = COST_NEUTRAL + (COST_FACTOR * v);\n      if (v >= COST_OBS)\n        v = COST_OBS - 1;\n\n      *cm = v;\n    }\n    else\n      if (v == COST_UNKNOWN_ROS)\n    {\n      v = COST_OBS - 1;\n      *cm = v;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/2"}
{"code": "for (i = 0; i < order; i++)\n{\n  sprintf(temp, \"%s/FACTOR%d\", ResultPath, i);\n  FILE *fin = fopen(temp, \"w\");\n  for (j = 0; j < dimensionality[i]; j++)\n  {\n    for (k = 0; k < Core_size[i]; k++)\n    {\n      if (k == (Core_size[i] - 1))\n        fprintf(fin, \"%e\", FactorM[((i * mult) + (j * Core_size[i])) + k]);\n      else\n        fprintf(fin, \"%e\\t\", FactorM[((i * mult) + (j * Core_size[i])) + k]);\n\n    }\n\n    fprintf(fin, \"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/14"}
{"code": "for (int i = 0; i < pre.size(); i++)\n{\n  for (int j = 0; j < temp[i].size(); j++)\n  {\n    res[pre[i] + j] = temp[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankitsultana/parallel-df/src/populate_htables/1"}
{"code": "for (c1 = (0 > ni) ? (0) : (ni); c1 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/75"}
{"code": "for (int jj = 0; jj < (N + 2); jj += 2)\n{\n  for (int ii = 0; ii < (N + 2); ii += 2)\n  {\n    fill_array3d(new_X, new_N, ii / 2, jj / 2, 0, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/6"}
{"code": "for (int i = 0; i < size_n; i++)\n{\n  dataLeft[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TollisK/Jacobi-Method-Parallel-Programming/parallelJacobi_mp/3"}
{"code": "for (int i = 0; i < imageFileHeader.maxImages; i++)\n{\n  Image img;\n  getImage(imageFile, &img);\n  uint8_t lbl = getLabel(labelFile);\n  feedForward(network, &img);\n  uint8_t classification = getClassification(&network->outputLayer);\n  if (classification != lbl)\n  {\n    errCount++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/8"}
{"code": "for (i = 0; i < (nrows / 2); i++)\n{\n  j = index[i];\n  index[i] = index[(nrows - 1) - i];\n  index[(nrows - 1) - i] = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/28"}
{"code": "for (int i = 0; i < data.size(); i++)\n{\n  (cout << data[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wszymkowski/large-scale-computing-course/primes_parallel/1"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  resid = ((((ax * (uold[(i - 1) + (m * j)] + uold[(i + 1) + (m * j)])) + (ay * (uold[i + (m * (j - 1))] + uold[i + (m * (j + 1))]))) + (b * uold[i + (m * j)])) - f[i + (m * j)]) / b;\n  u[i + (m * j)] = uold[i + (m * j)] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n", "pragma": "omp for reduction(+:error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_Jacobi/c_jacobi03/0"}
{"code": "for (i = 0; i < n; ++i)\n  res[i] = data[i];\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivanker/ompsort/msort/0"}
{"code": "for (int point_id = 0; point_id < npoints; point_id++)\n{\n  float min_dist = FLT_MAX;\n  for (int i = 0; i < nclusters; i++)\n  {\n    float dist = 0;\n    float ans = 0;\n    for (int l = 0; l < nfeatures; l++)\n    {\n      ans += (feature_swap[(l * npoints) + point_id] - cluster[(i * nfeatures) + l]) * (feature_swap[(l * npoints) + point_id] - cluster[(i * nfeatures) + l]);\n    }\n\n    dist = ans;\n    if (dist < min_dist)\n    {\n      min_dist = dist;\n      index = i;\n    }\n\n  }\n\n  membership_OCL[point_id] = index;\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/kmeans-omp/cluster/1"}
{"code": "for (i = length - 2; i >= 0; --i)\n{\n  str[i + 1] = str[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DragosUnguru/ParallelFrameworksAnalyze/parallel_encoder/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if ((i % 2) == 0)\n  {\n    out_real[i] = in_real[i];\n    out_imag[i] = in_imag[i];\n  }\n  else\n  {\n    out_real[i] = -in_real[i];\n    out_imag[i] = -in_imag[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lsqt-omp/vector/7"}
{"code": "for (int si = 0; si < sendcnt; si++)\n{\n  int error_code = stat[si].MPI_ERROR;\n  if (error_code != MPI_SUCCESS)\n  {\n    stopFlag = true;\n    char error_string[100];\n    int length_of_error_string;\n    int error_class;\n    MPI_Error_class(error_code, &error_class);\n    MPI_Error_string(error_class, error_string, &length_of_error_string);\n    dprintf(\"MPI_Waitall error at %d%s\\n\", si, error_string);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/3"}
{"code": "for (c1 = 0; c1 <= c0; c1 += 1)\n  for (c3 = ((16 * c0) + (16 * c1)) + 5; c3 <= ((((((((2 * n) - (16 * c0)) + (16 * c1)) - 1) < ((n + (16 * c1)) + 17)) ? ((((2 * n) - (16 * c0)) + (16 * c1)) - 1) : ((n + (16 * c1)) + 17)) < (((16 * c0) + (16 * c1)) + 50)) ? ((((((2 * n) - (16 * c0)) + (16 * c1)) - 1) < ((n + (16 * c1)) + 17)) ? ((((2 * n) - (16 * c0)) + (16 * c1)) - 1) : ((n + (16 * c1)) + 17)) : (((16 * c0) + (16 * c1)) + 50)); c3 += 1)\n  for (c4 = ((c0 - c1) > ((((-2) * c1) + ((c3 - 2) / 16)) - 2)) ? (c0 - c1) : ((((-2) * c1) + ((c3 - 2) / 16)) - 2); c4 <= ((((n - 2) / 16) < ((-c1) + (((((16 * c0) + (16 * c1)) + c3) + 12) / 32))) ? ((n - 2) / 16) : ((-c1) + (((((16 * c0) + (16 * c1)) + c3) + 12) / 32))); c4 += 1)\n  for (c6 = (((((((16 * c1) + 2) > ((-n) + c3)) ? ((16 * c1) + 2) : ((-n) + c3)) > ((((-8) * c4) + (c3 / 2)) - 7)) ? ((((16 * c1) + 2) > ((-n) + c3)) ? ((16 * c1) + 2) : ((-n) + c3)) : ((((-8) * c4) + (c3 / 2)) - 7)) > (((((-8) * c0) + (8 * c1)) + ((c3 + 1) / 2)) - 8)) ? ((((((16 * c1) + 2) > ((-n) + c3)) ? ((16 * c1) + 2) : ((-n) + c3)) > ((((-8) * c4) + (c3 / 2)) - 7)) ? ((((16 * c1) + 2) > ((-n) + c3)) ? ((16 * c1) + 2) : ((-n) + c3)) : ((((-8) * c4) + (c3 / 2)) - 7)) : (((((-8) * c0) + (8 * c1)) + ((c3 + 1) / 2)) - 8); c6 <= ((((((16 * c1) + 17) < ((c3 - (16 * c4)) - 2)) ? ((16 * c1) + 17) : ((c3 - (16 * c4)) - 2)) < (((((-8) * c0) + (8 * c1)) + ((c3 + 1) / 2)) - 1)) ? ((((16 * c1) + 17) < ((c3 - (16 * c4)) - 2)) ? ((16 * c1) + 17) : ((c3 - (16 * c4)) - 2)) : (((((-8) * c0) + (8 * c1)) + ((c3 + 1) / 2)) - 1)); c6 += 1)\n  for (c10 = ((16 * c4) > (c3 - (2 * c6))) ? (16 * c4) : (c3 - (2 * c6)); c10 <= ((((16 * c4) + 15) < ((c3 - c6) - 2)) ? ((16 * c4) + 15) : ((c3 - c6) - 2)); c10 += 1)\n  m[c3 - (2 * c6)][((c3 - (2 * c6)) + c6) - 1] = minsq((m[c3 - (2 * c6)][c10] + m[c10 + 1][((c3 - (2 * c6)) + c6) - 1]) + ((p[(c3 - (2 * c6)) - 1] * p[c10]) * p[((c3 - (2 * c6)) + c6) - 1]), m[c3 - (2 * c6)][((c3 - (2 * c6)) + c6) - 1], c3 - (2 * c6), ((c3 - (2 * c6)) + c6) - 1, c10);\n\n\n\n\n\n", "pragma": "omp parallel for private(c3,c1,c4,c10,c6) shared(c0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcm/mmc/4"}
{"code": "for (i = 0; i < Y; i++)\n{\n  for (j = 0; j < X; j++)\n  {\n    out_matrix[i] += input_matrix[j] * weights[i][j];\n  }\n\n  out_matrix[i] += biases[i];\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miloshunter/MLP-OpenCL/c_implementation/simple_mlp/0"}
{"code": "for (i = 0; i < (test_dataframe.size() - 1); i++)\n{\n  res = model.predict(test_dataframe[i], k);\n  if (test_labels[i] == res)\n    match++;\n\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:match)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OnurArdaB/k-NearestNeighbor/omp/sample/main/2"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  for (j = 0; j < 10000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      D[(i * 10000) + j] = 0;\n    }\n    else\n    {\n      D[(i * 10000) + j] = (((float) i) * (j + 2)) / 10000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanafacion/Paralelas/Exercicio12/code-t12/4"}
{"code": "for (i = ntasks - 1; i < (10000 / 8); i++)\n{\n  int source = master_receive_result(numbers);\n  master_send_job(numbers, i * 8, source);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fgrehm/pucrs-mpi-openmp-master_slave/mpi_master_slave/3"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  for (wJ = 0; wJ < BIGN_MATR; wJ++)\n  {\n    fprintf(stdout, \"%.1f \", aMatr[wI][wJ]);\n  }\n\n  fprintf(stdout, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/14"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n{\n  inputf >> mat[convert_dimension_2D_1D(i, j, N)];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sunnlo/BellmanFord/openmp_bellman_ford/0"}
{"code": "for (int i = 0; i < 100000; i++)\n{\n  rnum = rand() % 1000000;\n  arr[i] = rnum;\n  temp[i] = arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Matt-st/Parallel_shell_sort/ShellOpenMP/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    sparse_A[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/3"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  for (int j = 1; j <= n; j++)\n  {\n    a[i][j] = a[i][j + 2] + a[i + 1][j - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab8/lab8/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  a[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task11/0"}
{"code": "for (i = numNodes - 1; i > (-1); --i)\n{\n  if (x[i] <= 0)\n  {\n    numNodes2--;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/minusminus-orig-yes/0"}
{"code": "for (int i = (a->size / 2) - 1; i < (a->size - 1); i++)\n{\n  if (b->tab[i] < a->tab[i])\n    b->tab[i - ((a->size / 2) - 1)] = a->tab[i];\n  else\n    b->tab[i - ((a->size / 2) - 1)] = b->tab[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/9"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->atomDegree[v] = graph->vertices->out_degree[v];\n  stats->atomChild[v] = 4294967295U;\n  stats->atom[v].pair.degree = graph->vertices->out_degree[v];\n  stats->atom[v].pair.child = 4294967295U;\n  stats->sibling[v] = 4294967295U;\n  stats->dest[v] = v;\n  stats->weightSum[v] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/3"}
{"code": "for (int i = 1; i < (WIN_SIZE - 1); i++)\n{\n  map[i][0] = 20.0;\n  map[0][i] = 20.0;\n  map[i][WIN_SIZE - 1] = 20.0;\n  map[WIN_SIZE - 1][i] = 20.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/heat-dissipation/programs/openmp/src/main/0"}
{"code": "for (unsigned i = 0; i < width; i++)\n{\n  for (unsigned j = 0; j < height; j++)\n  {\n    if (a[(i * width) + j] != b[(i * width) + j])\n    {\n      printf(\"ERROR: Result mismatch in Row %u, Column %u!\\n\", j, i);\n      exit(-1);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/mm-large/mm-large/2"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  printf(\"%d \", a[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_gpu_target/dataracebench/DRB046-doall2-orig-no/1"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  if (cast_cf->vec_[i] == 1)\n  {\n    cidx[i] = nc++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/109"}
{"code": "for (i = 0; i < numf1s; i++)\n  for (j = 0; j < numf2s; j++)\n  if (j == (numf2s - 1))\n  printf(\" %8.16f\\n\", tds[i][j]);\nelse\n  printf(\" %8.16f \", tds[i][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/15"}
{"code": "for (int kk = N + 1; kk >= 0; kk--)\n{\n  for (int jj = 0; jj < (N + 2); jj++)\n  {\n    (cout << evaluate_array3d(array3d, N, index, jj, kk)) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/14"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  a[i] = b[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikejcooper/OpenMP---Examples/openmp/example3/numa-bad/0"}
{"code": "for (j = 0; j < m; j++)\n{\n  R[i] = R[i] + (V[j] * A[i][j]);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:R[i]) if(n>425 && m>425)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mikomister/openmp_tasks/Tasks6-15/Task8/5"}
{"code": "for (int i = 0; i < j; ++i)\n{\n  processwork(nodelist[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_cpp/1"}
{"code": "for (int i = 0; i < n; i++)\n  score[i] = expf(dot_product[i]) / exp_sum[0];\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/attention-omp/main/0"}
{"code": "for (j = adj[ver].begin(); j != adj[ver].end(); ++j)\n{\n  int vv = *j;\n  if (visited[vv] == 0)\n  {\n    visited[vv] = 1;\n    Q.push(vv);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souravmohapatra/parallel_bfs/bfs_parallel/2"}
{"code": "for (exp = 0; exp < 22; exp++)\n{\n  start = _rdtsc();\n  mult_mat_vect3(M1, b, a);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/16"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    if (rowval[j] != 0.0)\n    {\n      rowval[j] = .1 + sign(rowval[j], powf(fabs(rowval[j]), .75));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/9"}
{"code": "for (int i = mid + 1; i < end; i++)\n  if (compare((void *) (&data[i]), (void *) (&data[mid])) < 0)\n  fail++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/08_quicksort.v0/3"}
{"code": "for (int from = 0; from < small_n; ++from)\n{\n  for (int to = 0; to < small_n; ++to)\n  {\n    printf(\"%05d \", distances_small[to + (small_n * from)]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkestene/tsp/openmp_target/tsp/1"}
{"code": "for (int i = 0; i < current_contig_length; ++i)\n{\n  current_contig_numeric[i] = table[(int) contig[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erictang000/GPU-BSW-Work-Stealing/driver/1"}
{"code": "for (j = 0; j > 6; j++)\n{\n  i = j + i;\n  printf(\"Thread number is = %d ,i = %d \\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for firstprivate(i) schedule(static,3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gunjapandey/Introduction-to-OpenMP/l5_prog2_part1/0"}
{"code": "for (int ck = 1; ck <= k; ++ck)\n{\n  C[cn][ck] = C[cn - 1][ck - 1] + C[cn - 1][ck];\n  C[cn][ck] %= modref;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/architkarandikar/OpenMP-Testing/nCk/nCk_par1/2"}
{"code": "for (i = 0; i < 16; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"Loop 2 - (%d) gets iteration %d\\n\", id, i);\n}\n\n", "pragma": "omp for schedule(dynamic) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/5.ordered/1"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    C[((i + (SIZE / 2)) * SIZE) + j] *= 2123.0f;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      C[((i + (SIZE / 2)) * SIZE) + j] += (32412.0f * A3[(i * SIZE) + k]) * B[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS) depend(in: b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/GEMM/gemmPL/2"}
{"code": "for (int i = 0; i < nc; i++)\n  d_c[i] = c0 + (inc * i);\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cmp-omp/main/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  fac1 = 1.0 / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i1][j][k] = lhs[n + 2][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i1][j][k] = lhs[n + 3][i1][j][k] - (lhs[n + 1][i1][j][k] * lhs[n + 4][i][j][k]);\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i1][j][k] = rhs[m][i1][j][k] - (lhs[n + 1][i1][j][k] * rhs[m][i][j][k]);\n  }\n\n  fac2 = 1. / lhs[n + 2][i1][j][k];\n  for (m = 0; m < 3; m++)\n  {\n    rhs[m][i1][j][k] = fac2 * rhs[m][i1][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(m ,k ,fac1 ,fac2 ,i ,i1 ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/163"}
{"code": "for (int x = 0; x < image_height; ++x)\n{\n  for (int y = 0; y < image_width; ++y)\n  {\n    grad_x = 0;\n    grad_y = 0;\n    if ((x == (image_height - 1)) || (y == (image_width - 1)))\n      grad = 0;\n    else\n    {\n      for (int i = 0; i <= 1; i++)\n      {\n        for (int j = 0; j <= 1; j++)\n        {\n          grad_x += inputImage[x + i][y + j] * maskX[i][j];\n        }\n\n      }\n\n      for (int i = 0; i <= 1; i++)\n      {\n        for (int j = 0; j <= 1; j++)\n        {\n          grad_y += inputImage[x + i][y + j] * maskY[i][j];\n        }\n\n      }\n\n      grad = (int) sqrt((grad_x * grad_x) + (grad_y * grad_y));\n    }\n\n    outputImage[x][y] = (grad <= 255) ? (grad) : (255);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static, chunkSize) shared(outputImage,message, chunkSize) private( grad, grad_x, grad_y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/usaruner/OpenMP/ImplementationA-tester/2"}
{"code": "for (int i = 0; i < (N / 4); i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/7"}
{"code": "for (int j = 0; j < log2(seq_len); j++)\n{\n  right_shift(s_arr, q_arr, seq_len, pow(2, j));\n  for (int k = 0; k < seq_len; k++)\n  {\n    s_arr[k] = s_arr[k] + q_arr[k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/1"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 2)\n    {\n      int pp = IDX(i, j, k);\n      Dzu[pp] = (((u[pp - (2 * n)] - (8.0 * u[pp - n])) + (8.0 * u[pp + n])) - u[pp + (2 * n)]) * idz_by_12;\n      Dzu[pp + 1] = (((u[(pp + 1) - (2 * n)] - (8.0 * u[(pp + 1) - n])) + (8.0 * u[(pp + 1) + n])) - u[(pp + 1) + (2 * n)]) * idz_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/4"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA256][32];\n  int i;\n  if (cur_salt->type == 0)\n  {\n    for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n      pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  }\n  else\n    if (cur_salt->type == 1)\n  {\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    yescrypt_params_t params = {.N = cur_salt->N, .r = cur_salt->r, .p = cur_salt->p};\n    for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    {\n      if (yescrypt_kdf(0, &local[t], (const uint8_t *) saved_key[index + i], strlen(saved_key[index + i]), (const uint8_t *) cur_salt->salt, strlen((const char *) cur_salt->salt), &params, master[i], 32))\n      {\n        failed = (errno) ? (errno) : (EINVAL);\n      }\n\n    }\n\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    if (new_keys)\n    {\n      for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n      {\n        pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), (unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), 2000, master[i], 16, 0);\n      }\n\n      for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n      {\n        memcpy(saved_presale[index + i], master[i], 32);\n      }\n\n    }\n    else\n    {\n      for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n        memcpy(master[i], saved_presale[index + i], 32);\n\n    }\n\n  }\n\n\n\n  if ((cur_salt->type == 0) || (cur_salt->type == 1))\n  {\n    for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    {\n      Keccak_HashInstance hash;\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, master[i] + 16, 16 * 8);\n      Keccak_HashUpdate(&hash, cur_salt->ct, cur_salt->ctlen * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    {\n      AES_KEY akey;\n      Keccak_HashInstance hash;\n      unsigned char iv[16];\n      unsigned char seed[4096];\n      int padbyte;\n      int datalen;\n      AES_set_decrypt_key(master[i], 128, &akey);\n      memcpy(iv, cur_salt->encseed, 16);\n      AES_cbc_encrypt(cur_salt->encseed + 16, seed, cur_salt->eslen - 16, &akey, iv, AES_DECRYPT);\n      if (check_pkcs_pad(seed, cur_salt->eslen - 16, 16) < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      padbyte = seed[(cur_salt->eslen - 16) - 1];\n      datalen = (cur_salt->eslen - 16) - padbyte;\n      if (datalen < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, seed, datalen * 8);\n      Keccak_HashUpdate(&hash, dpad.data, 1 * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ethereum_fmt_plug/1"}
{"code": "for (int i = 0; i < length; i++)\n{\n  array[i] = rand() % 20;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex10/0"}
{"code": "for (int k = 0; k < a.a; ++k)\n  ++this->a.a;\n\n", "pragma": "#pragma omp for private(a) private(this->a) private(T::a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_ast_print/0"}
{"code": "for (unsigned c = 0; c < OutCount; c++)\n{\n  ((((scsv << OutBuff[c].timestep) << OutBuff[c].posswl) << OutBuff[c].point0) << OutBuff[c].point2) << Endl();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsGaugeItem/1"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      Pworksx[LOC3D(i, j, k)] = (Pxfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pxfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n      Pworksy[LOC3D(i, j, k)] = (Pyfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pyfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n      Pworksz[LOC3D(i, j, k)] = (Pzfn[LOC4D(i, j, k, ns1)] * Parea[LOC4D(i, j, k, ns1)]) + (Pzfn[LOC4D(i - il1, j - jl1, k - kl1, ns1)] * Parea[LOC4D(i - il1, j - jl1, k - kl1, ns1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/4"}
{"code": "for (int i = 0; i < len; ++i)\n  gpuData[3] = min(gpuData[3], (T) i);\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256) reduction(min: gpuData[3])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/atomicIntrinsics-omp/main/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpsdafsfca.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/llvm-openmp/runtime/test/affinity/format/affinity_values/2"}
{"code": "for (int i = 0; i < ((int) MaxX); i++)\n{\n  for (int j = 0; j < ((int) MaxY); j++)\n  {\n    if (isTurbulenceReset && (ProblemType == SM_NS))\n    {\n      if (pJ->GetValue(i, j).isTurbulenceCond2D(TCT_Integral_Model_2D))\n        pJ->GetValue(i, j).CleanTurbulenceCond2D(TCT_Integral_Model_2D);\n\n      if (pJ->GetValue(i, j).isTurbulenceCond2D(TCT_Prandtl_Model_2D))\n        pJ->GetValue(i, j).CleanTurbulenceCond2D(TCT_Prandtl_Model_2D);\n\n      if (pJ->GetValue(i, j).isTurbulenceCond2D(TCT_Spalart_Allmaras_Model_2D))\n        pJ->GetValue(i, j).CleanTurbulenceCond2D(TCT_Spalart_Allmaras_Model_2D);\n\n      if (pJ->GetValue(i, j).isTurbulenceCond2D(TCT_k_eps_Model_2D))\n        pJ->GetValue(i, j).CleanTurbulenceCond2D(TCT_k_eps_Model_2D);\n\n      if (pJ->GetValue(i, j).isTurbulenceCond2D(TCT_Smagorinsky_Model_2D))\n        pJ->GetValue(i, j).CleanTurbulenceCond2D(TCT_Smagorinsky_Model_2D);\n\n      pJ->GetValue(i, j).SetTurbulenceCond2D(TM);\n      pJ->GetValue(i, j).dkdx = (pJ->GetValue(i, j).dkdy = (pJ->GetValue(i, j).depsdx = (pJ->GetValue(i, j).depsdy = (pJ->GetValue(i, j).S[i2d_k] = (pJ->GetValue(i, j).S[i2d_eps] = (pJ->GetValue(i, j).Src[i2d_k] = (pJ->GetValue(i, j).Src[i2d_eps] = (pJ->GetValue(i, j).mu_t = (pJ->GetValue(i, j).lam_t = 0.0)))))))));\n      pJ->GetValue(i, j).FillNode2D(0, 1);\n    }\n\n    if (pJ->GetValue(i, j).isCond2D(CT_NODE_IS_SET_2D) && (!pJ->GetValue(i, j).isCond2D(CT_SOLID_2D)))\n    {\n      num_active_nodes++;\n      if (num_active_nodes >= active_nodes_per_SubDomain)\n      {\n        ijsm.SetY(i + 1);\n        SubDomain->AddElement(&ijsm);\n        ijsm.SetX(i);\n        num_active_nodes = 0;\n      }\n\n    }\n\n  }\n\n  if ((isPrint == 1) && isVerboseOutput)\n  {\n    ((((*f_str) << \"Scan \") << ((100. * i) / MaxX)) << \"% nodes   \\r\") << flush;\n  }\n  else\n    if ((isPrint == 2) && isVerboseOutput)\n  {\n    ((((*f_str) << \"Scan \") << ((100. * i) / MaxX)) << \"% nodes   \\n\") << flush;\n  }\n\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/10"}
{"code": "for (i = 0; i < m_size; i++)\n{\n  rows_mask[i] = 0;\n  cols_mask[i] = 0;\n  boxes_mask[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/2"}
{"code": "for (j = 0; j < 200; j++)\n{\n  C[i][j] = BETA * C[i][j];\n  for (l = 0; l < 200; l++)\n  {\n    C[i][j] = C[i][j] + ((ALPHA * A[i][l]) * B[l][j]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Clark0/NSCC_OpenMP/matrix/0"}
{"code": "for (; myyb < myyt; myyb += c_inc)\n  yticks[me].push_back(myyb);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/hw2/p2/1"}
{"code": "for (int r = 0; r < k; r++)\n{\n  for (int c = 0; c < n; c++)\n  {\n    rightMat[(r * n) + c] = buf[(r * n) + c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/mpi/matrixMulti/gemm/3"}
{"code": "for (int i = 0; i < number_of_images; ++i)\n{\n  free(encoded_images[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/5"}
{"code": "for (n = 1; n < nzh; n++)\n{\n  ll = nxhyd * n;\n  l1 = (nxhyd * nz) - ll;\n  for (jj = 0; jj < 3; jj++)\n  {\n    i1 = nnxhd * nyh;\n    i0 = i1 + ll;\n    i1 += l1;\n    t1 = f[jj + i1];\n    f[jj + i1] = 0.5 * (cimagf(f[jj + i0] + t1) + (crealf(f[jj + i0] - t1) * _Complex_I));\n    f[jj + i0] = 0.5 * (crealf(f[jj + i0] + t1) + (cimagf(f[jj + i0] - t1) * _Complex_I));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/60"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  begin_timer();\n  init_energy_measure();\n  int p = 0;\n  int nobody_was_discovered = 0;\n  initialize_graph(g);\n  while (!nobody_was_discovered)\n  {\n    nobody_was_discovered = broadcast_start(g, p);\n    p++;\n  }\n\n  total_energy += total_energy_used();\n  duration += time_elapsed();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/bfs_dijkstra/3"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      if (betay[pp] > 0.0)\n      {\n        Dyu[pp] = ((((((-3.0) * u[pp - nx]) - (10.0 * u[pp])) + (18.0 * u[pp + nx])) - (6.0 * u[pp + (2 * nx)])) + u[pp + (3 * nx)]) * idy_by_12;\n      }\n      else\n      {\n        Dyu[pp] = (((((-u[pp - (3 * nx)]) + (6.0 * u[pp - (2 * nx)])) - (18.0 * u[pp - nx])) + (10.0 * u[pp])) + (3.0 * u[pp + nx])) * idy_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/15"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  temp = y_data[i];\n  for (jj = A_i[i]; jj < A_i[i + 1]; jj++)\n    temp += A_data[jj] * x_data[A_j[jj]];\n\n  y_data[i] = temp;\n}\n\n", "pragma": "omp parallel for private(temp, jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/amgmk/csr_matvec/2"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float a = 2.;\n  float b = (-2.) * (xc + yc);\n  float c = ((xc * xc) + (yc * yc)) - (r * r);\n  float d = (b * b) - ((4. * a) * c);\n  if (d < 0.)\n    continue;\n\n  d = sqrt(d);\n  float t1 = ((-b) + d) / (2. * a);\n  float t2 = ((-b) - d) / (2. * a);\n  float tmin = (t1 < t2) ? (t1) : (t2);\n  if (tmin < 0.)\n    continue;\n\n  float xcir = tmin;\n  float ycir = tmin;\n  float nx = xcir - xc;\n  float ny = ycir - yc;\n  float n = sqrt((nx * nx) + (ny * ny));\n  nx /= n;\n  ny /= n;\n  float inx = xcir - 0.;\n  float iny = ycir - 0.;\n  float in = sqrt((inx * inx) + (iny * iny));\n  inx /= in;\n  iny /= in;\n  float dot = (inx * nx) + (iny * ny);\n  float outx = inx - ((2. * nx) * dot);\n  float outy = iny - ((2. * ny) * dot);\n  float t = (0. - ycir) / outy;\n  if (t < 0.)\n    continue;\n\n  numHits += 1;\n}\n\n", "pragma": "        #pragma omp parallel for default(none) shared(xcs,ycs,rs) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RebeccaLyric/parallel/Project1/Proj1/0"}
{"code": "for (i = 0; i < 2000000; i++)\n{\n  M[i] = 3.0;\n  P[i] = 4.0;\n  R[i] = 5.0;\n}\n\n", "pragma": "omp parallel for shared(M) shared(P) shared(R)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/4"}
{"code": "for (i = 1; i < numClusters; i++)\n{\n  dist = euclid_dist_2(numCoords, object, clusters[i]);\n  if (dist < min_dist)\n  {\n    min_dist = dist;\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Guzzler/K-means-Parallel-Programming/omp_kmeans/2"}
{"code": "for (i = 1; i < num_procs; i++)\n{\n  key_buff1_aptr[i] = (INT_TYPE *) alloc_mem((sizeof(INT_TYPE)) * MAX_KEY);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/IS/is/4"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  virtualCenters[i].virutalCenter.dimensions = dimensions;\n  virtualCenters[i].virutalCenter.coordinates = (double *) calloc(dimensions, sizeof(double));\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/13"}
{"code": "for (size_t m = 0; m < dist_list_size; ++m)\n{\n  if ((m != centre) && (m != near_ind[0]))\n  {\n    if ((min2 == (-1.0)) || (dist_list[m] < min2))\n    {\n      min2 = dist_list[m];\n      near_ind[1] = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shoubhikraj/water-order/Water_order/12"}
{"code": "for (int i = 0; i < size; i++)\n  b[i] = 1.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/3"}
{"code": "for (unsigned int i = 0; i < a.n_elem; i++)\n{\n  if (a[i] != b[i])\n  {\n    re = FALSE;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      uijk = us[i][j][k];\n      up1 = us[i + 1][j][k];\n      um1 = us[i - 1][j][k];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dx1tx1 * ((u[0][i + 1][j][k] - (2.0 * u[0][i][j][k])) + u[0][i - 1][j][k]))) - (tx2 * (u[1][i + 1][j][k] - u[1][i - 1][j][k]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dx2tx1 * ((u[1][i + 1][j][k] - (2.0 * u[1][i][j][k])) + u[1][i - 1][j][k]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[1][i + 1][j][k] * up1) - (u[1][i - 1][j][k] * um1)) + ((((u[4][i + 1][j][k] - square[i + 1][j][k]) - u[4][i - 1][j][k]) + square[i - 1][j][k]) * c2)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dx3tx1 * ((u[2][i + 1][j][k] - (2.0 * u[2][i][j][k])) + u[2][i - 1][j][k]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[2][i + 1][j][k] * up1) - (u[2][i - 1][j][k] * um1)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dx4tx1 * ((u[3][i + 1][j][k] - (2.0 * u[3][i][j][k])) + u[3][i - 1][j][k]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[3][i + 1][j][k] * up1) - (u[3][i - 1][j][k] * um1)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dx5tx1 * ((u[4][i + 1][j][k] - (2.0 * u[4][i][j][k])) + u[4][i - 1][j][k]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[4][i + 1][j][k] * rho_i[i + 1][j][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i - 1][j][k] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[4][i + 1][j][k]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[4][i - 1][j][k]) - (c2 * square[i - 1][j][k])) * um1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (uijk,up1,um1,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/94"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  if (node->children[i].has_particle)\n  {\n    node->c_y += node->children[i].total_mass * calculate_center_of_mass_y(&node->children[i]);\n    m_tot += node->children[i].total_mass;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/7"}
{"code": "for (i = reachableSet->head; i < reachableSet->tail; i++)\n{\n  traversDendrogramLabelsDFS(&newLablesCounter, newLables, reachableSet->queue[i], atom, sibling);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/7"}
{"code": "for (x = 0; x < width; x++)\n  for (y = width; y < maxRowLimit; y += width)\n{\n  if (((!edge_pix[y + x]) && edge_pix[(y + width) + x]) && edge_pix[(y - width) + x])\n    edge_pix[y + x] = 255;\n\n}\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunpatel422/OpenMPLab/edgedetect/6"}
{"code": "for (int i = 0; i < len; i++)\n{\n  (cout << x[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/hybrid/0"}
{"code": "for (i = s; i <= e; i++)\n{\n  if ((!connected[i]) && (mind[i] < (*d)))\n  {\n    *d = mind[i];\n    *v = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    (cout << A[i][j]) << \"\\t\";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TharinduRusira/ParallelMatrix/mat_utils/9"}
{"code": "for (i = 0; i < num_of_platforms; ++i)\n{\n  size_t platform_name_length = 0;\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, 0, 0, &platform_name_length);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpy_5z9er_.c\", 266, 1);\n  }\n  ;\n  char platform_name[platform_name_length];\n  err = clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, platform_name_length, platform_name, 0);\n  {\n    devcall_opencl_errchk(err, \"/tmp/tmpy_5z9er_.c\", 271, 1);\n  }\n  ;\n  if (strstr(platform_name, required_platform_subname) && (selected_platform_index == num_of_platforms))\n  {\n    selected_platform_index = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/runtime/homp_dev/41"}
{"code": "for (j = 0; j < part_no; j++)\n{\n  move_particle(grid_sz, &par[j], grid, j);\n}\n\n", "pragma": "omp for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VascoAmaral9/Particles_Simulation_CPD_Project/parallelV/simpar-omp/0"}
{"code": "for (i = 0, pi = 0.0; i < NUM_THREADS; i++)\n  pi += sum[i] * step;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Daramgineer/OpenMP_study/Source/for_loop_compare/2"}
{"code": "for (row = 0; row < height; ++row)\n{\n  ulong couleur[width];\n  for (col = 0; col < width; ++col)\n  {\n    z.r = (z.i = 0);\n    c.r = r_min + (((double) col) * scale_r);\n    c.i = i_min + (((double) ((height - 1) - row)) * scale_i);\n    k = 0;\n    do\n    {\n      temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n      z.i = ((2 * z.r) * z.i) + c.i;\n      z.r = temp;\n      lengthsq = (z.r * z.r) + (z.i * z.i);\n      ++k;\n    }\n    while ((lengthsq < (2 * 2)) && (k < maxiter));\n    couleur[col] = ((ulong) ((k - 1) * scale_color)) + min_color;\n  }\n\n}\n\n", "pragma": "omp parallel for private(col, c, k, temp, z, lengthsq) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/linomp/INF560_Distributed_and_Parallel_Computing/lab4-openmp/mandelbrot/mandelbrot/0"}
{"code": "for (ii = 0; ii < 10; ++ii)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/13"}
{"code": "for (int i = offset; i < (offset + length); i++)\n{\n  dst[i] = src[i];\n}\n\n", "pragma": "#pragma omp teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGMultiOpenMPTarget/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (graph->vertices->out_degree[v])\n    riDividedOnDiClause[v] = DoubleToFixed64(stats->pageRanks[v] / graph->vertices->out_degree[v]);\n  else\n    riDividedOnDiClause[v] = 0.0f;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/12"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n  if (i == j)\n  if (abs(A[i][j]) > m)\n  m = abs(A[i][j]);\n\n\n\n\n", "pragma": "omp for schedule(static, num_of_lines) reduction(max:m)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Coursal/OpenMP-Strictly-Diagonally-Dominant/sdd/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  (*m_)[i][j] = drand48();\n  (*mcopy)[i][j] = (*m_)[i][j];\n  if (i == j)\n  {\n    (*l_)[i][j] = 1;\n    (*u_)[i][j] = 1;\n  }\n  else\n    if (i > j)\n  {\n    (*l_)[i][j] = 1;\n  }\n  else\n  {\n    (*u_)[i][j] = 1;\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaymalk/Parallelized-Matrix-LU-Decomposition/src/_c/lu_openmp/6"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    this->operator()(i, j) += rhs;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/9"}
{"code": "for (int i = 0; i < n; i++)\n  if (v[i] != ((double) i))\n{\n  err++;\n  printf(\"Err at %d, expected %lf, got %lf\\n\", i, (double) i, v[i]);\n  if (err > 10)\n    return err;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/managed_memory/managed_memory/0"}
{"code": "for (uint64_t ii = start_chunk; ii < end_chunk; ++ii)\n{\n  const uint32_t bucket_index = my_keys[ii] / BUCKET_WIDTH;\n  bucket_sizes[bucket_index]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_omp/4"}
{"code": "for (i = 0; i < 16; i++)\n{\n  cs.salt[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/racf_kdfaes_fmt_plug/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  m[i] = (int *) calloc(cols, sizeof(int *));\n  for (int j = 0; j < cols; j++)\n  {\n    m[i][j] = getRandomNumber();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/als-movie-recommender/main/2"}
{"code": "for (const_iterator it = itBgn + 1; it != itEnd; ++it)\n{\n  uint32_t v1 = *(it - 1);\n  uint32_t v2 = *it;\n  mplAssert(m_vCompId[v1] == m_vCompId[v2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/27"}
{"code": "for (idx_t v = 0; v < hg->nvtxs; ++v)\n{\n  hg->vwts[v] = ft->fptr[v + 1] - ft->fptr[v];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/0"}
{"code": "for (i = 0; i < length; i++)\n{\n  if (!set)\n  {\n    set = true;\n    for (int k = 0; k < i; k++)\n    {\n      b++;\n    }\n\n  }\n\n  *(b++) = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Tests/testing/assignment/matrixMult/0"}
{"code": "for (x = 0; x < diameter; x++)\n{\n  for (y = 0; y < diameter; y++)\n  {\n    double distance = sqrt(pow((double) ((x - radius) + 1), 2) + pow((double) ((y - radius) + 1), 2));\n    if (distance < radius)\n      disk[(x * diameter) + y] = 1;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/12"}
{"code": "for (int j = 0; j < expsz; j++)\n{\n  for (int i = 0; i < m; i++)\n  {\n    e[i] = exps[i + (j * m)];\n  }\n\n  value = monomial_value(m, n, e, x);\n  result[j] = (simplex_volume(m, t) * vec_sum(n, value)) / ((double) n);\n  free(value);\n}\n\n", "pragma": "omp parallel for default(none) private(value, e) shared(n, result, x, t, exps) OMP_SCHEDULE", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task2_simplex/simplex_modified_for_omp/simplex/1"}
{"code": "for (int i = starts[thread_num]; i < ends[thread_num]; i++)\n{\n  a[i] += const_sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/radinshayanfar/MCP/Lab4/Lab_4_m1/3"}
{"code": "for (uint32_t i = 0; i < nblocks; i++)\n{\n  uint64_t k1 = getblock64(data, (i * 2) + 0);\n  uint64_t k2 = getblock64(data, (i * 2) + 1);\n  k1 *= c1;\n  k1 = ROTL64(k1, 31);\n  k1 *= c2;\n  h1 ^= k1;\n  h1 = ROTL64(h1, 27);\n  h1 += h2;\n  h1 = (h1 * 5) + 0x52dce729;\n  k2 *= c2;\n  k2 = ROTL64(k2, 33);\n  k2 *= c1;\n  h2 ^= k2;\n  h2 = ROTL64(h2, 31);\n  h2 += h1;\n  h2 = (h2 * 5) + 0x38495ab5;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/murmurhash3-omp/murmurhash3/1"}
{"code": "for (int i = 1; i < generations; i++)\n{\n  if (0 == 1)\n  {\n    printTable(table, size, threads, i);\n    getchar();\n  }\n\n  newTable = stepGeneration(table, size, threads);\n  table = newTable;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arielfreire/conways-game-of-life/jogo_da_vida/4"}
{"code": "for (int j = 0; j < 10000; j++)\n{\n  activateNN(TEST_INPUT[j]);\n  category = classDecision(OL2);\n  desiredCategory = desiredDecision(j, train_flag);\n  categoryTruth = decisionTruth(category, desiredCategory);\n  if (categoryTruth)\n  {\n    trueDecisioncounter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex4/ex4/3"}
{"code": "for (int i = (k + t_id) + 1; i < n; i += THREAD_NUM)\n{\n  temp = mat[i][k];\n  for (int j = k + 1; j < n; j++)\n  {\n    mat[i][j] -= temp * mat[k][j];\n  }\n\n  mat[i][k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/2"}
{"code": "for (x = 0; x < size; x++)\n{\n  fprintf(fptr, \"%u %u\\n\", x, labels[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/29"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n    STDEV[i] += (A[(i * n) + j] - MEAN[i]) * (A[(i * n) + j] - MEAN[i]);\n\n  STDEV[i] = sqrt(STDEV[i] / n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/testP_AI/2"}
{"code": "for (igroup = 0; igroup < group_count; igroup++)\n{\n  batch_size += group_size[igroup];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arghyac007/DMRG-openMP/Analysis/dmrg_vbatch/1"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  local_sum += i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/sum/sum/0"}
{"code": "for (int i = 1; i <= n; ++i)\n{\n  x = 0;\n  costhe = 1;\n  while ((x >= 0) & (x <= a))\n  {\n    x -= (b * costhe) * log(r2());\n    if (r2() < p)\n    {\n      count++;\n      break;\n    }\n    else\n    {\n      costhel = (2 * r2()) - 1;\n      costhe = (costhe * costhel) + ((sqrt(1 - (costhe * costhe)) * sqrt(1 - (costhel * costhel))) * cos((2 * 3.14159265358979323846) * r2()));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, costhe, costhel) reduction(+:count) schedule(guided,1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/royess/SimplifiedNeutronScattering/neutron_openmp/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    ((((cout << \"j  Threads:\") << omp_get_num_threads()) << \"  ThreadID:\") << omp_get_thread_num()) << \"\\n\";\n  }\n\n  ((((cout << \"  i=\") << i) << \"  Threads:\") << omp_get_num_threads()) << \"\\n\";\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gnnnn/openmp-/OpenMPdemo/\u5d4c\u5957\u5e76\u884c/\u5d4c\u5957\u5e76\u884c/NestingTest/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char pwd_ver[3 * SHA_DIGEST_LENGTH];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), saved_salt->salt, (4 * (saved_salt->v.mode & 3)) + 4, KEYING_ITERATIONS, (pwd_ver + early_skip) - late_skip, SHA_DIGEST_LENGTH, early_skip);\n  if (!memcmp((pwd_ver + (2 * key_len)) - late_skip, saved_salt->passverify, 2))\n  {\n    pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), saved_salt->salt, (4 * (saved_salt->v.mode & 3)) + 4, KEYING_ITERATIONS, pwd_ver, late_size, late_skip);\n    hmac_sha1((pwd_ver + key_len) - late_skip, key_len, (const unsigned char *) saved_salt->datablob, saved_salt->comp_len, crypt_key[index], WINZIP_BINARY_SIZE);\n  }\n  else\n    memset(crypt_key[index], 0, WINZIP_BINARY_SIZE);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/zip_fmt_plug/2"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int task_ids[tasks_per_process];\n  MPI_Recv(task_ids, tasks_per_process, MPI_INT, i, collect_results_tag, comm, &status);\n  int task_penalties[tasks_per_process];\n  MPI_Recv(task_penalties, tasks_per_process, MPI_INT, i, collect_results_tag2, comm, &status);\n  char buffer[sha512_strlen];\n  for (int j = 0; j < tasks_per_process; j++)\n  {\n    penalties[task_ids[j]] = task_penalties[task_ids[j]];\n    MPI_Recv(buffer, 128, MPI_CHAR, i, collect_results_tag3, comm, &status);\n    answers_hash[task_ids[j]] = string(buffer, 128);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel2/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  sumalocal += a[i];\n  printf(\"thread %d suma de a[%d]=%d sumalocal=%d \\n\", tid, i, a[i], sumalocal);\n}\n\n", "pragma": "omp for private(i) schedule(static) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/if_clause_modificado/0"}
{"code": "for (i = 0; i < 9; i++)\n{\n  if (taules[thread][x][i] == z)\n    return 0;\n\n  if (taules[thread][i][y] == z)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_Dauden/3"}
{"code": "for (i = 0; i < NCLUSTERS; i++)\n{\n  my_new_centers_len[i] = 0;\n  for (j = 0; j < NFEATURES; j++)\n  {\n    my_new_centers[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcanalesmayo/Heterogeniuses/opencl/kmeans/kmeans/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i] = i;\n  for (int j = 0; j < n; j++)\n  {\n    if (j < i)\n    {\n      u[i][j] = 0.0;\n      l[i][j] = drand48();\n    }\n    else\n      if (j == i)\n    {\n      l[i][j] = 1.0;\n      u[i][j] = drand48();\n    }\n    else\n    {\n      u[i][j] = drand48();\n      l[i][j] = 0.0;\n    }\n\n\n    p_matrix[i][j] = 0.0;\n    a[i][j] = drand48();\n    a_copy[i][j] = a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brijeshvp/LU-Decomposition-using-Parallel-Programming/omp_parallel/LU_omp/1"}
{"code": "for (int i = 1; i < (m - 1); i++)\n{\n  A[j][i] = Anew[j][i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jefflarkin/GTC16-S6510/c99/04-target-teams-seperated/laplace2d/1"}
{"code": "for (i = 0; i < nHubs; i++)\n{\n  int hub_id = g->hubs[i];\n  double sum = 0.0;\n  for (eid = g->neighbor_start[hub_id]; eid < g->neighbor_start[hub_id + 1]; eid++)\n  {\n    sum += s->node_weight[g->neighbor[eid]];\n    s->neighbor_accum_weight[eid] = sum;\n  }\n\n  s->sum_weight[hub_id] = sum;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WeijiaGao49/Shared-Memory-Parallelism-with-OpenMP/code/sim/2"}
{"code": "for (; *p; p++)\n{\n  if (((*p) == ' ') || ((*p) == '\\t'))\n    continue;\n\n  tmp = (uint32_t) (*p);\n  nr ^= (((nr & 63) + add) * tmp) + (nr << 8);\n  nr2 += (nr2 << 8) ^ nr;\n  add += tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mysql_fmt_plug/3"}
{"code": "for (n = 0; n < (6 - m); n++)\n{\n  printf(\"At thread: %d\\n\", omp_get_thread_num);\n  printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/ackerman/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    sum += x[j] * a[(i * n) + j];\n  }\n\n  y[i] = (alpha * sum) + (beta * y[i]);\n}\n\n", "pragma": "omp parallel for private(j,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/gemv/0"}
{"code": "for (int i = 0; i < 4000; ++i)\n{\n  buffer[i] = (n * i) * rank;\n}\n\n", "pragma": "omp parallel for firstprivate(buffer) schedule(static,1000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tudasc/CommPart/demo-codes/full_buffer_in_loop/0"}
{"code": "for (size_t i = 0; i < size; i++)\n  sum += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hongzhouye/openMP_tests/prog-3/1"}
{"code": "for (iter = 0; iter < NITER; iter++)\n{\n  for (iPE = 0; iPE < nPEs; iPE++)\n    fprintf(timesOutFile, \"%e \\t\", times[iPE][iter]);\n\n  fprintf(timesOutFile, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxhutch/homb/src/homb/18"}
{"code": "for (i = 1; i < size; i++)\n{\n  MPI_Recv(&AllAlphas[i], 1, MPI_DOUBLE, i, MPI_ANY_TAG, MPI_COMM_WORLD, &status);\n  for (j = 0; j < (dimensionSize + 1); j++)\n  {\n    MPI_Recv(&AllWeights[i][j], 1, MPI_DOUBLE, i, MPI_ANY_TAG, MPI_COMM_WORLD, &status);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/8"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  for (k = 0; k < 1000; k++)\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/autoParallelization/tests/matrixmultiply/0"}
{"code": "for (l = 0; l < 1024; l++)\n{\n  for (l1 = 0; l1 < 1024; l1++)\n  {\n    A[l][l1] = (((double) rand()) / ((double) 32767)) * 3.0;\n    B[l][l1] = (((double) rand()) / ((double) 32767)) * 3.0;\n    C[l][l1] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial_double/5"}
{"code": "for (i = 0; i <= (3000 + 1); i++)\n{\n  for (j = 0; j <= (3000 + 1); j++)\n  {\n    A[i][j] = 20;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leo-ventura/parallel-computing-openmp/src/gauss_seidel/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  col_1[i] = C_n[i][0];\n  col_1[i + N] = C_n[i][1];\n  col_n[i] = C_n[i][N - 1];\n  col_n[i + N] = C_n[i][N - 2];\n  row_1[i] = C_n[0][i];\n  row_1[i + N] = C_n[1][i];\n  row_n[i] = C_n[N - 1][i];\n  row_n[i + N] = C_n[N - 2][i];\n}\n\n", "pragma": "        #pragma omp parallel for default(none) private(i) shared(row_1, row_n, col_1, col_n, C_n, N) schedule(guided)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/final-version/advection_simulation/4"}
{"code": "for (i = 0; i < bar_num; i++)\n{\n  if (i == 0)\n  {\n    printf(\"The range starts with %d, end with %d with count %d \\n\", (int) min_value, (int) bar_maxes[i], bar_counts[i]);\n  }\n  else\n  {\n    printf(\"The range starts with %d, end with %d with count %d \\n\", (int) bar_maxes[i - 1], (int) bar_maxes[i], bar_counts[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bahaa29/OpenMP_with_mpi-compute-hisogram/A3/1"}
{"code": "for (int h = 0; h < 4; h++)\n  for (int w = 0; w < 4; w++)\n  input_file.read((char *) (&initGuess->data[h][w]), sizeof(float));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/0"}
{"code": "for (int i = 0; i < numcells; i++)\n{\n  R2[i] = ((0.75 * R[i]) + (0.25 * R1[i])) - ((0.25 * dtdx) * (FR[i + 1] - FR[i]));\n  RU2[i] = ((0.75 * RU[i]) + (0.25 * RU1[i])) - ((0.25 * dtdx) * (FRU[i + 1] - FRU[i]));\n  RE2[i] = ((0.75 * RE[i]) + (0.25 * RE1[i])) - ((0.25 * dtdx) * (FRE[i + 1] - FRE[i]));\n  U2[i] = RU2[i] / R2[i];\n  P2[i] = (GAMMA - 1.0) * (RE1[i] - ((0.5 * RU2[i]) * U2[i]));\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/13"}
{"code": "for (i = 0; i < Np; i++)\n{\n  r[i] = r0[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/leukocyte/OpenMP/track_ellipse.ref/1"}
{"code": "for (j = 0; j < K; j++)\n{\n  if (centroids[j].numPoints != 0)\n  {\n    centroids[j].x = centroids[j].sumX / centroids[j].numPoints;\n    centroids[j].y = centroids[j].sumY / centroids[j].numPoints;\n    centroids[j].z = centroids[j].sumZ / centroids[j].numPoints;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mkdan91/ParallelKmeans/Kmeans/Main/8"}
{"code": "for (i = 0; i < cs.challenge_length; i++)\n  cs.challenge[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/chap_fmt_plug/1"}
{"code": "for (i = 0; i < prof; i++)\n{\n  double temp = x;\n  double x2 = x * x;\n  double y2 = y * y;\n  x = (x2 - y2) + a;\n  y = ((2 * temp) * y) + b;\n  if ((x2 + y2) > 4.0)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/mandel_openmp/1"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv5[layer5_index];\n    if (conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv5_data[(((layer5_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/29"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int j = 0; j < nyn; j++)\n{\n  rhons[0][i][j][0] += ne_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + ne_phase);\n  rhons[1][i][j][0] += ni_mod * cos(((kx * grid->getXN(i, j, 0)) + (ky * grid->getYN(i, j, 0))) + ni_phase);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/46"}
{"code": "for (int i = 0; i < (cast_mat->nrow_ + 1); ++i)\n{\n  row_offset[i] = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/48"}
{"code": "for (int i = 0;; i++)\n  c[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/18"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  a[i][j] = (b[i][j] = i * j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyRybalkin/openmpi_samples/matrix_product_openmp/0"}
{"code": "formula.append(number(aa) + \"x^7 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/87"}
{"code": "for (j = 0; j < K_global; j++)\n{\n  current_dist = (pow((double) (trained_global[((iter_counter * K_global) + j) * 3] - ((float) data_pts_global[i])), 2.0) + pow((double) (trained_global[(((iter_counter * K_global) + j) * 3) + 1] - ((float) data_pts_global[i + 1])), 2.0)) + pow((double) (trained_global[(((iter_counter * K_global) + j) * 3) + 2] - ((float) data_pts_global[i + 2])), 2.0);\n  if (current_dist < min_dist)\n  {\n    min_dist = current_dist;\n    point_to_cluster_id[i - start] = j;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    (cout << \"\\n\") << result[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/matrix_matrix_openmp/4"}
{"code": "for (i = 0; i < numPartitions; i++)\n{\n  a = (i + .5) * interval;\n  for (j = 0; j < numPartitions; j++)\n  {\n    b = (j + .5) * interval;\n    if (((a * a) + (b * b)) <= 1)\n      circleCount++;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(a,b,j) reduction(+: circleCount)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/munawira/Using-OpenMP-to-Estimate-Pi/Parallel_1_final/0"}
{"code": "for (j = 1; j < num_proc; j++)\n{\n  if (i < numNs2)\n  {\n    int done = 0;\n    MPI_Send(&done, 1, MPI_INT, j, tag, 1);\n    i = sendSeq2ToWorkerProcessNumJ(i, j, file);\n  }\n  else\n  {\n    int done = 1;\n    MPI_Send(&done, 1, MPI_INT, j, tag, 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/asafsuryano/Parallel-Sequence-alignment/src/parallel_project/2"}
{"code": "for (i = k + 1; i < size; ++i)\n{\n  temp = Au[index[i]][k] / Au[index[k]][k];\n  for (j = k; j < (size + 1); ++j)\n    Au[index[i]][j] -= Au[index[k]][j] * temp;\n\n}\n\n", "pragma": "omp for schedule(static, 64) private(temp, i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abidrahman/Discovering-OpenMP/static/0"}
{"code": "for (m = 1; m < 5; m++)\n{\n  buf[m][k] = dtpp * dtemp[m];\n}\n\n", "pragma": "omp parallel for firstprivate(dtpp ,m ,k ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/30"}
{"code": "for (int i = 0; i < numberGroups; i++)\n{\n  groupAction(numberGroups, i + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucyRez/ABC-OpenMp_HW4/TreasureIsland_Openmp/TreasureIsland_Openmp/6"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  A[i] = i * sin((i * M_PI) / N);\n  B[i] = (i / pow(N, 2)) + (pow(N, 2) / (i + 1));\n  C[i] = A[i] * B[i];\n}\n\n", "pragma": "#pragma omp parallel for shared(N, A, B, C)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/efti-nile/concurrent_computing/pc_lab1_omp/src/pc_lab_1_omp/0"}
{"code": "for (long long int j = 0; j < size; ++j)\n{\n  a[j] = temp[j];\n}\n\n", "pragma": "omp parallel for num_threads(threads) schedule(dynamic, size / threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GlenGGG/FastParallelMergeSort/omp_mergesort/5"}
{"code": "for (i = 0; i < (4 / block_size); i++)\n{\n  for (j = 0; j < (4 / block_size); j++)\n    printf(\"%d   \", cb[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Matrix_mult/block_mult_tasks/2"}
{"code": "for (i = 0; i < (1 << 16); i++)\n  key_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/44"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < p; j++)\n  {\n    matrixC[i][j] = 0;\n    for (k = 0; k < o; k++)\n    {\n      matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekaryaREPO/Concurrent-Programming-with-Java-and-OpenMP/ASSIGNMENT 2-OpenMP/SOURCE CODE AND EXECUTABLES/MatrixMultiplicationUsingThreadsAndTask/0"}
{"code": "for (i = 0; i < (128 + 1); i++)\n{\n  for (j = 0; j < (128 + 1); j++)\n  {\n    u[i][j] = unew[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule (static,chunk_size) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/14"}
{"code": "for (i = 0; i < (height * width); ++i)\n{\n  if ((image[i] != 255) && (image[i] != 0))\n    image[i] = 0;\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) shared(image,height,width)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thu105/PhotoMosaic/main/5"}
{"code": "for (int i = 3; i <= num; i++)\n{\n  prime = true;\n  for (int n = 2; n < i; n++)\n  {\n    if ((i % n) == 0)\n    {\n      prime = false;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/OpenMP/Goldbach_conjecture/goldbach_omp_d/0"}
{"code": "for (i = 0; i < nd; i++)\n{\n  fprintf(fp, \"%f\\n\", xi[i]);\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/girihemant19/Pagerank-serial-C-and-parallel-openMp-/pagerank_openMp/2"}
{"code": "for (int i = 0; i < ((1024 * 1024) * 64); ++i)\n{\n  localSum++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment1/fast/0"}
{"code": "for (int i = 0; i < (N * N); ++i)\n{\n  A[i] = drand48();\n  Btranspose[i] = drand48();\n  C[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/mpi/matmat_omp_opt/1"}
{"code": "for (i = 0; i < leny; i++)\n{\n  head_sum = (tail_sum = 0.0);\n  ;\n  aij = ai;\n  jx = kx;\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a_i[aij];\n    x_elem = x_i[jx];\n    {\n      double a1;\n      double a2;\n      double b1;\n      double b2;\n      double con;\n      con = a_elem * split;\n      a1 = con - a_elem;\n      a1 = con - a1;\n      a2 = a_elem - a1;\n      con = x_elem * split;\n      b1 = con - x_elem;\n      b1 = con - b1;\n      b2 = x_elem - b1;\n      head_prod = a_elem * x_elem;\n      tail_prod = ((((a1 * b1) - head_prod) + (a1 * b2)) + (a2 * b1)) + (a2 * b2);\n    }\n    {\n      double bv;\n      double s1;\n      double s2;\n      double t1;\n      double t2;\n      s1 = head_sum + head_prod;\n      bv = s1 - head_sum;\n      s2 = (head_prod - bv) + (head_sum - (s1 - bv));\n      t1 = tail_sum + tail_prod;\n      bv = t1 - tail_sum;\n      t2 = (tail_prod - bv) + (tail_sum - (t1 - bv));\n      s2 += t1;\n      t1 = s1 + s2;\n      s2 = s2 - (t1 - s1);\n      t2 += s2;\n      head_sum = t1 + t2;\n      tail_sum = t2 - (head_sum - t1);\n    }\n    aij += incaij;\n    jx += incx;\n  }\n\n  {\n    double a11;\n    double a21;\n    double b1;\n    double b2;\n    double c11;\n    double c21;\n    double c2;\n    double con;\n    double t1;\n    double t2;\n    con = head_sum * split;\n    a11 = con - head_sum;\n    a11 = con - a11;\n    a21 = head_sum - a11;\n    con = alpha_i * split;\n    b1 = con - alpha_i;\n    b1 = con - b1;\n    b2 = alpha_i - b1;\n    c11 = head_sum * alpha_i;\n    c21 = ((((a11 * b1) - c11) + (a11 * b2)) + (a21 * b1)) + (a21 * b2);\n    c2 = tail_sum * alpha_i;\n    t1 = c11 + c2;\n    t2 = (c2 - (t1 - c11)) + c21;\n    head_tmp1 = t1 + t2;\n    tail_tmp1 = t2 - (head_tmp1 - t1);\n  }\n  y_elem = y_i[iy];\n  {\n    double a1;\n    double a2;\n    double b1;\n    double b2;\n    double con;\n    con = y_elem * split;\n    a1 = con - y_elem;\n    a1 = con - a1;\n    a2 = y_elem - a1;\n    con = beta_i * split;\n    b1 = con - beta_i;\n    b1 = con - b1;\n    b2 = beta_i - b1;\n    head_tmp2 = y_elem * beta_i;\n    tail_tmp2 = ((((a1 * b1) - head_tmp2) + (a1 * b2)) + (a2 * b1)) + (a2 * b2);\n  }\n  {\n    double bv;\n    double s1;\n    double s2;\n    double t1;\n    double t2;\n    s1 = head_tmp1 + head_tmp2;\n    bv = s1 - head_tmp1;\n    s2 = (head_tmp2 - bv) + (head_tmp1 - (s1 - bv));\n    t1 = tail_tmp1 + tail_tmp2;\n    bv = t1 - tail_tmp1;\n    t2 = (tail_tmp2 - bv) + (tail_tmp1 - (t1 - bv));\n    s2 += t1;\n    t1 = s1 + s2;\n    s2 = s2 - (t1 - s1);\n    t2 += s2;\n    head_tmp1 = t1 + t2;\n    tail_tmp1 = t2 - (head_tmp1 - t1);\n  }\n  y_i[iy] = head_tmp1;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv_x/5"}
{"code": "for (i = 0; i < 500; i++)\n  p += a[i] * b[i];\n\n", "pragma": "omp for reduction(+:p) schedule(dynamic,50)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/matrix_operations/dot_product/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"Value of b [%d] ? : \\n\", i);\n  scanf(\" %f\", &val);\n  (*vect)[i] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/6"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    temp[i][j].rgbRed = image[i][j].rgbRed;\n    temp[i][j].rgbGreen = image[i][j].rgbGreen;\n    temp[i][j].rgbBlue = image[i][j].rgbBlue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab4/parallel_lab4/filter/0"}
{"code": "for (i = 0; i < nr_class; i++)\n  weighted_C[i] = param->C;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/55"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  mor_s_v[i] = mor_v[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/39"}
{"code": "for (i = 0; i < NoofRows; i++)\n{\n  Matrix[i] = (float *) malloc((sizeof(float)) * NoofCols);\n  for (j = 0; j < NoofCols; j++)\n    Matrix[i][j] = ((i * j) * 5) + i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/1"}
{"code": "for (uint32_t comp_id = 0; comp_id < m_comp_cnt; ++comp_id)\n{\n  iterator itBgn = m_vVertexOrder.begin() + m_vBookmark[comp_id];\n  iterator itEnd = ((comp_id + 1) != m_comp_cnt) ? (m_vVertexOrder.begin() + m_vBookmark[comp_id + 1]) : (m_vVertexOrder.end());\n  this->lg_simplification(itBgn, itEnd, comp_id);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(m_db->thread_num())", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/6"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  SHA512_CTX ctx;\n  memcpy(&ctx, &ctx_salt, sizeof(ctx));\n  SHA512_Update(&ctx, saved_key[index], saved_len[index]);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, ctx_salt, saved_key, saved_len, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/XSHA512_fmt_plug/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"The number of threads are : %d \\n\", omp_get_num_threads());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DedrickEnc/CParallelProgramming/openmp/functions/functions/0"}
{"code": "for (j = 0; j < N; j++)\n{\n  w[0][j] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhin-kakkad/SteadyStateHeatEquation/Project_parallel/3"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  int n = 0;\n  for (j = 0; j < ndata; j++)\n  {\n    if (mask[j][i])\n    {\n      double term = data[j][i];\n      term = term * term;\n      stddata[i] += term;\n      n++;\n    }\n\n  }\n\n  if (stddata[i] > 0)\n    stddata[i] = sqrt(stddata[i] / n);\n  else\n    stddata[i] = 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/94"}
{"code": "for (int ii = 0; ii < nCells; ii++)\n{\n  double sum1;\n  double sum2;\n  const double x = Vm[ii];\n  const int Mhu_l = 10;\n  const int Mhu_m = 5;\n  sum1 = 0;\n  for (int j = Mhu_m - 1; j >= 0; j--)\n    sum1 = Mhu_a[j] + (x * sum1);\n\n  sum2 = 0;\n  int k = (Mhu_m + Mhu_l) - 1;\n  for (int j = k; j >= Mhu_m; j--)\n    sum2 = Mhu_a[j] + (x * sum2);\n\n  double mhu = sum1 / sum2;\n  const int Tau_m = 18;\n  sum1 = 0;\n  for (int j = Tau_m - 1; j >= 0; j--)\n    sum1 = Tau_a[j] + (x * sum1);\n\n  double tauR = sum1;\n  m_gate[ii] += (mhu - m_gate[ii]) * (1 - exp(-tauR));\n  if (ii == 0)\n    checkVal = (int) (1000000.0 * m_gate[ii]);\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(128) map(from:checkVal)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-325070/clang-325070/0"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  bl[i] = sqrt(1.0 - (bm[i] * bm[i])) / SQ2;\n  Ogrid[(26 + (24 * i)) + 0] = TlPosition(bl[i], bl[i], bm[i]);\n  Ogrid[(26 + (24 * i)) + 1] = TlPosition(-bl[i], bl[i], bm[i]);\n  Ogrid[(26 + (24 * i)) + 2] = TlPosition(bl[i], -bl[i], bm[i]);\n  Ogrid[(26 + (24 * i)) + 3] = TlPosition(bl[i], bl[i], -bm[i]);\n  Ogrid[(26 + (24 * i)) + 4] = TlPosition(-bl[i], -bl[i], bm[i]);\n  Ogrid[(26 + (24 * i)) + 5] = TlPosition(-bl[i], bl[i], -bm[i]);\n  Ogrid[(26 + (24 * i)) + 6] = TlPosition(bl[i], -bl[i], -bm[i]);\n  Ogrid[(26 + (24 * i)) + 7] = TlPosition(-bl[i], -bl[i], -bm[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/28"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if (fabs(rez[i] - x[i]) > 1E-5)\n    printf(\"%lf=%lf\\n\", rez[i], x[i]);\n\n  fflush(stdout);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj/bench/7"}
{"code": "for (i = 0; i < nb; i++)\n{\n  printf(\"tab[%d] : %d\\n\", i, tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_5/TP_OPENMP_5/2"}
{"code": "for (k = 0; k < num_keys; k++)\n{\n  srand(time(0) + k);\n  key[k] = rand() % n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kylexu1005/Parallel-Binary-Search/pbsearch/1"}
{"code": "for (i = 0; i < g_psf_extent; i++)\n{\n  for (j = 0; j < g_psf_extent; j++)\n  {\n    psf_totale(((g_extended_image_dim_y - g_psf_extent) / 2) + i, ((g_extended_image_dim_x - g_psf_extent) / 2) + j) = 0.;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/16"}
{"code": "for (int i = a.size() - 1; i >= 0; i--)\n  v.push_back(\"\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/riak16/Parallel-addition/proj_omp/1"}
{"code": "for (unsigned int i = DIMEN; i--; ret += powf64(coord.ref[i], 2.0) - cos((M_PI * 2.0) * coord.ref[i]))\n  for (unsigned int j = 1000; j--; ret += 0.01)\n  ;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/imhele/pso-openmp/main/2"}
{"code": "formula.append((\"+ \" + number(cc)) + \"x^5 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/93"}
{"code": "for (int i = 0; i < tam; i++)\n{\n  for (int j = 0; j < tam; j++)\n  {\n    for (int k = 0; k < 3; k++)\n    {\n      for (int x = 0; x < 256; x++)\n      {\n        aux = (long) (((((h[k + x] * h[k + x]) * h[k + x]) * h[k + x]) - ((h[k + x] * h[k + x]) * h[k + x])) + (h[k + x] * h[k + x]));\n        h[k + x] = (int) (aux % 256);\n      }\n\n      imagen[(k + i) + j] = (short) (imagen[(k + i) + j] * h[k + imagen[(k + i) + j]]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/11"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    ((((((ofs << \" \") << image[0][i][j]) << \" \") << image[1][i][j]) << \" \") << image[2][i][j]) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zigal0/OpenMP/Mandelbrot/src/parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  *sum += factor / ((2 * i) + 1);\n  factor = -factor;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+:sum) private(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omnyyah/Parallel-Programming-Lab/piParallel/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  for (j = 0; j < histogram_size; j++)\n  {\n    hist_private[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/histogram/5"}
{"code": "for (i = 0; i <= (grid_rows - 1); i += 1)\n{\n  for (j = 0; j <= (grid_cols - 1); j += 1)\n  {\n    for (k = 0; k <= (layers - 1); k += 1)\n    {\n      if (fgets(str, 256, fp) == ((void *) 0))\n        fatal(\"Error reading file\\n\");\n\n      if (feof(fp))\n        fatal(\"not enough lines in file\");\n\n      if (sscanf(str, \"%f\", &val) != 1)\n        fatal(\"invalid file format\");\n\n      vect[((i * grid_cols) + j) + ((k * grid_rows) * grid_cols)] = val;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/hotspot3D/3D/1"}
{"code": "for (int i = 1; i < (eq_Nx - 1); i++)\n{\n  eq_inv_m[i * eq_Nx] = (-eq_inv_m[(i * eq_Nx) + 1]) * eq_Aa;\n  eq_inv_m[((i * eq_Nx) + eq_Nx) - 1] = (-eq_inv_m[((i * eq_Nx) + eq_Nx) - 2]) * eq_Aa;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/14"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n    printf(\"%2d \", matrix[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bova-ev/openmp_hw/bova_hw4/matrix/3"}
{"code": "for (i = 0; i < 16; i++)\n  b[i + 48] = i + 48;\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/for-16/12"}
{"code": "for (int j = 0; j < 3; j++)\n  g_colors[(((y * g_width) * 4) + (x * 4)) + j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tokarevart/mandelbrot-fractal-calculation/CPUC++/CPUFractalCalc/0"}
{"code": "for (int i = k1; i < m; ++i)\n{\n  g += predict[i] - y[i];\n}\n\n", "pragma": "#pragma omp for reduction(+: g)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/logistic_bgd/5"}
{"code": "for (int v = 0; v < 5; v++)\n  if ((mstSet[v] == 0) && (key[v] < temp_min))\n{\n  temp_min = key[v];\n  temp_min_index = v;\n}\n\n\n", "pragma": "omp parallel for defalut(private) shared(min, min_index)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/minspanningtree/0"}
{"code": "for (int i = 0; i < count; i++)\n{\n  x = (i + 0.5) * dx;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for reduction (+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PravarChaurasia/Openmp/Q6/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  temp = malloc(sizeof(struct node));\n  p->next = temp;\n  p = temp;\n  p->data = (38 + i) + 1;\n  p->fibdata = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsmankoo/OpenMP/linked/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d\\n\", orden[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer2/scheduler-clauseModificado/1"}
{"code": "for (int i = 1; i < (dim->rows - 1); i++)\n{\n  for (int j = 1; j < (dim->columns - 1); j++)\n    util_grid->cells[i][j] = change_cell_state(i, j, ptr, syms);\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/0"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14lf \", pageRankCorrelationStats_array[x].float_Kendall);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/28"}
{"code": "for (int i = 0; i < schd_boundary; ++i)\n{\n  local_result[tid][0] = (local_result[tid][0] * rand_num[i]) % INT_MAX;\n}\n\n", "pragma": "        #pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/taeguk/dist-prog-assignment/assignment-3/p2/example2_myschd/2"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  printf(\"%3d \", disFromStartOpenmp[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/13"}
{"code": "for (r = 0; r < r_num; r++)\n{\n  thread = omp_get_thread_num();\n  jsr = seed[thread];\n  for (s = 0; s < s_num; s++)\n  {\n    r4_value = r4_nor(&jsr, kn, fn, wn);\n  }\n\n  result_par[thread] = r4_value;\n  seed[thread] = jsr;\n}\n\n", "pragma": "omp for schedule ( static, 1 )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/ziggurat_openmp_original/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  (cout << val[i]) << ((i == (m - 1)) ? (\"\") : (\", \"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/XJay18/ParallelApp_OMP/Matrix/2"}
{"code": "for (i = 1; i < lenC; i++)\n{\n  C[i] += C[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/duinobot2/OMPCountingSort/ProjectCountingSortFinal2/src/countingsort/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  vet[i] = aux[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danilo94/Genetic-Regulator-Network---With-OpenMP/main/4"}
{"code": "for (i = 0; i < image->row; i++)\n{\n  for (j = 0; j < image->col; j++)\n  {\n    omp_set_lock(&lck[image->content[i][j]]);\n    histo[image->content[i][j]] += 1;\n    omp_unset_lock(&lck[image->content[i][j]]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_locks/0"}
{"code": "for (it = 1; it <= 1; it++)\n{\n  conj_grad(colidx, rowstr, x, z, a, p, q, r, &rnorm);\n  norm_temp11 = 0.0;\n  norm_temp12 = 0.0;\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    norm_temp11 = norm_temp11 + (x[j] * z[j]);\n    norm_temp12 = norm_temp12 + (z[j] * z[j]);\n  }\n\n  norm_temp12 = 1.0 / sqrt(norm_temp12);\n  for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n  {\n    x[j] = norm_temp12 * z[j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/CG/cg/1"}
{"code": "for (i = iend; i >= ist; i--)\n{\n  if (i != iend)\n  {\n    while (flag[i + 1] == 0)\n    {\n      ;\n    }\n\n  }\n\n  if (i != ist)\n  {\n    while (flag[i] == 1)\n    {\n      ;\n    }\n\n  }\n\n  for (j = jend; j >= jst; j--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[i][j][m] = tv[i][j][m] + (omega * ((((((((((udy[i][j][m][0] * v[i][j + 1][k][0]) + (udx[i][j][m][0] * v[i + 1][j][k][0])) + (udy[i][j][m][1] * v[i][j + 1][k][1])) + (udx[i][j][m][1] * v[i + 1][j][k][1])) + (udy[i][j][m][2] * v[i][j + 1][k][2])) + (udx[i][j][m][2] * v[i + 1][j][k][2])) + (udy[i][j][m][3] * v[i][j + 1][k][3])) + (udx[i][j][m][3] * v[i + 1][j][k][3])) + (udy[i][j][m][4] * v[i][j + 1][k][4])) + (udx[i][j][m][4] * v[i + 1][j][k][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[m][0] = d[i][j][m][0];\n      tmat[m][1] = d[i][j][m][1];\n      tmat[m][2] = d[i][j][m][2];\n      tmat[m][3] = d[i][j][m][3];\n      tmat[m][4] = d[i][j][m][4];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[1][0];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[0][1]);\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[0][2]);\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[0][3]);\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[0][4]);\n    tv[i][j][1] = tv[i][j][1] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[2][0];\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[0][1]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[0][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[0][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[0][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[3][0];\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[0][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[0][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[0][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[0][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][0] * tmp);\n    tmp = tmp1 * tmat[4][0];\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[0][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[0][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[0][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[0][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[2][1];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[1][2]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[1][3]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[1][4]);\n    tv[i][j][2] = tv[i][j][2] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[3][1];\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[1][2]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[1][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[1][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][1] * tmp);\n    tmp = tmp1 * tmat[4][1];\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[1][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[1][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[1][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[3][2];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[2][3]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[2][4]);\n    tv[i][j][3] = tv[i][j][3] - (tv[i][j][2] * tmp);\n    tmp = tmp1 * tmat[4][2];\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[2][3]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[2][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[4][3];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[3][4]);\n    tv[i][j][4] = tv[i][j][4] - (tv[i][j][3] * tmp);\n    tv[i][j][4] = tv[i][j][4] / tmat[4][4];\n    tv[i][j][3] = tv[i][j][3] - (tmat[3][4] * tv[i][j][4]);\n    tv[i][j][3] = tv[i][j][3] / tmat[3][3];\n    tv[i][j][2] = (tv[i][j][2] - (tmat[2][3] * tv[i][j][3])) - (tmat[2][4] * tv[i][j][4]);\n    tv[i][j][2] = tv[i][j][2] / tmat[2][2];\n    tv[i][j][1] = ((tv[i][j][1] - (tmat[1][2] * tv[i][j][2])) - (tmat[1][3] * tv[i][j][3])) - (tmat[1][4] * tv[i][j][4]);\n    tv[i][j][1] = tv[i][j][1] / tmat[1][1];\n    tv[i][j][0] = (((tv[i][j][0] - (tmat[0][1] * tv[i][j][1])) - (tmat[0][2] * tv[i][j][2])) - (tmat[0][3] * tv[i][j][3])) - (tmat[0][4] * tv[i][j][4]);\n    tv[i][j][0] = tv[i][j][0] / tmat[0][0];\n    v[i][j][k][0] = v[i][j][k][0] - tv[i][j][0];\n    v[i][j][k][1] = v[i][j][k][1] - tv[i][j][1];\n    v[i][j][k][2] = v[i][j][k][2] - tv[i][j][2];\n    v[i][j][k][3] = v[i][j][k][3] - tv[i][j][3];\n    v[i][j][k][4] = v[i][j][k][4] - tv[i][j][4];\n  }\n\n  if (i != iend)\n    flag[i + 1] = 0;\n\n  if (i != ist)\n    flag[i] = 1;\n\n}\n\n", "pragma": "omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/3"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  int sum = 0;\n  for (int k = 0; k < 2; k++)\n  {\n    sum = sum + (errout[k] * outputlayer[k][i]);\n  }\n\n  errl3[i] = (forpassl3[i] * (1 - forpassl3[i])) * sum;\n}\n\n", "pragma": "omp for schedule(dynamic,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/5"}
{"code": "for (const_iterator p = pBegin; p != pEnd; ++p)\n{\n  const int u_index = p->index;\n  const double u_value = p->value;\n  const double tmp1A = coef * u_value;\n  pF->add(u_index, u_index, tmp1A * u_value);\n  const_iterator qEnd = upper_bound(p + 1, pEnd, WFGrid(0, cutoffValue / tmp1A), WFGrid_sort_functional());\n  for (const_iterator q = p + 1; q != qEnd; ++q)\n  {\n    const int v_index = q->index;\n    const double v_value = q->value;\n    pF->add(u_index, v_index, tmp1A * v_value);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCalcGridX/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  next_x[i] = b[i];\n  for (int j = 0; j < n; ++j)\n  {\n    if (i != j)\n    {\n      next_x[i] -= A[i][j] * x[j];\n    }\n\n  }\n\n  next_x[i] /= A[i][i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/6"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  for (int j = 0; j < size; ++j)\n  {\n    for (int k = 0; k < size; ++k)\n      C[i][j] += A[i][k] * B[k][j];\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JeremyLWright/openmp-game-of-life/MatrixProj/matrix/2"}
{"code": "for (int i = w.start; i < w.end; i++)\n{\n  RSComplex PSIIKI;\n  RSComplex CDUM;\n  Pole pole = data.poles[(nuc * data.max_num_poles) + i];\n  RSComplex t1 = {0, 1};\n  RSComplex t2 = {sqrt(E), 0};\n  PSIIKI = c_div(t1, c_sub(pole.MP_EA, t2));\n  RSComplex E_c = {E, 0};\n  CDUM = c_div(PSIIKI, E_c);\n  sigT += c_mul(pole.MP_RT, c_mul(CDUM, sigTfactors[pole.l_value])).r;\n  sigA += c_mul(pole.MP_RA, CDUM).r;\n  sigF += c_mul(pole.MP_RF, CDUM).r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/5"}
{"code": "for (i = 0; i < nout; i++)\n  _hull.push_back(data0[hullbuf[i]]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/euclidean_cluster/kernel/3"}
{"code": "for (j = 0; j < num_impulse_samples; j++)\n{\n  for (output_channel = 0; output_channel < num_output_channels; output_channel++)\n  {\n    input_channel = output_channel;\n    impulse_channel = output_channel;\n    if (num_input_channels < 2)\n      input_channel = 0;\n\n    if (num_impulse_channels < 2)\n      impulse_channel = 0;\n\n    if (((i - j) < 0) || ((i - j) >= num_input_samples))\n      input_sample = 0.0;\n    else\n      input_sample = inputAF.samples[input_channel][i - j];\n\n    sum += input_sample * impulseAF.samples[impulse_channel][j];\n  }\n\n}\n\n", "pragma": "      #pragma omp for nowait schedule(static, num_impulse_samples/p)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tristanelma/reverb_parallelization/project/impulse_parallel/3"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    for (i = 1; i < (grid_points[0] - 1); i++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] * dt;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/71"}
{"code": "for (int node = g->num_nodes - 1; node >= 0; node--)\n{\n  if (distances[node] == NOT_VISITED_MARKER)\n  {\n    int start_edge = g->incoming_starts[node];\n    int end_edge = (node == (g->num_nodes - 1)) ? (g->num_edges) : (g->incoming_starts[node + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      if (distances[g->incoming_edges[neighbor]] == current_value)\n      {\n        distances[node] = distances[g->incoming_edges[neighbor]] + 1;\n        int index = 0;\n        index = __sync_fetch_and_add(&new_frontier->count, 1);\n        new_frontier->vertices[index] = node;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic, g->num_nodes/1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/bfs/bfs/4"}
{"code": "for (it = line.begin(); it < line.end(); ++it)\n{\n  if (Symbols.find(*it) != npos)\n  {\n    *it = ' ';\n  }\n\n}\n\n", "pragma": "       \t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhatiasiddharth/Parallel-Indexer/mpi-openmp/tfidf/0"}
{"code": "for (j = 1; j <= NLat; j++)\n{\n  R6[j] = cosdeg(LatMin + ((j - 0.5) * DLat));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/7"}
{"code": "for (*n_placed = 0, x = 0; x < L; x++)\n{\n  current_weight = beta - ((alpha * step) * ((double) x));\n  for (y = 0; y < L; y++)\n  {\n    *n_placed += random_draw((n_input * (current_weight / total_weight)) / L, parm);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/PIC/pic/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (i == j)\n      A[i][j] = ((double) (rand() % maxnum)) + 5.0;\n    else\n      A[i][j] = ((double) (rand() % maxnum)) + 1.0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUMB_CORES) schedule(dynamic, chunksize) collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/gaussian_openmp/3"}
{"code": "for (idx_t mode = 0; mode < nmults; ++mode)\n{\n  const idx_t m = (start + mode) % nmats;\n  const idx_t I = mats[m]->I;\n  const val_t * const Av = mats[m]->vals;\n  memset(bufv, 0, (F * F) * (sizeof(val_t)));\n  for (idx_t i = 0; i < I; ++i)\n  {\n    for (idx_t mi = 0; mi < F; ++mi)\n    {\n      for (idx_t mj = mi; mj < F; ++mj)\n      {\n        bufv[mj + (mi * F)] += Av[mi + (i * F)] * Av[mj + (i * F)];\n      }\n\n    }\n\n  }\n\n  for (idx_t mi = 0; mi < F; ++mi)\n  {\n    for (idx_t mj = mi; mj < F; ++mj)\n    {\n      rv[mj + (mi * F)] *= bufv[mj + (mi * F)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/18"}
{"code": "for (i = 0; i < nrows; i++)\n{\n  for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n  {\n    if (rowval[j] != 0.0)\n      rowval[j] = .1 + sign(rowval[j], powf(fabs(rowval[j]), .65));\n\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/4"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/38"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < TRAN; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, Q, (MPI_Datatype) 0x4c000406, T, Q, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((Q * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (Q - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/59"}
{"code": "for (k = 0; k < counterTid; k++)\n  for (l = 0; l < 256; l++)\n  histogram[l] += histograms[k][l];\n\n\n", "pragma": "omp parallel for private(k, l) shared(histogram,histograms, counterTid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShalevSaban/Histogram-CUDA-MPI-OPENMP/openMpFuncs/2"}
{"code": "for (int i = 0; i < (len - 1); i++)\n{\n  for (int j = i + 1; j < len; j++)\n  {\n    if (distances[i] > distances[j])\n    {\n      float t = distances[i];\n      distances[i] = distances[j];\n      distances[j] = t;\n      int m = sortDistances[i];\n      sortDistances[i] = sortDistances[j];\n      sortDistances[j] = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/8"}
{"code": "for (i = 0; i < 5; ++i)\n  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/IPB2_fmt_plug/2"}
{"code": "for (int i = max_cols - 4; i >= 0; i--)\n{\n  for (int idx = 0; idx <= i; idx++)\n  {\n    int index = ((((((max_cols - idx) - 2) * max_cols) + idx) + max_cols) - i) - 2;\n    input_itemsets[index] = maximum(input_itemsets[(index - 1) - max_cols] + referrence[index], input_itemsets[index - 1] - penalty, input_itemsets[index - max_cols] - penalty);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/10"}
{"code": "for (i = 0; i < nbRawMatrix; ++i)\n{\n  error = 1.0;\n  intiValueLayer(tabLayer[0], i);\n  fillOutc(outc, i);\n  rnnsetstart(tabLayer);\n  rnnset(tabLayer, outc);\n  ajustError(tabLayer[NBLAYER - 1]);\n  error = geterror(tabLayer[NBLAYER - 1], outc);\n  printf(\"\\nLigne : %d | Error : %f |\", i, error);\n  displayVector(outc, sizeOfTableOutput);\n  wichError(tabLayer[NBLAYER - 1], outc);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/28"}
{"code": "for (int i = 1; i < (gpu_count + 1); i++)\n{\n  alloc_cuda(&tasks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rickyboy320/hpc_bench/vector/vector/3"}
{"code": "for (i = 0; i < s; i++)\n{\n  for (j = i + 1; j < s; j++)\n  {\n    float distance;\n    float x;\n    float y;\n    x = vector[i].x - vector[j].x;\n    y = vector[i].y - vector[j].y;\n    x = x * x;\n    y = y * y;\n    distance = x + y;\n    distance = sqrt(distance);\n    selected[(i * s) + j].value = distance;\n    selected[(i * s) + j].position = j;\n    selected[(j * s) + i].value = distance;\n    selected[(j * s) + i].position = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/other-nearest/src/other-nearest_gpu/2"}
{"code": "for (long i = 0; i < I->ntracks_2D; i++)\n{\n  if ((i % 50) == 0)\n    if (I->mype == 0)\n    printf(\"%s%ld%s%ld\\n\", \"2D Tracks Completed = \", i, \" / \", I->ntracks_2D);\n\n\n  bool pos_z_dir = 1;\n  for (int j = 0; j < I->n_polar_angles; j++)\n  {\n    if (j == (I->n_polar_angles / 2))\n      pos_z_dir = 0;\n\n    float p_angle = params->polar_angles[j];\n    float mu = cos(p_angle);\n    int begin_stacked = 0;\n    int end_stacked = I->z_stacked;\n    for (int n = 0; n < params->tracks_2D[i].n_segments; n++)\n    {\n      float s_full = params->tracks_2D[i].segments[n].length / sin(p_angle);\n      float ds = 0;\n      for (int k = begin_stacked; k < end_stacked; k++)\n      {\n        float s = s_full;\n        Track *track = &params->tracks[i][j][k];\n        bool seg_complete = 0;\n        int curr_interval;\n        if (pos_z_dir)\n          curr_interval = get_pos_interval(track->z_height, fine_delta_z);\n        else\n          curr_interval = get_neg_interval(track->z_height, fine_delta_z);\n\n        while (!seg_complete)\n        {\n          bool reset = 0;\n          float z = track->z_height + (s * cos(p_angle));\n          int new_interval;\n          if (pos_z_dir)\n            new_interval = get_pos_interval(z, fine_delta_z);\n          else\n            new_interval = get_neg_interval(z, fine_delta_z);\n\n          if (new_interval == curr_interval)\n          {\n            seg_complete = 1;\n            ds = s;\n          }\n          else\n          {\n            if (pos_z_dir)\n            {\n              curr_interval++;\n              z = fine_delta_z * ((float) curr_interval);\n            }\n            else\n            {\n              curr_interval--;\n              z = fine_delta_z * ((float) curr_interval);\n            }\n\n            ds = (z - track->z_height) / cos(p_angle);\n            s -= ds;\n            if (s <= 0)\n              seg_complete = 1;\n\n            if ((z <= 0) || (z >= node_delta_z))\n            {\n              seg_complete = 1;\n              if (pos_z_dir)\n                end_stacked--;\n              else\n                begin_stacked++;\n\n              reset = 1;\n            }\n\n          }\n\n          long QSR_id = rand() % I->n_source_regions_per_node;\n          if (I->axial_exp == 2)\n          {\n            attenuate_fluxes(track, 1, &params->sources[QSR_id], I, params, ds, mu, params->tracks_2D[i].az_weight, &A);\n            segments_processed++;\n          }\n          else\n            if (I->axial_exp == 0)\n          {\n            attenuate_FSR_fluxes(track, 1, &params->sources[QSR_id], I, params, ds, mu, params->tracks_2D[i].az_weight, &A);\n            segments_processed++;\n          }\n          else\n          {\n            printf(\"Error: invalid axial expansion order\");\n            printf(\"\\n Please input 0 or 2\\n\");\n            exit(1);\n          }\n\n\n          if ((n == (params->tracks_2D[i].n_segments - 1)) || reset)\n          {\n            if (pos_z_dir)\n              track->z_height = I->axial_z_sep * k;\n            else\n              track->z_height = I->axial_z_sep * (k + 1);\n\n          }\n          else\n            track->z_height = z;\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule( dynamic )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/0"}
{"code": "for (int i = 0; i < pointsLength; i++)\n{\n  double dist = 0;\n  for (int x = 0; x < dimensions; x++)\n  {\n    dist += fabs(points[(i * dimensions) + x] - reference[x]);\n  }\n\n  if (dist > distances[maxSize - 1])\n  {\n    int index = 0;\n    while ((dist < distances[index]) && (index < maxSize))\n    {\n      index++;\n    }\n\n    for (int j = maxSize - 1; j > index; j--)\n    {\n      distances[j] = distances[j - 1];\n      for (int tmpIdx = 0; tmpIdx < dimensions; tmpIdx++)\n      {\n        realPoints[(j * dimensions) + tmpIdx] = realPoints[((j - 1) * dimensions) + tmpIdx];\n      }\n\n    }\n\n    distances[index] = dist;\n    for (int tmpIdx = 0; tmpIdx < dimensions; tmpIdx++)\n    {\n      realPoints[(index * dimensions) + tmpIdx] = points[(i * dimensions) + tmpIdx];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/loremacchia/kMeans/omp/main/7"}
{"code": "for (j = jst; j <= jend; j++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    flux[i][j][k][0] = u[i][j][k][1];\n    u21 = u[i][j][k][1] / u[i][j][k][0];\n    q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n    flux[i][j][k][1] = (u[i][j][k][1] * u21) + (C2 * (u[i][j][k][4] - q));\n    flux[i][j][k][2] = u[i][j][k][2] * u21;\n    flux[i][j][k][3] = u[i][j][k][3] * u21;\n    flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u21;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(L2 ,nx ,j ,k ,u21 ,q ,nz ,jst ,jend ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/66"}
{"code": "for (; j < N; j++)\n{\n  res2 += (u[j] * u[j]) / (d[j] - lambda_j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Secular_Equation_Solvers_In_OpenMP/gragg/7"}
{"code": "for (i = 1; i < numOfProcs; i++)\n{\n  startAlpha = *currentAlpha;\n  if (startAlpha > alphaMax)\n    startAlpha = HUGE_NUMBER;\n  else\n  {\n    *numOfProcsUsed = (*numOfProcsUsed) + 1;\n    for (j = 0, *currentAlpha = startAlpha; ((*currentAlpha) < alphaMax) && (j < (chunkSize - 1)); j++)\n      *currentAlpha += alphaZero;\n\n  }\n\n  MPI_Send(&startAlpha, 1, MPI_DOUBLE, i, START_ALPHA_TAG, MPI_COMM_WORLD);\n  MPI_Send(currentAlpha, 1, MPI_DOUBLE, i, LAST_ALPHA_TAG, MPI_COMM_WORLD);\n  *currentAlpha += alphaZero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danrol/Parallel_Perceptron_MPI_CUDA_openMP/CudaMPIOpenMP_onVDI/MPIAndOpenMPMethods/2"}
{"code": "for (int i = 0; i < niters; ++i)\n  S.solve(x1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/17"}
{"code": "for (k = (*arr_start)[2]; k <= (*arr_end)[2]; k++)\n{\n  for (j = (*arr_start)[1]; j <= (*arr_end)[1]; j++)\n  {\n    for (i = (*arr_start)[0]; i <= (*arr_end)[0]; i++)\n    {\n      int x;\n      x = (i + (j * ni)) + ((k * ni) * nj);\n      psum += data[x];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/2"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_sequence(X, N);\n  start = _rdtsc();\n  sequential_bitonic_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted_sequence(X, N))\n  {\n    fprintf(stderr, \"ERROR: the sequential sorting of the array failed\\n\");\n    print_array(X, N);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/bitonicsort/2"}
{"code": "for (unsigned long long i = 0; i < n_explorers; ++i)\n{\n  if (solutions_h[i] > 0)\n    qtd_sols_global += solutions_h[i];\n\n  if (vector_of_tree_size_h[i] > 0)\n    tree_size += vector_of_tree_size_h[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nqueen-omp/main/8"}
{"code": "for (i = 0; i < (m * n); ++i)\n{\n  sse += pow(c[i] - c_gpu[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openmpf/openmpf-component-archive/DarknetDetection/darknet_lib/src/gemm/10"}
{"code": "for (unsigned i = 0; i < ((I * I) * I); ++i)\n  if (A[i] != ReferenceA[i])\n{\n  printf(\"Error A[i] != ReferenceA[i] at %08x: %08x != %08x\\n\", i, A[i], ReferenceA[i]);\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-data-sharing-many-teams/test/3"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  {\n    a = 2;\n  }\n}\n\n", "pragma": "  #pragma omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/ordered_ast_print/1"}
{"code": "for (int i = 0; i < n; ++i)\n  array[i] = 1.;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/Cuda-Polynomial/polynomial/2"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  s = a[i];\n  r = b[i];\n  t = a[i] * b[i];\n  printf(\"%d \", r);\n  printf(\" * %d \", s);\n  printf(\" = %d \\n\", t);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pierorex/parallelism-homework/practica6/e6/2"}
{"code": "for (int i = 0; i < NUM_STATS; i++)\n{\n  double s = s_stats[i];\n  double p = p_stats[i];\n  char faster = (s < p) ? ('s') : ('p');\n  s_total += s;\n  p_total += p;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/rsa/utils/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  double x = getrand(&seed) - 1;\n  double y = getrand(&seed);\n  s_loc += func(x, y);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SazPavel/Numerical_integration_OpenMP_SIBSUTIS/monte-carlo/0"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (2 * nxhd) * i;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(f[(2 * j) + joff]);\n    f[(2 * j) + joff] = crealf(f[(2 * j) + joff]) + (crealf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n    f[(1 + (2 * j)) + joff] = at1 + (cimagf(f[(1 + (2 * j)) + joff]) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      t1 = f[(2 * j1) + joff];\n      t2 = f[(1 + (2 * j1)) + joff];\n      f[(2 * j1) + joff] = f[(2 * j) + joff];\n      f[(1 + (2 * j1)) + joff] = f[(1 + (2 * j)) + joff];\n      f[(2 * j) + joff] = t1;\n      f[(1 + (2 * j)) + joff] = t2;\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = sct[kmr * j];\n        t2 = t1 * f[(2 * j2) + joff];\n        t3 = t1 * f[(1 + (2 * j2)) + joff];\n        f[(2 * j2) + joff] = f[(2 * j1) + joff] - t2;\n        f[(1 + (2 * j2)) + joff] = f[(1 + (2 * j1)) + joff] - t3;\n        f[(2 * j1) + joff] += t2;\n        f[(1 + (2 * j1)) + joff] += t3;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxy / nx;\n  ani = 0.5 / (((float) nx) * ((float) ny));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < 2; jj++)\n    {\n      t2 = conjf(f[(jj + (2 * (nxh - j))) + joff]);\n      t1 = f[(jj + (2 * j)) + joff] + t2;\n      t2 = (f[(jj + (2 * j)) + joff] - t2) * t3;\n      f[(jj + (2 * j)) + joff] = ani * (t1 + t2);\n      f[(jj + (2 * (nxh - j))) + joff] = ani * conjf(t1 - t2);\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (jj = 0; jj < 2; jj++)\n  {\n    f[(jj + (2 * nxhh)) + joff] = ani * conjf(f[(jj + (2 * nxhh)) + joff]);\n    f[jj + joff] = ani * ((crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,joff,at1,ani,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/3"}
{"code": "for (int source = 1; source < size; ++source)\n{\n  MPI_Cart_coords(comm_cart, source, 2, coords);\n  int rx = params.gx % dims[0];\n  int ry = params.gy % dims[1];\n  int sx = (coords[0] * (params.gx / dims[0])) + ((coords[0] < rx) ? (coords[0]) : (rx));\n  int sy = (coords[1] * (params.gy / dims[1])) + ((coords[1] < ry) ? (coords[1]) : (ry));\n  int lx = (params.gx / dims[0]) + ((coords[0] < rx) ? (1) : (0));\n  int ly = (params.gy / dims[1]) + ((coords[1] < ry) ? (1) : (0));\n  int nx = lx + 2;\n  int ny = ly + 2;\n  for (int ii = 0; ii < ly; ++ii)\n  {\n    MPI_Recv(&cells[((sy + ii) * params.gx) + sx], lx, mpi_speed_type, source, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n    MPI_Recv(&obstacles[((sy + ii) * params.gx) + sx], lx, (MPI_Datatype) 0x4c000405, source, 0, (MPI_Comm) 0x44000000, (MPI_Status *) 1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/4"}
{"code": "for (x = 0; x < 64; x++)\n{\n  ;\n}\n\n", "pragma": "omp distribute parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/clauses-4/3"}
{"code": "for (i = 0; i < ((int) n_b); i++)\n{\n  result[i] = (*a) > b[i];\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/31"}
{"code": "for (i = 2; i < m_size; i++)\n  for (j = 1; j < i; j++)\n  uArray[i][j] = 0;\n\n\n", "pragma": "  #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aldlfkahs/OpenMP-LUdecomposition/lu-omp/3"}
{"code": "for (unsigned long long int i = 0; i < 76; i++)\n{\n  printf(\"%06d \", p.path[i]);\n  if (((i + 1) % 10) == 0)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebaMederos/TSP-OpenMP/sim-ann/SA/4"}
{"code": "for (i = 0; i < prof; i++)\n{\n  temp = x;\n  x2 = x * x;\n  y2 = y * y;\n  x = (x2 - y2) + a;\n  y = ((2 * temp) * y) + b;\n  if ((x2 + y2) >= 4.0)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/mandel/1"}
{"code": "for (i = 0; i < t; i++)\n{\n  omg[i] = cpx(cos(((2 * PI) * i) / t), sin(((2 * PI) * i) / t));\n}\n\n", "pragma": "    #pragma omp parallel for shared(omg)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/0"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    density1[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D(j, 0 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/4"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  if (marker[i] == 0)\n  {\n    levset[0] = i;\n    qlength = 1;\n    cast_perm->vec_[i] = next;\n    marker[i] = 1;\n    ++next;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/79"}
{"code": "for (n = 0; n < 4; n++)\n{\n  printf(\"thread %d:i=%d\\n\", omp_get_thread_num(), i);\n  i = 100 + omp_get_thread_num();\n}\n\n", "pragma": "omp for lastprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jadhavganesh/OpenMp_File/private/last_private/0"}
{"code": "for (int i = 0; i < argc; ++i)\n  a = (((foo(&i) + foo(&a)) + foo(&b[i])) + foo(&c[i])) + foo(&d[i]);\n\n", "pragma": "#pragma omp distribute parallel for firstprivate(b) lastprivate(c) if(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/nvptx_distribute_parallel_generic_mode_codegen/0"}
{"code": "for (int i_counter = 4; i_counter <= pnHalfed; i_counter++)\n{\n  if ((pn % i_counter) == 0)\n  {\n    primIndicator = false;\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hu-ry/MathOMP/src/mathomp/2"}
{"code": "for (int i = 0; i < intervals.divisions; i++)\n{\n  pthread_create(&thds[i], 0, _call, &intervals.args[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fol21/parallel-adaptative_quadrature/src/adaptative-quadrature/0"}
{"code": "for (int i = 0; i < grid_size; i++)\n{\n  for (int j = 0; j < grid_size; j++)\n  {\n    cell_t *cell = &cells[i][j];\n    for (int k = 1; k < num_threads; k++)\n    {\n      cell_t *thread_cell = &cells_threads[k][i][j];\n      cell->mass_sum += thread_cell->mass_sum;\n      cell->center_of_mass.x += thread_cell->center_of_mass.x;\n      cell->center_of_mass.y += thread_cell->center_of_mass.y;\n    }\n\n    if (cell->mass_sum != 0)\n    {\n      cell->center_of_mass.x /= cell->mass_sum;\n      cell->center_of_mass.y /= cell->mass_sum;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrodaniel10/CPD/src/openmp/simpar-omp/1"}
{"code": "for (int i = 0; i < 15; i++)\n{\n  for (int j = i + 1; j < 16; j++)\n    if (((board[i] > board[j]) && (board[i] != 0)) && (board[j] != 0))\n  {\n    count++;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohadesehjm/Multicore-Npuzzle/15p/13"}
{"code": "for (i = 0; i < 134217728; ++i)\n{\n  double x = (i + 0.5) * dx;\n  pi += 1.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp parallel for private(i) reduction(+: pi)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/pi/pi_parallel_reduction/0"}
{"code": "for (k = kinf; k < ksup; k++)\n  for (i = iinf; i < isup; i++)\n  for (j = jinf; j < jsup; j++)\n  A[i][j]--;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/masotrix/OpenMP/Basics/P5/main/1"}
{"code": "for (int g = 0; g < number; g++)\n{\n  x = ((((2.0 * g) * 1.0) - 1.0) / h) * 1.0;\n  sumOnThread += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "#pragma omp for schedule(guided, 10) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Artemidaazaza/lab3openmp/lab3openmp/lab3openmp/0"}
{"code": "for (i = 0; i < orderOfMatrix; i++)\n{\n  lineSum[i] = 0;\n}\n\n", "pragma": "omp parallel for private(i) num_threads(numberOfThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/2"}
{"code": "for (j = 0; j < nxyzh; j++)\n{\n  arg = dnxyz * ((float) j);\n  sct[j] = cosf(arg) - (sinf(arg) * _Complex_I);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/53"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * (((5.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113]) - (4.0 * u[i_imopVar110][j_imopVar111 + 1][k_imopVar112][m_imopVar113])) + u[i_imopVar110][j_imopVar111 + 2][k_imopVar112][m_imopVar113]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/16"}
{"code": "for (; (i + 31) < n; i += 32)\n{\n  xv[0] = _mm256_load_ps(&x[i + 0]);\n  xv[1] = _mm256_load_ps(&x[i + 8]);\n  xv[2] = _mm256_load_ps(&x[i + 16]);\n  xv[3] = _mm256_load_ps(&x[i + 24]);\n  _mm256_store_ps(&y[i + 0], xv[0]);\n  _mm256_store_ps(&y[i + 8], xv[1]);\n  _mm256_store_ps(&y[i + 16], xv[2]);\n  _mm256_store_ps(&y[i + 24], xv[3]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/11"}
{"code": "for (unsigned int i = 0; i < nsubranks_1d; ++i)\n{\n  g.in_queue[i].bm.ensure_size(nvertices_local_2d_per_subowner(lg_nvertices, lg_nvertices_local_1d_per_subowner));\n  g.in_blocks_empty[i].clear();\n  g.in_blocks_empty[i].resize(((nvertices_local_2d_per_subowner(lg_nvertices, lg_nvertices_local_1d_per_subowner) + (1 << 16)) - 1) >> 16, 1);\n  g.out_queue[i].bm.ensure_size(nvertices_local_2d_per_subowner(lg_nvertices, lg_nvertices_local_1d_per_subowner));\n  g.out_queue_last[i].bm.ensure_size(0);\n  g.my_assigned_targets[i].bm.ensure_size(nvertices_local_2d_per_subowner(lg_nvertices, lg_nvertices_local_1d_per_subowner));\n  g.visited[i].bm.ensure_size(nvertices_local_2d_per_subowner(lg_nvertices, lg_nvertices_local_1d_per_subowner));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/18"}
{"code": "for (int i = 0; i < m; ++i)\n{\n  predict[i] = h(x[i], old_weights, no_of_features, bias_old);\n  double g = 0.0;\n  for (int k = 0; k < no_of_features; ++k)\n  {\n    double gradient = 0.0;\n    gradient = (predict[i] - y[i]) * x[i][k];\n    new_weights[k] = (old_weights[k] - ((alpha * gradient) / m)) - ((l2 / m) * old_weights[k]);\n  }\n\n  g = predict[i] - y[i];\n  bias = bias_old;\n  bias_old = (bias - ((alpha * g) / m)) - ((l2 / m) * bias);\n  cross_entropy_loss += -(((y[i] * log(predict[i])) + ((1 - y[i]) * log(1 - predict[i]))) / m);\n  swap(old_weights, new_weights);\n}\n\n", "pragma": "#pragma omp for reduction(+ \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/logistic/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  matrix[i] = malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ryszard-put/PR-openmp-cuda/matrix-parallel/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"tid=%d\\n\", id);\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/omp/old/vector/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (act[i] == res[i])\n    count++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/24"}
{"code": "for (i = 0; i < (dim * dim); i++)\n  A[i] = i * 2.;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/Openmp/FastTr_omp/2"}
{"code": "for (i = 0; i < v_size; i++)\n{\n  if ((i % m_size) != (m_size - 1))\n    printf(\"%2d \", sudoku[i]);\n  else\n    printf(\"%2d\\n\", sudoku[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/mpi/sudoku-mpi/12"}
{"code": "for (i = 0; i < nn; i++)\n{\n  for (j = 0; j < nn; j++)\n  {\n    if (c_mat[(i * nn) + j] != 0)\n      dist_mat[(i * nn) + j] = c_mat[(i * nn) + j];\n    else\n      dist_mat[(i * nn) + j] = H_VAL;\n\n    if (i == j)\n      dist_mat[(i * nn) + j] = 0;\n\n    if ((dist_mat[(i * nn) + j] > 0) && (dist_mat[(i * nn) + j] < H_VAL))\n      pred_mat[(i * nn) + j] = i;\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for                               ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TransientObject/ParallelizeAlgos/lib/floyd_warshall/floyd/0"}
{"code": "for (int i = 0; i < N2; i++)\n{\n  for (int j = 0; j < N2; j++)\n  {\n    (cout << table[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnstephenson39/gameoflife_openmp/gol/0"}
{"code": "for (int i = start; i < end; i++)\n{\n  printf(\"%d \", arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tanghyd/CITS5507Project01/random_array/5"}
{"code": "for (int p = 1; p <= r1; p++)\n{\n  int k = omp_get_thread_num();\n  int i = I1[p];\n  int j = i + l;\n  double alpha = 0;\n  double beta = 0;\n  double gamma = 0;\n  double zeta;\n  double tau;\n  double cos_theta;\n  double sin_theta;\n  calculate_alpha_beta_gamma(alpha, beta, gamma, matrix_U, A.size(), i, j);\n  double temp = max(C[k], abs(gamma) / sqrt(alpha * beta));\n  C[k] = temp;\n  zeta = (beta - alpha) / (2.0 * gamma);\n  tau = sgn(zeta) / (abs(zeta) + sqrt(1.0 + (zeta * zeta)));\n  cos_theta = 1.0 / sqrt(1.0 + (tau * tau));\n  sin_theta = cos_theta * tau;\n  assiging_sin_cos_operations_to_matrix(matrix_U, matrix_V, cos_theta, sin_theta, tau, i, j, columns);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(num)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    c[i][j] = randomize(&seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kothiga/Matrix-Matrix-Parallel/MatMultOpenMP/10"}
{"code": "for (int y_dash = y_diff; y_dash > 0; y_dash--)\n{\n  yans[y_dash] = (int) '_';\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing12/test/8"}
{"code": "for (i = 1; i < N; i++)\n  aindex[i] = i - 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/7"}
{"code": "for (int ix = 0; ix < size; ++ix)\n{\n  for (int iy = 0; iy < size; ++iy)\n  {\n    (cout << M[ix][iy]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/I-Iaroslav/MIPT_Programs/Parallel_2/Strassen/0"}
{"code": "for (i = 1; i < n_threads; i++)\n  local_newClusterSize[i] = local_newClusterSize[i - 1] + n_clusters;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreP-git/Kmeans-OpenMP/kmeans/7"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  for (j = 1; j < (columns - 1); j++)\n  {\n    if ((step % 2) == 0)\n    {\n      surfaceCopy[(i * columns) + j] = (((surface[((i - 1) * columns) + j] + surface[((i + 1) * columns) + j]) + surface[(i * columns) + (j - 1)]) + surface[(i * columns) + (j + 1)]) / 4;\n    }\n    else\n    {\n      surface[(i * columns) + j] = (((surfaceCopy[((i - 1) * columns) + j] + surfaceCopy[((i + 1) * columns) + j]) + surfaceCopy[(i * columns) + (j - 1)]) + surfaceCopy[(i * columns) + (j + 1)]) / 4;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SantiagoBlascoArnaiz/ParalelaOMP/extinguishing/0"}
{"code": "for (unsigned int i = StartXLocal; i < MaxXLocal; i++)\n  for (unsigned int j = 0; j < F->GetY(); j++)\n{\n  F->GetValue(i, j).Q_conv = 0.;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/18"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  initializeQueue(&queues[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vivekmurali/producer_consumer_openmp/omp_tokenizer/2"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  int tID = omp_get_thread_num();\n  printf(\"[%d] by thread %d\\n\", i, tID);\n  Sleep(1);\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided) num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture14/guided_scheduling/guided_scheduling/0"}
{"code": "for (i = oldI; i < N_gas; i++)\n{\n  if (P[i].Ti_endstep == All.Ti_Current)\n  {\n    ndone++;\n    for (j = 0; j < NTask; j++)\n    {\n      Exportflag2[(i * NTask) + j] = 0;\n    }\n\n    density_evaluate(i, 0);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:ndone)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/density/0"}
{"code": "for (m = 3; m < 5; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      n = ((m - 3) + 1) * 5;\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,i1 ,i ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/167"}
{"code": "for (int i = 0; i < cloud_size; ++i)\n{\n  processed[i] = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(cloud_size, processed)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP/euclidean_cluster/kernel/1"}
{"code": "for (v = 0; v < stats->num_vertices; v++)\n{\n  if (stats->distances[v] != (4294967295U / 2))\n  {\n    printf(\"d %u \\n\", stats->distances[v]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/7"}
{"code": "for (j = 0; j < y; j++)\n{\n  for (k = 0; k < z; k++)\n  {\n    pressure_on_solid[i][j][k] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/pressure_on_solid_reset/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if (sorttype != RADIX)\n    (cout << getkey(data, i)) << \"\\t\";\n  else\n    (cout << getkey(data, i)) << \"\\n\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishek4747/openmp-sort/test/0"}
{"code": "for (i = 1; i < (1 << TOTAL_KEYS_LOG_2); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/52"}
{"code": "for (toss = 0; toss < number_of_tosses; toss++)\n{\n  x = (2 * my_drand(&seed)) - 1;\n  y = (2 * my_drand(&seed)) - 1;\n  distance_squared = (x * x) + (y * y);\n  if (distance_squared <= 1)\n    number_in_circle++;\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: number_in_circle) schedule(runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pouyarz/Parallel--Monte-Carlo-method-for-Pi--using-OpenMP/omp_pi_monte_carlo/0"}
{"code": "for (i = 0; i < array_size; i++)\n{\n  product *= my_array[i];\n  product %= module_product;\n}\n\n", "pragma": "#pragma omp for reduction(* : product) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/blackgold44441/multithreading_openmp/programm_1_openmp/0"}
{"code": "for (i = 0; i < nbits; i++)\n{\n  if (k & bitmask)\n  {\n    *pQ = addpoints(*pQ, Psums[i], a, p, 0);\n  }\n\n  bitmask = bitmask << 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bumbleblo/ppd-openmp/vow_with_hash/5"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,k ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/126"}
{"code": "for (iter = 0; iter <= iterations; iter++)\n{\n  if (iter == 1)\n    dgemm_time = wtime();\n\n  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, order, order, order, 1.0, &A[0 + (order * 0)], order, &B[0 + (order * 0)], order, 1.0, &C[0 + (order * 0)], order);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/DGEMM/dgemm/4"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (k = 1; k <= (nz - 2); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = dt * rsd[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/130"}
{"code": "for (i = sharedFrontierQueue->head; i < sharedFrontierQueue->tail; i++)\n{\n  v = sharedFrontierQueue->queue[i];\n  edge_idx = graph->vertices->edges_idx[v];\n  for (j = edge_idx; j < (edge_idx + graph->vertices->out_degree[v]); j++)\n  {\n    u = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n    int u_parent = stats->parents[u];\n    if (u_parent < 0)\n    {\n      if (__sync_bool_compare_and_swap(&stats->parents[u], u_parent, v))\n      {\n        enArrayQueue(localFrontierQueue, u);\n        mf += -u_parent;\n        stats->distances[u] = stats->distances[v] + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:mf) schedule(auto)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  guess = exp(guess);\n  guess = sin(guess);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_sections/01_sections_nested/4"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  for (size_t j = 0; j < 40000; j++)\n  {\n    if ((j > i) && (graph[(i * 40000) + j] != 0))\n    {\n      num_edges++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/9"}
{"code": "for (int i = 0; i < argc; i++)\n{\n  ((((cout << \"argv[\") << i) << \"]:\\t\") << argv[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/9"}
{"code": "for (i = 1; i < size_results; i++)\n{\n  if (results[i] > final_score)\n  {\n    final_class = i;\n    final_score = results[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/NeuralNet/1"}
{"code": "for (i = j1; i <= k1; ++i)\n{\n  if ((i < j2) || (i > k2))\n    ++e;\n\n  ++c;\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr29947-1/0"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t i;\n  for (i = 0; i < totalPartitions; ++i)\n  {\n    uint32_t k;\n    uint32_t src;\n    uint32_t dest;\n    float weight = 0.0001f;\n    struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n    for (k = 0; k < partition->num_edges; ++k)\n    {\n      src = partition->edgeList->edges_array_src[k];\n      dest = partition->edgeList->edges_array_dest[k];\n      stats->vector_output[dest] += weight * stats->vector_input[src];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  im1 = i - 1;\n  ip1 = i + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tx2 * (ue[1][ip1] - ue[1][im1]))) + (dx1tx1 * ((ue[0][ip1] - (2.0 * ue[0][i])) + ue[0][im1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tx2 * (((ue[1][ip1] * buf[1][ip1]) + (c2 * (ue[4][ip1] - q[ip1]))) - ((ue[1][im1] * buf[1][im1]) + (c2 * (ue[4][im1] - q[im1])))))) + (xxcon1 * ((buf[1][ip1] - (2.0 * buf[1][i])) + buf[1][im1]))) + (dx2tx1 * ((ue[1][ip1] - (2.0 * ue[1][i])) + ue[1][im1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tx2 * ((ue[2][ip1] * buf[1][ip1]) - (ue[2][im1] * buf[1][im1])))) + (xxcon2 * ((buf[2][ip1] - (2.0 * buf[2][i])) + buf[2][im1]))) + (dx3tx1 * ((ue[2][ip1] - (2.0 * ue[2][i])) + ue[2][im1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tx2 * ((ue[3][ip1] * buf[1][ip1]) - (ue[3][im1] * buf[1][im1])))) + (xxcon2 * ((buf[3][ip1] - (2.0 * buf[3][i])) + buf[3][im1]))) + (dx4tx1 * ((ue[3][ip1] - (2.0 * ue[3][i])) + ue[3][im1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tx2 * ((buf[1][ip1] * ((c1 * ue[4][ip1]) - (c2 * q[ip1]))) - (buf[1][im1] * ((c1 * ue[4][im1]) - (c2 * q[im1])))))) + ((0.5 * xxcon3) * ((buf[0][ip1] - (2.0 * buf[0][i])) + buf[0][im1]))) + (xxcon4 * ((cuf[ip1] - (2.0 * cuf[i])) + cuf[im1]))) + (xxcon5 * ((buf[4][ip1] - (2.0 * buf[4][i])) + buf[4][im1]))) + (dx5tx1 * ((ue[4][ip1] - (2.0 * ue[4][i])) + ue[4][im1]));\n}\n\n", "pragma": "omp parallel for firstprivate(dx1tx1 ,tx2 ,dx2tx1 ,xxcon1 ,c2 ,dx3tx1 ,xxcon2 ,dx4tx1 ,dx5tx1 ,xxcon5 ,xxcon4 ,xxcon3 ,c1 ,i ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/17"}
{"code": "for (size_t i = 0; i < mx.size(); ++i)\n{\n  for (size_t j = 0; j < v.size(); ++j)\n  {\n    for (size_t z = 0; z < mx[i].size(); ++z)\n    {\n      result[i][j] += mx[i][z] * v[j][z];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/libs/Math/SimpleMath/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpq7yrhurw.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang8/projects/openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n  fscanf(fp, \"%d\", &matrix[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/caiobrreis/openMP-matrix-multiplication/omp/4"}
{"code": "for (int k = 0; k < waveLength; k++)\n{\n  int i = wave - k;\n  int j = k + 1;\n  if (wave > (nRows - 1))\n  {\n    i = (nRows - 1) - k;\n    j = ((wave - (nRows - 1)) + k) + 1;\n  }\n\n  array[i][j] = (array[i - 1][j] + array[i][j - 1]) + array[i - 1][j - 1];\n}\n\n", "pragma": "#pragma omp parallel for default(none) shared(array,wave,waveLength,nRows,nCols)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/WaveParallelization/WaveParallelization/Parallel/0"}
{"code": "for (m = 0; m < 177; m++)\n{\n  for (n = 0; n < 317; n++)\n  {\n    for (k = 0; k < 6; k++)\n    {\n      for (l = 0; l < 6; l++)\n      {\n        y[(((15 * 177) * 317) + (m * 317)) + n] += in_layer[((((qindex * 358) * 638) + (((m * 2) + k) * 638)) + (n * 2)) + l] * weight[(((54 + q) * 36) + (k * 6)) + l];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-tavana/CNN_OPENMP/conv_layer4/5"}
{"code": "for (int i = 0; i < getVertexNumber(gr); i++)\n{\n  F[i] = 0;\n  X[i] = 0;\n  C[i] = -1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fusiled/large-graphs-openmp/src/graph_algo/1"}
{"code": "for (int i = 0; i < m_cellSize; i++)\n{\n  m_PE[i] = 0.0f;\n  m_INFIL[i] = 0.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/SUR_GA/SUR_GreenAmpt/0"}
{"code": "for (int i = 0; i < matrixN; i++)\n{\n  for (int j = 0; j < matrixN; j++)\n  {\n    (((cout << left) << setw(5)) << setfill(' ')) << Mat[i][j];\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/1/1/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  s->Bt = s->sBt;\n  s->Bt[i] = s->Mcoefs2_3d[0][1][i] * x[i];\n  if ((i - 1) >= 0)\n    s->Bt[i] += s->Mcoefs2_3d[0][0][i] * x[i - 1];\n\n  if ((i + 1) < N)\n    s->Bt[i] += s->Mcoefs2_3d[0][2][i] * x[i + 1];\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/161"}
{"code": "for (int j = 0; j < ENCRYPTEDLEN; ++j)\n  encryptedMap[j] = ENCRYPTED_T[j] - 'a';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/columnarSolver-omp/main/2"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = nppmx * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[3 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[3 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (3 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (3 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    z = ppart[2 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 3 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 3]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 3]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 3]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 3]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 3]));\n    nn += 3 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 3]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 3]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 3])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 3])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 3])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 3]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 3]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 3]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 3]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 3]));\n    nn += 3 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 3]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 3]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 3]);\n    mm = nn + (3 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 3])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 3])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 3])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[3 + (idimp * (j + npoff))] + dx;\n    acy = ppart[4 + (idimp * (j + npoff))] + dy;\n    acz = ppart[5 + (idimp * (j + npoff))] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[3 + (idimp * (j + npoff))] = dx;\n    ppart[4 + (idimp * (j + npoff))] = dy;\n    ppart[5 + (idimp * (j + npoff))] = dz;\n    p2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (dx * dtg);\n    dy = y + (dy * dtg);\n    dz = z + (dz * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        ppart[3 + (idimp * (j + npoff))] = -ppart[3 + (idimp * (j + npoff))];\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        ppart[4 + (idimp * (j + npoff))] = -ppart[4 + (idimp * (j + npoff))];\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        ppart[5 + (idimp * (j + npoff))] = -ppart[5 + (idimp * (j + npoff))];\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        ppart[3 + (idimp * (j + npoff))] = -ppart[3 + (idimp * (j + npoff))];\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        ppart[4 + (idimp * (j + npoff))] = -ppart[4 + (idimp * (j + npoff))];\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n    ppart[2 + (idimp * (j + npoff))] = dz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,noff,moff,loff,npp,npoff,nn,mm,ll,nm,x,y,z,dxp,dyp,dzp, amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm, rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,p2,gami,qtmg,dtg,sum1, sfxyz,sbxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/3"}
{"code": "for (i = 0; i < N; i++)\n  k = fscanf(file, \"%lf\", &testVec[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/savvpais/omp-pagerank/pageRankGSOMP/8"}
{"code": "for (k = 0; k < 10; k++)\n  printf(\"%d, \", x[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/terbos/HPC-OPENMP/barrier1/1"}
{"code": "for (cj = 0; cj < NCELLS; cj++)\n{\n  if (cj != ci)\n    nc += contacts(ci, cj);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/34"}
{"code": "for (int i = 0; i < n; i++)\n{\n  marks[i] = i + 1;\n}\n\n", "pragma": "            #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/gaussianElimination/gaussianEliminationTotalPivot/2"}
{"code": "for (int i = 0; i < length; ++i)\n  if (arr[i] < min)\n  min = arr[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task1/1"}
{"code": "for (int line = 0; line < my_lines.size(); line++)\n{\n  if (req == my_lines[line].index)\n  {\n    response = my_lines[line];\n    break;\n  }\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Lewis98/OpenMP_Tasks/distribution/Poem_task/main/3"}
{"code": "for (int i = 0; i < dataset->n; i++)\n{\n  for (int j = 0; j < dataset->n; j++)\n  {\n    for (int k = 0; k < dataset->n; k++)\n    {\n      dataset->A[i][j][k] = rand() % 100;\n      dataset->B[i][j][k] = rand() % 100;\n      dataset->C[i][j][k] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW3/3DMatMul/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  a = adjacent_toHelpFunction(ArrayBegin, 1, j, N);\n  if (a == 2)\n    NewBoard(0, j) = ArrayBegin[1][j];\n\n  if (a == 3)\n    NewBoard(0, j) = 1;\n\n  if (a < 2)\n    NewBoard(0, j) = 0;\n\n  if (a > 3)\n    NewBoard(0, j) = 0;\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(j,a) shared(ArrayBegin,newboard,N) num_threads(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/GameOfLife_game/src/src/play/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    a[i][j] = 0.5;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB003-antidep2-orig-yes/0"}
{"code": "for (k = y_min - 1; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    node_mass_pre[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (node_mass_post[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - node_flux[FTNREF2D(j, k - 1, x_max + 5, x_min - 2, y_min - 2)]) + node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/11"}
{"code": "for (int i = 7; i >= 0; i--)\n  for (int j = 7; j > (7 - i); j--)\n  if (eigenValue[j] > eigenValue[j - 1])\n  swap(eigenValue[j], eigenValue[j - 1]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/16"}
{"code": "for (int denominator = number - 1; denominator >= 2; denominator--)\n{\n  if ((number % denominator) == 0)\n  {\n    isprime = false;\n    break;\n  }\n\n  if (isprime == false)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YoussefAwny/OpenMP-Lab/Prime Numbers (8 threads)/0"}
{"code": "for (m = 0; m < kd; m = m + inc)\n{\n  xd[m] = xd[m] + (sumd * yd[m]);\n  xd[m + 1] = xd[m + 1] + (sumd * yd[m + 1]);\n  xd[m + 2] = xd[m + 2] + (sumd * yd[m + 2]);\n  xd[m + 3] = xd[m + 3] + (sumd * yd[m + 3]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmemspd/memSpeedOMP/0"}
{"code": "for (i = 1; i < (n + 1); i++)\n{\n  for (j = 1; j < (n + 1); j++)\n  {\n    for (k = 1; k < (n + 1); k++)\n    {\n      a0[(((i * sz) * sz) + (j * sz)) + k] = a1[(((i * sz) * sz) + (j * sz)) + k];\n    }\n\n  }\n\n}\n\n", "pragma": "\t #pragma omp parallel for  private(i,j,k) schedule(dynamic) shared(a1) num_threads(th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/herculeshcs/SYCL-OpenCL-OpenMP-Benchmark/27stencil/stencil27-mod/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    printf(\"%lf   \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 6/matrix-mult/4"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    a[i][j] = (i + 1) + (j + 1);\n    b[i][j] = ((i + j) + 2) * 10;\n    c[i][j] = a[i][j] + b[i][j];\n    tid = omp_get_thread_num();\n    nthreads = omp_get_num_threads();\n    printf(\"   %d        %d    %d   %d     %d\\n\", nthreads, tid, i, j, c[i][j]);\n  }\n\n  printf(\"--------------------------------\\n\");\n}\n\n", "pragma": "omp parallel for private(i, j, tid, nthreads) shared(a, b, c)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter5/dfapli/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA256][32];\n  int i;\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n    pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, master[i], outlen, 0);\n\n  for (i = 0; i < SSE_GROUP_SZ_SHA256; ++i)\n  {\n    cracked[index + i] = fvde_decrypt(cur_salt, master[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/fvde_fmt_plug/4"}
{"code": "for (int i = 0; i < vectorOfFilePaths.size(); i++)\n{\n  readData(string(station), vectorOfFilePaths[i], local_wr);\n}\n\n", "pragma": "\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/WindRosePOC/src_MPI/MP+MPI/0"}
{"code": "for (int i = 2; i < 5; i++)\n{\n  timeStart = omp_get_wtime();\n  SumABParallelSection(masA, masB, masC, MasLen, i);\n  timeEnd = omp_get_wtime();\n  ((cout << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\") << i) << \": \";\n  ((cout << \"\u0412\u0440\u0435\u043c\u044f \u0441\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u0434\u0432\u0443\u0445 \u043c\u0430\u0442\u0440\u0438\u0446\u044b  \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u044c\u043d\u043e \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0441\u0435\u043a\u0446\u0438\u0439 = \") << (timeEnd - timeStart)) << endl;\n  (SaveOut << (timeEnd - timeStart)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    a[i][j] = u(e);\n    b[i][j] = u(e);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_matrix_parallel/1"}
{"code": "for (int x = 0; x < GRAIN; x++)\n{\n  for (int y = 0; y < GRAIN; y++)\n  {\n    if (current_array[(x * GRAIN) + y] == 1)\n    {\n      current_array[(x * GRAIN) + y] = 0;\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          compute_new_state(i, j);\n          if ((cur_img(i, j) != next_img(i, j)) && ((cur_img(i, j) == 0xFFFF00FF) || (next_img(i, j) == 0xFFFF00FF)))\n          {\n            next_array[(x * GRAIN) + y] = 1;\n            if (((i % TILEX) == 0) && (x > 0))\n            {\n              next_array[((x - 1) * GRAIN) + y] = 1;\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[((x - 1) * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[((x - 1) * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n            if (((i % TILEX) == (TILEX - 1)) && (x < (GRAIN - 1)))\n            {\n              next_array[((x + 1) * GRAIN) + y] = 1;\n              if (((j % TILEY) == 0) && (y > 0))\n              {\n                next_array[((x + 1) * GRAIN) + (y - 1)] = 1;\n              }\n\n              if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n              {\n                next_array[((x + 1) * GRAIN) + (y + 1)] = 1;\n              }\n\n            }\n\n            if (((j % TILEY) == 0) && (y > 0))\n            {\n              next_array[(x * GRAIN) + (y - 1)] = 1;\n            }\n\n            if (((j % TILEY) == (TILEY - 1)) && (y < (GRAIN - 1)))\n            {\n              next_array[(x * GRAIN) + (y + 1)] = 1;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n    else\n    {\n      for (int i = TILEX * x; i < (TILEX * (x + 1)); i++)\n      {\n        for (int j = TILEY * y; j < (TILEY * (y + 1)); j++)\n        {\n          if (next_img(i, j) != 0xFFFF00FF)\n          {\n            next_img(i, j) = 0;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/14"}
{"code": "for (int c = 0; c < k; c++)\n{\n  sum += pow(getDistance(oldCentroids[c], centroids[c], nCol), 2);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum) firstprivate(centroids,oldCentroids,nCol)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/7"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  omp_init_lock(&hist_locks[i]);\n  hist[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram_omp/0"}
{"code": "for (i = 0; i < h; ++i)\n{\n  (*g)[i][w - 1] = (*g)[i][1];\n  (*g)[i][0] = (*g)[i][w - 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kianenigma/pmms-heat-dissipation/assignment_2/heat_omp/compute/2"}
{"code": "for (int i = 0; i < (*tam); i++)\n{\n  vet[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/11"}
{"code": "for (j = i + 1; j < n; j++)\n{\n  if (key > (*(localList + j)))\n  {\n    index = j;\n    key = *(localList + j);\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/swapnilushinde/OpenMP_MPI_Sample_sort_algorithm/Source code/SSHINDE2/sampleSortOpenMP/0"}
{"code": "for (int i = 0; i < ((int) genePool.size()); i++)\n{\n  totalFitness += genePool.at(i).fitness;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shay9000/Genetic-Algorithm-Sudoku-Solver/src/genetic/8"}
{"code": "for (i = 1; i <= len; i++)\n{\n  if (b[i] > max)\n  {\n    max = b[i];\n    max_loc = i;\n  }\n\n  if (b[i] < min)\n  {\n    min = b[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManafMukred/Parallelization_nsertion_Sorting_OpenMP/my_sort-insertion/1"}
{"code": "for (int i = 0; i < (nr_centroids * nr_dimensions); i++)\n  centroids[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    centroid_p[objects[i].cluster].x[j] += objects[i].x[j];\n  }\n\n  count[objects[i].cluster]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MahmoudAshraf97/OpenMP-KMeans-Clustering/Q1/7"}
{"code": "for (int i = c; i <= 5; i++)\n{\n  if ((newPos->_Cases[j][i] == 2) || (newPos->_Cases[j][i] == 3))\n  {\n    newPos->_PionsPris[joueur] += newPos->_Cases[j][i];\n    newPos->_Cases[j][i] = 0;\n  }\n  else\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/9"}
{"code": "for (i = 0; i < np; i++)\n{\n  work(i);\n}\n\n", "pragma": "omp parallel for num_threads( (omp_get_max_threads ()) ) shared(np)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny15/ocl_tiny15/tiny15/0"}
{"code": "for (c2 = nk; c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/21"}
{"code": "for (int i = 0; i < n; i++)\n{\n  bin_index = compute_bin_index_from_xy(p[i].x, p[i].y);\n  bin_map.at(bin_index).push_back(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/urmilas239/Openmp/common/10"}
{"code": "for (int i = 0; i < (dim * gene); i++)\n{\n  ex_a[i] = distribution(generator);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnikChaudhuri/Variational-Bayes-with-OpenMP/VB1/0"}
{"code": "for (i = 0; i < N; ++i)\n{\n  A[i] = i * sin((i * M_PI) / N);\n  B[i] = (i / pow(N, 2)) + (pow(N, 2) / (i + 1));\n  C[i] = A[i] * B[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/efti-nile/concurrent_computing/pc_lab1_omp/src/pc_lab_1_omp/1"}
{"code": "for (int i = 0; i < list.size(); ++i)\n{\n  merge.insert(merge.end(), list[i].begin(), list[i].end());\n}\n\n", "pragma": "#pragma omp parallel for reduction(MyMerge: merge)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mangosroom/learn-openmp/custom_reduction/main/2"}
{"code": "for (int i = 0; i < dataArr.size(); i++)\n  if (dataArr[i] != decoded[i])\n  err++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MeetSable/Huffman-encoding-and-Adaptive-Huffman-encoding-OpenMP/adaptiveHuffman/6"}
{"code": "for (int j = 1; j <= n3; ++j)\n{\n  sum += w2[i][j] * theta3[j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum) ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/10"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n{\n  c = ELEM(A, an, i, j) - ELEM(B, bn, i, j);\n  if (c < 0.0)\n    c = -c;\n\n  c = c / ELEM(A, an, i, j);\n  if (c > EPSILON)\n  {\n    printf(\"Error: Wrong answer! %d, %d\\n\", i, j);\n    return 0;\n  }\n\n  if ((0 == ELEM(A, an, i, j)) && (0 == ELEM(B, bn, i, j)))\n  {\n    num_zeros++;\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/non-automated/strassen/strassen/3"}
{"code": "for (i = 0; i < (1 << 19); i++)\n{\n  key_buff1[i] += prv_buff1[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/8"}
{"code": "for (i = 0; i < 5; i++)\n  switch ('S')\n{\n  case 'S':\n    test_index_array[i] = S_test_index_array[i];\n    test_rank_array[i] = S_test_rank_array[i];\n    break;\n\n  case 'A':\n    test_index_array[i] = A_test_index_array[i];\n    test_rank_array[i] = A_test_rank_array[i];\n    break;\n\n  case 'W':\n    test_index_array[i] = W_test_index_array[i];\n    test_rank_array[i] = W_test_rank_array[i];\n    break;\n\n  case 'B':\n    test_index_array[i] = B_test_index_array[i];\n    test_rank_array[i] = B_test_rank_array[i];\n    break;\n\n  case 'C':\n    test_index_array[i] = C_test_index_array[i];\n    test_rank_array[i] = C_test_rank_array[i];\n    break;\n\n  case 'D':\n    test_index_array[i] = D_test_index_array[i];\n    test_rank_array[i] = D_test_rank_array[i];\n    break;\n\n  case 'E':\n    test_index_array[i] = E_test_index_array[i];\n    test_rank_array[i] = E_test_rank_array[i];\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Perl-OpenMP/p5-OpenMP-Environment/benchmarks/NPB3.4.1/NPB3.4-OMP/IS/is/4"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  ans[i] += myVector[i];\n  ans[i] += myVector2[i];\n  ans[i] += myVector2[i];\n  ans[i] += myVector2[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(vec_double_plus:ans)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/reduction_temp/1"}
{"code": "for (i = 0; i < vertices; i++)\n{\n  graph->adjLists[i] = 0;\n  graph->visited[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ata-Pab/Parallel_BFS_OpenMP/parallel_bfs_openmp/2"}
{"code": "for (i = 0; i < MIN(8, cs.ctlen); i++)\n  cs.ciphertext.buf[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/tacacs_plus_fmt_plug/1"}
{"code": "for (uint32_t i = 0; i < vLPNumIter.size(); ++i)\n{\n  mplPrint(kNONE, \"%u %u %u %u %u %u %u\\n\", vLP1NonInteger.at(i), vLP1HalfInteger.at(i), vLP2NonInteger.at(i), vLP2HalfInteger.at(i), vLPEndNonInteger.at(i), vLPEndHalfInteger.at(i), vLPNumIter.at(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/5"}
{"code": "for (unsigned long long tid = start; tid < end; tid++)\n{\n  if (h_updating_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = true;\n    h_graph_visited[tid] = true;\n    *stop = true;\n    h_updating_graph_mask[tid] = false;\n  }\n\n}\n\n", "pragma": "          #pragma omp target teams distribute parallel for device(d) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/bfs/bfs_mulgpu/2"}
{"code": "for (int i = 0; i < lhs.Size(); ++i)\n{\n  res += lhs[i] * rhs[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/8"}
{"code": "for (i = 0; i < size_0; i++)\n{\n  str_1[i] = (char *) malloc((sizeof(char)) * 15);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Shyeok/Distributed-Programming/OpenMP/p/0"}
{"code": "for (unsigned int i = 0; i < _m; i++)\n{\n  sum += _adjacentMatrixBool[i][hyperEdge->getIdentifier()];\n}\n\n", "pragma": "#pragma omp for schedule( dynamic )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex-87/HyperGraphLib/src/model/AdjacentMatrix/3"}
{"code": "for (int i = 0; i < rank; i++)\n{\n  int irank = i * rank;\n  for (j = 0; j <= i; j++)\n  {\n    small_r[j + irank] = r[j + (indices[i] * m)];\n  }\n\n  for (j = i + 1; j < rank; j++)\n  {\n    small_r[j + irank] = 0.0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/37"}
{"code": "for (x = 0; x < size_x; ++x)\n{\n  for (y = 0; y < size_y; ++y)\n  {\n    if ((((x > 0) && (x < nx)) && (y > 0)) && (y < ny))\n    {\n      sum = 0;\n      sum -= grid_current[((x - 1) * size_y) + y] / (hx * hx);\n      sum -= grid_current[((x + 1) * size_y) + y] / (hx * hx);\n      sum -= grid_current[(x * size_y) + (y - 1)] / (hy * hy);\n      sum -= grid_current[(x * size_y) + (y + 1)] / (hy * hy);\n      sum += grid_current[(x * size_y) + y] * (((2 / (hx * hx)) + (2 / (hy * hy))) + (((2 * M_PI) * 2) * M_PI));\n      residue += pow(((((4 * M_PI) * M_PI) * sin(((2 * M_PI) * x) * hx)) * sinh(((2 * M_PI) * y) * hy)) - sum, 2);\n    }\n\n    fprintf(solution, \"%lf %lf %lf\\n\", x * hx, y * hy, grid_current[(x * size_y) + y]);\n  }\n\n  fprintf(solution, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bazk/rbgs/rbgs/5"}
{"code": "for (i = 0; i < NRA; i++)\n  for (j = 0; j < NCA; j++)\n  a[(i * NRA) + j] = i + j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TELESIO/OpenMP4.5/example/MatrixMultiplication/gpu/mm/0"}
{"code": "for (int i = 0; i < _rows; i++)\n{\n  double temp = 0;\n  for (int j = 0; j < _cols; j++)\n  {\n    temp += this->mat[i][j] * obj[j];\n  }\n\n  res[i] = temp;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/Matrix_omp/22"}
{"code": "for (int i = 0; i < SIZE; i++)\n  data[i] = rand() % (SIZE * 10);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/radixSort/sort_radix/4"}
{"code": "for (int i = 0; i < no_of_elements; i = i + j)\n{\n  if (((i / j) % 2) == 0)\n    bitonic_merge(i, (i + j) - 1, 1);\n  else\n    bitonic_merge(i, (i + j) - 1, 0);\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Bitonic_sort_OpenMP/1"}
{"code": "for (i = 0; i < 2000; i++)\n  for (j = 0; j < 2000; j++)\n{\n  a[i][j] = 1 + ((int) ((70.0 * rand()) / (32767 + 1.0)));\n  b[i][j] = (double) (rand() % 5);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamodi08jaya/Parallel-Computing/openMPmm/1"}
{"code": "for (int ii = 0; ii < (HEIGHT * WIDTH); ++ii)\n{\n  int i = ii / WIDTH;\n  int j = ii % WIDTH;\n  double stepJ = abs(curWE - curWS) / (WIDTH - 1);\n  double stepI = abs(curHE - curHS) / (HEIGHT - 1);\n  int ZVal = computeZ(IPoint(0, 0), IPoint(curWS + (j * stepJ), curHE - (i * stepI)));\n  paintP[i][j] = (ZVal < DEPTH) ? (ZVal) : (0);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TarekVito/FractalMandelbrotSet/Fractal/Source/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i + 1;\n  for (j = 0; j < n; j++)\n  {\n    b[i][j] = a[i];\n    printf(\"b[%d][%d] = %d, threads: %d\\n\", i, j, b[i][j], omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/012_nested_parallelism/0"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  a[j] = 2.0E0 * a[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-4/stream-gpu/stream/3"}
{"code": "for (unsigned int j = 0; j < constant_size; ++j)\n{\n  assert(send_offset[j] == elts_per_dest[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/31"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (fabs(output[i] - expected_output[i]) > error_rate)\n  {\n    error_rate = fabs(output[i] - expected_output[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/geodesic-omp/main/1"}
{"code": "for (unsigned c = 0; c < OutCount; c++)\n{\n  (((scsv << OutBuff[c].timestep) << OutBuff[c].vel) << OutBuff[c].point) << Endl();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JDsGaugeItem/0"}
{"code": "for (c1 = (((ni > nk) ? (ni) : (nk)) > nm) ? ((ni > nk) ? (ni) : (nk)) : (nm); c1 <= (nj + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/26"}
{"code": "for (int a = 0; a < sizeA; a++)\n{\n  for (int b = 0; b < sizeB; b++)\n  {\n    if (matA[a].j == matB[b].i)\n    {\n      updateEntry(partial, &partialSize, matA[a].i, matB[b].j, matA[a].value * matB[b].value);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mvhv/mpi-openmp-matrix/mmMPI/0"}
{"code": "for (int real = world_rank; real < num; real += comm_size)\n{\n  for (int img = 0; img < num; img++)\n  {\n    count += inset(real_lower + (real * real_step), img_lower + (img * img_step), maxiter);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:count) collapse(2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongfeiyang/parallel-mandelbrot-set/mandelbrot/0"}
{"code": "for (i = 0; i < heigth; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    aux[i][j].white_black = buffer[(i * width) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SebastianCojocariu/Kernels-Parallelization-Techniques-Serial-MPI-OpenMP-Pthreads-Hybrid-/APP/hibrid/mpi_openmp(hibrid)/homework/4"}
{"code": "for (int k = 0; k < MAX_MATRIX_LENGTH; k++)\n{\n  for (i_iter = 0; i_iter < matrixRows; i_iter++)\n  {\n    for (j_iter = 0; j_iter < MAX_MATRIX_LENGTH; j_iter++)\n      matrix_final[i_iter][k] += matrix_0[i_iter][j_iter] * matrix_1[j_iter][k];\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kiippu/MSMPI-and-OpenMP/M3.T1P/Source/4"}
{"code": "for (int i = 0; i < edges.size(); i++)\n  free(edges[i].move);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlSaeed/15618-Final-Project/heuristic_minimax_player/1"}
{"code": "for (j = 0; j < a; j += 32)\n{\n  int l;\n  for (l = 0; l < b; ++l)\n    c += d[j + l];\n\n}\n\n", "pragma": "omp parallel for reduction(+: c)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr58756/0"}
{"code": "for (i = 0; tests[i].ciphertext; i++)\n{\n  struct argon2_salt *salt;\n  salt = get_salt(tests[i].ciphertext);\n  m_cost = MAX(m_cost, salt->m_cost);\n  if (i == 0)\n  {\n    printf(\"\\n\");\n    prev_m_cost = m_cost;\n    print_memory((sizeof(block)) * m_cost);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/3"}
{"code": "for (it = 1; it <= nit; it++)\n{\n  mg3P(u, v, r, a, c, n1, n2, n3, lt);\n  resid(u[lt], v, r[lt], n1, n2, n3, a, lt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/16"}
{"code": "for (i = 0; i < nvars; i++)\n{\n  keep = 1;\n  if (fabs(newx[i] - xbefore[i]) > (0.5 * fabs(delta[i])))\n    break;\n  else\n    keep = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iloudaros/Paralllelll/Code/1.OpenMP/multistart_hooke_omp/7"}
{"code": "for (arrx = 0; arrx < size; arrx++)\n{\n  if (arr[arrx] > max)\n  {\n    maxx = arrx;\n    max = arr[maxx];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mithradatha/parallel-pagerank/dense_omp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  j = i * incx;\n  sx[j] *= sa;\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD2_OMP/MolDyn/correction/solQ4/dscal/1"}
{"code": "for (int row = 0; row < 8; row++)\n{\n  VALID_ROWS[col][row] = isvalid(row, col);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens2/Queens2.1/1"}
{"code": "for (i = 1; i <= nodesCount; ++i)\n{\n  if (distance[i][k])\n    for (j = 1; j <= nodesCount; ++j)\n  {\n    if (((distance[i][k] != NOT_CONNECTED) && (distance[k][j] != NOT_CONNECTED)) && ((distance[i][j] == NOT_CONNECTED) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n    {\n      distance[i][j] = distance[i][k] + distance[k][j];\n    }\n\n  }\n\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic) private(i, j) num_threads(numthreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harisrkhan7/FloydWarshallAlgorithmParallelisation/fw_in/0"}
{"code": "for (i = 0; i < n2; i++)\n{\n  k = index2[i];\n  for (j = 0; j < nrows; j++)\n  {\n    if (mask[j][k] != 0)\n    {\n      cdata[j][1] = cdata[j][1] + data[j][k];\n      count[j][1] = count[j][1] + 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/120"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  rvv = vvContacts(ci);\n  rcc = ccContacts(ci);\n  if ((rcc <= NDIM) && (rvv <= 3))\n  {\n    nr++;\n    if (rvv > 0)\n    {\n      nm++;\n      for (cj = 0; cj < NCELLS; cj++)\n      {\n        if (ci != cj)\n          setContact(ci, cj, 0);\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/41"}
{"code": "for (b = 0; b < (rtot - 1); b++)\n{\n  if ((m[b] < ntot) && (n < ntot))\n  {\n    MNS[b][(int) m[b]] = NS[b][n];\n    MNSH[b][(int) m[b]] = NSH[b][n];\n    MNSL[b][(int) m[b]] = NSL[b][n];\n    MNSET[b][(int) m[b]] = NSET[b][n];\n    MRVE[b][(int) m[b]] = RVE[b][n];\n    MRVEET[b][(int) m[b]] = RVEET[b][n];\n    MRMAEH[b][(int) m[b]] = RMAEH[b][n];\n    MRMAEL[b][(int) m[b]] = RMAEL[b][n];\n    MREVE[b][(int) m[b]] = REVE[b][n];\n    Mdqd[(int) m[b]] = dqd[n];\n    mtot[b] = m[b];\n    m[b] = m[b] + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/HBV/hbv_performance/3"}
{"code": "for (j = 1; j < (pcinfo.y_cells_num - 1); j++)\n{\n  int index_i = pcinfo.x_cell_pos + i;\n  int index_j = pcinfo.y_cell_pos + j;\n  df[(j * pcinfo.x_cells_num) + i] = ((((f[(j * pcinfo.x_cells_num) + i] - recv_message_lr[j]) / hx_(index_i - 1)) - ((f[((j * pcinfo.x_cells_num) + i) + 1] - f[(j * pcinfo.x_cells_num) + i]) / hx_(index_i))) / hhx_(index_i)) + ((((f[(j * pcinfo.x_cells_num) + i] - f[((j - 1) * pcinfo.x_cells_num) + i]) / hy_(index_j - 1)) - ((f[((j + 1) * pcinfo.x_cells_num) + i] - f[(j * pcinfo.x_cells_num) + i]) / hy_(index_j))) / hhy_(index_j));\n}\n\n", "pragma": "                #pragma omp for schedule (static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/6"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    float v = infinity();\n    for (int k = 0; k < n; ++k)\n    {\n      float x = d[(n * i) + k];\n      float y = d[(n * k) + j];\n      float z = x + y;\n      v = min(v, z);\n    }\n\n    r[(n * i) + j] = v;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/parallel-rust-cpp/shortcut-comparison/src/cpp/v0_baseline/step/0"}
{"code": "for (r = 0; r < rows; r++)\n{\n  for (c = 0; c < cols; c++)\n  {\n    dot = 0.0;\n    sum = 0.0;\n    for (cc = -center; cc <= center; cc++)\n    {\n      if (((c + cc) >= 0) && ((c + cc) < cols))\n      {\n        dot += kernel[center + cc] * image[(r * cols) + (c + cc)];\n        sum += kernel[center + cc];\n      }\n\n    }\n\n    tempim[(r * cols) + c] = dot / sum;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(image, tempim) private(r,c,cc,dot,sum) num_threads(threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aguilarmauri/ProgramacionParalela/src/canny-openmp/2"}
{"code": "for (int i = lp; i < rp; i++)\n{\n  float s1[q];\n  int s2[q];\n  fix_stage(n, i, q, t, s1, s2, dp1, Y, A, B);\n  local_converged = (is_parallel(t, q, i, s1, dp1)) ? (1) : (0);\n  if (!local_converged)\n  {\n    copy_new_to_old(t, q, i, s1, s2, dp1, dp2);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_hybrid/1"}
{"code": "for (int k = 1; k < matrices.size(); k++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n    {\n      if (matrices[k][(i * n) + j] != matrices[0][(i * n) + j])\n      {\n        return false;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/popandopulogeo/RibbonMatrixMultiplication/OpenMP/OpenMP/2"}
{"code": "for (j = 1; j < number_of_buckets; j++)\n{\n  global_boucket_start[j] = global_boucket_start[j - 1] + global_boucket_count[j - 1];\n  buckets[j].startpos = buckets[j - 1].startpos + global_boucket_count[j - 1];\n  buckets[j].index = buckets[j - 1].index + global_boucket_count[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training6/b0521229-train6/5"}
{"code": "for (int row = 0; row < Nx; ++row)\n{\n  for (int col = 0; col < Ny; ++col)\n  {\n    if (row < row_bound)\n    {\n      U[(row * Ny) + col] = 1.0;\n    }\n\n    if (col < col_bound)\n    {\n      V[(row * Ny) + col] = a / 2.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raihaan123/HPC/CPP/archived/ReactionDiffusion/1"}
{"code": "for (int i = 1; i <= m_nSubbasins; i++)\n{\n  m_surfqToCh[0] += m_surfqToCh[i];\n  m_sedToCh[0] += m_sedToCh[i];\n  m_surNO3ToCh[0] += m_surNO3ToCh[i];\n  m_surNH4ToCh[0] += m_surNH4ToCh[i];\n  m_surSolPToCh[0] += m_surSolPToCh[i];\n  m_surCodToCh[0] += m_surCodToCh[i];\n  m_sedOrgNToCh[0] += m_sedOrgNToCh[i];\n  m_sedOrgPToCh[0] += m_sedOrgPToCh[i];\n  m_sedMinPAToCh[0] += m_sedMinPAToCh[i];\n  m_sedMinPSToCh[0] += m_sedMinPSToCh[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IMP_SWAT/pothole_SWAT/5"}
{"code": "for (int n = 0; n < N; n++)\n{\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < N; j++)\n    {\n      C[i][j] += A[i][n] * B[n][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elyaishere/sk_high_performance_computing/openmp/MatMul/2"}
{"code": "for (unsigned int i = 0; i < ((sizeof(__m128i)) / (sizeof(T))); i++)\n{\n  (sstr << values[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-neumann/versalignLib/src/Kernels/AVX-SSE/SSEKernel/1"}
{"code": "for (i = 0; i < num_elements; i++)\n  hist_temp[current_thread][input_data[i]]++;\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-Histogram/histogram/0"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  r[i] = find_min(A + (i * H), A + ((i + 1) * H), B, K, f);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/4_openmp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < (n - 1); j++)\n    fprintf(heatmap, \"%lf,\", u[(i * n) + j]);\n\n  fprintf(heatmap, \"%lf\\n\", u[((i * n) + n) - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emmanuellujan/2d-diff-eq-julia-vs-c-openmp/diffusion-parallel/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  int expected = ((((-1) + ((((-3) + i) + 2) * i)) + ((2 * i) * (i + 5))) + 10) + (2 * i);\n  if (a[i] != expected)\n  {\n    printf(\"Error at %d: device = %d, host = %d\\n\", i, a[i], expected);\n    fail = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/5"}
{"code": "for (i = bestOffs - SCANWIND; i < end; i++)\n{\n  if (i == bestOffs)\n    continue;\n\n  corr = (float) calcCrossCorr(refPos + (channels * i), pMidBuffer, norm);\n  float tmp = ((float) (((2 * i) - seekLength) - 1)) / ((float) seekLength);\n  corr = (corr + 0.1f) * (1.0f - ((0.25f * tmp) * tmp));\n  if (corr > bestCorr)\n  {\n    bestCorr = corr;\n    bestOffs = i;\n    best = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/branches/OpenMPT-1.25/include/soundtouch/source/SoundTouch/TDStretch/0"}
{"code": "for (i = n; i >= 1; i--)\n{\n  l = i + 1;\n  g = w[i];\n  if (i < n)\n    for (j = l; j <= n; j++)\n    a[i][j] = 0.0;\n\n\n  if (g)\n  {\n    g = 1.0 / g;\n    if (i != n)\n    {\n      for (j = l; j <= n; j++)\n      {\n        for (s = 0.0, k = l; k <= m; k++)\n          s += a[k][i] * a[k][j];\n\n        f = (s / a[i][i]) * g;\n        for (k = i; k <= m; k++)\n          a[k][j] += f * a[k][i];\n\n      }\n\n    }\n\n    for (j = i; j <= m; j++)\n      a[j][i] *= g;\n\n  }\n  else\n  {\n    for (j = i; j <= m; j++)\n      a[j][i] = 0.0;\n\n  }\n\n  ++a[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reedv/Tircis/tircis_process_cmd_v4/svdcmp_d/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  test[i] = 0;\n  count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/TransposeSPMX/0"}
{"code": "for (int u = 0; u < n; u++)\n{\n  for (int v = u; v < n; v++)\n  {\n    if (adj_matrix[u][v] == 1)\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_multithread/2"}
{"code": "for (i = 0; i < rec_count; i++)\n{\n  float max_dist = -1;\n  int max_idx = 0;\n  for (j = 0; j < k; j++)\n  {\n    if (neighbors[j].dist > max_dist)\n    {\n      max_dist = neighbors[j].dist;\n      max_idx = j;\n    }\n\n  }\n\n  if (z[i] < neighbors[max_idx].dist)\n  {\n    sandbox[((i + 1) * 49) - 1] = '\\0';\n    strcpy(neighbors[max_idx].entry, sandbox + (i * 49));\n    neighbors[max_idx].dist = z[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nn/nn_hsa/3"}
{"code": "for (int i = 0; i < inputs.size(); i++)\n{\n  err += g.error(inputs.at(i), exp_outputs.at(i));\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xbassi/dl-space/main/1"}
{"code": "for (idx_t m = 0; m < tt->nmodes; ++m)\n{\n  maxdim = (tt->dims[m] > maxdim) ? (tt->dims[m]) : (maxdim);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/7"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpms5m8919.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (int i = 0; i < lines; i++)\n{\n  for (int j = 0; j < columns; j++)\n    cout << image[(i * columns) + j];\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pterolex/MandelbrotConsole/mandelbrot_openmp/1"}
{"code": "for (i = 0; i < area; i++)\n{\n  data[i] = data[i] + key;\n  checksum += data[i];\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:checksum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oliviercotte/Parallel-system/inf8601-lab2-2.1.2/encode/algo/0"}
{"code": "for (i = 0; i < controlLength; i++)\n{\n  if (patternLength[controlData[2][i]] > textLength[controlData[1][i]])\n  {\n    writeToResultString(controlData[1][i], controlData[2][i], -1);\n  }\n  else\n  {\n    if (textLength[controlData[1][i]] == patternLength[controlData[2][i]])\n      worstcaseComparisons = (long long) textLength[controlData[1][i]];\n    else\n      if (textLength[controlData[1][i]] < patternLength[controlData[2][i]])\n      worstcaseComparisons = 0ULL;\n    else\n      worstcaseComparisons = ((long long) patternLength[controlData[2][i]]) * (((long long) textLength[controlData[1][i]]) - ((long long) patternLength[controlData[2][i]]));\n\n\n    if (worstcaseComparisons > 100000000ULL)\n    {\n      NUMTHREADS = 20;\n    }\n    else\n      if (worstcaseComparisons <= 1000ULL)\n    {\n      NUMTHREADS = 1;\n    }\n    else\n      if (worstcaseComparisons <= 10000ULL)\n    {\n      NUMTHREADS = 3;\n    }\n    else\n      if (worstcaseComparisons <= 100000000ULL)\n    {\n      NUMTHREADS = 18;\n    }\n    else\n    {\n      NUMTHREADS = 20;\n    }\n\n\n\n\n    processData(controlData[0][i], controlData[1][i], controlData[2][i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/paullewisjohnston/hpc-pattern-searching/project_OMP/3"}
{"code": "for (i = 0; i < STREAM_ARRAY_SIZE; i++)\n{\n  a[i] = 1.0;\n  b[i] = 2.0;\n  c[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/23"}
{"code": "for (x = 0; x < 64; x++)\n{\n  for (y = 0; y < 16; y++)\n  {\n    ;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/clauses-4/5"}
{"code": "for (int i = 0; i < table_size; i++)\n  table[i] = i;\n\n", "pragma": "    #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jolatechno/HPC-examples/mpi_rma_cuda_uma/1"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  vijk = vs[i][j][k];\n  vp1 = vs[i][j + 1][k];\n  vm1 = vs[i][j - 1][k];\n  rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n  rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n  rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n  rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n  rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n}\n\n", "pragma": "omp parallel for private (vijk,vp1,vm1,k) firstprivate (ty2,yycon2,yycon3,yycon4,yycon5,dy1ty1,dy2ty1,dy3ty1,dy4ty1,dy5ty1,c1,c2,con43)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/115"}
{"code": "for (local_est = A[id].edge_head; local_est != 0; local_est = local_est->next)\n{\n  if (local_est->id == rec_msg->id)\n  {\n    if (rec_msg->est < local_est->est)\n    {\n      local_est->est = rec_msg->est;\n      int t = computeIndex(A, id, A[id].kcore);\n      if (t < A[id].kcore)\n      {\n        ret = 1;\n        A[id].kcore = t;\n        A[id].active = 1;\n        printf(\"%d is setting core to %d\\n\", id, t);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tjj5036/kcore-openmp/parallel_kcore/10"}
{"code": "for (int j = 2; j <= check; j++)\n{\n  if ((i % j) == 0)\n  {\n    isPrimeNumberFound = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/banjarashalin/FluidSimulationSolver/SloverCode/src/SpatialHashing/0"}
{"code": "for (int i = 0; i < 16; ++i)\n{\n  for (int n = 1; n < (1 << 13); n <<= 1)\n  {\n    int *p = (int *) omp_target_alloc(n * (sizeof(int)), 0);\n    for (int j = 0; j < n; ++j)\n    {\n      p[j] = i;\n    }\n\n    int buffer[n];\n    for (int j = 0; j < n; ++j)\n    {\n      buffer[j] = p[j];\n    }\n\n    for (int j = 0; j < n; ++j)\n    {\n      assert(buffer[j] == i);\n    }\n\n    omp_target_free(p, 0);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/offloading/memory_manager/1"}
{"code": "for (;;)\n{\n  if ((local_cnt + length) <= 64)\n  {\n    memcpy(&cp[local_cnt], password, length);\n    local_cnt += length;\n    if (local_cnt == 64)\n    {\n      bufs_used++;\n      break;\n    }\n\n  }\n  else\n  {\n    int spill = (local_cnt + length) - 64;\n    memcpy(&cp[local_cnt], password, length - spill);\n    cp = buf[++bufs_used];\n    memcpy(cp, &password[length - spill], spill);\n    local_cnt = spill;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vtp_fmt_plug/3"}
{"code": "for (j = 0; j <= 19; j += 1)\n{\n  a[i][j] += a[i + 1][j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/datarace/inner_only_1.no/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    sum += a[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/advaitjavadekar/OpenMP/q1/2"}
{"code": "for (i = 0; i < buckets_count; i++)\n{\n  buckets[i] = malloc((sizeof(double)) * N);\n  bucket_sizes[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrycz/c-parallel-programming/openmp/openmp_bucket_sort/2"}
{"code": "for (jy = HALO_Y; jy < (DIM_Y - HALO_Y); jy++)\n{\n  #pragma acc loop independent\n  for (jx = HALO_X; jx < (DIM_X - HALO_X); jx++)\n  {\n    fn[ADDR_FROM_XYZ(jx, jy, 0)] = fn[ADDR_FROM_XYZ(jx, jy, 1)];\n    fn[ADDR_FROM_XYZ(jx, jy, DIM_Z - 1)] = fn[ADDR_FROM_XYZ(jx, jy, DIM_Z - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muellermichel/Hybrid-Fortran/examples/diffusion3d/source/diffusion3d/3"}
{"code": "for (int l = 0; l < CVT_INT(m_nSoilLyrs[i]); l++)\n{\n  root_fr[l] /= cum_rf;\n  if (l == k)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/management/PLTMGT_SWAT/managementOperation_SWAT/8"}
{"code": "for (i = 0; i < 2000; i++)\n  if (B[i] != nthreads)\n  res2 = 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/target-critical-1/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  C[i] = A[i] * B[i];\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(cntThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Onyaxoxo/OpenMP-FEFU-/4/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < n; k++)\n    {\n      if (a[(i * n) + k] != 0)\n        c[(i * n) + j] += a[(i * n) + k] * b[(k * n) + j];\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/teaching-openmp/src/mm/main/2"}
{"code": "for (size_t I = CurrentSize; I < NewSize; ++I)\n{\n  checkResult(cuStreamCreate(&Pool[I], CU_STREAM_NON_BLOCKING), \"Error returned from cuStreamCreate\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/openmp/libomptarget/plugins/cuda/src/rtl/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    matvec_sub(lhs[i][j][k][AA], rhs[i][j - 1][k], rhs[i][j][k]);\n    matmul_sub(lhs[i][j][k][AA], lhs[i][j - 1][k][CC], lhs[i][j][k][BB]);\n    binvcrhs(lhs[i][j][k][BB], lhs[i][j][k][CC], rhs[i][j][k]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/45"}
{"code": "for (i = 0; i < n; i++)\n  bar(0);\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr29955/0"}
{"code": "for (i = 1; i < n; i += 2)\n{\n  if (a1[i - 1] > a1[i])\n  {\n    temp = a1[i - 1];\n    a1[i - 1] = a1[i];\n    a1[i] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) default(none) shared(a1, n) private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/14"}
{"code": "for (int i = 0; i < k; i++)\n{\n  char buffer[seq_length[i] + 1];\n  MPI_Bcast(buffer, seq_length[i], MPI_CHAR, root, comm);\n  buffer[seq_length[i]] = '\\0';\n  genes[i] = string(buffer, seq_length[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing11/p1/3"}
{"code": "for (i = 0; i < 1048; i++)\n  for (j = 0; j < 1048; j++)\n  a[i][j] = (tid + i) + j;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jpmcd/HPC15-hw3/omp_solved4/0"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = pow(this->vec_[i], (static_cast < ValueType) > power);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/45"}
{"code": "for (int jj = 1; jj < (_chunk.y - 1); ++jj)\n{\n  for (int kk = 1; kk < (_chunk.x - 1); ++kk)\n  {\n    const int index = (jj * _chunk.x) + kk;\n    double temp = energy[index] * density[index];\n    u0[index] = temp;\n    u[index] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_jacobi_kernel/0"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  a[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/array product & sum/1"}
{"code": "for (size_t i = 0; i < Nqd; i++)\n{\n  for (size_t j = 0; j < Nelt; j++)\n  {\n    P1t(i, j) = ((0.5 * (1 - quadf(i, 0))) * g.coordinates(g.elements(j, 0), 0)) + ((0.5 * (1 + quadf(i, 0))) * g.coordinates(g.elements(j, 1), 0));\n    P2t(i, j) = ((0.5 * (1 - quadf(i, 0))) * g.coordinates(g.elements(j, 0), 1)) + ((0.5 * (1 + quadf(i, 0))) * g.coordinates(g.elements(j, 1), 1));\n    P1tau(i, j) = ((0.5 * (1 - quadf(i, 1))) * g.coordinates(g.elements(j, 0), 0)) + ((0.5 * (1 + quadf(i, 1))) * g.coordinates(g.elements(j, 1), 0));\n    P2tau(i, j) = ((0.5 * (1 - quadf(i, 1))) * g.coordinates(g.elements(j, 0), 1)) + ((0.5 * (1 + quadf(i, 1))) * g.coordinates(g.elements(j, 1), 1));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/0"}
{"code": "for (int32_t i = 0; i < 10; i++)\n{\n  assert(sum[i].x == 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_10/2"}
{"code": "for (int i = nel; i < nelr; i++)\n{\n  h_areas[i] = h_areas[last];\n  for (int j = 0; j < NNB; j++)\n  {\n    h_elements_surrounding_elements[i + (j * nelr)] = h_elements_surrounding_elements[last + (j * nelr)];\n    for (int k = 0; k < NDIM; k++)\n      h_normals[last + ((j + (k * NNB)) * nelr)] = h_normals[last + ((j + (k * NNB)) * nelr)];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/cfd-omp/euler3d/7"}
{"code": "for (int j = pow(2, l) - 1; j < upper_bound; j++)\n{\n  if ((j % 2) != 0)\n  {\n    *(B + j) = (*(B + ((j - 1) / 2))) + (*((A + j) + 1));\n  }\n  else\n  {\n    *(B + j) = *(B + ((j - 2) / 2));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Natsukooh/parallel_programming_project_radix_sort/radixsort/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  printf(\"%d \", res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/omp-exercises/iterative_scan/4"}
{"code": "for (int i = 0; i < NumOptimizables; i++)\n  (((((d_out << (i + 1)) << \" \") << m_vec(0, i)) << \"  \") << m_vec(1, i)) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/VMC/VMCLinearOptOMP/1"}
{"code": "for (int i = 0; i < Dim; i++)\n{\n  Res[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/96"}
{"code": "for (k = n - 1; k >= 0; k--)\n{\n  x[k] = y[k];\n  for (int i = 0; i < k; i++)\n    y[i] = y[i] - (a[i][k] * x[k]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PAAnisimofff/SLAU_OpenMP/SLAU_OpenMP/SLAU_OpenMP/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name print#0#0\n  for (j = 0; j < 100; j++)\n  {\n    printf(\"%lf %lf %lf\\n\", c[i][j], a[i][j], b[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB060-matrixmultiply-orig-no/5"}
{"code": "for (i = 1; i <= (N - 2); i++)\n{\n  double local_eps = eps;\n  for (j = 1; j <= (N - 2); j++)\n  {\n    double e;\n    e = fabs(A[i][j] - B[i][j]);\n    A[i][j] = B[i][j];\n    local_eps = (eps > e) ? (eps) : (e);\n  }\n\n  eps = (eps > local_eps) ? (eps) : (local_eps);\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dzhidzhoev/skpod-openmp/jacobi_2d/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      b[i] = rand() % (n + 1);\n      A[i][j] = 1;\n    }\n    else\n    {\n      A[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/10"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    if (root.goal[i][j] != root.pz[i][j])\n    {\n      flag = 1;\n      break;\n    }\n\n  }\n\n  if (flag == 1)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShekharShiroor/8-Puzzle-problem-using-CPP-and-OpenMP/8-puzzle/2"}
{"code": "for (i = ibeg; i <= ifin1; i++)\n{\n  for (j = jbeg; j <= jfin1; j++)\n  {\n    frc1 = frc1 + (((((((phi1[i][j] + phi1[i + 1][j]) + phi1[i][j + 1]) + phi1[i + 1][j + 1]) + phi2[i][j]) + phi2[i + 1][j]) + phi2[i][j + 1]) + phi2[i + 1][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin1 ,j ,jbeg ,jfin1 ,i ) reduction(+:frc1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/53"}
{"code": "for (y = 2; y < (maxYCount - 2); y++)\n{\n  fY = yBottom + ((y - 1) * deltaY);\n  updateVal = (((((west_v[y - 1] + u_old[(y * maxXCount) + 2]) * cx) + ((u_old[((y - 1) * maxXCount) + 1] + u_old[((y + 1) * maxXCount) + 1]) * cy)) + (u_old[(y * maxXCount) + 1] * cc)) - (((((-alpha) * (1.0 - (fX * fX))) * (1.0 - (fY * fY))) - (2.0 * (1.0 - (fX * fX)))) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  cur_error += updateVal * updateVal;\n  u[(y * maxXCount) + 1] = u_old[(y * maxXCount) + 1] - (relax * updateVal);\n}\n\n", "pragma": "omp for reduction(+: cur_error) schedule(static,1000)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksakkas/Parallel-Systems-Project/HybridMPI/hybrid/3"}
{"code": "for (src = 0; src < 800; src++)\n{\n  for (dst = 0; dst < 800; dst++)\n  {\n    if (src != dst)\n    {\n      distance_matrix[src][dst] = rand() % 20;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuvrajdalia/openmp_project/floydp/1"}
{"code": "for (i = 1; i < sp->len; i++)\n  re = re->next;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/2"}
{"code": "for (int k = 0; k < n; k++)\n{\n  R[k] = (double *) malloc(n * (sizeof(double)));\n  D[k] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/2"}
{"code": "for (p = 0; p < 500; p++)\n{\n  unsigned long int _imopVarPre155;\n  void *_imopVarPre156;\n  _imopVarPre155 = 500 * (sizeof(double));\n  _imopVarPre156 = malloc(_imopVarPre155);\n  u[p] = (double *) _imopVarPre156;\n  unsigned long int _imopVarPre159;\n  void *_imopVarPre160;\n  _imopVarPre159 = 500 * (sizeof(double));\n  _imopVarPre160 = malloc(_imopVarPre159);\n  w[p] = (double *) _imopVarPre160;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/src/imop/lib/testcases/mhpTests/silo-check/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n      rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n      rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n      rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n      rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/32"}
{"code": "for (int i = 0; i < num_row; i++)\n{\n  for (int j = 0; j < num_col; j++)\n  {\n    {\n      if ((i == row[common_index]) && (j == col[common_index]))\n      {\n        fprintf(fptr, \"%d. \", val[common_index] * ((int) input_scalar));\n        if (!required_logging)\n          printf(\"%d. \", val[common_index] * ((int) input_scalar));\n\n        common_index++;\n      }\n      else\n      {\n        fprintf(fptr, \"%d. \", 0);\n        if (!required_logging)\n          printf(\"%d. \", 0);\n\n      }\n\n    }\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VumGualnam/2019S2_C_I_T_S_3_4_0_2__HPC_Project1/scalarMul/0"}
{"code": "for (int i = 0; i < count; i++)\n{\n  parr[i] = p;\n  p = p->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dragonfly9113/introduction_to_OpenMP/OpenMPApplication/OpenMPApplication/Linked/1"}
{"code": "for (int i = 0; i < ((4 * L) * L); i++)\n{\n  E_afm_an += sum_array_1[i];\n  E_afm_ex += sum_array_2[i];\n  E_afm_dm += sum_array_3[i];\n}\n\n", "pragma": "              #pragma omp parallel for shared(sum_array_1,sum_array_2,sum_array_3)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/facuMH/HeisenbergModel/OpenMP/main/8"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 2 * (ie / 2); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      DyDyu[pp] = (((((-u[pp - (2 * nx)]) + (16.0 * u[pp - nx])) - (30.0 * u[pp])) + (16.0 * u[pp + nx])) - u[pp + (2 * nx)]) * idy_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/9"}
{"code": "for (int i = 0; i < blocksize; i++)\n{\n  for (int j = 0; j < blocksize; j++)\n  {\n    L[i + row_start][j + column_start] = 0;\n    for (int k = 0; k <= j; k++)\n    {\n      L[i + row_start][j + column_start] += A[i + row_start][k + column_start] * U[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q3/11"}
{"code": "for (i = 0; i < 12; i++)\n  u[i] = v1[i] * v2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/21"}
{"code": "for (i1 = 1; i1 < I; i1++)\n{\n  for (i2 = 0; i2 < i1; i2++)\n  {\n    k = (((K - (((I - i2) * ((I - i2) - 1)) / 2)) + i1) - i2) - 1;\n    ptres[k] = 0;\n    for (j = 0; j < J; j++)\n    {\n      ptres[k] += abs(ptx[i1 + (I * j)] - ptx[i2 + (I * j)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(ptx, ptres) private(i1, i2, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Atrebas/pmdr/src/distance/0"}
{"code": "for (v = 0; v < degree; v++)\n{\n  uint32_t t = nodes->edges_array_dest[v];\n  stats->parents[t] = arguments->source;\n  bitmapNext->numSetBits++;\n  setBit(bitmapNext, t);\n  activeVertices++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/19"}
{"code": "for (i = 0; i < size; i++)\n{\n  A[i] = (int *) calloc(sizeof(int), size);\n  B[i] = (int *) calloc(sizeof(int), size);\n  C[i] = (int *) calloc(sizeof(int), size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pupking/OpenMP-codes/matrix/1"}
{"code": "for (int i = 0; i < k; i++)\n{\n  storia.centroids[i] = (float *) calloc(training.atts, sizeof(float));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/6"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  x <<= 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_atomic/9"}
{"code": "for (int i = 0; i < n; i++)\n  if (node_type[offset[i]] == marker)\n  offset[count++] = offset[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  local_sum[id].sum += x[i];\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raaavioli/OpenMP-Assignments-DD2356/Exercise-3/sum/4"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  sum += 4.0 / (1.0 + (((i + 0.5) * step) * ((i + 0.5) * step)));\n}\n\n", "pragma": "omp parallel for schedule(static, 4) reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcinbogiel/OpenMP_examples/My solutions/exercise_4/0"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  int curNode = DijkstraSelectNode(nodeNum, visited, disFromStart);\n  DijkstraUpdate(nodeNum, visited, edges, curNode, disFromStart, prevNode);\n  visited[curNode] = NODE_VISITED;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/3"}
{"code": "for (int x = 1; x < (pcolumns - 1); x++)\n{\n  fX = yStart + ((x - 1) * deltaX);\n  updateVal = (((((u_old[((prows - 2) * pcolumns) + (x - 1)] + u_old[((prows - 2) * pcolumns) + (x + 1)]) * cx) + ((u_old[((prows - 3) * pcolumns) + x] + u_old[((prows - 1) * pcolumns) + x]) * cy)) + (u_old[((prows - 2) * pcolumns) + x] * cc)) - ((((fX * fX) - 1.0) * ((alpha * (1.0 - (fY * fY))) + 2.0)) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  u[((prows - 2) * pcolumns) + x] = u_old[((prows - 2) * pcolumns) + x] - (relax * updateVal);\n  loop_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:loop_error) private(fX, updateVal, x) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dora-jpg/parallel-jacobi-SOR/HybridMPI/openmpi/4"}
{"code": "for (int i = 0; i < (dim * dim); i++)\n{\n  if ((i % 2) == 0)\n  {\n    C[i] = 0;\n    D[i] = 1;\n  }\n  else\n  {\n    C[i] = 1;\n    D[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/hands-on/gemm/1-gemmNN-omp-thread/1-gemmNN-omp-thread/1"}
{"code": "for (int i = 1; i < width; i++)\n  dp[i] = dp[i - 1] + height;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/3"}
{"code": "for (h = 0; h < 1024; ++h)\n  B[h] = malloc(1024 * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/4"}
{"code": "for (int i = 0; i < ((int) nsubranks_1d); ++i)\n{\n  out_queue_size += popcount_range(g.out_queue[i].bm.get_data(0, g.out_queue[i].bm.get_nwords()), g.out_queue[i].bm.get_length());\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:out_queue_size)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/21"}
{"code": "for (i = 0; i < 2; i++)\n{\n  free(cdata[i]);\n  free(cmask[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/126"}
{"code": "for (i = 0; i < 50; i++)\n{\n  if (i != boidNum)\n  {\n    centerPt[0] = centerPt[0] + boidArray[i][0];\n    centerPt[1] = centerPt[1] + boidArray[i][1];\n    centerPt[2] = centerPt[2] + boidArray[i][2];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjhenning6/ASCII_boids_OpenMP/boids/1"}
{"code": "for (k = a; k <= b; ++k)\n{\n  c = cos(twoPiOverN * k);\n  W[k].re = (W[n - k].re = c);\n  s = sin(twoPiOverN * k);\n  W[k].im = -s;\n  W[n - k].im = s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/fft/src/fft_ompi/0"}
{"code": "for (i = 0; i <= n2; i++)\n{\n  free((char *) net->hidden_weights[i]);\n  free((char *) net->hidden_prev_weights[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_backprop/backprop/7"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  pool[i] = parent[0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/4"}
{"code": "for (int i = 0; i < NRA; i++)\n{\n  for (int j = 0; j < NCB; j++)\n    fprintf(fptr, \"%6.2f   \", c[i][j]);\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPMatrixMult/Ex5MM_Multiply/1"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n  {\n    if (percentDiff(b_cpu[(i * 500) + j], b_gpu[(i * 500) + j]) > 0.05)\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/lu-decomposition/src/lu-decomposition_gpu/2"}
{"code": "for (i = 0; i < (*num_ph); i++)\n{\n  if ((((*ph_orig)[i].weight != 0) && (((*ph_orig)[i].type == COMPTONIZED_PHOTON) || ((*ph_orig)[i].type == UNABSORBED_CS_PHOTON))) && ((*ph_orig)[i].p0 > 0))\n  {\n    if ((*ph_orig)[i].p0 < p0_min)\n    {\n      p0_min = (*ph_orig)[i].p0;\n      min_idx = i;\n    }\n\n    if ((*ph_orig)[i].p0 > p0_max)\n    {\n      p0_max = (*ph_orig)[i].p0;\n      max_idx = i;\n    }\n\n    ph_r = sqrt((((*ph_orig)[i].r0 * (*ph_orig)[i].r0) + ((*ph_orig)[i].r1 * (*ph_orig)[i].r1)) + ((*ph_orig)[i].r2 * (*ph_orig)[i].r2));\n    ph_theta = acos((*ph_orig)[i].r2 / ph_r);\n    if (ph_theta > temp_theta_max)\n    {\n      temp_theta_max = ph_theta;\n    }\n\n    if (ph_theta < temp_theta_min)\n    {\n      temp_theta_min = ph_theta;\n    }\n\n    ph_phi = fmod(((atan((*ph_orig)[i].r1 / (*ph_orig)[i].r0) * 180) / M_PI) + 360.0, 360.0);\n    if (ph_phi > temp_phi_max)\n    {\n      temp_phi_max = ph_phi;\n    }\n\n    if (ph_phi < temp_phi_min)\n    {\n      temp_phi_min = ph_phi;\n    }\n\n    synch_comp_photon_idx[count] = i;\n    count++;\n    if ((*ph_orig)[i].type == COMPTONIZED_PHOTON)\n    {\n      count_c_ph += 1;\n    }\n\n  }\n  else\n    if (((*ph_orig)[i].type == CS_POOL_PHOTON) && ((*ph_orig)[i].weight != 0))\n  {\n    synch_photon_count++;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/3"}
{"code": "for (c3 = 0; c3 <= (((N - c1) - 3) / 16); c3 += 1)\n  for (c5 = 0; c5 <= ((c1 - 1) / 16); c5 += 1)\n  for (c7 = 0; c7 <= ((-c3) + (((N - c1) - 3) / 16)); c7 += 1)\n  for (c11 = (c1 + (16 * c3)) + 1; c11 <= ((((c1 + (16 * c3)) + 16) < ((N - (16 * c7)) - 2)) ? ((c1 + (16 * c3)) + 16) : ((N - (16 * c7)) - 2)); c11 += 1)\n{\n  if (N >= (((16 * c7) + c11) + 18))\n  {\n    for (c15 = ((16 * c7) + c11) + 1; c15 <= (((16 * c7) + c11) + 16); c15 += 1)\n      Pbp[c1][c11] += ((((Pbp[16 * c5][c15] * ERT) * Q[(16 * c5) + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[16 * c5][c15] == 0) ? (1) : (Qbp[16 * c5][c15]));\n\n  }\n  else\n  {\n    for (c13 = 16 * c5; c13 <= (((c1 - 1) < ((16 * c5) + 15)) ? (c1 - 1) : ((16 * c5) + 15)); c13 += 1)\n    {\n      if (c13 >= ((16 * c5) + 1))\n        for (c15 = c11 + 1; c15 <= ((16 * c7) + c11); c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n\n      for (c15 = ((16 * c7) + c11) + 1; c15 < N; c15 += 1)\n        Pbp[c1][c11] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][c11]) * Q[c11 + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n    }\n\n  }\n\n}\n\n\n\n\n", "pragma": "omp parallel for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_pb_traco/2"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < columns; j++)\n  {\n    printf(\"%ld\\t\", M[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chander2207/Dijkstra-openmp/omp_dijkstra/12"}
{"code": "for (y = max(1, r); y < min(GLOBAL_GRID_W - 1, r + OMP_THREADS); ++y)\n  buf_grid_values[get_index_row(proc_x_indices.second, y)] = recv_matrix_buf[y - r];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/18"}
{"code": "for (j = 0; j <= l; j++)\n  a[j] = 1;\n\n", "pragma": "omp parallel for num_threads (3 * i) schedule (dynamic, i * 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/for-18/0"}
{"code": "for (i = 0; i < N; i++)\n  yi[i] = (((-1) * (i + 2)) * rand()) * 1.0E-6;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hibari-K/ParallelProg/nbody/2"}
{"code": "for (int k = 0; k < num_blocks; k += 1)\n{\n  log_debug(\"Node %d calculating block %d block of local C\\n\", node_rank, k);\n  int offset = k * block_size;\n  ijk_parallel(row_block_a + offset, col_block_b + offset, block_c, block_width, node_rank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/malogulko/matrix_dot_omp_mpi_hybrid/matrix_dot_omp_mpi/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] += offset;\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/prefixsum/3"}
{"code": "for (col = 0; col < nX; col++)\n{\n  l1[col] = (geomx[3] + (geomx[4] * col)) + (geomx[5] * row);\n}\n\n", "pragma": "omp parallel for default(none) private(col) shared( row, geomx, nX, l1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/0"}
{"code": "for (i = 0; i < M; i = i + 4)\n{\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[(i * M) + k] * B[(k * M) + j]);\n      r = r + (A[((i * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[((i * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[((i * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[(i * M) + j] = (alpha * r) + (beta * C[(i * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 1) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 1) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 1) * M) + j] = (alpha * r) + (beta * C[((i + 1) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 2) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 2) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 2) * M) + j] = (alpha * r) + (beta * C[((i + 2) * M) + j]);\n  }\n\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    for (k = 0; k < M; k = k + 4)\n    {\n      r = r + (A[((i + 3) * M) + k] * B[(k * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 1] * B[((k + 1) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 2] * B[((k + 2) * M) + j]);\n      r = r + (A[(((i + 3) * M) + k) + 3] * B[((k + 3) * M) + j]);\n    }\n\n    C[((i + 3) * M) + j] = (alpha * r) + (beta * C[((i + 3) * M) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemm/11"}
{"code": "for (i = 0; i < N; i++)\n  free(array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1a/code/Game_Of_Life/3"}
{"code": "for (int col = 0; col < 7; col++)\n{\n  for (int row = 6; row >= 0; row--)\n  {\n    if (this->board[row][col] == (-1))\n    {\n      positions.push_back(make_pair(row, col));\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/0"}
{"code": "for (int i = 0; i < str.length(); i += 3)\n{\n  temp = str.substr(i, 3);\n  codons[temp]++;\n  result[amino[temp]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/be320/OpenMP-DNA-Translator/DNA-Transaltor/DNA-Transaltor/DNA-Transaltor/1"}
{"code": "for (i = 0; i < len; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#1#0\n  #pragma cetus parallel\n  for (j = 0; j < len; j++)\n  {\n    c[i][j] = a[i][j] * b[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB098-simd2-orig-no/2"}
{"code": "for (int i = 0; i < (*size); i++)\n{\n  temp = atoi(strtok(NULL, \" \"));\n  if ((temp > 0) && (temp < 257))\n    numbers[i] = temp;\n  else\n  {\n    *size = (*size) - 1;\n    i = i - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NaorFahima/Parallel-And-Distributed-Computing/Exercise 3/histogram/0"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  for (unsigned int j = i + 1; j < size; ++j)\n  {\n    if (rGeometry[i].GetValue(MODEL_PART_NAME) == rGeometry[j].GetValue(MODEL_PART_NAME))\n    {\n      rSlaveVertices[i] += 1;\n      rSlaveVertices[j] += 1;\n    }\n\n  }\n\n  NumberOfSlaves += rSlaveVertices[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/10"}
{"code": "for (unsigned p = 0; p < Size; p++)\n{\n  unsigned k = (data[p] >> ckmov) & KEYSMASK;\n  unsigned pk = p2[k];\n  data2[pk] = data[p];\n  index2[pk] = index[p];\n  p2[k]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/9"}
{"code": "for (int i = 0; i < n1; i++)\n{\n  for (int k = 0; k < m1; k++)\n  {\n    const float *bl = mb[k];\n    const float v = ma[i][k];\n    float *rl = resultMatrix[i];\n    for (size_t j = 0; j < m2; j++)\n    {\n      rl[j] += v * bl[j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/5"}
{"code": "for (int i = 0; i < 20000; ++i)\n{\n  sum += f(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/scheduleFor/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    C[i][j] = 0.;\n    for (m = 0; m < 4; m++)\n    {\n      C[i][j] = (A[i][m] * B[m][j]) + C[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(m,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/matrix_matrix_multiplication/0"}
{"code": "for (i = 0; i < 10; i++)\n  sleep(0.5);\n\n", "pragma": "\t\t#pragma omp parallel for private(i) num_threads(nthreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/tests/3"}
{"code": "for (int i = 0; i < images_nr; ++i)\n{\n  MPI_Send(encoded_images[i], encoded_images_sz[i], (MPI_Datatype) 0x4c00010d, 0, 0, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/8"}
{"code": "for (r = 0; r < 1000; r++)\n{\n  xNew[r] = (float *) malloc(1000 * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/se-mendheim/Jacobi-Iterations/JacobiIteration/2"}
{"code": "for (uint8_t n = start8; n <= end8; n++)\n{\n  double time_diff;\n  double time_start;\n  time_start = get_time();\n  uint64_t result = nqueens(n);\n  time_diff = get_time() - time_start;\n  int pass = result == results[n - 1];\n  all_pass &= pass;\n  (pass) ? (printf(\"PASS \")) : (printf(\"FAIL \"));\n  printf(\"N %2d, Solutions %18u, Expected %18u, Time %f sec., Solutions/s %f\\n\", n, result, results[n - 1], time_diff, result / time_diff);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sudden6/m-queens/main/2"}
{"code": "for (i = 0; i < 16; i++)\n{\n  if (input[i] != i)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_17_epilog_killer_parallel/8"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  a[i] -= b[i];\n}\n\n", "pragma": "    #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paulpaulych/parallel_labs/Lab2/var1/3"}
{"code": "for (i = 0; i < 4; i++)\n{\n  switch (llave_hexadecimal[i])\n  {\n    case '0':\n      llave_hexadecimal[i] = 0;\n      break;\n\n    case '1':\n      llave_hexadecimal[i] = 1;\n      break;\n\n    case '2':\n      llave_hexadecimal[i] = 2;\n      break;\n\n    case '3':\n      llave_hexadecimal[i] = 3;\n      break;\n\n    case '4':\n      llave_hexadecimal[i] = 4;\n      break;\n\n    case '5':\n      llave_hexadecimal[i] = 5;\n      break;\n\n    case '6':\n      llave_hexadecimal[i] = 6;\n      break;\n\n    case '7':\n      llave_hexadecimal[i] = 7;\n      break;\n\n    case '8':\n      llave_hexadecimal[i] = 8;\n      break;\n\n    case '9':\n      llave_hexadecimal[i] = 9;\n      break;\n\n    case 'a':\n\n    case 'A':\n      llave_hexadecimal[i] = 10;\n      break;\n\n    case 'b':\n\n    case 'B':\n      llave_hexadecimal[i] = 11;\n      break;\n\n    case 'c':\n\n    case 'C':\n      llave_hexadecimal[i] = 12;\n      break;\n\n    case 'd':\n\n    case 'D':\n      llave_hexadecimal[i] = 13;\n      break;\n\n    case 'e':\n\n    case 'E':\n      llave_hexadecimal[i] = 14;\n      break;\n\n    case 'f':\n\n    case 'F':\n      llave_hexadecimal[i] = 15;\n      break;\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chuucks/C-Multi-Parallel-programing-with-and-OpenMp-and-MPI/encriptador_paralelo/0"}
{"code": "for (int i = 0; i < (size / 2); i++)\n{\n  suma[i] = vect1[i] + vect2[i];\n  printf(\"[Proceso %d] (Suma) He calculado %f (indice=%d)\\n\", id, suma[i], i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashant-JT/OpenMP-Examples/Practica/OpenMP/9"}
{"code": "for (int i = 0; i < kernel.width; i++)\n  kernel.pixels[i][row] = kernel.pixels[i][rank];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YacineSahli/ImageConvolutionOpenMP/convolution/2"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  if (u_data->received_first_message)\n    continue;\n\n  while (!is_ql_queue_empty(msgs, u->label))\n  {\n    u_data->received_first_message = 1;\n    message *m = dequeue(msgs, u->label);\n    for (int j = 0; j < u->degree; j++)\n    {\n      node *v = *((node **) elem_at(&u->neighbors, j));\n      payload *v_data = v->data;\n      if (v->label == m->from)\n        continue;\n\n      if (v_data->fragment_id != u_data->fragment_id)\n      {\n        edge b = {u->label, v->label, g->adj_mat[u->label][v->label]};\n        enqueue(blues, u_data->fragment_id, &b);\n      }\n      else\n      {\n        message mx = {u->label};\n        enqueue(tmp_msgs, v->label, &mx);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/2"}
{"code": "for (int i = 0; i < nelr; i++)\n{\n  for (int j = 0; j < NVAR; j++)\n    variables[(i * NVAR) + j] = ff_variable[j];\n\n}\n\n", "pragma": "\t#pragma omp parallel for default(shared) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gssrinivasan/offomp/benchmarks/UV_rodinia_3.0/openmp/cfd/euler3d_cpu/4"}
{"code": "for (row = 0; row < rows; row++)\n{\n  for (col = 0; col < cols; col++)\n    edited_image[(row * rows) + col] = (unsigned char) new_gray_level[image[(row * rows) + col]];\n\n}\n\n", "pragma": "omp parallel for shared(row, edited_image) private(col)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/9"}
{"code": "for (int i = 0; i < src.rows; i++)\n{\n  for (int j = 0; j < src.cols; j++)\n  {\n    if ((((i < fsize) || (i >= (src.rows - fsize))) || (j < fsize)) || (j >= (src.cols - fsize)))\n    {\n      dst(i, j)[0] = 0;\n      dst(i, j)[1] = 0;\n      dst(i, j)[2] = 0;\n    }\n    else\n    {\n      for (int n = 0; n < k; n++)\n      {\n        for (int m = 0; m < k; m++)\n        {\n          dst(i, j)[0] += (int) (src((i + n) - fsize, (j + m) - fsize)[0] * kernel[n][m]);\n          dst(i, j)[1] += (int) (src((i + n) - fsize, (j + m) - fsize)[1] * kernel[n][m]);\n          dst(i, j)[2] += (int) (src((i + n) - fsize, (j + m) - fsize)[2] * kernel[n][m]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/Conv/2"}
{"code": "for (j = 0; j < V; j += step)\n{\n  for (i = 0; i < V; i += step)\n  {\n    for (int jj = j; jj < (j + step); jj++)\n    {\n      for (int ii = i; ii < (i + step); ii++)\n      {\n        if (graph[ii][jj] > (graph[ii][k] + graph[k][jj]))\n        {\n          graph[ii][jj] = graph[ii][k] + graph[k][jj];\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/duleryr/hpc_gpu/src/Floyd_Warshall/32"}
{"code": "for (i = SCANSTEP; i < ((seekLength - SCANWIND) - 1); i += SCANSTEP)\n{\n  corr = (float) calcCrossCorr(refPos + (channels * i), pMidBuffer, norm);\n  float tmp = ((float) (((2 * i) - seekLength) - 1)) / ((float) seekLength);\n  corr = (corr + 0.1f) * (1.0f - ((0.25f * tmp) * tmp));\n  if (corr > bestCorr)\n  {\n    bestCorr2 = bestCorr;\n    bestOffs2 = bestOffs;\n    bestCorr = corr;\n    bestOffs = i;\n  }\n  else\n    if (corr > bestCorr2)\n  {\n    bestCorr2 = corr;\n    bestOffs2 = i;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/TDStretch/1"}
{"code": "for (int i = 1; i < HEIGHT; i++)\n{\n  lock(i, locks);\n  for (int j = 1; j < WIDTH; j++)\n  {\n    if (MeshA[i][j].isEmpty())\n    {\n      continue;\n    }\n\n    MeshA[i][j].setOwner(SOUTH);\n    MeshA[i][j].setEmpty(true);\n    double move = twisters[omp_get_thread_num()]->rand();\n    double moveProb = MeshA[i][j].getMoveAdjustment(MOVE_PROB);\n    if (((move < (1.0 * moveProb)) && MeshA[i - 1][j].isEmpty()) && MeshB[i - 1][j].isEmpty())\n    {\n      MeshB[i - 1][j] = MeshA[i][j];\n    }\n    else\n      if (((move < (2.0 * moveProb)) && MeshA[i + 1][j].isEmpty()) && MeshB[i + 1][j].isEmpty())\n    {\n      MeshB[i + 1][j] = MeshA[i][j];\n    }\n    else\n      if (((move < (3.0 * moveProb)) && MeshA[i][j - 1].isEmpty()) && MeshB[i][j - 1].isEmpty())\n    {\n      MeshB[i][j - 1] = MeshA[i][j];\n    }\n    else\n      if (((move < (4.0 * moveProb)) && MeshA[i][j + 1].isEmpty()) && MeshB[i][j + 1].isEmpty())\n    {\n      MeshB[i][j + 1] = MeshA[i][j];\n    }\n    else\n    {\n      MeshB[i][j] = MeshA[i][j];\n    }\n\n\n\n\n    MeshB[i][j].setEmpty(false);\n  }\n\n  unlock(i, locks);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for default(none) shared(s,MeshA,MeshB,locks,twisters) num_threads(nThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yang0228/zombieApocalypse-MPI-OPENMP/stage2/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = 0;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for simd num_teams(te), thread_limit(th) aligned(a : 8) safelen(16) simdlen(4) linear(i : n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_teams_distribute_parallel_for_simd_codegen/0"}
{"code": "for (i = iters->begin(); i != iters->end(); ++i)\n  if (!strcmp(*i, (char *) pv->symbol->name_str))\n  break;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/PolyOpt2/polyopt/PastToSage/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i].start_time = (i == 0) ? (p[i].arrival_time) : (max(p[i - 1].completion_time, p[i].arrival_time));\n  p[i].completion_time = p[i].start_time + p[i].burst_time;\n  p[i].turnaround_time = p[i].completion_time - p[i].arrival_time;\n  p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n  p[i].response_time = p[i].start_time - p[i].arrival_time;\n  total_turnaround_time += p[i].turnaround_time;\n  total_waiting_time += p[i].waiting_time;\n  total_response_time += p[i].response_time;\n  total_idle_time += (i == 0) ? (p[i].arrival_time) : (p[i].start_time - p[i - 1].completion_time);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/fcfs_parallel/1"}
{"code": "for (int i = 0; i < g->num_verts; ++i)\n{\n  pr_sum += pageranks[i];\n  if (pageranks[i] > max_pr)\n  {\n    max_pr = pageranks[i];\n    max_vert = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/surf/1"}
{"code": "for (i = 0; i < n1; i++)\n{\n  L[i] = fit[low + i];\n  copy(G1[i], genes[low + i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/8"}
{"code": "for (int i = 0; i < pt.size(); i++)\n{\n  cipher[i] = encryption(pt[i], roundKeys);\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(guided) num_threads(8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ashishpoudel995/Parallelization-of-DES-Algorithm-Using-Open-MP/Codes/nestedParallelism/4"}
{"code": "for (int i = 0; i < farm_size; i++)\n  cascade_dx[i].load(cascadeName);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/ComputerVision/ufacedetect/2"}
{"code": "for (int k = 0; k < NUMOUT; k++)\n  for (int j = 0; j < NUMHID; j++)\n  WeightHO[k][j] += DeltaWeightHO[k][j];\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/oriolmartinezac/cap-openmp/nn-vo-db/7"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n{\n  for (int j = 1; j < (ny - 1); j++)\n  {\n    in[(i * nx) + j] = out[(i * nx) + j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/OpenMP/jacobi_omp/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (scheme == \"Second-Order-Upwind\")\n    {\n      if (i == 0)\n      {\n        C_n_up = up_ghost_cells[j];\n        C_n_up2 = up_ghost_cells[j + N];\n        C_n_down = C_n[i + 1][j];\n        C_n_down2 = C_n[i + 2][j];\n        if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_left2 = left_ghost_cells[i + N];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 1))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = right_ghost_cells[i];\n          C_n_right2 = right_ghost_cells[i + N];\n        }\n        else\n          if (j == 1)\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 2))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = right_ghost_cells[i];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n\n\n\n\n      }\n      else\n        if (i == (N - 1))\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_up2 = C_n[i - 2][j];\n        C_n_down = down_ghost_cells[j];\n        C_n_down2 = down_ghost_cells[j + N];\n        if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_left2 = left_ghost_cells[i + N];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 1))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = right_ghost_cells[i];\n          C_n_right2 = right_ghost_cells[i + N];\n        }\n        else\n          if (j == 1)\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 2))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = right_ghost_cells[i];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n\n\n\n\n      }\n      else\n        if (i == 1)\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_up2 = up_ghost_cells[j];\n        C_n_down = C_n[i + 1][j];\n        C_n_down2 = C_n[i + 2][j];\n        if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_left2 = left_ghost_cells[i + N];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 1))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = right_ghost_cells[i];\n          C_n_right2 = right_ghost_cells[i + N];\n        }\n        else\n          if (j == 1)\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 2))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = right_ghost_cells[i];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n\n\n\n\n      }\n      else\n        if (i == (N - 2))\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_up2 = C_n[i - 2][j];\n        C_n_down = C_n[i + 1][j];\n        C_n_down2 = down_ghost_cells[j];\n        if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_left2 = left_ghost_cells[i + N];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 1))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = right_ghost_cells[i];\n          C_n_right2 = right_ghost_cells[i + N];\n        }\n        else\n          if (j == 1)\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 2))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = right_ghost_cells[i];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n\n\n\n\n      }\n      else\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_up2 = C_n[i - 2][j];\n        C_n_down = C_n[i + 1][j];\n        C_n_down2 = C_n[i + 2][j];\n        if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_left2 = left_ghost_cells[i + N];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 1))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = right_ghost_cells[i];\n          C_n_right2 = right_ghost_cells[i + N];\n        }\n        else\n          if (j == 1)\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n        else\n          if (j == (N - 2))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = right_ghost_cells[i];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_left2 = C_n[i][j - 2];\n          C_n_right = C_n[i][j + 1];\n          C_n_right2 = C_n[i][j + 2];\n        }\n\n\n\n\n      }\n\n\n\n\n    }\n    else\n    {\n      if ((i != 0) && (i != (N - 1)))\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_down = C_n[i + 1][j];\n        if ((j != 0) && (j != (N - 1)))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n          if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = right_ghost_cells[i];\n        }\n\n\n      }\n      else\n        if (i == 0)\n      {\n        C_n_up = up_ghost_cells[j];\n        C_n_down = C_n[i + 1][j];\n        if ((j != 0) && (j != (N - 1)))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n          if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = right_ghost_cells[i];\n        }\n\n\n      }\n      else\n      {\n        C_n_up = C_n[i - 1][j];\n        C_n_down = down_ghost_cells[j];\n        if ((j != 0) && (j != (N - 1)))\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n          if (j == 0)\n        {\n          C_n_left = left_ghost_cells[i];\n          C_n_right = C_n[i][j + 1];\n        }\n        else\n        {\n          C_n_left = C_n[i][j - 1];\n          C_n_right = right_ghost_cells[i];\n        }\n\n\n      }\n\n\n    }\n\n    C_n[i][j] = 0.25 * (((C_n_up + C_n_down) + C_n_left) + C_n_right);\n    if (scheme == \"LAX\")\n    {\n      C_n_1[i][j] = C_n[i][j] - ((dt / (2 * dx)) * ((u * (C_n_down - C_n_up)) + (v * (C_n_right - C_n_left))));\n    }\n    else\n      if (scheme == \"First-Order-Upwind\")\n    {\n      if (((u * u) + (v * v)) > 0)\n      {\n        C_n_1[i][j] = C_n[i][j] - ((dt / dx) * ((u * (C_n[i][j] - C_n_up)) + (v * (C_n[i][j] - C_n_left))));\n      }\n      else\n        if (((u * u) + (v * v)) < 0)\n      {\n        C_n_1[i][j] = C_n[i][j] - ((dt / dx) * ((u * (C_n_down - C_n[i][j])) + (v * (C_n_right - C_n[i][j]))));\n      }\n\n\n    }\n    else\n      if (scheme == \"Second-Order-Upwind\")\n    {\n      if (((u * u) + (v * v)) > 0)\n      {\n        C_n_1[i][j] = C_n[i][j] - ((dt / (2 * dx)) * ((u * (((3 * C_n[i][j]) - (4 * C_n_up)) + C_n_up2)) + (v * (((3 * C_n[i][j]) - (4 * C_n_left)) + C_n_left2))));\n      }\n      else\n        if (((u * u) + (v * v)) < 0)\n      {\n        C_n_1[i][j] = C_n[i][j] - ((dt / (2 * dx)) * ((u * (((4 * C_n_down) - C_n_down2) - (3 * C_n[i][j]))) + (v * (((4 * C_n_right) - (3 * C_n[i][j])) - C_n_right2))));\n      }\n\n\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i, j, C_n_up, C_n_down, C_n_left, C_n_right, C_n_up2, C_n_down2, C_n_left2, C_n_right2) shared(C_n, C_n_1, N, dt, dx, u, v, left_ghost_cells, right_ghost_cells, up_ghost_cells, down_ghost_cells, scheme) schedule(guided)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/Advection-Diffusion-Simulation/final-version/advection_simulation/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB068-restrictpointer2-orig-no/2"}
{"code": "for (int j = 0; j < N; j++)\n{\n  move_body(bodies, N, G, DT, EPS, j);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dd2356/OpenMP/OpenMP/exercise_4/src/nbody/0"}
{"code": "for (i = 1; i < n; ++i)\n{\n  a[i] = a[i] + a[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alty-ir/openmp/openmp/Lab_4_parallel1/1"}
{"code": "for (int i = 0; i < thread_num; i++)\n{\n  if (remaining_rows == 0)\n  {\n    thread_p[i].start = i * rows_per_thread;\n    thread_p[i].end = (thread_p[i].start + rows_per_thread) - 1;\n  }\n  else\n  {\n    if (i <= remaining_rows)\n    {\n      ci = i;\n    }\n\n    thread_p[i].start = (i * rows_per_thread) + ci;\n    thread_p[i].end = (i < remaining_rows) ? (thread_p[i].start + rows_per_thread) : ((thread_p[i].start + rows_per_thread) - 1);\n  }\n\n  thread_p[i].n = n;\n  thread_p[i].dst = (void *) dist;\n  thread_p[i].id = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vgafx/APSP/apsp_kernel/7"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericParticles[i]->Move(delta_t, rotation_option, force_reduction_factor, StepFlag);\n}\n\n", "pragma": "            #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/6"}
{"code": "for (j = 0; j < 5; j++)\n{\n  printf(\"\\n Sequencia %s quantidade dna1 %d quantidade dna2 %d\\n\", comb[maiores[j]], qnt[maiores[j]], qntmaior[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarceloMilbradt/Analizador-genoma-paralelo/dna/7"}
{"code": "for (k = 0; k < nn; k++)\n{\n  for (i = 0; i < nn; i++)\n  {\n    for (j = 0; j < nn; j++)\n    {\n      if (dist_mat[(i * nn) + j] > (dist_mat[(i * nn) + k] + dist_mat[(k * nn) + j]))\n      {\n        dist_mat[(i * nn) + j] = dist_mat[(i * nn) + k] + dist_mat[(k * nn) + j];\n        pred_mat[(i * nn) + j] = k;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for                                ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TransientObject/ParallelizeAlgos/lib/floyd_warshall/floyd/2"}
{"code": "for (int i = 0; i < m; i++)\n{\n  pC[i] = (float *) _mm_malloc(n * (sizeof(float)), 64);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akhauriyash/XNOR-Nets/xCMMA/7"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  bar();\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/nesting_of_regions/1"}
{"code": "for (i = 0; i < DEV_NUM; i++)\n{\n  for (j = 0; j < num_rows[i]; j++)\n  {\n    err = clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *) (img_buf[i] + j));\n    err = clSetKernelArg(kernel, 1, sizeof(cl_mem), (void *) (cifar_buf + i));\n    err = clSetKernelArg(kernel, 2, sizeof(cl_mem), (void *) (output[i] + j));\n    err = clEnqueueNDRangeKernel(command_queue[i][1], kernel, 3, 0, g_wsize, l_wsize, 1, write_event[i] + j, kernel_event[i] + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/C/photomosaic/7"}
{"code": "for (i = 0; i < 5; i++)\n  printf(\"[%d] = %d\\n\", i, hist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram/2"}
{"code": "for (n = 0; n <= 45; n++)\n{\n  printf(\"Fib(%lld): %lld\\n\", n, fib(n));\n}\n\n", "pragma": "omp parallel for schedule(guided, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 3/exp/0"}
{"code": "for (i = 0; i < num_b; i++)\n{\n  *(((unsigned long *) dst) + i) = *(((unsigned long *) src) + i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/0"}
{"code": "for (int m = 0; m < ts.ROWS; m++)\n{\n  index[m] = ts.value[m * ts.COLS];\n  signal[m] = ts.value[(m * ts.COLS) + 1];\n  uncert[m] = sqrt(fabs(signal[m]));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mwilchek/HPC-Examples/Project_1/Get_Stats/src/get_data/1"}
{"code": "for (i = 0; i < 8; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    a[i][j] = (j + i) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/Esercizio1/1"}
{"code": "for (i = 0; i < edgeList->num_vertices; i++)\n{\n  printf(\"label %-2u->%-2u - %-2u->%-2u \\n\", i, edgeList->label_array[i], i, edgeList->inverse_label_array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/edgeList/10"}
{"code": "for (int i = 0; i < m; i++)\n{\n  int in = i * n;\n  for (j = 0; j < n; j++)\n  {\n    at[j + in] = a[i + (j * m)];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/26"}
{"code": "for (i = 0; i < m->size; i++)\n{\n  maxIndexA[i] = -2147483648;\n  minIndexA[i] = 2147483647;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/remy-grc/maximum-subsequence/maximum_subsequence/12"}
{"code": "for (col = 0; col < 1000; col++)\n{\n  *((current + (250 * 1000)) + col) = 100;\n  *((next + (250 * 1000)) + col) = 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShaunJorstad/Hybrid-parallelized-thermal-conduction/jacobiHybrid/3"}
{"code": "for (int i = 1; i <= 4; i++)\n{\n  char str[25] = \"cat (\";\n  char out[25] = \"out (\";\n  int a = i;\n  int tmp = i;\n  int cnt = 0;\n  while (tmp)\n  {\n    tmp = tmp / 10;\n    cnt++;\n  }\n\n  int j = cnt - 1;\n  char pok[25] = \").png\";\n  char lok[25];\n  while (a)\n  {\n    int k = a % 10;\n    lok[j] = (char) ('0' + k);\n    a = a / 10;\n    j--;\n  }\n\n  lok[cnt] = '\\0';\n  strcat(str, lok);\n  strcat(str, pok);\n  strcat(out, lok);\n  strcat(out, pok);\n  char *s = out;\n  char *p = str;\n  edgeDetection(p, s);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/LoGParallel/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    I[(i * cols) + j] = rand() / ((float) RAND_MAX);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_srad/srad_v2/srad/6"}
{"code": "for (i = 0; i < n_charges; i++)\n  M[i] = malloc(n_charges * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ssvassiliev/Summer_School_OpenMP/code/elect_energy_omp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n    b[i][j] = 0.5;\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB031-truedepfirstdimension-orig-yes/0"}
{"code": "for (c1 = nk; c1 <= (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nk; c2 <= (((nl + (-1)) < (nm + (-1))) ? (nl + (-1)) : (nm + (-1))); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nk > nl) ? (nk) : (nl); c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/10"}
{"code": "for (i = 0; i < num_rownnz; i++)\n{\n  m = A_rownnz[i];\n  if (num_vectors == 1)\n  {\n    tempx = y_data[m];\n    for (jj = A_i[m]; jj < A_i[m + 1]; jj++)\n      tempx += A_data[jj] * x_data[A_j[jj]];\n\n    y_data[m] = tempx;\n  }\n  else\n    for (j = 0; j < num_vectors; ++j)\n  {\n    tempx = y_data[(j * vecstride_y) + (m * idxstride_y)];\n    for (jj = A_i[m]; jj < A_i[m + 1]; jj++)\n      tempx += A_data[jj] * x_data[(j * vecstride_x) + (A_j[jj] * idxstride_x)];\n\n    y_data[(j * vecstride_y) + (m * idxstride_y)] = tempx;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/3"}
{"code": "for (c1 = 0; c1 <= (n + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (n + (-1)); c2++)\n  {\n    A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n    B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB055-jacobi2d-parallel-no/0"}
{"code": "for (unsigned int i = 0; i < _intraGroup.size(); ++i)\n{\n  if (((_intraGroup[i].BitIsOn(a->GetIdx()) && _intraGroup[i].BitIsOn(b->GetIdx())) && _intraGroup[i].BitIsOn(c->GetIdx())) && _intraGroup[i].BitIsOn(d->GetIdx()))\n    validTorsion = true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/12"}
{"code": "for (i = 0; i < new_size; i++)\n{\n  for (j = 0; j < new_size; j++)\n  {\n    C[i][j] = c11[i][j];\n    C[i][j + new_size] = c12[i][j];\n    C[i + new_size][j] = c21[i][j];\n    C[i + new_size][j + new_size] = c22[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Soubhagyabehera/strassen-matrix-multiplication-parallel-program/strassens-matrix-mul/3"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      z = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      nn = x;\n      mm = y;\n      ll = z;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      dzp = z - ((float) ll);\n      n[j] = ((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      dx1 = dxp * dyp;\n      dyp = amx * dyp;\n      amx = amx * amy;\n      amz = 1.0f - dzp;\n      amy = dxp * amy;\n      s[j] = amx * amz;\n      s[j + 32] = amy * amz;\n      s[j + (2 * 32)] = dyp * amz;\n      s[j + (3 * 32)] = dx1 * amz;\n      s[j + (4 * 32)] = amx * dzp;\n      s[j + (5 * 32)] = amy * dzp;\n      s[j + (6 * 32)] = dyp * dzp;\n      s[j + (7 * 32)] = dx1 * dzp;\n      t[j] = x;\n      t[j + 32] = y;\n      t[j + (2 * 32)] = z;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = (nn + mxv) - 2;\n      ll = (nn + mxyv) - 4;\n      k = (ll + mxv) - 2;\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      for (i = 0; i < 8; i++)\n      {\n        if (i > 5)\n        {\n          nn = k;\n        }\n        else\n          if (i > 3)\n        {\n          nn = ll;\n        }\n        else\n          if (i > 1)\n        {\n          nn = mm;\n        }\n\n\n\n        dx += sfxyz[4 * (i + nn)] * s[j + (32 * i)];\n        dy += sfxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        dz += sfxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n        ox += sbxyz[4 * (i + nn)] * s[j + (32 * i)];\n        oy += sbxyz[1 + (4 * (i + nn))] * s[j + (32 * i)];\n        oz += sbxyz[2 + (4 * (i + nn))] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n      s[j + (2 * 32)] = dz;\n      s[j + (3 * 32)] = ox;\n      s[j + (4 * 32)] = oy;\n      s[j + (5 * 32)] = oz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      z = t[j + (2 * 32)];\n      dx = qtmh * s[j];\n      ;\n      dy = qtmh * s[j + 32];\n      dz = qtmh * s[j + (2 * 32)];\n      acx = ppart[((j + joff) + (3 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (4 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (5 * nppmx)) + npoff] + dz;\n      sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n      omxt = qtmh * s[j + (3 * 32)];\n      omyt = qtmh * s[j + (4 * 32)];\n      omzt = qtmh * s[j + (5 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      s[j] = x + (vx * dtc);\n      s[j + 32] = y + (vy * dtc);\n      s[j + (2 * 32)] = z + (vz * dtc);\n      s[j + (3 * 32)] = vx;\n      s[j + (4 * 32)] = vy;\n      s[j + (5 * 32)] = vz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      dz = s[j + (2 * 32)];\n      vx = s[j + (3 * 32)];\n      vy = s[j + (4 * 32)];\n      vz = s[j + (5 * 32)];\n      if (ipbc == 2)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n        if ((dz < edgelz) || (dz >= edgerz))\n        {\n          dz = t[j + (2 * 32)];\n          vz = -vz;\n        }\n\n      }\n      else\n        if (ipbc == 3)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = dz;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = vx;\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = vy;\n      ppart[((j + joff) + (5 * nppmx)) + npoff] = vz;\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    dz = z + (vz * dtc);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        vz = -vz;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,ipp,joff,nps,nn,mm,ll,nm,x, y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz, omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, sum1,sfxyz,sbxyz,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/6"}
{"code": "for (t = 0; t < (ytot - 1); t++)\n{\n  float maxVal = ((ttot - 1) < (TY * t)) ? (ttot - 1) : (TY * t);\n  float minVal = ((1 + ((t - 1) * TY)) < (ttot - 1)) ? (1 + ((t - 1) * TY)) : (ttot - 1);\n  for (u = minVal; u < maxVal; u++)\n  {\n    if ((minVal < maxVal) && (maxVal < ttot))\n    {\n      qdo[t] = qdo[t] + ((((QDB - qo[btot - 1][u]) > 0.) ? (QDB - qo[btot - 1][u]) : (0.)) * TS);\n      qdr[t] = qdr[t] + ((((QDB - qr[btot - 1][u]) > 0.) ? (QDB - qr[btot - 1][u]) : (0.)) * TS);\n    }\n\n  }\n\n  dqd[n] = dqd[n] + ((qdo[t] - qdr[t]) / qdo[t]);\n  qodef[n] = qodef[n] + qdo[t];\n  qrdef[n] = qrdef[n] + qdr[t];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/HBV/hbv_performance/1"}
{"code": "for (i = 0; (i < 64) || (i < (data[(data_len * 64) - 1] + 32)); i++)\n{\n  memcpy(data, password, pwlen);\n  memcpy(data + pwlen, block, block_size);\n  data_len = (pwlen + block_size) + ((ownerkey) ? (48) : (0));\n  for (j = 1; j < 64; j++)\n    memcpy(data + (j * data_len), data, data_len);\n\n  AES_set_encrypt_key(block, 128, &aes);\n  AES_cbc_encrypt(data, data, data_len * 64, &aes, block + 16, AES_ENCRYPT);\n  for (j = 0, sum = 0; j < 16; j++)\n    sum += data[j];\n\n  block_size = 32 + ((sum % 3) * 16);\n  switch (block_size)\n  {\n    case 32:\n      SHA256_Init(&sha256);\n      SHA256_Update(&sha256, data, data_len * 64);\n      SHA256_Final(block, &sha256);\n      break;\n\n    case 48:\n      SHA384_Init(&sha384);\n      SHA384_Update(&sha384, data, data_len * 64);\n      SHA384_Final(block, &sha384);\n      break;\n\n    case 64:\n      SHA512_Init(&sha512);\n      SHA512_Update(&sha512, data, data_len * 64);\n      SHA512_Final(block, &sha512);\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pdf_fmt_plug/4"}
{"code": "for (int jj = 1; jj < (params.nx - 1); ++jj)\n{\n  cells[(line * params.nx) + jj].speeds[6] = recvbuf[((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)];\n  cells[(line * params.nx) + jj].speeds[2] = recvbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 1];\n  cells[(line * params.nx) + jj].speeds[5] = recvbuf[(((params.lx * 3) + (params.ly * 6)) + ((jj - 1) * 3)) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/31"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i][j - 2][k][m] - (4. * u[i][j - 1][k][m])) + (5. * u[i][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/31"}
{"code": "for (jj = 0; jj < size; jj += block_size)\n{\n  for (kk = 0; kk < size; kk += block_size)\n  {\n    for (i = 0; i < size; i++)\n    {\n      for (j = jj; j < (((jj + block_size) > size) ? (size) : (jj + block_size)); j++)\n      {\n        tmp = 0.0f;\n        for (k = kk; k < (((kk + block_size) > size) ? (size) : (kk + block_size)); k++)\n        {\n          tmp += A[i][k] * B[k][j];\n        }\n\n        C[i][j] += tmp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmitrydonchenko/Block-Matrix-Multiplication-OpenMP/block_matrix/Source/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    if (array[(i * size) + j] < thresh)\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) reduction(+:count) private(i, j)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/texasfight/OpenMP_HW1/parallel_script/2"}
{"code": "for (int j = 0; j < LEN; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sergioge99/vectorization_and_parallelism/practicas_paralelizacion/p6_iaca_valgrind_aps/triad/6"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  if (rGeometry[i].Is(BOUNDARY))\n  {\n    BoundaryNodes += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  prev[(i * N) + 0] = INIT_VALUE;\n  prev[(i * N) + 1] = INIT_VALUE;\n  prev[(i * N) + (N - 1)] = INIT_VALUE;\n  prev[(i * N) + (N - 2)] = INIT_VALUE;\n  prev[(0 * N) + i] = INIT_VALUE;\n  prev[(1 * N) + i] = INIT_VALUE;\n  prev[((N - 1) * N) + i] = INIT_VALUE;\n  prev[((N - 2) * N) + i] = INIT_VALUE;\n  cur[(i * N) + 0] = INIT_VALUE;\n  cur[(i * N) + 1] = INIT_VALUE;\n  cur[(i * N) + (N - 1)] = INIT_VALUE;\n  cur[(i * N) + (N - 2)] = INIT_VALUE;\n  cur[(0 * N) + i] = INIT_VALUE;\n  cur[(1 * N) + i] = INIT_VALUE;\n  cur[((N - 1) * N) + i] = INIT_VALUE;\n  cur[((N - 2) * N) + i] = INIT_VALUE;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA1/stencil_2D/2"}
{"code": "for (int i = 0; i < iters_num; i++)\n{\n  printf(\"%d: One more for iteration\\n\", i + 1);\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR6/LR6_0/0"}
{"code": "for (n = 0; n < 3; n++)\n{\n  for (i = 0; i < grid_points[0]; i++)\n  {\n    for (j = 0; j < grid_points[1]; j++)\n    {\n      for (k = 0; k < grid_points[2]; k++)\n      {\n        lhs[(5 * n) + 2][i][j][k] = 1.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  C[i] = 0.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMP/4"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  lenscales.at(ci) = sqrt(cell(ci).geta0() / PI);\n  sum_a += cell(ci).geta0();\n  (calAPrintObject << lenscales.at(ci)) << endl;\n  cell(ci).setCForce(0, 0.0);\n  cell(ci).setCForce(1, 0.0);\n  for (vi = 0; vi < cell(ci).getNV(); vi++)\n    cell(ci).setUInt(vi, 0.0);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/101"}
{"code": "for (c2 = 0; c2 <= 127; c2++)\n{\n  for (c5 = 0; c5 <= 127; c5++)\n  {\n    F[c1][c2] += C[c1][c5] * D[c5][c2];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2, c5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/35"}
{"code": "for (int i = 0; i < L; ++i)\n{\n  for (int j = 0; j < C; ++j)\n  {\n    fscanf(f_in, \"%c \", &c);\n    switch (c)\n    {\n      case '.':\n      {\n        bools[i][j] = 0;\n        break;\n      }\n\n      case 'X':\n      {\n        bools[i][j] = 1;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cristof17/Game-of-Life-OpenMP/g_omp/12"}
{"code": "for (i = 0; i < num_points; i++)\n{\n  min = distarr[i].arr[0];\n  cluster[i] = 0;\n  for (j = 1; j < K; j++)\n  {\n    if (distarr[i].arr[j] < min)\n    {\n      min = distarr[i].arr[j];\n      cluster[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bahaa29/k_mean-with-openmp/main/5"}
{"code": "for (i = p; i < r; i++)\n{\n  if (a[i] < a[r])\n  {\n    lt[lt_n++] = a[i];\n  }\n  else\n  {\n    gt[gt_n++] = a[i];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aayushaggarwal/Distributed-Keyword-construction/docfreq2/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  if (somaArrayMulti == 0)\n  {\n    somaArrayMulti = MeuArray[i];\n  }\n  else\n  {\n    somaArrayMulti = somaArrayMulti + MeuArray[i];\n  }\n\n}\n\n", "pragma": "omp parallel for private( i, j) num_threads(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/array_openmp/0"}
{"code": "for (i = 1; i < (1 << 27); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/16"}
{"code": "for (int i = 0; i <= numcells; i++)\n{\n  FR[i] = dss[i] * uss[i];\n  FRU[i] = ((dss[i] * uss[i]) * uss[i]) + pss[i];\n  FRE[i] = (((pss[i] / (GAMMA - 1.0)) + (((0.5 * dss[i]) * uss[i]) * uss[i])) * uss[i]) + (pss[i] * uss[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/12"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n  {\n    c[i][j] = 0;\n    for (int k = 0; k < dim; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AniMahajan20/Parallel-Computing/Take Home Exercises/take home assignment 3/openmp_classes/0"}
{"code": "for (int i = 1; i < ARRAY_SIZE; ++i)\n{\n  if (max < ar[i])\n    max = ar[i];\n\n}\n\n", "pragma": "omp parallel for reduction(max: max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patilanurag/OpenMP/Reduction/0"}
{"code": "for (j = 1, nerrs = 0, derr = 0.0; j <= n; j++)\n{\n  for (i = 1; i <= m; i++)\n  {\n    if (C[((j - 1) * ldc) + (i - 1)] >= D[((j - 1) * ldc) + (i - 1)])\n    {\n      ctmp = C[((j - 1) * ldc) + (i - 1)] - D[((j - 1) * ldc) + (i - 1)];\n    }\n    else\n    {\n      ctmp = D[((j - 1) * ldc) + (i - 1)] - C[((j - 1) * ldc) + (i - 1)];\n    }\n\n    derr += ctmp;\n    if (fabs(ctmp) > 0.000000001)\n    {\n      if (((++nerrs) < 10) && (j <= 10))\n      {\n        printf(\"Node %d: Error at C(%d,%d): Act=%g Comp=%g Err=%g Tot=%g\\n\", me, i, j, D[((j - 1) * ldc) + (i - 1)], C[((j - 1) * ldc) + (i - 1)], ctmp, derr);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/8"}
{"code": "for (int j = 0; j < array_length; j++)\n{\n  sum += array[j];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ciarancourtney/concurrent_openmp_opencl_examples/openmp_array_reduce/0"}
{"code": "for (;;)\n{\n  mincos = 2;\n  for (int i = 0; i < s; i++)\n  {\n    cosine = roundFloat(turnPoint(last, beforelast, finale_local[i]) * INFINITE) / INFINITE;\n    if (cosine < mincos)\n    {\n      minind = i;\n      mincos = cosine;\n      maxlen = betweenPoints(last, finale_local[i]);\n    }\n\n    if (cosine == mincos)\n    {\n      len = betweenPoints(last, finale_local[i]);\n      if (len > maxlen)\n      {\n        minind = i;\n        maxlen = len;\n      }\n\n    }\n\n  }\n\n  beforelast = last;\n  last = finale_local[minind];\n  if (last == finale_local[m])\n    break;\n\n  result.push_back(finale_local[minind]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ysph/parallel-stuff/b_omp/convex_hull/7"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  val = i;\n}\n\n", "pragma": "#pragma omp parallel for lastprivate(val)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jablub/chpc_omp/samples/src/lastprivate/0"}
{"code": "for (int i = 0; i < y.size(); i++)\n{\n  y.data()[i] = y.data()[i] + (alpha * x.data()[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/blas/axpy/7"}
{"code": "for (unsigned int i = 0; i < dimFactorVector.size(); ++i)\n{\n  shrinkDimensionality(iter_no);\n  dimFactorVector[i] = dimFactors;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/0"}
{"code": "for (int i = 0; i < 10000000; i++)\n  if (z_oracle[i] != z_v_add[i])\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kishkaru/OpenMP_Demos/OpenMP/vadd_OmpFor/3"}
{"code": "for (unsigned int elem_index = 0; elem_index < obj_dot_x.vector_dimension; elem_index++)\n{\n  result_dot_prod += obj_dot_x.values[elem_index] * obj_dot_y.values[elem_index];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:result_dot_prod)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shreyas-Gururaj/HPC_PNLA_Library_OpenMP/src/vector_omp/4"}
{"code": "for (size_t element = 0; element < _numberOfAverages; element++)\n  _averagesVector.push_back(Average(dimensionality, iterations));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariodematties/MPI_Tests/Set/0"}
{"code": "for (int index = (width * height) - 1; index >= 0; --index)\n{\n  if (!distance_is_close_8u_C3R(image_data[3 * index], image_data[(3 * index) + 1], image_data[(3 * index) + 2], first[3 * index], first[(3 * index) + 1], first[(3 * index) + 2], matchingThreshold))\n    segmentation_map[index] = matchingNumber;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learn-computer-graphics/code-optimization/src/tp-2/vibe-background-sequential/11"}
{"code": "for (i = 2; i <= n; i++)\n{\n  primo = 1;\n  for (j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n    {\n      primo = 0;\n      break;\n    }\n\n  }\n\n  total = total + primo;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/Calculo-Numeros-Primos/main/0"}
{"code": "for (int t = 0; t < numDivs; t++)\n  *(LL + t) = log(dataParamDLL.Dividers.at(t));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/4"}
{"code": "for (int i = 0; i < (*tasks); i++)\n{\n  options[i] = malloc((*level) * (sizeof(int)));\n  for (int j = 0; j < (*level); j++)\n  {\n    if (fscanf(cp, \"%d \", &options[i][j]) != 1)\n    {\n      err(1, \"Erreur de lecture du fichier %s\", cp_filename);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/24"}
{"code": "for (i = 0; i < NoofCols; i = i + 1)\n{\n  for (j = 0; j < NoofRows; j = j + 1)\n    printf(\"%d \\t\", Trans[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PavlyukVadim/software-engineering/Parallel/OpenMP/main/2"}
{"code": "for (l = 0; l < N; l++)\n{\n  s1 = func[k][0];\n  s1 = s1 + (a[k][l] * xend[l][0]);\n  func[k][0] = s1;\n}\n\n", "pragma": "omp parallel for reduction(+:s1)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jainpranav/OpenMP_Fun/Project2/matrix/3"}
{"code": "for (unsigned int i = 0; i < a.size(); i++)\n{\n  v[b[i]].species = v[a[i]].species;\n  v[b[i]].tempstring = v[a[i]].binarystring;\n  v[b[i]].tempscore = v[a[i]].score;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c6/7"}
{"code": "for (x = 0; x < chunk_num; x++)\n{\n  pageRankCorrelationStats = collectStatsPageRank_topK(ref_stats, stats, ref_rankedVertices_total, ref_rankedVertices_inverse, rankedVertices_inverse, chunk_x, ref_stats->num_vertices - (chunk_x * x), fptr, 0);\n  pageRankCorrelationStatsSum.levenshtein_distance += pageRankCorrelationStats.levenshtein_distance;\n  pageRankCorrelationStatsSum.float_Kendall += pageRankCorrelationStats.float_Kendall;\n  pageRankCorrelationStatsSum.real_Kendall += pageRankCorrelationStats.real_Kendall;\n  pageRankCorrelationStatsSum.intersection += pageRankCorrelationStats.intersection;\n  pageRankCorrelationStatsSum.mismatch += pageRankCorrelationStats.mismatch;\n  pageRankCorrelationStatsSum.avg_error_float += pageRankCorrelationStats.avg_error_float;\n  pageRankCorrelationStatsSum.avg_error_relative += pageRankCorrelationStats.avg_error_relative;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/34"}
{"code": "for (size_t i = 0; i < src_coord.size(); i++)\n  src_coord[i] *= b;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashb/tbslas/src/applications/src/kernel_tst/0"}
{"code": "for (int i = 0; i < nProj; i++)\n  h_pDetAngle[i] = (-2.1) + ((i * 4.2) / nProj);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/16"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((x & mask) != 0)\n  {\n    result++;\n  }\n\n  mask = mask * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NateWichman/OpenMP_Max_Indy_Set/DominatingSet/1"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  double x = (i + .5) * step;\n  sum = sum + (4.0 / (1. + (x * x)));\n}\n\n", "pragma": "#pragma omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ptylczynski/parallel-processing/1PR141331/code/parallel_reduction_pi/0"}
{"code": "for (int i = 0; i < omp_get_num_threads(); i++)\n{\n  val = omp_get_thread_num();\n}\n\n", "pragma": "omp parallel for lastprivate(val)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rookiehpc/rookiehpc.github.io/openmp/docs/lastprivate/example_1/0"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"/ V1[%d]+V2[%d]=V3[%d](%8.6f+%8.6f=%8.6f) /\\n\", i, i, i, v1[i], v2[i], v3[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P1/7/SumaVectoresC-parallel/2"}
{"code": "for (int i = 0; i < ((x2 - x1) + 1); i++)\n{\n  for (int j = 0; j < ((y2 - y1) + 1); j++)\n  {\n    slice[i][j] = Mat[x1 + i][y1 + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thesaurabhkumar/ParallelInverseUpperTriangleMatrixOpenMP/inverse/3"}
{"code": "for (k = 1; k < (MAX_VARS_PER_NODE - 2); k++)\n{\n  for (int i = 1; i <= NLon; i++)\n  {\n    for (int j = 1; j <= NLat; j++)\n    {\n      Node(idx(j, i), k) = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    scanf(\"%d\", &g[i][j]);\n    if (g[i][j] == 0)\n      g[i][j] = 0x3f3f3f3f;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/FastDPComputing/main/1"}
{"code": "for (int i = 0; i < (height + 2); i++)\n{\n  for (int j = 0; j < (width + 2); j++)\n  {\n    if ((((i == 0) || (i == (height + 1))) || (j == 0)) || (j == (width + 1)))\n      array[(i * (width + 2)) + j] = 0;\n    else\n      array[(i * (width + 2)) + j] = rand() % 256;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeorgeMitrakis/raw_image_blur/project_hybrid/0"}
{"code": "for (j = 0; j < size; j++)\n{\n  sum += buffer[j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timbo-rafa/parallel_programming/prodcons/prod_cons_paralelo/1"}
{"code": "for (i = 0; i < (avg + 2); i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    if ((((i == (row - 1)) || (i == 0)) || (j == 0)) || (j == (col - 1)))\n      out[(i * col) + j] = in[(i * col) + j];\n    else\n    {\n      sum_kernal = ((((((((kernal[8] * in[((i - 1) * col) + (j - 1)]) + (kernal[7] * in[(i * col) + (j - 1)])) + (kernal[6] * in[((i + 1) * col) + (j - 1)])) + (kernal[5] * in[((i - 1) * col) + j])) + (kernal[4] * in[(i * col) + j])) + (kernal[3] * in[((i + 1) * col) + j])) + (kernal[2] * in[((i - 1) * col) + (j + 1)])) + (kernal[1] * in[(i * col) + (j + 1)])) + (kernal[0] * in[((i + 1) * col) + (j + 1)]);\n      out[(i * col) + j] = sum_kernal / total_kernal;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) num_threads(t) private(sum_kernal,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/exam_final/final/0"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  s = a[i];\n  r = b[i];\n  t = a[i] * b[i];\n  printf(\"%d \", r);\n  printf(\" * %d \", s);\n  printf(\" = %d \\n\", t);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pierorex/parallelism-homework/practica6/e5/0"}
{"code": "for (int i = nbthreads * granularity; i < n; i++)\n{\n  pr[i + 1] = pr[i] + arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkalyanpurr/openMP/prefixsum/prefixsum/1"}
{"code": "for (i = 1; (i < n) && sort; i++)\n  if (data[i] < data[i - 1])\n  sort = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Count-Sort/count/3"}
{"code": "for (i = 0; i < nColumns; i++)\n{\n  nTotalZero += cM->nZero[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mapa17/teacup/teacup_tools/13"}
{"code": "for (i = 0; i < 5; i++)\n{\n  row_sum = 0;\n  for (j = 0; j < 2; j++)\n  {\n    row_sum += (*((array + (i * 2)) + j)) * (*(vector + j));\n  }\n\n  result[i] = row_sum;\n}\n\n", "pragma": "omp parallel for private(i, j, row_sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1b_MatrixVectorMult_OpenMP_approach2/0"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  pageRankCorrelationStats = collectStatsPageRank_topK(ref_stats, stats, ref_rankedVertices_total, ref_rankedVertices_inverse, rankedVertices_inverse, topK_array[x], ref_stats->num_vertices, fptr, 0);\n  pageRankCorrelationStats_array[x] = pageRankCorrelationStats;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/17"}
{"code": "for (size_t i = 0; i < N; ++i)\n  C[i] = exp(Comp(0, w * Real(i * i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shuibitianantian/Arbitrary-FFT/openmp/fft/3"}
{"code": "for (int i = 0; i < number_of_elements; i++)\n{\n  mListOfSphericContinuumParticles[i]->SetSearchRadius((amplification * mListOfSphericContinuumParticles[i]->mLocalRadiusAmplificationFactor) * (added_search_distance + mListOfSphericContinuumParticles[i]->GetRadius()));\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/9"}
{"code": "for (i = startwave; i <= stopwave; i++)\n{\n  g_real[i] = (hotreal[i] - coldreal[i]) / (bbhot[i] - bbcold[i]);\n  g_im[i] = (hotimag[i] - coldimag[i]) / (bbhot[i] - bbcold[i]);\n  off_real[i] = ((bbhot[i] * coldreal[i]) - (bbcold[i] * hotreal[i])) / (bbhot[i] - bbcold[i]);\n  off_im[i] = ((bbhot[i] * coldimag[i]) - (bbcold[i] * hotimag[i])) / (bbhot[i] - bbcold[i]);\n  scene_rad[i] = sqrt(pow(scenereal[i] - off_real[i], 2.) + pow(sceneimag[i] - off_im[i], 2.)) / sqrt((g_real[i] * g_real[i]) + (g_im[i] * g_im[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/10"}
{"code": "for (i = 0; i < num_rownnz; i++)\n{\n  m = A_rownnz[i];\n  tempx = y_data[m];\n  for (jj = A_i[m]; jj < A_i[m + 1]; jj++)\n    tempx += A_data[jj] * x_data[A_j[jj]];\n\n  y_data[m] = tempx;\n}\n\n", "pragma": "omp parallel for private(tempx, m, jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiangmoquan/OpenMP-Parallel-Programming-Assignment-/amgmk/csr_matvec/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (a[i] > localmax)\n    localmax = a[i];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/find_max/1"}
{"code": "for (int i = 0; i < num_nodes; i++)\n{\n  for (int j = 0; j < num_nodes; j++)\n  {\n    if (fscanf(data_file, \"%d\", &temp) == EOF)\n    {\n      break;\n    }\n    else\n    {\n      if (i == j)\n      {\n        nodes_distance[i][j] = 0;\n      }\n      else\n      {\n        nodes_distance[i][j] = temp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/intesar-gist/floyd_warshall_openmp/floyd_warshall_openmp/4"}
{"code": "for (int j = 0; j < this->input_neurons; j++)\n{\n  float result = 0.0f;\n  for (int k = 0; k < this->output_neurons; k++)\n  {\n    result += (*(per_batch_gradient + k)) * (*((w_t + (k * this->input_neurons)) + j));\n  }\n\n  *((this->dldW + (i * this->input_neurons)) + j) = result;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/Linear Layer - ANN/Linear/5"}
{"code": "for (int x_pixel = 0; x_pixel < nb_pixel_x; x_pixel++)\n{\n  for (int y_pixel = 0; y_pixel < nb_pixel_y; y_pixel++)\n  {\n    double x = (-2) + (x_pixel * 0.001);\n    double y = (-2) + (y_pixel * 0.001);\n    fprintf(output_file, \"%f %f %d\\n\", x, y, iter_tab[(x_pixel * nb_pixel_y) + y_pixel]);\n  }\n\n  fprintf(output_file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/logarithm27/Mandelbrot_Fractal_Set_Parallelism/mandelbrot_open_mp/1"}
{"code": "for (i = 0; i < omp_get_num_threads(); i++)\n  somas[omp_get_thread_num()] = somaLinhaMatriz(M, omp_get_thread_num());\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabriellramos/lista-openmp-concorrente/q5/0"}
{"code": "for (j = 0; j < height; ++j)\n{\n  for (i = 0; i < width; ++i)\n  {\n    double y0 = (j * ((upper - lower) / height)) + lower;\n    double x0 = (i * ((right - left) / width)) + left;\n    int repeats = 0;\n    double x = 0;\n    double y = 0;\n    double length_squared = 0;\n    while ((repeats < 100000) && (length_squared < 4))\n    {\n      double temp = ((x * x) - (y * y)) + x0;\n      y = ((2 * x) * y) + y0;\n      x = temp;\n      length_squared = (x * x) + (y * y);\n      ++repeats;\n    }\n\n    image[(j * width) + i] = repeats;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aalty/MPI-OpenMP-Mandlebrot-Set/ms_omp/1"}
{"code": "for (i = 0; i < 8; i += 2)\n{\n  stop = 0;\n  a = x + D[i][0];\n  b = y + D[i][1];\n  while (((((!stop) && (a >= 0)) && (a <= 7)) && (b >= 0)) && (b <= 7))\n  {\n    if (conf.mat[a][b] > 0)\n      stop = 1;\n    else\n    {\n      copier(&conf, &T[*n]);\n      T[*n].mat[x][y] = 0;\n      if (T[*n].mat[a][b] < 0)\n        stop = 1;\n\n      T[*n].mat[a][b] = 't';\n      if ((T[*n].xrN == a) && (T[*n].yrN == b))\n      {\n        T[*n].xrN = -1;\n        T[*n].yrN = -1;\n      }\n\n      if ((conf.roqueB != 'e') && (conf.roqueB != 'n'))\n      {\n        if (((x == 0) && (y == 0)) && (conf.roqueB != 'p'))\n          T[*n].roqueB = 'g';\n        else\n          if ((x == 0) && (y == 0))\n          T[*n].roqueB = 'n';\n\n\n        if (((x == 0) && (y == 7)) && (conf.roqueB != 'g'))\n          T[*n].roqueB = 'p';\n        else\n          if ((x == 0) && (y == 7))\n          T[*n].roqueB = 'n';\n\n\n      }\n\n      (*n)++;\n      a = a + D[i][0];\n      b = b + D[i][1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/15"}
{"code": "for (i = 0; i < 4096; i++)\n  for (j = 0; j < 4096; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc/matmult-toy/matmult-toy/2"}
{"code": "for (i = 1; i <= N; i++)\n{\n  for (j = 1; j <= N; j += 2)\n  {\n    if ((i % 2) == 0)\n      x = ((i * M) + j) + 1;\n    else\n      x = (i * M) + j;\n\n    u[x] = 0.25 * ((((hsq + u[x - M]) + u[x - 1]) + u[x + 1]) + u[x + M]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(M,N,u,hsq) private(i,j,x) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/churia/HPC-OpenMP/gs2D-omp/2"}
{"code": "for (int i = 0; i < row_num_blocks; ++i)\n{\n  for (int j = 0; j < col_num_blocks; ++j)\n  {\n    this->ExtractSubMatrix(row_offset[i], col_offset[j], row_offset[i + 1] - row_offset[i], col_offset[j + 1] - col_offset[j], mat[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/local_matrix/0"}
{"code": "for (unsigned int j = 0; j < sz; j++)\n{\n  encodedBlockBuffer.get()[idx].cr.encoded[j].encoded = (*encodedBlock->cr->encoded.get())[j].encoded;\n  encodedBlockBuffer.get()[idx].cr.encoded[j].count = (*encodedBlock->cr->encoded.get())[j].count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spenceryu/15618-final-project/src/rle/3"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  virtualCenters[allProducts[i].clusterId].numOfProducts++;\n  for (j = 0; j < dimensions; j++)\n  {\n    virtualCenters[allProducts[i].clusterId].virutalCenter.coordinates[j] += allProducts[i].coordinates[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/14"}
{"code": "for (int i = 0; i < size_matrix; i++)\n{\n  int adder = 0;\n  for (int j = 0; j < size_matrix; j++)\n  {\n    adder += matrix_A[i][j] * matrix_B[j][a];\n  }\n\n  matrix_Out[i][a] = adder;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/1"}
{"code": "for (int i = 0; i < LIMIT; i++)\n{\n  printf(\"%u \", array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/omp1/1"}
{"code": "for (int i = 0; i < (*aNumberOfCentroids); i++)\n{\n  double dist = sqrt(pow((*aPoint).mX - aCentroids[i].mX, 2) + pow((*aPoint).mY - aCentroids[i].mY, 2));\n  if (dist < (*aPoint).mDistnceToCenter)\n  {\n    (*aPoint).mDistnceToCenter = dist;\n    (*aPoint).mCentroidId = aCentroids[i].mId;\n    return true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/3"}
{"code": "for (int i = start_iter_index; i <= end_iter_index; i++)\n{\n  permutation[i] = i;\n  for (int j = 0; j < MATRIX_SIZE; j++)\n  {\n    drand48_r(&buffer, &mat[i][j]);\n    mat[i][j] *= 1000;\n    mat_dup[i][j] = mat[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivamshuklama/Parallelization-of-LU-DECOMPOSITION/lupthread/seqpthread/6"}
{"code": "for (int i = 0; i < nLinks; i++)\n{\n  Links[i] = false;\n  omp_init_lock(&Locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elena1905/ParallelIsingModel/src/worm/two_threads/Worm/0"}
{"code": "for (x = 0; x < width; ++x)\n{\n  ray = camera->ComputeRay(x, y);\n  finalColor = traceRay(ray, 0).ToRange();\n  pFrameBuf->SetPixel(x, y, finalColor);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for private(x, ray, finalColor) schedule(dynamic, chunkSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnoazx005/RTRender/RTRender/source/impls/RTOpenMPRayTracer/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    C[(i * SIZE) + j] = 0.0;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      C[(i * SIZE) + j] += A[(i * SIZE) + k] * B[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/2MM/2mm/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  box_counter++;\n  box[box_counter - 1].level = cube.level + 1;\n  box[box_counter - 1].boxid = box_counter;\n  box[box_counter - 1].parent = cube.boxid;\n  box[box_counter - 1].length = cube.length / 2;\n  box[box_counter - 1].n = 0;\n  box[box_counter - 1].child_index = i;\n  box[cube.boxid - 1].child[i] = box_counter;\n  box[box_counter - 1].colleague_counter = 0;\n  for (j = 0; j < 26; j++)\n  {\n    box[box_counter - 1].colleague[j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikos912000/octree-partitioning/octree_openmp/octree_openmp/7"}
{"code": "for (x = 0; x < (PROBLEMSIZE + 2); x++)\n{\n  for (y = 0; y < (PROBLEMSIZE + 2); y++)\n  {\n    if ((((x >= 1) && (x <= PROBLEMSIZE)) && (y >= 1)) && (y <= PROBLEMSIZE))\n    {\n      cur_gen[x][y] = rand() % 2;\n      next_gen[x][y] = 0;\n    }\n    else\n    {\n      cur_gen[x][y] = 0;\n      next_gen[x][y] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nilayladke/Game-Of-Life-Project/omp/1"}
{"code": "for (;;)\n{\n  setPixelRed(imgPPM, y, x);\n  if ((x == xe) && (y == ye))\n    break;\n\n  e2 = 2 * err;\n  if (e2 >= dy)\n  {\n    err += dy;\n    x += sx;\n  }\n\n  if (e2 <= dx)\n  {\n    err += dx;\n    y += sy;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/image_utility/2"}
{"code": "for (int j = i + 1; j < N; j++)\n{\n  U[i][j] = A[i][j] - sum_i_j_K(i, j, i);\n  L[j][i] = (A[j][i] - sum_i_j_K(j, i, i)) / U[i][i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NJU-TJL/OpenMP-MPI_Labs/Lab02/OpenMP/LU_OpenMP/0"}
{"code": "for (ivelt = 0; ivelt < nzv; ivelt++)\n{\n  acol[iouter][ivelt] = ivc[ivelt] - 1;\n  aelt[iouter][ivelt] = vc[ivelt];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lovenery/conjugate-gradient-openmp/cg/3"}
{"code": "for (int q = j + 1; q < numOfPoints; q++)\n{\n  if (allPoints[j].clusterId == allPoints[q].clusterId)\n  {\n    double distance = sqrt(pow(allPoints[q].x - allPoints[j].x, 2) + pow(allPoints[q].y - allPoints[j].y, 2));\n    if (allClusters[allPoints[j].clusterId].diameter < distance)\n    {\n      allClusters[allPoints[j].clusterId].diameter = distance;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(dynamic,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/Cluster/1"}
{"code": "for (int d = 0; d < size; d++)\n{\n  ((cout << \"Chromosome no. \") << d) << \" with gene permutation as \";\n  for (int j = 0; j < num; j++)\n  {\n    cout << a[d].gene[j].city_id;\n  }\n\n  ((cout << \" with distance \") << a[d].distance) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prachi220/Parallel-Programming/Travelling Salesman Problem/tsp_2014CS50289/2"}
{"code": "for (int i = 0; i < nx; i++)\n  for (int k = 0; k < nz; k++)\n{\n  vectorX[i][0][k] = vectorX[i][4][k];\n  vectorY[i][0][k] = vectorY[i][4][k];\n  vectorZ[i][0][k] = vectorZ[i][4][k];\n  vectorX[i][1][k] = vectorX[i][4][k];\n  vectorY[i][1][k] = vectorY[i][4][k];\n  vectorZ[i][1][k] = vectorZ[i][4][k];\n  vectorX[i][2][k] = vectorX[i][4][k];\n  vectorY[i][2][k] = vectorY[i][4][k];\n  vectorZ[i][2][k] = vectorZ[i][4][k];\n  vectorX[i][3][k] = vectorX[i][4][k];\n  vectorY[i][3][k] = vectorY[i][4][k];\n  vectorZ[i][3][k] = vectorZ[i][4][k];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/108"}
{"code": "for (int iz = 1; iz < (nz - 1); iz++)\n{\n  vector[0][0][iz] = vector[nx - 2][0][iz];\n  vector[nx - 1][0][iz] = vector[1][0][iz];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/7"}
{"code": "for (int i = 0; i < r; i++)\n{\n  a[i] = (int *) malloc(r * (sizeof(int)));\n  b[i] = (int *) malloc(r * (sizeof(int)));\n  mul[i] = (int *) malloc(r * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ajit-Kumar/Concurrent_Programming/matrix/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp49xe89rq.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmnpatel/openmp-rpc-offloading/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (chunk = 0; chunk < num_chunk; ++chunk)\n{\n  r = chunk / col;\n  c = chunk % col;\n  if ((((r == 0) || (c == 0)) || ((r + 1) == row)) || ((c + 1) == col))\n  {\n    if ((r == 0) && (c == 0))\n    {\n      delta = Cap_1 * (((power[0] + ((temp[1] - temp[0]) * Rx_1)) + ((temp[col] - temp[0]) * Ry_1)) + ((amb_temp - temp[0]) * Rz_1));\n    }\n    else\n      if ((r == 0) && (c == (col - 1)))\n    {\n      delta = Cap_1 * (((power[c] + ((temp[c - 1] - temp[c]) * Rx_1)) + ((temp[c + col] - temp[c]) * Ry_1)) + ((amb_temp - temp[c]) * Rz_1));\n    }\n    else\n      if ((r == (row - 1)) && (c == (col - 1)))\n    {\n      delta = Cap_1 * (((power[(r * col) + c] + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) * Rx_1)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) * Ry_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n    }\n    else\n      if ((r == (row - 1)) && (c == 0))\n    {\n      delta = Cap_1 * (((power[r * col] + ((temp[(r * col) + 1] - temp[r * col]) * Rx_1)) + ((temp[(r - 1) * col] - temp[r * col]) * Ry_1)) + ((amb_temp - temp[r * col]) * Rz_1));\n    }\n    else\n      if (r == 0)\n    {\n      delta = Cap_1 * (((power[c] + (((temp[c + 1] + temp[c - 1]) - (2.0 * temp[c])) * Rx_1)) + ((temp[col + c] - temp[c]) * Ry_1)) + ((amb_temp - temp[c]) * Rz_1));\n    }\n    else\n      if (c == (col - 1))\n    {\n      delta = Cap_1 * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.0 * temp[(r * col) + c])) * Ry_1)) + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) * Rx_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n    }\n    else\n      if (r == (row - 1))\n    {\n      delta = Cap_1 * (((power[(r * col) + c] + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.0 * temp[(r * col) + c])) * Rx_1)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) * Ry_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1));\n    }\n    else\n      if (c == 0)\n    {\n      delta = Cap_1 * (((power[r * col] + (((temp[(r + 1) * col] + temp[(r - 1) * col]) - (2.0 * temp[r * col])) * Ry_1)) + ((temp[(r * col) + 1] - temp[r * col]) * Rx_1)) + ((amb_temp - temp[r * col]) * Rz_1));\n    }\n\n\n\n\n\n\n\n\n    result[(r * col) + c] = temp[(r * col) + c] + delta;\n  }\n  else\n  {\n    result[(r * col) + c] = temp[(r * col) + c] + (Cap_1 * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.f * temp[(r * col) + c])) * Ry_1)) + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.f * temp[(r * col) + c])) * Rx_1)) + ((amb_temp - temp[(r * col) + c]) * Rz_1)));\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/hotspot/hotspot_openmp/0"}
{"code": "for (int expo = 0; expo < 32; expo++)\n  countSortNonParallel(arr, n, 1 << expo);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/radix_sort/6"}
{"code": "for (;;)\n{\n  z++;\n  {\n    int x = 11;\n    x++;\n  }\n  z = x - 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/src/imop/lib/testcases/simplification/scoping/0"}
{"code": "for (int id = start; id < end; id++)\n{\n  int src = inwl.getItem(id);\n  int row_begin = row_offsets[src];\n  int row_end = row_offsets[src + 1];\n  for (int offset = row_begin; offset < row_end; offset++)\n  {\n    int dst = column_indices[offset];\n    if ((src < dst) && (colors[src] == colors[dst]))\n    {\n      outwl.push(src);\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/vc/omp_target/1"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  for (j = 0; j < NCB; j++)\n    printf(\"%6.2f   \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/MatrixMultiply/4"}
{"code": "for (i = 0; i < num_nodes; ++i)\n{\n  printf(\"%4c\", 'A' + i);\n  for (j = 0; j < num_nodes; ++j)\n  {\n    printf(\"%4d\", nodes_distance[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/intesar-gist/floyd_warshall_openmp/floyd_warshall_openmp/2"}
{"code": "for (i = 0; i < 64; i++)\n  if (b[i] != (i + ((i == y) ? ((31 * 32) / 2) : (0))))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/target-35/6"}
{"code": "for (int i = 0; i < num_output_channels; i++)\n{\n  output_buffer[i].resize(num_output_samples);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tristanelma/reverb_parallelization/project/impulse_parallel/0"}
{"code": "for (k = 0; k < nn; k++)\n{\n  MX3[k] = 0;\n  for (l = 1; l <= count[k]; l++)\n  {\n    MX2[i] = tja[k][l];\n    i++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXsetup/3"}
{"code": "for (int i = 1; i < NUM_PI; i++)\n{\n  sendsum += sendsize[i - 1];\n  MPI_Recv(outmsg_ll[0] + sendsum, sendsize[i], MPI_LONG_LONG, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n  MPI_Recv(&elapsedtime[i], 1, MPI_DOUBLE, i, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ReinhartC/Parallel-RSA-on-Raspberry-Pi/Builds/LB_OMP_MPI/RSA_LB_OMP_MPI/6"}
{"code": "for (i = 0; i < ((nx * ny) * nz); ++i)\n{\n  if ((i + activate) % 1)\n  {\n    rb[i] = 'r';\n  }\n  else\n  {\n    rb[i] = 'b';\n  }\n\n  if (0 == ((i + 1) % (nx * ny)))\n    ++activate;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilmerhenao/Poisson-OpenMP/serial_hw2/8"}
{"code": "for (int i = 0; i < (number_bacteria - 1); i++)\n  for (int j = i + 1; j < number_bacteria; j++)\n{\n  double correlation = CompareBacteria(b[i], b[j]);\n  correlations[i][j] = correlation;\n  printf(\"%2d %2d -> %.20lf\\n\", i, j, correlation);\n}\n\n\n", "pragma": "\t#pragma omp parallel for collapse(2) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AshCott/CVTree-Parallelisation-Project/CVtree_Parallelisation_Project/cvtree_Parallelisation_Project/0"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  mat_normalize(mats[m], tmp, MAT_NORM_2, rinfo, thds, nthreads);\n  for (idx_t f = 0; f < nfactors; ++f)\n  {\n    lambda[f] *= tmp[f];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/cpd/13"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/6"}
{"code": "for (int i = 0; i < threads; i++)\n  p2 += P2_OpenMP_thread(x, y, z, thread_distance, i, low, prime_sums[i], correct[i]);\n\n", "pragma": "    #pragma omp parallel for num_threads(threads) reduction(+: p2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primesum/src/P2/0"}
{"code": "for (int var = 0; var < quesAfterDup.size(); var++)\n{\n  for (int var2 = 0; var2 < quesAfterDup[var].size(); var2++)\n  {\n    if (quesAfterDup[var].at(var2).getTId() == task)\n    {\n      lastTask = quesAfterDup[var].at(var2);\n      lastEndTime = quesAfterDup[var].at(var2).getEndtime();\n      if (lastEndTime <= minEndTime)\n      {\n        minEndTime = lastEndTime;\n        minTask = lastTask;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/SeqGeneticAlgo/src/SeqGeneticAlgo/2"}
{"code": "for (int row = 0; row < n; row++)\n  if (degree[row] < degree[perm[0]])\n  perm[0] = row;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manolismih/sparseMatPerm/parallel/4"}
{"code": "for (size_t i = 0; i != count; ++i)\n{\n  rx[i] = vrt[i].x;\n  ry[i] = vrt[i].y;\n  rz[i] = vrt[i].z;\n  vx[i] = vel[i].x;\n  vy[i] = vel[i].y;\n  vz[i] = vel[i].z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_cuda/0"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    soundspeed[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = soundspeed[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/25"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  dest_num = i % comm_size;\n  if (dest_num == MASTER_PROC_RANK)\n  {\n    master_seq_nums[tmp_i++] = i;\n    continue;\n  }\n\n  MPI_Send(m_arrays[i], command_line_args.seq_len, MPI_DOUBLE, dest_num, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/5"}
{"code": "for (int i = 0; i < ts.ROWS; i++)\n{\n  meanY += signal[i];\n}\n\n", "pragma": "omp parallel for reduction(+: meanY)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mwilchek/HPC-Examples/Project_1/Get_Stats/src/get_stats_for/1"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    POPULATION[i][j] = NEW_POPULATION[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/5. N queens problem/Queens4/Queens4.0/1"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/106"}
{"code": "for (tid = 0; tid < total_threads; tid++)\n  sum += valid_collisions;\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlexKasapis/OpenMP/Examine/0"}
{"code": "for (int i = 0; i < threadNum; i++)\n{\n  threads[i].join();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hd-zhao-uu/PedestrianSimulation/libpedsim/ped_model/2"}
{"code": "for (int col = 0; col < width; col++)\n{\n  result[(row * width) + col] += a[(row * widthA) + i] * b[(i * width) + col];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/epoell/openMP_examples_and_Matrix-Matrix-Multiplication/matmult_parallel/3"}
{"code": "for (i = 0; i < (p7 + 4); i++)\n{\n  if (i < p7)\n    b[i] = -6;\n\n  a[i].t = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/reduction-10/1"}
{"code": "for (lev = 0; lev < nlev; lev++)\n{\n  relax_parallel(phi[lev], res[lev], lev, n_per_lev, p);\n  proj_res_parallel(res[lev + 1], res[lev], phi[lev], lev, p);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/parallel_mg/11"}
{"code": "for (i = 0; i < n; ++i)\n{\n  (((cout << \"Num_threads: \") << omp_get_num_threads()) << \" Thread: \") << omp_get_thread_num();\n  ((cout << \" Iteration: \") << i) << endl;\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/12"}
{"code": "for (int i = 0; i < ans.size(); i++)\n{\n  ans[i] = vec1[i] + vec2[i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector/add/0"}
{"code": "for (i2 = 0; i2 < n2; i2++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    z[i3][i2][i1] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(n3 ,i1 ,z ,n1 ,n2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/MG/mg/8"}
{"code": "for (int i = 0; i < 100000; ++i)\n  total += (3 * i) * i;\n\n", "pragma": "omp for schedule(dynamic) reduction(+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonibofarull/mini-openmp/miniomp/test/tfinal/1"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  printf(\"i=%d processed by thread=%d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/paralelodev/openmp_examples_in_c/prueba-000/0"}
{"code": "for (k = 0; k < 200; k++)\n{\n  for (i = 0; i < rows; i++)\n  {\n    c[i][k] = 0.0;\n    for (j = 0; j < 250; j++)\n    {\n      c[i][k] = c[i][k] + (a[i][j] * b[j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wahmingchen/parallel-computing/matrix_multiplication_with_MPI/mpi_mm/0"}
{"code": "for (i = n - 11; i < n; i++)\n{\n  printf(\"  %8d  %14.6g\\n\", i, x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/jacobi/7"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    fprintf(outFile, \"%f %f %f\\n\", h * i, h * j, unew[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jzuhusky/HPC_Homework2/gs2D-omp/5"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (j = 1 * 3; j <= ((grid_points[1] - (3 * 1)) - 1); j++)\n  {\n    forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * ((((ue[j - 2][m] - (4.0 * ue[j - 1][m])) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/7"}
{"code": "for (int i = 0; i < v.size(); i++)\n{\n  for (int j = 0; j < v[0].size(); j++)\n    (cout << v[i][j]) << ' ';\n\n  cout << '\\n';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SingularityUrBrain/computer-architecture-labs/sem5/lab3/openmp/0"}
{"code": "for (j = 1; j < numOfProcs; j++)\n{\n  MPI_Recv(bufferClusters, numOfClusters, ClusterMPIType, j, 0, MPI_COMM_WORLD, &status);\n  for (int k = 0; k < numOfClusters; k++)\n  {\n    allClusters[k].clusterSize += bufferClusters[k].clusterSize;\n    allClusters[k].x += bufferClusters[k].x;\n    allClusters[k].x /= 2;\n    allClusters[k].y += bufferClusters[k].y;\n    allClusters[k].y /= 2;\n    allClusters[k].z += bufferClusters[k].z;\n    allClusters[k].z /= 2;\n    if (allClusters[k].diameter < bufferClusters[k].diameter)\n    {\n      allClusters[k].diameter = bufferClusters[k].diameter;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/1"}
{"code": "for (i = 1; i < (268 - 1); i++)\n  for (j = 1; j < (268 - 1); j++)\n  error = (error > fabs(solution[i][j] - x[i][j])) ? (error) : (fabs(solution[i][j] - x[i][j]));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_jacobi/sor_jacobi_par/5"}
{"code": "for (i = 1; i <= m; i++)\n  s[m * i] = s[m * (i - 1)] + levenshtein(a[i - 1], 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/2"}
{"code": "for (int i = 0; i < message.size(); i++)\n  messageArr[i % nthreads] += message[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MeetSable/Huffman-encoding-and-Adaptive-Huffman-encoding-OpenMP/adaptiveHuffman/2"}
{"code": "for (int id = 0; id < (sizepernode * NODE_N); id++)\n  D_localscore[id] = 0.f;\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/0"}
{"code": "for (int i = 1; i < (nxn - 1); i++)\n  for (int k = 1; k < (nzn - 1); k++)\n{\n  rhons[is][i][1][k] *= 2;\n  Jxs[is][i][1][k] *= 2;\n  Jys[is][i][1][k] *= 2;\n  Jzs[is][i][1][k] *= 2;\n  pXXsn[is][i][1][k] *= 2;\n  pXYsn[is][i][1][k] *= 2;\n  pXZsn[is][i][1][k] *= 2;\n  pYYsn[is][i][1][k] *= 2;\n  pYZsn[is][i][1][k] *= 2;\n  pZZsn[is][i][1][k] *= 2;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/35"}
{"code": "for (int i = 0; i < (cells_per_side * cells_per_side); i++)\n{\n  for (int k = 0; k < MAX_PARTICLES_PER_CELL; k++)\n  {\n    cells[i].particles[k] = -1;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vjeganat/MD_simulations/Openmp_neighbor_lists/openmp/2"}
{"code": "for (j = p; j < r; ++j)\n{\n  b[j - p] = *(a + j);\n  if ((*(a + j)) < key)\n  {\n    lt[j - p] = 1;\n    gt[j - p] = 0;\n  }\n  else\n  {\n    lt[j - p] = 0;\n    gt[j - p] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham-gaur/OpenMP/Quick Sort/main/0"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  asum += fabsf(x[i]);\n  asum += fabsf(x[i + 1]);\n  asum += fabsf(x[i + 2]);\n  asum += fabsf(x[i + 3]);\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:asum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/asum/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/67"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      A[(i * N) + j] = 0;\n    }\n    else\n    {\n      A[(i * N) + j] = (((float) i) * j) / N;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/13"}
{"code": "for (i = 0; i < 5; i++)\n{\n  a[i] = i;\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bhuvaneswar005/OpenMP/Assignment 2/Code/qs3/1"}
{"code": "for (int a = 0; a < N_a; a++)\n{\n  p.nV[a] *= Z_m1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/13"}
{"code": "for (v = 0; v < edgeList->num_vertices; ++v)\n{\n  edgeList->label_array[v] = labels[edgeList->label_array[v]];\n  edgeList->inverse_label_array[edgeList->label_array[v]] = v;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/3"}
{"code": "for (j = 0; j < M; j++)\n{\n  Board(0, j) = NewBoard(0, j);\n  Board(N - 1, j) = NewBoard(N - 1, j);\n}\n\n", "pragma": "omp parallel for private(j) shared(board,newboard) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/9"}
{"code": "for (i = 0; i < count; ++i)\n  if (crc == crypt_out[i])\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/pst_fmt_plug/1"}
{"code": "for (int i = 0; i < N; i++)\n  visited[i] = false;\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Pratapabhay/Parallel/dfs_parallel/1"}
{"code": "for (e = 1; e < sv.num_edicts; e++, check = NEXT_EDICT(check))\n{\n  if (check->free)\n    continue;\n\n  if (((check->v.movetype == MOVETYPE_PUSH) || (check->v.movetype == MOVETYPE_NONE)) || (check->v.movetype == MOVETYPE_NOCLIP))\n    continue;\n\n  pusher->v.solid = SOLID_NOT;\n  block = SV_TestEntityPosition(check);\n  pusher->v.solid = SOLID_BSP;\n  if (block)\n    continue;\n\n  if (!((((int) check->v.flags) & FL_ONGROUND) && (PROG_TO_EDICT(check->v.groundentity) == pusher)))\n  {\n    if ((((((check->v.absmin[0] >= maxs[0]) || (check->v.absmin[1] >= maxs[1])) || (check->v.absmin[2] >= maxs[2])) || (check->v.absmax[0] <= mins[0])) || (check->v.absmax[1] <= mins[1])) || (check->v.absmax[2] <= mins[2]))\n      continue;\n\n    if (!SV_TestEntityPosition(check))\n      continue;\n\n  }\n\n  VectorCopy(check->v.origin, moved_from[num_moved]);\n  moved_edict[num_moved] = check;\n  num_moved++;\n  VectorAdd(check->v.origin, move, check->v.origin);\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  VectorSubtract(check->v.origin, move, check->v.origin);\n  block = SV_TestEntityPosition(check);\n  if (!block)\n  {\n    num_moved--;\n    continue;\n  }\n\n  if (check->v.mins[0] == check->v.maxs[0])\n  {\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  if ((check->v.solid == SOLID_NOT) || (check->v.solid == SOLID_TRIGGER))\n  {\n    check->v.mins[0] = (check->v.mins[1] = 0);\n    VectorCopy(check->v.mins, check->v.maxs);\n    SV_LinkEdict(check, 0);\n    continue;\n  }\n\n  VectorCopy(pushorig, pusher->v.origin);\n  SV_LinkEdict(pusher, 0);\n  if (pusher->v.blocked)\n  {\n    pr_global_struct->self = EDICT_TO_PROG(pusher);\n    pr_global_struct->other = EDICT_TO_PROG(check);\n    PR_ExecuteProgram(pusher->v.blocked);\n  }\n\n  for (i = 0; i < num_moved; i++)\n  {\n    VectorCopy(moved_from[i], moved_edict[i]->v.origin);\n    SV_LinkEdict(moved_edict[i], 0);\n  }\n\n  return 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jrk/QuakeTM/server/sv_phys/4"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (j = 0; j < ny; j++)\n    {\n      flux[j][0] = u[k][j][i][2];\n      u31 = u[k][j][i][2] * rho_i[k][j][i];\n      q = qs[k][j][i];\n      flux[j][1] = u[k][j][i][1] * u31;\n      flux[j][2] = (u[k][j][i][2] * u31) + (C2 * (u[k][j][i][4] - q));\n      flux[j][3] = u[k][j][i][3] * u31;\n      flux[j][4] = ((C1 * u[k][j][i][4]) - (C2 * q)) * u31;\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (ty2 * (flux[j + 1][m] - flux[j - 1][m]));\n      }\n\n    }\n\n    for (j = jst; j < ny; j++)\n    {\n      tmp = rho_i[k][j][i];\n      u21j = tmp * u[k][j][i][1];\n      u31j = tmp * u[k][j][i][2];\n      u41j = tmp * u[k][j][i][3];\n      u51j = tmp * u[k][j][i][4];\n      tmp = rho_i[k][j - 1][i];\n      u21jm1 = tmp * u[k][j - 1][i][1];\n      u31jm1 = tmp * u[k][j - 1][i][2];\n      u41jm1 = tmp * u[k][j - 1][i][3];\n      u51jm1 = tmp * u[k][j - 1][i][4];\n      flux[j][1] = ty3 * (u21j - u21jm1);\n      flux[j][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[j][3] = ty3 * (u41j - u41jm1);\n      flux[j][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j = jst; j < jend; j++)\n    {\n      rsd[k][j][i][0] = rsd[k][j][i][0] + ((dy1 * ty1) * ((u[k][j - 1][i][0] - (2.0 * u[k][j][i][0])) + u[k][j + 1][i][0]));\n      rsd[k][j][i][1] = (rsd[k][j][i][1] + (((ty3 * C3) * C4) * (flux[j + 1][1] - flux[j][1]))) + ((dy2 * ty1) * ((u[k][j - 1][i][1] - (2.0 * u[k][j][i][1])) + u[k][j + 1][i][1]));\n      rsd[k][j][i][2] = (rsd[k][j][i][2] + (((ty3 * C3) * C4) * (flux[j + 1][2] - flux[j][2]))) + ((dy3 * ty1) * ((u[k][j - 1][i][2] - (2.0 * u[k][j][i][2])) + u[k][j + 1][i][2]));\n      rsd[k][j][i][3] = (rsd[k][j][i][3] + (((ty3 * C3) * C4) * (flux[j + 1][3] - flux[j][3]))) + ((dy4 * ty1) * ((u[k][j - 1][i][3] - (2.0 * u[k][j][i][3])) + u[k][j + 1][i][3]));\n      rsd[k][j][i][4] = (rsd[k][j][i][4] + (((ty3 * C3) * C4) * (flux[j + 1][4] - flux[j][4]))) + ((dy5 * ty1) * ((u[k][j - 1][i][4] - (2.0 * u[k][j][i][4])) + u[k][j + 1][i][4]));\n    }\n\n  }\n\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][1][i][m] = rsd[k][1][i][m] - (dssp * ((((+5.0) * u[k][1][i][m]) - (4.0 * u[k][2][i][m])) + u[k][3][i][m]));\n      rsd[k][2][i][m] = rsd[k][2][i][m] - (dssp * (((((-4.0) * u[k][1][i][m]) + (6.0 * u[k][2][i][m])) - (4.0 * u[k][3][i][m])) + u[k][4][i][m]));\n    }\n\n  }\n\n  for (j = 3; j < (ny - 3); j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[k][j][i][m] = rsd[k][j][i][m] - (dssp * ((((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n      }\n\n    }\n\n  }\n\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rsd[k][ny - 3][i][m] = rsd[k][ny - 3][i][m] - (dssp * (((u[k][ny - 5][i][m] - (4.0 * u[k][ny - 4][i][m])) + (6.0 * u[k][ny - 3][i][m])) - (4.0 * u[k][ny - 2][i][m])));\n      rsd[k][ny - 2][i][m] = rsd[k][ny - 2][i][m] - (dssp * ((u[k][ny - 4][i][m] - (4.0 * u[k][ny - 3][i][m])) + (5.0 * u[k][ny - 2][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/rhs/2"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k++)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  r[j] = d;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/benchmark-subsetting/NPB3.0-omp-C/CG/cg/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  Est += Covxy.slice(i) * ((Exy.row(i).t() * Ex.row(i)) - Covxx.slice(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/reg_save_solver/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  current_k3[j] = func[j](current_x + (h / 2.), current_y_k3);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example3/main/5"}
{"code": "for (i = 0; i < confReps; i++)\n{\n  D.zeros();\n  shuffle = uvec > ((n, distr_param(0, B.n_cols - 1)));\n  BG = B.cols(shuffle);\n  strp.zeros();\n  for (j = 0; j < n; j++)\n  {\n    Res = StrROne(D, P, data_proc.col(j).head(cov_num), cov_num, level_num, bsize, B, BG, strp);\n    strp = Res(0, 0);\n    BG = Res(1, 0);\n    assignew(j) = Res(2, 0)(0, 0);\n    D = Res(3, 0);\n  }\n\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  y = data_proc.row(cov_num + 1);\n  y.elem(indy) = y.elem(indy) - Lp;\n  TL = ((-sum(y % (assignew - 2))) / n1) - (sum(y % (assignew - 1)) / n0);\n  c = k * (diff_data - Lp);\n  mupdate = ((diff_data - Lp) > (2 * (diff_data - Lm))) || ((diff_data - Lp) < ((diff_data - Lm) * 0.5));\n  Lp = (TL < (diff_data - ((Lp * n1c) / n))) ? (Lp + ((c * alpha) / m)) : (Lp - ((c * (1.0 - alpha)) / m));\n  m = (mupdate) ? (mvalues.min()) : (m + 1);\n  Lm = (mupdate) ? (Lp) : (Lm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/46"}
{"code": "for (tile = 0; tile < length; ++tile)\n{\n  int ii = i + (tile * di);\n  int jj = j - (tile * dj);\n  int imax = MIN(ii + di, height);\n  int jmax = MIN(jj + dj, width);\n  for (int iii = ii; iii < imax; ++iii)\n  {\n    for (int jjj = jj; jjj < jmax; ++jjj)\n    {\n      if ((iii == 0) || (jjj == 0))\n      {\n      }\n      else\n      {\n        if (x[iii - 1] == y[jjj - 1])\n        {\n          dp[iii][jjj] = dp[iii - 1][jjj - 1];\n        }\n        else\n        {\n          if (x[iii - 1] == y[jjj - 1])\n          {\n            dp[iii][jjj] = dp[iii - 1][jjj - 1];\n          }\n          else\n          {\n            dp[iii][jjj] = min3(dp[iii - 1][jjj - 1] + pxy, dp[iii - 1][jjj] + pgap, dp[iii][jjj - 1] + pgap);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for private(tile) schedule(static) num_threads(numThreads) proc_bind(close)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laiweihong2020/OpenMP-KSeq/weihong_kseqalign-1/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  Xid[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/7"}
{"code": "for (int p = 0; p < 10000; p++)\n  for (int i = 0; i < 10; i++)\n{\n  if (i == ((int) TEST_DATA[p][0]))\n    TEST_GOLDEN_OUTPUTS[p][i] = 0.999;\n  else\n    TEST_GOLDEN_OUTPUTS[p][i] = 0.001;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn06/7"}
{"code": "for (int i = sx; i <= ex; i++)\n{\n  for (int j = sy; j <= ey; j++)\n  {\n    for (int k = sz; k <= ez; k++)\n    {\n      v->x[counter] = i;\n      v->y[counter] = j;\n      v->z[counter] = k;\n      v->mass[counter] = (fabs(v->x[counter]) + fabs(v->y[counter])) + fabs(v->z[counter]);\n      counter++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llama95/Parallel_Programming/Patterns/reorg/openmp/1"}
{"code": "for (int i = 0; i < fHeight; ++i)\n{\n  for (int j = 0; j < fWidth; ++j)\n  {\n    filterSum += filter[i + (j * fHeight)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/korgan00/openmpi-and-openmp-project/main/4"}
{"code": "for (int i = 0; i < newlen; i++)\n{\n  nv[i] = v[start + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/12"}
{"code": "for (i = 0; i < n; i++)\n  sums[i] = gk_fsum(ptr[i + 1] - ptr[i], val + ptr[i], 1);\n\n", "pragma": "omp parallel for if (ptr[n] > OMPMINOPS) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/12"}
{"code": "for (i = 0; i < steps; i++)\n{\n  play(prev, next, size);\n  printf(\"%d ----------\\n\", i);\n  print(next, size);\n  tmp = next;\n  next = prev;\n  prev = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/jogo_da_vida/paralell_life/7"}
{"code": "for (i = 0; i < px; i++)\n  for (j = 0; j < py; j++)\n  im[(i * py) + j] = ((double) (i * px)) + j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/filtro-bloques/3"}
{"code": "for (i = 0; i < num_ph; i++)\n{\n  old_position = pow((pow(ph->r0, 2) + pow(ph->r1, 2)) + pow(ph->r2, 2), 0.5);\n  divide_p0 = 1.0 / (ph + i)->p0;\n  (ph + i)->r0 += (((ph + i)->p1 * divide_p0) * C_LIGHT) * t;\n  (ph + i)->r1 += (((ph + i)->p2 * divide_p0) * C_LIGHT) * t;\n  (ph + i)->r2 += (((ph + i)->p3 * divide_p0) * C_LIGHT) * t;\n  new_position = pow((pow(ph->r0, 2) + pow(ph->r1, 2)) + pow(ph->r2, 2), 0.5);\n  if (((new_position - old_position) / t) > C_LIGHT)\n  {\n    fprintf(fPtr, \"PHOTON NUMBER %d IS SUPERLUMINAL. ITS SPEED IS %e c.\\n\", i, ((new_position - old_position) / t) / C_LIGHT);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(num_thread) firstprivate(old_position, new_position, divide_p0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/1"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, 0, z)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, yval, z)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (x = 0; x < OMP_xMax; x++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      u[OMP_Index(x, y, 0)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (x = 0; x < OMP_xMax; x++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      u[OMP_Index(x, y, zval)] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/iompDeblur/0"}
{"code": "for (int y = 0; y < height; y++)\n{\n  for (int x = 0; x < width; x++)\n    printf((1 == currentfield[(y * width) + x]) ? (\"\\033[07m  \\033[m\") : (\"  \"));\n\n  printf(\"\\033[E\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/R-Fehler/lab2/gameoflife-kommi/5"}
{"code": "for (int it = 0; it < iter; it++)\n{\n  if (opp == \"+\")\n  {\n    for (int i = 0; i < source1.rows; i++)\n      for (int j = 0; j < source1.cols; j++)\n      destination(i, j) = source1(i, j) + source2(i, j);\n\n\n  }\n  else\n    if (opp == \"-\")\n  {\n    for (int i = 0; i < source1.rows; i++)\n      for (int j = 0; j < source1.cols; j++)\n      destination(i, j) = source1(i, j) - source2(i, j);\n\n\n  }\n  else\n    if (opp == \"*\")\n  {\n    for (int i = 0; i < source1.rows; i++)\n      for (int j = 0; j < source1.cols; j++)\n      destination(i, j) = mult(source1(i, j), source2(i, j));\n\n\n  }\n  else\n  {\n    for (int i = 0; i < source1.rows; i++)\n      for (int j = 0; j < source1.cols; j++)\n      destination(i, j) = div(source1(i, j), source2(i, j));\n\n\n  }\n\n\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raimonmerce/ImageProcessingOpenMP/arithOMP/0"}
{"code": "for (I = 0; I < M; I++)\n{\n  for (J = 0; J < N; J++)\n  {\n    CU[I + 1][J] = (.5 * (P[I + 1][J] + P[I][J])) * U[I + 1][J];\n    CV[I][J + 1] = .5 * V[I][J + 1];\n    H[I][J] = ((U[I + 1][J] * U[I + 1][J]) + (U[I][J] * U[I][J])) + (V[I][J + 1] * V[I][J + 1]);\n  }\n\n  for (J = 0; J < N; J++)\n  {\n    CV[I][J + 1] *= P[I][J + 1] + P[I][J];\n    Z[I + 1][J + 1] = ((FSDX * (V[I + 1][J + 1] - V[I][J + 1])) - (FSDY * (U[I + 1][J + 1] - U[I + 1][J]))) / (((P[I][J] + P[I + 1][J]) + P[I + 1][J + 1]) + P[I][J + 1]);\n    H[I][J] = P[I][J] + (.25 * (H[I][J] + (V[I][J] * V[I][J])));\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/0"}
{"code": "for (int i = 0; i < num_threads; ++i)\n{\n  radixSortParallelHistoBlock(keys.begin() + (i * blockSize), (i == (num_threads - 1)) ? (keys.end()) : (keys.begin() + ((i + 1) * blockSize)), &local_histogram[i * numBuckets], startBit, numBits);\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (cout << result_vector_pos[i]) << \" \";\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task3/2"}
{"code": "for (int i = 0; i < ((signed) mask.size()); i++)\n{\n  if ((((mask[i][0] < ((signed) img->getHeight())) && (mask[i][0] >= 0)) && (mask[i][1] < ((signed) img->getWidth()))) && (mask[i][1] >= 0))\n    c->fill(img, mask[i][0], mask[i][1]);\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) num_threads(Data::NB_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serrearthur/Fauxtoshop/source/src/base/mask/1"}
{"code": "for (unsigned int i = 0; i < MATRIX_SIZE; ++i)\n{\n  T factor = 0.;\n  for (unsigned int j = 0; j < MATRIX_SIZE; ++j)\n  {\n    T factorTemp = abs(inputMatrix[i][j]);\n    if (factorTemp > factor)\n    {\n      factor = factorTemp;\n    }\n\n  }\n\n  factors[i] = factor;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZachMarcus/Experiments/matrix-inversion/matrix-inversion/1"}
{"code": "for (int i = 0; i < h; i++)\n{\n  for (int j = 0; j < w; j++)\n  {\n    mns[omp_get_thread_num()] = min(mns[omp_get_thread_num()], pixels[i][j].r);\n    mns[omp_get_thread_num()] = min(mns[omp_get_thread_num()], pixels[i][j].g);\n    mns[omp_get_thread_num()] = min(mns[omp_get_thread_num()], pixels[i][j].b);\n    mxs[omp_get_thread_num()] = max(mxs[omp_get_thread_num()], pixels[i][j].r);\n    mxs[omp_get_thread_num()] = max(mxs[omp_get_thread_num()], pixels[i][j].g);\n    mxs[omp_get_thread_num()] = max(mxs[omp_get_thread_num()], pixels[i][j].b);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(kind, chunk_size) shared(mns, mxs)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MONICgh/OpenMP/lab04/6"}
{"code": "for (i = 0; i < N; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    for (k = 0; k < N; ++k)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prplcld/arrays_and_openmp/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (int k = 0; k < data->nOfPatterns; k++)\n{\n  for (i = 0; i < data->nOfInputs; i++)\n  {\n    getline(file, aux, ' ');\n    n = atof(aux.c_str());\n    data->inputs[k][i] = n;\n  }\n\n  for (i = 0; i < (data->nOfOutputs - 1); i++)\n  {\n    getline(file, aux, ' ');\n    n = atof(aux.c_str());\n    data->outputs[k][i] = n;\n  }\n\n  getline(file, aux);\n  n = atof(aux.c_str());\n  data->outputs[k][i] = n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/21"}
{"code": "for (int i = 0; i < (n + 1); i++)\n{\n  I1[i] = cer[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vamartid/NSK-birthday-attack/parallel/Ns/7"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/79"}
{"code": "for (j = 0; j < 4; j++)\n{\n  avgtime[j] = avgtime[j] / ((double) (NTIMES - 1));\n  if (label[j][0] != 'i')\n  {\n    printf(\"%s%12.1f  %11.6f  %11.6f  %11.6f\\n\", label[j], (1.0E-06 * bytes[j]) / mintime[j], avgtime[j], mintime[j], maxtime[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-4/stream-gpu/stream/2"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < NCB; j++)\n    for (k = 0; k < NCA; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/MatrixMultiply/3"}
{"code": "for (int i = 0; i <= 10; i++)\n{\n  val = fibonnaci(i);\n  printf(\"Fibonacci of %d th term is:     %d\\n\", i, val);\n}\n\n", "pragma": "omp parallel for private(val)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Introduction_To_OpenMP/6/Fibonacci/main/0"}
{"code": "for (i = 0; i < (n - 1); ++i)\n  if (((long long) data[i].key) > ((long long) data[i + 1].key))\n{\n  printf(\"Sort failed!\\n\");\n  printf(\"Time taken: %.2fs\\n\", end - start);\n  return -1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivanker/ompsort/time/0"}
{"code": "for (j3 = 1; j3 < (m3j - 1); j3++)\n{\n  i3 = (2 * j3) - d3;\n  for (j2 = 1; j2 < (m2j - 1); j2++)\n  {\n    i2 = (2 * j2) - d2;\n    for (j1 = 1; j1 < m1j; j1++)\n    {\n      i1 = (2 * j1) - d1;\n      x1[i1] = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      y1[i1] = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n    }\n\n    for (j1 = 1; j1 < (m1j - 1); j1++)\n    {\n      i1 = (2 * j1) - d1;\n      y2 = ((r[i3][i2][i1 + 1] + r[i3 + 2][i2][i1 + 1]) + r[i3][i2 + 2][i1 + 1]) + r[i3 + 2][i2 + 2][i1 + 1];\n      x2 = ((r[i3 + 1][i2][i1 + 1] + r[i3 + 1][i2 + 2][i1 + 1]) + r[i3][i2 + 1][i1 + 1]) + r[i3 + 2][i2 + 1][i1 + 1];\n      s[j3][j2][j1] = (((0.5 * r[i3 + 1][i2 + 1][i1 + 1]) + (0.25 * ((r[i3 + 1][i2 + 1][i1] + r[i3 + 1][i2 + 1][i1 + 2]) + x2))) + (0.125 * ((x1[i1] + x1[i1 + 2]) + y2))) + (0.0625 * (y1[i1] + y1[i1 + 2]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j1 ,j2 ,j3 ,i1 ,i2 ,i3 ,x1 ,y1 ,x2 ,y2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/5"}
{"code": "for (unsigned long long i = 1; i <= steps; i++)\n{\n  double x = a + (i * h);\n  sum += h * f(x);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gvintux/openmp_example/main/0"}
{"code": "for (j = 0; j < (m_nSizePoint * ELEMENT_COUNT_POINT); j++)\n  m_pIn[j] = 2.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soulsheng/openmp-app/environment/common/app-MatrixMultPoint3D/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  calcForce(&pos[i], pos, &force[i], 1000);\n  updateVelocity(&velocity[i], &force[i], &velocity[i]);\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/3"}
{"code": "for (k = 1; k < omp_get_max_threads(); k++)\n{\n  if (dmax_t[k] > dmax_t[0])\n    dmax_t[0] = dmax_t[k];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/Poisson/C/poisson/8"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ++r;\n}\n\n", "pragma": "#pragma omp for reduction(+ : r)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/task_messages/2"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 0; k <= (nz - 1); k++)\n    {\n      flux[i][j][k][0] = u[i][j][k][3];\n      u41 = u[i][j][k][3] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = u[i][j][k][1] * u41;\n      flux[i][j][k][2] = u[i][j][k][2] * u41;\n      flux[i][j][k][3] = (u[i][j][k][3] * u41) + (C2 * (u[i][j][k][4] - q));\n      flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u41;\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n      }\n\n    }\n\n    for (k = 1; k <= (nz - 1); k++)\n    {\n      tmp = 1.0 / u[i][j][k][0];\n      u21k = tmp * u[i][j][k][1];\n      u31k = tmp * u[i][j][k][2];\n      u41k = tmp * u[i][j][k][3];\n      u51k = tmp * u[i][j][k][4];\n      tmp = 1.0 / u[i][j][k - 1][0];\n      u21km1 = tmp * u[i][j][k - 1][1];\n      u31km1 = tmp * u[i][j][k - 1][2];\n      u41km1 = tmp * u[i][j][k - 1][3];\n      u51km1 = tmp * u[i][j][k - 1][4];\n      flux[i][j][k][1] = tz3 * (u21k - u21km1);\n      flux[i][j][k][2] = tz3 * (u31k - u31km1);\n      flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * tz3) * (((pow2(u21k) + pow2(u31k)) + pow2(u41k)) - ((pow2(u21km1) + pow2(u31km1)) + pow2(u41km1)))) + (((1.0 / 6.0) * tz3) * (pow2(u41k) - pow2(u41km1)))) + (((C1 * C5) * tz3) * (u51k - u51km1));\n    }\n\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      rsd[i][j][k][0] = rsd[i][j][k][0] + ((dz1 * tz1) * ((u[i][j][k - 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k + 1][0]));\n      rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][1] - flux[i][j][k][1]))) + ((dz2 * tz1) * ((u[i][j][k - 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k + 1][1]));\n      rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][2] - flux[i][j][k][2]))) + ((dz3 * tz1) * ((u[i][j][k - 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k + 1][2]));\n      rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][3] - flux[i][j][k][3]))) + ((dz4 * tz1) * ((u[i][j][k - 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k + 1][3]));\n      rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tz3 * C3) * C4) * (flux[i][j][k + 1][4] - flux[i][j][k][4]))) + ((dz5 * tz1) * ((u[i][j][k - 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][1][m] = rsd[i][j][1][m] - (dssp * ((((+5.0) * u[i][j][1][m]) - (4.0 * u[i][j][2][m])) + u[i][j][3][m]));\n      rsd[i][j][2][m] = rsd[i][j][2][m] - (dssp * (((((-4.0) * u[i][j][1][m]) + (6.0 * u[i][j][2][m])) - (4.0 * u[i][j][3][m])) + u[i][j][4][m]));\n    }\n\n    for (k = 3; k <= (nz - 4); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][j][nz - 3][m] = rsd[i][j][nz - 3][m] - (dssp * (((u[i][j][nz - 5][m] - (4.0 * u[i][j][nz - 4][m])) + (6.0 * u[i][j][nz - 3][m])) - (4.0 * u[i][j][nz - 2][m])));\n      rsd[i][j][nz - 2][m] = rsd[i][j][nz - 2][m] - (dssp * ((u[i][j][nz - 4][m] - (4.0 * u[i][j][nz - 3][m])) + (5.0 * u[i][j][nz - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(tmp, u21k, u31k, u41k, u51k, u21km1, u31km1, u41km1, u51km1, u41, q)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/45"}
{"code": "for (m = 0; m < (2635 - 1); m += 1)\n{\n  double x0;\n  double x1;\n  double x2;\n  double x3;\n  double allerr;\n  int maxmitr = 1000000;\n  x0 = (double) m;\n  x1 = (double) (2635 - 1);\n  bool a = false;\n  allerr = 0.000001157;\n  int itr = 0;\n  regula(&x2, x0, x1, macd_position(x0) - signal_position(x0), macd_position(x1) - signal_position(x1), &itr);\n  do\n  {\n    if (((macd_position(x0) - signal_position(x0)) * (macd_position(x2) - signal_position(x2))) < 0)\n      x1 = x2;\n    else\n      x0 = x2;\n\n    regula(&x3, x0, x1, macd_position(x0) - signal_position(x0), macd_position(x1) - signal_position(x1), &itr);\n    if (fabs(x3 - x2) < allerr)\n    {\n      if (((x3 > 0) && (x3 <= macd.size())) && (ans.find(x3) == ans.end()))\n      {\n        a = true;\n        if (macd_position(x3) > signal_position(x3))\n        {\n          amount -= close[(int) round(x3)];\n        }\n        else\n          if (macd_position(x3) < signal_position(x3))\n        {\n          amount += close[(int) round(x3)];\n        }\n\n\n        ans.insert(x3);\n        itr = 5000000;\n      }\n\n    }\n\n    x2 = x3;\n  }\n  while (itr < maxmitr);\n  if (!a)\n  {\n    a = false;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(4) shared(ans) private(m) reduction(+:amount)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harshnagarkar/OpenMP-MACD-performance-evaluator/stock_macd_omp/0"}
{"code": "for (int j = 0; j < threadLenDivision; j++)\n{\n  delete(tmpResMatrix[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nablax/OpenMP-CUDA-Matrix-Multiplication/QtMatrixOpenMP/MatrixCalculation/8"}
{"code": "for (i1 = 0; i1 < N1; i1++)\n{\n  for (i2 = 0; i2 < N2; i2++)\n  {\n    for (i3 = 0; i3 < N3; i3++)\n    {\n      for (i4 = 0; i4 < N4; i4++)\n      {\n        RES[4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)] = A1[i1];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 1] = A2[i2];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 2] = A3[i3];\n        RES[(4 * ((((((i1 * N2) * N3) * N4) + ((i2 * N3) * N4)) + (i3 * N4)) + i4)) + 3] = A4[i4];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(i1, i2, i3, i4) shared(RES, A1, A2, A3, A4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AleiynikovPavel/OpenMPLab7/main/1"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  mult();\n  shift();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/10"}
{"code": "for (i = 0; i < 5; i++)\n{\n  if ((line[i] >= 9) && (line[i] <= 19))\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/matrix/2"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 6; j++)\n  A[i][j] = cnt++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture14/lastprivate/2"}
{"code": "for (i = 0; i < qtdveiculos; i++)\n{\n  qtdvagasdisponiveis++;\n  qtdvagasocupadas--;\n  numerovaga--;\n  movimentacaoveiculos++;\n}\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YujiSeto/Estacionamento-OpenMP/Estacionamento OpenMP/1"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((((-4.0) * u[i][j][k - 1][m]) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/62"}
{"code": "for (int i = 0; i < (n - 1); ++i)\n{\n  fprintf(file, \"%lf \", z[i]);\n}\n\n", "pragma": "omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/2"}
{"code": "for (int y = 0; y < DIM; y += TILE_SIZE)\n  changement += do_tile_unstable(1, y + (y == 0), DIM - 2, TILE_SIZE - (((y + TILE_SIZE) == DIM) + (y == 0)), omp_get_thread_num());\n\n", "pragma": "omp for reduction (+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/4"}
{"code": "for (int i = 2 * (i & x); i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/42"}
{"code": "for (int i = 0; i < max_iter; i++)\n{\n  tmp = x;\n  x = _mm_add_ps(a, _mm_sub_ps(_mm_mul_ps(x, x), _mm_mul_ps(y, y)));\n  y = _mm_add_ps(b, _mm_mul_ps(_mm_mul_ps(y, tmp), two));\n  z = _mm_sqrt_ps(_mm_add_ps(_mm_mul_ps(x, x), _mm_mul_ps(y, y)));\n  num_iter = _mm_add_epi32(num_iter, _mm_cvtps_epi32(_mm_and_ps(_mm_cmplt_ps(z, two), one)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/3"}
{"code": "for (k = 0; k < DIM; k++)\n{\n  test += a[i][k] * b[k][j];\n}\n\n", "pragma": "omp parallel for schedule(static, 250), reduction(+ : test)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yaiciwalid/Programmation-Parall-le/archi/0"}
{"code": "for (j = _usedSymbols.begin(); j != _usedSymbols.end(); ++j)\n  if (!strcmp(j->c_str(), buffer))\n{\n  isUsedSymbol = true;\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/PolyOpt/polyopt/PastToSage/8"}
{"code": "for (i = 0; i < num_threads; i++)\n{\n  if (vMax < vMaxLocal[i])\n  {\n    vMax = vMaxLocal[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/thresh/0"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    for (k = 0; k < 1024; k++)\n    {\n      c[(i * 1024) + j] += a[(i * 1024) + k] * b[(k * 1024) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SatoYuki8/example_openmp/omp_matmul/0"}
{"code": "for (i = q->head; i < q->tail; i++)\n{\n  v = q->queue[i];\n  setBitAtomic(b, v);\n}\n\n", "pragma": "omp parallel for default(none) shared(q,b) private(v,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/arrayQueue/1"}
{"code": "for (int hn = 0; hn < numberOfNodes; ++hn)\n{\n  Node *node = &nodes[hn];\n  initNode(numberOfWeights, node);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/0"}
{"code": "for (int ix = 2; ix < (nx + 2); ix++)\n{\n  for (int iy = 2; iy < (ny + 2); iy++)\n  {\n    for (int iz = 2; iz < (nz + 2); iz++)\n    {\n      int s = columnMajorLinearIndex(ix, iy, iz, nx + 4, ny + 4, nz + 4);\n      energy_density_evoution[0][ix - 2][iy - 2][iz - 2] = energy_density_evoution[1][ix - 2][iy - 2][iz - 2];\n      for (int ivar = 0; ivar < 16; ivar++)\n      {\n        hydrodynamic_evoution[ivar][0][ix - 2][iy - 2][iz - 2] = hydrodynamic_evoution[ivar][1][ix - 2][iy - 2][iz - 2];\n      }\n\n      energy_density_evoution[1][ix - 2][iy - 2][iz - 2] = (double) e[s];\n      hydrodynamic_evoution[0][1][ix - 2][iy - 2][iz - 2] = (double) u->ux[s];\n      hydrodynamic_evoution[1][1][ix - 2][iy - 2][iz - 2] = (double) u->uy[s];\n      hydrodynamic_evoution[2][1][ix - 2][iy - 2][iz - 2] = (double) u->un[s];\n      hydrodynamic_evoution[3][1][ix - 2][iy - 2][iz - 2] = (double) e[s];\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/freezeout/FreezeOut/1"}
{"code": "for (unsigned int i = 0; i < ((2048 / 1) + 2); i++)\n  gro[i] = get[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/16"}
{"code": "for (k = 0; k < nlines; k++)\n  fprintf(fout, \"\\n%s\", lines[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Alfie-Edwards/CM3103-High-Performance-Computing/OpenMP/Code/blurOMP-Dynamic/3"}
{"code": "for (int i = 0; i < s.length(); i++)\n{\n  n = ((n * 10) + s[i]) - '0';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DimaUtyuz/parallel-determinant/main/0"}
{"code": "for (long i = 0; i < N1; i++)\n{\n  if (C1[i] == 0)\n    isZero1 = true;\n\n  if (C1[i] > nC1)\n  {\n    nC1 = C1[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/0"}
{"code": "for (unsigned long i = 0; i < vectorCallee.size(); ++i)\n{\n  if ((vectorCallee[i] < 0) || (vectorCallee[i] >= vectorFunc.size()))\n  {\n    (cout << \"SpreadUsedInOMP \u9519\u8bef: vectorCallee \u7684 index \u975e\u6cd5\") << endl;\n    exit(1);\n  }\n\n  vectorFunc[vectorCallee[i]].UsedInOMP = true;\n  SpreadFuncUsedInOMP(vectorFunc[vectorCallee[i]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/src/OAORewriter/10"}
{"code": "for (i = 0; i < m; i++)\n  for (k = 0; k < p; k++)\n{\n  REAL c = 0.0;\n  for (j = 0; j < n; j++)\n    c += A[(i * ld) + j] * B[(k * ld) + j];\n\n  C[(i * ld) + k] += c;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/mmult/mm_funcs/2"}
{"code": "for (j = key; j < (n - 1); ++j)\n  if (a[j] > a[j + 1])\n  swap(&a[j], &a[j + 1]);\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rikky3/high-performance-computing/mbsort/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  align_A[i] = (float *) malloc((n + pad) * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huxiaotaostasy/OpenMP/code_OpenMP/main/5"}
{"code": "for (i = 1; i < nthreads; ++i)\n{\n  in_seed = (unsigned long) ((MULTIPLIER * in_seed) % PMOD);\n  pseed[i] = in_seed;\n  mult_n = (mult_n * MULTIPLIER) % PMOD;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParallelProgTeam/Aula-3-OpenMP/OMP_Exercises/solutions/pi_mc_par_array/1"}
{"code": "for (int a = 0; a < N_a; a++)\n{\n  la.nV = l.nM[a];\n  Z += exp(fa__aLME__(la, lambda, Beta));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/14"}
{"code": "for (i = 0; i < count; i++)\n{\n  parr[i] = p;\n  p = p->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/Linked_lists/Solutions/linked_omp25/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"#\");\n  for (int j = 0; j < N; j++)\n    printf(\"%.2f \", m1[i][j]);\n\n  printf(\"#\");\n  if (i == (N - 1))\n    printf(\"* #%.2f# = #%.3f#\\n\", v2[i], v3[i]);\n  else\n    printf(\"  #%.2f# = #%.3f#\\n\", v2[i], v3[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanca-rf/Arquitectura-de-Computadores---OpenMP/BP3/ejer8/pmtv-OpenMP/4"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    for (k = 1; k < (nz - 1); k++)\n    {\n      f = 2 * phi[i][j][k];\n      phi_xx = (-2.0) / (dx * dx);\n      phi_yy = (-2.0) / (dy * dy);\n      phi_zz = (-2.0) / (dz * dz);\n      phi_jac[i][j][k] = ((phi_xx + phi_yy) + phi_zz) - f;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/7"}
{"code": "for (int n = 0; n < 10; ++n)\n  sleep((rand() % 10) + 1);\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JCisneros77/AdvancedProgrammingTask5/omp_no_wait/0"}
{"code": "for (int i = 0; i < (*aNumberOfCentroids); i++)\n{\n  int tid = omp_get_thread_num();\n  for (int j = 0; j < (*aNumberOfPoints); j++)\n  {\n    if (aCentroids[i].mId == aPoints[j].mCentroidId)\n    {\n      aCentroids[i].mNumberOfPoints++;\n      aCentroids[i].mXcount += aPoints[j].mX;\n      aCentroids[i].mYCount += aPoints[j].mY;\n    }\n\n  }\n\n  if (aCentroids[i].mNumberOfPoints > 0)\n  {\n    aCentroids[i].mX = aCentroids[i].mXcount / aCentroids[i].mNumberOfPoints;\n    aCentroids[i].mY = aCentroids[i].mYCount / aCentroids[i].mNumberOfPoints;\n    aCentroids[i].mNumberOfPoints = 0;\n    aCentroids[i].mXcount = 0;\n    aCentroids[i].mYCount = 0;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/0"}
{"code": "for (c1 = (nj > nm) ? (nj) : (nm); c1 <= (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((i % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n  fprintf(stderr, \"%0.2lf \", w[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aleksyav/C-MPI-OMP-Gemver/OpenMP/gemver/5"}
{"code": "for (int i = 0; i < m_tillageNum; i++)\n{\n  m_tillageLookupMap.insert(make_pair(CVT_INT(m_tillageLookup[i][1]), m_tillageLookup[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/management/PLTMGT_SWAT/managementOperation_SWAT/3"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  Mat->PutXY(RowIdx, LastColIdx, Col[RowIdx]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/108"}
{"code": "for (i = 0; i < 16; i++)\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus5_fmt_plug/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (flow_in_num_[i] == 0)\n  {\n    last_layer[num_last_layer++] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/7"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  if (this->mat_.row[i] != this->mat_.col[i])\n  {\n    this->mat_.val[i] += alpha;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/22"}
{"code": "for (int node = 0; node < node_count; node++)\n{\n  if (outbound_count[node] == 0)\n    (*dangling_count)++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/5"}
{"code": "for (i = 0; i < 64; i++)\n  s8 = s7++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/distribute-1/6"}
{"code": "for (unsigned i = 0; i < width_local; i++)\n{\n  for (unsigned j = 0; j < height_local; j++)\n  {\n    uint32_t sum = 0;\n    for (unsigned k = 0; k < width_local; k++)\n      sum = sum + (a_local[(i * width_local) + k] * b_local[(k * width_local) + j]);\n\n    c_local[(i * width_local) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) firstprivate(a_local, b_local, c_local, width_local, height_local)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/mm-small/mm-small/3"}
{"code": "for (unsigned long long int i = 0; i < combinations; i++)\n{\n  if (found == 0)\n    run(i);\n\n}\n\n", "pragma": "omp parallel for shared(found) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogoazevedos/hash-breaker/main/0"}
{"code": "for (i = 0; i < (NGROUPS / 10); i++)\n{\n  for (j = 0; j < 10; j++)\n    printf(\"%6d\", iingrs[(10 * i) + j].size);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/13"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = 0; j < col; j++)\n  {\n    (cout << data.at(i).at(j)) << ' ';\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddahatonde/OPENMP/Matrix/1"}
{"code": "for (unsigned i = 0; i < xCoordinates.size(); i++)\n{\n  xCoordinates[i] = xCoordinates[i] * scale;\n  yCoordinates[i] = yCoordinates[i] * scale;\n  zCoordinates[i] = zCoordinates[i] * scale;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/geometry/operators/mesh/2"}
{"code": "for (long i = 2; i <= 1000; i++)\n{\n  res[i] = daxpyParallel(i);\n  printf(\"#threads: %ld time: %lf\\n\", i, res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSE-Projects/parallel-programming-openmp/A1/q3/q3/2"}
{"code": "for (int jj = internal_ystart - 1; jj <= (internal_ystop + 1); jj++)\n{\n  for (int ji = internal_xstart - 1; ji <= internal_xstop; ji++)\n  {\n    bc_flather_u_code(ji, jj, width, ua, hu, sshn_u, tmask, g);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = (b[i] = 1.0 * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BigBach/AdvancedComputerArchitecture/ExamplesPart1/omp_orphan/0"}
{"code": "for (k = 1; k < (nz0 - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = ist; i < iend; i++)\n    {\n      sum0 = sum0 + (v[i][j][k][0] * v[i][j][k][0]);\n      sum1 = sum1 + (v[i][j][k][1] * v[i][j][k][1]);\n      sum2 = sum2 + (v[i][j][k][2] * v[i][j][k][2]);\n      sum3 = sum3 + (v[i][j][k][3] * v[i][j][k][3]);\n      sum4 = sum4 + (v[i][j][k][4] * v[i][j][k][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/17"}
{"code": "for (int i = 0; i < max.capa; ++i)\n  sync.degree[i] = 0;\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/matching/1"}
{"code": "for (long i = 0; i < contRelationOk; i++)\n{\n  vect_solution[i] = 0;\n  vect_pivot[i] = -1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_gmp/4"}
{"code": "for (iz = 0; iz < 2; iz++)\n{\n  for (ix = 0; ix < 3600; ix++)\n  {\n    for (iy = 0; iy < 3600; iy++)\n    {\n      offset = (((iz * 3600) * 3600) + (ix * 3600)) + iy;\n      *(table_u + offset) = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/spirosdelviniotis/parallel_programming/OpenMP/Pure_OpenMP_main/1"}
{"code": "for (unsigned int i = 0; i < ((2048 / NODESY) + 2); i++)\n  grn[i] = gst[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/78"}
{"code": "for (i = 0; i < 700; i++)\n{\n  for (j = 0; j < 700; j++)\n  {\n    u[i][j] = w[i][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/hated_plate_local/7"}
{"code": "for (k = 0; k < N; k++)\n{\n  x[k] = tmp[k];\n}\n\n", "pragma": "            #pragma omp for schedule(guided, N_chunks) private(s, k, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Minyoung-Kim1110/OpenMP/HW1/jacobi/4"}
{"code": "for (i = 0; i < messages.size(); ++i)\n{\n  encrypted_messages[i] = XOR(aes.encrypt(ctrs[i]), messages[i]);\n}\n\n", "pragma": "\t\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/franneck94/CUDA-AES/AES OpenMP/Mode/3"}
{"code": "for (i = 0; i < dataSet->n; i++)\n{\n  for (j = 0; j < dataSet->m; j++)\n  {\n    dataSet->A[(i * dataSet->m) + j] = rand() % 100;\n    dataSet->B[(i * dataSet->m) + j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZahraY10/Parallel-Programming-OpenMP/Lab 2/lab2/codes/parallel/2_Dimensional/0"}
{"code": "for (int i = 0; i < w; ++i)\n{\n  for (int j = 0; j < h; ++j)\n  {\n    printf(\"%f \", mat[(i * w) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/korgan00/openmpi-and-openmp-project/main/0"}
{"code": "for (i = windowStart; i < windowLen; i++)\n{\n  if (xcorr[i] < minval)\n  {\n    minval = xcorr[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/branches/OpenMPT-1.25/include/soundtouch/source/SoundTouch/BPMDetect/0"}
{"code": "for (iter = 0; iter < 1000; iter++)\n{\n  temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n  z.i = ((z.r * z.i) * 2) + c.i;\n  z.r = temp;\n  if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n  {\n    numoutsides++;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/mandelserial/1"}
{"code": "for (n = 1, Zn = c; (abs(Zn) < fd->T) && (n < (fd->maxiter + 1)); ++n)\n{\n  Zn = (Zn * Zn) + c;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kvoss/parallel-fractals/mandelbrot_set_omp/0"}
{"code": "for (k = iBegin; k < iEnd; k++)\n{\n  if ((i < iMiddle) && ((j >= iEnd) || (tablica[i] <= tablica[j])))\n  {\n    t[k] = tablica[i];\n    i = i + 1;\n  }\n  else\n  {\n    t[k] = tablica[j];\n    j = j + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TomaszAugustyn/multicore-mergesort-with-openmp/OpenMP2/main/0"}
{"code": "for (int x = 0; x < 256; x++)\n{\n  for (int y = 0; y < N; ++y)\n    histo[x] += arr[x][y];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative2/2"}
{"code": "for (int j = 0; j < N; j++)\n  printf(\"%3d\", j);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/16"}
{"code": "for (j = 13; j >= 1; j--)\n{\n  if (size[j] == '.')\n    size[j] = ' ';\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/EP/ep/1"}
{"code": "for (y = 0; y < h; y++)\n{\n  for (x = 0; x < w; x++)\n  {\n    uint32_t status = random() % 100;\n    if (status < 50)\n    {\n      univ[y][x] = 1;\n    }\n    else\n      if (status < 95)\n    {\n      univ[y][x] = 0;\n    }\n    else\n    {\n      univ[y][x] = 2;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/4"}
{"code": "for (int jj = 1; jj < (params.nx - 1); ++jj)\n{\n  cells[(line * params.nx) + jj].speeds[7] = recvbuf[(params.ly * 3) + ((jj - 1) * 3)];\n  cells[(line * params.nx) + jj].speeds[4] = recvbuf[((params.ly * 3) + ((jj - 1) * 3)) + 1];\n  cells[(line * params.nx) + jj].speeds[8] = recvbuf[((params.ly * 3) + ((jj - 1) * 3)) + 2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/mpi/d2q9-bgk/29"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  u_data->received_first_message = 0;\n  if (u_data->fragment_id != u->label)\n    continue;\n\n  message m = {-1};\n  enqueue(msgs, u->label, &m);\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/1"}
{"code": "for (int i = 0; i < height; i++)\n  free(row[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/Img Processing and Morpological Operations/image/0"}
{"code": "for (i = 1; i < pointsInProc; ++i)\n{\n  pointsVelocityProc[i] = pointsVelocityProc[i - 1] + DIMS;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OrMilis/Kmeans/kmeans_Parallel/main/5"}
{"code": "for (unsigned i = 0, e = Node->getNumLabels(); i != e; ++i)\n{\n  if (i != 0)\n    OS << \", \";\n\n  OS << Node->getLabelName(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/lib/AST/StmtPrinter/0"}
{"code": "for (int c = c1; c < c2; c++)\n{\n  int r = (int) ((k * (c - c1)) + r1);\n  data[((r * w) * 3) + (3 * c)] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 1] = 0;\n  data[(((r * w) * 3) + (3 * c)) + 2] = 255;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/image_utility/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    float temp = 0;\n    for (int k = 0; k < n; k++)\n      temp += A[i][k] * B[k][j];\n\n    C[i][j] = temp;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(A,B,C,n) schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part1/Asgn1/1"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  c[(i * 500) + j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/application_kernels/mmm_target_parallel_for_simd/3"}
{"code": "for (i = 0; i < nthreads; i++)\n{\n  shmemx_ctx_destroy(contexts[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-wavefront/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] -= b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/21"}
{"code": "for (int i = 0; i < n; i++)\n{\n  points[i].x = rand() % n;\n  points[i].y = rand() % n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dashan124/Parallel_Convex_Hull/jarvis/0"}
{"code": "for (i = 0; i < (strlen(Q) + 1); i++)\n{\n  free(scoreTable[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z1skgr/OpenMP-pthreads-parallelComputing/OMPa/7"}
{"code": "for (i = 1; i < (size - 1); i++)\n  for (j = 1; j < (size - 1); j++)\n  if (lt[i][j] != next_gen_table[i][j])\n  return 1;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimTsesm/Parallel-Conway-s-Game-of-Life./src/mpi-openmp/openMPfunc/3"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < (columns + 2); j++)\n  {\n    array[(i * (columns + 2)) + j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajdangwal/Game-of-Life/GameOfLife/0"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      vijk = vs[k][j][i];\n      vp1 = vs[k][j + 1][i];\n      vm1 = vs[k][j - 1][i];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dy1ty1 * ((u[k][j + 1][i][0] - (2.0 * u[k][j][i][0])) + u[k][j - 1][i][0]))) - (ty2 * (u[k][j + 1][i][2] - u[k][j - 1][i][2]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dy2ty1 * ((u[k][j + 1][i][1] - (2.0 * u[k][j][i][1])) + u[k][j - 1][i][1]))) + (yycon2 * ((us[k][j + 1][i] - (2.0 * us[k][j][i])) + us[k][j - 1][i]))) - (ty2 * ((u[k][j + 1][i][1] * vp1) - (u[k][j - 1][i][1] * vm1)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dy3ty1 * ((u[k][j + 1][i][2] - (2.0 * u[k][j][i][2])) + u[k][j - 1][i][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[k][j + 1][i][2] * vp1) - (u[k][j - 1][i][2] * vm1)) + ((((u[k][j + 1][i][4] - square[k][j + 1][i]) - u[k][j - 1][i][4]) + square[k][j - 1][i]) * c2)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dy4ty1 * ((u[k][j + 1][i][3] - (2.0 * u[k][j][i][3])) + u[k][j - 1][i][3]))) + (yycon2 * ((ws[k][j + 1][i] - (2.0 * ws[k][j][i])) + ws[k][j - 1][i]))) - (ty2 * ((u[k][j + 1][i][3] * vp1) - (u[k][j - 1][i][3] * vm1)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dy5ty1 * ((u[k][j + 1][i][4] - (2.0 * u[k][j][i][4])) + u[k][j - 1][i][4]))) + (yycon3 * ((qs[k][j + 1][i] - (2.0 * qs[k][j][i])) + qs[k][j - 1][i]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[k][j + 1][i][4] * rho_i[k][j + 1][i]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k][j - 1][i][4] * rho_i[k][j - 1][i])))) - (ty2 * ((((c1 * u[k][j + 1][i][4]) - (c2 * square[k][j + 1][i])) * vp1) - (((c1 * u[k][j - 1][i][4]) - (c2 * square[k][j - 1][i])) * vm1)));\n    }\n\n  }\n\n  j = 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((5.0 * u[k][j][i][m]) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n    }\n\n  }\n\n  j = 2;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((((-4.0) * u[k][j - 1][i][m]) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n    }\n\n  }\n\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])) + u[k][j + 2][i][m]));\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 3;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((u[k][j - 2][i][m] - (4.0 * u[k][j - 1][i][m])) + (6.0 * u[k][j][i][m])) - (4.0 * u[k][j + 1][i][m])));\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * ((u[k][j - 2][i][m] - (4. * u[k][j - 1][i][m])) + (5. * u[k][j][i][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/rhs/3"}
{"code": "for (int wiID = 0; wiID < N; wiID++)\n{\n  const float GDC_DEG_TO_RAD = 3.141592654 / 180.0;\n  const float GDC_FLATTENING = 1.0 - (6356752.31424518 / 6378137.0);\n  const float GDC_ECCENTRICITY = 6356752.31424518 / 6378137.0;\n  const float GDC_ELLIPSOIDAL = ((1.0 / (6356752.31414 / 6378137.0)) / (6356752.31414 / 6378137.0)) - 1.0;\n  const float GDC_SEMI_MINOR = 6356752.31424518f;\n  const float EPS = 0.5e-5f;\n  float dist;\n  float BAZ;\n  float C;\n  float C2A;\n  float CU1;\n  float CU2;\n  float CX;\n  float CY;\n  float CZ;\n  float D;\n  float E;\n  float FAZ;\n  float SA;\n  float SU1;\n  float SX;\n  float SY;\n  float TU1;\n  float TU2;\n  float X;\n  float Y;\n  const float rad_latitude_1 = VA[wiID].x * GDC_DEG_TO_RAD;\n  const float rad_longitude_1 = VA[wiID].y * GDC_DEG_TO_RAD;\n  const float rad_latitude_2 = VA[wiID].z * GDC_DEG_TO_RAD;\n  const float rad_longitude_2 = VA[wiID].w * GDC_DEG_TO_RAD;\n  TU1 = (GDC_ECCENTRICITY * sinf(rad_latitude_1)) / cosf(rad_latitude_1);\n  TU2 = (GDC_ECCENTRICITY * sinf(rad_latitude_2)) / cosf(rad_latitude_2);\n  CU1 = 1.0f / sqrtf((TU1 * TU1) + 1.0f);\n  SU1 = CU1 * TU1;\n  CU2 = 1.0f / sqrtf((TU2 * TU2) + 1.0f);\n  dist = CU1 * CU2;\n  BAZ = dist * TU2;\n  FAZ = BAZ * TU1;\n  X = rad_longitude_2 - rad_longitude_1;\n  do\n  {\n    SX = sinf(X);\n    CX = cosf(X);\n    TU1 = CU2 * SX;\n    TU2 = BAZ - ((SU1 * CU2) * CX);\n    SY = sqrtf((TU1 * TU1) + (TU2 * TU2));\n    CY = (dist * CX) + FAZ;\n    Y = atan2f(SY, CY);\n    SA = (dist * SX) / SY;\n    C2A = ((-SA) * SA) + 1.0f;\n    CZ = FAZ + FAZ;\n    if (C2A > 0.0f)\n      CZ = ((-CZ) / C2A) + CY;\n\n    E = ((CZ * CZ) * 2.0f) - 1.0f;\n    C = (((((((-3.0f) * C2A) + 4.0f) * GDC_FLATTENING) + 4.0f) * C2A) * GDC_FLATTENING) / 16.0f;\n    D = X;\n    X = ((((((E * CY) * C) + CZ) * SY) * C) + Y) * SA;\n    X = ((((1.0f - C) * X) * GDC_FLATTENING) + rad_longitude_2) - rad_longitude_1;\n  }\n  while (fabsf(D - X) > EPS);\n  X = sqrtf((GDC_ELLIPSOIDAL * C2A) + 1.0f) + 1.0f;\n  X = (X - 2.0f) / X;\n  C = 1.0f - X;\n  C = (((X * X) / 4.0f) + 1.0f) / C;\n  D = (((0.375f * X) * X) - 1.0f) * X;\n  X = E * CY;\n  dist = (1.0f - E) - E;\n  dist = (((((((((((((((SY * SY) * 4.0f) - 3.0f) * dist) * CZ) * D) / 6.0f) - X) * D) / 4.0f) + CZ) * SY) * D) + Y) * C) * GDC_SEMI_MINOR;\n  VC[wiID] = dist;\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/geodesic-omp/main/0"}
{"code": "for (i = 1; i <= (2048 - 2); i++)\n  for (j = 1 + ((i + 1) % 2); j <= (2048 - 2); j += 2)\n  if (((i + j) % 2) == 1)\n{\n  double b;\n  b = w * (((((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.) - A[i][j]);\n  _eps = (fabs(b) > _eps) ? (fabs(b)) : (_eps);\n  A[i][j] = A[i][j] + b;\n  if (_eps > max_eps_pt)\n  {\n    max_eps_pt = _eps;\n  }\n\n}\n\n\n\n", "pragma": "omp for private(j) private(_eps)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AVasK/SuperPCs_OpenMP/redb_2d_parallel_final/2"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"v2[%d] = %d\\n\", i, v2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/10/pvm-OpenMP-reduction/2"}
{"code": "for (j = 0, k = 0; j < (size_seq2 + 1); j++, k++)\n{\n  if ((*i) == j)\n  {\n    (*new_seq2)[*i] = '-';\n    (*scores)->mute_loc = *i;\n    j += 1;\n  }\n\n  (*new_seq2)[j] = seq2[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/5"}
{"code": "for (itr = match_li.begin(); itr != match_li.end(); itr++)\n{\n  locs1(i, 0) = itr->c1;\n  locs1(i, 1) = itr->r1;\n  locs2(i, 0) = itr->c2;\n  locs2(i, 1) = itr->r2;\n  homogeneous_loc1(i, 0) = itr->c1;\n  homogeneous_loc1(i, 1) = itr->r1;\n  homogeneous_loc1(i, 2) = 1.0;\n  homogeneous_loc2(i, 0) = itr->c2;\n  homogeneous_loc2(i, 1) = itr->r2;\n  homogeneous_loc2(i, 2) = 1.0;\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_cuda/image_stitching/3"}
{"code": "for (i = 0; i < m_ar; i++)\n{\n  for (k = 0; k < m_br; k++)\n  {\n    for (j = 0; j < m_ar; j++)\n    {\n      phc[(i * m_ar) + j] += pha[(i * m_ar) + k] * phb[(k * m_br) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danfergo/cpar/assignment/cpp/matrixprod/5"}
{"code": "for (j = 0; j < 50000000; j++)\n{\n  a[j] = 1.0;\n  b[j] = 2.0;\n  c[j] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avr-aics-riken/PMlib/doc/src_advanced/sub_copy/0"}
{"code": "for (i = 1; i < (N + 1); i++)\n{\n  if (mx[i] > max)\n    max = mx[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/second/functions/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpjvpzzzmg.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sx-aurora-dev/openmp/runtime/test/affinity/format/affinity_values/2"}
{"code": "for (i = 0; i < outdegree; i++)\n{\n  int rcount = s->rat_count[start[i]];\n  double r = imbalance(lcount, rcount);\n  sum += r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WeijiaGao49/Shared-Memory-Parallelism-with-OpenMP/code/sim/6"}
{"code": "for (i = 0; i < Size; i++)\n{\n  pVectorB[i] = distrib(gen);\n  for (j = 0; j < Size; j++)\n    pMatrix[(i * Size) + j] = distrib(gen);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savinaDaria/Cramer_rule_OpenMP/lab2OpenMP/lab2OpenMP/0"}
{"code": "for (k = 0; k < dims[2][2]; k++)\n{\n  kk = (((((k + 1) + zstart[2]) - 2) + (NZ / 2)) % NZ) - (NZ / 2);\n  indexmap[k][j][i] = (kk * kk) + ij2;\n}\n\n", "pragma": "omp parallel for firstprivate(k ,j ,ii ,ii2 ,jj ,ij2 ,kk ,indexmap ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  vector[i] = initValue;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paulpaulych/parallel_labs/Lab2/var1/1"}
{"code": "for (int i = 0; i < (limit - 1); i++)\n{\n  h_Indexes[i + 1] = h_Indexes[i] + h_prevalentSlotCounts[index][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/20"}
{"code": "for (i = 0; i < numOfThreads; i++)\n  mergeHistogram(workerHistogram, histograms[i], N);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/eladshoham1/Parallel_Computation_MPI_OpenMP_CUDA/main/3"}
{"code": "for (int i = 0; i < 11000; i++)\n  input[i] = malloc((sizeof(char)) * 1001);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par2/3"}
{"code": "for (int i = 0; i < SIZE; ++i)\n{\n  bootstrap(groupOfBoardDeques[i], i);\n  _board_deque.boardDeque.insert(_board_deque.boardDeque.end(), groupOfBoardDeques[i].boardDeque.begin(), groupOfBoardDeques[i].boardDeque.end());\n}\n\n", "pragma": "\t\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huaminghuangtw/Parallel-Sudoku-Solver/src/SudokuSolver_ParallelBruteForce/3"}
{"code": "for (int k = 0; k < Num_Of_People; ++k)\n{\n  node_ptr = array_ptr[k];\n  if (NODE_FLAG == TO_BE_INFECTED)\n  {\n    NODE_FLAG = INFECTED;\n    ++tmp_newCases;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cretanian/HY-342/OpenMP/main/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  double t = 0.0;\n  int ni = n * i;\n  for (j = 0; j < n; j++)\n  {\n    t += a[ni + j] * x[j];\n  }\n\n  z[i] = t;\n}\n\n", "pragma": "omp parallel for num_threads(nt) firstprivate(n) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KrzysiekJa/Parallel-programming-2020/lab_13/mat_vec_row_omp/moj_program/0"}
{"code": "for (k = 0; k < MINIBATCH; k++)\n{\n  for (i = 0; i < outN; i++)\n  {\n    errtemp = y[k][i] - out[k][i];\n    out_delta[k][i] = (errtemp * out[k][i]) * (1.0 - out[k][i]);\n    error += (0.5 * errtemp) * errtemp;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchParallel/11"}
{"code": "for (i = 0; i < 62; i++)\n{\n  for (j = 0; j < 7; j++)\n    for (k = 0; k < 15; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dfordivam/perf-check/haskellWithOpenMP/omp_mm/0"}
{"code": "for (int i = 0; i < alignedN; i += 16)\n  _mm512_storeu_ps(&y[i], _mm512_mul_ps(_mm512_loadu_ps(&x[i]), scalar));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/17"}
{"code": "for (int i = 0; i < 12; ++i)\n{\n  serial_frac[i] = ((1 / speed[i]) - (1 / numthd[i])) / (1 - (1 / numthd[i]));\n  (((fout << numthd[i]) << \",\") << serial_frac[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sagarbhatt0904/OpenMP/Goldbach_conjecture/goldbach_omp_d/3"}
{"code": "for (int i = 0; i < conf.nsrcs; i++)\n{\n  free(srcs[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ijpq/15418/utils/opencv/CodeSamples/lectures_code/iso/src/iso2d/2"}
{"code": "for (int x = 0; x < rowsM1; x++)\n{\n  for (int y = 0; y < colsM2; y++)\n  {\n    (cout << resul[x][y]) << \"\\t\";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejovanihh191197/MatrizXmatrizOpenMP/matrizxmatriz/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    double partial_sum = 0;\n    for (int k = 0; k < size; k++)\n    {\n      partial_sum += matrix1[(i * size) + k] * matrix2[(k * size) + j];\n    }\n\n    matrix3[(i * size) + j] = partial_sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/absurdistFrank/OpenMPFinal/Matrix/3"}
{"code": "for (size_t i = 0; i < (szx * szy); ++i)\n{\n  image[i] = temp[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WarwickRSE/OpenMPExamples/FromSlides/C/16_blur_parallel_copy/0"}
{"code": "for (i3 = 1; i3 <= (mm3 - 1); i3 += 1)\n{\n  for (i2 = d2; i2 <= (mm2 - 1); i2 += 1)\n  {\n    for (i1 = d1; i1 <= (mm1 - 1); i1 += 1)\n    {\n      u[((2 * i3) - t3) - 1][((2 * i2) - d2) - 1][((2 * i1) - d1) - 1] = u[((2 * i3) - t3) - 1][((2 * i2) - d2) - 1][((2 * i1) - d1) - 1] + (0.5 * (z[i3][i2 - 1][i1 - 1] + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n    for (i1 = 1; i1 <= (mm1 - 1); i1 += 1)\n    {\n      u[((2 * i3) - t3) - 1][((2 * i2) - d2) - 1][((2 * i1) - t1) - 1] = u[((2 * i3) - t3) - 1][((2 * i2) - d2) - 1][((2 * i1) - t1) - 1] + (0.25 * (((z[i3][i2 - 1][i1] + z[i3][i2 - 1][i1 - 1]) + z[i3 - 1][i2 - 1][i1]) + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n  }\n\n  for (i2 = 1; i2 <= (mm2 - 1); i2 += 1)\n  {\n    for (i1 = d1; i1 <= (mm1 - 1); i1 += 1)\n    {\n      u[((2 * i3) - t3) - 1][((2 * i2) - t2) - 1][((2 * i1) - d1) - 1] = u[((2 * i3) - t3) - 1][((2 * i2) - t2) - 1][((2 * i1) - d1) - 1] + (0.25 * (((z[i3][i2][i1 - 1] + z[i3][i2 - 1][i1 - 1]) + z[i3 - 1][i2][i1 - 1]) + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n    for (i1 = 1; i1 <= (mm1 - 1); i1 += 1)\n    {\n      u[((2 * i3) - t3) - 1][((2 * i2) - t2) - 1][((2 * i1) - t1) - 1] = u[((2 * i3) - t3) - 1][((2 * i2) - t2) - 1][((2 * i1) - t1) - 1] + (0.125 * (((((((z[i3][i2][i1] + z[i3][i2 - 1][i1]) + z[i3][i2][i1 - 1]) + z[i3][i2 - 1][i1 - 1]) + z[i3 - 1][i2][i1]) + z[i3 - 1][i2 - 1][i1]) + z[i3 - 1][i2][i1 - 1]) + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/25"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n    lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n    lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n    lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n    lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n    lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,dttz2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/80"}
{"code": "for (i = 0; i < n; i++)\n{\n  NWS[i][0] = i + top;\n  NWS[i][1] = cells[left].rhs + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/floorplan/src/floorplan_ompi/0"}
{"code": "for (int i = 0; i < char_offset; i++)\n  printf(\"%c\", chrs[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/10"}
{"code": "for (uint8_t i = 1; i < nLevels; i++)\n  downsampleConvolve_parallel(outPyr[i + 1], outPyr[i], &width, &height, filter, nThreads);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stranck/RealTimeLLF/src/OpenMP/openmp/5"}
{"code": "for (k = 0; k < m3[lt]; k++)\n{\n  unsigned long int _imopVarPre203;\n  void *_imopVarPre204;\n  _imopVarPre203 = m2[lt] * (sizeof(double *));\n  _imopVarPre204 = malloc(_imopVarPre203);\n  v[k] = (double **) _imopVarPre204;\n  for (j = 0; j < m2[lt]; j++)\n  {\n    unsigned long int _imopVarPre207;\n    void *_imopVarPre208;\n    _imopVarPre207 = m1[lt] * (sizeof(double));\n    _imopVarPre208 = malloc(_imopVarPre207);\n    v[k][j] = (double *) _imopVarPre208;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/3"}
{"code": "for (int ix = 0; ix < (_M + 2); ix++)\n  for (int iy = 0; iy < (K + 2); iy++)\n  spr[ix][iy] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/68"}
{"code": "for (i = 0; i < size; i++)\n{\n  x[i] = UNI;\n  y[i] = UNI;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/12"}
{"code": "for (; i < 11; i++)\n  if (salt[i] != salt_buffer[i])\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash1_fmt_plug/5"}
{"code": "for (i = 0; i < (dimensionSize + 1); i++)\n  fprintf(fp, \"w%d is--->%lf\\n\", i, AllWeights[minIndex][i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/11"}
{"code": "for (x = 0; (c >= '0') && (c <= '9'); c = getchar_unlocked())\n{\n  x = ((x << 3) + (x << 1)) + (c - '0');\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramesh-chandra-saini/Parallel_Prims_Algorithms/src/prim_hybridPMA/3"}
{"code": "for (i = 0; i < num_ts; i++)\n{\n  sum += plug_values[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Timmy93/C-PowerMonitory/read_stderr/19"}
{"code": "for (m = 0; m < np1; m++)\n{\n  f[m][j][k].Re = fft_data_local[2 * m];\n  f[m][j][k].Im = fft_data_local[(2 * m) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/LTic/local_shape_transfer/8"}
{"code": "for (i = 0; i < 30000; i++)\n  for (j = 0; j < 15; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/masotrix/OpenMP/Basics/P4/main/0"}
{"code": "for (i = 0; i < threads; i++)\n  index[i] = (i * size) / threads;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/quicksort/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  if (init == 0)\n    M.elements[i] = 0;\n  else\n    M.elements[i] = get_random_number(2, 50);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg443/Gaussian-Elimination-OpenMP/gauss_eliminate/4"}
{"code": "for (idx_t j = 0; j < J; ++j)\n{\n  mylambda[j] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/9"}
{"code": "for (int j = 0; j < (len2 + 1); j++)\n  dp[0][j] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishekcs10/openmp_practice/mod_parallel/1"}
{"code": "for (c1 = 0; c1 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c1++)\n{\n  for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n  {\n    for (c3 = 16 * c1; c3 <= ((((16 * c1) + 15) < (n + (-1))) ? ((16 * c1) + 15) : (n + (-1))); c3++)\n    {\n      for (c4 = 16 * c2; c4 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c4++)\n      {\n        X[c3][c4] = ((((double) c3) * (c4 + 1)) + 1) / n;\n        A[c3][c4] = ((((double) c3) * (c4 + 2)) + 2) / n;\n        B[c3][c4] = ((((double) c3) * (c4 + 3)) + 3) / n;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(c4, c2, c3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/adi-tile-no/0"}
{"code": "for (i = 0; i < m; i++)\n  r[i] = malloc(n * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ssvassiliev/Summer_School_OpenMP/code/mandelbrot_omp/1"}
{"code": "for (int i = 0; i < (np - (unroll - 1)); i += unroll)\n{\n  vector_sum_64(input->x, i * d, d, sup->V);\n  vector_sum_64(input->x, (i * d) + d, d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 2), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 3), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 4), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 5), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 6), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 7), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 8), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 9), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 10), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 11), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 12), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 13), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 14), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 15), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 16), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 17), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 18), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 19), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 20), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 21), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 22), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 23), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 24), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 25), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 26), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 27), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 28), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 29), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 30), d, sup->V);\n  vector_sum_64(input->x, (i * d) + (d * 31), d, sup->V);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss64comp/0"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][G_ELI_USERKEYLEN];\n  unsigned char key[1][G_ELI_USERKEYLEN];\n  int i;\n  for (i = 0; i < 1; ++i)\n    pbkdf2_sha512((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->md_salt, G_ELI_SALTLEN, cur_salt->md_iterations, master[i], G_ELI_USERKEYLEN, 0);\n\n  for (i = 0; i < 1; ++i)\n  {\n    JTR_hmac_sha512((const unsigned char *) \"\", 0, master[i], G_ELI_USERKEYLEN, key[i], G_ELI_USERKEYLEN);\n    cracked[index + i] = geli_decrypt_verify(cur_salt, key[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/geli_fmt_plug/0"}
{"code": "for (int i = 0; i < FRAMES_PER_BUFFER; i++)\n{\n  comb[i] = data->monoDelay[(posActual + i) % DELAY_SIZE] + (data->monoDelay[(monoDelayedPos + i) % DELAY_SIZE] * decay);\n}\n\n", "pragma": "    #pragma omp parallel for shared(posActual,monoDelayedPos,decay, data, comb)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SurturTawers/OpenMP-ReverbDSP/reverbParalelo/1"}
{"code": "for (int i = 0; i < number_threads; i++)\n{\n  V12.AddTo(vs12[i]);\n  V21.AddTo(vs21[i]);\n  number_switches += v_number_switches[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/7"}
{"code": "for (i = 0; i < (lm + 2); i++)\n{\n  for (j = 0; j < (n + 2); j++)\n  {\n    localbnorm += psi[i][j] * psi[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yvonnezou/Hybrid_MPI-OpenMP/Hybrid programme in single style/cfd/4"}
{"code": "for (int i = 0; i < m; i++)\n{\n  mn[i] = (unsigned long long *) malloc((sizeof(unsigned long long)) * m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpaltsai/OpenMP/project_3_omp_cg/3"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float v = vs[n];\n  float thr = Radians(ths[n]);\n  float vx = v * cos(thr);\n  float vy = v * sin(thr);\n  float g = gs[n];\n  float h = hs[n];\n  float d = ds[n];\n  float t = (-(2 * vy)) / GRAVITY;\n  float x = 0. + (vx * t);\n  if (x <= g)\n  {\n    if (DEBUG)\n      fprintf(stderr, \"Ball doesn't even reach the cliff\\n\");\n\n  }\n  else\n  {\n    t = g / vx;\n    float y = (0. + (vy * t)) + ((0.5 * GRAVITY) * (t * t));\n    if (y <= h)\n    {\n      if (DEBUG)\n        fprintf(stderr, \"Ball hits the cliff face\\n\");\n\n    }\n    else\n    {\n      float a = GRAVITY / 2.;\n      float b = vy;\n      float c = -h;\n      float disc = (b * b) - ((4.f * a) * c);\n      if (disc < 0.)\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Ball doesn't reach the upper deck.\\n\");\n\n        exit(1);\n      }\n\n      disc = sqrtf(disc);\n      float t1 = ((-b) + disc) / (2.f * a);\n      float t2 = ((-b) - disc) / (2.f * a);\n      float tmax = t1;\n      if (t2 > t1)\n        tmax = t2;\n\n      float upperDist = (vx * tmax) - g;\n      if (fabs(upperDist - d) > TOL)\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Misses the castle at upperDist = %8.3f\\n\", upperDist);\n\n      }\n      else\n      {\n        if (DEBUG)\n          fprintf(stderr, \"Hits the castle at upperDist = %8.3f\\n\", upperDist);\n\n        numHits += 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(vs, ths, gs, hs, ds, stderr) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Abhi-Balijepalli/monte-carlo-simulation/monte_carlo/0"}
{"code": "for (i = 0; i < 4; i++)\n  v[i] = i;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/garciparedes/cc-examples/parallel/openmp/uva/proof2/0"}
{"code": "for (int k = 0; k < D; k++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    dim[k] += points.at(i)->dim[k];\n  }\n\n  dim[k] = dim[k] / n;\n  tree->root->pivot[k] = dim[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/10"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  calcHalfVelocity(&velocity[i], &force[i], &velocity[i]);\n  updatePos(&pos[i], &velocity[i]);\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/2"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    s = g[j + (3 * (ny - k))];\n    g[j + (3 * (ny - k))] = 0.5 * (cimagf(g[j + (3 * k)] + s) + (crealf(g[j + (3 * k)] - s) * _Complex_I));\n    g[j + (3 * k)] = 0.5 * (crealf(g[j + (3 * k)] + s) + (cimagf(g[j + (3 * k)] - s) * _Complex_I));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/42"}
{"code": "for (i = 0; i < c_iterations; i++)\n{\n  knn_serial(ref, ref_nb, query, query_nb, dim, k, dist, ind);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/5"}
{"code": "for (i = 0; i < 2000; i++)\n  if (A[i] != nthreads)\n  res = 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/target-critical-1/2"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  for (int j = 0; j < 500; j++)\n  {\n    y[i] = a1[getIndex(i, j)] * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(THREAD_COUNT) default(none) shared(a1, x, y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/karan9360/openmp_matrix/Assignment3 /2d/2d/1"}
{"code": "for (int i = 1; i < num; i++)\n{\n  strcpy(buffer, \"FINISH \\0\");\n  MPI_Send(buffer, strlen(buffer) + 1, MPI_CHAR, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rushabhk7/Branch_and_bound/Hybrid/bnb_hybrid/1"}
{"code": "for (int i = 0; i < top; i++)\n{\n  arr[i] = vec[i].second;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengling0410/Parallelized-Movie-Recommendation/src/movierecommendation_parallel/3"}
{"code": "for (c = 0; c < size; c++)\n{\n  for (d = 0; d < size; d++)\n  {\n    for (k = 0; k < size; k++)\n    {\n      sum = sum + ((*((first + (c * size)) + k)) * (*((second + (k * size)) + d)));\n    }\n\n    *((multiply + (size * c)) + d) = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MeghanaVankadari/Gemm_parallel/gemm_omp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  int j;\n  for (j = 0; j < n; j++)\n  {\n    ++results[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(static,chunk) reduction(+:results[:10])", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulasthi/KmeansC-OpenMP/1/0"}
{"code": "for (int i = 0; i < I->egroups; i++)\n{\n  if (fabs(state_flux_device[i] - state_flux[i]) > 1e-1)\n  {\n    printf(\"%f %f\\n\", state_flux_device[i], state_flux[i]);\n    error = true;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/19"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = 1; j < (ny - 1); j++)\n  {\n    for (i = 1; i < (nx - 1); i++)\n    {\n      Anext[Index3D(nx, ny, i, j, k)] = ((((((A0[Index3D(nx, ny, i, j, k + 1)] + A0[Index3D(nx, ny, i, j, k - 1)]) + A0[Index3D(nx, ny, i, j + 1, k)]) + A0[Index3D(nx, ny, i, j - 1, k)]) + A0[Index3D(nx, ny, i + 1, j, k)]) + A0[Index3D(nx, ny, i - 1, j, k)]) * c1) - (A0[Index3D(nx, ny, i, j, k)] * c0);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Parboil/stencil/src/kernels/0"}
{"code": "for (int k = 0; k < N; k++)\n  a[k] = b[k];\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-1/no_loop_1/1"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  A[i][j] = sigmoid_prime(A[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/9"}
{"code": "for (int i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/pi_loop/0"}
{"code": "for (size_t element = world_rank; element < _numberOfSets; element = element + world_size)\n  _setsVector.push_back(Set(dimensionality, iterations, numberOfElements));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariodematties/MPI_Tests/SuperSet/0"}
{"code": "for (j = 1; j < (m - 1); j++)\n  for (i = 1; i < (n - 1); i++)\n{\n  resid = ((((ax * (uold[(i - 1) + (m * j)] + uold[(i + 1) + (m * j)])) + (ay * (uold[i + (m * (j - 1))] + uold[i + (m * (j + 1))]))) + (b * uold[i + (m * j)])) - f[i + (m * j)]) / b;\n  u[i + (m * j)] = uold[i + (m * j)] - (omega * resid);\n  error = error + (resid * resid);\n}\n\n\n", "pragma": "omp parallel for reduction(+:error) private(i,resid)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_Jacobi/c_jacobi01/1"}
{"code": "for (int i = 1; i < N; i++)\n{\n  b[i] += a[i - 1];\n  a[i] += c[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/loop_skewing/1"}
{"code": "for (int I = 0; I < m; I += BLOCK_SIZE)\n{\n  for (int J = 0; J < p; J += BLOCK_SIZE)\n  {\n    int i_max = min(m, I + BLOCK_SIZE);\n    int j_max = min(p, J + BLOCK_SIZE);\n    for (int i = I; i < i_max; i++)\n    {\n      for (int j = J; j < j_max; j++)\n      {\n        C[(i * p) + j] = 0.0;\n      }\n\n    }\n\n    for (int K = 0; K < n; K += BLOCK_SIZE)\n    {\n      int k_max = min(n, K + BLOCK_SIZE);\n      for (int i = I; i < i_max; i++)\n      {\n        for (int j = J; j < j_max; j++)\n        {\n          for (int k = K; k < k_max; k++)\n          {\n            C[(i * p) + j] += A[(i * n) + k] * B[(k * p) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for collapse(2) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/1"}
{"code": "for (i = 0; i < nparticles; i++)\n  printf(\"%lld : %lg %lg %lg\\n\", i, x[i], y[i], z[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ucyang/nbody/src/nbody_parallel/3"}
{"code": "for (k = 0; k < 8; k++)\n  printf(\"%f \", r1[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB169-missingsyncwrite-orig-yes/2"}
{"code": "for (i = 0; i < o.k; i++)\n  fprintf(f, \"%lf \\n\", o.w[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorelShoshany/Perceptron-Algorithm/hw4/work/5"}
{"code": "for (int i = lower; i < upper; i++)\n  entity += m->SquareMatrix[row][i] * m->SquareMatrix[i][column];\n\n", "pragma": "omp parallel for num_threads(num_t) reduction(+: entity)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/Parallel_2.0/0"}
{"code": "for (i = 1; i < (32 - 1); i++)\n{\n  b[i] = (a[i + 1] - a[i - 1]) / 2.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwina/five-short-openmp/stencil/0"}
{"code": "for (long i = 0; i < I.ntracks_2D; i++)\n  for (int j = 0; j < I.n_polar_angles; j++)\n  for (int k = 0; k < I.z_stacked; k++)\n  for (int g = 0; g < I.n_egroups; g++)\n{\n  params.tracks[i][j][k].f_psi[g] *= norm_factor;\n  params.tracks[i][j][k].b_psi[g] *= norm_factor;\n}\n\n\n\n\n", "pragma": "omp parallel for default(none) shared(I, params) private(norm_factor) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/4"}
{"code": "for (int row = 0; row < 2000; row++)\n{\n  for (int col = 0; col < 2000; col++)\n  {\n    double resultValue = 0;\n    for (int transNumber = 0; transNumber < 2000; transNumber++)\n    {\n      resultValue += firstMatrix[row][transNumber] * secondMatrix[transNumber][col];\n    }\n\n    matrixMultiResult[row][col] = resultValue;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) schedule(static, 4) num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LonghuaHu/openmp/Matrix_Multiple_openMP/0"}
{"code": "for (int k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 1; j <= (x_max + 2); j++)\n  {\n    node_mass_post[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = 0.25 * ((((density1[FTNREF2D(j, k - 1, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j, k - 1, x_max + 5, x_min - 2, y_min - 2)]) + (density1[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)])) + (density1[FTNREF2D(j - 1, k - 1, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j - 1, k - 1, x_max + 5, x_min - 2, y_min - 2)])) + (density1[FTNREF2D(j - 1, k, x_max + 4, x_min - 2, y_min - 2)] * post_vol[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)]));\n    node_mass_pre[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (node_mass_post[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - node_flux[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)]) + node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/5"}
{"code": "for (int p = 0; p < boxes[i].num_particles; p++)\n{\n  (*boxes[i].particles[p]).ax = 0;\n  (*boxes[i].particles[p]).ay = 0;\n  for (int p2 = 0; p2 < boxes[i].num_particles; p2++)\n  {\n    apply_force2(*boxes[i].particles[p], *boxes[i].particles[p2]);\n  }\n\n  if ((c - 1) >= 0)\n  {\n    for (int p2 = 0; p2 < boxes[i - 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[i - 1].particles[p2]);\n    }\n\n  }\n\n  if ((c + 1) < NUM_BINS_PER_SIDE)\n  {\n    for (int p2 = 0; p2 < boxes[i + 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[i + 1].particles[p2]);\n    }\n\n  }\n\n  if ((r - 1) >= 0)\n  {\n    for (int p2 = 0; p2 < boxes[i - box_size].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[i - box_size].particles[p2]);\n    }\n\n  }\n\n  if ((r + 1) < NUM_BINS_PER_SIDE)\n  {\n    for (int p2 = 0; p2 < boxes[i + box_size].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[i + box_size].particles[p2]);\n    }\n\n  }\n\n  if (((c - 1) >= 0) && ((r - 1) >= 0))\n  {\n    for (int p2 = 0; p2 < boxes[(i - box_size) - 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[(i - box_size) - 1].particles[p2]);\n    }\n\n  }\n\n  if (((c + 1) < NUM_BINS_PER_SIDE) && ((r - 1) >= 0))\n  {\n    for (int p2 = 0; p2 < boxes[(i - box_size) + 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[(i - box_size) + 1].particles[p2]);\n    }\n\n  }\n\n  if (((c - 1) >= 0) && ((r + 1) < NUM_BINS_PER_SIDE))\n  {\n    for (int p2 = 0; p2 < boxes[(i + box_size) - 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[(i + box_size) - 1].particles[p2]);\n    }\n\n  }\n\n  if (((c + 1) < NUM_BINS_PER_SIDE) && ((r + 1) < NUM_BINS_PER_SIDE))\n  {\n    for (int p2 = 0; p2 < boxes[(i + box_size) + 1].num_particles; p2++)\n    {\n      apply_force2(*boxes[i].particles[p], *boxes[(i + box_size) + 1].particles[p2]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yuchaoran2011/particles-OpenMP-simulation/openmp/1"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  for (j = i + 1; j < n; j++)\n  {\n    double temp = A[(j * n) + i] / A[(i * n) + i];\n    for (k = i; k < n; k++)\n    {\n      A[(j * n) + k] -= temp * A[(i * n) + k];\n    }\n\n    b[j] -= temp * b[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/18"}
{"code": "for (int i = 0; i < colNumX; i++)\n{\n  XmatVecTemp = Xmat.col(i);\n  Sigma_iX1.col(i) = getPCG1ofSigmaAndVector_sparse(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG, phi, nThreads) / M;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/15"}
{"code": "for (j = i * i; j <= N; j = j + i)\n{\n  primes[j] = 0;\n}\n\n", "pragma": "omp parallel for shared(primes)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/sieve_of_erastosthenes_openmp/0"}
{"code": "for (int j = 0; j < GLOBAL_SIZE; j++)\n  out2[j] = out[j];\n\n", "pragma": "#pragma omp target parallel for map(from: out2[0:GLOBAL_SIZE]) map(to: out[0:GLOBAL_SIZE])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/examples/cloc/vector_copy_hip_omp/vector_copy/1"}
{"code": "for (int i = 0; i < itemNum; i++)\n{\n  if (info[i][0].section('.', 2, 2) == \"close\")\n  {\n    tmp1.clear();\n    for (int j = 0; j < 25; j++)\n    {\n      tmp1.append(info[i][j]);\n    }\n\n    pixelList2.append(tmp1);\n    infoNum++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/9"}
{"code": "for (i = 0; i < nparticles; i++)\n{\n  x[i] = x_tmp[i];\n  y[i] = y_tmp[i];\n  z[i] = z_tmp[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ucyang/nbody/src/nbody_parallel/1"}
{"code": "for (i = 0; i < 1500; i++)\n{\n  for (j = 0; j < 1500; j++)\n    C[i][j] = 0.0;\n\n  B_T[i][j] = 0.0;\n  transp_res[i][j] = 0.0;\n  seq_res[i][j] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/omikulkarni02/OpenMP-Matrix-Multiplication/matrix_multiplication/8"}
{"code": "for (c1 = (ni > nj) ? (ni) : (nj); c1 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/77"}
{"code": "for (m = 0; m < 5; m++)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (tx2 * (flux[i + 1][j][k][m] - flux[i - 1][j][k][m]));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/71"}
{"code": "for (i = 0; i < sendcounts[taskid]; i++)\n{\n  localMatrix[l][c] = rec_buf[i];\n  c++;\n  if (((i + 1) % 3000) == 0)\n  {\n    l++;\n    c = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/11"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      vk[j][i][m] = vk[j][i][m] - (omega * (((((ldz[j][i][0][m] * vkm1[j][i][0]) + (ldz[j][i][1][m] * vkm1[j][i][1])) + (ldz[j][i][2][m] * vkm1[j][i][2])) + (ldz[j][i][3][m] * vkm1[j][i][3])) + (ldz[j][i][4][m] * vkm1[j][i][4])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/blts/0"}
{"code": "for (i = 0; i < N; i += N / 8)\n{\n  for (j = 0; j < N; j += N / 8)\n  {\n    printf(\"%.2f \", g[0][i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/openmp/6"}
{"code": "for (int i = 0; i < num_splines; i++)\n  destroy_Bspline(norm_splines[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/6"}
{"code": "for (i = 0; i < nStudents; i++)\n{\n  sorted[grades[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fvvsantana/gradesAnalyzer-OpenMP/mpi/statisticspar/5"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at1 = crealf(ffc[j]) * cimagf(ffc[j]);\n  at2 = (at1 * dnx) * ((float) j);\n  zt1 = cimagf(q[j]) - (crealf(q[j]) * _Complex_I);\n  fxy[2 * j] = at2 * zt1;\n  fxy[1 + (2 * j)] = zero;\n  fxy[(2 * j) + k1] = zero;\n  fxy[(1 + (2 * j)) + k1] = zero;\n  wp += at1 * (q[j] * conjf(q[j]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/12"}
{"code": "for (int i = 0; i < aSize; i++)\n{\n  if (a[i] == value)\n    return true;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  pi[i] = i;\n  for (int j = 0; j < n; j++)\n  {\n    fscanf(file, \"%lf\", &a[(i * n) + j]);\n    a_copy[(i * n) + j] = a[(i * n) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/5"}
{"code": "for (i = 0; i < 10; ++i)\n  main1();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/omp-loop01/9"}
{"code": "for (i = 0; i < ((phi_max_index + 1) - phi_min_index); i++)\n{\n  for (j = 0; j < ((theta_max_index + 1) - theta_min_index); j++)\n  {\n    for (k = 0; k < ((r_max_index + 1) - r_min_index); k++)\n    {\n      r_index = r_min_index + k;\n      theta_index = theta_min_index + j;\n      phi_index = phi_min_index + i;\n      dr_index = adjusted_remapping_index + k;\n      hydro_index = (((i * ((r_max_index + 1) - r_min_index)) * ((theta_max_index + 1) - theta_min_index)) + (j * ((r_max_index + 1) - r_min_index))) + k;\n      if (ph_inj_switch == 0)\n      {\n        if (((ph_rmin - ((elem_factor * C_LIGHT) / fps)) < (*(r_unprc + r_index))) && ((*(r_unprc + r_index)) < (ph_rmax + ((elem_factor * C_LIGHT) / fps))))\n        {\n          (*pres)[elem] = *(pres_unprc + hydro_index);\n          (*dens)[elem] = *(dens_unprc + hydro_index);\n          (*temp)[elem] = pow(((3 * (*(pres_unprc + hydro_index))) * pow(C_LIGHT, 2.0)) / A_RAD, 1.0 / 4.0);\n          (*gamma)[elem] = pow(pow(1.0 - ((pow(*(vel_r_unprc + hydro_index), 2) + pow(*(vel_theta_unprc + hydro_index), 2)) + pow(*(vel_phi_unprc + hydro_index), 2)), 0.5), -1);\n          (*dens_lab)[elem] = (*(dens_unprc + hydro_index)) * pow(pow(1.0 - ((pow(*(vel_r_unprc + hydro_index), 2) + pow(*(vel_theta_unprc + hydro_index), 2)) + pow(*(vel_phi_unprc + hydro_index), 2)), 0.5), -1);\n          (*r)[elem] = *(r_unprc + r_index);\n          (*theta)[elem] = *(theta_unprc + theta_index);\n          (*phi)[elem] = *(phi_unprc + phi_index);\n          (*x)[elem] = ((*(r_unprc + r_index)) * sin(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index));\n          (*y)[elem] = ((*(r_unprc + r_index)) * sin(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index));\n          (*z)[elem] = (*(r_unprc + r_index)) * cos(*(theta_unprc + theta_index));\n          (*szx)[elem] = *(dr + dr_index);\n          (*szy)[elem] = M_PI / 560;\n          (*velx)[elem] = ((((*(vel_r_unprc + hydro_index)) * sin(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index))) + (((*(vel_theta_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index)))) - ((*(vel_phi_unprc + hydro_index)) * sin(*(phi_unprc + phi_index)));\n          (*vely)[elem] = ((((*(vel_r_unprc + hydro_index)) * sin(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index))) + (((*(vel_theta_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index)))) + ((*(vel_phi_unprc + hydro_index)) * cos(*(phi_unprc + phi_index)));\n          (*velz)[elem] = ((*(vel_r_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) - ((*(vel_theta_unprc + hydro_index)) * sin(*(theta_unprc + theta_index)));\n          elem++;\n        }\n\n      }\n      else\n      {\n        if (((r_inj - ((elem_factor * C_LIGHT) / fps)) < (*(r_unprc + r_index))) && ((*(r_unprc + r_index)) < (r_inj + ((elem_factor * C_LIGHT) / fps))))\n        {\n          (*pres)[elem] = *(pres_unprc + hydro_index);\n          (*dens)[elem] = *(dens_unprc + hydro_index);\n          (*temp)[elem] = pow(((3 * (*(pres_unprc + hydro_index))) * pow(C_LIGHT, 2.0)) / A_RAD, 1.0 / 4.0);\n          (*gamma)[elem] = pow(pow(1.0 - ((pow(*(vel_r_unprc + hydro_index), 2) + pow(*(vel_theta_unprc + hydro_index), 2)) + pow(*(vel_phi_unprc + hydro_index), 2)), 0.5), -1);\n          (*dens_lab)[elem] = (*(dens_unprc + hydro_index)) * pow(pow(1.0 - ((pow(*(vel_r_unprc + hydro_index), 2) + pow(*(vel_theta_unprc + hydro_index), 2)) + pow(*(vel_phi_unprc + hydro_index), 2)), 0.5), -1);\n          (*r)[elem] = *(r_unprc + r_index);\n          (*theta)[elem] = *(theta_unprc + theta_index);\n          (*phi)[elem] = *(phi_unprc + phi_index);\n          (*x)[elem] = ((*(r_unprc + r_index)) * sin(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index));\n          (*y)[elem] = ((*(r_unprc + r_index)) * sin(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index));\n          (*z)[elem] = (*(r_unprc + r_index)) * cos(*(theta_unprc + theta_index));\n          (*szx)[elem] = *(dr + dr_index);\n          (*szy)[elem] = M_PI / 560;\n          (*velx)[elem] = ((((*(vel_r_unprc + hydro_index)) * sin(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index))) + (((*(vel_theta_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) * cos(*(phi_unprc + phi_index)))) - ((*(vel_phi_unprc + hydro_index)) * sin(*(phi_unprc + phi_index)));\n          (*vely)[elem] = ((((*(vel_r_unprc + hydro_index)) * sin(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index))) + (((*(vel_theta_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) * sin(*(phi_unprc + phi_index)))) + ((*(vel_phi_unprc + hydro_index)) * cos(*(phi_unprc + phi_index)));\n          (*velz)[elem] = ((*(vel_r_unprc + hydro_index)) * cos(*(theta_unprc + theta_index))) - ((*(vel_theta_unprc + hydro_index)) * sin(*(theta_unprc + theta_index)));\n          elem++;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib_3d/3"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = xvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/reset_field_kernel_c/2"}
{"code": "for (i = 0; i < (H - h); i++)\n{\n  for (j = 0; j < (W - w); j++)\n  {\n    sadValue = 0;\n    for (m = 0; m < h; m++)\n    {\n      for (n = 0; n < w; n++)\n      {\n        sadValue += abs(img[((i + m) * W) + (j + n)] - im_crop[(m * w) + n]);\n      }\n\n    }\n\n    if (sadValue < min_val)\n    {\n      min_val = sadValue;\n      idx_i = i;\n      idx_j = j;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhattagoutham/parallel-programming/2_template_matching/sad_omp/2"}
{"code": "for (int i = 0; i < MAT_ROWS; i++)\n{\n  for (int j = 0; j < MAT_COLS; j++)\n  {\n    printf(\"%4d \", result[(i * MAT_COLS) + j]);\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/psattiza/matrixMult/main/6"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    temp = u[i][j];\n    error = error + (temp * temp);\n  }\n\n}\n\n", "pragma": "omp parallel for private (temp,i,j) reduction (+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_reduction_2/0"}
{"code": "for (i = 0; i < M; i = i + 1)\n{\n  for (j = 0; j < M; j++)\n  {\n    r = 0.0;\n    indice_ligne = i * M;\n    for (k = 0; k < M; k = k + 2)\n    {\n      av2 = _mm_load_pd((A + indice_ligne) + k);\n      bv2 = _mm_load_pd((B + indice_ligne) + k);\n      dot = _mm_dp_pd(av2, bv2, 0xFF);\n      _mm_store_pd(R2, dot);\n      r = r + R2[0];\n    }\n\n    C[indice_ligne + j] = (alpha * r) + (beta * C[indice_ligne + j]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) private(i,j,k,l,av2, bv2, dot, R2,r,indice_ligne)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemm/10"}
{"code": "for (int i = 0; i < particle_num; ++i)\n{\n  particles[i].ax = (particles[i].ay = 0);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nlyu/Project_particle_simulation/openmp/8"}
{"code": "for (a = TOPEF - 1; a > 0; --a)\n{\n  if (v2[a - 1] > v2[a])\n  {\n    t = v2[a - 1];\n    v2[a - 1] = v2[a];\n    v2[a] = t;\n    exchange = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/3"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  mediaAritmeticaVecinos[j] = (dias[indiceDiaMAPEMasBajo + 1][j] + dias[indiceDiaMAPEMasBajo + 2][j]) / 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quiquemachado5/Prediccion-series-temporales-OpenMP-MPI/AlgoritmoProyectoSDFicherosMPIfin/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  cout << endl;\n  for (int k = 0; k < o; k++)\n  {\n    A[i][k] = rand() % 100;\n    (cout << A[i][k]) << \" \";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task2/0"}
{"code": "for (int i = 0; i < desc.size(); i++)\n{\n  stdev_nom += pow(desc[i] - mean, 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zon5566/SIFT-on-OpenMP/sift/7"}
{"code": "for (int i = 0; i < Nx; i++)\n  un[i] = (double *) malloc(Ny * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/3"}
{"code": "for (i = 1; i <= 1000000; i = i + 1)\n{\n  buyerIndex = rand() % 10000;\n  bidPrice = (rand() % Buyers[buyerIndex].value) + 1;\n  sellerIndex = rand() % 10000;\n  askPrice = Sellers[sellerIndex].value + (rand() % ((20 - Sellers[sellerIndex].value) + 1));\n  if (((Buyers[buyerIndex].quantityHeld == 0) && (Sellers[sellerIndex].quantityHeld == 1)) && (bidPrice >= askPrice))\n  {\n    transactionPrice = askPrice + (rand() % ((bidPrice - askPrice) + 1));\n    Buyers[buyerIndex].price = transactionPrice;\n    Sellers[sellerIndex].price = transactionPrice;\n    Buyers[buyerIndex].quantityHeld = 1;\n    Sellers[sellerIndex].quantityHeld = 0;\n  }\n\n  ;\n}\n\n", "pragma": "omp parallel for private(buyerIndex, bidPrice, sellerIndex, askPrice, transactionPrice) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp1/0"}
{"code": "for (int i = 0; i < height; ++i)\n{\n  ret[i] = row + (i * width);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yduman/qt-image-processing/src/algorithms/CartoonizeOMP/0"}
{"code": "for (int i = 0; i < length; i++)\n{\n  omp_set_lock(&lock);\n  total += array[i];\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex10/1"}
{"code": "for (i = 0; i < mat1_1d; i++)\n{\n  for (j = 0; j < mat1_2d; j++)\n  {\n    scanf(\"%lf\", &matr1[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/april314/matr-mult-open-mp/matrmulp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = 2 * a[i];\n  printf(\"b[%d] = %d\\n\", i, b[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mishal23/parallel-programming-openmp/work-sharing-constructs/parallel-loop-barrier/1"}
{"code": "for (unsigned int i = 0; i < pgm->height; i++)\n{\n  printf(\"\\n\");\n  for (unsigned int j = 0; j < pgm->width; j++)\n  {\n    temp = (unsigned int) pgm->data[i][j];\n    fprintf(pgm_file, \"%c\", temp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FeedehC/openmp-img-patterns/src/main/2"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  struct tablo *recievedMatrix = allocateTablo((dim / numprocs) * dim);\n  recievedMatrix->tab = recieve_slice(i, recievedMatrix->size);\n  recievedMatrix->nb_rows = dim / numprocs;\n  recievedMatrix->nb_cols = dim;\n  fillFinalMatrix(finalMatrix, recievedMatrix, (i * dim) / numprocs);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/15"}
{"code": "for (int k = 0; k < factorial(N); ++k)\n{\n  (route_iterator < N) > rit(k);\n  rit.print();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pkestene/tsp/openmp/tsp/0"}
{"code": "for (j = data->iRowFirst + 1; j <= (data->iRowLast - 1); j++)\n{\n  for (i = data->iColFirst + 1; i <= (data->iColLast - 1); i++)\n  {\n    fLRes = ((((ax * (uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + ((i - 1) - data->iColFirst)] + uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + ((i + 1) - data->iColFirst)])) + (ay * (uold[(((j - 1) - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] + uold[(((j + 1) - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)]))) + (b * uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)])) - afF[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)]) / b;\n    afU[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] = uold[((j - data->iRowFirst) * ((data->iColLast - data->iColFirst) + 1)) + (i - data->iColFirst)] - (data->fRelax * fLRes);\n    residual += fLRes * fLRes;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, i, fLRes) reduction(+:residual)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KevinMTO/Helmholtz-ACC/cart/advanced/0"}
{"code": "for (int cout = 0; cout < Cout; ++cout)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    ATM[((cout * 12) + (0 * 4)) + j] = (M[((cout * 16) + (0 * 4)) + j] + M[((cout * 16) + (1 * 4)) + j]) + M[((cout * 16) + (2 * 4)) + j];\n    ATM[((cout * 12) + (2 * 4)) + j] = (M[((cout * 16) + (1 * 4)) + j] - M[((cout * 16) + (2 * 4)) + j]) - M[((cout * 16) + (3 * 4)) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/winograd_transform/4"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    mass_flux_x[FTNREF2D((x_max + 1) + j, k, x_max + 5, x_min - 2, y_min - 2)] = -mass_flux_x[FTNREF2D((x_max + 1) - j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/51"}
{"code": "for (int i = 0; i < array1.size(); i++)\n{\n  scalar_product = scalar_product + (array1[i] * array2[i]);\n}\n\n", "pragma": "#pragma omp parallel for shared(array1, array2) reduction(+:scalar_product) default(none) num_threads(threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail11235/openmp/scalar_product/6"}
{"code": "for (row = xoffset; row < (xoffset + myxsize); row++)\n{\n  for (col = yoffset; col < (yoffset + myysize); col++)\n  {\n    u[0][row + 1][col + 1] = s[0][row][col];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/1"}
{"code": "for (int e = 0; e < V; e++)\n{\n  bf_graph->edge_array[e + gr->E] = Edge(V, e);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/johnson/6"}
{"code": "for (y = 2; y < (in->y - 2); y++)\n{\n  for (x = 2; x < (in->x - 2); x++)\n  {\n    int gridCounter = 0;\n    int finalR = 0;\n    int finalG = 0;\n    int finalB = 0;\n    for (y2 = -2; y2 <= 2; y2++)\n    {\n      for (x2 = -2; x2 <= 2; x2++)\n      {\n        finalR += in->data[((y + y2) * width) + (x + x2)].red * filter[gridCounter];\n        finalG += in->data[((y + y2) * width) + (x + x2)].green * filter[gridCounter];\n        finalB += in->data[((y + y2) * width) + (x + x2)].blue * filter[gridCounter];\n        gridCounter++;\n      }\n\n    }\n\n    finalR /= div;\n    finalG /= div;\n    finalB /= div;\n    out->data[(y * width) + x].red = finalR;\n    out->data[(y * width) + x].green = finalG;\n    out->data[(y * width) + x].blue = finalB;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Oneloves/Introduction-to-OpenMP/OpenMP/OpenMP/OpenMP/1"}
{"code": "for (i = 0; i < 2000000000; i++)\n{\n  x = (i + 0.5) * interval_width;\n  pi += 1.0 / ((x * x) + 1.0);\n}\n\n", "pragma": "omp parallel for reduction(+:pi) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/pireduction-orig-no/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  vector[i] = (rand() % MAX_VAL) + MIN_VAL;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/PerfTool/MXVPerfTool/0"}
{"code": "for (i = 0; i < NUM_OF_NODES; i++)\n{\n  double sum = 0;\n  for (j = 0; j < NUM_OF_NODES; j++)\n  {\n    sum += E[i][j];\n  }\n\n  if (sum > 0)\n  {\n    for (j = 0; j < NUM_OF_NODES; j++)\n    {\n      E[i][j] /= sum;\n    }\n\n    d[i] = 0;\n  }\n  else\n    if (sum == 0)\n  {\n    d[i] = 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anapt/PageRank/src/parallel/6"}
{"code": "for (size_t i = 0; i < (total_size / single_chunk_size); i++)\n{\n  bench_code(dst + (i * single_chunk_size));\n}\n\n", "pragma": "      #pragma omp parallel for num_threads(num_threads) if (num_threads > 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/14"}
{"code": "for (int i = 0; i < matrixN; i++)\n{\n  for (int j = 0; j < matrixN; j++)\n  {\n    (((cout << right) << setw(5)) << setfill(' ')) << Mat[i][j];\n  }\n\n  if (i != (matrixN - 1))\n  {\n    (cout << \" ]\") << endl;\n    cout << \" [\";\n  }\n  else\n  {\n    (cout << \" ]]\") << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buchacha/openMPTasks/3/3/0"}
{"code": "for (i = start_frame; i < last_frame; i = i + increment)\n{\n  fprintf(fPtr, \"Merging files for frame: %d\\n\", i);\n  fflush(fPtr);\n  if (((riken_switch == 1) && (dim_switch == 1)) && (i >= 3000))\n  {\n    increment = 10;\n  }\n\n  for (j = 0; j < num_files; j = j + 1)\n  {\n    switch (j)\n    {\n      case 0:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P0\");\n        break;\n\n      case 1:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P1\");\n        break;\n\n      case 2:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P2\");\n        break;\n\n      case 3:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"P3\");\n        break;\n\n      case 4:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R0\");\n        break;\n\n      case 5:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R1\");\n        break;\n\n      case 6:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"R2\");\n        break;\n\n      case 7:\n        snprintf(mcdata_type, sizeof(mcdata_type), \"%s\", \"NS\");\n        break;\n\n    }\n\n    for (k = 0; k < numprocs; k++)\n    {\n      snprintf(file_no_thread_num, sizeof(file_no_thread_num), \"%s%s%d%s%s%s\", dir, \"mcdata_\", i, \"_\", mcdata_type, \".dat\");\n      snprintf(filename_k, sizeof(filename_k), \"%s%s%d%s%s%s%d%s\", dir, \"mcdata_\", i, \"_\", mcdata_type, \"_\", k, \".dat\");\n      if (access(filename_k, F_OK) != (-1))\n      {\n        snprintf(cmd, sizeof(cmd), \"%s%s %s%s\", \"cat \", filename_k, \" >> \", file_no_thread_num);\n        system(cmd);\n      }\n\n      snprintf(cmd, sizeof(cmd), \"%s%s\", \"rm \", filename_k);\n      system(cmd);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib/16"}
{"code": "for (int i = 0; i < counterTid; i++)\n  for (int j = 0; j < 256; j++)\n  histogram[j] += histograms[i][j];\n\n\n", "pragma": "omp parallel for reduction(+:histogram[:ARRAY_HISTOGRAM_SIZE])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShalevSaban/Histogram-CUDA-MPI-OPENMP/openMpFuncs/0"}
{"code": "for (col = 1; col < LX1; col++)\n{\n  tmor[col][0] = tmor[col][0] + temp[col][0];\n  for (j = 0; j < LX1; j++)\n  {\n    for (i = 1; i < (LX1 - 1); i++)\n    {\n      tmor[col][j] = tmor[col][j] + (qbnew[0][j][i - 1] * temp[col][i]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/20"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_sd[i] = m_depCo * m_depCap[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/DEP_LINSLEY/DepressionLinsley/0"}
{"code": "for (i_imopVar79 = 1; i_imopVar79 < (grid_points[0] - 1); i_imopVar79++)\n{\n  for (j_imopVar80 = 1; j_imopVar80 < (grid_points[1] - 1); j_imopVar80++)\n  {\n    for (k_imopVar81 = 1; k_imopVar81 < (grid_points[2] - 1); k_imopVar81++)\n    {\n      for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n      {\n        forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = (-1.0) * forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/6"}
{"code": "for (int y = 0; y < n; y++)\n{\n  x[y] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/doddapanenipurna/GaussianProcessRegression/gpr/9"}
{"code": "for (i = 2; i < 10; i++)\n{\n  double serial_start_time;\n  double serial_end_time;\n  double parallel_start_time;\n  double parallel_end_time;\n  serial_start_time = omp_get_wtime();\n  serial(x, y);\n  serial_end_time = omp_get_wtime();\n  parallel_start_time = omp_get_wtime();\n  parallel(x, y, i);\n  parallel_end_time = omp_get_wtime();\n  printf(\"%d\\t%lf\\t%lf\\t%lf\\n\", i, (serial_end_time - serial_start_time) * 1000, (parallel_end_time - parallel_start_time) * 1000, (parallel_end_time - parallel_start_time) / (serial_end_time - serial_start_time));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/daxpy-loop/3"}
{"code": "for (i = 0; i < 512; i++)\n{\n  X[i] = Y[i] + Z[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/exo2/1"}
{"code": "for (i = 0; i < (1 << TOTAL_KEYS_LOG_2); i++)\n  key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/51"}
{"code": "for (int i = 0; i < half; i++)\n{\n  for (int j = 0; j < half; j++)\n  {\n    A11[(i * half) + j] = A[(i * n) + j];\n    A12[(i * half) + j] = A[(i * n) + (j + half)];\n    A21[(i * half) + j] = A[((i + half) * n) + j];\n    A22[(i * half) + j] = A[((i + half) * n) + (j + half)];\n    B11[(i * half) + j] = B[(i * n) + j];\n    B12[(i * half) + j] = B[(i * n) + (j + half)];\n    B21[(i * half) + j] = B[((i + half) * n) + j];\n    B22[(i * half) + j] = B[((i + half) * n) + (j + half)];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_strassen/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"This is iter: %d handled by thread: %d out of %d \\n\", i, tid, nth);\n}\n\n", "pragma": "omp for schedule (static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Yogesh17IITM/OpenMP-Tutorial/Basic OpenMP Codes/8_Static/0"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vVelocityV[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/53"}
{"code": "for (iter = 0; iter < numOfImages; iter++)\n{\n  boxBlur(imageArray, outImageArray, w, h, blurSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrchowmein/Cuda_Comparison/openMPBlur/1"}
{"code": "for (i = 0; i < (((L / NODESX) + 2) / 2); i++)\n{\n  for (j = 0; j < ((L / NODESY) + 2); j++)\n  {\n    whites[i][j].data = 0;\n    blacks[i][j].data = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/146"}
{"code": "for (n_threads = 2; n_threads <= NUM_MAX_THREADS; n_threads = +2)\n{\n  int i;\n  double init_time;\n  double end_time;\n  srand(time(0));\n  double **M1;\n  double **M2;\n  double **MULT;\n  int m;\n  int n;\n  int p = 0;\n  m = 100;\n  n = 100;\n  p = 100;\n  M1 = (double **) malloc(m * (sizeof(double *)));\n  for (i = 0; i < m; ++i)\n    M1[i] = (double *) malloc(n * (sizeof(double)));\n\n  M2 = (double **) malloc(n * (sizeof(double *)));\n  for (i = 0; i < n; ++i)\n    M2[i] = (double *) malloc(p * (sizeof(double)));\n\n  MULT = (double **) malloc(m * (sizeof(double *)));\n  for (i = 0; i < m; ++i)\n    MULT[i] = (double *) malloc(p * (sizeof(double)));\n\n  fillMatrix(M1, m, n);\n  fillMatrix(M2, n, p);\n  int threads = 8;\n  init_time = current_time();\n  pararell_multiplication(MULT, M1, M2, m, n, p);\n  end_time = current_time();\n  printf(\"Time->[%f], Num threads->[%d] \\n\", end_time - init_time, threads);\n  free(M1);\n  free(M2);\n  free(M3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/matrix_multiplication/1"}
{"code": "for (int i = 3; (i * i) <= to; i += 2)\n{\n  if ((i >= (3 * 3)) && ((i % 3) == 0))\n    continue;\n\n  if ((i >= (5 * 5)) && ((i % 5) == 0))\n    continue;\n\n  if ((i >= (7 * 7)) && ((i % 7) == 0))\n    continue;\n\n  if ((i >= (11 * 11)) && ((i % 11) == 0))\n    continue;\n\n  if ((i >= (13 * 13)) && ((i % 13) == 0))\n    continue;\n\n  int minJ = (((from + i) - 1) / i) * i;\n  if (minJ < (i * i))\n    minJ = i * i;\n\n  if ((minJ & 1) == 0)\n    minJ += i;\n\n  for (int j = minJ; j <= to; j += 2 * i)\n  {\n    int index = j - from;\n    isPrime[index / 2] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketthakare/sieve-of-eratosthenes/sieve-v-40/0"}
{"code": "for (int i = lo; i < hi; i++)\n{\n  culmulative += W(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JuliaCao/k_means_pp/omp/omp/1"}
{"code": "for (i = 0; i < A->nrow; i++)\n{\n  A->rowStart[i] = i;\n  A->colIndex[i] = i;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/cg/5"}
{"code": "for (int m = 0; m < max_neighbor; ++m)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    xx_new[(m * n) + i] = model.xx[(i * max_neighbor) + m];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lsqt-omp/hamiltonian/3"}
{"code": "for (i = 0; i < Xs->dim; i++)\n  v_set_val(YY, i, v_get_val(Ys, i) * v_get_val(Ys, i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/29"}
{"code": "for (i = 0; i <= (NQ - 1); i++)\n  q[i] += qq[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/EP/ep/6"}
{"code": "for (int i = 0; i < Wx.size(); i++)\n{\n  for (int j = 0; j < Wx[0].size(); j++)\n  {\n    Wx[i][j] = Wx_temp[k];\n    k++;\n  }\n\n}\n\n", "pragma": "    \t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_4_final/3"}
{"code": "for (i = 0; i < 9; i += 2)\n{\n  for (j = 0; j < 9; j++)\n    sumTot += mat[i][j];\n\n}\n\n", "pragma": "omp parallel for collapse(2) reduction(+:sumTot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/Esercizio2/0"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  start_time = omp_get_wtime();\n  compute_mat_ser();\n  run_time += omp_get_wtime() - start_time;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kidharb/openmp/matmul/0"}
{"code": "for (int ii = 0; ii < N; ii++)\n  myS += array[ii];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/01d_array_sum/0"}
{"code": "for (; i < ((r2 - r1) / 2); i++)\n  swap(townsOrder[r1 + i], townsOrder[r2 - i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/9"}
{"code": "for (i = 0; i <= 10; i++)\n{\n  x = i;\n  printf(\"N\u00famero da thread: %d    x: %d\\n\", omp_get_thread_num(), x);\n}\n\n", "pragma": "omp parallel for lastprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_lastprivate/0"}
{"code": "for (size_t i = 0; i < tokens.size(); i++)\n{\n  if (tokens[i][0] == '#')\n  {\n    tokens.resize(i);\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/ShapePack/3"}
{"code": "for (i = 0; i < s1_n; i++)\n{\n  for (j = 0; j < mr_m; j++)\n  {\n    sum = 0;\n    for (k = 0; k < s2_n; k++)\n    {\n      sum += (*mat1)[(i * s2_n) + k] * (*mat2)[(k * mr_m) + j];\n    }\n\n    (*m_res)[(i * mr_m) + j] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/base_mul_matrix/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x = MY_random();\n  y = MY_random();\n  if (((x * x) + (y * y)) <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "#pragma omp parallel for private(x,y) reduction(+:Ncirc)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/pi/lab_pi_lcg_rnd/pi_lcg_rnd/0"}
{"code": "for (i = 0; i < 205; i++)\n{\n  glColor3f(1.0f, 0.0f, 0.0f);\n  glVertex3f(Shuffled_galaxysParticles[i].position_x, Shuffled_galaxysParticles[i].position_y, Shuffled_galaxysParticles[i].position_z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnouarWalziki/Galaxeirb/1024_particles_OpenMP/src/main/3"}
{"code": "for (nedges = 0, vi = 0; vi < nvtxs; vi++)\n{\n  for (ei = xadj[vi], eiend = xadj[vi + 1]; ei < eiend; ei++)\n  {\n    if (adjwgt[ei] > 0)\n    {\n      aii[xaii[vi].start].vj = adjncy[ei];\n      aii[xaii[vi].start].inc = 1;\n      aii[xaii[vi].start].dec = 1;\n      ids[xaii[vi].start] = nedges;\n      edges[nedges].eij = xaii[vi].start++;\n      nedges++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/kt/24"}
{"code": "for (i = 0; i < num_elements; i++)\n{\n  rand_nums[i] = rand() / ((float) 32767);\n}\n\n", "pragma": "omp parallel for num_threads(n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/Combining OpenMP and MPI/average/0"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  reverse_col[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/116"}
{"code": "for (int i = upXstart; i <= xend; i++)\n  for (int j = ybeg; j <= yend; j++)\n  for (int k = zbeg; k <= zend; k++)\n{\n  populate_cell_with_particles(i, j, k, q_per_particle, dx_per_pcl, dy_per_pcl, dz_per_pcl);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/14"}
{"code": "for (i = rb; i < re; i++)\n  p_d[0][i] = p_zw[i] - p_u[i];\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/33"}
{"code": "for (int j = 0; j < NUMHID; j++)\n{\n  for (int i = 0; i < NUMIN; i++)\n    SumH += tSet[p][i] * WeightIH[j][i];\n\n  Hidden[j] = 1.0 / (1.0 + exp(-SumH));\n  SumH = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Raptorino/NeuralNetworkMIMD/Code_OpenMP/nn-main/1"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    wp[i][j] = 0.25 * (((up[i - 1][j] + up[i + 1][j]) + up[i][j - 1]) + up[i][j + 1]);\n    if (my_diff < fabs(wp[i][j] - up[i][j]))\n      my_diff = fabs(wp[i][j] - up[i][j]);\n\n  }\n\n}\n\n", "pragma": "omp for schedule(OMP_SCHED)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/Jacobi/0"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  long adj1 = vtxPtr[i];\n  long adj2 = vtxPtr[i + 1];\n  for (long j = adj1; j < adj2; j++)\n  {\n    fprintf(out, \"%ld %ld\\n\", i, vtxInd[j].tail);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/6"}
{"code": "for (int i = ST; i < N; i++)\n  for (int j = ST; j < N; j++)\n  for (int k = ST; k < N; k++)\n  foo();\n\n\n\n", "pragma": "#pragma omp for ordered(N) collapse(N + 2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_ordered_clause/0"}
{"code": "for (int i = 0; i < nNeighWall.size(); i++)\n  (cout << nNeighWall[i]) << \", \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/PolygonMesh/7"}
{"code": "for (i = 0; i < k; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp parallel for private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/vector_add/0"}
{"code": "for (it = 0; it < total_its; it++)\n  omp_offloading_start(__off_info__, it == (total_its - 1));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jiawen11/OpenCL-OpenMP-Cuda-and-Rodinia/offomp/benchmarks/matmul/matmul_mdev/1"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  frct[i][j][k][0] = frct[i][j][k][0] + ((dx1 * tx1) * ((rsd[i - 1][j][k][0] - (2.0 * rsd[i][j][k][0])) + rsd[i + 1][j][k][0]));\n  frct[i][j][k][1] = (frct[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((rsd[i - 1][j][k][1] - (2.0 * rsd[i][j][k][1])) + rsd[i + 1][j][k][1]));\n  frct[i][j][k][2] = (frct[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((rsd[i - 1][j][k][2] - (2.0 * rsd[i][j][k][2])) + rsd[i + 1][j][k][2]));\n  frct[i][j][k][3] = (frct[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((rsd[i - 1][j][k][3] - (2.0 * rsd[i][j][k][3])) + rsd[i + 1][j][k][3]));\n  frct[i][j][k][4] = (frct[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((rsd[i - 1][j][k][4] - (2.0 * rsd[i][j][k][4])) + rsd[i + 1][j][k][4]));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,iend1 ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/23"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    wijk = ws[i][j][k];\n    wp1 = ws[i][j][k + 1];\n    wm1 = ws[i][j][k - 1];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private (wijk,wp1,wm1,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/114"}
{"code": "for (long long i = 0; i < 'z'; i += 1u)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/5"}
{"code": "for (i = 0; i < vp->_size; i++)\n  rsearch(vp->_str[i]);\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dc-fukuoka/pfind/src/pfind/0"}
{"code": "for (iter = 1; iter <= niter; iter++)\n{\n  prod_mat_vec_omp(&A, &X, &Y);\n  if (!is_equal(&Y, &YSEQ))\n  {\n    printf(\"Difference sur l'iteration %d\\n\", iter);\n    abort();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD1_OMP/omp_prod_mat_vec/correction/prod_mat_vec_omp/6"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  if (Q[i][j] != Q1[i][j])\n{\n  printf(\"error %.6f %.6f -- %d %d\\n\", Q[i][j], Q1[i][j], i, j);\n  exit(0);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcc/mcc/3"}
{"code": "for (i = 0; i < processProductsRange; i++)\n{\n  allProducts[i + (prodcessId * numberOfProducts)].currentCluster = partialProducts[i].currentCluster;\n  allProducts[i + (prodcessId * numberOfProducts)].prevCluster = partialProducts[i].prevCluster;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MichaelSabbah/K-MEANS-parallel-project/K-MEANS_Parallel/K-MEANS/12"}
{"code": "for (int j = 0; j < dim.y; j++)\n{\n  const uint8_t * const line = getData(0, j);\n  assert(isAligned(line, alignment));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/common/RawImage/0"}
{"code": "for (i = 0; i < ncolors; i++)\n{\n  SHIFTCSR(j, nrows, smats[i]->rowptr);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/28"}
{"code": "for (i = 1; i <= ni; i++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    lhs[0][i][m] = 0.0;\n    lhsp[0][i][m] = 0.0;\n    lhsm[0][i][m] = 0.0;\n    lhs[nj][i][m] = 0.0;\n    lhsp[nj][i][m] = 0.0;\n    lhsm[nj][i][m] = 0.0;\n  }\n\n  lhs[0][i][2] = 1.0;\n  lhsp[0][i][2] = 1.0;\n  lhsm[0][i][2] = 1.0;\n  lhs[nj][i][2] = 1.0;\n  lhsp[nj][i][2] = 1.0;\n  lhsm[nj][i][2] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/initialize/3"}
{"code": "for (i = ji; i < ki; i++)\n  l++;\n\n", "pragma": "omp for reduction(+: l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  for (j = 0; j < 2; j++)\n  {\n    s = cimagf(g[j + (2 * (ny - k))]) + (crealf(g[j + (2 * (ny - k))]) * _Complex_I);\n    g[j + (2 * (ny - k))] = conjf(g[j + (2 * k)] - s);\n    g[j + (2 * k)] += s;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mppic2/mppush2/12"}
{"code": "for (int i = 0; i < (geom1->n_grid_r - 1); i++)\n  for (int k = 0; k < (geom1->n_grid_z - 1); k++)\n{\n  j_r[i][k] = 0.;\n  j_phi[i][k] = 0.;\n  j_z[i][k] = 0.;\n}\n\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/current/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  foo();\n  break;\n  continue;\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/target_teams_distribute_parallel_for_messages/1"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (NX / 2)) % NX) - (NX / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (NY / 2)) % NY) - (NY / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (NZ / 2)) % NZ) - (NZ / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for private(i,j,k,ii,ii2,jj,ij2,kk)    ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/FT/ft/6"}
{"code": "for (row = 0; row < out->height; row++)\n{\n  in_offset = row * in->width;\n  out_offset = row * out->width;\n  for (col = 0; col < out->width; col++)\n  {\n    out->data[out_offset + col] = conv2D_region(in, in_offset + col, kernel, n);\n  }\n\n}\n\n", "pragma": "omp parallel for private(in_offset, out_offset) shared(in, out)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jeffcav/parallel-convolution/src/conv/0"}
{"code": "for (int k = 0; k < c_len; k++)\n{\n  P_Matrix[k] = (int *) calloc(len_b + 1, sizeof(int));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v2/space_optimized/row_wise_v2/2"}
{"code": "for (int i = 0; i < NUM_ELEMENTS; i++)\n  localBins[tID][(int) _input[i]]++;\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  double *add1 = (double *) malloc(n * (sizeof(double)));\n  double *add2 = (double *) malloc(n * (sizeof(double)));\n  double *add3 = (double *) malloc(n * (sizeof(double)));\n  lower.push_back(add1);\n  upper.push_back(add2);\n  perm_final.push_back(add3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pradyumnameena/COL380-Parallel-Programming/A1/openmp/6"}
{"code": "for (i = 0; i < 7; i++)\n{\n  printf(\"Run %d \\n\", i);\n  train9(G, i);\n  sleep(2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/train9/0"}
{"code": "for (int i = 0; i < 100; i++)\n  stddev(std, data, D, N, sample);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/stddev-omp/main/2"}
{"code": "for (int e = 0; e < EXPERIMENT_TIMES; e++)\n{\n  times[e] = gather(input, output, idx, len);\n  if (e == 0)\n  {\n    bool res = true;\n    for (int i = 0; i < len; i++)\n    {\n      if (output[i] != input[idx[i]])\n      {\n        res = false;\n        break;\n      }\n\n    }\n\n    if (!res)\n      log_error(\"Wrong results\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/openmp/test_gather_scatter_CPU/1"}
{"code": "for (i = 0; i < len; i++)\n  array[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skyrain/openmp/openmp_skyrain/1"}
{"code": "for (x = 0; x < N; x++)\n  for (y = 0; y < N; y++)\n{\n  A[x][y] = 3;\n  B[x][y] = 3;\n  C[x][y] = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HectorMontillo/OpenMP/openmp/1"}
{"code": "for (i = 0; 16 > i; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/0"}
{"code": "for (int i = 0; i < _neighborhoods[origin].numNeighbors; i++)\n{\n  callback(_neighborhoods[origin].neighbors[i]->index, _neighborhoods[origin].distances[i]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kerber31/Smoothed-Particle-Hydrodynamics/src/GridNeighborhood2D/2"}
{"code": "for (i = 1; i <= 1000; i += 1)\n{\n  foo(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB084-threadprivatemissing-orig-yes/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  error += (b[i] - a[i]) * (b[i] - a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Neural Network/ex3/ex3/18"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = (ci2 * crealf(ffc[j + kk])) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = (-cimagf(cu[2 + (3 * (j + kj))])) + (crealf(cu[2 + (3 * (j + kj))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (j + kj))])) + (crealf(cu[1 + (3 * (j + kj))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (j + kj)])) + (crealf(cu[3 * (j + kj)]) * _Complex_I);\n    bxyz[3 * (j + kj)] = at3 * zt1;\n    bxyz[1 + (3 * (j + kj))] = (-at2) * zt1;\n    bxyz[2 + (3 * (j + kj))] = (at2 * zt2) - (at3 * zt3);\n    zt1 = (-cimagf(cu[2 + (3 * (j + k1))])) + (crealf(cu[2 + (3 * (j + k1))]) * _Complex_I);\n    zt2 = (-cimagf(cu[1 + (3 * (j + k1))])) + (crealf(cu[1 + (3 * (j + k1))]) * _Complex_I);\n    zt3 = (-cimagf(cu[3 * (j + k1)])) + (crealf(cu[3 * (j + k1)]) * _Complex_I);\n    bxyz[3 * (j + k1)] = (-at3) * zt1;\n    bxyz[1 + (3 * (j + k1))] = (-at2) * zt1;\n    bxyz[2 + (3 * (j + k1))] = (at2 * zt2) + (at3 * zt3);\n    bxyz[3 * ((j + kj) + l1)] = zero;\n    bxyz[1 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[2 + (3 * ((j + kj) + l1))] = zero;\n    bxyz[3 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    wp += at1 * ((((((cu[3 * (j + kj)] * conjf(cu[3 * (j + kj)])) + (cu[1 + (3 * (j + kj))] * conjf(cu[1 + (3 * (j + kj))]))) + (cu[2 + (3 * (j + kj))] * conjf(cu[2 + (3 * (j + kj))]))) + (cu[3 * (j + k1)] * conjf(cu[3 * (j + k1)]))) + (cu[1 + (3 * (j + k1))] * conjf(cu[1 + (3 * (j + k1))]))) + (cu[2 + (3 * (j + k1))] * conjf(cu[2 + (3 * (j + k1))])));\n  }\n\n  at1 = (ci2 * crealf(ffc[kk])) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = (-cimagf(cu[2 + (3 * kj)])) + (crealf(cu[2 + (3 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(cu[3 * kj])) + (crealf(cu[3 * kj]) * _Complex_I);\n  bxyz[3 * kj] = at3 * zt1;\n  bxyz[1 + (3 * kj)] = zero;\n  bxyz[2 + (3 * kj)] = (-at3) * zt3;\n  bxyz[3 * k1] = zero;\n  bxyz[1 + (3 * k1)] = zero;\n  bxyz[2 + (3 * k1)] = zero;\n  bxyz[3 * (kj + l1)] = zero;\n  bxyz[1 + (3 * (kj + l1))] = zero;\n  bxyz[2 + (3 * (kj + l1))] = zero;\n  bxyz[3 * (k1 + l1)] = zero;\n  bxyz[1 + (3 * (k1 + l1))] = zero;\n  bxyz[2 + (3 * (k1 + l1))] = zero;\n  wp += at1 * (((cu[3 * kj] * conjf(cu[3 * kj])) + (cu[1 + (3 * kj)] * conjf(cu[1 + (3 * kj)]))) + (cu[2 + (3 * kj)] * conjf(cu[2 + (3 * kj)])));\n  sum2 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,zt3,wp) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/4"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  wijk = ws[i][j][k];\n  wp1 = ws[i][j][k + 1];\n  wm1 = ws[i][j][k - 1];\n  rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n  rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n  rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n  rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n  rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,wijk ,wp1 ,wm1 ,tz2 ,dz1tz1 ,zzcon2 ,dz2tz1 ,dz3tz1 ,c2 ,dz4tz1 ,con43 ,c1 ,zzcon5 ,zzcon3 ,dz5tz1 ,zzcon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/114"}
{"code": "for (i = 0; i < size; i++)\n{\n  pixel = (int) (a * pow((double) pixels[i], (double) gamma));\n  if (pixel > 255)\n  {\n    pixels[i] = 255;\n  }\n  else\n  {\n    pixels[i] = pixel;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matti16/GammaCorrection/code/gamma/0"}
{"code": "for (i = 0; i < num_array; i++)\n{\n  *(gamma + i) = gamma_infinity;\n  *(vx + i) = 0;\n  *(vy + i) = vel;\n  *(dens + i) = ddensity;\n  *(dens_lab + i) = lab_dens;\n  *(pres + i) = (A_RAD * pow(t_comov, 4.0)) / (3 * pow(C_LIGHT, 2.0));\n  *(temp + i) = pow(((3 * (*(pres + i))) * pow(C_LIGHT, 2.0)) / A_RAD, 1.0 / 4.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/15"}
{"code": "for (row = 0; row < MAXROW; row++)\n{\n  for (col = 0; col < MAXCOL; col++)\n  {\n    int nei = 0;\n    int c;\n    int r;\n    for (r = row - 1; r <= (row + 1); r++)\n      for (c = col - 1; c <= (col + 1); c++)\n    {\n      if ((((r < 0) || (r >= MAXROW)) || (c < 0)) || (c >= MAXCOL))\n        continue;\n\n      if (allmap[(r * MAXCOL) + c] == ALIVE)\n        nei++;\n\n    }\n\n\n    if (allmap[(row * MAXCOL) + col] == ALIVE)\n      nei--;\n\n    switch (nei)\n    {\n      case 0:\n\n      case 1:\n\n      case 4:\n\n      case 5:\n\n      case 6:\n\n      case 7:\n\n      case 8:\n        newallmap[(row * MAXCOL) + col] = DEAD;\n        break;\n\n      case 2:\n        newallmap[(row * MAXCOL) + col] = allmap[(row * MAXCOL) + col];\n        break;\n\n      case 3:\n        newallmap[(row * MAXCOL) + col] = ALIVE;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"GOL\" with OMP and MPI/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  x[i] = 2.0f;\n  y[i] = 1.0f;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gpsilva2003/OPENMP/src/omp_parfor/0"}
{"code": "for (int i = 0; i < train_space; i++)\n{\n  for (int j = 0; j < train_space; j++)\n  {\n    int p = train_test_idx[0][i];\n    int q = train_test_idx[0][j];\n    res(i, j) = kernel(grid(p, 0), grid(p, 1), grid(q, 0), grid(q, 1), l1, l2);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/gpr/5"}
{"code": "for (size_t i = 0; i < result.rows(); ++i)\n  for (size_t j = 0; j < result.cols(); ++j)\n{\n  for (size_t k = 0; k < result.rows(); ++k)\n    result(i, j) += first(i, k) * second(k, j);\n\n}\n\n\n", "pragma": "\t\t#pragma omp parallel for shared(result)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KnsRoo/OpenMP/new/Matrix/0"}
{"code": "for (int i = 0; i < n_centroids; i++)\n{\n  random_idx = uniform_dist(random_engine);\n  for (int j = 0; j < n_features; j++)\n  {\n    centroids[i][j] = X[random_idx][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/2"}
{"code": "for (int i = orig_ncols; i < m.rows(); i++)\n{\n  m.col(i).setZero();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/6"}
{"code": "for (int i = 0; i < MAX; i++)\n  a[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lucas-t-reis/openMP/reduction/0"}
{"code": "for (i = 0; i < 3000; i++)\n  for (j = 0; j < 3000; j++)\n  data[i][j] = A[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/19"}
{"code": "for (int ii = 0; ii < N; ii++)\n  for (int jj = 0; jj < N; jj++)\n  A[(ii * N) + jj] = n;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_goto+cuBLAS_v2/0"}
{"code": "for (i = 0; i < keyspace; ++i)\n{\n  if (found == 0)\n  {\n    strcpy(candidate, \"\");\n    for (j = max - 1; j >= 0; --j)\n    {\n      index[j] = (i / ((int) pow(strlen(alpha), j))) % strlen(alpha);\n      sprintf(candidate, \"%s%c\", candidate, alpha[index[j]]);\n    }\n\n    sprintf(str, \"%lu\", compute_hash(candidate));\n    if (strcmp(str, secret) == 0)\n    {\n      printf(\"Secret found: **%s**\\n\", candidate);\n      found = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, candidate, str) shared(found)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jb25/openmp-mpi/cracker_final/0"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = rsd[i][j][k][2];\n      u31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n      q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n      flux[i][j][k][1] = rsd[i][j][k][1] * u31;\n      flux[i][j][k][2] = (rsd[i][j][k][2] * u31) + (C2 * (rsd[i][j][k][4] - q));\n      flux[i][j][k][3] = rsd[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(u31, q)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/14"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min - 1; j <= (x_max + 1); j++)\n  {\n    sigma = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    sigma2 = fabs(node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_pre[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n    width = celldx[FTNREF1D(j, x_min - 2)];\n    vdiffuw = vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j + 2, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffdw = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffuw2 = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - vel1[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)];\n    vdiffdw2 = -vdiffdw;\n    auw = fabs(vdiffuw);\n    adw = fabs(vdiffdw);\n    auw2 = fabs(vdiffuw2);\n    wind = 1.0;\n    wind2 = 1.0;\n    limiter = 0.0;\n    if (vdiffdw <= 0.0)\n      wind = -1.0;\n\n    if (vdiffdw2 <= 0.0)\n      wind2 = -1.0;\n\n    limiter = wind * MIN((width * ((((2.0 - sigma) * adw) / width) + (((1.0 + sigma) * auw) / celldx[FTNREF1D(j + 1, x_min - 2)]))) / 6.0, MIN(auw, adw));\n    limiter2 = wind2 * MIN((width * ((((2.0 - sigma2) * adw) / width) + (((1.0 + sigma2) * auw2) / celldx[FTNREF1D(j - 1, x_min - 2)]))) / 6.0, MIN(auw2, adw));\n    if ((vdiffuw * vdiffdw) <= 0.0)\n      limiter = 0.0;\n\n    if ((vdiffuw2 * vdiffdw2) <= 0.0)\n      limiter2 = 0.0;\n\n    if (node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] < 0.0)\n    {\n      advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = vel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] + ((1.0 - sigma) * limiter);\n    }\n    else\n    {\n      advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + ((1.0 - sigma2) * limiter2);\n    }\n\n    mom_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = advec_vel[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(sigma,width,limiter,vdiffuw,vdiffdw,auw,adw,wind,sigma2,limiter2,vdiffuw2,vdiffdw2,auw2,wind2,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/advec_mom_kernel_c/0"}
{"code": "for (int r = 0; r < bmp->height; r++)\n{\n  for (int c = 0; c < bmp->width; c++)\n  {\n    writePixel(fp, bmp->pixels[(r * bmp->width) + c]);\n  }\n\n  writePadding(fp, bmp->padding);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Victohu1/ParallelImageProcessor/openmp_image_processor/7"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < BLOCK_SIZE; m++)\n    {\n      for (n = 0; n < BLOCK_SIZE; n++)\n      {\n        rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][CC][m][n] * rhs[i + 1][j][k][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/74"}
{"code": "for (i = 0; i < 500; i++)\n  for (j = 0; j < 500; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixMul/matrixMul_openMP/1"}
{"code": "for (i = 0; i < N; ++i)\n  m[i * N] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/worksharing/for/omp_doacross/7"}
{"code": "for (i = 0; i < img1.h; i++)\n{\n  for (j = 0; j < img1.w; j++)\n  {\n    gray.arr[i][j] /= max_v;\n    gray.arr[i][j] *= 255;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for  collapse(2) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Images/Ivpomp/6"}
{"code": "for (long trg = 0; trg < N; trg++)\n{\n  double tx = x[trg];\n  double ty = y[trg];\n  double tz = z[trg];\n  double potential = 0;\n  for (long src = 0; src < N; src++)\n  {\n    double dx = tx - x[src];\n    double dy = ty - y[src];\n    double dz = tz - z[src];\n    double r2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    double rinv = (r2 > 0) ? (1 / sqrt(r2)) : (0);\n    potential += rinv * f[src];\n  }\n\n  u[trg] = potential;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NYU-HPC19/lecture4/03-omp-nbody/0"}
{"code": "for (int i = 0; i < NB; i++)\n  for (int j = 0; j < BS; j++)\n{\n  if ((((1 + (i * BS)) + j) >= rb) && (((1 + (i * BS)) + j) <= re))\n    Om[(1 + (i * BS)) + j] = Rp((1 + (i * BS)) + j);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/91"}
{"code": "for (int i = 0; i < n; i++)\n{\n  fprintf(fd, \"%d\", i);\n  for (int j = 0; j < k; j++)\n  {\n    fprintf(fd, \"\\t%d\", clusters[i][j]);\n  }\n\n  fprintf(fd, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/27"}
{"code": "for (i = 0; i < 3; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1/1"}
{"code": "for (i = 0; i < N; i = i + 1)\n{\n  for (j = 0; j < N; j = j + 1)\n  {\n    Result[i][j] = 0.;\n    for (k = 0; k < N; k = k + 1)\n    {\n      Result[i][j] = Result[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/0"}
{"code": "for (int i = 0; i < file1_totalNonzeros; i++)\n{\n  if (matrix1_rowindices[i] == matrix1_colindices[i])\n  {\n    inttrace_val += matrix1_intvalues[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+: inttrace_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VumGualnam/2019S2_C_I_T_S_3_4_0_2__HPC_Project1/trace/0"}
{"code": "for (d = a; d < b; d++)\n{\n  u[d] = v[d] + w[d];\n  c += 5;\n  e = c;\n}\n\n", "pragma": "omp parallel for simd default(none) firstprivate (a, b) shared(u, v, w) linear(d) linear(c:5) lastprivate(e)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_2_0_release/testsuite/libgomp.c/pr66199-1/1"}
{"code": "for (int i = 0; i < m_nCells; ++i)\n{\n  m_sd[i] = m_depCo * m_depCap[i];\n  m_sr[i] = 0.0f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/DEP_FS/DepressionFS/0"}
{"code": "for (int i = 0; i < sizeOfMatrix; i++)\n{\n  if ((i == 0) && (debug == 1))\n  {\n    printf(\"number of active threads\");\n  }\n  else\n    if (debug == 1)\n  {\n    printf(\"%i \", omp_get_num_threads());\n    printf(\"%i \\n\\r\", omp_get_thread_num());\n  }\n\n\n  for (int j = 0; j < sizeOfMatrix; j++)\n  {\n    for (int k = 0; k < sizeOfMatrix; k++)\n    {\n      result[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(numberThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sajidamro/eclipse-workspace/Lab_1/matrix_Multi/3"}
{"code": "for (i = 0; i < prim.dim; i++)\n  prim.U[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GennadySX/vvrs/lab_3/main/4"}
{"code": "for (uint32_t y = 0; y < s1->rows; y++)\n{\n  uint32_t y0 = ((y - 1) & rows_m1) << cols_p2;\n  uint32_t y1 = y << cols_p2;\n  uint32_t y2 = ((y + 1) & rows_m1) << cols_p2;\n  for (uint32_t x = 0; x < s1->cols; x++)\n  {\n    uint32_t x0 = (x - 1) & cols_m1;\n    uint32_t x2 = (x + 1) & cols_m1;\n    uint8_t aliveCells = countAliveCells(s1->matrix, x0, x, x2, y0, y1, y2);\n    s2->matrix[y1 + x] = ((aliveCells == 3) || ((aliveCells == 2) && s1->matrix[x + y1])) ? (1) : (0);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DrLux/CudaOfLife/source/openmp/0"}
{"code": "for (int i = threadId; i < num_steps; i += privateNumThreads)\n{\n  double x = (i + 0.5) * step;\n  sum[threadId] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnwest/OpenMPConsoleApplication/OpenMPConsoleApplication/OpenMPConsoleApplication/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = (rand() % (1 << 4)) / ((float) (1 << 2));\n  y[i] = (z[i] = (rand() % (1 << 8)) / ((float) (1 << 4)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_gpu/saxpy/0"}
{"code": "for (vi = vistart; vi < viend; vi++)\n{\n  perm[vi] = counts[xadj[vi + 1] - xadj[vi]]++;\n  nxadj[perm[vi]] = (xadj[vi + 1] - xadj[vi]) + 1;\n  iperm[perm[vi]] = vi;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/9"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  printf(\"%d \", prefix[i][0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/prefix_sum_2/5"}
{"code": "for (y = 0; y < 10; y++)\n{\n  b = (long **) malloc(10 * (sizeof(long *)));\n  for (i = 0; i < m; i++)\n  {\n    b[i] = (long *) malloc((sizeof(long *)) * 10);\n  }\n\n  for (int x = 0; x < 10; x++)\n  {\n    for (int g = 0; g < 10; g++)\n    {\n      b[x][g] = 0;\n    }\n\n  }\n\n  getCofactor(a, b, 0, y, m);\n  if (y % 2)\n  {\n    det += ((-1) * a[0][y]) * determinantOfMatrix(b, m - 1);\n  }\n  else\n  {\n    det += a[0][y] * determinantOfMatrix(b, m - 1);\n  }\n\n  for (i = 0; i < m; i++)\n  {\n    free(b[i]);\n  }\n\n  free(b);\n}\n\n", "pragma": "omp parallel for private(i, j, b) reduction(+:det)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Magiera/P-M-D/openMP/matrix/0"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  cursum += a[i];\n  printf(\"Thread no : %d\\t i = %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aadhityasw/VIT-Labs/Parallel_Distributed_Computing_CSE_4001/OpenMP_Constructs_Lab_2/array_sum/0"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    obs += norm(wf.wave[wf.in2(j, i)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/15"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    (cout << data[i][j]) << \"\\t\";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PiotrMydlowski/Gauss-Elimination/main/0"}
{"code": "for (j = (c = 0); j < 18; j++)\n{\n  for (i = 0; i < (sizeof(buffer)); i += 6)\n  {\n    buffer[i] ^= ebits_to_num[((c - i) + 48) & 0xFF];\n    buffer[i + 1] ^= ebits_to_num[((buffer[i] - i) + 47) & 0xFF];\n    buffer[i + 2] ^= ebits_to_num[((buffer[i + 1] - i) + 46) & 0xFF];\n    buffer[i + 3] ^= ebits_to_num[((buffer[i + 2] - i) + 45) & 0xFF];\n    buffer[i + 4] ^= ebits_to_num[((buffer[i + 3] - i) + 44) & 0xFF];\n    buffer[i + 5] ^= ebits_to_num[((buffer[i + 4] - i) + 43) & 0xFF];\n    c = buffer[i + 5];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus85_fmt_plug/2"}
{"code": "for (j = 1; j < (my_grid->dimension - 1); j++)\n{\n  temp = my_grid->element[(i * my_grid->dimension) + j];\n  my_grid->element[(i * my_grid->dimension) + j] = 0.20 * ((((my_grid->element[(i * my_grid->dimension) + j] + my_grid->element[((i - 1) * my_grid->dimension) + j]) + my_grid->element[((i + 1) * my_grid->dimension) + j]) + my_grid->element[(i * my_grid->dimension) + (j + 1)]) + my_grid->element[(i * my_grid->dimension) + (j - 1)]);\n  diff = diff + fabs(my_grid->element[(i * my_grid->dimension) + j] - temp);\n}\n\n", "pragma": "omp parallel for default(shared) private(temp,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nidhi1994/Parallel-computing-openmp/solver/solver/1"}
{"code": "for (int i = 0; i < num_of_lines; ++i)\n  mins[i] = mtr[i][0];\n\n", "pragma": "    #pragma omp parallel for shared(mins, mtr)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/1/1/0"}
{"code": "for (i = current_row; i < 4; i++)\n{\n  row_array[i] = row_array[i] / pivo;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  A[i] = rand() % 5;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bupingxx/Parallel-linear-equations-solver/src/gauss2/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    sum[i][j] = mat1[i][j] + mat2[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Matrices/matrix_sum/0"}
{"code": "for (i = 0; i < n; i++)\n  scanf(\"%d\", &vec[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task2/prod_cons/0"}
{"code": "for (mergeIndex = 0; mergeIndex < NUM_BIRDS; mergeIndex++)\n{\n  if (f2->birds[mergeIndex].id != (-1))\n  {\n    mergeBirdData(&f1->birds[mergeIndex], &f2->birds[mergeIndex]);\n    updateRanking(&f1->topFurthestDistance, f1->birds[mergeIndex].distance, f1->birds[mergeIndex].id);\n    updateRanking(&f1->topFastest, f1->birds[mergeIndex].maxSpeed, f1->birds[mergeIndex].id);\n    updateRanking(&f1->topSlowest, f1->birds[mergeIndex].minSpeed, f1->birds[mergeIndex].id);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HakAus/Caso6_Analisis_de_Algoritmos/RankingGenerator/main/0"}
{"code": "for (int i = 0; i < massPoints.size(); ++i)\n{\n  massPoints[i]->initInitialMove(maxAbsXY, initialSpeed);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jakubbegera/OpenMP-Space-simulator/SpaceSimulator/0"}
{"code": "for (i = 0; i < STREAM_ARRAY_SIZE; i++)\n  a[i] = 2.0E0 * a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/28"}
{"code": "for (int i = 0; i < NUM_THREADS; i++)\n{\n  flag[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /PrefixSum/parallel_simple/0"}
{"code": "for (int32_t i = N; i >= 0; --i)\n{\n  sum += buffer[i];\n  if (sum >= i)\n  {\n    return i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/11"}
{"code": "for (int i = 0; i < MAX_ROWS; ++i)\n{\n  for (int j = 0; j < MAX_COLS; j += 16)\n  {\n    if (j != _overflow)\n    {\n      SIMDitoa16(&iOutputData[i][j], numString);\n    }\n    else\n    {\n      SIMDitoa8(&iOutputData[i][j], numString);\n    }\n\n    for (int k = 0; k < 16; ++k)\n    {\n      int simdIdx = k * MAX_CHARS;\n      for (int m = 0; m < 4; ++m)\n      {\n        if (numString[simdIdx + m] == '0')\n        {\n          numString[simdIdx + m] = ' ';\n        }\n        else\n        {\n          break;\n        }\n\n      }\n\n    }\n\n    odata += numString;\n    odata += \"\\t\";\n  }\n\n  odata += \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = w * (i - 0.5);\n  sum = sum + f(x);\n}\n\n", "pragma": "omp parallel for private(x) shared(w) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/omp-11/0"}
{"code": "for (i = 0; (i < latent_template.m_nrof_texture_templates) && (rolled_template.m_nrof_texture_templates > 0); ++i)\n{\n  float s = One2One_texture_matching(latent_template.m_texture_templates[i], rolled_template.m_texture_templates[0]);\n  score[i + latent_template.m_nrof_minu_templates] = s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/3"}
{"code": "for (i = 0; i < row1; i++)\n{\n  for (j = 0; j < col2; j++)\n  {\n    mul[i][j] = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j) shared(row1,col2,mul) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zeeshanmahar007/Matrix-Matrix-Multiplication-in-Parallel/omp_parallel/5"}
{"code": "for (uint jobs = 1; jobs <= tot_jobs; jobs++)\n{\n  tot_resp = 0.0;\n  for (uint k = 0; k < num_stations; k++)\n  {\n    num_jobs[k] = thr * response[k];\n    response[k] = demand[k] * (1 + num_jobs[k]);\n    tot_resp += response[k];\n  }\n\n  thr = ((double) jobs) / (think_time + tot_resp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cattaneo-riccardo/ExactMVA_OpenMP/mva/0"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  int st = xadj[i + 1];\n  int ed = xadj[i];\n  double rsum = 0;\n  for (int k = ed; k < st; k++)\n  {\n    rsum += cv[adj[k]];\n  }\n\n  rv[i] = 1 / rsum;\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided) num_threads(numberofthread) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/serhansilah/Sinkhorn_Knopp_Scaling/OpenMP_code/openMP_version/0"}
{"code": "for (int i = 0, biHeight = abs(bi.biHeight); i < biHeight; i++)\n{\n  unsigned char gray;\n  for (int j = 0; j < bi.biWidth; j++)\n  {\n    RGBTRIPLE triple;\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n    gray = img[img_idx];\n    r = gray;\n    g = gray;\n    b = gray;\n    triple.rgbtBlue = b;\n    triple.rgbtGreen = g;\n    triple.rgbtRed = r;\n    fwrite(&triple, sizeof(RGBTRIPLE), 1, fname);\n    img_idx++;\n  }\n\n  for (int k = 0; k < padding; k++)\n  {\n    fputc(0x00, fname);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laasya98/omp-image-processing/load_bmp_omp/11"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  v_it = _mm512_set1_epi32(k);\n  v_dky = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dky = _mm512_mul_ps(v_dny, v_dky);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  v_wp = _mm512_set1_pd(0.0);\n  for (j = 0; j < nxhs; j += 8)\n  {\n    v_at1 = _mm512_load_ps((float *) (&ffc[j + kk]));\n    v_at2 = (int) _mm512_shuffle_epi32((int) v_at1, 177);\n    v_at1 = _mm512_mul_ps(v_at1, v_at2);\n    v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n    v_at2 = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n    v_at2 = _mm512_mul_ps(v_at1, _mm512_mul_ps(v_dnx, v_at2));\n    v_at3 = _mm512_mul_ps(v_dky, v_at1);\n    v_zt1 = _mm512_load_ps((float *) (&q[j + kj]));\n    v_zt1 = _mm512_mask_sub_ps(v_zt1, _mm512_int2mask(21845), v_zero, v_zt1);\n    v_zt1 = (int) _mm512_shuffle_epi32((int) v_zt1, 177);\n    v_zt2 = _mm512_load_ps((float *) (&q[j + k1]));\n    v_zt2 = _mm512_mask_sub_ps(v_zt2, _mm512_int2mask(21845), v_zero, v_zt2);\n    v_zt2 = (int) _mm512_shuffle_epi32((int) v_zt2, 177);\n    if (j == 0)\n    {\n      v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(3), v_zero);\n      v_zt2 = _mm512_mask_mov_ps(v_zt2, _mm512_int2mask(3), v_zero);\n    }\n\n    a = _mm512_mul_ps(v_at2, v_zt1);\n    b = _mm512_mul_ps(v_at3, v_zt1);\n    c = v_zero;\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(65280), c, 78);\n    f = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(255), a, 78);\n    g = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(65280), v_zero, 78);\n    h = _mm512_mask_permute4f128_ps(v_zero, _mm512_int2mask(255), b, 78);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), g, 177);\n    b = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(3855), e, 177);\n    c = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(61680), h, 177);\n    d = _mm512_mask_permute4f128_ps(h, _mm512_int2mask(3855), f, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    _mm512_store_ps((float *) (&fxyz[4 * (j + kj)]), a);\n    _mm512_store_ps((float *) (&fxyz[8 + (4 * (j + kj))]), b);\n    _mm512_store_ps((float *) (&fxyz[16 + (4 * (j + kj))]), c);\n    _mm512_store_ps((float *) (&fxyz[24 + (4 * (j + kj))]), d);\n    a = _mm512_mul_ps(v_at2, v_zt2);\n    b = _mm512_sub_ps(v_zero, _mm512_mul_ps(v_at3, v_zt2));\n    c = v_zero;\n    ;\n    e = _mm512_mask_permute4f128_ps(a, _mm512_int2mask(65280), c, 78);\n    f = _mm512_mask_permute4f128_ps(c, _mm512_int2mask(255), a, 78);\n    g = _mm512_mask_permute4f128_ps(b, _mm512_int2mask(65280), v_zero, 78);\n    h = _mm512_mask_permute4f128_ps(v_zero, _mm512_int2mask(255), b, 78);\n    a = _mm512_mask_permute4f128_ps(e, _mm512_int2mask(61680), g, 177);\n    b = _mm512_mask_permute4f128_ps(g, _mm512_int2mask(3855), e, 177);\n    c = _mm512_mask_permute4f128_ps(f, _mm512_int2mask(61680), h, 177);\n    d = _mm512_mask_permute4f128_ps(h, _mm512_int2mask(3855), f, 177);\n    a = (int) _mm512_permutevar_epi32(v_perm, (int) a);\n    b = (int) _mm512_permutevar_epi32(v_perm, (int) b);\n    c = (int) _mm512_permutevar_epi32(v_perm, (int) c);\n    d = (int) _mm512_permutevar_epi32(v_perm, (int) d);\n    _mm512_store_ps((float *) (&fxyz[4 * (j + k1)]), a);\n    _mm512_store_ps((float *) (&fxyz[8 + (4 * (j + k1))]), b);\n    _mm512_store_ps((float *) (&fxyz[16 + (4 * (j + k1))]), c);\n    _mm512_store_ps((float *) (&fxyz[24 + (4 * (j + k1))]), d);\n    _mm512_store_ps((float *) (&fxyz[4 * ((j + kj) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[8 + (4 * ((j + kj) + l1))]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[16 + (4 * ((j + kj) + l1))]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[24 + (4 * ((j + kj) + l1))]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[4 * ((j + k1) + l1)]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[8 + (4 * ((j + k1) + l1))]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[16 + (4 * ((j + k1) + l1))]), v_zero);\n    _mm512_store_ps((float *) (&fxyz[24 + (4 * ((j + k1) + l1))]), v_zero);\n    v_zt3 = _mm512_mul_ps(v_zt1, v_zt1);\n    v_zt3 = _mm512_add_ps(v_zt3, _mm512_mul_ps(v_zt2, v_zt2));\n    v_zt3 = _mm512_mul_ps(v_at1, v_zt3);\n    v_wp = _mm512_add_pd(v_wp, _mm512_cvtpslo_pd(v_zt3));\n    v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_zt3, 78));\n    v_wp = _mm512_add_pd(v_wp, v_d);\n  }\n\n  for (j = itn; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxyz[4 * (j + kj)] = at2 * zt1;\n    fxyz[1 + (4 * (j + kj))] = at3 * zt1;\n    fxyz[2 + (4 * (j + kj))] = zero;\n    fxyz[4 * (j + k1)] = at2 * zt2;\n    fxyz[1 + (4 * (j + k1))] = (-at3) * zt2;\n    fxyz[2 + (4 * (j + k1))] = zero;\n    fxyz[4 * ((j + kj) + l1)] = zero;\n    fxyz[1 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[2 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[4 * ((j + k1) + l1)] = zero;\n    fxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    fxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    at1 = at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n    wp += (double) at1;\n  }\n\n  _mm512_store_pd(&dd[0], v_wp);\n  for (j = 1; j < 8; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += wp + dd[0];\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp,v_it,v_dky,v_at1, v_at2,v_at3,v_zt1,v_zt2,v_zt3,a,b,c,d,e,f,g,h,v_d,v_wp,dd) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/16"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  if (fabs(Y[i] - ((double) 8)) > 1.0e-18)\n  {\n    printf(\" Error! in ( %d ) th argument. %lf \\n\", i, Y[i]);\n    iflag = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/SpMV/C/spmv/2"}
{"code": "for (i = 0; i < LOOPCOUNT; ++i)\n{\n  bit_and = bit_and & logics[i];\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1) private(i) reduction(& : bit_and)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_parallel_reduction/4"}
{"code": "for (int j = 0; j < 256; j++)\n{\n  if ((k <= need_k) && ((k + count_b[j]) > need_k))\n  {\n    break;\n  }\n  else\n  {\n    k += count_b[j];\n    min_b = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/13"}
{"code": "for (i = 0; i < Cy->n; i++)\n  m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) + (dt * v_get_val(dCy, i)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/34"}
{"code": "for (int i = 1; i < (this->size_ - 1); ++i)\n  for (int j = 1; j < (this->size_ - 1); ++j)\n{\n  idx = (i * this->size_) + j;\n  cast_out->vec_[idx] = (((((((((static_cast < ValueType) > (((-1) * cast_in->vec_[idx - this->size_]) + static_cast)) < ValueType) > (((-1) * cast_in->vec_[idx - 1]) + static_cast)) < ValueType) > ((4 * cast_in->vec_[idx]) + static_cast)) < ValueType) > (((-1) * cast_in->vec_[idx + 1]) + static_cast)) < ValueType) > ((-1) * cast_in->vec_[idx + this->size_]);\n}\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_stencil_laplace2d/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  p[i] = r_new[i] + (beta * p[i]);\n  r[i] = r_new[i];\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yilehu/CG_OpenMP/main/2"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/28"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  array[i] = size - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddhantNadkarni/Parallel-and-Distributed-Computing/src/PHW_3/p2/0"}
{"code": "for (i = 0; i < N; i += delta)\n  fprintf(res, \"%2.5f %2.5f\\n\", x[i], y[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLRivero/Pthread-OpenMP-assignment/sinx-p/2"}
{"code": "for (j = neighbor_start; j < neighbor_end; j++)\n{\n  const uint64_t to_explore_global_id = neighbors[j];\n  const int target_pe = get_owner_pe(to_explore_global_id, nglobalverts);\n  const uint64_t to_explore_local_id = to_explore_global_id - get_starting_vertex_for_pe(target_pe, nglobalverts);\n  assert(to_explore_local_id < get_vertices_per_pe(nglobalverts));\n  const int already_visited = is_visited(to_explore_global_id, shared_visited, visited_ints, local_min_vertex) || is_visited(to_explore_global_id, local_visited, visited_ints, local_min_vertex);\n  if (!already_visited)\n  {\n    const int ctx_index = *curr_ctx_index;\n    const shmemx_ctx_t curr_ctx = thread_ctxs[ctx_index];\n    shmemx_ctx_putmem(&verts[to_explore_local_id].bufs[updating_index], pe_plus_one_ptr, sizeof(*pe_plus_one_ptr), target_pe, curr_ctx);\n    const int curr_n_atomics = (*thread_natomics) + 1;\n    *thread_natomics = curr_n_atomics;\n    natomics_issued[ctx_index]++;\n    if (natomics_issued[ctx_index] > 512)\n    {\n      const int next_index = (ctx_index + 1) % 2;\n      shmemx_ctx_t next_ctx = thread_ctxs[next_index];\n      const unsigned long long start_quiet = current_time_ns();\n      shmemx_ctx_quiet(next_ctx);\n      natomics_issued[next_index] = 0;\n      *curr_ctx_index = next_index;\n      const unsigned long long elapsed_quiet = current_time_ns() - start_quiet;\n      *time_blocked_on_quiet += elapsed_quiet;\n    }\n\n    set_visited(to_explore_global_id, local_visited, visited_ints, local_min_vertex);\n    if (target_pe == pe)\n    {\n      set_visited(to_explore_global_id, shared_visited, visited_ints, local_min_vertex);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-wavefront/2"}
{"code": "for (i = 1; i < argc; i += 2)\n  if (argv[i][0] != '-')\n  goto abort_and_show_usage;\nelse\n  switch (argv[i][1])\n{\n  case 'i':\n    strncpy(args->input, argv[i + 1], sizeof(args->input));\n    break;\n\n  case 'o':\n    strncpy(args->output, argv[i + 1], sizeof(args->output));\n    break;\n\n  case 'h':\n    args->height = atoi(argv[i + 1]);\n    break;\n\n  case 'w':\n    args->width = atoi(argv[i + 1]);\n    break;\n\n  case 'n':\n    args->iterations = atoi(argv[i + 1]);\n    break;\n\n  case 'c':\n    args->channels = atoi(argv[i + 1]);\n    break;\n\n  default:\n    goto abort_and_show_usage;\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gnafpas/Image_Convolution_mpi_openmp/Test_mpi/main/0"}
{"code": "for (int node = 0; node < 16; node++)\n{\n  if (vertex == q->items[node])\n  {\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ata-Pab/Parallel_BFS_OpenMP/parallel_bfs_openmp/1"}
{"code": "for (int i = 0; i < V; i++)\n{\n  if (vertices[i].label != root->label)\n  {\n    path_length[vertices[i].label] = findEdgeWeight(*root, vertices[i], edges, weights);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaurabhMohata/PGraph/dijkstra parallel/1"}
{"code": "for (layer17_index = 0; layer17_index < Layer_CH_Num; layer17_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (layer16_index = 0; layer16_index < Layer_CH_Num; layer16_index++)\n  {\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        temp_data17[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n      }\n\n    }\n\n    for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n    {\n      for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n      {\n        for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n        {\n          for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n          {\n            temp_data17[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data17[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv16_data[(((layer16_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv17[(((((layer17_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer16_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n          }\n\n        }\n\n      }\n\n    }\n\n    for (i = 0; i < HIgh_h; i++)\n    {\n      for (j = 0; j < HIgh_w; j++)\n      {\n        conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data17[(((layer16_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv17[layer17_index];\n      if (conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n        conv17_data[(((layer17_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/63"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  fprintf(stderr, \"%0.2lf \", A[i][j]);\n  if ((((i * n) + j) % 20) == 0)\n    fprintf(stderr, \"\\n\");\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/jacobi2d-parallel-no/2"}
{"code": "for (i = 0; i < num_agents; i++)\n{\n  int starting_city;\n  for (starting_city = 0; starting_city < 1000; starting_city++)\n  {\n    generate_solutions(graph, transitions, starting_city);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lar9482/High-Performance-Computing-Projects/TSP/Ant Colony Attempt/Ant_Colony/5"}
{"code": "for (x = 0; x < 175; x++)\n{\n  TOP[x] = (char *) malloc((strlen(FULL[0]) + 1) * (sizeof(char)));\n  strcpy(TOP[x], FULL[x]);\n  BOTTOM[x] = (char *) malloc((strlen(TOP[0]) + 1) * (sizeof(char)));\n  strcpy(BOTTOM[x], TOP[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giovannicaprio/t1_paralela_jogo_da_vida_openmp/paralelo/1"}
{"code": "for (int j = 0; j < total_values; j++)\n  sum += pow(p1.values[j] - p2.values[j], 2.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      D[(i * 1000) + j] = 0;\n    }\n    else\n    {\n      D[(i * 1000) + j] = (((float) i) * (j + 2)) / 1000;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/4"}
{"code": "for (i = 0; i < 4; i++)\n{\n  out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/XSHA_fmt_plug/2"}
{"code": "for (unsigned long j = 0; j < n2; j++)\n{\n  R[j] = arr[(middle + 1) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sabusajin/openmp_parallel/mergesort/1"}
{"code": "for (i = 0; i < (interSize - 1); i += 2)\n{\n  swap(partY[i], partY[i + 1]);\n}\n\n", "pragma": "    #pragma omp parallel for private(i) shared(partY, interSize) default(none)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/parallel/ParallelSweepMethod/7"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Send(pointsArr, n, PointMPIType, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/main/2"}
{"code": "for (i = 0; i < numf2s; i++)\n  Y[o][i].y = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/14"}
{"code": "for (curr_size = 1; curr_size <= (n - 1); curr_size = 2 * curr_size)\n{\n  for (left_start = start; left_start < (n - 1); left_start += 2 * curr_size)\n  {\n    int mid = min((left_start + curr_size) - 1, n - 1);\n    int right_end = min((left_start + (2 * curr_size)) - 1, n - 1);\n    merge(arr, left_start, mid, right_end);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP Tasks/q3_w/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  count[i] = 0;\n  private_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/0"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  Res[RowIdx] = Mat->At(RowIdx, ColIdx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/112"}
{"code": "for (int i = 0; i < nx; i++)\n  for (int j = i + 1; j < nx; j++)\n{\n  conn = classification[j] == classification[i];\n  consensus[ii] += conn;\n  ii++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artecs-group/nmf-openmp/src/main/7"}
{"code": "for (int i = 1; i < M; i++)\n{\n  s_array_wl[i] = s_array_wl[i - 1] + b_array[i - 1];\n  omp_set_lock(&lock);\n  s_array_l[i] = s_array_l[i - 1] + b_array[i - 1];\n  omp_unset_lock(&lock);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR7/LR7_1/1"}
{"code": "for (int it = 0; it < t_itrs; it++)\n{\n  for (int i = 1; i < x_points; i++)\n  {\n    u_new[i] = u[i] - (((u[i] * del_t) / del_x) * (u[i] - u[i - 1]));\n  }\n\n  for (int i = 0; i < x_points; i++)\n  {\n    u[i] = u_new[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D NonLinear Convection/main/1"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  cu[4 * j] = zero;\n  cu[(4 * j) + k1] = zero;\n  cu[(1 + (4 * j)) + k1] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/32"}
{"code": "for (i = 0; i < 100; i++)\n{\n  if (c[i + 100] != i)\n  {\n    fprintf(stderr, \"c[%d] == %d != %d\\n\", i + 100, c[i + 100], i);\n    abort();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_for_14/1"}
{"code": "for (i = 0; i < NoofCols; i++)\n{\n  Checkoutput[i] = (float *) malloc((sizeof(float)) * NoofRows);\n  Trans[i] = (float *) malloc((sizeof(float)) * NoofRows);\n  for (j = 0; j < NoofRows; j++)\n  {\n    Checkoutput[i][j] = 0.0;\n    Trans[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/2"}
{"code": "for (j = 4; j <= 10000; j += 2)\n{\n  for (i = 3; i <= (j / 2); i++)\n  {\n    r1 = isprime(i);\n    r2 = isprime(j - i);\n    if ((r1 == 1) && (r2 == 1))\n    {\n      isgold[i][j / 2] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhiy91/Goldbach_conjecture/goldbach_omp/0"}
{"code": "for (i = 0; i < REPETITIONS; i++)\n{\n  if (!test_omp_parallel_reduction())\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_parallel_reduction/7"}
{"code": "for (int i = a_start, j = b_start; i <= a_end; i += block_size, j += block_size * size[0])\n{\n  pBA[(y_local * block_size) + x_local] = a[(i + (size[0] * y_local)) + x_local];\n  pBB[(x_local * block_size) + y_local] = b[(j + (size[0] * y_local)) + x_local];\n  block.barrier(local_space);\n  for (int k = 0; k < block_size; k++)\n  {\n    result += pBA[(y_local * block_size) + k] * pBB[(x_local * block_size) + k];\n  }\n\n  block.barrier(local_space);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AD2605/Vectorization-Parallelism-and-GPGPU-programming/BLAS/matmul/0"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"%d\\n\", c[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubhams167/intro-to-OpenMP/OMP - MatrixVectorProduct/2"}
{"code": "for (j = 2; j < (n - 2); j++)\n{\n  for (i = 2; i < (n - 2); i++)\n  {\n    for (jj = -2; jj <= 2; jj++)\n      for (ii = -2; ii <= 2; ii++)\n      out[i + (j * n)] += weight[ii + 2][jj + 2] * in[(i + ii) + ((j + jj) * n)];\n\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/Stencil/stencil/2"}
{"code": "for (int i = 0; i < n; ++i)\n  y[i] = (a * x[i]) + y[i];\n\n", "pragma": "omp parallel for num_threads(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/h4koo/Arquitectura-taller2/src/saxpy_par/0"}
{"code": "for (int i = 0; i < dNumOfAtoms; ++i)\n{\n  this->coord_[i] = this->flGeometry_.getCoordinate(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/0"}
{"code": "for (j = 0; j < 10; j++)\n  (*u)[(*my_rows) - 1][j] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/estsaon/parallel-programming-in-c-with-mpi-and-openmp/openmp/chapter18/jacobi/jacobi/4"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  y[i] = (a * x[i]) + y[i];\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_saxpy/c1/saxpy/0"}
{"code": "for (i = 0; i < m_ar; i++)\n{\n  for (k = 0; k < m_ar; k++)\n  {\n    for (j = 0; j < m_br; j++)\n    {\n      phc[(i * m_ar) + j] += pha[(i * m_ar) + k] * phb[(k * m_br) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/5"}
{"code": "for (int j = 0; j < N_POINTS; j += 1)\n{\n  for (int k = 0; k < N_POINTS; k += 1)\n  {\n    pherormone_matrix.at(j).at(k) = (1 - RHO) * pherormone_matrix.at(j).at(k);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2) schedule(dynamic, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/tsp/tsp/Colonize/0"}
{"code": "for (j = 1; j < HEAVY; j++)\n{\n  value = (i + 1) * (j % 10);\n  result += cos(value);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranzxc/Exam3_Parallal_OpenMP_MPI_CUDA/Exam3_Parallel_CUDA_MPI_OPENMP/MainProgram/2"}
{"code": "for (; r < rows; r++)\n{\n  if (r > 0)\n  {\n    printf(\",\");\n  }\n\n  printf(\"{\");\n  int c = 0;\n  for (; c < cols; c++)\n  {\n    if (c > 0)\n    {\n      printf(\",\");\n    }\n\n    printf(\"%d\", mat[(r * cols) + c]);\n  }\n\n  printf(\"}\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pnookala/MIC_OpenMP_GeMTC/src/Apps/MatrixMul/4"}
{"code": "for (iteration = 1; iteration <= 10; iteration++)\n{\n  if (CLASS != 'S')\n    printf(\"        %d\\n\", iteration);\n\n  rank(iteration);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/IS/is/16"}
{"code": "for (int j = 0; j < newTrainData->nOfPatterns; j++)\n{\n  newTrainData->inputs[j] = trainDataset->inputs[randomVector[i]];\n  newTrainData->outputs[j] = trainDataset->outputs[randomVector[i]];\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/33"}
{"code": "for (i = 0; i < 8; i++)\n{\n  MPI_Start(&receiveReq[pos][i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/billDrett/GameOfLife-MPI-OpenMp-Cuda-/openMP/openmpParrallelCommunication/main/1"}
{"code": "for (int h = 0; h < (rows * cols); h++)\n{\n  cc_map[i][h] = class_flag[i][h];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amy-tabb/tabb-level-set-segmentation/level-set-segmentation/src/LevelSets/3"}
{"code": "for (int currentGrid = 0; currentGrid < 2; ++currentGrid)\n{\n  free(grid[currentGrid][0]);\n  free(grid[currentGrid]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/13"}
{"code": "for (int i = 0; i < sz; i++)\n{\n  reduction_elem += vec[i];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:reduction_elem)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/learning-process/parallel_programming_course/modules/test_tasks/test_omp/ops_omp/1"}
{"code": "for (int i = 0; i < n; i++)\n  r[i] = b[i];\n\n", "pragma": "omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/16"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  if (x[i] > mval)\n  {\n    mval = x[i];\n    mloc = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_non_critical/3"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  if (vis[i] != 2)\n    dfs2(i);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/4"}
{"code": "for (int i = 1; i < (nx + 1); i++)\n{\n  #pragma ivdep\n  for (int j = 1; j < (ny + 1); j++)\n  {\n    h[i][j] -= dt * hNetUpdates[i][j];\n    hu[i][j] -= dt * huNetUpdates[i][j];\n    hv[i][j] -= dt * hvNetUpdates[i][j];\n    hNetUpdates[i][j] = (float) 0;\n    huNetUpdates[i][j] = (float) 0;\n    hvNetUpdates[i][j] = (float) 0;\n    if (h[i][j] < 0.1)\n      hu[i][j] = (hv[i][j] = 0.);\n\n    if (h[i][j] < 0)\n    {\n      if (h[i][j] < (-0.1))\n      {\n        ((((((cerr << \"Warning, negative height: (i,j)=(\") << i) << \",\") << j) << \")=\") << h[i][j]) << endl;\n        ((cerr << \"         b: \") << b[i][j]) << endl;\n      }\n\n      h[i][j] = (float) 0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_WaveAccumulationBlock/2"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  count1 = increament_counter();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest06/simple_test_06/1"}
{"code": "for (i = 0; i < numOfPoints; ++i)\n{\n  const double *point = getPointAtLocation(points, i);\n  classified[i] = discFunction(point, W, *w0, k);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roteml8/binary_classification/BinaryClassifier/3"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    wp[i][j] = 0.25 * (((up[i - 1][j] + up[i + 1][j]) + up[i][j - 1]) + up[i][j + 1]);\n    error += (wp[i][j] - up[i][j]) * (wp[i][j] - up[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(OMP_SCHED) private(j) reduction(+:error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/Jacobi/1"}
{"code": "for (l = 1; l < nzh; l++)\n{\n  dkz = dnz * ((float) l);\n  ll = nxyhd * l;\n  lj = nxvyh * l;\n  l1 = (nxvyh * nz) - lj;\n  wp = 0.0;\n  for (k = 1; k < nyh; k++)\n  {\n    dky = dny * ((float) k);\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    #pragma ivdep\n    for (j = 1; j < nxh; j++)\n    {\n      at1 = crealf(ffc[(j + kk) + ll]) * cimagf(ffc[(j + kk) + ll]);\n      at2 = (at1 * dnx) * ((float) j);\n      at3 = dky * at1;\n      at4 = dkz * at1;\n      zt1 = cimagf(q[(j + kj) + lj]) - (crealf(q[(j + kj) + lj]) * _Complex_I);\n      zt2 = cimagf(q[(j + k1) + lj]) - (crealf(q[(j + k1) + lj]) * _Complex_I);\n      fxyz[4 * ((j + kj) + lj)] = at2 * zt1;\n      fxyz[1 + (4 * ((j + kj) + lj))] = at3 * zt1;\n      fxyz[2 + (4 * ((j + kj) + lj))] = at4 * zt1;\n      fxyz[4 * ((j + k1) + lj)] = at2 * zt2;\n      fxyz[1 + (4 * ((j + k1) + lj))] = (-at3) * zt2;\n      fxyz[2 + (4 * ((j + k1) + lj))] = at4 * zt2;\n      zt1 = cimagf(q[(j + kj) + l1]) - (crealf(q[(j + kj) + l1]) * _Complex_I);\n      zt2 = cimagf(q[(j + k1) + l1]) - (crealf(q[(j + k1) + l1]) * _Complex_I);\n      fxyz[4 * ((j + kj) + l1)] = at2 * zt1;\n      fxyz[1 + (4 * ((j + kj) + l1))] = at3 * zt1;\n      fxyz[2 + (4 * ((j + kj) + l1))] = (-at4) * zt1;\n      fxyz[4 * ((j + k1) + l1)] = at2 * zt2;\n      fxyz[1 + (4 * ((j + k1) + l1))] = (-at3) * zt2;\n      fxyz[2 + (4 * ((j + k1) + l1))] = (-at4) * zt2;\n      at1 = at1 * ((((q[(j + kj) + lj] * conjf(q[(j + kj) + lj])) + (q[(j + k1) + lj] * conjf(q[(j + k1) + lj]))) + (q[(j + kj) + l1] * conjf(q[(j + kj) + l1]))) + (q[(j + k1) + l1] * conjf(q[(j + k1) + l1])));\n      wp += (double) at1;\n    }\n\n  }\n\n  #pragma ivdep\n  for (k = 1; k < nyh; k++)\n  {\n    kk = nxhd * k;\n    kj = nxvh * k;\n    k1 = (nxvh * ny) - kj;\n    at1 = crealf(ffc[kk + ll]) * cimagf(ffc[kk + ll]);\n    at3 = (at1 * dny) * ((float) k);\n    at4 = dkz * at1;\n    zt1 = cimagf(q[kj + lj]) - (crealf(q[kj + lj]) * _Complex_I);\n    zt2 = cimagf(q[kj + l1]) - (crealf(q[kj + l1]) * _Complex_I);\n    fxyz[4 * (kj + lj)] = zero;\n    fxyz[1 + (4 * (kj + lj))] = at3 * zt1;\n    fxyz[2 + (4 * (kj + lj))] = at4 * zt1;\n    fxyz[4 * (k1 + lj)] = zero;\n    fxyz[1 + (4 * (k1 + lj))] = zero;\n    fxyz[2 + (4 * (k1 + lj))] = zero;\n    fxyz[4 * (kj + l1)] = zero;\n    fxyz[1 + (4 * (kj + l1))] = at3 * zt2;\n    fxyz[2 + (4 * (kj + l1))] = (-at4) * zt2;\n    fxyz[4 * (k1 + l1)] = zero;\n    fxyz[1 + (4 * (k1 + l1))] = zero;\n    fxyz[2 + (4 * (k1 + l1))] = zero;\n    at1 = at1 * ((q[kj + lj] * conjf(q[kj + lj])) + (q[kj + l1] * conjf(q[kj + l1])));\n    wp += (double) at1;\n  }\n\n  k1 = nxvh * nyh;\n  #pragma ivdep\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + ll]) * cimagf(ffc[j + ll]);\n    at2 = (at1 * dnx) * ((float) j);\n    at4 = dkz * at1;\n    zt1 = cimagf(q[j + lj]) - (crealf(q[j + lj]) * _Complex_I);\n    zt2 = cimagf(q[j + l1]) - (crealf(q[j + l1]) * _Complex_I);\n    fxyz[4 * (j + lj)] = at2 * zt1;\n    fxyz[1 + (4 * (j + lj))] = zero;\n    fxyz[2 + (4 * (j + lj))] = at4 * zt1;\n    fxyz[4 * ((j + k1) + lj)] = zero;\n    fxyz[1 + (4 * ((j + k1) + lj))] = zero;\n    fxyz[2 + (4 * ((j + k1) + lj))] = zero;\n    fxyz[4 * (j + l1)] = at2 * zt2;\n    fxyz[1 + (4 * (j + l1))] = zero;\n    fxyz[2 + (4 * (j + l1))] = (-at4) * zt2;\n    fxyz[4 * ((j + k1) + l1)] = zero;\n    fxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    fxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    at1 = at1 * ((q[j + lj] * conjf(q[j + lj])) + (q[j + l1] * conjf(q[j + l1])));\n    wp += (double) at1;\n  }\n\n  at1 = crealf(ffc[ll]) * cimagf(ffc[ll]);\n  at4 = dkz * at1;\n  zt1 = cimagf(q[lj]) - (crealf(q[lj]) * _Complex_I);\n  fxyz[4 * lj] = zero;\n  fxyz[1 + (4 * lj)] = zero;\n  fxyz[2 + (4 * lj)] = at4 * zt1;\n  fxyz[4 * (k1 + lj)] = zero;\n  fxyz[1 + (4 * (k1 + lj))] = zero;\n  fxyz[2 + (4 * (k1 + lj))] = zero;\n  fxyz[4 * l1] = zero;\n  fxyz[1 + (4 * l1)] = zero;\n  fxyz[2 + (4 * l1)] = zero;\n  fxyz[4 * (k1 + l1)] = zero;\n  fxyz[1 + (4 * (k1 + l1))] = zero;\n  fxyz[2 + (4 * (k1 + l1))] = zero;\n  at1 = at1 * (q[lj] * conjf(q[lj]));\n  wp += (double) at1;\n  sum1 += wp;\n}\n\n", "pragma": "omp for nowait private(j,k,l,k1,l1,ll,lj,kk,kj,dky,dkz,at1,at2,at3,at4,zt1,zt2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/26"}
{"code": "for (j = 1; j < (height - 1); j++)\n{\n  for (i = 1; i < (width - 1); i++)\n  {\n    if ((nms[t] >= t2) && (out[t] == 0))\n    {\n      out[t] = 255;\n      nedges = 1;\n      edges[0] = t;\n      do\n      {\n        nedges--;\n        const int e = edges[nedges];\n        int nbs[8];\n        nbs[0] = e - width;\n        nbs[1] = e + width;\n        nbs[2] = e + 1;\n        nbs[3] = e - 1;\n        nbs[4] = nbs[0] + 1;\n        nbs[5] = nbs[0] - 1;\n        nbs[6] = nbs[1] + 1;\n        nbs[7] = nbs[1] - 1;\n        for (k = 0; k < 8; k++)\n        {\n          if ((nms[nbs[k]] >= t1) && (out[nbs[k]] == 0))\n          {\n            out[nbs[k]] = 255;\n            edges[nedges] = nbs[k];\n            nedges++;\n          }\n\n        }\n\n      }\n      while (nedges > 0);\n    }\n\n    t++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheTwoOfUs/video-canny-edge-detection/mpi-omp/mpi-omp/5"}
{"code": "for (j = 0; j < nright; j++)\n  temp_right[j] = arr[(m + 1) + j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/himanshudhawale/MergeSort-OpenMP-Loop/mergesort/1"}
{"code": "for (i = 0; i < N; ++i)\n  duration[i] = 1 + (rand() % 5);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xi-liu-cs/mpi-openmp-cuda-project/openmp/2022.4.5/1"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n  assert(v[i][j] == 1);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/cxx/success_collapse_01/1"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i += incX + 2, j += incY + 2)\n{\n  o2 = _mm_set_ps(*(XP + i), *((XP + i) + 1), *((XP + i) + 1), *(XP + i));\n  rm = _mm_mul_ps(o1, o2);\n  rm = _mm_addsub_ps(rm, _mm_shuffle_ps(rm, rm, _MM_SHUFFLE(0, 0, 3, 2)));\n  _mm_store_ps(t, rm);\n  *(YP + j) += t[0];\n  *((YP + j) + 1) += t[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/axpy/8"}
{"code": "for (chunk = 0; chunk < num_chunks; chunk++)\n{\n  int32_t r_start = GSTEP * (chunk / chunks_in_col);\n  int32_t c_start = GSTEP * (chunk % chunks_in_row);\n  int32_t r_end = ((r_start + GSTEP) > h) ? (h) : (r_start + GSTEP);\n  int32_t c_end = ((c_start + GSTEP) > w) ? (w) : (c_start + GSTEP);\n  int32_t r;\n  int32_t c;\n  for (c = c_start; c < c_end; c += GSTEP)\n  {\n    for (r = r_start; r < r_end; r += GSTEP)\n    {\n      for (y = c_start; y < c_end; ++y)\n      {\n        for (x = r_start; x < r_end; ++x)\n        {\n          uint32_t alive = 0;\n          uint32_t undead = 0;\n          for (y1 = y - 1; y1 <= (y + 1); y1++)\n          {\n            for (x1 = x - 1; x1 <= (x + 1); x1++)\n            {\n              if ((((y1 >= 0) && (y1 < h)) && (x1 >= 0)) && (x1 < w))\n              {\n                alive += univ[y1][x1] == 1;\n                undead += univ[y1][x1] == 2;\n              }\n\n            }\n\n          }\n\n          fprintf(stderr, \"univ[%u][%u] state=%u alive=%u undead=%u\\n\", y, x, univ[y][x], alive, undead);\n          if (univ[y][x] == 1)\n          {\n            if (undead > 1)\n            {\n              new[y][x] = 0;\n            }\n            else\n              if ((undead == 1) && (alive > 2))\n            {\n              new[y][x] = 1;\n            }\n            else\n              if ((undead == 1) && (alive <= 2))\n            {\n              new[y][x] = 2;\n            }\n            else\n              if (alive > 4)\n            {\n              new[y][x] = 0;\n            }\n            else\n            {\n              new[y][x] = 1;\n            }\n\n\n\n\n          }\n          else\n            if (univ[y][x] == 2)\n          {\n            if (alive > 3)\n            {\n              new[y][x] = 0;\n            }\n            else\n              if ((alive == 3) && (undead == 3))\n            {\n              new[y][x] = 2;\n            }\n            else\n              if (undead > 4)\n            {\n              new[y][x] = 0;\n            }\n            else\n            {\n              new[y][x] = 2;\n            }\n\n\n\n          }\n          else\n          {\n            if (alive == 3)\n            {\n              new[y][x] = 1;\n            }\n            else\n              if (undead > 2)\n            {\n              new[y][x] = 2;\n            }\n            else\n            {\n              new[y][x] = 0;\n            }\n\n\n          }\n\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(u, univ, new) firstprivate(w, h, num_chunks, chunks_in_row, chunks_in_col) private(x, x1, y, y1, chunk) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/lovelace/game-of-unlife/gou/9"}
{"code": "for (int i = 0; i < memorySize; i++)\n  isPrime[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketthakare/sieve-of-eratosthenes/sieve-v-30/0"}
{"code": "for (k = 0; k <= (grid_points[2] - 1); k += 1)\n{\n  tmp1 = 1.0 / u[i][j][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  fjac[i][j][k][0][0] = 0.0;\n  fjac[i][j][k][0][1] = 0.0;\n  fjac[i][j][k][0][2] = 0.0;\n  fjac[i][j][k][0][3] = 1.0;\n  fjac[i][j][k][0][4] = 0.0;\n  fjac[i][j][k][1][0] = (-(u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][1][1] = u[i][j][k][3] * tmp1;\n  fjac[i][j][k][1][2] = 0.0;\n  fjac[i][j][k][1][3] = u[i][j][k][1] * tmp1;\n  fjac[i][j][k][1][4] = 0.0;\n  fjac[i][j][k][2][0] = (-(u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][2][1] = 0.0;\n  fjac[i][j][k][2][2] = u[i][j][k][3] * tmp1;\n  fjac[i][j][k][2][3] = u[i][j][k][2] * tmp1;\n  fjac[i][j][k][2][4] = 0.0;\n  fjac[i][j][k][3][0] = (-((u[i][j][k][3] * u[i][j][k][3]) * tmp2)) + ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][3][1] = ((-c2) * u[i][j][k][1]) * tmp1;\n  fjac[i][j][k][3][2] = ((-c2) * u[i][j][k][2]) * tmp1;\n  fjac[i][j][k][3][3] = ((2.0 - c2) * u[i][j][k][3]) * tmp1;\n  fjac[i][j][k][3][4] = c2;\n  fjac[i][j][k][4][0] = (((c2 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * tmp2) - (c1 * (u[i][j][k][4] * tmp1))) * (u[i][j][k][3] * tmp1);\n  fjac[i][j][k][4][1] = ((-c2) * (u[i][j][k][1] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][4][2] = ((-c2) * (u[i][j][k][2] * u[i][j][k][3])) * tmp2;\n  fjac[i][j][k][4][3] = (c1 * (u[i][j][k][4] * tmp1)) - ((0.50 * c2) * ((((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + ((3.0 * u[i][j][k][3]) * u[i][j][k][3])) * tmp2));\n  fjac[i][j][k][4][4] = (c1 * u[i][j][k][3]) * tmp1;\n  njac[i][j][k][0][0] = 0.0;\n  njac[i][j][k][0][1] = 0.0;\n  njac[i][j][k][0][2] = 0.0;\n  njac[i][j][k][0][3] = 0.0;\n  njac[i][j][k][0][4] = 0.0;\n  njac[i][j][k][1][0] = ((-c3c4) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][1][1] = c3c4 * tmp1;\n  njac[i][j][k][1][2] = 0.0;\n  njac[i][j][k][1][3] = 0.0;\n  njac[i][j][k][1][4] = 0.0;\n  njac[i][j][k][2][0] = ((-c3c4) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][2][1] = 0.0;\n  njac[i][j][k][2][2] = c3c4 * tmp1;\n  njac[i][j][k][2][3] = 0.0;\n  njac[i][j][k][2][4] = 0.0;\n  njac[i][j][k][3][0] = (((-con43) * c3c4) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][3][1] = 0.0;\n  njac[i][j][k][3][2] = 0.0;\n  njac[i][j][k][3][3] = ((con43 * c3) * c4) * tmp1;\n  njac[i][j][k][3][4] = 0.0;\n  njac[i][j][k][4][0] = (((((-(c3c4 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c3c4 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - ((((con43 * c3c4) - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]);\n  njac[i][j][k][4][1] = ((c3c4 - c1345) * tmp2) * u[i][j][k][1];\n  njac[i][j][k][4][2] = ((c3c4 - c1345) * tmp2) * u[i][j][k][2];\n  njac[i][j][k][4][3] = (((con43 * c3c4) - c1345) * tmp2) * u[i][j][k][3];\n  njac[i][j][k][4][4] = c1345 * tmp1;\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,k) firstprivate (c3c4,c1345,c1,c2,c3,c4,con43)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/64"}
{"code": "for (int k = 0; k < len; k++)\n{\n  if (s[k] == ' ')\n  {\n    counter++;\n  }\n\n  if (counter == (i + 1))\n  {\n    break;\n  }\n\n  if (counter == i)\n  {\n    if (s[k] != ' ')\n      temp += s[k];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ahmadelmasri95/multiplecache-openmp-project/src/main/3"}
{"code": "for (i = 1; i <= N; ++i)\n{\n  printf(\"[%d][tid.%d] fib(%d) = %d\\n\", my_id, (int) syscall(SYS_gettid), i, fib(i));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deborasetton/cpar-openmp-mpi-examples/openmp/v16_eg02_fib_tasks/0"}
{"code": "for (int j = 0; j < k; j++)\n{\n  int tid = omp_get_thread_num();\n  findHull(xc[j], yc[j], clust_size[j], con_x, con_y, &con_n);\n  for (int i = 0; i < con_n; i++)\n  {\n    fin_x[fin_n + i] = con_x[i];\n    fin_y[fin_n + i] = con_y[i];\n  }\n\n  fin_n += con_n;\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(k) private(con_x,con_y,con_n) shared(xc,yc,clust_size,fin_x,fin_y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/pc/2"}
{"code": "for (i = 0; i < num_edges; i++)\n{\n  edgeList->edges_array_dest[i] = sorted_edges_array->edges_array_dest[i];\n  edgeList->edges_array_src[i] = sorted_edges_array->edges_array_src[i];\n  edgeList->edges_array_weight[i] = sorted_edges_array->edges_array_weight[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/countsort/7"}
{"code": "for (i = 0; i < l; i++)\n{\n  for (j = 0; j < t; j++)\n    uold[i][j] = u[i][j];\n\n}\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/jacobiVect/0"}
{"code": "for (int i = 0; i < nth; i++)\n  t.push_back(thread(multiplicacionCneon, i, nth, A, B, C, (int) size));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/davidbejarcaceres/Histogram-Android-Kotlin-Coroutines/app/src/main/cpp/native-lib/28"}
{"code": "for (int i = 1; i <= 1; ++i)\n{\n  avg_times[i] = calcAvgTime(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vidit23/ParallelProgramming/Assignment-1/Q3/q3/1"}
{"code": "for (i = begin; i < mid; i++)\n{\n  globB[i] = bot[i - begin];\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW2/flt_val_sort/2"}
{"code": "for (size_t i = 1; i < (n_vals + 1); ++i)\n{\n  if (!settings.nm_settings.custom_initial_simplex)\n  {\n    if (init_out_vals(i - 1) != 0.0)\n    {\n      simplex_points.row(i) = BMO_MATOPS_TRANSPOSE(init_out_vals + ((0.05 * init_out_vals(i - 1)) * unit_vec(i - 1, n_vals)));\n    }\n    else\n    {\n      simplex_points.row(i) = BMO_MATOPS_TRANSPOSE(init_out_vals + (0.00025 * unit_vec(i - 1, n_vals)));\n    }\n\n  }\n\n  simplex_fn_vals(i) = opt_objfn(BMO_MATOPS_TRANSPOSE(simplex_points.row(i)), nullptr, opt_data);\n  if (vals_bound)\n  {\n    simplex_points.row(i) = (transform < RowVec_t) > ((simplex_points.row(i), bounds_type, lower_bounds, upper_bounds));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kthohr/optim/src/unconstrained/nm/0"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n  if (rGeometry[i].IsNot(BOUNDARY))\n  return NonContact;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/9"}
{"code": "for (k = current_row; k < 4; k++)\n{\n  row_array[k] = row_array[k] - (value * send_row[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/4"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    foo();\n  }\n  {\n    foo();\n  }\n}\n\n", "pragma": "  #pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/ordered_messages/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  int in = i * n;\n  double sum = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    sum += at[in + j] * v[j];\n  }\n\n  b[i] = sum;\n}\n\n", "pragma": "    #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/21"}
{"code": "for (int i = 0; i < n_rows_; i++)\n{\n  for (int j = 0; j < n_cols_; j++)\n  {\n    int index = (i * n_cols_) + j;\n    if (pos_index_[index] < 0)\n      continue;\n\n    p_output[counter++] = CVT_FLT(connect_count[index]);\n    int acc_flowin_dir = compressed_dir[index];\n    if (acc_flowin_dir & 1)\n    {\n      if ((j != (n_cols_ - 1)) && (compressed_dir[index + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index + 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 2)\n    {\n      if (((i != (n_rows_ - 1)) && (j != (n_cols_ - 1))) && (compressed_dir[(index + n_cols_) + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index + n_cols_) + 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 4)\n    {\n      if ((i != (n_rows_ - 1)) && (compressed_dir[index + n_cols_] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index + n_cols_]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 8)\n    {\n      if (((i != (n_rows_ - 1)) && (j != 0)) && (compressed_dir[(index + n_cols_) - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index + n_cols_) - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 16)\n    {\n      if ((j != 0) && (compressed_dir[index - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 32)\n    {\n      if (((i != 0) && (j != 0)) && (compressed_dir[(index - n_cols_) - 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index - n_cols_) - 1]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 64)\n    {\n      if ((i != 0) && (compressed_dir[index - n_cols_] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[index - n_cols_]);\n      }\n\n    }\n\n    if (acc_flowin_dir & 128)\n    {\n      if (((i != 0) && (j != (n_cols_ - 1))) && (compressed_dir[(index - n_cols_) + 1] != dir_nodata_))\n      {\n        p_output[counter++] = CVT_FLT(pos_index_[(index - n_cols_) + 1]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/4"}
{"code": "for (int i = 1; i <= ((64 + 2) - 2); i++)\n  for (int j = 1; j <= ((64 + 2) - 2); j++)\n  if (((i + j) % 2) == 0)\n{\n  float b;\n  b = w * (((((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.) - A[i][j]);\n  A[i][j] = A[i][j] + b;\n}\n\n\n\n", "pragma": "omp parallel for collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariaMsu/red_black_parallel/v_openmp/redb_2d/2"}
{"code": "for (i = 0; i < (128 / 2); i++)\n{\n  pivots[i].x = i * 3;\n  pivots[i].y = i * 2;\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/k-nearest/src/k-nearest_gpu/1"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    u[i][j] = 1.0;\n    u_new[i][j] = 1.0;\n    if ((((x[i] > 0.5) && (x[i] < 1.0)) && (y[i] > 0.5)) && (y[i] < 1.0))\n    {\n      u[i][j] = 2.0;\n      u_new[i][j] = 2.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Linear Convection/2-D_Linear_Convection/main/0"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (ndvi_median[rowcol] <= 99999.99)\n  {\n    if ((ndvi_median[rowcol] * 0.0001) < ndvi_min)\n      ndvi_min = ndvi_median[rowcol] * 0.0001;\n\n    if ((ndvi_median[rowcol] * 0.0001) > ndvi_max)\n      ndvi_max = ndvi_median[rowcol] * 0.0001;\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol) shared(N, ndvi_min, ndvi_max, ndvi_median )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_SEBS/gdal_sebs_eta/2"}
{"code": "for (int i = 0; i < block; i++)\n{\n  if (calculated[i + (my_rank * block)] == (-1))\n  {\n    double tmp_coff = myA[(i * n) + j] / max_row[j];\n    myA[(i * n) + j] = 0;\n    for (int k = j + 1; k < n; k++)\n    {\n      myA[(i * n) + k] -= tmp_coff * max_row[k];\n    }\n\n    myb[i] -= tmp_coff * max_b;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(num_threads) shared(myA, myb) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bupingxx/Parallel-linear-equations-solver/src/gauss3/1"}
{"code": "for (i = 0; i < ((ptrdiff_t) (width * height)); ++i)\n{\n  unsigned char threshold = 127;\n  bool pixel = (test_above) ? (img_in[(((size_t) i) * stride) + offset] > threshold) : (img_in[(((size_t) i) * stride) + offset] < threshold);\n  bool_out[i] = pixel;\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chaquator/chaq-sdfgen/openmp/sdfgen/0"}
{"code": "for (i = 0; i < 3; i++)\n  for (j = 0; j < 5; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemafe7/SistemasDistribuidos/p5/2"}
{"code": "for (i = 0; i < maxThreads; i++)\n{\n  QuickSort(v, i * subArraySize, ((i * subArraySize) - 1) + subArraySize);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/QuickSort_Parallell/0"}
{"code": "for (i = 0; i < validationDataset->nOfPatterns; i++)\n{\n  validationDataset->inputs[i] = trainDataset->inputs[randomVector[i]];\n  validationDataset->outputs[i] = trainDataset->outputs[randomVector[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/32"}
{"code": "for (uint64_t i = 0; i < (NI / 204); i++)\n{\n  data_out[i * 188] = data_in[i * 204];\n  rsdec_204(((unsigned char *) data_out) + (i * 188), ((unsigned char *) data_in) + (i * 204));\n}\n\n", "pragma": "  #pragma omp parallel for use(hrw) module(reed_solomon_decoder)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/reed_solomon_decoder/sw/src/main/1"}
{"code": "for (long i = 0; i < m; ++i)\n{\n  for (long j = 0; j < n; ++j)\n  {\n    result += i + j;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/j-haj/collapse-test/main/1"}
{"code": "for (unsigned long i = 0; i < HEIGHT; ++i)\n{\n  for (unsigned long j = 0; j < WIDTH; ++j)\n  {\n    result[(i * HEIGHT) + j] = a[(i * HEIGHT) + j] + b[(i * HEIGHT) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/suma/0"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  for (k = 1; k < (neigh[i][0] + 1); k++)\n  {\n    j = neigh[i][k];\n    if (((i + j) % 2) == 0)\n      intraHardE += softcore(i, j, R_HC_INTRA);\n    else\n      interHardE += softcore(i, j, R_HC_INTER);\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:hardE) schedule(static)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/langevin/4"}
{"code": "for (i = 0; i <= m; ++i)\n{\n  dp[i][0] = i * pgap;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing11/p1/4"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x[i] = i * M_PI;\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/ATAX/atax/4"}
{"code": "for (i = 0; i < len; i++)\n{\n  if (numList[i] != 0)\n  {\n    answer[counter] = numList[i];\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theminigundude/CSCI-UA.0480-003-Parallel-Computing-Lab-2/genprime/3"}
{"code": "for (i = 0; i <= (w * h); i++)\n{\n  imageArray[i] = (unsigned char) ((rand() % 255) + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mrchowmein/Cuda_Comparison/openMPBlur/2"}
{"code": "for (int k = 0; k < n; k++)\n{\n  Q(k, 0) = q[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jar-evans/Krylov_subspace_methods/libKrylov/3"}
{"code": "for (int j = 0; j < NUM_POINTS_T; j++)\n{\n  for (int i = 0; i < NUM_POINTS_0; i++)\n  {\n    (Solution << Results[j][i]) << \" \";\n    (Solution_Phi_z << Results_Phi_z[j][i]) << \" \";\n    (Solution_Phi_x << Results_Phi_x[j][i]) << \" \";\n    (Solution_Eta_x << Results_Eta_x[j][i]) << \" \";\n  }\n\n  (((((((((EdgeValuesFile << \"t = \") << ((double) ((j + 1) * DT))) << \": Absolute difference between edge values = \") << fabs(EdgeValues[j][0] - EdgeValues[j][1])) << endl) << \"left edge = \") << Results_Eta_x[j][0]) << \" and right edge = \") << Results_Eta_x[j][1]) << endl;\n  Solution << endl;\n  Solution_Phi_z << endl;\n  Solution_Phi_x << endl;\n  Solution_Eta_x << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/0"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  switch (argv[i][0])\n  {\n    case 'p':\n      data->pN = atoi(&argv[i][1]);\n      if (data->pN < 1)\n      return 4;\n\n      parseCount++;\n      break;\n\n    case 'b':\n      data->bN = atoi(&argv[i][1]);\n      if (data->bN < 2)\n      return 2;\n\n      parseCount++;\n      break;\n\n    case 'c':\n      data->cN = atoi(&argv[i][1]);\n      if ((data->cN > 100) || (data->cN <= 0))\n      return 3;\n\n      parseCount++;\n      break;\n\n    case 'm':\n      data->mN = atoi(&argv[i][1]);\n      parseCount++;\n      break;\n\n    case 's':\n      data->sN = atoi(&argv[i][1]);\n      break;\n\n    case 't':\n      data->tN = atoi(&argv[i][1]);\n      if (data->tN == 1)\n      return 1;\n\n      parseCount++;\n      break;\n\n    case 'i':\n      data->iN = 1;\n      break;\n\n    default:\n      return 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daudich/RBOpenMP/orbs/6"}
{"code": "for (i = 0; i < matrix.count; i++)\n{\n  matrix.elements[i].value.f *= scalar;\n}\n\n", "pragma": "omp parallel for shared(matrix,scalar) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/1"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  x[i] = 2 * i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/allocate/test_allocate_on_device/0"}
{"code": "for (int i = 0; i < (pattlength - 1); i++)\n  h = (d * h) % prime;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RadhikaBailurkar/OpenMP/PatternSearch/0"}
{"code": "for (j = 0; j < 512; j++)\n{\n  B[i][j] += A[i][k] * B[k][j];\n  B[i + 1][j] += A[i + 1][k] * B[k][j];\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP1/PA2-Prob1-unr-nowait/0"}
{"code": "for (t = 0; t < NT; t++)\n{\n  for (i = 0; i < NX; i++)\n  {\n    f << solution[((2 * t) * NX) + i];\n    if (i != (NX - 1))\n    {\n      f << \",\";\n    }\n\n  }\n\n  endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omi14098/Parallel-PDE-solvers/1D/omp1DPDE/2"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  b = b & a[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitand/2"}
{"code": "for (c = 0; c < 3; c++)\n{\n  int clusterSize = clusters[c].numDatapoints;\n  double *distances = malloc(clusterSize * (sizeof(double)));\n  #pragma acc parallel for\n  for (i = 0; i < clusterSize; i++)\n  {\n    distances[i] = 0.0;\n    for (j = 0; j < clusterSize; j++)\n    {\n      distances[i] += distance(*clusters[c].datapoints[i], *clusters[c].datapoints[j]);\n    }\n\n  }\n\n  int medoidIndex = indexOfSmallestElement(distances, clusterSize);\n  clusters[c].medoid = clusters[c].datapoints[medoidIndex];\n  free(distances);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/57"}
{"code": "for (int i = 1; i < 100; i++)\n{\n  {\n    var[i] = var[i - 1] + 1;\n  }\n}\n\n", "pragma": "omp parallel for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB155-missingordered-orig-gpu-no/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    result[i] += a[i][j] * b[j];\n  }\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task5/OpenMPtask5/1"}
{"code": "for (procIndex = 1; procIndex < 4; procIndex++)\n{\n  MPI_Recv(current, 1000 * processHeight, (MPI_Datatype) 0x4c00040a, procIndex, 1, 1, &status);\n  printImage(current, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShaunJorstad/Hybrid-parallelized-thermal-conduction/jacobiHybrid/5"}
{"code": "for (i = 1; i <= m; i++)\n{\n  for (j = 1; j <= n; j++)\n  {\n    while (b[i - 1][j] == 0)\n      ;\n\n    diag = c[i - 1][j - 1] + ((X[i - 1] == Y[j - 1]) ? (+1) : (-1));\n    up = c[i - 1][j] + (-3);\n    left = c[i][j - 1] + (-3);\n    if ((diag >= up) && (diag >= left))\n    {\n      c[i][j] = diag;\n      b[i][j] = '\\\\';\n    }\n    else\n      if (up >= left)\n    {\n      c[i][j] = up;\n      b[i][j] = '|';\n    }\n    else\n    {\n      c[i][j] = left;\n      b[i][j] = '_';\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1) private(j,diag,up,left)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/auriza/pairwise-openmp/rowwise/0"}
{"code": "for (int i = 0; i < num_inner_loop_instructions; ++i)\n{\n  vmovntdq(ptr[rdi + (i * 32)], ymm0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jczaja/test-openmp/main/4"}
{"code": "for (int jj = 0; jj < params.nx; jj++)\n{\n  if ((((!obstacles[(ii * params.nx) + jj]) && ((cells[(ii * params.nx) + jj].speeds[3] - w1) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[6] - w2) > 0.0)) && ((cells[(ii * params.nx) + jj].speeds[7] - w2) > 0.0))\n  {\n    cells[(ii * params.nx) + jj].speeds[1] += w1;\n    cells[(ii * params.nx) + jj].speeds[5] += w2;\n    cells[(ii * params.nx) + jj].speeds[8] += w2;\n    cells[(ii * params.nx) + jj].speeds[3] -= w1;\n    cells[(ii * params.nx) + jj].speeds[6] -= w2;\n    cells[(ii * params.nx) + jj].speeds[7] -= w2;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/borektsioglou/OpenMP/d2q9-bgk/0"}
{"code": "for (k = 0; k < i; k++)\n{\n  sum_u += array_get(u, n, k + 1, i + 1) * array_get(l, n, i + 1, k + 1);\n}\n\n", "pragma": "omp parallel for reduction(+:sum_u) firstprivate(val, n, i) private(k)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matthewpoletin/LUMD/src/lu/openmp/0"}
{"code": "for (i = 0; i < n; i = i + 1)\n{\n  printf(\"%d \", tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_6/TD_OPENMP_06/4"}
{"code": "for (int i = 0; i < this->size_; ++i)\n{\n  this->vec_[i] = cast_vec->vec_[cast_perm->vec_[i]];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_vector/34"}
{"code": "for (int i = 0; i < 200; i++)\n{\n  sum0 += A[i] * C[i];\n}\n\n", "pragma": "omp parallel for simd reduction(+ : sum0)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/8.norace10/0"}
{"code": "for (i = 0; i < city_num; i++)\n{\n  if (ant->visited[i] != '\\0')\n    continue;\n\n  sum += probability[offset + i];\n  avail_city[index] = i;\n  city_prob[index] = probability[offset + i] + previous;\n  previous = city_prob[index];\n  index++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/12"}
{"code": "for (i = 0; i < 10000; i += 500)\n{\n  printf(\"w[%d] = %d\\n\", i, w[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charlesyangc/ECE563-Parallel-Programming/hw5/hw5Loop/0"}
{"code": "for (k = j + 1; k < n; k++)\n{\n  m = A[k][j] / A[j][j];\n  for (l = j; l < n; l++)\n  {\n    A[k][l] -= m * A[j][l];\n  }\n\n  b[k] -= m * b[j];\n}\n\n", "pragma": "omp parallel for private(k, l, m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Avantgarde95/Gauss/src/gauss_omp/0"}
{"code": "for (int i = 0; i < num_data; i++)\n{\n  if ((i % 2) == 0)\n  {\n    for (int j = 1; j < num_data; j += 2)\n    {\n      if (ser_data[j - 1] > ser_data[j])\n      {\n        ser_tmp = ser_data[j - 1];\n        ser_data[j - 1] = ser_data[j];\n        ser_data[j] = ser_tmp;\n      }\n\n    }\n\n  }\n  else\n  {\n    for (int j = 1; j < (num_data - 1); j += 2)\n    {\n      if (ser_data[j] > ser_data[j + 1])\n      {\n        ser_tmp = ser_data[j + 1];\n        ser_data[j + 1] = ser_data[j];\n        ser_data[j] = ser_tmp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_sort/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float maxEl = abs(A[i][i]);\n  int maxRow = i;\n  for (int k = i + 1; k < n; k++)\n  {\n    if (abs(A[k][i]) > maxEl)\n    {\n      maxEl = abs(A[k][i]);\n      maxRow = k;\n    }\n\n  }\n\n  for (int k = i; k < (n + 1); k++)\n  {\n    float tmp = A[maxRow][k];\n    A[maxRow][k] = A[i][k];\n    A[i][k] = tmp;\n  }\n\n  for (int k = i + 1; k < n; k++)\n  {\n    float c = (-A[k][i]) / A[i][i];\n    for (int j = i; j < (n + 1); j++)\n    {\n      if (i == j)\n      {\n        A[k][j] = 0;\n      }\n      else\n      {\n        A[k][j] += c * A[i][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Trabajo_SEL-Solutions/code/cpu_parallel_SEL-Solution/16"}
{"code": "for (splatt_blas_int i = 0; i < N; ++i)\n{\n  for (splatt_blas_int j = i; j < N; ++j)\n  {\n    neqs[j + (i * N)] *= mat[j + (i * N)];\n  }\n\n}\n\n", "pragma": "omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    sum_serial[i] += vec[j] * mat[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/mat_vec_mul/1"}
{"code": "for (size_t i = 0; i < points.size(); i++)\n{\n  final_hull = MergeHulls(final_hull, QuickHull(points[i]));\n}\n\n", "pragma": "    #pragma omp parallel for reduction(hull_merge:final_hull)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Hull/ConvexHullParallel/0"}
{"code": "for (int i = 0; i < _torsioncalculations.size(); ++i)\n{\n  if (gradients)\n  {\n    AddGradient(_torsioncalculations[i].force_a, _torsioncalculations[i].idx_a);\n    AddGradient(_torsioncalculations[i].force_b, _torsioncalculations[i].idx_b);\n    AddGradient(_torsioncalculations[i].force_c, _torsioncalculations[i].idx_c);\n    AddGradient(_torsioncalculations[i].force_d, _torsioncalculations[i].idx_d);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/3"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  a++;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/15"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  if (((((c[j] / cj) - 1.0) >= 0) ? ((c[j] / cj) - 1.0) : (-((c[j] / cj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/25"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = n - i;\n  sum += i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ilanfink/openmp-multithreading/openmp-multithreading/1"}
{"code": "for (int j = 0; j < n; ++j)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    double y = (j + 1) * dx;\n    double x = (i + 1) * dx;\n    u[i + (j * n)] = sin((PI * x) / length) * sin((PI * y) / length);\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd collapse(2) thread_limit(block_size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/heat-omp/heat/0"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->present[i] == iteration)\n  {\n    int start_edge = g->outgoing_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->outgoing_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int outgoing = g->outgoing_edges[neighbor];\n      if (frontier->present[outgoing] == BOTTOMUP_NOT_VISITED_MARKER)\n      {\n        distances[outgoing] = distances[i] + 1;\n        local_count++;\n        frontier->present[outgoing] = iteration + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+ : local_count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chaihf/BFS-OpenMP/bfs/bfs/2"}
{"code": "for (i = 0; i < leny; i++)\n{\n  head_sum = (tail_sum = 0.0);\n  ;\n  head_sum2 = (tail_sum2 = 0.0);\n  ;\n  aij = ai;\n  jx = kx;\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a_i[aij];\n    x_elem = head_x_i[jx];\n    {\n      double a1;\n      double a2;\n      double b1;\n      double b2;\n      double con;\n      con = a_elem * split;\n      a1 = con - a_elem;\n      a1 = con - a1;\n      a2 = a_elem - a1;\n      con = x_elem * split;\n      b1 = con - x_elem;\n      b1 = con - b1;\n      b2 = x_elem - b1;\n      head_prod = a_elem * x_elem;\n      tail_prod = ((((a1 * b1) - head_prod) + (a1 * b2)) + (a2 * b1)) + (a2 * b2);\n    }\n    {\n      double bv;\n      double s1;\n      double s2;\n      double t1;\n      double t2;\n      s1 = head_sum + head_prod;\n      bv = s1 - head_sum;\n      s2 = (head_prod - bv) + (head_sum - (s1 - bv));\n      t1 = tail_sum + tail_prod;\n      bv = t1 - tail_sum;\n      t2 = (tail_prod - bv) + (tail_sum - (t1 - bv));\n      s2 += t1;\n      t1 = s1 + s2;\n      s2 = s2 - (t1 - s1);\n      t2 += s2;\n      head_sum = t1 + t2;\n      tail_sum = t2 - (head_sum - t1);\n    }\n    x_elem = tail_x_i[jx];\n    {\n      double a1;\n      double a2;\n      double b1;\n      double b2;\n      double con;\n      con = a_elem * split;\n      a1 = con - a_elem;\n      a1 = con - a1;\n      a2 = a_elem - a1;\n      con = x_elem * split;\n      b1 = con - x_elem;\n      b1 = con - b1;\n      b2 = x_elem - b1;\n      head_prod = a_elem * x_elem;\n      tail_prod = ((((a1 * b1) - head_prod) + (a1 * b2)) + (a2 * b1)) + (a2 * b2);\n    }\n    {\n      double bv;\n      double s1;\n      double s2;\n      double t1;\n      double t2;\n      s1 = head_sum2 + head_prod;\n      bv = s1 - head_sum2;\n      s2 = (head_prod - bv) + (head_sum2 - (s1 - bv));\n      t1 = tail_sum2 + tail_prod;\n      bv = t1 - tail_sum2;\n      t2 = (tail_prod - bv) + (tail_sum2 - (t1 - bv));\n      s2 += t1;\n      t1 = s1 + s2;\n      s2 = s2 - (t1 - s1);\n      t2 += s2;\n      head_sum2 = t1 + t2;\n      tail_sum2 = t2 - (head_sum2 - t1);\n    }\n    aij += incaij;\n    jx += incx;\n  }\n\n  {\n    double a11;\n    double a21;\n    double b1;\n    double b2;\n    double c11;\n    double c21;\n    double c2;\n    double con;\n    double t1;\n    double t2;\n    con = head_sum * split;\n    a11 = con - head_sum;\n    a11 = con - a11;\n    a21 = head_sum - a11;\n    con = alpha_i * split;\n    b1 = con - alpha_i;\n    b1 = con - b1;\n    b2 = alpha_i - b1;\n    c11 = head_sum * alpha_i;\n    c21 = ((((a11 * b1) - c11) + (a11 * b2)) + (a21 * b1)) + (a21 * b2);\n    c2 = tail_sum * alpha_i;\n    t1 = c11 + c2;\n    t2 = (c2 - (t1 - c11)) + c21;\n    head_tmp1 = t1 + t2;\n    tail_tmp1 = t2 - (head_tmp1 - t1);\n  }\n  {\n    double a11;\n    double a21;\n    double b1;\n    double b2;\n    double c11;\n    double c21;\n    double c2;\n    double con;\n    double t1;\n    double t2;\n    con = head_sum2 * split;\n    a11 = con - head_sum2;\n    a11 = con - a11;\n    a21 = head_sum2 - a11;\n    con = alpha_i * split;\n    b1 = con - alpha_i;\n    b1 = con - b1;\n    b2 = alpha_i - b1;\n    c11 = head_sum2 * alpha_i;\n    c21 = ((((a11 * b1) - c11) + (a11 * b2)) + (a21 * b1)) + (a21 * b2);\n    c2 = tail_sum2 * alpha_i;\n    t1 = c11 + c2;\n    t2 = (c2 - (t1 - c11)) + c21;\n    head_tmp2 = t1 + t2;\n    tail_tmp2 = t2 - (head_tmp2 - t1);\n  }\n  {\n    double bv;\n    double s1;\n    double s2;\n    double t1;\n    double t2;\n    s1 = head_tmp1 + head_tmp2;\n    bv = s1 - head_tmp1;\n    s2 = (head_tmp2 - bv) + (head_tmp1 - (s1 - bv));\n    t1 = tail_tmp1 + tail_tmp2;\n    bv = t1 - tail_tmp1;\n    t2 = (tail_tmp2 - bv) + (tail_tmp1 - (t1 - bv));\n    s2 += t1;\n    t1 = s1 + s2;\n    s2 = s2 - (t1 - s1);\n    t2 += s2;\n    head_tmp1 = t1 + t2;\n    tail_tmp1 = t2 - (head_tmp1 - t1);\n  }\n  y_elem = y_i[iy];\n  {\n    double a1;\n    double a2;\n    double b1;\n    double b2;\n    double con;\n    con = y_elem * split;\n    a1 = con - y_elem;\n    a1 = con - a1;\n    a2 = y_elem - a1;\n    con = beta_i * split;\n    b1 = con - beta_i;\n    b1 = con - b1;\n    b2 = beta_i - b1;\n    head_tmp2 = y_elem * beta_i;\n    tail_tmp2 = ((((a1 * b1) - head_tmp2) + (a1 * b2)) + (a2 * b1)) + (a2 * b2);\n  }\n  {\n    double bv;\n    double s1;\n    double s2;\n    double t1;\n    double t2;\n    s1 = head_tmp1 + head_tmp2;\n    bv = s1 - head_tmp1;\n    s2 = (head_tmp2 - bv) + (head_tmp1 - (s1 - bv));\n    t1 = tail_tmp1 + tail_tmp2;\n    bv = t1 - tail_tmp1;\n    t2 = (tail_tmp2 - bv) + (tail_tmp1 - (t1 - bv));\n    s2 += t1;\n    t1 = s1 + s2;\n    s2 = s2 - (t1 - s1);\n    t2 += s2;\n    head_tmp1 = t1 + t2;\n    tail_tmp1 = t2 - (head_tmp1 - t1);\n  }\n  y_i[iy] = head_tmp1;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/11"}
{"code": "for (int j = 0; j < NUMHID; j++)\n{\n  for (int k = 0; k < NUMOUT; k++)\n  {\n    SumDOW += WeightHO[k][j] * DeltaO[k];\n  }\n\n  DeltaH[j] = (SumDOW * Hidden[j]) * (1.0 - Hidden[j]);\n  for (int i = 0; i < NUMIN; i++)\n    DeltaWeightIH[j][i] = ((eta * tSet[p][i]) * DeltaH[j]) + (alpha * DeltaWeightIH[j][i]);\n\n  SumDOW = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Raptorino/NeuralNetworkMIMD/Code_OpenMP/nn-main/3"}
{"code": "for (i = 0; i < 32; ++i)\n{\n  gemm_gpu(TA, TB, m, n, k, 1, a, lda, b, ldb, 1, c, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openmpf/openmpf-component-archive/DarknetDetection/darknet_lib/src/gemm/8"}
{"code": "for (int i = 0; i < MAX_ROWS; ++i)\n{\n  for (int j = 0; j < MAX_COLS; ++j)\n  {\n    _itoa_s(averages[i][j], numString, 10);\n    int k = 0;\n    char temp = numString[k];\n    while (temp != '\\0')\n    {\n      output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + k] = temp;\n      temp = numString[++k];\n    }\n\n    output[((i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (j * (MAX_CHARS + 1))) + MAX_CHARS] = '\\t';\n  }\n\n  output[(i * (((MAX_COLS * MAX_CHARS) + MAX_COLS) + 1)) + (MAX_COLS * (MAX_CHARS + 1))] = '\\n';\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic, 100) firstprivate(numString) shared(data)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BlurEffect/OpenMP/OpenMPAssignment/02_Sortout_Parallel_For/7"}
{"code": "for (int i = 0; i < (READER_THREADS * num_p); i++)\n{\n  MPI_Status status;\n  int flag;\n  char complete_message[25] = \"CompletedReadingAllFiles\";\n  MPI_Recv(&flag, 1, MPI_INT, MPI_ANY_SOURCE, FILE_REQUEST_TAG, MPI_COMM_WORLD, &status);\n  MPI_Send(complete_message, MAX_FILENAME_LENGTH, MPI_CHAR, status.MPI_SOURCE, FILE_BROADCAST_TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramachav/Map-Reduce-Multi-Threaded/Map_Reduce_Code/map_reduce/2"}
{"code": "for (i = 0; i < (2 * N); i++)\n  mag[i] = sqrt(((f[i][0] * f[i][0]) + (f[i][1] * f[i][1])) + (f[i][2] * f[i][2]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/3"}
{"code": "for (int i = 0; i < SIFT_SIZE; i++)\n{\n  if (s1[i] < s2[i])\n    dist += pow(s2[i] - s1[i], 2);\n  else\n    dist += pow(s1[i] - s2[i], 2);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/siftcmp/2"}
{"code": "for (i = 0; i < 10; i++)\n{\n  m++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/cvalidation/omp_pragma_example2/3"}
{"code": "for (jrow = 0; jrow <= 7; jrow += 1)\n{\n  real8 hj1 = h * c[(jrow + l8) * 4];\n  for (icol = 0; icol <= 7; icol += 1)\n  {\n    a[icol + ((jrow + l8) * 8)] += hj1 * tmp[icol];\n  }\n\n}\n\n", "pragma": "omp parallel for private (icol,jrow) firstprivate (l8,h)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_regression01/1"}
{"code": "for (int i = (M * N) - ((M * N) % 4); i < (M * N); i++)\n{\n  C[i] *= beta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  *(array + i) = rand() % 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/4"}
{"code": "for (i = 0; i < num_steps; i++)\n{\n  float partial_sum = partial_sum_calculate(i, step);\n  Sum = Sum + partial_sum;\n}\n\n", "pragma": "omp parallel for reduction(+ : Sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chennakeshava1998/CO316-Heterogenous-Parallel-Computing/A5-OpenMP/6/0"}
{"code": "for (int i = 0; i < fila; i++)\n{\n  for (int j = 0; j < colunma; j++)\n  {\n    ma[i][j].Herida = rand() % 2;\n    ran = rand() % 101;\n    if (ran <= 65)\n    {\n      ma[i][j].Estado.verde = 1;\n      ma[i][j].Estado.naranja = 0;\n      ma[i][j].Estado.rojo = 0;\n      ma[i][j].Estado.azul = 0;\n      ma[i][j].Estado.blanco = 0;\n    }\n    else\n    {\n      ran2 = (rand() % 1001) / 10;\n      if (ran2 <= 1.5)\n      {\n        ma[i][j].Estado.verde = 0;\n        ma[i][j].Estado.naranja = 0;\n        ma[i][j].Estado.rojo = 1;\n        ma[i][j].Estado.azul = 0;\n        ma[i][j].Estado.blanco = 0;\n      }\n      else\n      {\n        ran2 = (rand() % 1001) / 10;\n        if (ran2 <= 0.5)\n        {\n          ma[i][j].Estado.verde = 0;\n          ma[i][j].Estado.naranja = 1;\n          ma[i][j].Estado.rojo = 0;\n          ma[i][j].Estado.azul = 0;\n          ma[i][j].Estado.blanco = 0;\n        }\n        else\n        {\n          ran = rand() % 101;\n          if (ran <= 50)\n          {\n            ma[i][j].Estado.verde = 0;\n            ma[i][j].Estado.naranja = 0;\n            ma[i][j].Estado.rojo = 0;\n            ma[i][j].Estado.azul = 1;\n            ma[i][j].Estado.blanco = 0;\n          }\n          else\n          {\n            ma[i][j].Estado.verde = 0;\n            ma[i][j].Estado.naranja = 0;\n            ma[i][j].Estado.rojo = 0;\n            ma[i][j].Estado.azul = 0;\n            ma[i][j].Estado.blanco = 1;\n          }\n\n        }\n\n      }\n\n    }\n\n    ran = rand() % 101;\n    if (ran <= 30)\n    {\n      ma[i][j].Edad = rand() % 145;\n    }\n\n    if ((ran > 30) && (ran <= 80))\n    {\n      ma[i][j].Edad = (rand() % (((35 * 48) - (4 * 48)) + 1)) + (4 * 48);\n    }\n\n    if (ran > 80)\n    {\n      ma[i][j].Edad = (rand() % (((100 * 48) - (36 * 48)) + 1)) + (36 * 48);\n    }\n\n    ma[i][j].Podado = 0;\n    ma[i][j].Enfermo = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nachoLedesma1/openMP2/openMPLedesmaIgnacio/1"}
{"code": "for (int i = 0; i <= 6; i++)\n{\n  m = max(m, rand() % 10);\n  printf(\"Th %i: m = %i\\n\", omp_get_thread_num(), m);\n}\n\n", "pragma": "#pragma omp parallel for reduction(max:m)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/epoell/openMP_examples_and_Matrix-Matrix-Multiplication/min_examples/4"}
{"code": "for (i = 0; i <= c->ncols; ++i)\n  c->colPtr[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/3"}
{"code": "for (int i = 0; i < (num_points - 1); i++)\n{\n  integral_mult = integral_mult + ((h / 2.0) * (func_x(a + (i * h)) + func_x(a + ((i + 1) * h))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/5/Numerical_Integration/main/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/greenmapc/OpenMP-MPI/OpenMP/Task8/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  f[i] = f[i] + (dt * smb[i]);\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) shared(f,dt,N,smb) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victor13165/projet-1-SNHP/CPP/projet1/4"}
{"code": "for (i = 0; i < num_nodes; ++i)\n{\n  for (j = 0; j < num_nodes; ++j)\n  {\n    if (((dist[i][k] == INT_MAX) || (dist[k][j] == INT_MAX)) || (i == j))\n      continue;\n\n    int new_dist = dist[i][k] + dist[k][j];\n    if (dist[i][j] <= new_dist)\n      continue;\n\n    dist[i][j] = new_dist;\n    paths[i][j] = k;\n  }\n\n}\n\n", "pragma": "\t#pragma omp for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alec-Horne/parallel-processing/OpenMP-NQMQ/FloydOMP/2"}
{"code": "for (k = 0; k < np; k++)\n{\n  for (i = 0; i < nd; i++)\n  {\n    f[i + (k * nd)] = 0.0;\n  }\n\n  for (j = 0; j < np; j++)\n  {\n    if (k != j)\n    {\n      d = dist(nd, pos + (k * nd), pos + (j * nd), rij);\n      if (d < PI2)\n      {\n        d2 = d;\n      }\n      else\n      {\n        d2 = PI2;\n      }\n\n      pe = pe + (0.5 * pow(sin(d2), 2));\n      for (i = 0; i < nd; i++)\n      {\n        f[i + (k * nd)] = f[i + (k * nd)] - ((rij[i] * sin(2.0 * d2)) / d);\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < nd; i++)\n  {\n    ke = ke + (vel[i + (k * nd)] * vel[i + (k * nd)]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/md_open_mp/0"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    w[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/4"}
{"code": "for (int i = 0; i < 10000000; i += 4)\n{\n  float32x4_t y_vec = vld1q_f32(y_1 + i);\n  float32x4_t x_vec = vld1q_f32(x_1 + i);\n  y_vec = vmlaq_f32(y_vec, a, x_vec);\n  vst1q_f32(y_1 + i, y_vec);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denporras/CE-4202-Taller3_OpenMP_2/saxpy_par/jni/saxpy_par/0"}
{"code": "for (i = 1; i < numProces; i++)\n{\n  terminate = 1;\n  MPI_Send(&terminate, 1, MPI_INT, i, TAG1, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mkdan91/ParallelKmeans/Kmeans/Main/9"}
{"code": "for (int i = 0; i < treen_points_val.size(); i++)\n{\n  treen_points_val[i] = (ccoeff * tconc_points_val[i]) - (pcoeff * tconp_points_val[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashb/tbslas/src/applications/src/advdiff-ss-tv-extrap/0"}
{"code": "for (int i = 0; i < total_values; i++)\n{\n  sum1 += pow(p1.values[i], 2.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/2"}
{"code": "for (int i = 0; i < N; ++i)\n  if (A[i] != 10)\n{\n  printf(\"Error! %d != %d\\n\", A[i], 10);\n  return 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-is-device-ptr-all-directives/test/1"}
{"code": "for (long i = 0; i < N; i++)\n{\n  err += (F_err[i] - F[i]) * (F_err[i] - F[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikitaP2001/3d_course_parallel/OpenMp/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  int subid = CVT_INT(m_subbsnID[i]);\n  if (m_rchID[i] > 0)\n    tmp_latNO3ToCh[subid] += m_latNO3[i];\n\n  tmp_surfRfNO3ToCh[subid] += m_surfRfNO3[i] * m_cellArea;\n  tmp_surfRfNH4ToCh[subid] += m_surfRfNH4[i] * m_cellArea;\n  tmp_surfRfSolPToCh[subid] += m_surfRfSolP[i] * m_cellArea;\n  tmp_surfRfCodToCh[subid] += m_surfRfCod[i] * m_cellArea;\n  float ratio2_gw = 1.f;\n  tmp_percoNGw[subid] += (m_percoN[i] * m_cellArea) * ratio2_gw;\n  tmp_percoPGw[subid] += (m_percoP[i] * m_cellArea) * ratio2_gw;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrMV/NutrientMovementViaWater/2"}
{"code": "for (i = 0; i < 1000000; i++)\n  arr[i] = rand() % 50;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rnikhori/OpenMP/histogram/0"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  d = row_ptr[i + 1] - row_ptr[i];\n  if (maxDegree < d)\n    maxDegree = d;\n\n  if (minDegree > d)\n    minDegree = d;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/berkerdemirel/Parallel-Breadth-First-Search-OpenMP-and-CUDA/CPU/qbfs/2"}
{"code": "for (k = 0; k < ny; k++)\n{\n  for (j = 0; j < nxs; j += 4)\n  {\n    v_cu = _mm512_load_ps(&cu[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)]);\n    v_cu = _mm512_add_ps(_mm512_load_ps(&cu[(4 * j) + ((4 * nxe) * k)]), v_cu);\n    _mm512_store_ps(&cu[(4 * j) + ((4 * nxe) * k)], v_cu);\n    _mm512_store_ps(&cu[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)], v_zero);\n  }\n\n  for (j = nxs; j < nx; j++)\n  {\n    cu[(4 * j) + ((4 * nxe) * k)] += cu[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)];\n    cu[(1 + (4 * j)) + ((4 * nxe) * k)] += cu[((1 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)];\n    cu[(2 + (4 * j)) + ((4 * nxe) * k)] += cu[((2 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)];\n    cu[((4 * j) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n    cu[((1 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n    cu[((2 + (4 * j)) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n  }\n\n  cu[(4 * nxe) * k] += cu[((4 * nx) + ((4 * nxe) * k)) + (nxyen * nz)];\n  cu[1 + ((4 * nxe) * k)] += cu[((1 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)];\n  cu[2 + ((4 * nxe) * k)] += cu[((2 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)];\n  cu[((4 * nx) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n  cu[((1 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n  cu[((2 + (4 * nx)) + ((4 * nxe) * k)) + (nxyen * nz)] = 0.0;\n}\n\n", "pragma": "omp for private(j,k,v_cu)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/12"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  koff = (2 * nxhd) * k;\n  k1 = ((2 * nxhd) * ny) - koff;\n  for (jj = 0; jj < 2; jj++)\n  {\n    t1 = cimagf(f[jj + k1]) + (crealf(f[jj + k1]) * _Complex_I);\n    f[jj + k1] = conjf(f[jj + koff] - t1);\n    f[jj + koff] += t1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mpic2/mpush2/14"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  rotate_matrix_serial(serial_res, n);\n  rotate_matrix_parallel(parallel_res, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/matrix-rotate-omp/main/1"}
{"code": "for (i = myid + 1; i <= n; i += numprocs)\n{\n  x = h * (((double) i) - 0.5);\n  sum += 4.0 / (1.0 + (x * x));\n  if ((omp_get_thread_num() % 2) == 0)\n    putchar('.');\n  else\n    putchar('-');\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kc9qey/mpi_openmp/cpiw/0"}
{"code": "for (int n = 0; n < N; n++)\n{\n  z[n] = distribution(gen);\n  int val = 0;\n  for (int j = 0; j < M; j++)\n  {\n    double r = distribution(gen);\n    val += (pow(sqrt(1 - ccov), M - (j + 1)) * r) * P[j][n];\n  }\n\n  x[i][n] = m[t & 1][n] + (sigma * ((pow(sqrt(1 - ccov), M) * z[n]) + (sqrt(ccov) * val)));\n}\n\n", "pragma": "            #pragma omp prallel for shared(x,m,sigma,ccov,p,z)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/RmES_omp_alt/3"}
{"code": "for (intptr_t i = 0; i <= N; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/sum/sum_reduction/0"}
{"code": "for (j = jbeg; j <= jfin; j++)\n{\n  jglob = j;\n  for (k = ki1; k <= ki2; k++)\n  {\n    phi2[j][k] = C2 * (u[ifin][j][k][4] - ((0.50 * ((pow2(u[ifin][j][k][1]) + pow2(u[ifin][j][k][2])) + pow2(u[ifin][j][k][3]))) / u[ifin][j][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/42"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  L2:\n  foo();\n\n}\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-omp/clang/test/OpenMP/target_teams_distribute_parallel_for_messages/1"}
{"code": "for (unsigned int i = 0; i < input.size(); i++)\n{\n  for (unsigned int j = 0; j < input[i].size(); j++)\n  {\n    (cout << input[i][j]) << endl;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/4"}
{"code": "for (int i = 5; i < 16; i = i + (2 * i))\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/51"}
{"code": "for (logn = 1; logn <= logn_max; logn++)\n{\n  strcpy(mode, \"SEQ\");\n  wtime = omp_get_wtime();\n  estimate = r8_pi_est_seq(n);\n  wtime = omp_get_wtime() - wtime;\n  error = r8_abs(estimate - r8_pi);\n  (((((((((((((((cout << \"  \") << setw(14)) << n) << \"  \") << setw(3)) << mode) << \"  \") << setw(14)) << estimate) << \"  \") << setw(14)) << error) << \"  \") << setw(14)) << wtime) << \"\\n\";\n  strcpy(mode, \"OMP\");\n  wtime = omp_get_wtime();\n  estimate = r8_pi_est_omp(n);\n  wtime = omp_get_wtime() - wtime;\n  error = r8_abs(estimate - r8_pi);\n  (((((((((((((((cout << \"  \") << setw(14)) << n) << \"  \") << setw(3)) << mode) << \"  \") << setw(14)) << estimate) << \"  \") << setw(14)) << error) << \"  \") << setw(14)) << wtime) << \"\\n\";\n  n = n * 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejetzer/test_openmp/compute_pi_openmp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (fabs(c_d[i] - validate_d[i]) > EPS_DOUBLE)\n  {\n    ++N_errors;\n    if (!flag)\n    {\n      printf(\"First fail: c_d[%d](%f) != validate_d[%d](%f)\\n\", i, c_d[i], i, validate_d[i]);\n      flag = true;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/examples/openmp/vmul_template/vmul_template/4"}
{"code": "for (h = 0; h < alto; h++)\n{\n  mini = max(M - h, 0);\n  supi = min((alto + M) - h, N);\n  for (w = 0; w < ancho; w++)\n  {\n    redAux = 0, greenAux = 0, blueAux = 0;\n    for (i = mini; i < supi; i++)\n    {\n      aux = image->pixel(w, (h - M) + i);\n      redAux += vectorGauss[i] * qRed(aux);\n      greenAux += vectorGauss[i] * qGreen(aux);\n      blueAux += vectorGauss[i] * qBlue(aux);\n    }\n\n    ;\n    indice = (h * ancho) + w;\n    red[indice] = redAux;\n    green[indice] = greenAux;\n    blue[indice] = blueAux;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidCarneros/Arco_OpenMP/GaussianCompleto/GaussianCompleto/1"}
{"code": "for (cRow = 0; cRow < n_row; cRow++)\n{\n  for (cCol = 0; cCol < n_col; cCol++)\n  {\n    *((A + (cCol * n_row)) + cRow) = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ddsihongliang/ece_5720/hw2/hs983_hw2_openmp_sort_column/1"}
{"code": "for (int i = 0; i < numprocs; i++)\n{\n  row_start[i] = row_counter;\n  if (row_modulo)\n  {\n    row_counter += rows_per_proc + 1;\n    row_modulo--;\n  }\n  else\n  {\n    row_counter += rows_per_proc;\n  }\n\n  row_counter = min(row_counter, TOTAL_ROW);\n  row_end[i] = row_counter;\n  col_start[i] = col_counter;\n  if (col_modulo)\n  {\n    col_counter += cols_per_proc + 1;\n    col_modulo--;\n  }\n  else\n    col_counter += cols_per_proc;\n\n  col_counter = min(col_counter, TOTAL_COLUMN);\n  col_end[i] = col_counter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/4"}
{"code": "for (int m = 0; m < itr; ++m)\n{\n  for (int i = 0; i < n; ++i)\n  {\n    x1 = x[i];\n    y1 = y[i];\n    for (int j = 0; j < d; ++j)\n    {\n      x1y1[j] = x1[j] * y1;\n    }\n\n    for (int k = 0; k < d; ++k)\n    {\n      w[k] = w[k] - (alpha * x1y1[k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vibhatha/OpenMP/code/exp1/OpenMPExamples/12"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  a[i] = 3 * a[i];\n  for (int j = 0; j < 4; ++j)\n  {\n    b[j] = b[j] + a[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-07-ParallelOmpForNestedOmpParallelFor/0"}
{"code": "for (int x = data_size_X - kern_cent_X; x < data_size_X; x++)\n{\n  for (int y = 0; y < kern_cent_Y; y++)\n  {\n    for (int j = -y; j <= kern_cent_Y; j++)\n    {\n      for (int i = -kern_cent_X; i <= ((data_size_X - 1) - x); i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n  for (int y = data_size_Y - kern_cent_Y; y < data_size_Y; y++)\n  {\n    for (int j = -kern_cent_Y; j <= ((data_size_Y - 1) - y); j++)\n    {\n      for (int i = -kern_cent_X; i <= ((data_size_X - 1) - x); i++)\n      {\n        out[x + (y * data_size_X)] += kernel[(kern_cent_X - i) + ((kern_cent_Y - j) * 3)] * in[(x + i) + ((y + j) * data_size_X)];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kt9302/ImageConvolution/part2/3"}
{"code": "for (i = 0; i < num_line; i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    printf(\" %d\", localMatrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/12"}
{"code": "for (int i = 0; i < n_tasks; i++)\n{\n  MPI_Send(task_problemhashs[i].c_str(), 128, MPI_CHAR, root, collect_results_tag3, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing10/test/5"}
{"code": "for (int o0 = 0; o0 < 28; o0 += 2)\n  for (int o1 = 0; o1 < 28; o1 += 2)\n{\n  double bias = net->bias0_1[0];\n  double max = -bias;\n  max = (features->layer1[0][o0][o1] > max) ? (features->layer1[0][o0][o1]) : (max);\n  max = (features->layer1[0][o0][o1 + 1] > max) ? (features->layer1[0][o0][o1 + 1]) : (max);\n  max = (features->layer1[0][o0 + 1][o1] > max) ? (features->layer1[0][o0 + 1][o1]) : (max);\n  max = (features->layer1[0][o0 + 1][o1 + 1] > max) ? (features->layer1[0][o0 + 1][o1 + 1]) : (max);\n  features->layer2[0][o0 >> 1][o1 >> 1] = max + bias;\n  bias = net->bias0_1[1];\n  max = -bias;\n  max = (features->layer1[1][o0][o1] > max) ? (features->layer1[1][o0][o1]) : (max);\n  max = (features->layer1[1][o0][o1 + 1] > max) ? (features->layer1[1][o0][o1 + 1]) : (max);\n  max = (features->layer1[1][o0 + 1][o1] > max) ? (features->layer1[1][o0 + 1][o1]) : (max);\n  max = (features->layer1[1][o0 + 1][o1 + 1] > max) ? (features->layer1[1][o0 + 1][o1 + 1]) : (max);\n  features->layer2[1][o0 >> 1][o1 >> 1] = max + bias;\n  bias = net->bias0_1[2];\n  max = -bias;\n  max = (features->layer1[2][o0][o1] > max) ? (features->layer1[2][o0][o1]) : (max);\n  max = (features->layer1[2][o0][o1 + 1] > max) ? (features->layer1[2][o0][o1 + 1]) : (max);\n  max = (features->layer1[2][o0 + 1][o1] > max) ? (features->layer1[2][o0 + 1][o1]) : (max);\n  max = (features->layer1[2][o0 + 1][o1 + 1] > max) ? (features->layer1[2][o0 + 1][o1 + 1]) : (max);\n  features->layer2[2][o0 >> 1][o1 >> 1] = max + bias;\n  bias = net->bias0_1[3];\n  max = -bias;\n  max = (features->layer1[3][o0][o1] > max) ? (features->layer1[3][o0][o1]) : (max);\n  max = (features->layer1[3][o0][o1 + 1] > max) ? (features->layer1[3][o0][o1 + 1]) : (max);\n  max = (features->layer1[3][o0 + 1][o1] > max) ? (features->layer1[3][o0 + 1][o1]) : (max);\n  max = (features->layer1[3][o0 + 1][o1 + 1] > max) ? (features->layer1[3][o0 + 1][o1 + 1]) : (max);\n  features->layer2[3][o0 >> 1][o1 >> 1] = max + bias;\n  bias = net->bias0_1[4];\n  max = -bias;\n  max = (features->layer1[4][o0][o1] > max) ? (features->layer1[4][o0][o1]) : (max);\n  max = (features->layer1[4][o0][o1 + 1] > max) ? (features->layer1[4][o0][o1 + 1]) : (max);\n  max = (features->layer1[4][o0 + 1][o1] > max) ? (features->layer1[4][o0 + 1][o1]) : (max);\n  max = (features->layer1[4][o0 + 1][o1 + 1] > max) ? (features->layer1[4][o0 + 1][o1 + 1]) : (max);\n  features->layer2[4][o0 >> 1][o1 >> 1] = max + bias;\n  bias = net->bias0_1[5];\n  max = -bias;\n  max = (features->layer1[5][o0][o1] > max) ? (features->layer1[5][o0][o1]) : (max);\n  max = (features->layer1[5][o0][o1 + 1] > max) ? (features->layer1[5][o0][o1 + 1]) : (max);\n  max = (features->layer1[5][o0 + 1][o1] > max) ? (features->layer1[5][o0 + 1][o1]) : (max);\n  max = (features->layer1[5][o0 + 1][o1 + 1] > max) ? (features->layer1[5][o0 + 1][o1 + 1]) : (max);\n  features->layer2[5][o0 >> 1][o1 >> 1] = max + bias;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NegarNd/CNN-Inference-Acceleration/main_omp/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < res[i].size(); j++)\n  {\n    res[i][j].push_back(0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AnomDevgun/ParallelComputing/openMP/cp/2"}
{"code": "for (int i = 0; i < length_A; i++)\n  a[i] = (double *) malloc(dims * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/distance/7"}
{"code": "for (int i = 0; i < n; i++)\n  wu[i] = 0;\n\n", "pragma": "omp parallel for shared(wu)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sg0/bin-packing/direct/new/bin_packing_omp_par/0"}
{"code": "for (int i = 1; i < (size_n + 1); i++)\n{\n  u_old[(i * (size_n + 2)) + (size_n + 1)] = dataRight[i - 1];\n  u_old[(i * (size_n + 2)) + 0] = dataLeft[i - 1];\n  u_old[(0 * (size_n + 2)) + i] = dataUp[i - 1];\n  u_old[((size_n + 1) * (size_n + 2)) + i] = dataDown[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TollisK/Jacobi-Method-Parallel-Programming/parallelJacobi_mp/7"}
{"code": "for (i = 1; i < (30 - 1); i++)\n{\n  for (j = 1; j < (30 - 1); j++)\n  {\n    int thread = calc_thread(30, 30, i, j);\n    printf(\"%d L: %p\\n\", thread, &mean);\n    printf(\"%d S: %p\\n\", thread, &w[i][j]);\n    w[i][j] = mean;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/desparza22/openmp_implementations/heated_plate/heated_plate_openmp/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  result += fabsf(x[i * inc_x]);\n}\n\n", "pragma": "omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/2"}
{"code": "for (int k = 0; k < instance->n_items; k++)\n  if (strcmp(id, instance->item_name[k]) == 0)\n{\n  item_number = k;\n  break;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/13"}
{"code": "for (int _i0 = 2; _i0 < R; _i0 = _i0 + 1)\n{\n  #pragma ivdep\n  for (int _i1 = 2; _i1 < C; _i1 = _i1 + 1)\n  {\n    Syy[(_i0 * (2 + C)) + _i1] = (((((((Iyy[(((-1) + _i0) * (2 + C)) + ((-1) + _i1)] + Iyy[(((-1) + _i0) * (2 + C)) + _i1]) + Iyy[(((-1) + _i0) * (2 + C)) + (1 + _i1)]) + Iyy[(_i0 * (2 + C)) + ((-1) + _i1)]) + Iyy[(_i0 * (2 + C)) + _i1]) + Iyy[(_i0 * (2 + C)) + (1 + _i1)]) + Iyy[((1 + _i0) * (2 + C)) + ((-1) + _i1)]) + Iyy[((1 + _i0) * (2 + C)) + _i1]) + Iyy[((1 + _i0) * (2 + C)) + (1 + _i1)];\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victornicolet/harris-corner-implementations/bench_source/harris_polymage_naive/5"}
{"code": "for (int i = 2; i < ((int) sqrt((double) size)); i++)\n{\n  if (!primes[i])\n    continue;\n\n  for (int j = i * 2; j < size; j += i)\n    primes[j] = false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fizyk93/OpenMP/main/8"}
{"code": "for (int i = jump / 2; i < n; i++)\n{\n  if (i < jump)\n    A[!index][i] = A[index][i];\n  else\n    A[!index][i] = A[index][i] + A[index][i - jump];\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic,chunk) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelgalliakis/openMP_cnt16009_cnt16003/erot1/parallelPrefix_A_Opt/0"}
{"code": "for (i = 0; i < leny; i++)\n{\n  y[iy] = 0.0;\n  iy += incy;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv2_x/4"}
{"code": "for (; blockNum >= rArrayLen; blockNum >>= 1, bLen <<= 1)\n{\n  float *blocks[rArrayLen];\n  float *blockBound[rArrayLen];\n  float *output[rArrayLen >> 1];\n  for (size_t i = 0; i < blockNum; i += rArrayLen)\n  {\n    size_t startIndex = i * bLen;\n    blocks[0] = data.buffers[data.selector] + startIndex;\n    for (int j = 1; j < rArrayLen; ++j)\n      blocks[j] = blocks[j - 1] + bLen;\n\n    copy(blocks + 1, blocks + rArrayLen, blockBound);\n    blockBound[rArrayLen - 1] = blocks[rArrayLen - 1] + bLen;\n    output[0] = data.buffers[data.selector ^ 1] + startIndex;\n    for (int j = 1; j < (rArrayLen >> 1); ++j)\n      output[j] = output[j - 1] + (bLen << 1);\n\n    loadSimdDataInitial(rData, blocks, rArrayLen, 1);\n    size_t loop = ((bLen * 2) / simdLen) - 1;\n    for (size_t i = 0; i < loop; ++i)\n    {\n      loadSimdData(rData, blocks, blockBound, rArrayLen, 1);\n      (bitonicSort428 < 4) > ((rData, true));\n      storeSimdData(rData, output, rArrayLen, 1, 0);\n    }\n\n    storeSimdData(rData, output, rArrayLen, 1, 1);\n  }\n\n  data.selector ^= 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/milesxu/Hybrid_Sort/cpu_sort_dbuf/6"}
{"code": "for (int i = 0; i < 512; i++)\n{\n  W[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maturocha/multiplication-matrix/src/openmp_multiplication/3"}
{"code": "for (int process_id = 1; process_id < process_count; process_id++)\n{\n  MPI_Send(&VERTEX_COUNT, 1, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  MPI_Send(&EDGE_COUNT, 1, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  for (int i = 0; i < EDGE_COUNT; i++)\n  {\n    size_t length = sizeof(Edge);\n    int pos = 0;\n    char buffer[length];\n    MPI_Pack(&EDGES[i].begin, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Pack(&EDGES[i].end, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Pack(&EDGES[i].value, 1, (MPI_Datatype) 0x4c000405, buffer, length, &pos, (MPI_Comm) 0x44000000);\n    MPI_Send(buffer, pos, (MPI_Datatype) 0x4c00010f, process_id, 1, (MPI_Comm) 0x44000000);\n  }\n\n  MPI_Send(EDGE_INDICES, VERTEX_COUNT * VERTEX_COUNT, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n  MPI_Send(VALUE_LEFT, EDGE_COUNT, (MPI_Datatype) 0x4c000405, process_id, 1, (MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/20"}
{"code": "for (j = 0; j < J; j++)\n{\n  uo[j] = u[j];\n}\n\n", "pragma": "omp parallel for shared(u,uo) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcduta/programming/heat/1D/heat_omp/1"}
{"code": "for (i = 0; i < HWC_connect2_weights; i++)\n  fprintf(f, \"%lf \", network->layers[5]->weights[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/main/18"}
{"code": "for (int i = 0; i < size; i++)\n{\n  MPI_Scatter(ele_in_col_bloc, 1, MPI_INT, &ele_in_row_bloc[i], 1, MPI_INT, i, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prakharg24/openmpi_openmp_2d_sort/2d_sort/0"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (k = 0; k < nz; k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      frct[i][j][k][m] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/5"}
{"code": "for (i = 0; i < 20; i++)\n{\n  x[i] = -1.0;\n  if (omp_get_thread_num() == 0)\n  {\n    j = x[0];\n  }\n\n  if (omp_get_thread_num() == 0)\n  {\n    k = i + 0.05;\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB171-threadprivate3-orig-no/0"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  cu[3 * j] = zero;\n  cu[3 * (j + k1)] = zero;\n  cu[1 + (3 * (j + k1))] = zero;\n  cu[2 + (3 * (j + k1))] = zero;\n  cu[3 * (j + l1)] = zero;\n  cu[1 + (3 * (j + l1))] = zero;\n  cu[2 + (3 * (j + l1))] = zero;\n  cu[3 * ((j + k1) + l1)] = zero;\n  cu[1 + (3 * ((j + k1) + l1))] = zero;\n  cu[2 + (3 * ((j + k1) + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/47"}
{"code": "for (long i = 0; i < contRelationOk; i++)\n{\n  for (long j = start_to_check_pivot; j < (factorBase.size() + 1); j++)\n  {\n    if (listExponentOk_mod2[i][j] == 1)\n    {\n      vect_solution[i] = -1;\n      vect_pivot[i] = j;\n      start_to_check_pivot++;\n      n_free_var--;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alessandroPetz/qsieve_omp/qsieve_openmp_gmp/5"}
{"code": "for (i = 0; i < numVertices; ++i)\n{\n  vertex_cnt[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iMeanHow/OpenMP/Radix/src/sort/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  kernel_matrix(i, i) = diag;\n  for (int j = 0; j < i; j++)\n  {\n    u = sum(pow(X.row(i) - X.row(j), 2));\n    if ((u > (-1)) && (u < 1))\n      kernel_matrix(j, i) = pow(1 - (u * u), 3);\n\n    kernel_matrix(i, j) = kernel_matrix(j, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/utilities/2"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    (cout << a[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/4"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  while (!is_ql_queue_empty(invite_ql, i))\n  {\n    invitation *invite = dequeue(invite_ql, i);\n    min_invitation(&data->invite, invite);\n  }\n\n  if ((data->invite.y == data->default_leader) && (data->invite.x == data->leader))\n    data->committee = data->leader;\n\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/kcommittee/4"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  B[i] = A[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project2/K-Means-OpenMP/3"}
{"code": "for (i = 0; i < 10; i++)\n  A[i] = 2;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/01_critical_sections/1"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n      fprintf(logFile, \"OK\\n\");\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(logFile, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(logFile, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(logFile, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(logFile, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_static/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += array[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ctomacheski/openmp-flisol/examples/lock/0"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i += incX + 2, j += incY + 2)\n{\n  save.REEL = YP[j];\n  save.IMAG = YP[j + 1];\n  YP[j] = XP[j];\n  YP[j + 1] = XP[j];\n  XP[i] = save.REEL;\n  XP[i + 1] = save.IMAG;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/swap/5"}
{"code": "for (int j = 0; j < grid; j++)\n  for (int k = 0; k < grid; k++)\n{\n  int blk = ((i + j) + k) % grid;\n  long ai = (i * sBLK) * BLK;\n  long aj = (blk * sBLK) * BLK;\n  long bi = (blk * sBLK) * BLK;\n  long bj = (j * sBLK) * BLK;\n  mymult(&A[INDEX(ai, aj, n)], &B[INDEX(bi, bj, n)], &C[INDEX(ai, bj, n)], s, s, s, n);\n}\n\n\n", "pragma": "omp parallel for private(id,nthreads) num_threads(20)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcheng761/Parallel-Block-Multiplier/mymult/1"}
{"code": "for (i = 12; i > 0; i--)\n{\n  B = (((B - S[(2 * i) + 1]) >> (A & (32 - 1))) | ((B - S[(2 * i) + 1]) << (32 - (A & (32 - 1))))) ^ A;\n  A = (((A - S[2 * i]) >> (B & (32 - 1))) | ((A - S[2 * i]) << (32 - (B & (32 - 1))))) ^ B;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sara7860/Enhancement-of-RC5-Algorithm/project code/parallel/2"}
{"code": "for (int i = 0; i < bins.size(); i++)\n  for (int j = 0; j < bins[i].size(); j++)\n{\n  index = bins[i][j].index;\n  particles[index] = bins[i][j];\n  pmove(particles[index]);\n}\n\n\n", "pragma": "#pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosjgm/High-Performance-Computing/N-body-simulation/OpenMP/6"}
{"code": "for (int j = 0; j < N; j += SMALL_N)\n{\n  int sub_N = (SMALL_N < (N - j)) ? (SMALL_N) : (N - j);\n  {\n    for (int i = 0; i < M; i += SMALL_M)\n    {\n      int sub_M = (SMALL_M < (M - i)) ? (SMALL_M) : (M - i);\n      compute(A + ((i * lda) + (k * STRIDE)), B + ((j * lda) + k), C + ((j * lda) + i), sub_M, sub_N, sub_K, lda);\n    }\n\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-bad/9"}
{"code": "for (int e = 0; e < num_particles; e++)\n{\n  const float mass = particles->mass[e];\n  const float velocity_x = particles->velocity_x[e];\n  const float velocity_y = particles->velocity_y[e];\n  const float velocity_z = particles->velocity_z[e];\n  const float position_x = particles->position_x[e];\n  const float position_y = particles->position_y[e];\n  const float position_z = particles->position_z[e];\n  const float time_by_mass = time_interval / mass;\n  const float half_time_interval = 0.5f * time_interval;\n  const float velocity_change_x = forces->x[e] * time_by_mass;\n  const float velocity_change_y = forces->y[e] * time_by_mass;\n  const float velocity_change_z = forces->z[e] * time_by_mass;\n  const float position_change_x = velocity_x + (velocity_change_x * half_time_interval);\n  const float position_change_y = velocity_y + (velocity_change_y * half_time_interval);\n  const float position_change_z = velocity_z + (velocity_change_z * half_time_interval);\n  particles->velocity_x[e] = velocity_x + velocity_change_x;\n  particles->velocity_y[e] = velocity_y + velocity_change_y;\n  particles->velocity_z[e] = velocity_z + velocity_change_z;\n  particles->position_x[e] = position_x + position_change_x;\n  particles->position_y[e] = position_y + position_change_y;\n  particles->position_z[e] = position_z + position_change_z;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_tasks_OmpSs/nbody/src/plain/solver_omp/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (((fabs(C[i] - C_ref[i]) > 1e-3) || (fabs(theta[i] - theta_ref[i]) > 1e-3)) || (fabs(K[i] - K_ref[i]) > 1e-3))\n  {\n    ok = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vanGenuchten-omp/main/3"}
{"code": "for (int i = 0; i < 9; ++i)\n  h[i] = 0.0f;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bspline-vgh-omp/main/0"}
{"code": "for (int sl = 0; sl < (numMySlices + (2 * halo)); sl++)\n{\n  Z = (firstSlice - halo) + sl;\n  if (Z < 0)\n    Z = Nz + Z;\n\n  if (Z >= Nz)\n    Z = Z - Nz;\n\n  for (int Y = 0; Y < Ny; Y++)\n  {\n    for (int X = 0; X < Nx; X++)\n    {\n      tid = (X + (Y * Nx)) + ((sl * Nx) * Ny);\n      if (X == 0)\n      {\n        if (!((((Y == 0) || (Y == (Ny - 1))) || (Z == 0)) || (Z == (Nz - 1))))\n        {\n          lnl[tid] = 1;\n        }\n\n      }\n      else\n      {\n        lnl[tid] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stu314159/LDC-3D-CUDA-OMP/lbm_utils/5"}
{"code": "for (i = 0; i < matrixSize; ++i)\n{\n  for (j = 0; j < matrixSize; ++j)\n  {\n    array[i][j] = (rand() % 10) + 1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PureDevPer/Distributed-and-Parallel-Computing/MonteCarlo using pThread, OpenMP/Part3/Parallel/p3Omp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (*matrix)[i] = (float *) calloc(n, sizeof(float));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  a[i] += foo(i);\n}\n\n", "pragma": "\t#pragma omp for shared (a,n) private (i) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/loop/0"}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char key[24];\n  unsigned char iv[16];\n  SHA_CTX ctx;\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, saved_key[index], saved_len[index]);\n  SHA1_Update(&ctx, cur_salt->salt, 10);\n  SHA1_Final(key, &ctx);\n  memset(key + 20, 0, 4);\n  if (cur_salt->pw_len)\n  {\n    int i;\n    unsigned char s_secret[48];\n    unsigned char c_secret[48];\n    unsigned char combined_sk[24];\n    unsigned char final_key[32];\n    unsigned char password[(16 + 32) + 16];\n    char *dec_pw = ((char *) password) + 16;\n    int blen = (saved_len[index] + 15) / 16;\n    MD5_CTX ctx;\n    if (cur_salt->pw_len == blen)\n    {\n      memset(iv, 0, 16);\n      aesDec(cur_salt->ct, s_secret, key, 3, iv);\n      memset(iv, 0, 16);\n      aesDec(cur_salt->csk, c_secret, key, 3, iv);\n      for (i = 0; i < 24; i++)\n        combined_sk[i] = s_secret[16 + i] ^ c_secret[16 + i];\n\n      MD5_Init(&ctx);\n      MD5_Update(&ctx, combined_sk, 16);\n      MD5_Final(final_key, &ctx);\n      MD5_Init(&ctx);\n      MD5_Update(&ctx, combined_sk + 16, 8);\n      MD5_Final(final_key + 16, &ctx);\n      memset(iv, 0, 16);\n      aesDec(cur_salt->pw, password, final_key, cur_salt->pw_len + 1, iv);\n      if (!memcmp(dec_pw, saved_key[index], saved_len[index]))\n      {\n        char *p = (dec_pw + (16 * blen)) - 1;\n        int n;\n        int pad;\n        int res = 1;\n        n = (pad = *p);\n        while (n--)\n        {\n          if ((*(p--)) != pad)\n          {\n            res = 0;\n            break;\n          }\n\n        }\n\n        if (res)\n        {\n          cracked[index] = 1;\n          any_cracked |= 1;\n        }\n\n      }\n\n    }\n\n  }\n  else\n  {\n    unsigned char pt[16];\n    memcpy(iv, cur_salt->ct + 16, 16);\n    aesDec(cur_salt->ct + 32, pt, key, 1, iv);\n    if (!memcmp(pt + 8, \"\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\", 8))\n    {\n      cracked[index] = 1;\n      any_cracked |= 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/o5logon_fmt_plug/4"}
{"code": "for (iIteration = 0; iIteration < MAX_NUM_ITERATIONS_4_CONV; iIteration++)\n{\n  fxErr = 0.0;\n  for (i = 0; i < n; i++)\n  {\n    double fSum;\n    double fDiff;\n    fSum = b[i];\n    for (j = 0; j < n; j++)\n      fSum -= A[i][j] * xk[j];\n\n    fSum += A[i][i] * xk[i];\n    xkp1[i] = fSum / A[i][i];\n    fDiff = xkp1[i] - xk[i];\n    fxErr += fDiff * fDiff;\n  }\n\n  if (fxErr < ATOL)\n    break;\n  else\n  {\n    for (i = 0; i < n; i++)\n      xk[i] = xkp1[i];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/1"}
{"code": "for (int b = 6; b <= 10; b++)\n{\n  int c = 1;\n  d = d * b;\n  int n = d * b;\n  printf(\"\\n El factorial de %d es %d \", b, d);\n}\n\n", "pragma": "omp for schedule(static,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ferjml97/OpenMp_Lib/Ejercicios/05 ejercicio/ejercicio_05/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = N; j < M; j++)\n  {\n    *((sigmaInv + (i * M)) + j) = 0.0;\n    *((sigmaPtr + (j * N)) + i) = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yash98/parallelized-principal-component-analysis/lab2_omp/10"}
{"code": "for (i = 0; i < (npart * 3); i += 3)\n{\n  double fxi = 0.0;\n  double fyi = 0.0;\n  double fzi = 0.0;\n  int j;\n  for (j = i + 3; j < (npart * 3); j += 3)\n  {\n    double xx = x[i] - x[j];\n    double yy = x[i + 1] - x[j + 1];\n    double zz = x[i + 2] - x[j + 2];\n    if (xx < ((-0.5) * side))\n      xx += side;\n\n    if (xx > (0.5 * side))\n      xx -= side;\n\n    if (yy < ((-0.5) * side))\n      yy += side;\n\n    if (yy > (0.5 * side))\n      yy -= side;\n\n    if (zz < ((-0.5) * side))\n      zz += side;\n\n    if (zz > (0.5 * side))\n      zz -= side;\n\n    double rd = ((xx * xx) + (yy * yy)) + (zz * zz);\n    if (rd <= (rcoff * rcoff))\n    {\n      double rrd = 1.0 / rd;\n      double rrd3 = (rrd * rrd) * rrd;\n      double rrd4 = rrd3 * rrd;\n      double r148 = rrd4 * (rrd3 - 0.5);\n      epot += rrd3 * (rrd3 - 1.0);\n      vir -= rd * r148;\n      fxi += xx * r148;\n      fyi += yy * r148;\n      fzi += zz * r148;\n      ftemp[myid][j] -= xx * r148;\n      ftemp[myid][j + 1] -= yy * r148;\n      ftemp[myid][j + 2] -= zz * r148;\n    }\n\n  }\n\n  ftemp[myid][i] += fxi;\n  ftemp[myid][i + 1] += fyi;\n  ftemp[myid][i + 2] += fzi;\n}\n\n", "pragma": "omp for reduction(+:epot,vir) schedule(static,32)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/MolDyn/MolDynSol3/forces/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp9xcsieek.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (i = 0; i < STREAM_ARRAY_SIZE; i++)\n  c[i] = a[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/24"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + (((vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)]) - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]);\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - (vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)] - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_cell/0"}
{"code": "for (int32_t vi = 1; vi < nvtxs; ++vi)\n{\n  xaii[vi].start += xaii[vi - 1].start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/multistage-peeling/8"}
{"code": "for (long i = 0; i < NVer; i++)\n{\n  long adj1;\n  long adj2;\n  long de;\n  adj1 = verPtr[i];\n  adj2 = verPtr[i + 1];\n  de = adj2 - adj1;\n  if (de > realMaxDegree)\n    realMaxDegree = de;\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(max: realMaxDegree)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Coloring/coloringDistanceOne/1"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    matrix1OMP[i][j] = matrixOMP[a];\n    a++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/5"}
{"code": "for (i = 0; i < 50; i++)\n{\n  if (i != boidNum)\n  {\n    pVelo[0] += boidArray[i][3];\n    pVelo[1] += boidArray[i][4];\n    pVelo[2] += boidArray[i][5];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjhenning6/ASCII_boids_OpenMP/boids/3"}
{"code": "for (unsigned int g1 = 0; g1 < ng; g1++)\n{\n  for (int k = 0; k < nz; ++k)\n  {\n    for (int j = 0; j < ny; ++j)\n    {\n      for (int i = 0; i < nx; ++i)\n      {\n        g2g_source(0, i, j, k, g1) = fixed_source(i, j, k, g1);\n        for (unsigned int g2 = 0; g2 < ng; g2++)\n        {\n          if (g1 == g2)\n          {\n            continue;\n          }\n\n          g2g_source(0, i, j, k, g1) += gg_cs(mat(i, j, k) - 1, 0, g2, g1) * scalar_flux(g2, i, j, k);\n          unsigned int mom = 1;\n          for (unsigned int l = 1; l < nmom; l++)\n          {\n            for (int m = 0; m < lma(l); m++)\n            {\n              g2g_source(mom, i, j, k, g1) += gg_cs(mat(i, j, k) - 1, l, g2, g1) * scalar_mom(g2, mom - 1, i, j, k);\n              mom++;\n            }\n\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    val = rand() % 100;\n    (*matrix)[i][j] = val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/GaussJordan/GaussJordanSeq/4"}
{"code": "for (i = 2; i <= N; ++i)\n{\n  local_primes[j++] = i;\n}\n\n", "pragma": "omp for nowait schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephbieselin/Primes-OpenMP/parallel/genprime/0"}
{"code": "for (z = 0; z < OMP_zMax; z++)\n{\n  for (x = 0; x < OMP_xMax; x += 8)\n  {\n    int ind = OMP_Index(x, 0, z);\n    u[ind] *= boundryScale;\n    u[ind + 1] *= boundryScale;\n    u[ind + 2] *= boundryScale;\n    u[ind + 3] *= boundryScale;\n    u[ind + 4] *= boundryScale;\n    u[ind + 5] *= boundryScale;\n    u[ind + 6] *= boundryScale;\n    u[ind + 7] *= boundryScale;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/loopunroll16/3ompDeblur/0"}
{"code": "for (int i = 0; i < GRID_SIZE; ++i)\n{\n  for (int j = 0; j < GRID_SIZE; ++j)\n  {\n    if ((((double) rand()) / ((double) 32767)) < density)\n    {\n      grid[(i * GRID_SIZE) + j] = 1;\n    }\n    else\n    {\n      grid[(i * GRID_SIZE) + j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mvhv/gol-openmp/gol_collapse/2"}
{"code": "for (size_t i = 0; i < Nelt; i++)\n{\n  nodalDOF1(i) = (k + 2) * i;\n  nodalDOF2(i) = 1 + ((k + 2) * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/25"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double a_temp = 0;\n  for (int j = 0; j < 3; j++)\n  {\n    for (int k = 0; k < 3; k++)\n    {\n      water_system[i].Acceleration_total[j] = water_system[i].Acceleration[k][j];\n    }\n\n    a_temp += pow(water_system[i].Acceleration_total[j], 2);\n    if (sqrt(a_temp) > FormerMaxForce)\n    {\n      FormerMaxForce = sqrt(a_temp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DFTheory/Water-system-openMP/water_system/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    for (k = 0; k < 1000; k++)\n    {\n      mresult[i][j] = mresult[i][j] + (matrixa[i][k] * matrixb[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Willster419/parallel_computing_uac/PAC2/countersomp/0"}
{"code": "for (int i = 0; i < 6; i++)\n  step_dir[i] *= -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/6"}
{"code": "for (int i = 0; i < arrayLength; ++i)\n{\n  printf(\"%d\\n\", pIntArray[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivaneduardomv/OpenMPTest/ompBubble1/2"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((u[m][i][j][k - 2] - (4.0 * u[m][i][j][k - 1])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/144"}
{"code": "for (int i = 0; i < N_b; ++i)\n{\n  printf(\"%c\", seq_b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/3"}
{"code": "for (int i = 0; i < 3; i++)\n  A_copy[i] = (double *) calloc(3, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/critical/0"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double sumReal = 0.0;\n  double sumImaginary = 0.0;\n  for (uint p = 0; p < length; ++p)\n  {\n    unsigned long currentAtom = startAtom + p;\n    if (particleHasNoCharge[currentAtom])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(p + startAtom, kxRef[box][i], kyRef[box][i], kzRef[box][i], currentCoords);\n    sumReal += particleCharge[currentAtom] * cos(dotProduct);\n    sumImaginary += particleCharge[currentAtom] * sin(dotProduct);\n  }\n\n  for (uint s = 0; s < lambdaSize; s++)\n  {\n    double coefDiff = sqrt(lambda_Coul[s]) - sqrt(lambda_Coul[iState]);\n    energyRecip[s] += prefactRef[box][i] * (((sumRref[box][i] + (coefDiff * sumReal)) * (sumRref[box][i] + (coefDiff * sumReal))) + ((sumIref[box][i] + (coefDiff * sumImaginary)) * (sumIref[box][i] + (coefDiff * sumImaginary))));\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for default(none) shared(lambda_Coul, lambdaSize, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/12"}
{"code": "for (int i = 0; i < img_size; i++)\n{\n  output[i].x = (ref_output[i].x = (input[i].x = rand() % 256));\n  output[i].y = (ref_output[i].y = (input[i].y = rand() % 256));\n  output[i].z = (ref_output[i].z = (input[i].z = rand() % 256));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/overlay-omp/main/1"}
{"code": "for (int ii = 0; ii < N; ii++)\n  S[me] += array[ii];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_loops/02_falsesharing/0"}
{"code": "for (int i = 0; i < initialPopulationSize; i++)\n{\n  this->population.push_back(random());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/krris/openmp-evolutionary-algorithm/src/Population/0"}
{"code": "for (i = 0; i < buckets_count; i++)\n{\n  free(buckets[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pedrycz/c-parallel-programming/openmp/openmp_bucket_sort/4"}
{"code": "for (j = jend - 1; j >= jst; j--)\n{\n  if (j != (jend - 1))\n  {\n    while (flag2[j + 1] == 0)\n    {\n      ;\n    }\n\n  }\n\n  if (j != jst)\n  {\n    while (flag2[j] == 1)\n    {\n      ;\n    }\n\n  }\n\n  for (i = iend - 1; i >= ist; i--)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[j][i][m] = tv[j][i][m] + (omega * ((((((((((udy[j][i][0][m] * v[k][j + 1][i][0]) + (udx[j][i][0][m] * v[k][j][i + 1][0])) + (udy[j][i][1][m] * v[k][j + 1][i][1])) + (udx[j][i][1][m] * v[k][j][i + 1][1])) + (udy[j][i][2][m] * v[k][j + 1][i][2])) + (udx[j][i][2][m] * v[k][j][i + 1][2])) + (udy[j][i][3][m] * v[k][j + 1][i][3])) + (udx[j][i][3][m] * v[k][j][i + 1][3])) + (udy[j][i][4][m] * v[k][j + 1][i][4])) + (udx[j][i][4][m] * v[k][j][i + 1][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[0][m] = d[j][i][0][m];\n      tmat[1][m] = d[j][i][1][m];\n      tmat[2][m] = d[j][i][2][m];\n      tmat[3][m] = d[j][i][3][m];\n      tmat[4][m] = d[j][i][4][m];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[0][1];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[1][0]);\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[2][0]);\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[3][0]);\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[4][0]);\n    tv[j][i][1] = tv[j][i][1] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[0][2];\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[1][0]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[2][0]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[3][0]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[4][0]);\n    tv[j][i][2] = tv[j][i][2] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[0][3];\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[1][0]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[2][0]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][0]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][0]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][0] * tmp);\n    tmp = tmp1 * tmat[0][4];\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[1][0]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[2][0]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][0]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][0]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[1][2];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[2][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[3][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[4][1]);\n    tv[j][i][2] = tv[j][i][2] - (tv[j][i][1] * tmp);\n    tmp = tmp1 * tmat[1][3];\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[2][1]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][1]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][1]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][1] * tmp);\n    tmp = tmp1 * tmat[1][4];\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[2][1]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][1]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][1]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[2][3];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][2]);\n    tv[j][i][3] = tv[j][i][3] - (tv[j][i][2] * tmp);\n    tmp = tmp1 * tmat[2][4];\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][2]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][2]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[3][4];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][3]);\n    tv[j][i][4] = tv[j][i][4] - (tv[j][i][3] * tmp);\n    tv[j][i][4] = tv[j][i][4] / tmat[4][4];\n    tv[j][i][3] = tv[j][i][3] - (tmat[4][3] * tv[j][i][4]);\n    tv[j][i][3] = tv[j][i][3] / tmat[3][3];\n    tv[j][i][2] = (tv[j][i][2] - (tmat[3][2] * tv[j][i][3])) - (tmat[4][2] * tv[j][i][4]);\n    tv[j][i][2] = tv[j][i][2] / tmat[2][2];\n    tv[j][i][1] = ((tv[j][i][1] - (tmat[2][1] * tv[j][i][2])) - (tmat[3][1] * tv[j][i][3])) - (tmat[4][1] * tv[j][i][4]);\n    tv[j][i][1] = tv[j][i][1] / tmat[1][1];\n    tv[j][i][0] = (((tv[j][i][0] - (tmat[1][0] * tv[j][i][1])) - (tmat[2][0] * tv[j][i][2])) - (tmat[3][0] * tv[j][i][3])) - (tmat[4][0] * tv[j][i][4]);\n    tv[j][i][0] = tv[j][i][0] / tmat[0][0];\n    v[k][j][i][0] = v[k][j][i][0] - tv[j][i][0];\n    v[k][j][i][1] = v[k][j][i][1] - tv[j][i][1];\n    v[k][j][i][2] = v[k][j][i][2] - tv[j][i][2];\n    v[k][j][i][3] = v[k][j][i][3] - tv[j][i][3];\n    v[k][j][i][4] = v[k][j][i][4] - tv[j][i][4];\n  }\n\n  if (j != (jend - 1))\n    flag2[j + 1] = 0;\n\n  if (j != jst)\n    flag2[j] = 1;\n\n}\n\n", "pragma": "\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/4"}
{"code": "for (j = 0; j < length; j++)\n  a[j] += b[j] + (scalar * c[j]);\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Nstream/nstream/1"}
{"code": "for (i = 1; i < (nx - 1); i++)\n  for (j = 1; j < (ny - 1); j++)\n{\n  int nn = ((((((currWorld[i + 1][j] + currWorld[i - 1][j]) + currWorld[i][j + 1]) + currWorld[i][j - 1]) + currWorld[i + 1][j + 1]) + currWorld[i - 1][j - 1]) + currWorld[i - 1][j + 1]) + currWorld[i + 1][j - 1];\n  nextWorld[i][j] = (currWorld[i][j]) ? ((nn == 2) || (nn == 3)) : (nn == 3);\n  total += nextWorld[i][j];\n  int thread_count = omp_get_num_threads();\n}\n\n\n", "pragma": "omp parallel for num_threads(numthreads) schedule(static) shared(nextWorld) firstprivate(nx,ny,currWorld,i ,j) reduction (+: total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/meaydira/GameofLifeParallel/life/0"}
{"code": "for (int i = 0; i < this->fields.size(); ++i)\n{\n  int x = i % this->width;\n  int y = floor(((double) i) / ((double) this->height));\n  int sum = 0;\n  for (int row = -horizon; row <= horizon; row++)\n    for (int col = -horizon; col <= horizon; col++)\n  {\n    if ((row == 0) && (col == 0))\n      continue;\n\n    int neiX = x + row;\n    int neiY = y + col;\n    if (neiX < 0)\n      neiX = width - 1;\n    else\n      if (neiX >= width)\n      neiX = 0;\n\n\n    if (neiY < 0)\n      neiY = height - 1;\n    else\n      if (neiY >= height)\n      neiY = 0;\n\n\n    if (fields[(neiX * width) + neiY].prev)\n      sum++;\n\n  }\n\n\n  Classic(i, sum);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Arogancki/OpenMP/4/1/console/GameOfLife/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src = v;\n  uint32_t dest;\n  degree = graph->vertices->out_degree[src];\n  edge_idx = graph->vertices->edges_idx[src];\n  for (j = edge_idx; j < (edge_idx + degree); j++)\n  {\n    dest = EXTRACT_VALUE(graph->sorted_edges_array->edges_array_dest[j]);\n    if (atomicMin(&stats->components[dest], stats->components[src]))\n    {\n      setBitAtomic(bitmapNext, dest);\n    }\n\n    if (atomicMin(&stats->components[src], stats->components[dest]))\n    {\n      setBitAtomic(bitmapNext, src);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,edge_idx) schedule(dynamic, 512)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/4"}
{"code": "for (i = 0; i <= max_q; i++)\n{\n  for (j = 0; j <= max_d; j++)\n  {\n    if (array[i][j] > max)\n    {\n      max = array[i][j];\n      max_array_num = 0;\n      if (max_array != 0)\n      {\n        free(max_array);\n        max_array = 0;\n      }\n\n      COORD *tmp_array;\n      tmp_array = realloc(max_array, (sizeof(COORD)) * (++max_array_num));\n      max_array = tmp_array;\n      max_array[max_array_num - 1].col = j;\n      max_array[max_array_num - 1].row = i;\n      max_array[max_array_num - 1].num = array[i][j];\n    }\n    else\n      if ((array[i][j] == max) && (max != 0))\n    {\n      COORD *tmp_array = realloc(max_array, (sizeof(COORD)) * (++max_array_num));\n      max_array = tmp_array;\n      max_array[max_array_num - 1].col = j;\n      max_array[max_array_num - 1].row = i;\n      max_array[max_array_num - 1].num = array[i][j];\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkasfikis/Smith-Waterman-/myProj_OMP_FG/7"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  if (isPattern == 1)\n    fscanf(file, \"%ld %ld\", &Si, &Ti);\n  else\n    fscanf(file, \"%ld %ld %lf\", &Si, &Ti, &weight);\n\n  Si--;\n  Ti--;\n  assert((Si >= 0) && (Si < NV));\n  assert((Ti >= 0) && (Ti < NV));\n  if (Si == Ti)\n  {\n    edgeListTmp[newNNZ].head = Si;\n    edgeListTmp[newNNZ].tail = Si;\n    edgeListTmp[newNNZ].weight = weight;\n    edgeListPtr[Si + 1]++;\n    newNNZ++;\n  }\n  else\n  {\n    edgeListTmp[newNNZ].head = Si;\n    edgeListTmp[newNNZ].tail = Ti;\n    edgeListTmp[newNNZ].weight = weight;\n    edgeListPtr[Ti + 1]++;\n    edgeListPtr[Si + 1]++;\n    newNNZ++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadMatrixMarket/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  data[(i * n) + 2] -= media[2];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/6"}
{"code": "for (j = 0; j < (*numFea); j++)\n  images[i][j] = atof(strtok(0, \" ,\\t\\n\"));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/siddhantkulkarni/parallelmachinelearning/Code/Kmeans/para/2"}
{"code": "for (int i = 0; i < MAX_DEPTH; i++)\n{\n  int local_size = leaf_nodes[i];\n  int global_size;\n  MPI_Allreduce(&local_size, &global_size, 1, MPI_INT, MPI_SUM, comm);\n  if (!myrank)\n    (cout << global_size) << ' ';\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashb/tbslas/src/applications/src/kernel_tst/4"}
{"code": "for (i = 0; i < nlocaledges; ++i)\n{\n  int64_t c = column[i];\n  column_swizzled[i] = ((VERTEX_OWNER(c) << lg_local_queue_size) * ulong_bits) | VERTEX_LOCAL(c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_replicated/5"}
{"code": "for (size_t i = 0; i < AllBoids.size(); i++)\n{\n  AllBoids[i]->Act(Params.DeltaTime);\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/5"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  grid[i][j] = inf;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dcarvalho21/Algoritmo-de-Lee---Paralelo/rotpar/0"}
{"code": "for (i = thread_id; i < num_steps; i = i + nthreads_at_thread_stack)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/V6429/openmp_present/3.B.paralell/0"}
{"code": "for (j = 0; j < kxps; j++)\n{\n  dkx = dnx * ((float) (j + joff));\n  dkx2 = dkx * dkx;\n  jk3 = (3 * nyv) * j;\n  if ((j + joff) > 0)\n  {\n    for (k = 1; k < nyh; k++)\n    {\n      k1 = ny - k;\n      dky = dny * ((float) k);\n      at1 = 1.0 / ((dky * dky) + dkx2);\n      zt1 = at1 * ((dkx * cu[(3 * k) + jk3]) + (dky * cu[(1 + (3 * k)) + jk3]));\n      cu[(3 * k) + jk3] -= dkx * zt1;\n      cu[(1 + (3 * k)) + jk3] -= dky * zt1;\n      zt1 = at1 * ((dkx * cu[(3 * k1) + jk3]) - (dky * cu[(1 + (3 * k1)) + jk3]));\n      cu[(3 * k1) + jk3] -= dkx * zt1;\n      cu[(1 + (3 * k1)) + jk3] += dky * zt1;\n    }\n\n    k1 = nyh;\n    cu[jk3] = zero;\n    cu[(3 * k1) + jk3] = zero;\n    cu[(1 + (3 * k1)) + jk3] = zero;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,k1,jk3,dkx,dkx2,dky,at1,zt1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/12"}
{"code": "for (i = 0; i < buckets_count; i++)\n{\n  memcpy(&array[j], results[i].values, results[i].count * (sizeof(double)));\n  j += results[i].count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc2/bsort/6"}
{"code": "for (int i = 1; i < numtasks; i++)\n{\n  int source = i;\n  MPI_Recv(&buffer[offset], chunksize * i_y_max, (MPI_Datatype) 0x4c000101, source, 1, 1, &status);\n  offset += chunksize * i_y_max;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danigfavero/concorrente-e-paralela/EP2/MPI+OMP/mandelbrot_openmpi+omp/2"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  memset(vforbidden[i], 0, (maxd + 1) * (sizeof(bool)));\n  temp_colors[i] = colors[i];\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Edge-Coloring/parallel-omp/4"}
{"code": "for (int count_column = 0; count_column < columns; count_column++)\n{\n  ptrmatrixOMP[count_row][count_column] = ptrarray[(count_row * columns) + count_column];\n}\n\n", "pragma": "                #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ALKovalev/OpenMP/OMPmultMatrixAndVector/OMPmultMatrixAndVector/OMPmultMatrixAndVector/7"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (k = 0; k < 1000; k++)\n  {\n    for (j = 0; j < 1000; j++)\n    {\n      C[i][j] = C[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pprudhvi/ME766-HPSC/2/code/OMPCFMM/0"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  double d = 0.0;\n  j = clusterid[i];\n  for (k = 0; k < nelements; k++)\n  {\n    if ((i == k) || (clusterid[k] != j))\n      continue;\n\n    d += (i < k) ? (distance[k][i]) : (distance[i][k]);\n    if (d > errors[j])\n      break;\n\n  }\n\n  if (d < errors[j])\n  {\n    errors[j] = d;\n    centroids[j] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/60"}
{"code": "for (int i = 0; i < n; i++)\n{\n  c3[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v3/v3_omp/7"}
{"code": "for (i = 0; i < nsub; i++)\n  printf(\"  %8d  %14f\\n\", i + 1, h[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/14"}
{"code": "for (i = 0; i < n; i++)\n{\n  sd_asum += (a[i] - mean_a) * (a[i] - mean_a);\n  sd_bsum += (b[i] - mean_b) * (b[i] - mean_b);\n  sum_r += (a[i] - mean_a) * (b[i] - mean_b);\n}\n\n", "pragma": "omp parallel for reduction(+:sd_asum) reduction(+:sd_bsum) reduction(+:sum_r) num_threads(8)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/knal1992/Pearson-Correlation-OpenMP/OMP/1"}
{"code": "for (i = num_steps; i > (-1); i++)\n{\n  k_3++;\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/inputOmpfor/3"}
{"code": "for (x = 0; x < (*dimX); x++)\n{\n  for (y = 0; y < (*dimY); y++)\n  {\n    for (z = 0; z < (*dimZ); z++)\n    {\n      array3D[(((x * (*dimY)) * (*dimZ)) + (y * (*dimZ))) + z] = array3D[(((x * (*dimY)) * (*dimZ)) + (y * (*dimZ))) + z] + ((int) (5 * randn(seed, 0)));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/11"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/0"}
{"code": "for (i = 90; i < 100; i++)\n  is = is + i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/lastprivate0/1"}
{"code": "for (ie = 0; ie < nelt; ie++)\n{\n  laplacian(pdiffp[ie], pdiff[ie], size_e[ie]);\n}\n\n", "pragma": "omp parallel for default(shared) private(ie)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/diffuse/5"}
{"code": "for (i = 0; i < rows; i++)\n  array[i] = &data[cols * i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/3"}
{"code": "for (int i = (5 * n) / 16; i < ((6 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/13"}
{"code": "for (u = ((2U * 0x7fffffff) + 1) - 6; u < ((2U * 0x7fffffff) + 1); u++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/11"}
{"code": "for (i = 0; i < (4 * TableSize); i++)\n{\n  temp = (6364136223846793005ULL * temp) + 1;\n  Table[temp >> (64 - ((int) logTableSize))] ^= temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/6"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < n; j++)\n{\n  if (C[i][j] != D[i][j])\n  {\n    printf(\"Failed\");\n    exit(-1);\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aman-1701/Tiled_Matrix_Multiplication_OpenMP/TiledMatrixMultiplication/8"}
{"code": "for (int i = 0; i < rank; i++)\n  printf(\"%.2f \", x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/Jacobi/jacobipar/7"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp6rliqvgp.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RWTH-HPC/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int ii = 0; ii < (N + 2); ii++)\n  {\n    fill_array3d(buffer, N, ii, N + 1, kk, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/smoother7p/3"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    fuzzyPadded[i + d][j + d] = fuzzy[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/z4/dosharpen/4"}
{"code": "for (i = 0; i < k; i++)\n{\n  s[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bbw7561135/NumCode/003/0"}
{"code": "for (int i = 50; i < 74; ++i)\n{\n  w[i] *= (B2 * 146.0) * invCORRP;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfGenerateGrid/25"}
{"code": "for (int u = 0; u < ((n * m) * o); u++)\n{\n  delta_T += (R[u] - T[u]) * (R[u] - T[u]);\n  if (R[u] > max)\n    max = R[u];\n\n}\n\n", "pragma": "omp parallel for reduction(+:delta_T)reduction(max:max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/heatsink_openmp/1"}
{"code": "for (int i = 0; i < size; i++)\n{\n  free_ctx(dequeue(), n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/21"}
{"code": "for (i = 0; i < num_bfs_roots; ++i)\n  secs_per_edge[i] = bfs_times[i] / edge_counts[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/main/6"}
{"code": "for (j = 1; j <= n; j++)\n{\n  for (i = 1; i <= m; i++)\n  {\n    if (grid[i + (j * (m + 2))] == 0)\n    {\n      if (s[(i - 1) + ((j - 1) * m)] == 3)\n      {\n        grid[i + (j * (m + 2))] = 1;\n      }\n\n    }\n    else\n      if (grid[i + (j * (m + 2))] == 1)\n    {\n      if ((s[(i - 1) + ((j - 1) * m)] < 2) || (3 < s[(i - 1) + ((j - 1) * m)]))\n      {\n        grid[i + (j * (m + 2))] = 0;\n      }\n\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/plloaao/lifegame_and_openmp/lifegame_omp/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 3 * 1; j <= ((grid_points[1] - 3) - 1); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/123"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  resM[i + j] = aM[i + j] * number;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziminyuri/AMP-OpenMP/AMP/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  localans += f(x0 + (i * dx));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/integral/0"}
{"code": "for (int i1 = 0; i1 < n; i1++)\n  for (int j1 = 0; j1 < n; j1++)\n{\n  if (resurse[i][j] == (1 - resurse[i1][j1]))\n  {\n    cost = preturi[i1][j1] + distanta(i, j, i1, j1);\n    if (cost < c.cost)\n      c.cost = cost;\n\n  }\n  else\n  {\n    costRes = preturi[i1][j1] + distanta(i, j, i1, j1);\n    if (costRes < c.costRes)\n      c.costRes = costRes;\n\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PetcuAlexandru/OpenMP_parallelization/parallel/0"}
{"code": "for (size_t aid = 0; aid < m_atoms.size(); ++aid)\n{\n  m_atoms[aid]->calculate_position(m_dt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-zero/CppMD/sources/solvers/md_solver/3"}
{"code": "for (i = 0; i < 5; i++)\n  a[i] = i * 1;\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/g1stavo/parallel-distributed/lab-2/master/0"}
{"code": "for (int i = 0; i < local_numOfNumbers; i++)\n{\n  privateHist[local_arr[i]]++;\n}\n\n", "pragma": "omp parallel for shared(local_arr) reduction(+: privateHist)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kerenrachev/CUDA_MPI_OpenMP_Histogram/histogram/0"}
{"code": "for (z = 0; z < (2 * L); z++)\n{\n  for (y = 0; y < (2 * L); y++)\n  {\n    for (x = 0; x < L; x++)\n    {\n      ixf = (2 * x) + STRF(color, y, z);\n      index = IX(ixf, y, z);\n      rbi = RB(x, y, z);\n      t_id = omp_get_thread_num();\n      res = myrand(Rng, Uni, t_id);\n      if (res <= frac)\n      {\n        oc[index] = 1;\n        macr[rbi] = 1.0f;\n        mafe[rbi] = 0.0f;\n      }\n      else\n      {\n        oc[index] = 2;\n        mafe[rbi] = 1.0f;\n        macr[rbi] = 0.0f;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(3) default(none) shared(oc, macr, mafe, L, Rng, Uni, frac, color)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/facuMH/HeisenbergModel/OpenMP/funs/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = i * 40;\n  b[i] = i - 1;\n  c[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB070-simd1-orig-no/0"}
{"code": "for (int i = 0; i < point_dim; ++i)\n{\n  distance += abs(p1[i] - p2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/treyvian/Kmeans-with-OpenMP/src/kmedoids/kmedoids/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  score2 = minmax(T[i], -1, niv - 1);\n  if (score2 > score)\n    score = score2;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/27"}
{"code": "for (size_t t = 1; t <= tmax; ++t)\n{\n  const float ratio = ((double) (t - 1)) / (tmax - 1);\n  switch (rcool)\n  {\n    case EXPONENTIAL:\n      radius = radius0 * powf(radiusN / radius0, ratio);\n      break;\n\n    case LINEAR:\n\n    default:\n      radius = radiusN + ((radius0 - radiusN) * (1. - ratio));\n      break;\n\n  }\n\n  trainOneEpoch(data, radius, stdCoef, bmus, dsts);\n  if (m_verbose > 1)\n  {\n    (((cout << \"  epoch \") << t) << \" / \") << tmax;\n    (cout << \", r = \") << radius;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/bsom/4"}
{"code": "for (i = 512; i < 617; i++)\n{\n  glColor3f(0.5625f, 0.92f, 0.5625f);\n  glVertex3f(Shuffled_galaxysParticles[i].position_x, Shuffled_galaxysParticles[i].position_y, Shuffled_galaxysParticles[i].position_z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnouarWalziki/Galaxeirb/1024_particles_OpenMP/src/main/6"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"%d:i%d\\t\", id, i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filipecosta90/Parallel-Computing-Paradigms/aula1/exec2.4/0"}
{"code": "for (i = 0; i < 8; i++)\n{\n  printf(\"loop_0[%d]: %lu, loop_1[%d]: %lu, loop_2[%d]: %lu\\n\", i, loop_0[i], i, loop_1[i], i, loop_2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp-hook/tests/vectoradd/parallel-region-with-multiple-loops/3"}
{"code": "for (i = 0; i < matrix.count; i++)\n{\n  result.nnz.f[i] = matrix.nnz.f[i];\n}\n\n", "pragma": "omp parallel for shared(result,matrix) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/7"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    temp2 = (((((4 * unew[i][j]) - unew[i - 1][j]) - unew[i + 1][j]) - unew[i][j - 1]) - unew[i][j + 1]) - ((1.0 * h) * h);\n    res += temp2 * temp2;\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jzuhusky/HPC_Homework2/gs2D-omp/2"}
{"code": "for (k = ki1; k <= ki2; k++)\n{\n  phi2[i][k] = C2 * (u[i][jfin][k][4] - ((0.50 * ((pow2(u[i][jfin][k][1]) + pow2(u[i][jfin][k][2])) + pow2(u[i][jfin][k][3]))) / u[i][jfin][k][0]));\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin ,k ,jfin ,ki1 ,ki2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/58"}
{"code": "for (int k = 0; k < n; k++)\n{\n  int begin = (k + 1) + ((*threadid) * (((n - k) - 1) / thread_count));\n  int end = begin + (((n - k) - 1) / thread_count);\n  if (end > n)\n    end = n;\n\n  int preprocessnumber = ((n - k) - 1) % 4;\n  int beginrow = (k + 1) + preprocessnumber;\n  float head[4] = {A[k][k], A[k][k], A[k][k], A[k][k]};\n  t2 = _mm_loadu_ps(head);\n  for (int j = k + 1; j < ((k + 1) + preprocessnumber); j++)\n  {\n    A[k][j] = A[k][j] / A[k][k];\n  }\n\n  for (int j = beginrow; j < end; j += 4)\n  {\n    t1 = _mm_loadu_ps(A[k] + j);\n    t1 = _mm_div_ps(t1, t2);\n    _mm_store_ss(A[k] + j, t1);\n  }\n\n  t1 = _mm_setzero_ps();\n  t2 = _mm_setzero_ps();\n  for (int i = k + 1; i < n; i++)\n  {\n    for (int j = k + 1; j < ((k + 1) + preprocessnumber); j++)\n    {\n      A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n    }\n\n    A[i][k] = 0;\n  }\n\n  for (int i = k + 1; i < n; i++)\n  {\n    float head1[4] = {A[i][k], A[i][k], A[i][k], A[i][k]};\n    t3 = _mm_loadu_ps(head1);\n    for (int j = beginrow; j < end; j += 4)\n    {\n      t1 = _mm_loadu_ps(A[k] + j);\n      t2 = _mm_loadu_ps(A[i] + j);\n      t1 = _mm_mul_ps(t1, t3);\n      t2 = _mm_sub_ps(t2, t1);\n      _mm_store_ss(A[i] + j, t2);\n    }\n\n    A[i][k] = 0;\n  }\n\n  sem_post(&sem_parent);\n  pthread_barrier_wait(&childbarrier_col);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/12"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/46"}
{"code": "for (long i = 0; i < n; i++)\n{\n  a[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/agdhruv/omp-parallel/sums/parallel/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    res[(i * N) + j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Erfanafshar/multicore-openMP-HW/4/code/q1/1"}
{"code": "for (i = 1; i <= proc_rows; i++)\n{\n  for (j = 1; j <= proc_columns; j++)\n    printf(\"%d \", matrix[((proc_columns + 2) * i) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yorgosk/game-of-life/MPI_OpenMp/functions_mpi_openmp/8"}
{"code": "for (i = 0; i < size; i++)\n{\n  a[i] = (double *) malloc(size * (sizeof(double)));\n  b[i] = (double *) malloc(size * (sizeof(double)));\n  c[i] = (double *) malloc(size * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/michal3141/openmp/matmul/3"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = b[i] + c[i];\n}\n\n", "pragma": "  #pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/distribute_parallel_for_codegen/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/0"}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_key[index])))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/4"}
{"code": "for (j = 0; j < 512; j++)\n{\n  B[i][j] += A[i][k] * B[k][j];\n  B[i][j] += A[i][k + 1] * B[k + 1][j];\n  if ((i % 2) == 1)\n    B[i][j] = A[i][512 - 1] * B[512 - 1][j];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/pa2/PP1/PA2-Prob1-unr/0"}
{"code": "for (i = 0; i <= n; i++)\n{\n  if (ele == arr[s[i]])\n  {\n    index = s[i];\n    printf(\"Element found at position %d\\n\", index + 1);\n    flag = 1;\n    break;\n  }\n\n  if (ele < arr[s[i]])\n  {\n    right = s[i];\n    if (i != 0)\n    {\n      left = 1 + s[i - 1];\n    }\n\n    n = (right - left) + 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ritika-07/PDC/OpenMP/search/3"}
{"code": "for (i = 1; i <= LOOPCOUNT; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1) private(i) reduction(+ : sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_parallel_reduction/0"}
{"code": "for (int i = 0; i < lines.size(); ++i)\n{\n  remove_punc(lines[i]);\n  words = split(lines[i], ' ');\n  for (int j = 0; j < words.size(); j++)\n  {\n    current_word = words[j];\n    to_lower(current_word);\n    increase_word_count(occurrences, current_word);\n  }\n\n}\n\n", "pragma": "        #pragma omp for schedule (static, 2) private(current_word, words)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarkovaDA/OpenMPHomeTask2/OpenMPTest/parallel_for/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < 800; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (L * L))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((0.75 - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/30"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  C[i] = (double *) malloc(2000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixin/3"}
{"code": "for (i = 0; i < (ncolumns / 2); i++)\n{\n  j = index[i];\n  index[i] = index[(ncolumns - 1) - i];\n  index[(ncolumns - 1) - i] = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/22"}
{"code": "for (int i = 0; i < colNumX; i++)\n{\n  XmatVecTemp = Xmat.col(i);\n  Sigma_iX1.col(i) = getPCG1ofSigmaAndVector_LOCO(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/16"}
{"code": "for (i = 0; i < n; i++)\n{\n  count = 0;\n  for (j = 0; j < n; j++)\n  {\n    if (a[j] < a[i])\n    {\n      count++;\n    }\n    else\n      if ((a[j] == a[i]) && (j < i))\n    {\n      count++;\n    }\n\n\n  }\n\n  temp[count] = a[i];\n}\n\n", "pragma": "omp parallel for num_threads(threads) default(none) private(count,i,j) shared(a,temp,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SotirisSotiriou/high-performance-computing/OpenMP/countsort/countsort_parallel_rand/0"}
{"code": "for (long K = coloradj1; K < coloradj2; K++)\n{\n  distExecuteLouvainIteration(colorIndex[K], dg, currComm, targetComm, vDegree, localCinfo, localCupdate, remoteComm, remoteCinfo, remoteCupdate, constantForSecondTerm, clusterWeight, me);\n}\n\n", "pragma": "#pragma omp parallel for shared(clusterWeight, localCupdate, currComm, targetComm, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/3"}
{"code": "for (size_t i = 3 * round(size / 4); i < size; i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  sum = sum + max_;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/5/5/Source/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  first = (i * 800) / size;\n  end = ((i + 1) * 800) / size;\n  MPI_Bcast(&neuron[0][first], 2 * (end - first), (MPI_Datatype) 0x4c00080b, i, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_mpi_omp/3"}
{"code": "for (int i = 0; i < p; i++)\n{\n  val *= 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/5"}
{"code": "for (i = 0; i < 100; i++)\n{\n  gen_task(i);\n}\n\n", "pragma": "omp parallel for private(i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB100-task-reference-orig-no/0"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  for (size_t j = 0; j < i; j++)\n  {\n    matrix[i][j] = -matrix[i][j];\n    matrix[j][i] = -matrix[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/8"}
{"code": "for (i = 0; i < M; i = i + 1)\n{\n  for (j = 0; j < M; j++)\n  {\n    for (l = 0; l < (M * 2); l = l + 4)\n    {\n      Bcol[l] = B[(l * M) + j];\n      Bcol[l + 1] = B[((l + 1) * M) + j];\n      Bcol[l + 2] = B[((l + 2) * M) + j];\n      Bcol[l + 3] = B[((l + 3) * M) + j];\n    }\n\n    r = 0.0;\n    indice_ligne = i * M;\n    for (k = 0; k < M; k = k + 2)\n    {\n      av4 = _mm_load_pd((A + indice_ligne) + k);\n      bv4 = _mm_load_pd(Bcol + k);\n      dot = _mm_dp_pd(av4, bv4, 0xFF);\n      _mm_store_pd(R4, dot);\n      r = r + R4[0];\n    }\n\n    C[indice_ligne + j] = (alpha * r) + (beta * C[indice_ligne + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/6"}
{"code": "for (i = 0; i < 4; i++)\n{\n  printf(\"Iteration: %d, Thread %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ehsan1222/parallel-processing-cheats/open-mp-examples/example9/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  tmpi = DSECND();\n  DGEMM(&transa, &transb, &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc);\n  tmpi = DSECND() - tmpi;\n  if ((i == 0) || (tmpi < t1))\n    t1 = tmpi;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/samadio/HPC_openMP_MPI_C/old_HPC/ex5/nodeperf/nodeperf/11"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_parallel_master_taskloop_simd); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/lib/Sema/SemaOpenMP/1"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  B[(j * N) + i] = 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/entrega-3/mpi-hibrido/4"}
{"code": "for (i = 0; i < dataSet->n; i++)\n{\n  for (j = 0; j < dataSet->m; j++)\n  {\n    dataSet->A[(i * dataSet->m) + j] = rand() % 100;\n    dataSet->B[(i * dataSet->m) + j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/ParaLab/OpenMP/matrix-addition/mat_add/3"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  uint32_t j;\n  uint32_t src = v;\n  uint32_t dest;\n  Nodes = graph->vertices[v].outNodes;\n  degree = graph->vertices[v].out_degree;\n  for (j = 0; j < degree; j++)\n  {\n    dest = Nodes->edges_array_dest[j];\n    uint32_t comp_src = stats->components[src];\n    uint32_t comp_dest = stats->components[dest];\n    if (comp_src == comp_dest)\n      continue;\n\n    uint32_t comp_high = (comp_src > comp_dest) ? (comp_src) : (comp_dest);\n    uint32_t comp_low = comp_src + (comp_dest - comp_high);\n    if (comp_high == stats->components[comp_high])\n    {\n      change = 1;\n      stats->components[comp_high] = comp_low;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,degree,Nodes) schedule(dynamic, 512)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/12"}
{"code": "for (int y = 0; y < imgHeight; ++y)\n{\n  for (int x = 0; x < imgWidth; ++x)\n  {\n    outArray->Area[(y * imgWidth) + x] = Pixel(image[y][x].red, image[y][x].green, image[y][x].blue);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MNie/ComparisonOfOpenCLOpenMPMPI/src/OpenMP/GeneticAlgorithm/GeneticAlgorithm/11"}
{"code": "for (j = 0; j < cache->assoc; j++)\n{\n  if (!getPLRU(&cache->cacheLines[i][j]))\n  {\n    victim = j;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/29"}
{"code": "for (i = 2; i < (Low_h / 2); i++)\n{\n  for (j = (Low_w / 4) * 3; j < Low_w; j++)\n  {\n    bicubic_Y_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Y[(i * Low_w) + j])) + (bicubic2[1][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Y_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Y[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Y[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Y[(i * Low_w) + j])) + (bicubic2[0][3] * input_Y[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cb_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cb[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cb[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cb[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cb[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[(((2 * i) - 1) * Low_w) + j] = floor(((((bicubic2[1][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[1][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[1][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[1][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n    bicubic_Cr_temp[((2 * i) * Low_w) + j] = floor(((((bicubic2[0][0] * input_Cr[((i - 2) * Low_w) + j]) + (bicubic2[0][1] * input_Cr[((i - 1) * Low_w) + j])) + (bicubic2[0][2] * input_Cr[(i * Low_w) + j])) + (bicubic2[0][3] * input_Cr[((i + 1) * Low_w) + j])) + 0.5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    aDual[i][j] = -1;\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trannguyendev/transportation-problem/ss/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  fac1 = 1. / lhs[n + 2][i][j][k];\n  lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n  lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n  }\n\n  lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n  lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n  }\n\n  fac2 = 1. / lhs[n + 2][i][j][k1];\n  for (m = 0; m <= 2; m += 1)\n  {\n    rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,j,m) firstprivate (k,n,k1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/209"}
{"code": "for (int i = 0; i < 4096; i++)\n{\n  globalized[i % 256] += i;\n}\n\n", "pragma": "omp parallel for reduction(+:globalized)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/reduction_shared_array/reduction_shared_array/1"}
{"code": "for (k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    field[FTNREF2D(x_min - j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = left_rcv_buffer[FTNREF1D(index, 1)];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/pack_kernel_c/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  v2[i] = 0;\n  for (j = i; j < n; j++)\n  {\n    v2[i] = v2[i] + (m[i][j] * v1[j]);\n  }\n\n}\n\n", "pragma": "omp for private(j) schedule(runtime)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/corderop/PracticasAC/bp3/ejer7/pmtv-OpenMP/0"}
{"code": "for (i = 0; i < num_buckets; ++i)\n{\n  free(degreesHot[i]);\n  free(verticesHot[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/27"}
{"code": "for (i = 1; i < (num_buckets - 1); ++i)\n{\n  thresholds[i] = thresholds[i - 1] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/19"}
{"code": "for (int i = 0; i < M.nrows; i++)\n{\n  sum = 0;\n  for (int j = M.indi[i] - sumnnzm; j < (M.indi[i + 1] - sumnnzm); j++)\n  {\n    sum += M.val[j] * x.val[M.indj[j]];\n  }\n\n  y.val[i] = sum;\n}\n\n", "pragma": "\t#pragma omp parallel for private(i) lastprivate(sum)\t", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/2"}
{"code": "for (int y = 0; y < 15; ++y)\n{\n  for (int x = 0; x < 10; x++)\n  {\n    tick(x, y);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wynnliam/openmp-learning/collapse/0"}
{"code": "for (j = 0; j < nxhs; j += 2)\n{\n  v_at1 = _mm512_mask_loadunpacklo_ps(v_zero, _mm512_int2mask(15), (float *) (&ffc[j]));\n  v_at1 = _mm512_mask_loadunpackhi_ps(v_at1, _mm512_int2mask(15), (float *) (&ffc[j + 8]));\n  v_at1 = _mm512_permute4f128_ps(v_at1, 0);\n  v_at4 = (int) _mm512_mask_shuffle_epi32((int) v_at1, _mm512_int2mask(13260), (int) v_at1, 78);\n  v_at1 = (int) _mm512_mask_shuffle_epi32((int) v_at4, _mm512_int2mask(43690), (int) v_at4, 177);\n  v_at1 = _mm512_mul_ps(v_ci2, v_at1);\n  v_it = _mm512_add_epi32(_mm512_set1_epi32(j), v_j);\n  v_dkx = _mm512_cvtfxpnt_round_adjustepi32_ps(v_it, _MM_FROUND_TO_ZERO, _MM_EXPADJ_NONE);\n  v_dkx = _mm512_mul_ps(v_dnx, v_dkx);\n  v_dk1 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(3084), v_dkx);\n  v_dk2 = _mm512_mask_mov_ps(v_zero, _mm512_int2mask(12336), v_dkx);\n  v_at2 = _mm512_mul_ps(v_at1, v_dk1);\n  v_at3 = _mm512_mul_ps(v_at1, v_dk2);\n  v_at4 = (int) _mm512_mask_shuffle_epi32((int) v_at4, _mm512_int2mask(21845), (int) v_at4, 177);\n  v_at1 = _mm512_mul_ps(v_at1, v_at4);\n  v_zt3 = _mm512_load_ps((float *) (&cu[4 * j]));\n  v_zt3 = _mm512_mask_sub_ps(v_zt3, _mm512_int2mask(43690), v_zero, v_zt3);\n  v_zt3 = (int) _mm512_shuffle_epi32((int) v_zt3, 177);\n  v_zt1 = _mm512_mul_ps(v_at2, v_zt3);\n  v_zt2 = _mm512_mul_ps(v_at3, v_zt3);\n  v_zt1 = (int) _mm512_permutevar_epi32(v_n, (int) v_zt1);\n  v_zt2 = (int) _mm512_permutevar_epi32(v_m, (int) v_zt2);\n  v_zt1 = _mm512_sub_ps(v_zt1, v_zt2);\n  if (j == 0)\n  {\n    v_zt1 = _mm512_mask_mov_ps(v_zt1, _mm512_int2mask(255), v_zero);\n    v_zt3 = _mm512_mask_mov_ps(v_zt3, _mm512_int2mask(255), v_zero);\n  }\n\n  _mm512_store_ps((float *) (&bxyz[4 * j]), v_zt1);\n  v_zt4 = _mm512_mul_ps(v_at1, _mm512_mask_mul_ps(v_zero, _mm512_int2mask(16191), v_zt3, v_zt3));\n  v_wp = _mm512_add_pd(v_wp, _mm512_cvtpslo_pd(v_zt4));\n  v_d = _mm512_cvtpslo_pd(_mm512_permute4f128_ps(v_zt4, 78));\n  v_wp = _mm512_add_pd(v_wp, v_d);\n  _mm512_store_ps((float *) (&bxyz[4 * (j + k1)]), v_zero);\n  _mm512_store_ps((float *) (&bxyz[4 * (j + l1)]), v_zero);\n  _mm512_store_ps((float *) (&bxyz[4 * ((j + k1) + l1)]), v_zero);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/49"}
{"code": "for (int j = 0; j < n; j++)\n{\n  num = num + (temp[j] * p[j]);\n}\n\n", "pragma": "omp parallel for num_threads(t) reduction(+ : num)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/Solving-System-of-linear-equations-in-parallel-and-serial/random/6"}
{"code": "for (i = 0; i < n; i++)\n  if (((posi < (n / 2)) && (val[posi] <= val[posj])) || (posj >= n))\n  vo[i] = val[posi++];\nelse\n  if (posj < n)\n  vo[i] = val[posj++];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelQuickMergeSort/src/OpenMP/P1.1_CPM_ElAzizi_Dauden/3"}
{"code": "for (int j = 0; j < 256; j++)\n{\n  if ((k <= need_k) && ((k + count_r[j]) > need_k))\n  {\n    break;\n  }\n  else\n  {\n    k += count_r[j];\n    min_r = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/9"}
{"code": "for (i = 1000 - 5; i <= 1000; i++)\n{\n  printf(\"[%d,%d]: %5.2f  \", i, i, t[i][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kuanweih/XSEDE-HPC-Workshop/Exercises-my/OpenMP/Examples/laplace_parallel_region/6"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->vertices[v] = v;\n  stats->degrees[v] = graph->grid->out_degree[v];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/1"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  q = i + 5;\n  p += i + 2;\n  a[i] += ((p * b[i]) + (c[i] * q)) + l;\n  r = i;\n}\n\n", "pragma": "omp for simd private(q) firstprivate(p) lastprivate(r) linear(l:2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-for-simd/test/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < K; j++)\n  {\n    pos[(i * K) + j] += vel[(i * K) + j] * info->dT;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanJbk/Parallel-Binary-Classification/main/7"}
{"code": "for (int vertex_other = 0; vertex_other < VERTEX_COUNT; vertex_other++)\n{\n  int edge_idx = EDGE_INDICES[(vertex * VERTEX_COUNT) + vertex_other];\n  if (edge_idx >= 0)\n  {\n    if ((edges[edge_idx] == 1) && (visited[vertex_other] == 0))\n    {\n      is_connected_recursive(vertex_other, edges, visited);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/langer-jaros/parallelization/src/multiprocessing/18"}
{"code": "for (i = 0; i < count; i++)\n{\n  if (!memcmp(binary, crypted[i], saved_salt.hash_size))\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/8"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = jj; j < (((jj + p) > row) ? (row) : (jj + p)); j++)\n  {\n    int temp = 0;\n    for (int k = kk; k < (((kk + p) > col) ? (col) : (kk + p)); k++)\n    {\n      temp += a[i][k] * b[k][j];\n    }\n\n    result[i][j] += temp;\n  }\n\n}\n\n", "pragma": "                #pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/charlsonso/openmp_matrix_multip/runner/2"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 0; j <= (n - 1); j += 1)\n  {\n    fprintf(stderr, \"%0.2lf \", C[i][j]);\n    if ((i % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/utilities/template-for-new-benchmark/4"}
{"code": "for (l = 1; l <= m; l += 2)\n{\n  fftz2(is, l, m, n, fftblock, fftblockpad, u, x, y);\n  if (l == m)\n  {\n    break;\n  }\n\n  int _imopVarPre270;\n  _imopVarPre270 = l + 1;\n  fftz2(is, _imopVarPre270, m, n, fftblock, fftblockpad, u, y, x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/24"}
{"code": "for (int i = 0; i < size; i++)\n{\n  int output = 1;\n  if (S[i] < 0)\n  {\n    output = -1;\n  }\n\n  fprintf(fp, \"%d\\n\", output);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/ParallelNewmanModularity/lib/CDUtils/11"}
{"code": "for (row = 0; row < MAXROW; row++)\n  for (col = 0; col < MAXCOL; col++)\n  map[row][col] = DEAD;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"Game of Life\" with OpenMP/2"}
{"code": "for (j = 0; j < nx; j++)\n{\n  q[j] += q[(j + (nxe * ny)) + (nxye * nz)];\n  q[(j + (nxe * ny)) + (nxye * nz)] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/43"}
{"code": "for (j_imopVarPre78 = 1; j_imopVarPre78 <= nrows; j_imopVarPre78++)\n{\n  nzrow = 0;\n  for (k_imopVarPre79 = jajp1; k_imopVarPre79 < rowstr[j_imopVarPre78 + 1]; k_imopVarPre79++)\n  {\n    i_imopVarPre76 = colidx[k_imopVarPre79];\n    x_imopVarPre75[i_imopVarPre76] = x_imopVarPre75[i_imopVarPre76] + a[k_imopVarPre79];\n    int _imopVarPre208;\n    _imopVarPre208 = mark[i_imopVarPre76] == 0;\n    if (_imopVarPre208)\n    {\n      _imopVarPre208 = x_imopVarPre75[i_imopVarPre76] != 0.0;\n    }\n\n    if (_imopVarPre208)\n    {\n      mark[i_imopVarPre76] = 1;\n      nzrow = nzrow + 1;\n      nzloc[nzrow] = i_imopVarPre76;\n    }\n\n  }\n\n  for (k_imopVarPre79 = 1; k_imopVarPre79 <= nzrow; k_imopVarPre79++)\n  {\n    i_imopVarPre76 = nzloc[k_imopVarPre79];\n    mark[i_imopVarPre76] = 0;\n    xi = x_imopVarPre75[i_imopVarPre76];\n    x_imopVarPre75[i_imopVarPre76] = 0.0;\n    if (xi != 0.0)\n    {\n      nza = nza + 1;\n      a[nza] = xi;\n      colidx[nza] = i_imopVarPre76;\n    }\n\n  }\n\n  jajp1 = rowstr[j_imopVarPre78 + 1];\n  rowstr[j_imopVarPre78 + 1] = nza + rowstr[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/27"}
{"code": "for (i = N - 1; i >= 0; i--)\n{\n  for (j = i + 1; j < N; j++)\n  {\n    Q1[i][j] = Q1[i][j - 1];\n    for (k = 0; k < ((j - i) - l); k++)\n    {\n      Qbp1[k + i][j] = (Q1[(k + i) + 1][j - 1] * ERT) * paired(k + i, j - 1);\n      Q1[i][j] += Q1[i][k + i] * Qbp1[k + i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcc/mcc/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    (cout << G.A[i][j]) << \" \";\n  }\n\n  cout << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BineshTharikoppula/Parallel-Tiled-Floyd-Warshall/FinalAPSP/7"}
{"code": "for (colx = 1; colx < (pages - 1); colx++)\n{\n  jA[i++] = colx - 1;\n  jA[i++] = colx + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mithradatha/parallel-pagerank/sparse_omp/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    A[(i * N) + j] = 1;\n    B[(j * N) + i] = 1;\n    C[(j * N) + i] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e2/entrega-2/openmp/4"}
{"code": "for (int i = 1; i <= n; i++)\n  for (int j = 1; j <= n; j++)\n{\n  printf(\"Valor A[%d][%d] \", i, j);\n  scanf(\"%d\", &a[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/MatricesCREW/6"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n  scanf(\"%lf\", &A[(i * n) + j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_mat_vect/0"}
{"code": "for (int is = 0; is < ns; is++)\n{\n  beta = ((.5 * qom[is]) * dt) / c;\n  for (int i = 0; i < nxn; i++)\n    for (int k = 0; k < nzn; k++)\n  {\n    omcx = beta * (Bxn[i][1][k] + Bx_ext[i][1][k]);\n    omcy = beta * (Byn[i][1][k] + By_ext[i][1][k]);\n    omcz = beta * (Bzn[i][1][k] + Bz_ext[i][1][k]);\n    denom = ((((((FourPI / 2) * delt) * dt) / c) * qom[is]) * rhons[is][i][1][k]) / (((1.0 + (omcx * omcx)) + (omcy * omcy)) + (omcz * omcz));\n    susxy[i][k] += (omcz + (omcx * omcy)) * denom;\n    susyy[i][k] += (1.0 + (omcy * omcy)) * denom;\n    suszy[i][k] += ((-omcx) + (omcy * omcz)) * denom;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/88"}
{"code": "for (j = 0; j < N; j++)\n{\n  U[0][j] = U[M][j];\n  V[M][j + 1] = V[0][j + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/13"}
{"code": "for (j = 0; j < 1000000; j++)\n{\n  rdot = rdot + (R[j] * R[j]);\n}\n\n", "pragma": "omp parallel for reduction(+:rdot)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/CG/C/cg/1"}
{"code": "formula.append((\"+ \" + number(dg)) + \"x \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/76"}
{"code": "for (; (last_i + 3) < n; last_i += 4)\n{\n  _mm256_store_pd(&y[last_i + 0], _mm256_load_pd(&x[last_i + 0]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/blas-kernels/GMS_copy_avx_unrolled16x/33"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  sum += i;\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/parallel9/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  graph[i] = (int *) malloc(n * (sizeof(int)));\n  for (int j = 0; j < n; j++)\n  {\n    graph[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arsalasif/bfs-hybrid-openmp-mpi/bfs/5"}
{"code": "for (int j = 0; j < (arraySize - 1); j++)\n{\n  if (compar(arrayBaseChar + (j * elementSize), pivot) <= 0)\n  {\n    swap(arrayBaseChar + (j * elementSize), arrayBaseChar + (index[j] * elementSize), elementSize);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/allywarner/HPC_OpenMP/Quicksort/main/2"}
{"code": "for (int i = xbeg; i <= xend; i++)\n  for (int j = ybeg; j <= yend; j++)\n  for (int k = upZstart; k <= zend; k++)\n{\n  populate_cell_with_particles(i, j, k, q_per_particle, dx_per_pcl, dy_per_pcl, dz_per_pcl);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/18"}
{"code": "for (int j = 0; j < N; j++)\n  matResult[j] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yasirunilan/Concurrent-OpenMP-Lab/main/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    A[(i * n) + j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hyejin97/GPU_programming_openmp-cuda/MatMul/matrixMul/1"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14u \", pageRankCorrelationStats_array[x].mismatch);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/31"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  sum_neigh = ((spins[neighs[i][UP]] + spins[neighs[i][DOWN]]) + spins[neighs[i][RIGHT]]) + spins[neighs[i][LEFT]];\n  energy += (spins[i]) ? ((2.0 * sum_neigh) - 4.0) : (4.0 - (2.0 * sum_neigh));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/12"}
{"code": "for (int i = 0; i < maxThreads; i++)\n{\n  vertexSetInit(&threadFrontiers[i], g->n);\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/2"}
{"code": "for (i = 0; i < 50; i++)\n{\n  sum += 1;\n}\n\n", "pragma": "omp parallel for private(i), reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmotel/zjp-labs/lab6/test/main/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  #pragma ivdep\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxyz[4 * (j + kj)] = at2 * zt1;\n    fxyz[1 + (4 * (j + kj))] = at3 * zt1;\n    fxyz[2 + (4 * (j + kj))] = zero;\n    fxyz[4 * (j + k1)] = at2 * zt2;\n    fxyz[1 + (4 * (j + k1))] = (-at3) * zt2;\n    fxyz[2 + (4 * (j + k1))] = zero;\n    fxyz[4 * ((j + kj) + l1)] = zero;\n    fxyz[1 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[2 + (4 * ((j + kj) + l1))] = zero;\n    fxyz[4 * ((j + k1) + l1)] = zero;\n    fxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    fxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    at1 = at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n    wp += (double) at1;\n  }\n\n  at1 = crealf(ffc[kk]) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = cimagf(q[kj]) - (crealf(q[kj]) * _Complex_I);\n  fxyz[4 * kj] = zero;\n  fxyz[1 + (4 * kj)] = at3 * zt1;\n  fxyz[2 + (4 * kj)] = zero;\n  fxyz[4 * k1] = zero;\n  fxyz[1 + (4 * k1)] = zero;\n  fxyz[2 + (4 * k1)] = zero;\n  fxyz[4 * (kj + l1)] = zero;\n  fxyz[1 + (4 * (kj + l1))] = zero;\n  fxyz[2 + (4 * (kj + l1))] = zero;\n  fxyz[4 * (k1 + l1)] = zero;\n  fxyz[1 + (4 * (k1 + l1))] = zero;\n  fxyz[2 + (4 * (k1 + l1))] = zero;\n  at1 = at1 * (q[kj] * conjf(q[kj]));\n  wp += (double) at1;\n  sum2 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/27"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  lsum += array[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ayush9719/Parallel-and-Distributed-Computing-Lab/Lab 04- Critical Construct and Reduction Clause/Code/thread4_1/0"}
{"code": "for (i = 0; i < stages; i++)\n{\n  for (j = 0; j < stages_array[i]; j++)\n  {\n    for (k = 0; k < 3; k++)\n    {\n      for (l = 0; l < 4; l++)\n      {\n        if (fgets(mystring, 12, fp) != NULL)\n          rectangles_array[r_index] = atoi(mystring);\n        else\n          break;\n\n        r_index++;\n      }\n\n      if (fgets(mystring, 12, fp) != NULL)\n      {\n        weights_array[w_index] = atoi(mystring);\n      }\n      else\n        break;\n\n      w_index++;\n    }\n\n    if (fgets(mystring, 12, fp) != NULL)\n      tree_thresh_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha1_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    if (fgets(mystring, 12, fp) != NULL)\n      alpha2_array[tree_index] = atoi(mystring);\n    else\n      break;\n\n    tree_index++;\n    if (j == (stages_array[i] - 1))\n    {\n      if (fgets(mystring, 12, fp) != NULL)\n        stages_thresh_array[i] = atoi(mystring);\n      else\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rajanjitenpatel/Face_detection/Parallel_code/haar/6"}
{"code": "for (int i = 1; i < K; i++)\n{\n  double dist;\n  sum = 0.0;\n  for (int j = 0; j < total_values; j++)\n  {\n    sum += pow(clusters[i].getCentralValue(j) - point.getValue(j), 2.0);\n  }\n\n  dist = sqrt(sum);\n  if (dist < min_dist)\n  {\n    min_dist = dist;\n    id_cluster_center = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gstangel/IT388_k_means/kmeans_parallel/1"}
{"code": "for (int j = real_subarray_size - 1; j >= 0; j--)\n{\n  sub_tablo->tab[j + real_subarray_size] = tab[((size - offset) - real_subarray_size) + j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thomasarmel/openmp_radix_sort/parallel_prefix_suffix/2"}
{"code": "for (size_t p = 0; p < fluidBoxes.size(); p++)\n{\n  double xmin1 = fluidBoxes[p]->getXmin();\n  double xmax1 = fluidBoxes[p]->getXmax();\n  double ymin1 = fluidBoxes[p]->getYmin();\n  double ymax1 = fluidBoxes[p]->getYmax();\n  double zmin1 = fluidBoxes[p]->getZmin();\n  double zmax1 = fluidBoxes[p]->getZmax();\n  for (size_t q = p + 1; q < fluidBoxes.size(); q++)\n  {\n    double xmin2 = fluidBoxes[q]->getXmin();\n    double xmax2 = fluidBoxes[q]->getXmax();\n    double ymin2 = fluidBoxes[q]->getYmin();\n    double ymax2 = fluidBoxes[q]->getYmax();\n    double zmin2 = fluidBoxes[q]->getZmin();\n    double zmax2 = fluidBoxes[q]->getZmax();\n    bool x_intersect = ((xmax1 >= xmax2) && (xmin1 <= xmax2)) || ((xmax2 >= xmax1) && (xmin2 <= xmax1));\n    bool y_intersect = ((ymax1 >= ymax2) && (ymin1 <= ymax2)) || ((ymax2 >= ymax1) && (ymin2 <= ymax1));\n    bool z_intersect = ((zmax1 >= zmax2) && (zmin1 <= zmax2)) || ((zmax2 >= zmax1) && (zmin2 <= zmax1));\n    if ((x_intersect && y_intersect) && z_intersect)\n    {\n      ((((cout << \"fluid object \") << (p + 1)) << \" is approaching fluid object \") << (q + 1)) << endl;\n      m_iContactAlert = true;\n      return;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/2"}
{"code": "for (j = 0; j < nxp; j++)\n{\n  f[j] = g[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpplib2/6"}
{"code": "for (int i = 0; i < length; i++)\n{\n  char count;\n  unsigned long x = data[i];\n  for (count = 0; x; count++)\n    x &= x - 1;\n\n  result[i] = count;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/popcount-omp/main/5"}
{"code": "for (int i = 0; i < 4000000; i++)\n{\n  maxs[omp_get_thread_num()] = fmaxf(maxs[omp_get_thread_num()], data[i]);\n  mins[omp_get_thread_num()] = fminf(mins[omp_get_thread_num()], data[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/min_max_reduction/3"}
{"code": "for (int i = 0; i < cells_ready_to_divide.size(); i++)\n{\n  cells_ready_to_divide[i]->divide();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/core/PhysiCell_cell_container/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  sum = 0;\n  for (k = 0; k < N; k++)\n    sum += A[i][k] * B[k][j];\n\n  C[i][j] = sum;\n}\n\n", "pragma": "      #pragma omp parallel for num_threads(NUM_THREADS) private(j,k) firstprivate(sum) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexandrosAlexiou/OpenMP-Exercise/Matrix-Multiplication/mat_mul_middle_for/0"}
{"code": "for (int i = 0; i < 45; i++)\n{\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter9/sibr/1"}
{"code": "for (int i = 0; i < vectorSize; i++)\n  sum += pVector[i];\n\n", "pragma": "#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/VectorSum/VectorSum/1"}
{"code": "for (k = n - 1; 1 <= k; k--)\n{\n  b[k - 1] = b[k - 1] + sdot(n - k, (a + k) + ((k - 1) * lda), 1, b + k, 1);\n  l = ipvt[k - 1];\n  if (l != k)\n  {\n    t = b[l - 1];\n    b[l - 1] = b[k - 1];\n    b[k - 1] = t;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/19"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float a = 2.;\n  float b = (-2.) * (xc + yc);\n  float c = ((xc * xc) + (yc * yc)) - (r * r);\n  float d = (b * b) - ((4. * a) * c);\n  if (d < 0.)\n  {\n    continue;\n  }\n\n  d = sqrt(d);\n  float t1 = ((-b) + d) / (2. * a);\n  float t2 = ((-b) - d) / (2. * a);\n  float tmin = (t1 < t2) ? (t1) : (t2);\n  if (tmin < 0.)\n  {\n    continue;\n  }\n\n  float xcir = tmin;\n  float ycir = tmin;\n  float nx = xcir - xc;\n  float ny = ycir - yc;\n  float n = sqrt((nx * nx) + (ny * ny));\n  nx /= n;\n  ny /= n;\n  float inx = xcir - 0.;\n  float iny = ycir - 0.;\n  float in = sqrt((inx * inx) + (iny * iny));\n  inx /= in;\n  iny /= in;\n  float dot = (inx * nx) + (iny * ny);\n  float outx = inx - ((2. * nx) * dot);\n  float outy = iny - ((2. * ny) * dot);\n  float t = (0. - ycir) / outy;\n  if (t < 0.)\n  {\n    continue;\n  }\n\n  numHits++;\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none) shared(xcs,ycs,rs) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AStockinger/Parallel-Programming/OpenMP Monte Carlo Simulation/MonteCarlo/1"}
{"code": "for (int64_t i = 0; i < themesh->vertices.size(); i++)\n{\n  if (i == 0)\n  {\n    printf(\"[Info] Using %d threads \\n\", omp_get_num_threads());\n  }\n\n  themesh->vertices[i] = themesh->vertices[i] - move_min;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/voxelizer-cuda/cpu_voxelizer/0"}
{"code": "for (k = 1; k <= n; k++)\n{\n  t = sdot(k - 1, (a + 0) + ((k - 1) * lda), 1, b, 1);\n  b[k - 1] = (b[k - 1] - t) / a[(k - 1) + ((k - 1) * lda)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/sgefa/18"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    double temp = arr[i][j];\n    arr[i][j] = arr[j][i];\n    arr[j][i] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KasunEdward/OpenMP_Project/OV_Parallel/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = iter->val;\n  iter = iter->next;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rahulr56/OpenMP/OpenMP_examples/mergesort/1"}
{"code": "for (r = 0; r < row; r++)\n{\n  for (c = 0; c < col; c++)\n  {\n    if ((r == 0) && (c == 0))\n    {\n      delta = (step / Cap) * (((power[0] + ((temp[1] - temp[0]) / Rx)) + ((temp[col] - temp[0]) / Ry)) + ((amb_temp - temp[0]) / Rz));\n    }\n    else\n      if ((r == 0) && (c == (col - 1)))\n    {\n      delta = (step / Cap) * (((power[c] + ((temp[c - 1] - temp[c]) / Rx)) + ((temp[c + col] - temp[c]) / Ry)) + ((amb_temp - temp[c]) / Rz));\n    }\n    else\n      if ((r == (row - 1)) && (c == (col - 1)))\n    {\n      delta = (step / Cap) * (((power[(r * col) + c] + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) / Rx)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) / Ry)) + ((amb_temp - temp[(r * col) + c]) / Rz));\n    }\n    else\n      if ((r == (row - 1)) && (c == 0))\n    {\n      delta = (step / Cap) * (((power[r * col] + ((temp[(r * col) + 1] - temp[r * col]) / Rx)) + ((temp[(r - 1) * col] - temp[r * col]) / Ry)) + ((amb_temp - temp[r * col]) / Rz));\n    }\n    else\n      if (r == 0)\n    {\n      delta = (step / Cap) * (((power[c] + (((temp[c + 1] + temp[c - 1]) - (2.0 * temp[c])) / Rx)) + ((temp[col + c] - temp[c]) / Ry)) + ((amb_temp - temp[c]) / Rz));\n    }\n    else\n      if (c == (col - 1))\n    {\n      delta = (step / Cap) * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.0 * temp[(r * col) + c])) / Ry)) + ((temp[((r * col) + c) - 1] - temp[(r * col) + c]) / Rx)) + ((amb_temp - temp[(r * col) + c]) / Rz));\n    }\n    else\n      if (r == (row - 1))\n    {\n      delta = (step / Cap) * (((power[(r * col) + c] + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.0 * temp[(r * col) + c])) / Rx)) + ((temp[((r - 1) * col) + c] - temp[(r * col) + c]) / Ry)) + ((amb_temp - temp[(r * col) + c]) / Rz));\n    }\n    else\n      if (c == 0)\n    {\n      delta = (step / Cap) * (((power[r * col] + (((temp[(r + 1) * col] + temp[(r - 1) * col]) - (2.0 * temp[r * col])) / Ry)) + ((temp[(r * col) + 1] - temp[r * col]) / Rx)) + ((amb_temp - temp[r * col]) / Rz));\n    }\n    else\n    {\n      delta = (step / Cap) * (((power[(r * col) + c] + (((temp[((r + 1) * col) + c] + temp[((r - 1) * col) + c]) - (2.0 * temp[(r * col) + c])) / Ry)) + (((temp[((r * col) + c) + 1] + temp[((r * col) + c) - 1]) - (2.0 * temp[(r * col) + c])) / Rx)) + ((amb_temp - temp[(r * col) + c]) / Rz));\n    }\n\n\n\n\n\n\n\n\n    result[(r * col) + c] = temp[(r * col) + c] + delta;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(power, temp,result) private(r, c, delta) firstprivate(row, col) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_hotspot/hotspot_openmp/0"}
{"code": "for (int j = begin; j < end; ++j)\n{\n  if ((i0 < middle) && ((i1 >= end) || (src[i0] <= src[i1])))\n  {\n    dest[j] = src[i0++];\n  }\n  else\n  {\n    dest[j] = src[i1++];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0xe1d1a/pcs/omp/vec/1"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  logic_or = logic_or || logics[i];\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(||:logic_or)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/for_reduction/6"}
{"code": "for (i = 0; i < 100; i++)\n{\n  sum += x[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/Laborator/lab01/ex_pdf/for/1"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  for (int j = 0; j < ((n - i) - 1); j++)\n  {\n    if (arr[j] > arr[j + 1])\n    {\n      swap(arr[j], arr[j + 1]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/odd_even/1"}
{"code": "for (v = 0; v < tot_ev_per_dim[1]; v++)\n  for (d = 2; d < dim; d++)\n  gridpoint_vec[(v * dim) + d] = gridpoint[d];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulopeznovoa/kde_openmp/computePDF/9"}
{"code": "for (int i = 0; i < Ndim; i++)\n{\n  TYPE tmp = xnew[i] - xold[i];\n  conv += tmp * tmp;\n}\n\n", "pragma": "omp teams distribute parallel for simd reduction(+ : conv)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Challenge_problems/GPU_Programming/Solutions/jac_solv_coal/1"}
{"code": "for (j = i; j < (i + m); j++)\n{\n  k = ((m + i) - 1) - j;\n  if (k == 0)\n  {\n    if (X[k] == Y[j])\n      L[k][j] = 1;\n    else\n      L[k][j] = L[k][j - 1];\n\n  }\n  else\n  {\n    if (X[k] == Y[j])\n      L[k][j] = L[k - 1][j - 1] + 1;\n    else\n      L[k][j] = (L[k - 1][j] >= L[k][j - 1]) ? (L[k - 1][j]) : (L[k][j - 1]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_diagonal/1"}
{"code": "for (r = 0; r < 1000; r++)\n{\n  loop2();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satlawa/edin_threaded_programming/loops_schedules/loop_schedules/1"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    yarea[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = celldx[FTNREF1D(j, x_min - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/10"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/36"}
{"code": "for (i = 1; i < numClusters; i++)\n{\n  newClusters[i] = newClusters[i - 1] + numDims;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amitlevy21/kMeans_200055986/kMeans_200055986/kMeans/1"}
{"code": "for (int step = 0; step < num_steps; step++)\n{\n  test(num_neurons, neurons_per_item, dt, encode_result, voltage, reftime, tau_rc, tau_ref, bias, gain, spikes);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lif-omp/main/4"}
{"code": "for (i = 0; i < x.size(); i++)\n{\n  for (j = 0; j < wh[1].size(); j++)\n  {\n    temp = 0.0;\n    for (k = 0; k < wh.size(); ++k)\n      temp += x[i][k] * wh[k][j];\n\n    temp += bh[j];\n    hidden[i][j] = sigmoid(temp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mitesh1612/Parallel-Neural-Networks/MiniBatchSequential/1"}
{"code": "for (ncand = 0, ii = 0; ii < nqterms; ii++)\n{\n  i = qind[ii];\n  if (i < ncols)\n  {\n    for (j = colptr[i]; j < colptr[i + 1]; j++)\n    {\n      k = colind[j];\n      if (marker[k] == (-1))\n      {\n        cand[ncand].val = k;\n        cand[ncand].key = 0;\n        marker[k] = ncand++;\n      }\n\n      cand[marker[k]].key += colval[j] * qval[ii];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/52"}
{"code": "for (i = 1; i <= 100; ++i)\n{\n  for (j = 1; j <= 100; ++j)\n  {\n    org[i][j] = h[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Jacob_iterations_OpenMP/6"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    get_min_dt_kernel(&((double *) arg0.data)[1 * n], &arg1_l[64 * omp_get_thread_num()]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[7].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/get_min_dt_kernel_kernel/1"}
{"code": "for (k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (j = 1; j <= depth; j++)\n  {\n    soundspeed[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = soundspeed[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/26"}
{"code": "for (int i = 1; i < (nxn - 1); i++)\n  for (int j = 1; j < (nyn - 1); j++)\n{\n  rhons[is][i][j][nzn - 2] *= 2;\n  Jxs[is][i][j][nzn - 2] *= 2;\n  Jys[is][i][j][nzn - 2] *= 2;\n  Jzs[is][i][j][nzn - 2] *= 2;\n  pXXsn[is][i][j][nzn - 2] *= 2;\n  pXYsn[is][i][j][nzn - 2] *= 2;\n  pXZsn[is][i][j][nzn - 2] *= 2;\n  pYYsn[is][i][j][nzn - 2] *= 2;\n  pYZsn[is][i][j][nzn - 2] *= 2;\n  pZZsn[is][i][j][nzn - 2] *= 2;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/39"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  sum += h * (4.0 / (1 + (x * x)));\n  x += h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/pi/0"}
{"code": "for (int i = 0; i < gray_size; i++)\n  gray[i] = ((0.30 * rgb[i * 3]) + (0.59 * rgb[(i * 3) + 1])) + (0.11 * rgb[(i * 3) + 2]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/sobel-filter/src/sobel/0"}
{"code": "for (int i = 0; i < BS; i++)\n  V[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/43"}
{"code": "for (int i = 0; i < pixelList2.size(); i++)\n{\n  (((((((out << pixelList2[i][0]) << ',') << pixelList2[i][1]) << ',') << pixelList2[i][2]) << ',') << pixelList2[i][3]) << ',';\n  (((((((out << pixelList2[i][13]) << ',') << pixelList2[i][15]) << ',') << pixelList2[i][12]) << ',') << pixelList2[i][16]) << ',';\n  (((((((out << pixelList2[i][17]) << ',') << pixelList2[i][18]) << ',') << pixelList2[i][11]) << ',') << pixelList2[i][19]) << ',';\n  (((((((out << pixelList2[i][20]) << ',') << pixelList2[i][9]) << ',') << pixelList2[i][21]) << ',') << pixelList2[i][22]) << ',';\n  (((((((out << pixelList2[i][23]) << ',') << pixelList2[i][10]) << ',') << pixelList2[i][24]) << ',') << pixelList2[i][4]) << ',';\n  (((((((out << pixelList2[i][5]) << ',') << pixelList2[i][6]) << ',') << pixelList2[i][7]) << ',') << pixelList2[i][8]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/52"}
{"code": "for (unsigned int i = 0; i < (1 + ((int) ((TEMP_MAX - 0.7) / 0.00005))); i++)\n{\n  printf(\"%lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\t%.10lf\\n\", stat[i].t, stat[i].e / (((double) (2048 * 2048)) * SAMPLES), stat[i].e2 / ((((double) (2048 * 2048)) * (2048 * 2048)) * SAMPLES), stat[i].e4 / ((((((double) (2048 * 2048)) * (2048 * 2048)) * (2048 * 2048)) * (2048 * 2048)) * SAMPLES), stat[i].m / SAMPLES, stat[i].m2 / SAMPLES, stat[i].m4 / SAMPLES);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/22"}
{"code": "for (i = 1; i < size; i++)\n  for (j = 0; j < row_each; j++)\n  MPI_Send(arr[j + (i * row_each)], 4, (MPI_Datatype) 0x4c000405, i, 0, (MPI_Comm) 0x44000000);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharangKulkarni2/matrix-dot-product/hybridparallel/7"}
{"code": "for (uint iy = start_y; iy < end_y; iy++)\n{\n  for (uint iz = start_z; iz < end_z; iz++)\n  {\n    for (uint ix = start_x; ix < end_x; ix++)\n    {\n      uint offset_window = (((iy * wnx) * wnz) + (iz * wnx)) + ix;\n      uint offset_full = (((((iy + sy) * nx) * nz) + ((iz + sz) * nx)) + ix) + sx;\n      window_param[offset_window] = param_ptr[offset_full];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp teams distribute parallel for collapse(3) schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/model-handlers/SeismicModelHandler/0"}
{"code": "for (i = 0; i < 16; i++)\n  a[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/nanox/tests/mcc/omp/omp_ws_01/1"}
{"code": "for (ii = 0; ii < (params->ny * params->nx); ++ii)\n{\n  (*cells_ptr)[ii].speeds[0] = w0;\n  (*cells_ptr)[ii].speeds[1] = w1;\n  (*cells_ptr)[ii].speeds[2] = w1;\n  (*cells_ptr)[ii].speeds[3] = w1;\n  (*cells_ptr)[ii].speeds[4] = w1;\n  (*cells_ptr)[ii].speeds[5] = w2;\n  (*cells_ptr)[ii].speeds[6] = w2;\n  (*cells_ptr)[ii].speeds[7] = w2;\n  (*cells_ptr)[ii].speeds[8] = w2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/an4/HPC-OpenMP/d2q9-bgk/5"}
{"code": "for (i = Slave_NS2; i < NS2; i++)\n{\n  computeOnGPU(seq1, seqs2[i], w, &best_ms[i], &best_offset[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iritashuri/Parallel_and_distributed_computing_Alignment_Score/main/0"}
{"code": "for (v = 0; v < cache->numPropertyRegions; ++v)\n{\n  if ((addr >= cache->propertyRegions[v].lower_bound) && (addr < cache->propertyRegions[v].hot_bound))\n  {\n    result = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/16"}
{"code": "for (i = 0; i < N; i++)\n{\n  free(uold[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niksterg/openmp-course/poisson-SOR/14"}
{"code": "for (ii = 0; ii < 10; jj = ii + 2)\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/26"}
{"code": "for (i = 0; i < len; i++)\n{\n  if ((tmp[i] == ' ') || (tmp[i] == '\\t'))\n  {\n    X.order++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/0"}
{"code": "for (i = 0; i < nbRawMatrix; ++i)\n{\n  error = 1.0;\n  intiValueLayer(tabLayer[0], i);\n  fillOutc(outc, i);\n  rnnsetstart(tabLayer);\n  rnnset(tabLayer, outc);\n  ajustError(tabLayer[NBLAYER - 1]);\n  error = geterror(tabLayer[NBLAYER - 1], outc);\n  wichError(tabLayer[NBLAYER - 1], outc);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/26"}
{"code": "for (i = 0; i < 20; i++)\n  toplam += dizi[i];\n\n", "pragma": "omp for schedule(static) reduction(+:toplam)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ienesaydogdu/Parallel-Programming-with-MPI-and-OpenMP/mpi_thread_funneled/0"}
{"code": "for (int i = 0; i < blockY; i++)\n{\n  for (int j = 0; j < blockY; j++)\n  {\n    printf(\"%5.2f   \", lookup2D(A, i, j, blockY));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ermangurses/Parallel-Programming-Models-CSC-620/matrixInverse/omp/ompInverse/6"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  u[i] = (double *) malloc(Nt * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svretina/OpenMP-projects/wave/3"}
{"code": "for (i = 0; i < 5000; i++)\n{\n  for (j = 0; j < 5000; j++)\n  {\n    fprintf(fp, \"%lf\\n\", B[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Add_Mult_Transpose_Tile/TiledTranspose/optimized_tiled_transpose/2"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(fptr, \"%-14lf \", pageRankCorrelationStats_array[x].avg_error_float);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/32"}
{"code": "for (int i = 0; i < points->num; i++)\n{\n  is_center[points->p[i].assign] = true;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/24"}
{"code": "for (unsigned int row = 2; row < (height - 2); ++row)\n{\n  for (unsigned int col = 2; col < (width - 2); ++col)\n  {\n    newPixel = 0;\n    for (int rowOffset = -2; rowOffset <= 2; rowOffset++)\n    {\n      for (int colOffset = -2; colOffset <= 2; colOffset++)\n      {\n        iOffset = (unsigned long) ((((row + rowOffset) * width) + col) + colOffset);\n        newPixel += image[iOffset] * gaussianMask[2 + rowOffset][2 + colOffset];\n      }\n\n    }\n\n    image[(row * width) + col] = newPixel / gaussianTotal;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) shared(gaussianMask,image,height,width) private(newPixel,iOffset)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thu105/PhotoMosaic/main/2"}
{"code": "for (i = 0; i < p; ++i)\n{\n  a1 = a->matrix + (i * q);\n  c = result->matrix + (i * r);\n  for (j = 0; j < r; ++j)\n  {\n    b1 = b->matrix + (j * q);\n    temp = 0;\n    q = q - 16;\n    for (k = 0; k < q; k += 16)\n    {\n      a1 += k;\n      b1 += k;\n      temp += ((((((((((((((((*a1) * (*b1)) + ((*(a1 + 1)) * (*(b1 + 1)))) + ((*(a1 + 2)) * (*(b1 + 2)))) + ((*(a1 + 3)) * (*(b1 + 3)))) + ((*(a1 + 4)) * (*(b1 + 4)))) + ((*(a1 + 5)) * (*(b1 + 5)))) + ((*(a1 + 6)) * (*(b1 + 6)))) + ((*(a1 + 7)) * (*(b1 + 7)))) + ((*(a1 + 8)) * (*(b1 + 8)))) + ((*(a1 + 9)) * (*(b1 + 9)))) + ((*(a1 + 10)) * (*(b1 + 10)))) + ((*(a1 + 11)) * (*(b1 + 11)))) + ((*(a1 + 12)) * (*(b1 + 12)))) + ((*(a1 + 13)) * (*(b1 + 13)))) + ((*(a1 + 14)) * (*(b1 + 14)))) + ((*(a1 + 15)) * (*(b1 + 15)));\n      a1 -= k;\n      b1 -= k;\n    }\n\n    q = q + 16;\n    for (; k < q; k++)\n      temp += (*(a1 + k)) * (*(b1 + k));\n\n    *(c + j) = temp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arjunth2001/Software-Programming-for-Performance/Assignment2/trials/1/0"}
{"code": "for (i = 0; i < nvtxs; i++)\n  perm[iperm[i]] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  binary[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] << 4;\n  binary[i] |= atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETLMv2_fmt_plug/4"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  for (j = 0; j < NCB; j++)\n  {\n    junction = 0.0;\n    for (k = 0; k < NCA; k++)\n    {\n      junction += a[i][k] * b[k][j];\n    }\n\n    c[i][j] = junction;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/mm_v3/0"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  d = x[j] - r[j];\n  sum = sum + (d * d);\n}\n\n", "pragma": "\t#pragma omp for reduction(+:sum) private(d)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/15"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n  }\n\n}\n\n", "pragma": "                    #pragma omp parallel for num_threads(thds) schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajaykvala/Single-threads/middle_loop_parallel_fw/0"}
{"code": "for (int j = 0; j < Ns; j++)\n{\n  del = Randint();\n  rho = 1.0;\n  int x[2];\n  int x_[2];\n  for (int i = 0; i < Nt; i++)\n  {\n    x[0] = i;\n    x[1] = j;\n    shiftx(x_, x, -1, 0);\n    if (del > 0)\n    {\n      if (k[i][j][0] >= 0)\n        rho *= 1.0 / ((k[i][j][0] + 1) + a[i][j][0]);\n      else\n        rho *= abs(k[i][j][0]) + a[i][j][0];\n\n      if ((k[x[0]][x[1]][0] >= 0) && (k[x_[0]][x_[1]][0] >= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][0] < 0) && (k[x_[0]][x_[1]][0] < 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n    }\n    else\n    {\n      if (k[i][j][0] > 0)\n        rho *= k[i][j][0] + a[i][j][0];\n      else\n        rho *= 1.0 / ((abs(k[i][j][0]) + a[i][j][0]) + 1);\n\n      if ((k[x[0]][x[1]][0] <= 0) && (k[x_[0]][x_[1]][0] <= 0))\n        rho *= I_val[sx(x, k, a) + 2] / I_val[sx(x, k, a)];\n      else\n        if ((k[x[0]][x[1]][0] > 0) && (k[x_[0]][x_[1]][0] > 0))\n        rho *= I_val[sx(x, k, a) - 2] / I_val[sx(x, k, a)];\n\n\n    }\n\n    rho *= exp(mu * del);\n  }\n\n  if (Rand() < rho)\n  {\n    for (int i = 0; i < Nt; i++)\n    {\n      k[i][j][0] += del;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(rho, del, x, x_)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rishabhmallik/parallel-loopplaquette-algorithm-openmp/main/9"}
{"code": "for (v = size_k - topk; v < size_k; v++)\n{\n  if (array2[array3[v]] != array1[array3[v]])\n    mismatch++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/10"}
{"code": "for (v = 0; v < gr->nodes; v++)\n{\n  if (v == startNode)\n  {\n    dijkstra[v].flag = 1;\n    dijkstra[v].prev = startNode;\n    dijkstra[v].cost = 0;\n  }\n  else\n  {\n    dijkstra[v].flag = 0;\n    dijkstra[v].cost = 4294967295U;\n  }\n\n  dijkstra[v].id = v;\n}\n\n", "pragma": "omp parallel for num_threads(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris21gr/Boruvka_and_Dijkstra_Parallel/openMP_dijkstra/openMP_dijkstra/0"}
{"code": "for (int i = max_cols - 4; i >= 0; i--)\n{\n  for (idx = 0; idx <= i; idx++)\n  {\n    index = ((((((max_cols - idx) - 2) * max_cols) + idx) + max_cols) - i) - 2;\n    input_itemsets[index] = maximum(input_itemsets[(index - 1) - max_cols] + referrence[index], input_itemsets[index - 1] - penalty, input_itemsets[index - max_cols] - penalty);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_nw/needle/8"}
{"code": "for (int i = 0; i < total_procs; i++)\n{\n  final_count += succesful_col[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlexKasapis/OpenMP/Examine/3"}
{"code": "for (size_t i = 0; i < 10240; i++)\n{\n  a[i] = ((float) rand()) / ((float) (32767 / 5));\n  ref[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fritschnils/tp-parallelisation/tp2/tp2_3_enumeration_sort/7"}
{"code": "for (int i = 0; i < NODE; i++)\n{\n  int distance = dist[start] + graph[start][i];\n  if ((distance < dist[i]) && (selected[i] == 0))\n  {\n    dist[i] = distance;\n    prev[i] = start;\n  }\n\n  if ((min > dist[i]) && (selected[i] == 0))\n  {\n    min = dist[i];\n    waypoint = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/actumn/dijkstra-openmp/dijkstra/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    result[j][i] = 0;\n    for (int k = 0; k < n; k++)\n    {\n      result[j][i] += mat1[j][k] * mat2[k][i];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(mat1, mat2, n, result)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BenjaminCreem/MatrixMatrixMultiplicationParallel/mm-student/0"}
{"code": "for (m = 3; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      n = ((m - 3) + 1) * 5;\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/31"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i + 1;\n  b[i] = i + 2;\n  validate[i] = sqrt(a[i]) * sqrt(b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/math_sqrt_float/math_sqrt_float/1"}
{"code": "for (int i = 0; i < NUM_OF_TASKS; i++)\n{\n  if (min_elem_in_task[i] < min)\n  {\n    min = min_elem_in_task[i];\n    min_row = min_row_in_task[i];\n    min_col = min_col_in_task[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalgoyall/ParallelMatrixMult/Competition/main/4"}
{"code": "for (bfs_root_idx = 0; bfs_root_idx < num_bfs_roots; ++bfs_root_idx)\n{\n  int64_t root;\n  while (1)\n  {\n    double d[2];\n    make_random_numbers(2, seed1, seed2, counter, d);\n    root = ((int64_t) ((d[0] + d[1]) * nglobalverts)) % nglobalverts;\n    counter += 2;\n    if (counter > (2 * nglobalverts))\n      break;\n\n    int is_duplicate = 0;\n    int i;\n    for (i = 0; i < bfs_root_idx; ++i)\n    {\n      if (root == bfs_roots[i])\n      {\n        is_duplicate = 1;\n        break;\n      }\n\n    }\n\n    if (is_duplicate)\n      continue;\n\n    int root_ok = 0;\n    if (in_generating_rectangle && (((root / CHAR_BIT) / bitmap_size_in_bytes) == my_col))\n    {\n      root_ok = (has_edge[(root / CHAR_BIT) % bitmap_size_in_bytes] & (1 << (root % CHAR_BIT))) != 0;\n    }\n\n    MPI_Allreduce((void *) (-1), &root_ok, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000007, 1);\n    if (root_ok)\n      break;\n\n  }\n\n  bfs_roots[bfs_root_idx] = root;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/main/3"}
{"code": "for (int i = 0; i < num; i++)\n{\n  int pos = rand() % 15;\n  res.append(1, arr[pos]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aleri-a/Parallel-Systems--Frequency-calculation-of-characters-/parallel_project/parallel_project/Source/3"}
{"code": "for (int i = 0; i < 5; i++)\n  printf(\" %d\\n\", i, b[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Srinidi-V/openmp/enumeration/1"}
{"code": "for (i = c + 1; i < 150; i++)\n{\n  e[2][i] = a1[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/6"}
{"code": "for (int32_t i = 0; i < 10; i++)\n{\n  sum[i].x = 0;\n  sum[i].y = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/iomp/c/success_for_reduction_10/1"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int idx = (i * width) + j;\n    if (labels[idx] != 0)\n    {\n      labels[idx] = max(labels[idx], labels[labels[idx] - 1]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saracmustafa/OpenMP-TBB-Image-Segmentation/OpenMP/imageseg_OMP/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  double ax = force_x[i] / mass[i];\n  double ay = force_y[i] / mass[i];\n  u[i] += ax * dt;\n  v[i] += ay * dt;\n  x[i] += u[i] * dt;\n  y[i] += v[i] * dt;\n  bounce(&x[i], &y[i], &u[i], &v[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/0"}
{"code": "for (j = 0; j < nmor; j++)\n{\n  tmort[j] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/4"}
{"code": "for (i = 0; i < order; i++)\n{\n  pos = i * max_dim;\n  for (j = 0; j < X.dimension[i]; j++)\n  {\n    k = CountX[pos];\n    CountX[pos] = now;\n    tempX[pos++] = now;\n    now += k;\n  }\n\n  CountX[pos] = now;\n  tempX[pos] = now;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/9"}
{"code": "for (i = 1; i < nu; i++)\n{\n  f[i] = (f[i] - (aleft[i] * f[i - 1])) / adiag[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/22"}
{"code": "for (int i = 1; i < size; i++)\n{\n  if (maxScore.scoreWeight < scoreList[i].scoreWeight)\n  {\n    maxScore.off = scoreList[i].off;\n    maxScore.n = scoreList[i].n;\n    maxScore.k = scoreList[i].k;\n    maxScore.scoreWeight = scoreList[i].scoreWeight;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MatanF5/Sequence_Allignment_Parllel/functions/5"}
{"code": "for (int i = border - localLabelSize; i < (border + decrement); i++)\n{\n  if (changes.find(labels[i]) != changes.end())\n  {\n    int newVal = changes[labels[i]];\n    while (changes.find(newVal) != changes.end())\n    {\n      newVal = changes[newVal];\n    }\n\n    labels[i] = newVal;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mebegu/Parallel-Image-Segmentation/imseg_serial/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  im[(indi[i] * py) + indj[i]] += 0.25 * sqrt(im[((indi[i] - 1) * py) + indj[i]] + im[((indi[i] * py) + indj[i]) - 1]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/filtro-paralelo/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  Automated();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Elusive7733/OpenMP-vs-Pthread-vs-Serial-Sorting/OpenMP/BubbleSort_OpenMP/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    double *pA;\n    double *pB;\n    double suma = 0.0;\n    pA = matrizA + (i * N);\n    pB = matrizB + j;\n    for (int k = 0; k < N; k++, pA++, pB += N)\n    {\n      suma += (*pA) * (*pB);\n    }\n\n    matrizC[(i * N) + j] = suma;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/macatimo17/openMP/MM1c/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  press[i] = pressurePPE(i);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/51"}
{"code": "for (int j = 1; j <= wf.n2; j++)\n{\n  for (int i = 1; i <= wf.n1; i++)\n  {\n    dip -= (conj(wf.wave[wf.in2(j, i)]) * (wf.x1[i] + wf.x2[i])) * wf.wave[wf.in2(j, i)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/47"}
{"code": "for (t = 0; t < n; t++)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current[lindex].S, BF_init_state.S, sizeof(BF_current[lindex].S));\n    memcpy(BF_current[lindex].P, BF_init_key[index], sizeof(BF_current[lindex].P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current[lindex].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[lindex].P[16 + 1];\n      ;\n      BF_current[lindex].P[i] = L0;\n      BF_current[lindex].P[i + 1] = R0;\n    }\n\n    ptr = BF_current[lindex].S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current[lindex].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[lindex].P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current[lindex].P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current[lindex].P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current[lindex].P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current[lindex].P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current[lindex].S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current[lindex].P[0] ^= BF_exp_key[index][0];\n      BF_current[lindex].P[1] ^= BF_exp_key[index][1];\n      BF_current[lindex].P[2] ^= BF_exp_key[index][2];\n      BF_current[lindex].P[3] ^= BF_exp_key[index][3];\n      BF_current[lindex].P[4] ^= BF_exp_key[index][4];\n      BF_current[lindex].P[5] ^= BF_exp_key[index][5];\n      BF_current[lindex].P[6] ^= BF_exp_key[index][6];\n      BF_current[lindex].P[7] ^= BF_exp_key[index][7];\n      BF_current[lindex].P[8] ^= BF_exp_key[index][8];\n      BF_current[lindex].P[9] ^= BF_exp_key[index][9];\n      BF_current[lindex].P[10] ^= BF_exp_key[index][10];\n      BF_current[lindex].P[11] ^= BF_exp_key[index][11];\n      BF_current[lindex].P[12] ^= BF_exp_key[index][12];\n      BF_current[lindex].P[13] ^= BF_exp_key[index][13];\n      BF_current[lindex].P[14] ^= BF_exp_key[index][14];\n      BF_current[lindex].P[15] ^= BF_exp_key[index][15];\n      BF_current[lindex].P[16] ^= BF_exp_key[index][16];\n      BF_current[lindex].P[17] ^= BF_exp_key[index][17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current[lindex].P[0] ^= u1;\n      BF_current[lindex].P[1] ^= u2;\n      BF_current[lindex].P[2] ^= u3;\n      BF_current[lindex].P[3] ^= u4;\n      BF_current[lindex].P[4] ^= u1;\n      BF_current[lindex].P[5] ^= u2;\n      BF_current[lindex].P[6] ^= u3;\n      BF_current[lindex].P[7] ^= u4;\n      BF_current[lindex].P[8] ^= u1;\n      BF_current[lindex].P[9] ^= u2;\n      BF_current[lindex].P[10] ^= u3;\n      BF_current[lindex].P[11] ^= u4;\n      BF_current[lindex].P[12] ^= u1;\n      BF_current[lindex].P[13] ^= u2;\n      BF_current[lindex].P[14] ^= u3;\n      BF_current[lindex].P[15] ^= u4;\n      BF_current[lindex].P[16] ^= u1;\n      BF_current[lindex].P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current[lindex].P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current[lindex].P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current[lindex].S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current[lindex].S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current[lindex].P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current[lindex].P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/40"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  (cout << sequencia_aleatoria[i].length()) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    a[i][j] = (i * j) + 0.01;\n  }\n\n  v_out[i] = (i * j) + 0.01;\n  v[i] = (i * j) + 0.01;\n}\n\n", "pragma": "omp parallel for private(i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB062-matrixvector2-orig-no/0"}
{"code": "for (i = 0; i != struct_count; ++i)\n{\n  ts_after_sub = __Pyx_BufFmt_CheckString(ctx, ts);\n  if (!ts_after_sub)\n    return NULL;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/36"}
{"code": "for (int i = 0; i < numRows; i++)\n{\n  grid[i].resize(numCols);\n}\n\n", "pragma": "\t\t\t\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexRod34/Largest_Product_in_Grid/alex_rodriguez_Hmk3Prob2/0"}
{"code": "for (i = 0; i < 180; i++)\n{\n  x_ptr[i] = x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/1"}
{"code": "for (i = 0; i <= dimension; i++)\n{\n  aux = matrix[(line * (dimension + 1)) + i];\n  matrix[(line * (dimension + 1)) + i] = matrix[(swap * (dimension + 1)) + i];\n  matrix[(swap * (dimension + 1)) + i] = aux;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/giovaniortolani/Projeto2-ProgConc/src/gauss/5"}
{"code": "for (w = 0; w < num_of_wires; w++)\n{\n  new_rand_path(&wires[w]);\n}\n\n", "pragma": "    #pragma omp parallel for default(shared)                       \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jcksber/CMU_15-418_hw3/code/wireroute/6"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpty1oz70a.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/llvm-openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (i = 0; i < k; i++)\n{\n  strcpy(&b_genes[gene_prefixes[i]], genes[i].c_str());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/3"}
{"code": "for (int i = 0; i < numDimensions; i++)\n  force[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Dynamique_Moleculaire/DynMol_parallel/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  M[i] = malloc(N * (sizeof(*M[i])));\n  E[i] = malloc(N * (sizeof(*E[i])));\n  M_hat[i] = malloc(N * (sizeof(*M_hat[i])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/4"}
{"code": "for (int i = 0; i < (num_test * 10); i++)\n{\n  int index = randGen.generate01() * (mesh.vert.size() - 1);\n  test_indeces.push_back(index);\n  randomSamples[i] += mesh.vert[i].P();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dfsp-spirit/cpp_geodesics/third_party/vcglib/apps/sample/trimesh_indexing/trimesh_indexing/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  wA[i] = ((((int) rand()) % 2) * i) / (n / 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/TestScheduleThreads/0"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  const double *residual = &data0[5 * n_op];\n  double *rms = &arg1_l;\n  for (int i = 0; i < NVAR; i++)\n  {\n    *rms += residual[i] * residual[i];\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1) reduction(+:arg1_l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/calc_rms_kernel_omp4kernel_func/0"}
{"code": "for (int i = 0; i < N_trials; i++)\n{\n  x = 1.0 * rand_om(rand_om_val);\n  y = 1.0 * rand_om(rand_om_val);\n  if (((x * x) + (y * y)) <= 1.0)\n    cnt++;\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:cnt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shashank68/OpenMP_Programs/7/7_parallel/0"}
{"code": "for (int j = 0; j < CVT_INT(m_nSoilLyrs[i]); j++)\n  tmp_rtfr[i][j] = 0.f;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/management/PLTMGT_SWAT/managementOperation_SWAT/5"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  graph->traverseParallel();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/3"}
{"code": "for (i = 0; i < 10; i++)\n{\n  d = d + ((a[i] - avg) * (a[i] - avg));\n}\n\n", "pragma": "omp parallel for reduction(+ : d)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/avg min max SD of  numbers/3"}
{"code": "for (int i = 0; i < nthreads; i++)\n  seeds[i] = random();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aswild/omp-randarray/randarray/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  this->Crossover(this->breeders[i][0], this->breeders[i][1]);\n}\n\n", "pragma": "      #pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a[%d] suma=%d\\n \", 0, i, suma);\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/firstlastprivate-clause/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  arr[i] = i / 2.;\n}\n\n", "pragma": "#pragma omp parallel for shared(N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidDureau/APP/TD1_OMP/omp_intro/10_parallel_for/0"}
{"code": "for (i = 0; i < clusters_size; i++)\n{\n  fprintf(file, \"%lf\\t%lf\\t%lf\\n\", clusters[i].center.x, clusters[i].center.y, clusters[i].center.z);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/12"}
{"code": "for (i = 0; i <= (NQ - 1); i++)\n{\n  gc = gc + q[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/EP/ep/7"}
{"code": "for (j = 0; j < 2; j++)\n{\n  secp256k1_fe_sqr(&x11, &x11);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/secp256k1-omp/main/3"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    energy0[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = energy0[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/10"}
{"code": "for (int iState = 0; iState < nState; iState++)\n{\n  float maxProb = 0.0;\n  int maxState = -1;\n  for (int preState = 0; preState < nState; preState++)\n  {\n    float p = maxProbOld[preState] + mtState[(iState * nState) + preState];\n    if (p > maxProb)\n    {\n      maxProb = p;\n      maxState = preState;\n    }\n\n  }\n\n  maxProbNew[iState] = maxProb + mtEmit[(obs[t] * nState) + iState];\n  path[((t - 1) * nState) + iState] = maxState;\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hmm-omp/ViterbiGPU/0"}
{"code": "for (direction[0] = -1; direction[0] < 2; direction[0]++)\n{\n  for (direction[1] = -1; direction[1] < 2; direction[1]++)\n  {\n    for (direction[2] = -1; direction[2] < 2; direction[2]++)\n    {\n      if (!((direction[0] || direction[1]) || direction[2]))\n      {\n        continue;\n      }\n\n      int src_coords[3] = {my_coords[0] - direction[0], my_coords[1] - direction[1], my_coords[2] - direction[2]};\n      int dest_coords[3] = {my_coords[0] + direction[0], my_coords[1] + direction[1], my_coords[2] + direction[2]};\n      int source;\n      int dest;\n      MPI_Cart_rank(comm, src_coords, &source);\n      MPI_Cart_rank(comm, dest_coords, &dest);\n      if ((source == rank) && (dest == rank))\n      {\n        recvbufs[shift] = malloc(0);\n        recvcount[shift] = 0;\n        shift++;\n        continue;\n      }\n\n      MPI_Sendrecv(&sendcount[shift], 1, (MPI_Datatype) 0x4c000406, dest, 18361, &recvcount[shift], 1, (MPI_Datatype) 0x4c000406, source, 18361, comm, 0);\n      recvbufs[shift] = calloc((size_t) recvcount[shift], sizeof(cell_t));\n      MPI_Sendrecv(sendbuf[shift], sendcount[shift], (MPI_Datatype) 0x4c000819, dest, 25341, recvbufs[shift], recvcount[shift], (MPI_Datatype) 0x4c000819, source, 25341, comm, 0);\n      shift++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogocp/life3d/life3d-mpi/7"}
{"code": "for (i = ist1; i <= iend1; i += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,m) firstprivate (iend1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/97"}
{"code": "for (size_t i = 0; i < NUM_THREADS; i++)\n{\n  const unsigned long int worker_quotient = (i < remainder) ? (quotient + 1) : (quotient);\n  struct transform_row_params *params = (struct transform_row_params *) (&buffer[(2 * IMAGE_SIZE_IN_BYTES) + (i * (sizeof(struct transform_row_params)))]);\n  params->input_image = read_buffer;\n  params->output_image = write_buffer;\n  copy_kernel(params->kernel, kernel);\n  params->IMAGE_HEIGHT = IMAGE_HEIGHT;\n  params->IMAGE_WIDTH = IMAGE_WIDTH;\n  params->num_rows = worker_quotient;\n  params->start_row = total_assigned_rows;\n  total_assigned_rows += worker_quotient;\n  transform_rows(params);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xeptore/blurrifier-openmp/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] += offset;\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AshkanGoharfar/Openmp_prefix_sum_Hillis_Steele_algorithm/inclusive_exclusive/inclusive_exclusive/1"}
{"code": "for (i = 0; i < n; ++i)\n  for (k = 0; k < n; ++k)\n  for (j = 0; j < n; ++j)\n  C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];\n\n\n\n", "pragma": "omp parallel for default(none) shared(n,A,B,C) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/konfou/openmp-course-sols/c/ex4-matrix-multi-openmp/0"}
{"code": "for (i = 0; i < 6; i++)\n  newTask->board[i] = (int *) malloc(6 * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chamalis/knightsTour_OMP/B_distirbuted_lists/knight/2"}
{"code": "for (int j = 0; j < (width * gray_channels); j += gray_channels)\n{\n  unsigned char *dir_sobel_pixel = (sobel_img + (i * width)) + j;\n  unsigned char *dir_gray_pixel = (gray_img + (i * width)) + j;\n  int sum = 0;\n  if ((((i == 0) || (i == ((height - 1) * gray_channels))) || (j == 0)) || (j == ((width - 1) * gray_channels)))\n  {\n    *dir_sobel_pixel = (uint8_t) sum;\n  }\n  else\n  {\n    for (int k = -1; k <= 1; ++k)\n    {\n      for (int l = -1; l <= 1; ++l)\n      {\n        unsigned char *dir_n_pixel = (dir_gray_pixel + (k * width)) + l;\n        sum += (*dir_n_pixel) * conv[k + 1][l + 1];\n      }\n\n    }\n\n    sum = (sum < 0) ? (0) : (sum);\n    *dir_sobel_pixel = (uint8_t) sum;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlejandroUN/ParallelComputing/omp/sobel/sobel_image_test_omp/1"}
{"code": "for (i = 1; i < world; i++)\n{\n  start += n_bytes / world;\n  end += n_bytes / world;\n  if ((end > n_bytes) || (i == (world - 1)))\n  {\n    end = n_bytes;\n  }\n\n  printf(\"[%d] will process bytes %d to %d\\n\", i, start, end);\n  diff = (end - start) + 1;\n  MPI_Send(&diff, 1, (MPI_Datatype) 1275069467, i, 0, (MPI_Comm) 0x44000000);\n  MPI_Isend(&buf[start], diff, (MPI_Datatype) 0x4c00010d, i, 0, (MPI_Comm) 0x44000000, &req[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmParallel/6"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < 16; j += i)\n  ;\n\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/32"}
{"code": "for (i = nxi - 1; i < nxt; i++)\n{\n  for (k = 0; k < ny; k++)\n  {\n    koff = nxhd * k;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = nxhd * k1;\n      v_t1 = _mm_loadl_pi(v_t1, (__m64 *) (&f[i + k1]));\n      v_t2 = _mm_loadl_pi(v_t2, (__m64 *) (&f[i + koff]));\n      _mm_storel_pi((__m64 *) (&f[i + k1]), v_t2);\n      _mm_storel_pi((__m64 *) (&f[i + koff]), v_t1);\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      nss = 2 * (ns / 2);\n      for (j = 0; j < nss; j += 2)\n      {\n        j1 = nxhd * (j + k1);\n        j2 = nxhd * (j + k2);\n        v_t1 = _mm_loadl_pi(v_t1, (__m64 *) (&sct[kmr * j]));\n        v_t1 = _mm_loadh_pi(v_t1, (__m64 *) (&sct[(kmr * j) + kmr]));\n        v_t2 = _mm_loadl_pi(v_t2, (__m64 *) (&f[i + j2]));\n        v_t2 = _mm_loadh_pi(v_t2, (__m64 *) (&f[(i + j2) + nxhd]));\n        v_t3 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 160));\n        v_t2 = _mm_shuffle_ps(v_t2, v_t2, 177);\n        v_t2 = _mm_mul_ps(v_t2, _mm_shuffle_ps(v_t1, v_t1, 245));\n        v_t2 = _mm_add_ps(v_t3, _mm_mul_ps(v_t2, v_m));\n        v_t3 = _mm_loadl_pi(v_t3, (__m64 *) (&f[i + j1]));\n        v_t3 = _mm_loadh_pi(v_t3, (__m64 *) (&f[(i + j1) + nxhd]));\n        v_t1 = _mm_sub_ps(v_t3, v_t2);\n        _mm_storel_pi((__m64 *) (&f[i + j2]), v_t1);\n        _mm_storeh_pi((__m64 *) (&f[(i + j2) + nxhd]), v_t1);\n        v_t1 = _mm_add_ps(v_t3, v_t2);\n        _mm_storel_pi((__m64 *) (&f[i + j1]), v_t1);\n        _mm_storeh_pi((__m64 *) (&f[(i + j1) + nxhd]), v_t1);\n      }\n\n      for (j = nss; j < ns; j++)\n      {\n        j1 = nxhd * (j + k1);\n        j2 = nxhd * (j + k2);\n        t1 = sct[kmr * j];\n        t2 = t1 * f[i + j2];\n        f[i + j2] = f[i + j1] - t2;\n        f[i + j1] += t2;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,nss,km,kmr,k1,k2,j1,j2,koff,t1,t2,v_t1,v_t2,v_t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/15"}
{"code": "for (i = 0; i < 800; i++)\n{\n  b[i] = (double *) malloc((sizeof(double)) * 800);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zambonin/parallel-kmeans/exercises/ine5410_e4-2/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  sleep(i);\n  printf(\"Thread=%d completed iteration with time %d seconds\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/exp3/schedule/0"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < height; j++)\n    printf(\"|%3d  \", grid[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luan-vilela/Parallel-Computing-Trabalho-1/rotpar/0"}
{"code": "for (int g = 0; g < egroups; g++)\n{\n  reuse[g] = (tau[g] * (tau[g] - 2.f)) + ((2.f * expVal[g]) / (sigT[g] * sigT2[g]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/5"}
{"code": "for (int row = 0; row < 4400; row++)\n{\n  if (col_neighbours[row][0] >= 0)\n  {\n    for (int x = 0; col_neighbours[row][x] > 0; x++)\n    {\n      for (int y = x + 1; col_neighbours[row][y] > 0; y++)\n      {\n        for (int z = y + 1; col_neighbours[row][z] > 0; z++)\n        {\n          long one_signature = getOneSignature(row, col_neighbours[row][x], col_neighbours[row][y], col_neighbours[row][z]);\n          setSignature(col, -1, one_signature, row, col_neighbours[row][x], col_neighbours[row][y], col_neighbours[row][z]);\n          index += 1;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JiyanBlack/MPI-HPC-Project2/Project2/7"}
{"code": "for (i = 0; i < (itersperthr * nthreads); i++)\n{\n  workloads[i] = delaylength;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/benchs/EPCC/schedbench/1"}
{"code": "for (i = 1; i <= N; i++)\n{\n  for (j = 1; j <= N; j += 2)\n  {\n    if ((i % 2) == 1)\n      x = ((i * M) + j) + 1;\n    else\n      x = (i * M) + j;\n\n    u[x] = 0.25 * ((((hsq + u[x - M]) + u[x - 1]) + u[x + 1]) + u[x + M]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(M,N,u,hsq) private(i,j,x) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/churia/HPC-OpenMP/gs2D-omp/3"}
{"code": "for (unsigned int id = 0; id < ITEMS; id += 4)\n{\n  B[id / 4] = horizontal_add(((A[id + 0] + A[id + 1]) + A[id + 2]) + A[id + 3]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hmazhar/ompeak/src/main/2"}
{"code": "for (int k = 0; k < current_item; k++)\n  if (strcmp(id, instance->item_name[k]) == 0)\n  errx(1, \"Nom d'objets dupliqu\u00e9 : %s\", id);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/12"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  float error = fabs((newX[i] - oldX[i]) / newX[i]);\n  flag += (int) (error > e);\n}\n\n", "pragma": "omp teams distribute parallel for reduction(+:flag)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aman-Chopra/CUDA-vs-OpenMP/Jacobi/jacobi_openmp/1"}
{"code": "for (i = 0; i < n; i++)\n  if (s_population.eachFitness[i] < s_population.eachFitness[worst])\n  worst = i;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PushenGao/Parallel-Computing-/GA_Queens_OpenMp/5"}
{"code": "for (vertex_id = 0; vertex_id < graphCSR->num_edges; vertex_id++)\n{\n  fwrite(&graphCSR->sorted_edges_array->edges_array_src[vertex_id], sizeof(graphCSR->sorted_edges_array->edges_array_src[vertex_id]), 1, pBinary);\n  fwrite(&graphCSR->sorted_edges_array->edges_array_dest[vertex_id], sizeof(graphCSR->sorted_edges_array->edges_array_dest[vertex_id]), 1, pBinary);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphCSR/2"}
{"code": "for (j = 0; j < (n / u_f2); j++)\n{\n  thread_counter[omp_get_thread_num()] += 1;\n  for (int x = j * u_f2; x < ((j + 1) * u_f2); x++)\n  {\n    __builtin_assume_aligned(mn, 64);\n    partialSumVector[omp_get_thread_num()] += mn[k][x];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpaltsai/OpenMP/project_3_omp_fg_vectorized/2"}
{"code": "for (i = 0; i < NoofCols; i = i + 1)\n  for (j = 0; j < NoofRows; j = j + 1)\n  if (Checkoutput[i][j] == Trans[i][j])\n  continue;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PavlyukVadim/software-engineering/Parallel/OpenMP/main/1"}
{"code": "for (n = i; n <= j; n++)\n  if (isprime(n))\n  s++;\n\n\n", "pragma": "            #pragma omp parallel for reduction(+:s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/an31146/source_code/prime_progs/omp_prime1/1"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  a[i] = rand() % 100;\n  b[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jessechoi/goulas-openmp-demos/for/for/1"}
{"code": "for (int i = 0; i < np; i++)\n  free(tset[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/9"}
{"code": "for (i = 0; i < nrows; i++)\n  for (j = 0; j < 2; j++)\n  if (count[i][j] > 0)\n{\n  cdata[i][j] = cdata[i][j] / count[i][j];\n  cmask[i][j] = 1;\n}\nelse\n  cmask[i][j] = 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/121"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  delta2[i] = ((OL2[i] - desired[i]) * OL2[i]) * (1 - OL2[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project4/NeuralNet-OpenMP/2"}
{"code": "for (i = 0; i < nz; ++i)\n{\n  j = I[i];\n  k = J[i];\n  A[j][k] = val[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/dense/6"}
{"code": "for (i = 0; i < nvars; i++)\n{\n  delta[i] *= rho;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iloudaros/Paralllelll/Code/1.OpenMP/multistart_hooke_omp/8"}
{"code": "for (i = 0; i < sz; i++)\n{\n  for (j = 0; j < sz; j++)\n  {\n    r[i][j] = p[i + r1][j + c1] - q[i + r2][j + c2];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LalitDhupar/Large-Matrix-Multiplication-Using-OpenMP/Large_Matrix_Multplication_OpenMP/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  printf(\"%f\\t\", vector[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/agarwal-ayushi/Parallel-Matrix-Vector-Multiplication/src/columnStripe_openmp/0"}
{"code": "for (i = 0; i < m_br; i++)\n  for (j = 0; j < m_br; j++)\n  phb[(i * m_br) + j] = (double) (i + 1);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/laureansvictor/FEUP-CPD-OpenMP/matrixproduct/1"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  double **sample_outputs = layer_outputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = sample_outputs[l - 1];\n    double *output = sample_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_fwd, 0);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU5/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  free(arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/4"}
{"code": "for (unsigned long long i = 0; i < nel; i++)\n{\n  file >> areas[i];\n  for (unsigned long long j = 0; j < NNB; j++)\n  {\n    file >> elements_surrounding_elements[i + (j * nelr)];\n    if (elements_surrounding_elements[i + (j * nelr)] < 0)\n      elements_surrounding_elements[i + (j * nelr)] = -1;\n\n    elements_surrounding_elements[i + (j * nelr)]--;\n    for (unsigned long long k = 0; k < NDIM; k++)\n    {\n      file >> normals[i + ((j + (k * NNB)) * nelr)];\n      normals[i + ((j + (k * NNB)) * nelr)] = -normals[i + ((j + (k * NNB)) * nelr)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/cfd/euler3d_gpu/1"}
{"code": "for (int tid = 0; tid < nthreads; tid++)\n{\n  for (int u = csrSplitter[tid]; u < csrSplitter[tid + 1]; u++)\n  {\n    float sum = 0;\n    int res = _mm512_setzero_ps();\n    int dif = RowPtr[u + 1] - RowPtr[u];\n    int nloop = dif / 16;\n    int remainder = dif % 16;\n    for (int li = 0; li < nloop; li++)\n    {\n      int j = RowPtr[u] + (li * 16);\n      int vecv = _mm512_loadu_ps(&Val[j]);\n      int veci = _mm512_loadu_si512(&ColIdx[j]);\n      int vecx = _mm512_i32gather_ps(veci, X, 4);\n      res = _mm512_fmadd_ps(vecv, vecx, res);\n    }\n\n    sum += _mm512_reduce_add_ps(res);\n    for (int j = RowPtr[u] + (nloop * 16); j < RowPtr[u + 1]; j++)\n    {\n      sum += Val[j] * X[ColIdx[j]];\n    }\n\n    Y[u] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiaosongAI/Parallel-SpMV/spmv_avx512/0"}
{"code": "for (i = 0; i < size; i++)\n  U.elements[i] = A.elements[i];\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) default(none) private(i) shared(U, size)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gregory-Matthews/Parallel-Computer-Programming/OpenMP-PThreads-Cholesky-Decomposition/chol/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%s\\n\", configdata[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NiramayVaidya/Linux_OpenMP_Benchmark_Results/code_and_results_files/32_bit/openmp/code/OpenMPMFLOPS/1"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->vector_output[v] = Fixed64ToDouble(vector_output[v]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/7"}
{"code": "for (int i = 0; i < height_local; i++)\n{\n  for (int j = 0; j < width_local; j++)\n  {\n    local[i + 1][j + 1] = local_input[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/v-pap/Game-of-Life-in-parallel-MPI-OpenMP-CUDA/src/game_openmp/6"}
{"code": "for (int i = 0; i < ARR_SIZE; i++)\n  dest_array[i] += src_array[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NaorFahima/Parallel-And-Distributed-Computing/Exercise 3/histogram/4"}
{"code": "for (int j = 0; j < k; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    if (kc[i] == j)\n    {\n      clust_size[j] += 1;\n      xc[j][clust_size[j] - 1] = x[i];\n      yc[j][clust_size[j] - 1] = y[i];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/pc/1"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (videoseuil[i][j][k] != videoseuilOld[j][k])\n        videoDiff[i][j][k] = 1;\n      else\n        videoDiff[i][j][k] = 0;\n\n      videoseuilOld[j][k] = videoseuil[i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/6"}
{"code": "for (i = 0; i < ((*tam) - 1); i++)\n  for (j = 0; j < (((*tam) - i) - 1); j++)\n  if (vet[j] > vet[j + 1])\n  swap(&vet[j], &vet[j + 1]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/12"}
{"code": "for (int jj = internal_ystart; jj <= (internal_ystop - 1); jj++)\n{\n  for (int ji = internal_xstart; ji <= internal_xstop; ji++)\n  {\n    momentum_v_code(ji, jj, width, va, un, vn, hu, hv, ht, ssha_v, sshn_t, sshn_u, sshn_v, tmask, dx_v, dx_t, dy_u, dy_v, dy_t, area_v, gphiv, rdt, cbfr, visc, omega, d2r, g);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/2"}
{"code": "for (int i = 0; i < (n * n); ++i)\n{\n  distance[i] = (i % (n + 1)) ? (NOT_CONNECTED) : (0);\n}\n\n", "pragma": "    #pragma omp parallel for shared(distance, n) default(none)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ajmorton/prog_parallelisation/graph_diameter_omp/code/diameter/1"}
{"code": "for (i = start; i < end; i++)\n  Y[i] += a * X[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/interop/examples/axpy_omp/7"}
{"code": "for (int ip = 0; ip < NumThreads; ++ip)\n{\n  wClones[ip]->clearEnsemble();\n  wClones[ip]->setNumSamples(samples_th);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/Experimental/WFMC/WFMCSingleOMP/1"}
{"code": "for (i = 0; i < ((250 * 1024) / 256); i++)\n{\n  printf(\"%g\", C[i * ((250 * 1024) / 256)]);\n  for (k = 1; k < ((250 * 1024) / 256); k++)\n  {\n    printf(\" %g\", C[(i * ((250 * 1024) / 256)) + k]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 1/matmul/7"}
{"code": "for (i = 0; i < nfields; i++)\n{\n  for (j = 0; j < nsites; j++)\n  {\n    if (siteMask[j])\n      targetData[(i * nsites) + j] = data[(i * nsites) + j];\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/Ludwig/targetDP/targetDP_C/3"}
{"code": "for (i = 0; i < ((int) nParticles); i++)\n  if (pBestFitness[i] < gBestFitness)\n{\n  gBestFitness = pBestFitness[i];\n}\n\n\n", "pragma": "omp for reduction(min:gBestFitness)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhi4578/Parallelization-of-PSO/omp_parallel/0"}
{"code": "for (int f = 0; f < m; ++f)\n{\n  int c = C(f);\n  if (use_parity)\n  {\n    I(f) = (C_vote_parity[c].first > C_vote_parity[c].second) ? (1) : (0);\n  }\n  else\n  {\n    I(f) = (((C_vote_infinity[c].first == C_vote_infinity[c].second) && (C_vote_distance[c].first < C_vote_distance[c].second)) || (C_vote_infinity[c].first < C_vote_infinity[c].second)) ? (1) : (0);\n  }\n\n  if (F.row(f) != FF.row(f))\n    I(f) = 1 - I(f);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC203-Computacion_Grafica/Trabajo_2_Fast-Winding-Numbers/fast-winding-number-soups/libigl/include/igl/embree/reorient_facets_raycast/2"}
{"code": "for (int i = 0; i <= n; i++)\n{\n  (unique_lock < mutex) > monitor(m_mutex);\n  while (m_writeLocked)\n  {\n    m_writingAllowed.wait(monitor);\n  }\n\n  m_writeLocked = true;\n  sum += i;\n  m_writeLocked = false;\n}\n\n", "pragma": "\t#pragma omp parallel for default(none) shared(sum, m_writeLocked, m_mutex, m_writingAllowed)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kw90/OpenMP/summation/2"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  if (m_dayOfYear == 1)\n  {\n    m_phuBase[i] = 0.f;\n  }\n\n  if ((m_meanTemp[i] > 0.f) && (m_phuAnn[i] > 0.01f))\n  {\n    m_phuBase[i] += m_meanTemp[i] / m_phuAnn[i];\n  }\n\n  float srMax;\n  MaxSolarRadiation(m_dayOfYear, m_cellLat[i], m_dayLen[i], srMax);\n  float latentHeat = 2.501f - (0.002361f * m_meanTemp[i]);\n  float h0 = srMax * 1.253f;\n  float petValue = (((m_HCoef_pet * h0) * pow(Abs(m_maxTemp[i] - m_minTemp[i]), 0.5f)) * (m_meanTemp[i] + 17.8f)) / latentHeat;\n  m_pet[i] = m_petFactor * Max(0.0f, petValue);\n  float satVaporPressure = SaturationVaporPressure(m_meanTemp[i]);\n  float actualVaporPressure = 0.f;\n  if (m_rhd[i] > 1)\n  {\n    actualVaporPressure = (m_rhd[i] * satVaporPressure) * 0.01f;\n  }\n  else\n  {\n    actualVaporPressure = m_rhd[i] * satVaporPressure;\n  }\n\n  m_vpd[i] = satVaporPressure - actualVaporPressure;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/PET_H/PETHargreaves/0"}
{"code": "for (i = 0; i < TABLESIZE; i++)\n  hashtable[i] = EMPTY_POINT;\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bumbleblo/ppd-openmp/vow_with_hash/2"}
{"code": "for (int i = 0; i < dim; i++)\n  ps[i] = (int *) malloc(dim * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/real_codes/max/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  v = v + z.arr[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector1/1"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  for (j = 1; j <= ny2; j++)\n  {\n    for (i = 1; i <= nx2; i++)\n    {\n      r1 = rhs[k][j][i][0];\n      r2 = rhs[k][j][i][1];\n      r3 = rhs[k][j][i][2];\n      r4 = rhs[k][j][i][3];\n      r5 = rhs[k][j][i][4];\n      t1 = bt * r3;\n      t2 = 0.5 * (r4 + r5);\n      rhs[k][j][i][0] = -r2;\n      rhs[k][j][i][1] = r1;\n      rhs[k][j][i][2] = bt * (r4 - r5);\n      rhs[k][j][i][3] = (-t1) + t2;\n      rhs[k][j][i][4] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/SP/sp/18"}
{"code": "for (i = 0; i < (1000 * 1000); i++)\n{\n  Host_Graph1[i] = Graph[i];\n  Host_Path1[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VishalVishnani/CUDA-pthread-openMP-implementation-of-Graph-Algorithms/Floyd_Warshall/2"}
{"code": "for (c1 = 0; c1 <= (((((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) < (nm + (-1))) ? (((((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) < (nk + (-1))) ? (((ni + (-1)) < (nj + (-1))) ? (ni + (-1)) : (nj + (-1))) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nl + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nl + (-1))) < (nm + (-1))) ? (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nl + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nl + (-1))) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = nm; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nl + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nl > nm) ? (nl) : (nm); c2 <= (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (((((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))) < (nm + (-1))) ? (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nj > nl) ? (nj) : (nl); c2 <= (((nk + (-1)) < (nm + (-1))) ? (nk + (-1)) : (nm + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nj > nm) ? (nj) : (nm); c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (((nj > nl) ? (nj) : (nl)) > nm) ? ((nj > nl) ? (nj) : (nl)) : (nm); c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (((((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))) < (nm + (-1))) ? (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nk > nl) ? (nk) : (nl); c2 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (nk > nm) ? (nk) : (nm); c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (((nk > nl) ? (nk) : (nl)) > nm) ? ((nk > nl) ? (nk) : (nl)) : (nm); c2 <= (nj + (-1)); c2++)\n  {\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = (nj > nk) ? (nj) : (nk); c2 <= (((nl + (-1)) < (nm + (-1))) ? (nl + (-1)) : (nm + (-1))); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (((nj > nk) ? (nj) : (nk)) > nl) ? ((nj > nk) ? (nj) : (nk)) : (nl); c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n  for (c2 = (((nj > nk) ? (nj) : (nk)) > nm) ? ((nj > nk) ? (nj) : (nk)) : (nm); c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/0"}
{"code": "for (i = 0; i < M; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    sum = 0.;\n    for (k = 0; k < K; k++)\n      sum += A[(i * K) + k] * B[(j * K) + k];\n\n    D[(i * N) + j] = sum + C[(i * N) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A, B, C, D) private(i, j, k, sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philorfa/Parallel-OpenMP-CUDA-FPGAs/CPU-GPU/linalg/2"}
{"code": "for (int i = 0; i < size_matrix; i++)\n{\n  int adder = 0;\n  for (int j = 0; j < size_matrix; j++)\n  {\n    adder += matrix_A[i][j] * matrix_B[j][a];\n  }\n\n  matrix_Out[i][a] = adder;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Malinowsk/Course-Work-Parallel-Distributed-Computing/Program/matrix/6"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/12"}
{"code": "for (int row = 0; row < rows; row++)\n{\n  for (int col = 0; col < columns; col++)\n  {\n    double value = (dataset->at(row)->getFeatures()->at(col) - mean[col]) / std[col];\n    dataset->at(row)->getFeatures()->at(col) = value;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(mean, std, columns, dataset)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-Hybrid-OpenMP-MPI/OpenMP/StandardScaler/1"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/88"}
{"code": "for (i = 0; i < 4000; i++)\n{\n  for (j = 0; j < 4000; j++)\n  {\n    fscanf(fptr1, \"%lld\", &b[i][j]);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 5 & 6/matmulpar/1"}
{"code": "for (k = klo; k < khi; k++)\n{\n  for (j = jlo; j < jhi; j++)\n  {\n    for (i = ilo; i < ihi; i++)\n    {\n      int ijk = (i + (j * jStride)) + (k * kStride);\n      double Ax_n = apply_op_ijk(x_n);\n      x_np1[ijk] = x_n[ijk] + ((weight * lambda[ijk]) * (rhs[ijk] - Ax_n));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(3) if(num_my_blocks >= GPU_THRESHOLD && GPU_OFFLOAD_ENABLE && GPU_ENABLE_SMOOTHER)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/jacobi/0"}
{"code": "for (long i = 0; i < length; i++)\n{\n  data[i] = 0;\n}\n\n", "pragma": "omp for schedule (guided , 4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ToniCifre/Parallelism/divide and conquer - sorting/multisort-omp-task-rama-cutoff-opt2/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum += A[i];\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMParrayAvg/0"}
{"code": "for (int I = 0; I < ArgNum; ++I)\n{\n  Ptrs[I] = (void *) (((intptr_t) TgtArgs[I]) + TgtOffsets[I]);\n  Args[I] = &Ptrs[I];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/openmp/libomptarget/plugins/cuda/src/rtl/1"}
{"code": "for (index = 0; index < count; index++)\n{\n  MD5_CTX ctx;\n  unsigned char *out = (unsigned char *) crypt_out[index];\n  unsigned char hash[16];\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, saved_key[index], saved_len[index]);\n  MD5_Final(hash, &ctx);\n  compressor(hash, out);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dahua_fmt_plug/0"}
{"code": "for (iter = 0; iter < row_size; iter++)\n{\n  int j = iter;\n  int k;\n  int l;\n  int ii;\n  int jj;\n  int pos_B;\n  int pos_C;\n  int pos = (i * max_dim) + j;\n  int nnz = CountX[pos + 1] - CountX[pos];\n  pos = CountX[pos];\n  for (k = 0; k < nnz; k++)\n  {\n    int current_input_entry = WhereX[pos + k];\n    int pre_val = current_input_entry * rank;\n    int now = 0;\n    double Entry_val = X.value[current_input_entry];\n    pos_B = (j * rank) * rank, pos_C = j * rank;\n    for (ii = 0; ii < rank; ii++)\n    {\n      double cach = Delta[pre_val + ii];\n      for (jj = 0; jj < rank; jj++)\n      {\n        B[pos_B++] += cach * Delta[pre_val + jj];\n      }\n\n      C[pos_C++] += cach * Entry_val;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/20"}
{"code": "for (unsigned int block = 0; block < total_blocks; block++)\n{\n  block_dim[block] = (block < (total_blocks - 1)) ? (MIN_BLOCK_SIZE) : (nz % MIN_BLOCK_SIZE);\n  if (block_dim[block] == 0)\n  {\n    block_dim[block] = MIN_BLOCK_SIZE;\n  }\n\n  if (((nx > 1) && (ny > 1)) && (nz > 1))\n  {\n    field[block] = zfp_field_3d(&array[((block * MIN_BLOCK_SIZE) * ny) * nx], type, nx, ny, block_dim[block]);\n  }\n  else\n  {\n    field[block] = zfp_field_2d(&array[(block * MIN_BLOCK_SIZE) * nx], type, nx, block_dim[block]);\n  }\n\n  zfp[block] = zfp_stream_open(nullptr);\n  if (zfp_is_relative)\n  {\n    zfp_stream_set_precision(zfp[block], tolerance);\n  }\n  else\n  {\n    zfp_stream_set_accuracy(zfp[block], tolerance);\n  }\n\n  buffer_size[block] = zfp_stream_maximum_size(zfp[block], field[block]);\n  buffer[block] = malloc(buffer_size[block]);\n  stream[block] = stream_open(buffer[block], buffer_size[block]);\n  zfp_stream_set_bit_stream(zfp[block], stream[block]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/utils/compressor/Compressor/0"}
{"code": "for (int i = 0; i < num_threads; ++i)\n{\n  int tmp[N];\n  for (int j = 0; j < N; ++j)\n  {\n    tmp[j] = i;\n  }\n\n  for (int j = 0; j < N; ++j)\n  {\n    tmp[j] += j;\n  }\n\n  for (int j = 0; j < N; ++j)\n  {\n    array[i] += tmp[j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/openmp/libomptarget/test/offloading/parallel_offloading_map/0"}
{"code": "for (i = 0; i < cur_salt->ctlen; i += 8)\n{\n  BF_ecb_encrypt(buffer + i, buffer + i, &bf_key, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/kwallet_fmt_plug/4"}
{"code": "for (int i = 0; i < cnt; ++i)\n{\n  m_reset2();\n  timespec_get(&sts, TIME_UTC);\n  ori();\n  timespec_get(&ets, TIME_UTC);\n  dsec = ets.tv_sec - sts.tv_sec;\n  dnsec = ets.tv_nsec - sts.tv_nsec;\n  if (dnsec_record < 0)\n  {\n    dnsec_record--;\n    dnsec_record += 1000000000ll;\n  }\n\n  dsec_record += (float) dsec;\n  dnsec_record += (float) dnsec;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp/8"}
{"code": "for (i1 = 0; i1 < 1000; i1++)\n{\n  double length = sqrt((pow((spheres + s)->cord.l - (spheres + i1)->cord.l, 2) + pow((spheres + s)->cord.w - (spheres + i1)->cord.w, 2)) + pow((spheres + s)->cord.d - (spheres + i1)->cord.d, 2));\n  if (length != 0)\n  {\n    F = force(s, i1);\n    Fl += (F * ((spheres + s)->cord.l - (spheres + i1)->cord.l)) / length;\n    Fw += (F * ((spheres + s)->cord.w - (spheres + i1)->cord.w)) / length;\n    Fd += (F * ((spheres + s)->cord.d - (spheres + i1)->cord.d)) / length;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(F) reduction(+: Fl, Fw, Fd)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shwetha-krishnamurthy/OpenMP/Assignment 3/many_body_problem/0"}
{"code": "for (int id = max_nb_pass; id < high_freq_pass.size; id++)\n  MPI_Send(high_freq_pass.pass[id], strlen(high_freq_pass.pass[id]) + 1, (MPI_Datatype) 0x4c00010d, id + 1, 0, (MPI_Comm) 0x44000000);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RadhJL/Parallel-password-cracking/src/main/7"}
{"code": "for (int row = 0; row < boundary_length; row++)\n{\n  for (int column = start_x; column < end_x; column++)\n  {\n    property_array[((start_z + row) * nx) + column] = 0;\n    property_array[(((end_z - 1) - row) * nx) + column] = deviceMinValue[0];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/components/concrete/omp-offload/boundary-managers/extensions/MinExtension/2"}
{"code": "for (j = 2; j < i; j++)\n{\n  if ((i % j) == 0)\n  {\n    prime = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/5"}
{"code": "for (int i = 0; i < m; i++)\n{\n  cout << \"[\\t \";\n  for (int j = 0; j < n; j++)\n  {\n    (cout << A[i][j]) << \"\\t\";\n  }\n\n  cout << \" ]\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejovanihh191197/MetodoGaussOpenMP/gauss/1"}
{"code": "for (j = 1; j <= npoints; j++)\n{\n  if ((((first + j) - 1) == 1) || (((first + j) - 1) == 500))\n    newval[j] = 0.0;\n  else\n    newval[j] = ((2.0 * values[j]) - oldval[j]) + (sqtau * ((values[j - 1] - (2.0 * values[j])) + values[j + 1]));\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lk-2020/CFiles/concurrent_wave_printOutput/0"}
{"code": "for (i = (size / 2) - 1; i >= 0; i--)\n{\n  heapify(part, size, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keyzj-archive/dev_sort/HeapSort/src/main/main_packed/2"}
{"code": "for (k = 0; k < n; k++)\n  if (k != j)\n  sum += a[j][k] * x[k];\n\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nithinmanne/openmp/midsem/midsem/3"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  km1 = k - 1;\n  kp1 = k + 1;\n  forcing[0][i][j][k] = (forcing[0][i][j][k] - (tz2 * (ue[3][kp1] - ue[3][km1]))) + (dz1tz1 * ((ue[0][kp1] - (2.0 * ue[0][k])) + ue[0][km1]));\n  forcing[1][i][j][k] = ((forcing[1][i][j][k] - (tz2 * ((ue[1][kp1] * buf[3][kp1]) - (ue[1][km1] * buf[3][km1])))) + (zzcon2 * ((buf[1][kp1] - (2.0 * buf[1][k])) + buf[1][km1]))) + (dz2tz1 * ((ue[1][kp1] - (2.0 * ue[1][k])) + ue[1][km1]));\n  forcing[2][i][j][k] = ((forcing[2][i][j][k] - (tz2 * ((ue[2][kp1] * buf[3][kp1]) - (ue[2][km1] * buf[3][km1])))) + (zzcon2 * ((buf[2][kp1] - (2.0 * buf[2][k])) + buf[2][km1]))) + (dz3tz1 * ((ue[2][kp1] - (2.0 * ue[2][k])) + ue[2][km1]));\n  forcing[3][i][j][k] = ((forcing[3][i][j][k] - (tz2 * (((ue[3][kp1] * buf[3][kp1]) + (c2 * (ue[4][kp1] - q[kp1]))) - ((ue[3][km1] * buf[3][km1]) + (c2 * (ue[4][km1] - q[km1])))))) + (zzcon1 * ((buf[3][kp1] - (2.0 * buf[3][k])) + buf[3][km1]))) + (dz4tz1 * ((ue[3][kp1] - (2.0 * ue[3][k])) + ue[3][km1]));\n  forcing[4][i][j][k] = ((((forcing[4][i][j][k] - (tz2 * ((buf[3][kp1] * ((c1 * ue[4][kp1]) - (c2 * q[kp1]))) - (buf[3][km1] * ((c1 * ue[4][km1]) - (c2 * q[km1])))))) + ((0.5 * zzcon3) * ((buf[0][kp1] - (2.0 * buf[0][k])) + buf[0][km1]))) + (zzcon4 * ((cuf[kp1] - (2.0 * cuf[k])) + cuf[km1]))) + (zzcon5 * ((buf[4][kp1] - (2.0 * buf[4][k])) + buf[4][km1]))) + (dz5tz1 * ((ue[4][kp1] - (2.0 * ue[4][k])) + ue[4][km1]));\n}\n\n", "pragma": "omp parallel for firstprivate(dz1tz1 ,tz2 ,dz2tz1 ,zzcon2 ,dz3tz1 ,dz4tz1 ,zzcon1 ,c2 ,dz5tz1 ,zzcon5 ,zzcon4 ,zzcon3 ,c1 ,k ,i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/31"}
{"code": "for (int i = 0; i < size; i++)\n  mat[i] = (float *) malloc((sizeof(mat[i])) * size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlirezaAK2000/Multicore-Programming/HW4/det/2"}
{"code": "for (int i = 0; i < nodes; i++)\n{\n  x_new[i] = (((1 - d) + (d * W_sum)) * one_over_N) + spmm_result[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/read_graph_from_file/5"}
{"code": "for (i = 1; i <= nseqs; i++)\n  bots_debug(\"Sequence %d: %s %6.d aa\\n\", i, names[i], seqlen_array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/21"}
{"code": "for (int i = 0; i < M; i++)\n{\n  int u;\n  int v;\n  (cin >> u) >> v;\n  if (u != v)\n  {\n    adj[u].push_back(v);\n    rev[v].push_back(u);\n    outdeg[u]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/14"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpointserial(c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/mandelserial/0"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  if (last == (-1))\n    last = u_data->fragment_id;\n  else\n    if (u_data->fragment_id != last)\n  {\n    multiple = 1;\n    break;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/8"}
{"code": "for (i = 0; i < topoinfo->numG; i++)\n{\n  fprintf(f_paras, \"Prod_of_%s\\t%f\\t%f\\t%d\\n\", topoinfo->Gname[i], minP * amplifyfold[i], maxP * amplifyfold[i], 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/25"}
{"code": "for (int i = 0; i < (h + 2); i++)\n{\n  for (int j = 0; j < (w + 2); j++)\n  {\n    if ((((i == 0) || (j == 0)) || (i == (h + 1))) || (j == (w + 1)))\n    {\n      arr1[i][j] = 0;\n      arr2[i][j] = 0;\n    }\n    else\n    {\n      arr1[i][j] = rand() % 2;\n      arr2[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/malfusion/hpc-game-of-life/gameoflife-opengl/0"}
{"code": "for (i = 0; i < n; i++)\n  if (mat[i] == 0)\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/23"}
{"code": "for (int RowIdx = 0; RowIdx < Rows; RowIdx++)\n{\n  Mat->At(RowIdx, ColIdx) = ColV[RowIdx];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/114"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  for (long long j = 0; j < n; j++)\n  {\n    c[i] += a[i][j] * b[j];\n  }\n\n  sume += c[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/matrix product & sum/0"}
{"code": "for (int i = 0; i < time_steps; i++)\n{\n  time_step();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunozampirom/Barnes-Hut/barnes_hut/8"}
{"code": "for (x = 0; x < (*dimX); x++)\n{\n  for (y = 0; y < (*dimY); y++)\n  {\n    for (z = 0; z < (*dimZ); z++)\n    {\n      array3D[(((x * (*dimY)) * (*dimZ)) + (y * (*dimZ))) + z] = array3D[(((x * (*dimY)) * (*dimZ)) + (y * (*dimZ))) + z] + ((unsigned char) (5 * randn(seed, 0)));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/1"}
{"code": "for (i = 0; i < 16; ++i)\n  printf(\"all for - thread = %d, i = %d\\n\", tid, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/examples/src/openmp_tutorial/1"}
{"code": "for (int i = 0; i < NUM_OF_THREADS; i++)\n  thread_min_val[i][0] = min;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalgoyall/ParallelMatrixMult/OMP-CO-ISPC/main/0"}
{"code": "for (i = 0; i < n; i++)\n  globalpear += (a[i] - meana) * (b[i] - meanb);\n\n", "pragma": "omp parallel for default(shared)private(i,meana,meanb,deta,detb)schedule(static,chunk)reduction(+:globalpear)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Liangyuefeng/Multi_core-computing/OpenMP/OpenMp_codes/3"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  for (d = 0; d < NDIM; d++)\n  {\n    veltmp = cell(ci).cvel(d);\n    aold = cell(ci).vacc(0, d);\n    ftmp = cell(ci).cforce(d) / cell(ci).getNV();\n    dampNum = b * (veltmp - ((0.5 * aold) * dt));\n    dampDenom = 1.0 + ((0.5 * b) * dt);\n    dampUpdate = (ftmp - dampNum) / dampDenom;\n    anew = dampUpdate;\n    veltmp += (0.5 * dt) * (anew + aold);\n    cell(ci).setCVel(d, veltmp);\n    for (vi = 0; vi < cell(ci).getNV(); vi++)\n      cell(ci).setVAcc(vi, d, anew);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/118"}
{"code": "for (int ip = 0; ip < NumThreads; ip++)\n  *Children[ip] = *Rng[ip];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/DMC/DMCOMP/4"}
{"code": "for (int i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) * step;\n  sum += 4. / (1. + (x * x));\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum) private(x)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lumeng16/OpenMPstudy/Basic/exercise1/0"}
{"code": "for (int i = 0; i < (SIZE / 4); i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    C1[(i * SIZE) + j] *= 2123.0f;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      C1[(i * SIZE) + j] += (32412.0f * A1[(i * SIZE) + k]) * B[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/pipelineTesting/GEMM_M/gemmPL/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*class) == 'U')\n  {\n    double _imopVarPre2200;\n    _imopVarPre2200 = xcr[m];\n    printf(\"          %2d%20.13e\\n\", m, _imopVarPre2200);\n  }\n  else\n  {\n    if (xcrdif[m] > epsilon)\n    {\n      *verified = 0;\n      double _imopVarPre2204;\n      double _imopVarPre2205;\n      double _imopVarPre2206;\n      _imopVarPre2204 = xcrdif[m];\n      _imopVarPre2205 = xcrref[m];\n      _imopVarPre2206 = xcr[m];\n      printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, _imopVarPre2206, _imopVarPre2205, _imopVarPre2204);\n    }\n    else\n    {\n      double _imopVarPre2210;\n      double _imopVarPre2211;\n      double _imopVarPre2212;\n      _imopVarPre2210 = xcrdif[m];\n      _imopVarPre2211 = xcrref[m];\n      _imopVarPre2212 = xcr[m];\n      printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, _imopVarPre2212, _imopVarPre2211, _imopVarPre2210);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/SP/sp-wrongSVE/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  r = B[i][k];\n  for (j = 0; j < n; j++)\n  {\n    A[i][j] += r * C[k][j];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kothiga/Matrix-Matrix-Parallel/MatMultOpenMP/1"}
{"code": "for (k = 0; k < np; k++)\n{\n  for (j = 0; j < np; j++)\n  {\n    d[j] = pt_dist(nd, nppadded, pos, k, j, rij);\n    d2[j] = min(d, j, PI2);\n    pe += 0.5 * pow(sin(d2[j]), 2);\n  }\n\n  for (i = 0; i < nd; i++)\n  {\n    f[(i * nppadded) + k] = 0.0;\n    ke += vel[(i * nppadded) + k] * vel[(i * nppadded) + k];\n  }\n\n  for (i = 0; i < nd; i++)\n  {\n    for (j = 0; j < np; j++)\n    {\n      f[(i * nppadded) + k] -= f_calc(nppadded, rij, d, d2, i, j, k);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction ( + : pe, ke )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MD/md_openmp/0"}
{"code": "for (unsigned long long j = 1; j < input_time; j++)\n{\n  for (i = 0; i < numRecords; i++)\n  {\n    locations.push_back(locations[i]);\n    records.push_back(records[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/nn/nn_omp/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    G[(i * SIZE) + j] = 0;\n    for (int k = 0; k < SIZE; ++k)\n    {\n      G[(i * SIZE) + j] += E[(i * SIZE) + k] * F[(k * SIZE) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/3MM/3mm/2"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  tmp = a[i] + i;\n}\n\n", "pragma": "omp parallel for private (tmp,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_scalar_output/0"}
{"code": "for (i = 3; (i * i) <= n; i += 2)\n{\n  if (pEratos[i / 2])\n  {\n    for (int j = i * i; j <= n; j += 2 * i)\n    {\n      pEratos[j / 2] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/heiung2001/Parallel-Computing-With-OpenMP-And-Alchemi/OpenMP/Prime Numbers/Parallelization/main/0"}
{"code": "for (int s = 0; s < sz; s++)\n  klabels[s] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/12"}
{"code": "for (int aux = 0; aux < 10; aux++)\n  if (result[aux] > 0)\n  fprintf(fout, \"%s\\n%d\\n\", desc_dna[aux], result[aux]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/infernanda/ProgramacaoParalelaBMHS/dna_openmp/5"}
{"code": "for (i = 1; i <= rows; i++)\n{\n  for (j = 1; j <= columns; j++)\n  {\n    b_matrix_curr_iter[i][j] = b_matrix_next_iter[i][j];\n  }\n\n}\n\n", "pragma": "                #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JohnBogdan1/Distributed-Programming/Game of Life/g_omp/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < x_y_place; j++)\n  {\n    arr[i][j] = rand() % 1001;\n  }\n\n  printf(\"Location of Node %d is x=%d and y=%d\\n\", i, arr[i][0], arr[i][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab7-Clustering/clusters/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = 0;\n  b[i] = (((float) rand()) / ((float) 32767)) * 4.0;\n  c[i] = (((float) rand()) / ((float) 32767)) * 4.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amamory-ampere/openmp-offloading/openmp_gpu/omp-ser/1"}
{"code": "for (i = 0; i < (NA + 1); i++)\n{\n  x[i] = 1.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/1"}
{"code": "for (int i = 0; i < subproblems_[subproblem_index].num_vars_; ++i)\n{\n  if (subproblems_[subproblem_index].constraints_[i].is_active_)\n  {\n    long double slack = subproblems_[subproblem_index].constraints_[i].price_ - ((u * subproblems_[subproblem_index].constraints_[i].coefficient_) + v);\n    if (slack < 0)\n    {\n      slack = (-1) * slack;\n    }\n\n    if (slack < numerical_accuracy_tolerance_)\n    {\n      tight_constraint_indices.push_back(i);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dragosciocan/OpenMPSolver/LPsolver/LPsolver/global_problem/5"}
{"code": "for (j = 0; j < 500; j++)\n{\n  for (k = 0; k < 500; k++)\n    for (i = 0; i < 500; i++)\n    c4[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Assignments/2/LA2/11"}
{"code": "for (i = 0; i <= ((N * M) / P); i++)\n{\n  a[i] = buf[pos] - '0';\n  pos += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/11"}
{"code": "for (size_t i = 0; i < array.size(); i++)\n{\n  (cout << array[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yinglyu/openmp-gaussian-process-regression/gpr/5"}
{"code": "for (int i = 0; i < An; i++)\n{\n  int nnzpv = nnzcum;\n  Crow[i] = nnzcum;\n  if ((nnzcum + An) > (*Csize))\n  {\n    *Csize += (An > ((*Csize) / 4)) ? (An) : ((*Csize) / 4);\n    *Ccol = realloc(*Ccol, (*Csize) * (sizeof(int)));\n  }\n\n  for (int jj = Arow[i]; jj < Arow[i + 1]; jj++)\n  {\n    int j = Acol[jj];\n    for (int kp = Brow[j]; kp < Brow[j + 1]; kp++)\n    {\n      int k = Bcol[kp];\n      if (!xb[k])\n      {\n        xb[k] = 1;\n        (*Ccol)[nnzcum] = k;\n        nnzcum++;\n      }\n\n    }\n\n  }\n\n  if (nnzcum > nnzpv)\n  {\n    quickSort(*Ccol, nnzpv, nnzcum - 1);\n    for (int p = nnzpv; p < nnzcum; p++)\n    {\n      xb[(*Ccol)[p]] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pavlidic/Binary-SpGEMM/old/SpGEMM_mpi_omp/1"}
{"code": "for (i = t; i >= 0; i--)\n  fprintf(out, \"%d\", ans[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/10"}
{"code": "for (int i = start_index; i < max_index; i++)\n{\n  const int key = my_bucket_keys[i];\n  if ((key < my_min_key) || (key > my_max_key))\n  {\n    printf(\"Rank %d Failed Verification!\\n\", shmem_my_pe());\n    printf(\"Key: %d is outside of bounds [%d, %d]\\n\", key, my_min_key, my_max_key);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/15"}
{"code": "for (unsigned int var = 0; var < QwD.size(); var++)\n{\n  if (var == procID)\n  {\n    for (unsigned int var3 = 0; var3 < pt.size(); var3++)\n    {\n      int exist = false;\n      for (unsigned int var2 = 0; var2 < QwD[var].size(); var2++)\n      {\n        if (pt[var3] == QwD[var].at(var2).getTId())\n        {\n          exist = true;\n          break;\n        }\n\n      }\n\n      if (!exist)\n      {\n        QwD[var].push_back(taskList[pt[var3]]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/2"}
{"code": "for (k = 0; k < d3; k++)\n{\n  for (j = 0; j < d2; j++)\n  {\n    for (i = 0; i < d1; i++)\n    {\n      u0[k][j][i] = dcomplex_create(0.0, 0.0);\n      u1[k][j][i] = dcomplex_create(0.0, 0.0);\n      twiddle[k][j][i] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/11"}
{"code": "for (unsigned int i_node = 0; i_node < pts_number; ++i_node)\n{\n  if (rNodalDistances[i_node] > 0.0)\n    n_pos++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/FluidDynamicsApplication/custom_processes/embedded_skin_visualization_process/0"}
{"code": "for (int i = 0; i < result1.size(); i++)\n  (cout << result1[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task5/0"}
{"code": "for (; itBgn != itEnd; ++itBgn)\n  if (m_db->vPatternBbox[*itBgn]->color() < 0)\n  return true;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/29"}
{"code": "for (si = 0; si < nseqs; si++)\n{\n  n = seqlen_array[si + 1];\n  for (i = 1, len1 = 0; i <= n; i++)\n  {\n    char c = seq_array[si + 1][i];\n    if ((c != gap_pos1) && (c != gap_pos2))\n      len1++;\n\n  }\n\n  for (sj = si + 1; sj < nseqs; sj++)\n  {\n    m = seqlen_array[sj + 1];\n    if ((n == 0) || (m == 0))\n    {\n      bench_output[(si * nseqs) + sj] = (int) 1.0;\n    }\n    else\n    {\n      {\n        int se1;\n        int se2;\n        int sb1;\n        int sb2;\n        int maxscore;\n        int seq1;\n        int seq2;\n        int g;\n        int gh;\n        int displ[(2 * 5000) + 1];\n        int print_ptr;\n        int last_print;\n        for (i = 1, len2 = 0; i <= m; i++)\n        {\n          char c = seq_array[sj + 1][i];\n          if ((c != gap_pos1) && (c != gap_pos2))\n            len2++;\n\n        }\n\n        if (dnaFlag == TRUE)\n        {\n          g = (int) (((2 * 100) * pw_go_penalty) * gap_open_scale);\n          gh = (int) ((100 * pw_ge_penalty) * gap_extend_scale);\n        }\n        else\n        {\n          gg = pw_go_penalty + log((double) ((n < m) ? (n) : (m)));\n          g = (int) ((mat_avscore <= 0) ? ((2 * 100) * gg) : (((2 * mat_avscore) * gg) * gap_open_scale));\n          gh = (int) (100 * pw_ge_penalty);\n        }\n\n        seq1 = si + 1;\n        seq2 = sj + 1;\n        forward_pass(&seq_array[seq1][0], &seq_array[seq2][0], n, m, &se1, &se2, &maxscore, g, gh);\n        reverse_pass(&seq_array[seq1][0], &seq_array[seq2][0], se1, se2, &sb1, &sb2, maxscore, g, gh);\n        print_ptr = 1;\n        last_print = 0;\n        diff(sb1 - 1, sb2 - 1, (se1 - sb1) + 1, (se2 - sb2) + 1, 0, 0, &print_ptr, &last_print, displ, seq1, seq2, g, gh);\n        mm_score = tracepath(sb1, sb2, &print_ptr, displ, seq1, seq2);\n        if ((len1 == 0) || (len2 == 0))\n          mm_score = 0.0;\n        else\n          mm_score /= (double) ((len1 < len2) ? (len1) : (len2));\n\n        bench_output[(si * nseqs) + sj] = (int) mm_score;\n      }\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic) private(i, n, si, sj, len1, m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/bots/alignment/alignment_for/alignment/0"}
{"code": "for (k = 0; k < maxit; k++)\n{\n  for (i = 0; i < size; i++)\n  {\n    dx[i] = b[i];\n    x_old[i] = x[i];\n    for (j = rowptr[i]; j < rowptr[i + 1]; j++)\n    {\n      if (i == colidx[j])\n      {\n        diag = val[j];\n      }\n      else\n        if (i != colidx[j])\n      {\n        dx[i] -= omg * (val[j] * x[colidx[j]]);\n      }\n\n\n    }\n\n    dx[i] /= diag;\n    x[i] = ((1.0 - omg) * x[i]) + dx[i];\n  }\n\n  spdgemv(val, colidx, rowptr, x, Ax, size, nnz);\n  for (i = 0; i < size; i++)\n    resid[i] = b[i] - Ax[i];\n\n  resid_norm = ddot(resid, resid, size);\n  error = sqrt(resid_norm / solut_norm);\n  if ((k % 10) == 0)\n    printf(\"%.6e \\n\", error);\n\n  if (error <= epsilon)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lnugraha/parallelized-sparse-iterative-solvers/new_omp_solvers/10"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"%f \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/reduction/4"}
{"code": "for (i = 1; i < TOPEF; i++)\n{\n  index = v2[i];\n  j = i;\n  while ((j > 0) && (v2[j - 1] > index))\n  {\n    v2[j] = v2[j - 1];\n    j = j - 1;\n  }\n\n  v2[j] = index;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/6"}
{"code": "for (unsigned long long int ii = 0; ii < N; ii++)\n  array[ii - first_iteration] = (double) ii;\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/threads_affinity/07_touch_by_all_threadprivate/1"}
{"code": "for (unsigned int i = 0; i < iterations; i++)\n{\n  accelerate_life(board_tick, board_tock, nx, ny);\n  char *tmp = board_tick;\n  board_tick = board_tock;\n  board_tock = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonedarts/rendezvous/openCL/master/Exercises/Exercise13/C/gameoflife/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  list[i] = rand();\n  if (list[i] > maxval)\n  {\n    maxval = list[i];\n  }\n\n  if (list[i] < minval)\n  {\n    minval = list[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/BucketSort/0"}
{"code": "for (int i = 0; i < procs; i++)\n{\n  ncols[i] = size;\n  nrows[i] = size / procs;\n  nozeros[i] = A.indi[(i + 1) * nrows[i]] - A.indi[i * nrows[i]];\n  sum += nozeros[i];\n  fnz[i] = sum - nozeros[i];\n  if (i > 0)\n    sumnnz[i] = nozeros[i - 1];\n\n  fsearch[i] = i * nrows[i];\n  lsearch[i] = (fsearch[i] + nrows[i]) - 1;\n  sizeindi[i] = nrows[i] + 1;\n  fnzi[i + 1] = nrows[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/11"}
{"code": "for (i = 0; i < numOfClusters; i++)\n{\n  if (allClusters[i].clusterSize != 0)\n  {\n    allClusters[i].x /= allClusters[i].clusterSize;\n    allClusters[i].y /= allClusters[i].clusterSize;\n    allClusters[i].z /= allClusters[i].clusterSize;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MotiElbaz/Parallel-KMEANS/Initial/icpi/7"}
{"code": "for (int col = 3 - 1; col >= 0; col--)\n{\n  x[col] /= A[col][col];\n  for (int row = 0; row < col; row++)\n    x[row] -= A[row][col] * x[col];\n\n}\n\n", "pragma": "omp parallel for schedule(static,1) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elard28/OpenMPparalelos/e4/1"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *u = elem_at(&g->vertices, i);\n  payload *u_data = u->data;\n  u_data->fragment_id = u_data->tmp_fragment_id;\n}\n\n", "pragma": "omp parallel for schedule(SCHEDULING_METHOD)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/7"}
{"code": "for (long i = 0; i < NV; i++)\n  head[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityFunctions/14"}
{"code": "for (int k = 0; k < NUMOUT; k++)\n  printf(\"\\t%f\\t\", Output[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/17"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Column %u : %u \\n\", i, csum[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab4-Matrix_Sums/rowsum/4"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  for (int j = 0; j < d; j++)\n  {\n    double dist = X[((j + 1) * n) - 1] - X[(j * n) + i];\n    distances[i] += dist * dist;\n  }\n\n  distances[i] = sqrt(distances[i]);\n}\n\n", "pragma": "omp parallel for if(n>25000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/0"}
{"code": "for (int region = 0; region < num_regions; region++)\n{\n  sscanf(argv[(region * 6) + 1], \"%lf\", &real_lower);\n  sscanf(argv[(region * 6) + 2], \"%lf\", &real_upper);\n  sscanf(argv[(region * 6) + 3], \"%lf\", &img_lower);\n  sscanf(argv[(region * 6) + 4], \"%lf\", &img_upper);\n  sscanf(argv[(region * 6) + 5], \"%i\", &num);\n  sscanf(argv[(region * 6) + 6], \"%i\", &maxiter);\n  printf(\"%d\\n\", mandelbrotSetCount(real_lower, real_upper, img_lower, img_upper, num, maxiter));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victorskl/openmp-mandelbrot/mandelbrot/2"}
{"code": "for (i = assign_index[0]; i < assign_index[1]; i++)\n{\n  double y0 = ((i / width) * vert_int) + lower;\n  double x0 = ((i % width) * hori_int) + left;\n  int repeats = 0;\n  double x = 0;\n  double y = 0;\n  double length_squared = 0;\n  while ((repeats < 100000) && (length_squared < 4))\n  {\n    double temp = ((x * x) - (y * y)) + x0;\n    y = ((2 * x) * y) + y0;\n    x = temp;\n    length_squared = (x * x) + (y * y);\n    ++repeats;\n  }\n\n  slave_buff[(2 + i) - assign_index[0]] = repeats;\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aalty/MPI-OpenMP-Mandlebrot-Set/ms_hybrid/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%i \", vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gerrytty/parallel-programming-course/openMP/task8/0"}
{"code": "for (int k = 0; k < ctx->level; k++)\n{\n  if (i > 44)\n    break;\n\n  int n = ctx->child_num[k];\n  int m = ctx->num_children[k];\n  if (m == 1)\n    continue;\n\n  printf(\"%c%c \", (n < 62) ? (DIGITS[n]) : ('*'), (m < 62) ? (DIGITS[m]) : ('*'));\n  i++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/checkpointing/exact_cover_hybrid_cp/7"}
{"code": "for (int ix = 1; ix < (nx - 1); ix++)\n{\n  vector[ix][ny - 1][0] = vector[ix][ny - 1][nz - 2];\n  vector[ix][ny - 1][nz - 1] = vector[ix][ny - 1][1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/12"}
{"code": "for (i = 0; i < 16; i++)\n{\n  c = lotus_magic_table[block[i] ^ t];\n  t = (checksum[i] ^= c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/6"}
{"code": "for (k = 0; k < N; k++)\n  temporal += matriz[i][k] * matriz2[k][j];\n\n", "pragma": "omp parallel for reduction(+:temporal)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio9/3"}
{"code": "for (i = 0; i < number_of_bars; i++)\n{\n  Range[i + 1] = (tmp / number_of_bars) * (i + 1);\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mohamed-Adel2/Parallel-processing-Histogram-MPI-OpenMP/main/2"}
{"code": "for (int i = 1; i < ((rowsNumber / sqrt_comm_sz) - 1); i++)\n{\n  for (int j = 3; j < (3 * ((colsNumber / sqrt_comm_sz) - 1)); j = j + 3)\n  {\n    for (int c = 0; c <= 2; c++)\n    {\n      myFinalArray[i][j + c] = ((((((((myArray[i - 1][(j - 3) + c] * (((double) 1) / 16)) + (myArray[i][(j - 3) + c] * (((double) 2) / 16))) + (myArray[i + 1][(j - 3) + c] * (((double) 1) / 16))) + (myArray[i - 1][j + c] * (((double) 2) / 16))) + (myArray[i][j + c] * (((double) 4) / 16))) + (myArray[i + 1][j + c] * (((double) 2) / 16))) + (myArray[i - 1][(j + 3) + c] * (((double) 1) / 16))) + (myArray[i][(j + 3) + c] * (((double) 2) / 16))) + (myArray[i + 1][(j + 3) + c] * (((double) 1) / 16));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/0"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  result_local[i].count = 0;\n  result_local[i].elements = allocate(matrix2.cols * (sizeof(struct ELEMENT)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/12"}
{"code": "for (r = 0; r < dim_n; r++)\n{\n  for (c = 0; c < dim_n; c++)\n  {\n    for (p = 0; p < dim_n; p++)\n    {\n      RR[(r * dim_n) + c] += A_test[(r * dim_n) + p] * result[(p * dim_n) + c];\n    }\n\n    RR[(r * dim_n) + c] -= B_test[(r * dim_n) + c];\n    nR += pow(RR[(r * dim_n) + c], 2);\n    nX += pow(result[(r * dim_n) + c], 2);\n    nA += pow(A_test[(r * dim_n) + c], 2);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZhixinLai/Parallel-Computing/Gaussian elimination with partial pivoting by OpenMP/gaussian/7"}
{"code": "for (int i = 0; i < n; i++)\n  arr[i] = i + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/Parallel_binary_search_openmp/0"}
{"code": "for (int i = 0; i < node1->nNeighbors; ++i)\n{\n  if (node1->neighbors[i] == node2)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JulianArmour/openmp_test/q2/0"}
{"code": "for (linha = 1; linha < tamanhoParcial; linha++)\n{\n  for (coluna = 1; coluna < tamanhoParcial; coluna++)\n  {\n    matriz[linha][coluna] = matrizResultado[linha][coluna];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bruno-braganca/gameOfLife_OpenMP/game_of_life/5"}
{"code": "for (i; i < tamano; i++)\n{\n  vector[i] = 1 + (rand() % 20);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dranys/Taller1-OpenMP/saxpy_par/1"}
{"code": "for (i = 0; i < size; i++)\n{\n  u[i] = malloc((sizeof(*u[i])) * size);\n  l[i] = malloc((sizeof(*l[i])) * size);\n  mat[i] = malloc((sizeof(*mat[i])) * size);\n  int j = i;\n  for (j = i; j < size; j++)\n  {\n    mat[i][j] = i + 1;\n    mat[j][i] = i + 1;\n    u[i][j] = mat[i][j];\n    u[j][i] = mat[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adilansari/luDecomposition/OpenMP/lu_openmp/5"}
{"code": "for (int i = 0; i < query_nb; ++i)\n{\n  for (int j = 0; j < ref_nb; ++j)\n  {\n    dist[j] = compute_distance(ref, ref_nb, query, query_nb, dim, j, i);\n    index[j] = j;\n  }\n\n  modified_insertion_sort(dist, index, ref_nb, k);\n  for (int j = 0; j < k; ++j)\n  {\n    knn_dist[(j * query_nb) + i] = dist[j];\n    knn_index[(j * query_nb) + i] = index[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/2"}
{"code": "for (i = 1; i < ((*tcount) + 1); i++)\n{\n  MMX22[i] = MMX2[i];\n  MMX33[i] = MMX3[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXreduction/2"}
{"code": "for (k = 2; k <= limit; k++)\n{\n  if (v[k] == 0)\n  {\n    i = k;\n    while ((i * k) < 1000000000)\n    {\n      v[i * k] = 1;\n      i++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/getmiranda/sieve_eratosthenes_openmp/SieveOpenMP/0"}
{"code": "for (j = 0; j < 22; j++)\n{\n  secp256k1_fe_sqr(&x44, &x44);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/secp256k1-omp/main/5"}
{"code": "for (size_t i = idx; i < n; i++)\n{\n  subset.push_back(inter[i]);\n  subsetList.push_back(subset);\n  subset.pop_back();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/4"}
{"code": "for (i = 0; i < (chunksize / 2); i++)\n{\n  fscanf(file, \"%d\", &temp);\n  for (j = 0; j < Number_Subjects; j++)\n  {\n    fscanf(file, \"%lf\", &doc[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DipeshMitthalal/MPI-OpenMP/mpiopenmp/9"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  Aik = _mm_set1_epi32(A[i][k]);\n  Ai1k = _mm_set1_epi32(A[i + 1][k]);\n  Ai2k = _mm_set1_epi32(A[i + 2][k]);\n  Ai3k = _mm_set1_epi32(A[i + 3][k]);\n  for (j = 0; j < N; j += 4)\n  {\n    Akj = _mm_load_si128((int *) (&A[k][j]));\n    if (i != k)\n    {\n      p = (int *) (&A[i][j]);\n      Aij = _mm_load_si128(p);\n      comp = _mm_add_epi32(Aik, Akj);\n      Aij = _mm_min_epi32(Aij, comp);\n      _mm_store_si128(p, Aij);\n    }\n\n    p = (int *) (&A[i + 1][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai1k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n    p = (int *) (&A[i + 2][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai2k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n    p = (int *) (&A[i + 3][j]);\n    Aij = _mm_load_si128(p);\n    comp = _mm_add_epi32(Ai3k, Akj);\n    Aij = _mm_min_epi32(Aij, comp);\n    _mm_store_si128(p, Aij);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filmnoirprod/parallel_processing/ex1b/part1/codes/fw/0"}
{"code": "for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i)\n  sprintf(&retval[i * 2], \"%02x\", (unsigned int) digest[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/benchmarks/benchmark2/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[(i * n) + j] = fabs(sin((double) rand()));\n    a1_A[(i * n) + j] = (t2_A[(i * n) + j] = (t2_a1_A[(i * n) + j] = 0.));\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MickiFoerster/spl-transformer/test-suite/plain-parallel-hessian/for/1"}
{"code": "for (ii = 0; ii < dim; ii += bs)\n  for (jj = 0; jj < dim; jj += bs)\n  for (kk = 0; kk < dim; kk += bs)\n  for (i = ii; i < ((dim < (ii + bs)) ? (dim) : (ii + bs)); i++)\n  for (j = jj; j < ((dim < (jj + bs)) ? (dim) : (jj + bs)); j++)\n{\n  sum = 0;\n  for (k = kk; k < ((dim < (kk + bs)) ? (dim) : (kk + bs)); k++)\n    sum += vectorA[(i * dim) + k] * vectorB[(j * dim) + k];\n\n  C_block[i][j] = sum;\n}\n\n\n\n\n\n", "pragma": "omp parallel for private(i, j, k, ii, jj, kk, sum) shared(C_block) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshan14/matrix-multiplication-openMP/MatrixMultiplication/1"}
{"code": "for (; (i < N) && (j < N); i = (i * incX) + 2, j = (j * incY) + 2)\n{\n  Y[j] = X[i];\n  Y[j + 1] = X[i + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/5"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 < k) && (k <= ((1 << 16) - 1)))\n  {\n    INT_TYPE key_rank = key_buff_ptr[k - 1];\n    int failed = 0;\n    switch (CLASS)\n    {\n      case 'S':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'W':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 2)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'A':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - (iteration - 1)))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'B':\n        if (((i == 1) || (i == 2)) || (i == 4))\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'C':\n        if (i <= 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n      case 'D':\n        if (i < 2)\n      {\n        if (key_rank != (test_rank_array[i] + iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n      else\n      {\n        if (key_rank != (test_rank_array[i] - iteration))\n          failed = 1;\n        else\n          passed_verification++;\n\n      }\n\n        break;\n\n    }\n\n    if (failed == 1)\n      printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, (int) i);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/51"}
{"code": "for (i = 0; i < 1024; i += 16)\n{\n  for (j = 0; j < 1024; j += 16)\n  {\n    for (k = 0; k < 1024; k += 16)\n    {\n      for (y = i; y < (((i + 16) < 1024) ? (i + 16) : (1024)); y++)\n      {\n        for (x = j; x < (((j + 16) < 1024) ? (j + 16) : (1024)); x++)\n        {\n          for (z = k; z < (((k + 16) < 1024) ? (k + 16) : (1024)); z++)\n          {\n            sum += A[y][z] * B[z][x];\n          }\n\n          C[y][x] += sum;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,y,x,z,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial_double/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  if ((arr[i] & expo) == 0)\n    ctr_even++;\n  else\n    ctr_odd++;\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction ( + : ctr_even, ctr_odd)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aj163/OpenMP/radix_sort/1"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  array[i] = value;\n}\n\n", "pragma": "omp parallel for num_threads(6)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/h4koo/Arquitectura-taller2/src/saxpy_par/1"}
{"code": "for (i = 0; i < 100000; i++)\n  p2[i] = v1[i] * v2[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.3/0"}
{"code": "for (int i = 0; i < len; i++)\n{\n  char delimit = (char) ((i == (len - 1)) ? ('\\n') : (','));\n  printf(\"%d%c\", data[i], delimit);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robfarr/openmp-prefix-sum/main/1"}
{"code": "for (i = 0; i < (1 << 27); i++)\n{\n  key_buff2[i] = key_array[i];\n  prv_buff1[key_buff2[i]]++;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/13"}
{"code": "for (j = 2; j <= (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/22"}
{"code": "for (i = 0; i < n; i++)\n{\n  tid = omp_get_thread_num();\n  ((((cout << \"Default: Thread \") << tid) << \" executing iteration \") << i) << endl;\n}\n\n", "pragma": "#pragma omp parallel for private(tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/main/1"}
{"code": "formula.append((\"- \" + number((-1) * b)) + \"x^6 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/13"}
{"code": "for (int i = 0; i < n; i++)\n{\n  factor = ((i % 2) == 0) ? (1.0) : (-1.0);\n  sum += factor / ((2 * i) + 1);\n  printf(\"Thread %d > i = %d, my_sum = %f\\n\", omp_get_thread_num(), i, sum);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: sum) private(factor)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/07_omp_pi/1"}
{"code": "for (int i = 0; i < 1826; i += 10)\n  ;\n\n", "pragma": "omp for schedule (guided, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr35625/0"}
{"code": "for (i = 1; i < len; i++)\n{\n  if (minWeights[thread_num] > vector[i].weight)\n  {\n    minWeights[thread_num] = vector[i].weight;\n  }\n  else\n    if (maxWeights[thread_num] < vector[i].weight)\n  {\n    maxWeights[thread_num] = vector[i].weight;\n  }\n\n\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sort/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (((flag[i] != 0) && (next[i] >= 0)) && (flag[next[i]] != 0))\n  {\n    flag[i] = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/independentSet/ind_set/3"}
{"code": "for (i = 0; i < 16; i++)\n{\n  t0 = (checksum[0][i] ^= lotus_magic_table[block0[i] ^ t0]);\n  t1 = (checksum[1][i] ^= lotus_magic_table[block1[i] ^ t1]);\n  t2 = (checksum[2][i] ^= lotus_magic_table[block2[i] ^ t2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"thread %d: -\\n\", omp_get_thread_num());\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lumeng16/OpenMPstudy/Basic/barrier/1"}
{"code": "for (int i = 0; i < (Ntot - 1); i++)\n  for (int j = i + 1; j < Ntot; j++)\n  if (((team_ID[i] != team_ID[j]) || (thread_ID[i] != thread_ID[j])) && (pointer[i] == pointer[j]))\n  printf(\"WARNING identical pointer = %p, (team,thread) id (%d,%d) and (%d,%d)\\n\", pointer[i], team_ID[i], thread_ID[i], team_ID[j], thread_ID[j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/tests/private/target_teams_distribute_parallel_for_private/1"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  testBuf[i] = startVal + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/collective_scatterGather/2"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  double x = i * dx;\n  sum += (4.0f / (1.0f + (x * x))) * dx;\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCL-PHAS0100-21-22/week8_examples/pi/main_openmp/0"}
{"code": "for (i = 0; i < count; i++)\n{\n  argon2_hash(saved_salt.t_cost, saved_salt.m_cost, saved_salt.lanes, saved_key[i], saved_len[i], saved_salt.salt, saved_salt.salt_length, crypted[i], saved_salt.hash_size, 0, 0, saved_salt.type, ARGON2_VERSION_NUMBER, memory[omp_get_thread_num() % sc_threads].aligned, pseudo_rands[omp_get_thread_num() % sc_threads]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/0"}
{"code": "for (unsigned int idx = 0; idx < parameter.size(); idx++)\n  if (a == parameter[idx].a)\n{\n  par = &parameter[idx];\n  return par;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/32"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"%d \", arr[i]);\n}\n\n", "pragma": "omp parallel for ordered schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Constructs/ordered_construct/0"}
{"code": "formula.append((\"+ \" + number(e)) + \"x^3 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/23"}
{"code": "for (int i = 0; i < seq_per_proc; i++)\n{\n  pref_sum_arr[master_seq_nums[i]] = pref_sum(m_arrays[master_seq_nums[i]], command_line_args.seq_len);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/6"}
{"code": "for (int i = 0; i < sad_array_size; i++)\n  m = min(m, sad_array[i]);\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/sad-omp/main/1"}
{"code": "for (int i = 0; i < num_persons; i++)\n{\n  for (int j = 0; j < num_training; j++)\n  {\n    if (dist[i][j] < closestValue)\n    {\n      closestValue = dist[i][j];\n      closest = i;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/2"}
{"code": "for (int np = 1; np <= NPI; np++)\n{\n  if (arq == 0)\n  {\n    printf(\"arquivo in.dat nao encontrado!\\n\");\n    exit(1);\n  }\n  else\n  {\n    fscanf(arq, \"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\\n\", &var1, &var1, &var1, &x, &y, &z, &var1, &xl0, &yl0, &zl0, &var1, &var1, &var1, &var1, &var1, &var1, &var1, &var1, &var1);\n  }\n\n  for (int VeAux = 1; VeAux <= 10; VeAux++)\n  {\n    double Ve = VeAux;\n    Ve = Ve / 2;\n    double vex;\n    double vey;\n    double vez;\n    vex = (vey = (vez = (Ve * Ve) / 3));\n    for (int aux = -14; aux <= 2; aux++)\n    {\n      double gama = pow(10, aux);\n      for (int Xaux = 1; Xaux <= 100; Xaux++)\n      {\n        double X = Xaux;\n        double A = brute_A(y, xl0, gama, X, vex, vey);\n        double B = brute_B(yl0, gama, X, vex, vey);\n        double E = brute_E(y, xl0, X, vex);\n        double G = brute_G(x, yl0, X, vex, vey);\n        for (int t = 1; t <= Tmax; t++)\n        {\n          double fx = dX(t, vey, vex, gama, X, A, B, E, G);\n        }\n\n      }\n\n    }\n\n  }\n\n  lineTime = finalTime;\n  time(&timer2);\n  tm_info = localtime(&timer2);\n  strftime(buffer2, 25, \"%d/%m/%Y %H:%M:%S\", tm_info);\n  finalTime = getRealTime();\n  fprintf(out, \"\\nLinha %d: %f segundos\\n\", np, finalTime - lineTime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhonedarts/rendezvous/openCL/rendezvous/rendezvous-opencl/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  XY[i] = f(s);\n  s += h;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aqfort/integrator/JNIDemoCdl/JNIDemoCPP/1"}
{"code": "for (int i = 0; i < len; i++)\n{\n  output[i] = local_sum;\n  local_sum += input[i];\n}\n\n", "pragma": "#pragma omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/openmp/test_scan_CPU/1"}
{"code": "for (i = 0; i < 10; ++i)\n  baz(i);\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr34610/1"}
{"code": "for (int i = 1; i <= m_nReaches; i++)\n{\n  m_qsTemp[i] = 0.f;\n  m_qiTemp[i] = 0.f;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/HS_WB/HS_WB/0"}
{"code": "for (int i = 1; i < n; i++)\n{\n  if (burst_remaining[i] > 0)\n  {\n    q.push(i);\n    mark[i] = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/rr_parallel/2"}
{"code": "for (int i = 0; i < n; ++i)\n  a[i] = rand() % 1000;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sunil-plsr/Parallel-Programming/OpenMP Tasks/q1_w/0"}
{"code": "for (i = 0; i < xbn; i++)\n{\n  lk = 0;\n  id = i * ybn;\n  for (k = 0; k < ybn; k++)\n  {\n    zmin = 9E9;\n    lmin = 0;\n    for (l = lk; l < n; l++)\n    {\n      yl = y[l];\n      if (yl >= yb[k + 1])\n      {\n        lk = l;\n        break;\n      }\n\n      xl = x[l];\n      if ((xb[i] <= xl) && (xl < xb[i + 1]))\n      {\n        if (z[l] < zmin)\n        {\n          zmin = z[l];\n          lmin = l;\n        }\n\n      }\n\n    }\n\n    zmg[id + k] = zmin;\n    idz[lmin] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,k,l,lk,id,xl,yl,zmin,lmin)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UP-RS-ESP/MinGrid/MinGrid/0"}
{"code": "for (int i = 0; i < x; i++)\n{\n  for (int j = 0; j < y; j++)\n    cin >> b[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rohankurekar/HPC/OpenMP/matrix_matrix_multiplication/1"}
{"code": "for (j = 2000; j > i; j--)\n{\n  if (MA[i][i] != 0)\n  {\n    MA[i][j] /= MA[i][i];\n  }\n  else\n    printf(\"ERROR DIV BY ZERO %d: MA[%d][%d] = %.2Lf\\n\", MyP, i, j, MA[i][j]);\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-20/1"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j++)\n{\n  for (k = rowstr[j]; k < rowstr[j + 1]; k++)\n  {\n    colidx[k] = (colidx[k] - firstcol) + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/CG/cg/0"}
{"code": "for (c5 = 0; c5 <= 127; c5++)\n{\n  F[c1][c2] += C[c1][c5] * D[c5][c2];\n}\n\n", "pragma": "omp parallel for private(c5 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/100"}
{"code": "for (int it = 0; it < num_itr; it++)\n{\n  for (int i = 1; i < x_points; i++)\n  {\n    *(u_new + i) = (*(u + i)) - (((c * del_t) / del_x) * ((*(u + i)) - (*((u + i) - 1))));\n  }\n\n  for (int i = 0; i < x_points; i++)\n  {\n    *(u + i) = *(u_new + i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/1-D_Linear_Convection/1-D_Linear_Convection_Dynamic/main/4"}
{"code": "for (size_t index = startIndex; index < endIndex; index++)\n  m_fMaxSoundSpeed = max(m_fMaxSoundSpeed, soundSpeed[index]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/17"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    sum = 0.0;\n    for (k = 0; k < N; k++)\n    {\n      sum = sum + (A[i][k] * B[k][j]);\n    }\n\n    Result[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vidya-vidz/OpenMpi/dgemm_seq/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  score2 = minmax_ab(T[i], +1, niv - 1, alpha, score, nb_noeuds, nb_coupes);\n  if (score2 < score)\n    score = score2;\n\n  if (score < alpha)\n  {\n    *nb_coupes += 1;\n    return alpha;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/26"}
{"code": "for (i = 0; i < ((maxN - minN) + 1); i++)\n{\n  if ((u >= ((minN - 0.5) + i)) && (u < ((minN + 0.5) + i)))\n  {\n    z = minN + i;\n    cnt = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/0"}
{"code": "for (i = 0; i < 960; i++)\n{\n  bag_of_tasks[i][index_pos] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_hybrid/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  printf(\"Thread=%d did row=%d\\n\", tid, i);\n  for (j = 0; j < 100; j++)\n    for (k = 0; k < 100; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vthanos/Parallel-Computing/OpenMP/matrix-calc-p/3"}
{"code": "for (j = 0; j < N; j++)\n  for (i = 0; i < M; i++)\n  V(u, i, j) += ((-dtdy) * (((V(ut, i + 1, j + 1) + V(ut, i + 1, j)) - V(ut, i, j)) - V(ut, i, j + 1))) - (dtdx * (((V(ut, i + 1, j + 1) + V(ut, i, j + 1)) - V(ut, i, j)) - V(ut, i + 1, j)));\n\n\n", "pragma": "omp parallel for schedule(static) default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongbozhang85/openmp-cuda-advection-solver/openmp/parAdvect/3"}
{"code": "for (int h = 0; h < 3; h++)\n  for (int w = 0; w < 3; w++)\n  input_file.read((char *) (&cameraMat->data[h][w]), sizeof(double));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/points2image/kernel/1"}
{"code": "for (i = N - 1; i >= 0; i--)\n{\n  x[i] = b[i];\n  for (j = i + 1; j < N; j++)\n  {\n    x[i] -= A[i][j] * x[j];\n  }\n\n  x[i] = x[i] / A[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-5/7"}
{"code": "for (currentRow = 2; currentRow < workingRows; ++currentRow)\n  for (currentColumn = 2; currentColumn < workingColumns; ++currentColumn)\n{\n  *((nextGrid + (currentRow * totalColumns)) + currentColumn) = ((*((oldGrid + (currentRow * totalColumns)) + currentColumn)) + (parms.cx * (((*((oldGrid + ((currentRow + 1) * totalColumns)) + currentColumn)) + (*((oldGrid + ((currentRow - 1) * totalColumns)) + currentColumn))) - (2.0 * (*((oldGrid + (currentRow * totalColumns)) + currentColumn)))))) + (parms.cy * (((*(((oldGrid + (currentRow * totalColumns)) + currentColumn) + 1)) + (*(((oldGrid + (currentRow * totalColumns)) + currentColumn) - 1))) - (2.0 * (*((oldGrid + (currentRow * totalColumns)) + currentColumn)))));\n  localConvergence = localConvergence && (fabs((*((nextGrid + (currentRow * totalColumns)) + currentColumn)) - (*((oldGrid + (currentRow * totalColumns)) + currentColumn))) < 1e-2);\n}\n\n\n", "pragma": "omp for schedule(static) collapse(DIMENSIONALITY) reduction(&&:localConvergence)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/charidimosv/parallel/src/mpi/src/heatconv/0"}
{"code": "for (i = 0; i < n_local_vertices; i++)\n{\n  const unsigned neighbors_start = local_vertex_offsets[i];\n  const unsigned neighbors_end = local_vertex_offsets[i + 1];\n  int j;\n  for (j = neighbors_start; j < neighbors_end; j++)\n  {\n    if (neighbors[j] >= nglobalverts)\n    {\n      fprintf(stderr, \"Invalid neighbor at i = %llu / %llu, j = %u (%u -> %u)\\n\", i, n_local_vertices, j, neighbors_start, neighbors_end);\n      assert(0);\n    }\n\n    if (get_owner_pe(neighbors[j], nglobalverts) == pe)\n    {\n      n_local_edges++;\n    }\n    else\n    {\n      n_remote_edges++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/18"}
{"code": "for (i = 0; i < ntrow; i++)\n{\n  for (j = 0; j < ntrow; j++)\n  {\n    if ((i == k) || (j == k))\n    {\n    }\n    else\n    {\n      updateSubmatrix(i * nbrow, j * nbrow, i * nbrow, k * nbrow, k * nbrow, j * nbrow, A, b);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for collapse(2)\t ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BineshTharikoppula/Parallel-Tiled-Floyd-Warshall/FinalAPSP/3"}
{"code": "for (i = 0; i < k; i++)\n{\n  if (new_clusters[i][2] > 0)\n  {\n    new_clusters[i][0] /= new_clusters[i][2];\n    new_clusters[i][1] /= new_clusters[i][2];\n  }\n\n  clusters[i][0] = new_clusters[i][0];\n  clusters[i][1] = new_clusters[i][1];\n  new_clusters[i][0] = (new_clusters[i][1] = (new_clusters[i][2] = 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbish/pc-means/par_kmeans/9"}
{"code": "for (j = 0; j < n; j++)\n{\n  fprintf(tm, \"%.3f\\n\", t[j]);\n  fprintf(pf, \"%f\\n\", x[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rcv911/Henon-map/test_sin_omp/1"}
{"code": "for (Vertical = 0; Vertical < MatrixSize; Vertical++)\n{\n  for (Horizontal = 0; Horizontal < MatrixSize; Horizontal += 8)\n  {\n    double *BColumnStart = B + Horizontal;\n    double FirstARowValue = *(ARowStart++);\n    double Sum0 = FirstARowValue * (*BColumnStart);\n    double Sum1 = FirstARowValue * (*(BColumnStart + 1));\n    double Sum2 = FirstARowValue * (*(BColumnStart + 2));\n    double Sum3 = FirstARowValue * (*(BColumnStart + 3));\n    double Sum4 = FirstARowValue * (*(BColumnStart + 4));\n    double Sum5 = FirstARowValue * (*(BColumnStart + 5));\n    double Sum6 = FirstARowValue * (*(BColumnStart + 6));\n    double Sum7 = FirstARowValue * (*(BColumnStart + 7));\n    unsigned Products;\n    for (Products = 1; Products < MatrixSize; Products++)\n    {\n      double ARowValue = *(ARowStart++);\n      BColumnStart = (double *) (((unsigned long) BColumnStart) + RowWidthBInBytes);\n      Sum0 += ARowValue * (*BColumnStart);\n      Sum1 += ARowValue * (*(BColumnStart + 1));\n      Sum2 += ARowValue * (*(BColumnStart + 2));\n      Sum3 += ARowValue * (*(BColumnStart + 3));\n      Sum4 += ARowValue * (*(BColumnStart + 4));\n      Sum5 += ARowValue * (*(BColumnStart + 5));\n      Sum6 += ARowValue * (*(BColumnStart + 6));\n      Sum7 += ARowValue * (*(BColumnStart + 7));\n    }\n\n    ARowStart = (double *) (((unsigned long) ARowStart) - MatrixWidthInBytes);\n    *C = Sum0;\n    *(C + 1) = Sum1;\n    *(C + 2) = Sum2;\n    *(C + 3) = Sum3;\n    *(C + 4) = Sum4;\n    *(C + 5) = Sum5;\n    *(C + 6) = Sum6;\n    *(C + 7) = Sum7;\n    C += 8;\n  }\n\n  ARowStart = (double *) (((unsigned long) ARowStart) + RowWidthAInBytes);\n  C = (double *) (((unsigned long) C) + RowIncrementC);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/strassen/src/strassen_ompi/1"}
{"code": "for (int i = 0; i < sizeOfComponents; ++i)\n{\n  assert((components[i] >= 0) && (components[i] < A->m));\n  assert(levels[components[i]] != INT_MAX);\n  ++prefixSum[levels[components[i]] + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/6"}
{"code": "for (size_t i = 0; i < n; ++i)\n  sum += a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/konfou/openmp-course-sols/cpp/ex7-imbalance-openmp/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < (n / m); j++)\n  {\n    bnum = (int) (((float) m) * (((float) (list[((i * n) / m) + j] - 0)) / range));\n    bucket[bnum][count[bnum]] = list[((i * n) / m) + j];\n    count[bnum]++;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HardiChandra/Parallel-Programming-Projects/Project4 Bucket Sort/Project4-BucketSort/Project4-BucketSortBackup/Project4-BucketSortBackup/2"}
{"code": "for (size_t l_va = 0; l_va < i_nVals; l_va++)\n  o_min[l_va] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/parallel/Distributed/5"}
{"code": "for (ix = 0; ix < Xdots; ix++)\n{\n  for (iy = 0; iy < Ydots; iy++)\n  {\n    v = grid.Values[ix + (iy * Xdots)];\n    if ((v <= vmax) && (v >= vmin))\n      np++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/4"}
{"code": "for (exp = 0; exp < NBEXPERIMENTS; exp++)\n{\n  init_array_random(X, N);\n  start = _rdtsc();\n  parallel_merge_sort(X, N);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n  if (!is_sorted(X, N))\n  {\n    fprintf(stderr, \"ERROR: the parallel sorting of the array failed\\n\");\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Paritosh97/openmp-demo/sorting_algorithms/mergesort/10"}
{"code": "for (i = 0; i < nbRawMatrix; ++i)\n{\n  error = 1.0;\n  j = 0;\n  intiValueLayer(tabLayer[0], i);\n  fillOutc(out, i);\n  while ((error > 0.05) && (j < 100))\n  {\n    rnnsetstart(tabLayer);\n    rnnset(tabLayer, out);\n    ajustError(tabLayer[NBLAYER - 1]);\n    rnnlearn(tabLayer, out, learningrate);\n    error = geterror(tabLayer[NBLAYER - 1], out);\n    j++;\n  }\n\n  printf(\"\\nLigne : %d | trouv\u00e9 en : %d iteration  | \", i + 1, j);\n  displayVector(out, sizeOfTableOutput);\n  wichError(tabLayer[NBLAYER - 1], out);\n  sum += j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/31"}
{"code": "for (i = 0; i < dim; i++)\n{\n  mat1[i] = temp1;\n  temp1 += dim;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj/bench/4"}
{"code": "for (k = 0; k < n_estimators; k++)\n{\n  read_data_3d(motherFucking3dVec, treeRF, maxNodesTree, colsTree, n_estimators, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/RandomForest/3"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      v[k][j][i][m] = v[k][j][i][m] - (omega * (((((ldz[j][i][0][m] * v[k - 1][j][i][0]) + (ldz[j][i][1][m] * v[k - 1][j][i][1])) + (ldz[j][i][2][m] * v[k - 1][j][i][2])) + (ldz[j][i][3][m] * v[k - 1][j][i][3])) + (ldz[j][i][4][m] * v[k - 1][j][i][4])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/1"}
{"code": "for (unsigned ci = 0; ci < GetCount(); ci++)\n  if (List[ci]->Use_InterpolatedVel())\n  List[ci]->GetInOutVel()->SaveVtkVelGrid();\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JSphInOut/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[0][i][j + 1][k] = lhs[0][i][j + 1][k] + comz1;\n    lhs[1][i][j + 1][k] = lhs[1][i][j + 1][k] - comz4;\n    lhs[2][i][j + 1][k] = lhs[2][i][j + 1][k] + comz5;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/67"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  begin_timer();\n  init_energy_measure();\n  initialize_graph(g);\n  do\n  {\n    six_color_tree(g, digits);\n  }\n  while (again(g));\n  total_energy += total_energy_used();\n  duration += time_elapsed();\n  verification = verify_and_print_solution(g);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/vertex_coloring/6"}
{"code": "for (i = 0; i < r; i++)\n{\n  printf(\"%4d\\n\", res[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m3zai6i/Matrix-Vector-Algo-OpenMP-Threading/mat_vec_omp/4"}
{"code": "for (i = 0; i < 3; i++)\n{\n  int _imopVarPre257;\n  int _imopVarPre258;\n  _imopVarPre257 = d[i];\n  _imopVarPre258 = ilog2(_imopVarPre257);\n  logd[i] = _imopVarPre258;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/22"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB033-truedeplinear-orig-yes/0"}
{"code": "for (index = 0; index < tot_todo; index += 1)\n{\n  union xx\n  {\n    unsigned char c[64];\n    long a[64 / (sizeof(long))];\n  } u;\n  unsigned char *temp_result = u.c;\n  SHA512_CTX ctx;\n  SHA512_CTX alt_ctx;\n  size_t cnt;\n  int idx;\n  char *cp;\n  char p_bytes[79 + 1];\n  char s_bytes[79 + 1];\n  char tmp_cls[(sizeof(cryptloopstruct)) + MEM_ALIGN_SIMD];\n  cryptloopstruct *crypt_struct;\n  crypt_struct = (cryptloopstruct *) mem_align(tmp_cls, MEM_ALIGN_SIMD);\n  for (idx = 0; idx < 1; ++idx)\n  {\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA512_Update(&ctx, cur_salt->salt, cur_salt->len);\n    SHA512_Init(&alt_ctx);\n    SHA512_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA512_Update(&alt_ctx, cur_salt->salt, cur_salt->len);\n    SHA512_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n    SHA512_Final((unsigned char *) crypt_out[MixOrder[index + idx]], &alt_ctx);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 64; cnt -= 64)\n      SHA512_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 64);\n\n    SHA512_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], cnt);\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt > 0; cnt >>= 1)\n      if ((cnt & 1) != 0)\n      SHA512_Update(&ctx, (unsigned char *) crypt_out[MixOrder[index + idx]], 64);\n    else\n      SHA512_Update(&ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n\n    SHA512_Final((unsigned char *) crypt_out[MixOrder[index + idx]], &ctx);\n    SHA512_Init(&alt_ctx);\n    for (cnt = 0; cnt < saved_len[MixOrder[index + idx]]; ++cnt)\n      SHA512_Update(&alt_ctx, (unsigned char *) saved_key[MixOrder[index + idx]], saved_len[MixOrder[index + idx]]);\n\n    SHA512_Final(temp_result, &alt_ctx);\n    cp = p_bytes;\n    for (cnt = saved_len[MixOrder[index + idx]]; cnt >= 64; cnt -= 64)\n      cp = ((char *) memcpy(cp, temp_result, 64)) + 64;\n\n    memcpy(cp, temp_result, cnt);\n    SHA512_Init(&alt_ctx);\n    for (cnt = 0; cnt < (16 + ((unsigned char *) crypt_out[MixOrder[index + idx]])[0]); ++cnt)\n      SHA512_Update(&alt_ctx, cur_salt->salt, cur_salt->len);\n\n    SHA512_Final(temp_result, &alt_ctx);\n    cp = s_bytes;\n    for (cnt = cur_salt->len; cnt >= 64; cnt -= 64)\n      cp = ((char *) memcpy(cp, temp_result, 64)) + 64;\n\n    memcpy(cp, temp_result, cnt);\n    LoadCryptStruct(crypt_struct, MixOrder[index + idx], idx, p_bytes, s_bytes);\n  }\n\n  idx = 0;\n  SHA512_Init(&ctx);\n  for (cnt = 1;; ++cnt)\n  {\n    SHA512_Update(&ctx, crypt_struct->bufs[0][idx], crypt_struct->datlen[idx]);\n    if (cnt == cur_salt->rounds)\n      break;\n\n    memcpy(crypt_struct->cptr[0][idx], ctx.h, 64);\n    if ((++idx) == 42)\n      idx = 0;\n\n    memcpy(ctx.h, ctx_init, sizeof(ctx_init));\n  }\n\n  memcpy(crypt_out[MixOrder[index]], ctx.h, 64);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sha512crypt_fmt_plug/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  p[i] = i;\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(T)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anandcse2018/LU-Decomposition/OMP/1"}
{"code": "for (short i = 0; i < stringtoSplit.length(); i++)\n{\n  if (stringtoSplit[i] != delim)\n  {\n    stringParts[j] += (char) stringtoSplit[i];\n  }\n  else\n  {\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tjp77/Seam-Carver/Seam Carver/2"}
{"code": "for (n = 0; n <= 14; n += 1)\n{\n  for (i = 0; i <= (grid_points[0] - 1); i += 1)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j += 1)\n    {\n      for (k = 0; k <= (grid_points[2] - 1); k += 1)\n      {\n        lhs[n][i][j][k] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/41"}
{"code": "for (i = 0; i <= 2021; i++)\n{\n  sum = sum + i;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPScheduleClause/0"}
{"code": "for (i = 0; i < block_dim; i++)\n{\n  for (t = 0; t < block_dim; t++)\n  {\n    b[i][t] = '2';\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoRouv/game-of-life/GOLOpenMP/golOpenMP/6"}
{"code": "for (int j = 0; j < o; j++)\n{\n  sum += A[i][j] * b[j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum)\t\t\t\t\t\t\t", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kreagentle/openmp/task3/4"}
{"code": "for (int i = 0; i < m; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    for (int l = 0; l < reduction_N; ++l)\n    {\n      int start = (l * k) / reduction_N;\n      int end = ((l + 1) * k) / reduction_N;\n      for (int ll = start; ll < end; ++ll)\n      {\n        temp[l] = (alpha * A[(i * k) + ll]) * B[(ll * n) + j];\n      }\n\n      C[(i * n) + j] += temp[l];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for collapse(3) reduction(+ : C[:m * n])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yanjen/gemm_lib_compare/OpenMP/gemm/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < p; j++)\n  {\n    (cout << b[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/superhit0/Openmp/mul2d/5"}
{"code": "for (i = 0; i < M; i++)\n  for (j = 0; j < N; j++)\n  a[i][j] = min(a[i][j], a[i][k] + tmp[j]);\n\n\n", "pragma": "  #pragma omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/dataSharing/1"}
{"code": "for (j = 0; j < 1000; ++j)\n{\n  exclusiv_bit_or = exclusiv_bit_or ^ logics[j];\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(^:exclusiv_bit_or)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_reduction/9"}
{"code": "for (size_t i = 0; i < (5120 * 5120); i++)\n  A[i] = ((float) rand()) / ((float) (32767 / 5));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fritschnils/tp-parallelisation/tp1/tp1_5_matvec/2"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; ++j)\n  {\n    sum = 0.0;\n    for (k = 0; k < j; ++k)\n    {\n      sum += matrixLU[i][k] * matrixLU[j][k];\n    }\n\n    matrixLU[i][j] = (matrixA[i][j] - sum) / matrixLU[j][j];\n  }\n\n  sum = 0.0;\n  for (k = 0; k < i; ++k)\n  {\n    sum += matrixLU[i][k] * matrixLU[i][k];\n  }\n\n  matrixLU[i][i] = sqrt(matrixA[i][i] - sum);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/lu/8"}
{"code": "for (i = 0; i < (colsNumber / sqrt_comm_sz); i++)\n{\n  topRow[i] = myArray[0][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/gray/3"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  truncated_radix_sort(&morton_codes[(i > 0) ? (BinSizes[i - 1]) : (0)], &sorted_morton_codes[(i > 0) ? (BinSizes[i - 1]) : (0)], &permutation_vector[(i > 0) ? (BinSizes[i - 1]) : (0)], &index[(i > 0) ? (BinSizes[i - 1]) : (0)], &level_record[(i > 0) ? (BinSizes[i - 1]) : (0)], BinSizes[i] - ((i > 0) ? (BinSizes[i - 1]) : (0)), population_threshold, sft - 3, lv + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/radix_sort/6"}
{"code": "for (size_t i = val_begin; i < val_end; i++)\n  masks_val[i] = 1;\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/gnn/net/1"}
{"code": "for (int i = 0; i < nvertices; ++i)\n{\n  free(adjacency_list[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vilas897/Parallel-Graph-Coloring-with-OpenMP-and-CUDA/Vertex-Coloring/parallel-omp/6"}
{"code": "for (jCount = 0; jCount < c2; jCount++)\n{\n  for (kCount = 0; kCount < c1; kCount++)\n  {\n    MAT3[i][jCount] += MAT1[i][kCount] * MAT2[kCount][jCount];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ahmed-Masoud-O/MatMultiply-OpenMp-/MatMultiply(openMp)/main/0"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  if (weight > delta)\n  {\n    edgesPlusCounter++;\n  }\n  else\n    if (weight <= delta)\n  {\n    edgesMinusCounter++;\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(graph,delta) reduction(+:edgesPlusCounter,edgesMinusCounter)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/3"}
{"code": "for (int p = 0; p < nproc; p++)\n{\n  values_count[p] = A->ptr[(p * n_local) + ptr_count[p]] - A->ptr[p * n_local];\n  values_displs[p] = A->ptr[p * n_local];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dboubacar/Parallelization_OpenMP_MPI/mpi_omp/cg/12"}
{"code": "for (i = 0; i <= 5; i++)\n{\n  printf(\"For i value equal to %d fibbonaci result is %d.\\n\", fibbonaci[i].n, fibbonaci[i].result);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcinbogiel/OpenMP_examples/My solutions/exercise_6/1"}
{"code": "for (int y = 0; y < data_size_Y; y++)\n{\n  for (int x = 16 * (data_size_X / 16); x < data_size_X; x++)\n  {\n    out[x + (y * data_size_X)] += (*r_kernel) * (*(padded_in + ((((x + 1) + (0 % 3)) - kern_cent_X) + ((((y + 1) + (0 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 1)) * (*(padded_in + ((((x + 1) + (1 % 3)) - kern_cent_X) + ((((y + 1) + (1 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 2)) * (*(padded_in + ((((x + 1) + (2 % 3)) - kern_cent_X) + ((((y + 1) + (2 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 3)) * (*(padded_in + ((((x + 1) + (3 % 3)) - kern_cent_X) + ((((y + 1) + (3 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 4)) * (*(padded_in + ((((x + 1) + (4 % 3)) - kern_cent_X) + ((((y + 1) + (4 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 5)) * (*(padded_in + ((((x + 1) + (5 % 3)) - kern_cent_X) + ((((y + 1) + (5 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 6)) * (*(padded_in + ((((x + 1) + (6 % 3)) - kern_cent_X) + ((((y + 1) + (6 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 7)) * (*(padded_in + ((((x + 1) + (7 % 3)) - kern_cent_X) + ((((y + 1) + (7 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n    out[x + (y * data_size_X)] += (*(r_kernel + 8)) * (*(padded_in + ((((x + 1) + (8 % 3)) - kern_cent_X) + ((((y + 1) + (8 / 3)) - kern_cent_Y) * (data_size_X + 2)))));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(kern_cent_X, kern_cent_Y, data_size_X, r_kernel)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erictu/Image-Processing-Optimization/part2/3"}
{"code": "for (int i = 0; i < 100; ++i)\n{\n  append_node(queuePointer, create(i));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sebmancipe/openmp-c-ppf/linked-list/main/0"}
{"code": "for (long int itr = 0; itr < number; itr++)\n{\n  if (algo == 1)\n  {\n    if (Algorithm_1_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n  else\n    if (algo == 2)\n  {\n    if (Algorithm_2_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n  else\n    if (algo == 3)\n  {\n    if (Algorithm_3_Prime(itr))\n    {\n      if (Prime < itr)\n      {\n        Prime = itr;\n      }\n\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(thread) schedule(guided, limit) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/6"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j <= i; j++)\n  {\n    t = 0.0f;\n    for (k = 0; k < j; k++)\n    {\n      if ((B[(i * 1000) + k] != 0.0f) && (B[(j * 1000) + k] != 0.0f))\n      {\n        t += B[(i * 1000) + k] * B[(j * 1000) + k];\n      }\n      else\n      {\n        k--;\n      }\n\n    }\n\n    if (i == j)\n    {\n      B[(i * 1000) + j] = sqrt(A[(i * 1000) + i] - t);\n    }\n    else\n    {\n      if (B[(j * 1000) + j] != 0.0f)\n      {\n        B[(i * 1000) + j] = (1.0 / B[(j * 1000) + j]) * (A[(i * 1000) + j] - t);\n      }\n      else\n      {\n        j--;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/cholesky/src/cholesky_gpu/0"}
{"code": "for (int i = 0; i < Index.TotalSize; i++)\n{\n  PopulateMesh(i, mesh);\n}\n\n", "pragma": "#pragma omp parallel for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HeartofTheForce/Isosurface/src/DualContouring/MeshGenerator/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    printf(\"%Lf\\t\", x[(i * N) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cleversonledur/ParallelMPIcode/winogradPar/4"}
{"code": "for (unsigned int i = 0; i < (((2048 / NODESX) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (9 - 1))))) % 9;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/95"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    double *pA;\n    double *pB;\n    double suma = 0.0;\n    pA = matrizA + (i * N);\n    pB = matrizB + (j * N);\n    for (int k = 0; k < N; k++, pA++, pB++)\n    {\n      suma += (*pA) * (*pB);\n    }\n\n    matrizC[(i * N) + j] = suma;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/macatimo17/openMP/MM1f/0"}
{"code": "for (i = 0; i < n; ++i)\n  for (j = 0; j < n; ++j)\n  if (i == j)\n  dist[i][j] = 0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zsims92/All-Shortest-Paths-Optimized/allShortestPathsParallel/openmpFW/2"}
{"code": "for (i = 0; i < number_of_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pockemon/Computer-Architecture-Lab/Assignment5/Q6-value-of-pie-worksharing-and-reduction/value-of-pie/0"}
{"code": "for (m = 0; m < ng; m++)\n{\n  p_temp = pfft(f, i, m, k);\n  fft_data_local[2 * m] = p_temp->Re;\n  fft_data_local[(2 * m) + 1] = p_temp->Im;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/fft_basic/3"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < (width * 3); j += 3, pos++)\n  {\n    red[pos] = imgdata[(i * rgb_width) + j];\n    green[pos] = imgdata[((i * rgb_width) + j) + 1];\n    blue[pos] = imgdata[((i * rgb_width) + j) + 2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manogna-mujje/Image-Processing/OpenMP/max_paralleize_openmp/3"}
{"code": "for (int k = 0; k < Process_Num; k++)\n{\n  ((((((cout << (Process_Length * (1 + k))) << \"\u4e2a\") << Matrix_de) << \"*\") << Matrix_de) << \"\u7684\u77e9\u9635\u5904\u7406\uff1a\") << endl;\n  (cout << \"\u7ebf\u7a0b\u6570    \u5904\u7406\u65f6\u95f4     \u52a0\u901f\u6bd4\") << endl;\n  for (int i = 0; i < 6; i++)\n  {\n    cout.setf(fixed);\n    (((cout << (i + 1)) << \"          \") << setprecision(3)) << thread_time[k][i];\n    (((cout << \"       \") << setprecision(3)) << (thread_time[k][0] / thread_time[k][i])) << endl;\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nanyuu/Matrix-multiplication-OpenMP/OpenMP/8"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  for (int j = 0; j < n; ++j)\n  {\n    A[j + (i * n)] = (i == j) ? (2.0) : (1.0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kobtsev-m/Parallel-Programming-Labs/Lab2/lab2/0"}
{"code": "for (unsigned int i = 0; i < (m_results.front().size() - 1); ++i)\n{\n  ((file << \"band_\") << i) << \",\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RemiHelleboid/BzMeshBandsDos/src/EPP/BandStructure/1"}
{"code": "for (j = start; j < end; j++)\n{\n  double init = 1 / ((double) ((2 * j) + 1));\n  if ((j % 2) == 0)\n  {\n    sum = sum + init;\n  }\n  else\n  {\n    sum = sum - init;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nishi1612/High-Performance-Computing/Lab2/201601408-201601059-pi_using_series-critical/parallel_measurement/0"}
{"code": "for (j = 0; j < grid_points[1]; j++)\n{\n  for (k = 0; k < grid_points[2]; k++)\n  {\n    rho_inv = 1.0 / u[i][j][k][0];\n    rho_i[i][j][k] = rho_inv;\n    us[i][j][k] = u[i][j][k][1] * rho_inv;\n    vs[i][j][k] = u[i][j][k][2] * rho_inv;\n    ws[i][j][k] = u[i][j][k][3] * rho_inv;\n    square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n    qs[i][j][k] = square[i][j][k] * rho_inv;\n  }\n\n}\n\n", "pragma": "omp parallel for private(rho_inv)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/27"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      video[i][j][k] = ((i + j) + k) % 255;\n      videoDiff[i][j][k] = 0;\n      videoDiffErod[i][j][k] = 0;\n      videoSil[i][j][k] = 0;\n      videoseuil[i][j][k] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/4"}
{"code": "for (i = 0; i < N; i++)\n  result += C[i] * A[i];\n\n", "pragma": "    #pragma omp parallel for default(shared)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/notTyche/various-openMP-program/src/ex2/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  unpredictable_amount_of_work(UD(2, 10));\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_scheduling/2"}
{"code": "for (part = 0; part < n; part++)\n  Compute_force(p, forces, part, n);\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Two-n-Body/Parallel-Basic/src/twoBody/0"}
{"code": "for (i = 1; i <= T_MAX; i++)\n{\n  t = timer_read(i);\n  printf(\" timer %2d(%16s) :%9.4f (%6.2f%%)\\n\", i, tstrings[i], t, (t * 100.0) / t_m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/FT/ft/12"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  free((*data)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hejohns/kmeans/kmeans/1"}
{"code": "for (int i = 0; i < 1000; i++)\n  map_par(&square, par_nums, par_out, size);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Baltoli/skeletons/examples/map/1"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int val = imageData[i][j] * PAD;\n    omp_set_lock(lock + val);\n    ++hist[val];\n    omp_unset_lock(lock + val);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/9"}
{"code": "for (i = 0; i < 4; i++)\n{\n  avgtime[i] = avgtime[i] / ((double) (NTIMES - 1));\n  bandwidth[i] = ((bytes[i] / 1024.0) / 1024.0) / mintime[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielecesarini/stream/stream/19"}
{"code": "for (int i = 0; i < MAT_ROWS; i++)\n{\n  for (int j = 0; j < MAT_COLS; j++)\n  {\n    int valA = (rand() % 20) + 1;\n    int valB = (rand() % 20) + 1;\n    matA[(i * MAT_COLS) + j] = valA;\n    matB[(i * MAT_COLS) + j] = valB;\n    matBTrans[(j * MAT_COLS) + i] = valB;\n    matC[(i * MAT_COLS) + j] = 0;\n    matA2d[i][j] = valA;\n    matB2d[i][j] = valB;\n    matC2d[i][j] = 0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/psattiza/matrixMult/main/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (a = 0; a < n; a++)\n    {\n      C[(i * n) + j] += A[(i * n) + a] * B[(a * n) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sand47/ME759-CUDA-Assignments/HW08/matmul/0"}
{"code": "for (int j = 0; j < Time_cell; ++j)\n{\n  for (int i = 0; i < Freq_cell; ++i)\n  {\n    fprintf(map_fp, \"%f,\", hsa_map[j][i]);\n  }\n\n  fprintf(map_fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/46"}
{"code": "for (int i = 1; i < nb_nodes; i++)\n{\n  start += n_bytes / nb_nodes;\n  end += n_bytes / nb_nodes;\n  if ((i == (nb_nodes - 1)) || (end > n_bytes))\n  {\n    end = n_bytes;\n  }\n\n  part_bytes = (end - start) + 1;\n  MPI_Send(&part_bytes, 1, (MPI_Datatype) 1275069467, i, 0, (MPI_Comm) 0x44000000);\n  printf(\"Rank 0 sended part_bytes : %d to rank %d\\n\", part_bytes, i);\n  MPI_Send(&buf[start], part_bytes, (MPI_Datatype) 0x4c00010d, i, 1, (MPI_Comm) 0x44000000);\n  printf(\"Rank 0 sended a part_buffer to rank %d\\n\", i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nordine-marie/hpc-dna-approximate-pattern-matching/apm/apm_omp_mpi/src/apm/6"}
{"code": "for (i = jull; i < kull; i++)\n  l++;\n\n", "pragma": "omp for reduction(+: l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/15"}
{"code": "for (wI = k + 1; wI <= SMALLN_MATR; wI++)\n{\n  coef = aMatrU[wI][k] / pivot;\n  for (wJ = k + 1; wJ <= SMALLN_MATR; wJ++)\n  {\n    aMatrU[wI][wJ] -= coef * aMatrU[k][wJ];\n    aMatrL[wI][k] = coef;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/10"}
{"code": "for (i = 0; i < 5; i++)\n{\n  printf(\"\\n\");\n  for (j = 0; j < 4; j++)\n  {\n    printf(\"%d\\t\", k[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephloochunhoe/parallel-computing/A1/Parallel_Bankers_Algorithm/8"}
{"code": "for (x = id * size; x < (size * (id + 1)); x++)\n{\n  for (y = 0; y < 2048; y++)\n  {\n    convolution_transform(x, y, kernel, kernel_half_size, kernel_size, bias, size_pix);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tino415/papp-openmp/main_mpi/0"}
{"code": "for (n = 1; n < 5; n++)\n{\n  printf(\"In loop 'i' is = %d \\n\", i);\n  i = i + 2;\n}\n\n", "pragma": "omp parallel for firstprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KhushbuB/openmp-/Fprivate/0"}
{"code": "for (i = 0; i < global_chunknr; i++)\n{\n  if (expected_chunk_size > 1)\n    expected_chunk_size = (c * openwork) / threads;\n\n  if (abs(chunksizes[i] - expected_chunk_size) >= 2)\n  {\n    result = 0;\n  }\n\n  if ((expected_chunk_size - chunksizes[i]) < 0)\n    fprintf(logFile, \"Chunksize did not decrease: %d instead of %d\\n\", chunksizes[i], expected_chunk_size);\n\n  openwork -= chunksizes[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_guided/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  pops[i] = rand() % 256;\n  totalPop += pops[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/QuintinDavis/Matrices_and_Sets/Set_Operations/TownSet_openmp/5"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; ++j)\n  for (k = 0; k < n; ++k)\n{\n  x[i][j][k] = (i + j) + k;\n}\n\n\n\n", "pragma": "omp parallel for ordered(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr81887/3"}
{"code": "for (; num_lines < 10u; num_lines++)\n{\n  if (!getline(file_in, line))\n  {\n    file_in.clear();\n    break;\n  }\n\n  total_line_size += line.size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leehongjoo88/pcsv_reader/read/0"}
{"code": "for (unsigned int i = 0; i < _m; i++)\n{\n  sum += _adjacentMatrixBool[i][edgeId];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex-87/HyperGraphLib/src/model/AdjacentMatrix/4"}
{"code": "for (i = 0; i < Size; i++)\n{\n  a[i].re = 1.0;\n  a[i].im = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_FFT/c_fft/2"}
{"code": "for (int k1 = 0; k1 < 3; k1++)\n{\n  for (int k2 = 0; k2 < 3; k2++)\n  {\n    int temp = 0;\n    for (int i = 0; i < 3; i++)\n    {\n      temp = temp + (matriz_A[k1][i] * matriz_B[i][k2]);\n    }\n\n    matriz_result[k1][k2] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for private( i, j) num_threads(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/matriz_openmp/0"}
{"code": "for (int it = 0; it < repeat; it++)\n{\n  gettimeofday(&startwtime, 0);\n  compute_hash_codes(hash_codes, X, N, nbins, min, max);\n  gettimeofday(&endwtime, 0);\n  double hash_time = (double) ((((endwtime.tv_usec - startwtime.tv_usec) / 1.0e6) + endwtime.tv_sec) - startwtime.tv_sec);\n  printf(\"Time to compute the hash codes            : %fs\\n\", hash_time);\n  gettimeofday(&startwtime, 0);\n  morton_encoding(morton_codes, hash_codes, N, maxlev);\n  gettimeofday(&endwtime, 0);\n  double morton_encoding_time = (double) ((((endwtime.tv_usec - startwtime.tv_usec) / 1.0e6) + endwtime.tv_sec) - startwtime.tv_sec);\n  printf(\"Time to compute the morton encoding       : %fs\\n\", morton_encoding_time);\n  gettimeofday(&startwtime, 0);\n  truncated_radix_sort(morton_codes, sorted_morton_codes, permutation_vector, index, level_record, N, population_threshold, 3 * (maxlev - 1), 0);\n  gettimeofday(&endwtime, 0);\n  double sort_time = (double) ((((endwtime.tv_usec - startwtime.tv_usec) / 1.0e6) + endwtime.tv_sec) - startwtime.tv_sec);\n  printf(\"Time for the truncated radix sort         : %fs\\n\", sort_time);\n  gettimeofday(&startwtime, 0);\n  data_rearrangement(Y, X, permutation_vector, N);\n  gettimeofday(&endwtime, 0);\n  double rearrange_time = (double) ((((endwtime.tv_usec - startwtime.tv_usec) / 1.0e6) + endwtime.tv_sec) - startwtime.tv_sec);\n  printf(\"Time to rearrange the particles in memory : %fs\\n\", rearrange_time);\n  int pass = check_index(permutation_vector, N);\n  if (pass)\n  {\n    printf(\"Index test PASS\\n\");\n  }\n  else\n  {\n    printf(\"Index test FAIL\\n\");\n  }\n\n  pass = check_codes(Y, sorted_morton_codes, level_record, N, maxlev);\n  gettimeofday(&endwtime, 0);\n  if (pass)\n  {\n    printf(\"Encoding test PASS\\n\");\n  }\n  else\n  {\n    printf(\"Encoding test FAIL\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/test_octree/1"}
{"code": "for (int i = 0; i <= m_nSubbsns; i++)\n{\n  tmp_orgn2ch[i] = 0.f;\n  tmp_orgp2ch[i] = 0.f;\n  tmp_minpa2ch[i] = 0.f;\n  tmp_minps2ch[i] = 0.f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrSED/NutrientTransportSediment/2"}
{"code": "for (i = 0; i < 256; i++)\n{\n  matrix[i] = p;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/icecr4ck/parallel-programming/openmp/labo2/5"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    lhs[1][i + 1][j][k] = lhs[1][i + 1][j][k] - comz4;\n    lhs[2][i + 1][j][k] = lhs[2][i + 1][j][k] + comz6;\n    lhs[3][i + 1][j][k] = lhs[3][i + 1][j][k] - comz4;\n    lhs[4][i + 1][j][k] = lhs[4][i + 1][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/53"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  printf(\"\\t neth[%d]=%f \\t outh[%d]=%f \\n\", col, neth[col], col, outh[col]);\n  col = col + 4;\n  printf(\"\\t neto[%d]=%f \\t outo[%d]=%f\\n \", col, neto[col], col, outo[col]);\n  col = col + 4;\n  printf(\"\\t Etotal[%d]=%f \\n \", col, E[col]);\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/7"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  wprintw(shipWindow, \"%c \", letters[i]);\n  for (int j = 0; j < 10; j++)\n  {\n    if (npcShootMap[i][j] != 0)\n      wprintw(shipWindow, \" x\");\n    else\n      if (playerShips[i][j] != 0)\n      wprintw(shipWindow, \" +\");\n    else\n      if (((!shipFinal) && isValueInArray(i, shipNodes, num_nodes)) && (j == active_col))\n      wprintw(shipWindow, \" |\");\n    else\n      wprintw(shipWindow, \" .\");\n\n\n\n  }\n\n  wprintw(shipWindow, \"\\n\");\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dragoonblade/battleship/battleship/3"}
{"code": "for (i = 0; i < m; ++i)\n{\n  evaluator_destroy(function_evaluators[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kozub/OpenMP-TrapezoidalRule-Integral/integral_omp/2"}
{"code": "for (i = 0; i < 100; i++)\n{\n  x[i] = i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mihai-constantin/ACS/APP/Laborator/lab01/ex_pdf/for/0"}
{"code": "for (i = 0; i < 500; i++)\n{\n  printf(\"Thread %d a=%d\\n\", omp_get_thread_num(), square);\n  square += number * number;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Romen-Adama-Dev/High-Performance-Computing-Lab7/lab7-square/0"}
{"code": "for (j = 0; j < dimension; j++)\n{\n  t = data_points[j] - c[j];\n  distance += t * t;\n  if (distance >= min)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/2"}
{"code": "for (i = 0; i < nlines; i++)\n{\n  mat[i] = (double *) malloc((sizeof(double)) * ncols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/obernardocosta/High-Performance-Computing-HPC/OPEN_MP/2/linalg_par/7"}
{"code": "for (i = 0; i < (((L / 1) + 2) / 2); i++)\n{\n  for (j = 0; j < ((L / NODESY) + 2); j++)\n  {\n    whites[i][j].data = 0;\n    blacks[i][j].data = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/92"}
{"code": "for (i = 0; i < (N * N); i++)\n{\n  (cout << B[i]) << \" \";\n  if (((i + 1) % N) == 0)\n  {\n    cout << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NekIP/OpenMP/openmp/ConsoleApplication2/ConsoleApplication2/3"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpo7un8u9a.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  printf(\"\\n Iteration %d is done by T%d \", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/V6429/openmp_present/presentation/5.Loop/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if (notdone[i] && (dist[i] < local_min_dist))\n  {\n    local_min_dist = dist[i];\n    local_min_idx = i;\n  }\n\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NDU-CSC413/stl-openmp/dijkstra/dijkstra/2"}
{"code": "for (int i = 0; i < steps; ++i)\n{\n  p->getNextWeek();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/16"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  printf(\"i = %d, thread id = %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest09/simple_test_09/0"}
{"code": "for (src = 0; src < 1200; src++)\n{\n  int *ds = distance_matrix[src];\n  for (dst = 0; dst < 1200; dst++)\n  {\n    ds[dst] = min(ds[dst], ds[middle] + dm[dst]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(src, dst) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kckishan/Floyd-Warshall-algorithm-OpenMP/apsp_1200_nodes/3"}
{"code": "for (j = strlen(MaxB) - 1; j > (-1); --j)\n{\n  OptB[k] = MaxB[j];\n  ++k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/12"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  a[x] = ((unsigned int) rand()) / ((double) (32767 / 2));\n  num_threads[x] = -x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitxor/0"}
{"code": "for (en = n - 1; en >= 0; en--)\n{\n  p = wr[en];\n  q = wi[en];\n  na = en - 1;\n  if (q == 0.)\n  {\n    m = en;\n    h[en][en] = 1.;\n    for (i = na; i >= 0; i--)\n    {\n      w = h[i][i] - p;\n      r = h[i][en];\n      for (j = m; j <= na; j++)\n        r += h[i][j] * h[j][en];\n\n      if (wi[i] < 0.)\n      {\n        z = w;\n        s = r;\n      }\n      else\n      {\n        m = i;\n        if (wi[i] == 0.)\n          h[i][en] = (-r) / ((w != 0.) ? (w) : (DBL_EPSILON * norm));\n        else\n        {\n          x = h[i][i + 1];\n          y = h[i + 1][i];\n          q = ((wr[i] - p) * (wr[i] - p)) + (wi[i] * wi[i]);\n          h[i][en] = (t = ((x * s) - (z * r)) / q);\n          h[i + 1][en] = (((x >= 0.) ? (x) : (-x)) > ((z >= 0.) ? (z) : (-z))) ? (((-r) - (w * t)) / x) : (((-s) - (y * t)) / z);\n        }\n\n      }\n\n    }\n\n  }\n  else\n    if (q < 0.)\n  {\n    m = na;\n    if (((h[en][na] >= 0.) ? (h[en][na]) : (-h[en][na])) > ((h[na][en] >= 0.) ? (h[na][en]) : (-h[na][en])))\n    {\n      h[na][na] = (-(h[en][en] - p)) / h[en][na];\n      h[na][en] = (-q) / h[en][na];\n    }\n    else\n    {\n      double c;\n      c = (-h[na][en]) / ((h[na][na] - p) + (q * I));\n      h[na][na] = creal(c);\n      h[na][en] = cimag(c);\n    }\n\n    h[en][na] = 1.;\n    h[en][en] = 0.;\n    for (i = na - 1; i >= 0; i--)\n    {\n      w = h[i][i] - p;\n      ra = h[i][en];\n      sa = 0.;\n      for (j = m; j <= na; j++)\n      {\n        ra += h[i][j] * h[j][na];\n        sa += h[i][j] * h[j][en];\n      }\n\n      if (wi[i] < 0.)\n      {\n        z = w;\n        r = ra;\n        s = sa;\n      }\n      else\n      {\n        m = i;\n        if (wi[i] == 0.)\n        {\n          double c;\n          c = ((-ra) - (sa * I)) / (w + (q * I));\n          h[i][na] = creal(c);\n          h[i][en] = cimag(c);\n        }\n        else\n        {\n          x = h[i][i + 1];\n          y = h[i + 1][i];\n          vr = (((wr[i] - p) * (wr[i] - p)) + (wi[i] * wi[i])) - (q * q);\n          vi = (2. * q) * (wr[i] - p);\n          if ((vr == 0.) && (vi == 0.))\n            vr = (DBL_EPSILON * norm) * ((((((w >= 0.) ? (w) : (-w)) + ((q >= 0.) ? (q) : (-q))) + ((x >= 0.) ? (x) : (-x))) + ((y >= 0.) ? (y) : (-y))) + ((z >= 0.) ? (z) : (-z)));\n\n          {\n            double c;\n            c = ((((x * r) - (z * ra)) + (q * sa)) + (I * (((x * s) - (z * sa)) - (q * ra)))) / (vr + (I * vi));\n            h[i][na] = creal(c);\n            h[i][en] = cimag(c);\n          }\n          if (((x >= 0.) ? (x) : (-x)) > (((z >= 0.) ? (z) : (-z)) + ((q >= 0.) ? (q) : (-q))))\n          {\n            h[i + 1][na] = (((-ra) - (w * h[i][na])) + (q * h[i][en])) / x;\n            h[i + 1][en] = (((-sa) - (w * h[i][en])) - (q * h[i][na])) / x;\n          }\n          else\n          {\n            double c;\n            c = (((-r) - (y * h[i][na])) + (I * ((-s) - (y * h[i][en])))) / (z + (I * q));\n            h[i + 1][na] = creal(c);\n            h[i + 1][en] = cimag(c);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/0"}
{"code": "for (i = 1; i < tend; i++)\n  psum += 2.0 * func(from + (i * h));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rosealexander/parallel-numerical-integration-openmp/Trapezium/4"}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(output[index], binary, 16))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETLMv2_fmt_plug/5"}
{"code": "for (int d_node = 0; d_node < (*dangling_count); d_node++)\n{\n  while (outbound_count[node] != 0)\n  {\n    node++;\n  }\n\n  (*D)[d_node] = node;\n  node++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/6"}
{"code": "for (col = 0; col < 11; col++)\n{\n  readresults(f, value);\n  forward(f, value, neth, outh, neto, outo, E);\n  backward(f, value, neth, outh, neto, outo, E, de, douto, dneto, dE, dEo11, dEo1, dEo22, dEo2, dEt, douth1, dneth1, dE1, dEo111, dneto11, dneto12, dEo222);\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_24/0"}
{"code": "for (int i = 0; i < 16; i++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/loop-1/37"}
{"code": "for (i = 0; i < n; i++)\n  a[i] = rand() % 1000;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MLSTS/ThreadProgramming/OpenMP_ArrayRankSort/1"}
{"code": "for (x = 0; x < diameter; x++)\n{\n  for (y = 0; y < diameter; y++)\n  {\n    if (disk[(x * diameter) + y] == 1)\n      countOnes++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/7"}
{"code": "for (j = 0; j < pcinfo.y_cells_num; j++)\n{\n  send_message_rl[j] = f[(j * pcinfo.x_cells_num) + 0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/3"}
{"code": "for (int it = 0; it < num_itr; it++)\n{\n  for (int i = 1; i < (y_points - 1); i++)\n  {\n    for (int j = 1; j < (x_points - 1); j++)\n    {\n      p_new[i][j] = ((((del_y * del_y) * (p[i][j + 1] + p[i][j - 1])) + ((del_x * del_x) * (p[i + 1][j] + p[i - 1][j]))) - ((((del_x * del_x) * del_y) * del_y) * b[i][j])) / (2 * ((del_x * del_x) + (del_y * del_y)));\n    }\n\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    p_new[i][0] = 0;\n    p_new[i][x_points - 1] = 0;\n  }\n\n  for (int j = 0; j < x_points; j++)\n  {\n    p_new[0][j] = 0;\n    p_new[y_points - 1][j] = 0;\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    for (int j = 0; j < x_points; j++)\n    {\n      p[i][j] = p_new[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Poissons Equation/2-D_Poissons_Equation/main/4"}
{"code": "for (i = 0; i < V; i++)\n{\n  graph[i] = (int *) malloc((sizeof(int)) * V);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zsims92/All-Shortest-Paths-Optimized/allShortestPathsParallel/openmpDS/3"}
{"code": "for (int i = 0; i < NBFS; i++)\n{\n  sum_of_value_mean_diff_square += (value[i] - mean) * (value[i] - mean);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/22"}
{"code": "for (i = 0; i <= n1; i++)\n{\n  for (j = 0; j <= n2; j++)\n  {\n    dvalue = w[i][j];\n    fastcopy(&mem[memcnt], &dvalue, sizeof(float));\n    memcnt += sizeof(float);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/backprop-omp/backprop/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float x = mat[0][i];\n  float sign = (float) pow(-1.0, 2.0 + i);\n  Matrix sub = submatrix(mat, i);\n  det += (sign * x) * det2_seq(sub);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xotonic/parallel-algorithms/mpi-6-determinant/mpi-kal-6/main/0"}
{"code": "for (i = 0; i < L; i++)\n{\n  printf(\"%g\", A[i * M]);\n  for (j = 1; j < M; j++)\n  {\n    printf(\" %g\", A[(i * M) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/20"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  x[i] = 1;\n  check[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TELESIO/OpenMP4.5/example/Prefix Sum/gpu/ps/0"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  eval_multi_UBspline_3d_d(multi_spline, x, y, z, multi_vals);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/8"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    DyDyu[IDX(i, je - 2, k)] = ((u[IDX(i, je - 3, k)] - (2.0 * u[IDX(i, je - 2, k)])) + u[IDX(i, je - 1, k)]) * idy_sqrd;\n    DyDyu[IDX(i, je - 1, k)] = ((((-u[IDX(i, je - 4, k)]) + (4.0 * u[IDX(i, je - 3, k)])) - (5.0 * u[IDX(i, je - 2, k)])) + (2.0 * u[IDX(i, je - 1, k)])) * idy_sqrd;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/19"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  for (k = 0; k < nz; k++)\n  {\n    double *_imopVarPre245;\n    _imopVarPre245 = &u[i][0][k][0];\n    exact(iglob, 0, k, _imopVarPre245);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  cu[1 + (4 * kj)] = zero;\n  cu[4 * k1] = zero;\n  cu[1 + (4 * k1)] = zero;\n  cu[2 + (4 * k1)] = zero;\n  cu[4 * (kj + l1)] = zero;\n  cu[1 + (4 * (kj + l1))] = zero;\n  cu[2 + (4 * (kj + l1))] = zero;\n  cu[4 * (k1 + l1)] = zero;\n  cu[1 + (4 * (k1 + l1))] = zero;\n  cu[2 + (4 * (k1 + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/45"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"a[%d] = %d\\n\", i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/1/shared-clause/2"}
{"code": "for (n = n_start; n <= n_stop; n += 1)\n{\n  int i;\n  for (i = 0; i < dim; ++i)\n  {\n    xdim[i] = sample_interval(a, b);\n  }\n\n  integral += funcL(xdim, dim);\n}\n\n", "pragma": "omp parallel for private(xdim) reduction(+: integral) num_threads(threads_tot)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p1c/0"}
{"code": "for (int i = 0; i < corte; i++)\n{\n  hijo1->imagen[i] = padre1->imagen[i];\n  hijo2->imagen[i] = padre2->imagen[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/0"}
{"code": "for (ii = 0; ii < 10; ii = ii + ((int) 1.1f))\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/25"}
{"code": "for (int i = 0; i < set_1.size(); ++i)\n{\n  if (!contains(set_2, set_1[i]))\n    res.push_back(set_1[i]);\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kiiitG/homework4_openmp/main/3"}
{"code": "for (int k = 0; k < characters_size; k++)\n{\n  if (!m_find)\n  {\n    bruteSequential(characters[k], max);\n  }\n  else\n  {\n    k = characters_size;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jasonjamet/CrackPass/Functions/6"}
{"code": "for (i = 0; i < size; i++)\n{\n  r[i] = b[i] - r[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adamorucu/conjugate-gradient/main/2"}
{"code": "for (unsigned int i = 0; i < ((2048 / NODESX) + 2); i++)\n  gre[i] = got[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/107"}
{"code": "for (int i = 0; i < n; i++)\n{\n  arr[i] = k.arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector/1"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  if (cell(ci).inside_hopper)\n    val += cell(ci).totalKineticEnergy();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/25"}
{"code": "for (i = 0; i < 3; i++)\n  fprintf(fp, \" %10.8f\", TIS_surface_roughness_center_FOV[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/5"}
{"code": "for (i = 0; i < (3 * np); i++)\n{\n  j_vel[i] *= vfactor;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/load_jing/1"}
{"code": "for (int j = i + 1; j < len; j++)\n  if (arr[j] < arr[min])\n  min = j;\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/taya92413/Algorithm-openmp/test/0"}
{"code": "for (; (end - data) >= 20; data += 20)\n{\n  cs[0] ^= cry;\n  in[0] ^= (uint32_t) cs[0];\n  cs[1] ^= cs[0] >> 32;\n  cs[0] = crc64_interleaved_table[0][in[0] & 0xff];\n  in[0] >>= 8;\n  in[1] ^= (uint32_t) cs[1];\n  cs[2] ^= cs[1] >> 32;\n  cs[1] = crc64_interleaved_table[0][in[1] & 0xff];\n  in[1] >>= 8;\n  in[2] ^= (uint32_t) cs[2];\n  cs[3] ^= cs[2] >> 32;\n  cs[2] = crc64_interleaved_table[0][in[2] & 0xff];\n  in[2] >>= 8;\n  in[3] ^= (uint32_t) cs[3];\n  cs[4] ^= cs[3] >> 32;\n  cs[3] = crc64_interleaved_table[0][in[3] & 0xff];\n  in[3] >>= 8;\n  in[4] ^= (uint32_t) cs[4];\n  cry = cs[4] >> 32;\n  cs[4] = crc64_interleaved_table[0][in[4] & 0xff];\n  in[4] >>= 8;\n  for (unsigned b = 1; b < 3; ++b)\n  {\n    cs[0] ^= crc64_interleaved_table[b][in[0] & 0xff];\n    in[0] >>= 8;\n    cs[1] ^= crc64_interleaved_table[b][in[1] & 0xff];\n    in[1] >>= 8;\n    cs[2] ^= crc64_interleaved_table[b][in[2] & 0xff];\n    in[2] >>= 8;\n    cs[3] ^= crc64_interleaved_table[b][in[3] & 0xff];\n    in[3] >>= 8;\n    cs[4] ^= crc64_interleaved_table[b][in[4] & 0xff];\n    in[4] >>= 8;\n  }\n\n  cs[0] ^= crc64_interleaved_table[3][in[0] & 0xff];\n  in[0] = ((const uint32_t *) data)[0];\n  cs[1] ^= crc64_interleaved_table[3][in[1] & 0xff];\n  in[1] = ((const uint32_t *) data)[1];\n  cs[2] ^= crc64_interleaved_table[3][in[2] & 0xff];\n  in[2] = ((const uint32_t *) data)[2];\n  cs[3] ^= crc64_interleaved_table[3][in[3] & 0xff];\n  in[3] = ((const uint32_t *) data)[3];\n  cs[4] ^= crc64_interleaved_table[3][in[4] & 0xff];\n  in[4] = ((const uint32_t *) data)[4];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/crc64-omp/CRC64/1"}
{"code": "for (i = 0; i < 27; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"\\nValue of i is %d and thread ID is %d\", i, id);\n  if (id == 0)\n    t0 = t0 + 1;\n  else\n    if (id == 1)\n    t1 = t1 + 1;\n  else\n    t2 = t2 + 1;\n\n\n}\n\n", "pragma": "omp for schedule(guided,3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pushpinder107/parallel-programming-lab/thread-scheduling/sched3/0"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  long head = edgeListTmp[i].head;\n  long tail = edgeListTmp[i].tail;\n  double weight = edgeListTmp[i].weight;\n  long Where = edgeListPtr[head] + __sync_fetch_and_add(&added[head], 1);\n  edgeList[Where].head = head;\n  edgeList[Where].tail = tail;\n  edgeList[Where].weight = weight;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadPajekFormat/4"}
{"code": "for (i = nbeg + 1; i < nfin; i++)\n{\n  if (fmod(i, 2) == 0)\n    toggl = 2;\n  else\n    toggl = 1;\n\n  for (j = mbeg + toggl; j < mfin; j += 2)\n  {\n    u[i][j] = tmp2 * (((((tmp1 * rhs[i][j]) + u[i - 1][j]) + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared( u, rhs ) private( i, j, toggl ) num_threads(numprocs)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jovubeliveus/PRelax/src_datapar/work/1"}
{"code": "for (int i = 0; i < row; ++i)\n  for (int j = 0; j < col; ++j)\n  t[(row * j) + i] = d[(col * i) + j];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/4"}
{"code": "for (i = 0; i < 8; i++)\n{\n  q = sol->r[i];\n  idiag = i - 1;\n  offset = 1;\n  while (idiag > 0)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      printf(\"updiags false!\\n\");\n      return 0;\n    }\n\n    offset++;\n    idiag--;\n  }\n\n  idiag = i + 1;\n  offset = 1;\n  while (idiag < 8)\n  {\n    q2 = sol->r[idiag];\n    if (((q + offset) == q2) || ((q - offset) == q2))\n    {\n      return 0;\n    }\n\n    offset++;\n    idiag++;\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    q2 = sol->r[j];\n    if (j == i)\n    {\n      continue;\n    }\n\n    if (q2 == q)\n    {\n      printf(\"cols false!\\n\");\n      return 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonaut/8queensOpenMP/hw3/7"}
{"code": "for (i = 0; i < N; i++)\n  b[i] = a[i] * ((double) i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB099-targetparallelfor2-orig-no/0"}
{"code": "for (long long int i = lower; i < upper; i += block_size)\n{\n  for (long long int k = 3; k <= lower; k += 2)\n  {\n    if (primes[k] != 0)\n      continue;\n\n    long long start = i + (k - (i % k));\n    if ((start % 2) == 0)\n      start += k;\n\n    for (long long int j = start; j <= (i + block_size); j += k * 2)\n    {\n      primes[j] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(number_of_threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artalukd/OpenMP-Prime-Sieve/genprimes/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (data[i] == i)\n  {\n    tid = omp_get_thread_num();\n    flag[tid].push_back(i);\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for private(tid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/circle/circle/4"}
{"code": "for (int i = 0; i < numcells; i++)\n{\n  x_n1[i] = x_n[i] + (tau * UFLUX[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(OMP_CORES)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/15"}
{"code": "for (int row = 0; row < height; row++)\n  for (int column = 0; column < width; column++)\n{\n  bufpos = (row * width) + column;\n  newpos = (((height - row) - 1) * psw) + (column * 3);\n  newbuf[newpos] = Buffer[bufpos];\n  newbuf[newpos + 1] = Buffer[bufpos];\n  newbuf[newpos + 2] = Buffer[bufpos];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moreflexible/openMpi/filter/1"}
{"code": "for (int i = 0; i < MAX_POINTS; i++)\n{\n  clusters[i] = label_point(points[i], centroids, K);\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Plutone11011/ParallelKMEANS/kmeans/2"}
{"code": "for (int i = 0; i < n_ysize; i++)\n{\n  for (int j = 0; j < n_xsize; j++)\n  {\n    int id = p_data[(i * n_xsize) + j];\n    if (nodata_value != id)\n    {\n      if (bbox_map.find(id) == bbox_map.end())\n      {\n        bbox_map[id] = SubBasin(j, i, j, i);\n      }\n      else\n      {\n        if (j < bbox_map[id].x_min)\n        {\n          bbox_map[id].x_min = j;\n        }\n        else\n          if (j > bbox_map[id].x_max)\n        {\n          bbox_map[id].x_max = j;\n        }\n\n\n        if (i > bbox_map[id].y_max)\n        {\n          bbox_map[id].y_max = i;\n        }\n\n      }\n\n      bbox_map[id].cell_count += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/import_raster/import_raster/0"}
{"code": "for (i = 0; i < image->row; i++)\n{\n  for (j = 0; j < image->col; j++)\n  {\n    long idx = image->content[i][j];\n    omp_set_lock(&lck[idx]);\n    histo[idx]++;\n    omp_unset_lock(&lck[idx]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JingruGao09/OpenMP_Performance/histogram_locks/histo_locks/0"}
{"code": "for (n = 0; (n <= iterations) && (!quality_achived); n++)\n{\n  time = n * input.dT;\n  update_points_position_by_time(dev_my_points, my_points, my_num_of_points, time);\n  kmeans(rank, clusters, &input, my_points, my_num_of_points, dev_my_points, dev_clusters, dev_point_moved_flag);\n  gather_all_points(all_points, input.N, my_points, my_num_of_points, rank, numprocs, &MPI_Point_type);\n  if (rank == MASTER)\n  {\n    evaluate_clusters_quality(&quality, clusters, all_points, &input);\n    quality_achived = (quality < input.QM) ? (1) : (0);\n  }\n\n  MPI_Bcast(&quality_achived, 1, MPI_INT, MASTER, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RanWeiner/Parallel_K_Means/Parallel_K_Means/Parallel_K_Means/K_Means/0"}
{"code": "for (int kk = 0; kk < 20; kk++)\n  ;\n\n", "pragma": "#pragma omp target parallel for is_device_ptr ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/target_parallel_for_is_device_ptr_messages/1"}
{"code": "for (ii = 0; ii < 10; ii++)\n  for (jj = 0; jj < 10; jj++)\n  c[ii] = a[jj];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/simd_loop_messages/0"}
{"code": "for (i = 1; i <= nt; i++)\n{\n  err = (get_real(sums[i]) - vdata_real_a[i]) / vdata_real_a[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = FALSE;\n    break;\n  }\n\n  err = (get_imag(sums[i]) - vdata_imag_a[i]) / vdata_imag_a[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = FALSE;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/FT/ft/19"}
{"code": "for (size_t i = 0; i < N; i++)\n{\n  float *row = BOLD + (i * L);\n  float sum1 = 0;\n  float sum2 = 0;\n  for (size_t l = 0; l < L; l++)\n  {\n    sum1 += row[l];\n  }\n\n  sum1 /= L;\n  for (size_t l = 0; l < L; l++)\n  {\n    sum2 += (row[l] - sum1) * (row[l] - sum1);\n  }\n\n  sum2 = sqrt(sum2);\n  for (size_t l = 0; l < L; l++)\n  {\n    if (sum2 != 0)\n    {\n      row[l] = (row[l] - sum1) / sum2;\n    }\n    else\n    {\n      if (sum2 == 0)\n      {\n        row[l] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carloradice/Fast-GPU-PCC-cuda-openmp-implementation/c-openmp/CPU_side/3"}
{"code": "for (int k = 0; k < 100; k++)\n{\n  b[k] = k;\n}\n\n", "pragma": "omp target parallel for simd aligned(b: 8*sizeof(int))", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/omptests/t-target-parallel-for-simd-clauses/test/0"}
{"code": "for (i = HIgh_h / 2; i < HIgh_h; i++)\n{\n  for (j = Low_w / 4; j < (Low_w / 2); j++)\n  {\n    bicubic_Y[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Y[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Y_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Y_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Y_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Y_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cb[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cb_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cb_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cb_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cb_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + ((2 * j) - 1)] = floor((((bicubic2[1][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[1][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[1][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[1][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n    bicubic_Cr[(i * HIgh_w) + (2 * j)] = floor((((bicubic2[0][0] * bicubic_Cr_temp[((i * Low_w) + j) - 2]) + (bicubic2[0][1] * bicubic_Cr_temp[((i * Low_w) + j) - 1])) + (bicubic2[0][2] * bicubic_Cr_temp[(i * Low_w) + j])) + (bicubic2[0][3] * bicubic_Cr_temp[((i * Low_w) + j) + 1]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/14"}
{"code": "for (i = 0; i < n; i += 1)\n  for (j = 0; j < n; j += 1)\n  fscanf(in, \"%d\", &year[0].P[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elf11/Parallel-Processing/OpenMP/paralel/3"}
{"code": "for (int kk = n; kk < (n + (nbh / 2)); kk++)\n{\n  if ((jj * dx) > (L + ((2 * bt) * dx)))\n  {\n    ii++;\n    jj = 0;\n  }\n\n  x[kk] = space2 + (jj * dx);\n  y[kk] = space2 + (ii * dx);\n  jj++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/9"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  omp_destroy_lock(&locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/19"}
{"code": "for (int i = 0; i < 26; i++)\n{\n  m = i;\n  for (int j = 0; j < 26; j++)\n  {\n    if (m <= 25)\n    {\n      a[i][j] = m + 97;\n      m++;\n    }\n    else\n    {\n      a[i][j] = 97;\n      m = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranavshah029/Parallelizing-Decryption-Alogirthm/parallel_decryption/1"}
{"code": "for (i = 0; i < n_stp; i++)\n{\n  x = (i + 0.5) * dx;\n  pi += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for reduction (+:pi) schedule(guided) nowait", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pf4d/intel_openmp/02/parallel_calc_pi/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = (i * (i + 1)) / 2;\n  printf(\"a[%d] = %d\\n\", i, a[i]);\n}\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Gildson/openMP/questao8/0"}
{"code": "for (int i = 0; i < hist.getSize(); ++i)\n{\n  h.setDataOnIndex(i, hist.getData(i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/samuelm00/openMp/pc/ex2/task2/histogram/2"}
{"code": "for (i = 1; i < dim; i++)\n  q += fabs(mat[0][i] / mat[0][0]);\n\n", "pragma": "omp for reduction(+:q)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jr/jacobi_omp/1"}
{"code": "for (i = a; i <= b; i++)\n{\n  if (i < 10000)\n  {\n  }\n\n  for (j = i; j < (b + 2); j++)\n  {\n    if (j < 10000)\n      if (p[i] >= p[j])\n    {\n      int temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n    }\n\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shaheryar3969/OSproject/mergeop/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  printf(\"%lf\\n\", X[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KotaIkehara/parallel-matvec/main/4"}
{"code": "for (int i = 1; i < length; ++i)\n{\n  IP[i] = IP[i - 1] + fabs(PhaseAngle[i - 1] - PhaseAngle[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/23"}
{"code": "for (int j = 0; j < nCols; j++)\n{\n  arrayC[i][j] = 0.0f;\n  for (int k = 0; k < nCols; k++)\n  {\n    arrayC[i][j] += arrayA[i][k] * arrayB[k][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/MatrixOperations/MatrixOperations/MatrixMult/2"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    energy1[FTNREF2D(j, y_max + k, x_max + 4, x_min - 2, y_min - 2)] = energy1[FTNREF2D(j, (y_max + 1) - k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/13"}
{"code": "for (j = i; j < ((i + blockSize) - 2); j++)\n{\n  b[j] -= (A[j][i - 2] * y[i - 2]) + (A[j][(i + blockSize) - 1] * y[(i + blockSize) - 1]);\n  y[j] = b[j] / A[j][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/parallel/ParallelSweepMethod/9"}
{"code": "for (i = 0; i < N; i++)\n  free(adjMat[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/savvpais/omp-pagerank/pageRankGSOMP/6"}
{"code": "for (int i = 0; i < nodes_num; ++i)\n{\n  {\n    fib(node->data());\n  }\n  node = node->next();\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_linked_list_traversal/c4/calculate/0"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] *= alpha;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/16"}
{"code": "for (int p = 0; p < (k - 1); p++)\n{\n  sum += L[i - 1][p] * U[p][k - 1];\n}\n\n", "pragma": "                    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvillegasm/NuMath/src/systemsOfEquations/directFactoring/croutMethod/1"}
{"code": "for (int i = 0; i < max_iter; i++)\n{\n  sub_r_old = sub_r;\n  alpha_num_old = alpha_num;\n  matrix_multiply_vector_openmp(sub_A, p, vec_sub_A_multiply_by_p);\n  denominator_alpha = dot_product_mpi(sub_p, vec_sub_A_multiply_by_p);\n  alpha = alpha_num / denominator_alpha;\n  vec_lin_combo(1.0, sub_x, alpha, sub_p, result1);\n  sub_x = result1;\n  vec_lin_combo(1.0, sub_r, -alpha, vec_sub_A_multiply_by_p, result2);\n  sub_r = result2;\n  alpha_num = dot_product_mpi(sub_r, sub_r);\n  if (vector_norm(sub_r) < tolerance)\n  {\n    if (prank == 0)\n    {\n      ((cout << \"Converged at iter = \") << i) << endl;\n    }\n\n    total_iters = i;\n    break;\n  }\n\n  beta = alpha_num / alpha_num_old;\n  vec_lin_combo(1.0, sub_r, beta, sub_p, result3);\n  sub_p = result3;\n  MPI_Allgatherv(&sub_p.front(), row_cnt[prank], MPI_DOUBLE, &p.front(), row_cnt, row_disp, MPI_DOUBLE, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicolaslesimple/Hybrid-MPI-OpenMP-Conjugate-Gradient-Algorithm/conj_grad_solve/2"}
{"code": "for (i = 0; i < local_n0; i++)\n  for (j = 0; j < N; j++)\n  for (k = 0; k < N; k++)\n{\n  const int z = ((((i * N) + j) * 2) * Nf) + k;\n  U[z] = (sin(dx * (i + local_0_start)) * cos(dx * j)) * cos(dx * k);\n  V[z] = ((-cos(dx * (i + local_0_start))) * sin(dx * j)) * cos(dx * k);\n  W[z] = 0.0;\n}\n\n\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/3"}
{"code": "for (i = 0; i < CACHE_SIZE; i++)\n  cache[i] = (cache[i] + i) % 256;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testvrinke/6"}
{"code": "for (int k = 0; k < 30; k++)\n{\n  double btm3_start = wtime();\n  for (int source = 0; source < V; ++source)\n  {\n    cc(source, g);\n  }\n\n  btm3_sum += wtime() - btm3_start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenghangyu/openmp-small-graph-project/main/2"}
{"code": "for (j = 0; j < num_snakes; j++)\n{\n  snakes[j].tail.line = snakes[j].prev_tail.line;\n  snakes[j].tail.col = snakes[j].prev_tail.col;\n  world[snakes[j].tail.line][snakes[j].prev_tail.col] = snakes[j].encoding;\n  world[snakes[j].head.line][snakes[j].head.col] = snakes[j].collided_into;\n  if (snakes[j].direction == 'N')\n    snakes[j].head.line = (snakes[j].head.line + 1) % num_lines;\n\n  if (snakes[j].direction == 'S')\n    snakes[j].head.line = ((snakes[j].head.line - 1) + num_lines) % num_lines;\n\n  if (snakes[j].direction == 'V')\n    snakes[j].head.col = (snakes[j].head.col + 1) % num_cols;\n\n  if (snakes[j].direction == 'E')\n    snakes[j].head.col = ((snakes[j].head.col - 1) + num_cols) % num_cols;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nix151515/Parallel-snake/parallel_snake/5"}
{"code": "for (int i = 0; i < numItems; i++)\n{\n  int item = start_index + i;\n  for (int j = 0; j < CLUSTERS; j++)\n  {\n    g[item][j] = (2 * LAMBDA) * items[item][j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cb1711/RecommenderSystem/src/gradient/0"}
{"code": "for (int process_iter = 0; process_iter < processes_count; process_iter++)\n{\n  chunk_size[process_iter] += 1;\n  remaining_blocks--;\n  if (remaining_blocks == 0)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/angelos-sp/pad_auth_4/pad4_MPI_OMP/4"}
{"code": "for (i = 1; i < 4; ++i)\n{\n  if (container[i] > temp)\n  {\n    temp = container[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main_fast3/0"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  changement = 0;\n  for (int i = 1; i < (GRAIN + 1); i += 1)\n    for (int j = 1; j < (GRAIN + 1); j += 1)\n  {\n    ;\n    if (!tab_unstable[(i * (GRAIN + 2)) + j])\n    {\n      if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n        tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n    }\n    else\n    {\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n      changement += tab_unstable[(i * (GRAIN + 2)) + j];\n    }\n\n  }\n\n\n  if (changement == 0)\n    return it;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/36"}
{"code": "for (int i = 0; i < N2; i++)\n{\n  for (int j = 0; j < N2; j++)\n  {\n    nextGen[i][j] = table[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnstephenson39/gameoflife_openmp/gol/3"}
{"code": "for (i = 0; i < k; ++i)\n{\n  weights[i] += (alpha * sign) * point[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yotamMoshe7/C-Classification-Problem-Precepton/MPI_OMP_CUDA/PerceptronClassification/2"}
{"code": "for (int i = 0; i < mat_size; i++)\n{\n  printf(\"%f\\n\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/Programming-for-Numerical-Computation/6/Gauss_Elimination/main/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  k[i] = 0.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMP/6"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    if (obstacles[ii + (jj * params.nx)])\n    {\n      u_x = (u_y = (u = 0.f));\n      pressure = params.density * c_sq;\n    }\n    else\n    {\n      local_density = 0.f;\n      for (int kk = 0; kk < 9; kk++)\n      {\n        local_density += cells[((kk * params.ny) * params.nx) + (ii + (jj * params.nx))];\n      }\n\n      u_x = (((cells[((1 * params.ny) * params.nx) + (ii + (jj * params.nx))] + cells[((5 * params.ny) * params.nx) + (ii + (jj * params.nx))]) + cells[((8 * params.ny) * params.nx) + (ii + (jj * params.nx))]) - ((cells[((3 * params.ny) * params.nx) + (ii + (jj * params.nx))] + cells[((6 * params.ny) * params.nx) + (ii + (jj * params.nx))]) + cells[((7 * params.ny) * params.nx) + (ii + (jj * params.nx))])) / local_density;\n      u_y = (((cells[((2 * params.ny) * params.nx) + (ii + (jj * params.nx))] + cells[((5 * params.ny) * params.nx) + (ii + (jj * params.nx))]) + cells[((6 * params.ny) * params.nx) + (ii + (jj * params.nx))]) - ((cells[((4 * params.ny) * params.nx) + (ii + (jj * params.nx))] + cells[((7 * params.ny) * params.nx) + (ii + (jj * params.nx))]) + cells[((8 * params.ny) * params.nx) + (ii + (jj * params.nx))])) / local_density;\n      u = sqrtf((u_x * u_x) + (u_y * u_y));\n      pressure = local_density * c_sq;\n    }\n\n    fprintf(fp, \"%d %d %.12E %.12E %.12E %.12E %d\\n\", ii, jj, u_x, u_y, u, pressure, obstacles[(ii * params.nx) + jj]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ainsleyrutterford/HPC-OpenCL/openmp_d2q9-bgk/5"}
{"code": "for (int i = 0; i < numNodes; ++i)\n{\n  solution[i] = equal_prob;\n  score_new[i] = 0.0;\n  if (outgoing_size(g, i) == 0)\n  {\n    index = __sync_fetch_and_add(&no_counter, 1);\n    no_outgoing_nodes[index] = i;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank - C\u00f3pia/page_rank/0"}
{"code": "for (i = 1; i <= n; i++)\n{\n  ihi = ihi * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/13"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n{\n  for (int j = 0; j < sizeOfItems; ++j)\n  {\n    if ((neighbor[i] != 0) && (neighbor[j] != 0))\n    {\n      weights[i][j] = (1.0 * collab[i][j]) / sqrt(neighbor[i] * neighbor[j]);\n    }\n    else\n    {\n      weights[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/serial/0"}
{"code": "for (int i = 0; i < nodeNum; i++)\n{\n  if ((visited[i] == NODE_VISITED) || (i == curNode))\n    continue;\n\n  if (edges[curNode][i] != NO_EDGE_BEWTEEN)\n  {\n    if ((disFromStart[i] == UNKNOWN_DISTANCE) || (disFromStart[i] > (curDis + edges[curNode][i])))\n    {\n      disFromStart[i] = curDis + edges[curNode][i];\n      prevNode[i] = curNode;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chwang1996/Dijkstra_parallel/Dijkstra-openmp/1"}
{"code": "for (int k = 0; k < 5; k++)\n{\n  printf(\"%d \\n\", result[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FinelifeX/openmp-tasks/block2/task8/1"}
{"code": "for (int i = 1; i <= (n - 2); i = i + 2)\n{\n  if (arr2[i] > arr2[i + 1])\n  {\n    swap(arr2[i], arr2[i + 1]);\n    isSorted = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/odd_even/2"}
{"code": "for (i = 1; i < 9; i++)\n{\n  x_temp = mov[0][i - 1] + pos_x;\n  y_temp = mov[1][i - 1] + pos_y;\n  if (((((x_temp < n) && (x_temp >= 0)) && (y_temp < m)) && (y_temp >= 0)) && (fricc[y_temp][x_temp] > 0.0))\n  {\n    count++;\n    if ((i % 2) != 0)\n    {\n      array[i - temp_temp].val_fricc = fricc[y_temp][x_temp];\n      array[i - temp_temp].x = x_temp;\n      array[i - temp_temp].y = y_temp;\n    }\n    else\n    {\n      array[i - temp_temp].val_fricc = sqrt(2) * fricc[y_temp][x_temp];\n      array[i - temp_temp].x = x_temp;\n      array[i - temp_temp].y = y_temp;\n    }\n\n  }\n  else\n  {\n    temp_temp++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(i,x_temp,y_temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/cost_dist/3"}
{"code": "for (int g = 0; g < number; g++)\n{\n  x = ((((2.0 * g) * 1.0) - 1.0) / h) * 1.0;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "#pragma omp for schedule(guided, 10) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vkalmykov/lab3openmp/lab3openmp/lab3openmp/0"}
{"code": "for (uint j = 0; j < line.length(); j++)\n{\n  if (line[j] == 'O')\n  {\n    grid.insert((i + (width / 2)) - (centering / 2), (j + (height / 2)) - (centering / 2), aliveValue);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DaveR27/Game-of-Life/Parallel/gameOfLife/3"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 300; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < 200; k++)\n    {\n      result[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Songrui9269/Parallel-Programming-Project-1/step1 matrix multiply openMP/0"}
{"code": "for (c = 1; c <= channels_col; ++c)\n{\n  int w_offset = c % ksize;\n  int h_offset = ((c / ksize) % ksize) + 1;\n  if (w_offset == 0)\n  {\n    w_offset = ksize;\n    h_offset--;\n  }\n\n  if (h_offset == 0)\n    h_offset = ksize;\n\n  int c_im = ((c - 1) / ksize) / ksize;\n  for (h = 0; h < height_col; ++h)\n  {\n    for (w = 0; w < width_col; ++w)\n    {\n      int im_row = (h_offset * dilate_rate) + (h * stride);\n      int im_col = (w_offset * dilate_rate) + (w * stride);\n      int col_index = ((((c - 1) * height_col) + h) * width_col) + w;\n      double val = data_col[col_index];\n      printf(\"%d \", col_index);\n      col2im_add_pixel_dilated(data_im, height, width, channels, im_row, im_col, c_im, pad, val);\n    }\n\n    printf(\"\\n\");\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/im2col/1"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    register float temp = C[(i * ldc) + j];\n    for (k = 0; k < K; ++k)\n    {\n      temp += (alpha * A[(i * lda) + k]) * B[(k * ldb) + j];\n    }\n\n    C[(i * ldc) + j] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/0-frameworks/cux/src/operator/gemm/1"}
{"code": "for (int i = 0; i < r; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    a[i][j] = rand() % 100;\n    b[i][j] = rand() % 100;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ajit-Kumar/Concurrent_Programming/matrix/1"}
{"code": "for (j = 0; j < n; j++)\n{\n  for (k = 0; k < n; k++)\n  {\n    c[i][j] += a[i][k] * b[k][j];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chahak13/HPC/Lab4/201501005-201501422-matrix_multiplication-middle/parallel_measurement/0"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  SHA_CTX ctx;\n  MD5_CTX mctx;\n  unsigned char hexhash[32];\n  unsigned char hash[16];\n  unsigned char out[20];\n  MD5_Init(&mctx);\n  MD5_Update(&mctx, cur_salt->username, strlen((char *) cur_salt->username));\n  MD5_Update(&mctx, \":mongo:\", 7);\n  MD5_Update(&mctx, saved_key[index], strlen(saved_key[index]));\n  MD5_Final(hash, &mctx);\n  hex_encode(hash, 16, hexhash);\n  pbkdf2_sha1(hexhash, 32, cur_salt->salt, 16, cur_salt->iterations, out, 20, 0);\n  hmac_sha1(out, 20, (unsigned char *) \"Client Key\", 10, out, 20);\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, out, 20);\n  SHA1_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mongodb_scram_fmt_plug/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  ((((cout << \"Distance # \") << i) << \" : \") << list[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac3/EulerTour_EREW_OpenMP/6"}
{"code": "for (c = 0; c < k; c++)\n{\n  clusters[c].numDatapoints = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/9"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%f\\t\", X[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/Matrix_ops/6"}
{"code": "for (m = 0; m < 3; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = grid_points[2] - 3; k >= 0; k--)\n      {\n        k1 = k + 1;\n        k2 = k + 2;\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j][k1])) - (lhs[n + 4][i][j][k] * rhs[m][i][j][k2]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k1, k2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/116"}
{"code": "for (long i = 0; i < KK; ++i)\n{\n  wrapper((void *) (i + 1));\n}\n\n", "pragma": "   #pragma omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/hip-openmp/aomp_hip_launch_test/hiplaunch/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] += alpha * b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu/4"}
{"code": "for (i = 0; i < (channels * overlapLength); i += 4)\n{\n  corr += ((mixingPos[i] * compare[i]) + (mixingPos[i + 1] * compare[i + 1])) >> overlapDividerBitsNorm;\n  corr += ((mixingPos[i + 2] * compare[i + 2]) + (mixingPos[i + 3] * compare[i + 3])) >> overlapDividerBitsNorm;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/branches/OpenMPT-1.25/include/soundtouch/source/SoundTouch/TDStretch/3"}
{"code": "for (int j = pow(2, i) - 1; j < finishposition; j++)\n{\n  if (j == 0)\n    b->tab[j] = 0;\n  else\n    if ((j % 2) == 1)\n    b->tab[j] = b->tab[(j - 1) / 2];\n  else\n    b->tab[j] = b->tab[(j - 2) / 2] + a->tab[j - 1];\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/2"}
{"code": "for (int i = 0; i < weeksNo; i++)\n{\n  localLethalAccidentsData[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/0"}
{"code": "for (i = starti; i < rows; i++)\n{\n  for (j = 0; j < NY; j++)\n  {\n    x = xmin + (i * dx);\n    y = ymin + (j * dy);\n    if (world_rank == 0)\n    {\n      iters_s[(((WIDTH / world_size) - (rows - i)) * WIDTH) + j] = Mandelbrot_Member(x, y);\n    }\n    else\n    {\n      iters[(((WIDTH / world_size) - (rows - i)) * WIDTH) + j] = Mandelbrot_Member(x, y);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(NUM_THREADS) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mareckste/mandelbrot_set/sources/mandelbrot_openmp_mpi_opengl/2"}
{"code": "for (i = 0; i <= xDim; i++)\n{\n  free(matrix[i]);\n  free(matrix1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varunsharma0286/LaplaceEquation/Openmp Solution/parallel/3"}
{"code": "for (int i = 0; i < n; ++i)\n  printf(\"%d \\t\\t %ld\\n\", i, dist[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/argha072k/openmp/path/1"}
{"code": "for (i = 0; i < (1 << 19); i++)\n{\n  prv_buff1[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/4"}
{"code": "for (i = 0; i < 8; i++)\n  for (j = 0; j < 8; j++)\n{\n  c = c + (b != ((7 + (2 * j)) + ((2 * 8) * i)));\n  b = b + 2;\n}\n\n\n", "pragma": "omp parallel for simd lastprivate (i, j) collapse (2) schedule (static, 4) linear(b:2) reduction(+:c)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-14/2"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (NX / 2)) % NX) - (NX / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (NY / 2)) % NY) - (NY / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (NZ / 2)) % NZ) - (NZ / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i ,j ,k ,ii ,ii2 ,jj ,ij2 ,kk )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/0"}
{"code": "for (int i = 0; i < NTIMES; i++)\n{\n  x[i] = (((((double) rand()) / 32767) * (((double) rand()) / 32767)) * (((double) rand()) / 32767)) * 1000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/false_sharing/1"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_teams); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/16"}
{"code": "for (unsigned i = 0; i < n; ++i)\n{\n  a[i] = numb;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (0 != strncmp((const char *) p, seqs.ptr(i), seqs.length(i)))\n  {\n    printf(\"error at i=%d  length=%zu\\n\", i, seqs.length(i));\n    printf(\"host=\");\n    char *s = seqs.ptr(i);\n    for (int j = 0; j < seqs.length(i); j++)\n    {\n      printf(\"%02d\", s[j]);\n    }\n\n    printf(\"\\ndevice=\");\n    for (int j = 0; j < seqs.length(i); j++)\n      printf(\"%02d\", *((seqs_device + (i * 33)) + j));\n\n    printf(\"\\n\");\n    error++;\n  }\n\n  p += seqs.length(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/diamond-omp/masking/14"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  for (int j = 0; j < command_line_args.seq_len; j++)\n  {\n    (cout << m_arrays[i][j]) << '\\t';\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/8"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dE[col] = (de[col] * douto[col]) * dneto[col];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/12"}
{"code": "for (int i = 0; i < rows; ++i)\n  for (int j = 0; j < columns; ++j)\n  m[(i * columns) + j] = i + j;\n\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KlausDornsbach/OpenMP/atividade_7/exercicio_2/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    up = i - 1;\n    down = i + 1;\n    left = j - 1;\n    right = j + 1;\n    if ((i == (N - 1)) && (j != (N - 1)))\n    {\n      down = 0;\n    }\n    else\n      if (((j == (N - 1)) && (i != (N - 1))) && (i != 0))\n    {\n      right = 0;\n    }\n    else\n      if (((i == 0) && (j != 0)) && (j != (N - 1)))\n    {\n      up = N - 1;\n    }\n    else\n      if ((j == 0) && (i != 0))\n    {\n      left = N - 1;\n    }\n    else\n      if ((j == 0) && (i == 0))\n    {\n      up = N - 1;\n      left = N - 1;\n    }\n    else\n      if ((i == (N - 1)) && (j == (N - 1)))\n    {\n      down = 0;\n      right = 0;\n    }\n    else\n      if ((i == (N - 1)) && (j == 0))\n    {\n      left = N - 1;\n      down = 0;\n    }\n    else\n      if ((i == 0) && (j == (N - 1)))\n    {\n      right = 0;\n      up = N - 1;\n    }\n    else\n      if ((i == 0) && (j == 0))\n    {\n      up = N - 1;\n      left = N - 1;\n    }\n\n\n\n\n\n\n\n\n\n    matrixn[i][j] = (.25 * (((matrixn1[down][j] + matrixn1[up][j]) + matrixn1[i][right]) + matrixn1[i][left])) - (d * ((u * (matrixn1[down][j] - matrixn1[up][j])) + (v * (matrixn1[i][right] - matrixn1[i][left]))));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, up, down, left, right)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stvschmdt/Advection_Parallel/ompAF/0"}
{"code": "for (long long tid = 0; tid < (nx * ny); tid++)\n{\n  float randval = randvals[tid];\n  signed char val = (randval < 0.5f) ? (-1) : (1);\n  lattice[tid] = val;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd thread_limit(THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ising-omp/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((arr[i] >> idx) & (1 == 1))\n  {\n    flag[i] = 1;\n  }\n  else\n  {\n    flag[i] = 0;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for num_threads(THREAD_COUNT)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fadhrigabestari/openmp/myradix/8"}
{"code": "for (m = 0; m < 5; m++)\n{\n  pxi = ((1.0 - xi) * ue_1jk[m]) + (xi * ue_nx0jk[m]);\n  peta = ((1.0 - eta) * ue_i1k[m]) + (eta * ue_iny0k[m]);\n  pzeta = ((1.0 - zeta) * ue_ij1[m]) + (zeta * ue_ijnz[m]);\n  u[i][j][k][m] = (((((pxi + peta) + pzeta) - (pxi * peta)) - (peta * pzeta)) - (pzeta * pxi)) + ((pxi * peta) * pzeta);\n}\n\n", "pragma": "omp parallel for firstprivate(pxi ,peta ,pzeta ,xi ,eta ,zeta ,m ,i ,k ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/92"}
{"code": "for (i = 0; i < res.get_size(); ++i)\n{\n  res[i] = first[i] - second[i];\n}\n\n", "pragma": "    #pragma omp parallel for shared(first, second, res) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tiana721/openMP/VectorHor/2"}
{"code": "for (long i = 0; i < NV; i++)\n  added[i] = 0;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadDimacs/4"}
{"code": "for (i = 0; i < (c1.sequence.length() - 1); i++)\n{\n  char ch1 = umap1[c1.sequence[i]];\n  char ch2 = umap2[c1.sequence[i]];\n  if (alreadyContains.find(ch1) != alreadyContains.end())\n  {\n    if (alreadyContains.find(ch2) != alreadyContains.end())\n    {\n      int rIndex = rand() % gGlobal.NumCities;\n      while (alreadyContains.find(p1.sequence[rIndex]) != alreadyContains.end())\n        rIndex = rand() % gGlobal.NumCities;\n\n      c1.sequence[i + 1] = p1.sequence[rIndex];\n      alreadyContains.insert(p1.sequence[rIndex]);\n    }\n    else\n    {\n      c1.sequence[i + 1] = ch2;\n      alreadyContains.insert(ch2);\n    }\n\n  }\n  else\n    if (alreadyContains.find(ch2) != alreadyContains.end())\n  {\n    c1.sequence[i + 1] = ch1;\n    alreadyContains.insert(ch1);\n  }\n  else\n  {\n    int id = getIDFromChar(c1.sequence[i]) - 1;\n    int id1 = getIDFromChar(ch1) - 1;\n    int id2 = getIDFromChar(ch2) - 1;\n    double distance1 = gGlobal.distances[id][id1];\n    double distance2 = gGlobal.distances[id][id2];\n    if (distance1 > distance2)\n    {\n      c1.sequence[i + 1] = ch2;\n      alreadyContains.insert(ch2);\n    }\n    else\n    {\n      c1.sequence[i + 1] = ch1;\n      alreadyContains.insert(ch1);\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akshittyagi/tsp/main/11"}
{"code": "for (i = 0; i < n; i++)\n{\n  arr.push_back((rand() % n) + 1);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(2) sections", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rybchanivskyi/OpenMP-MPI-quickSort/quickSortOpenMP/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float x = a + ((i + 0.5) * ((b - a) / n));\n  if (atoi(argv[1]) == 1)\n  {\n    sum = sum + (f1(x, intensity) * ((b - a) / n));\n  }\n  else\n    if (atoi(argv[1]) == 2)\n  {\n    sum = sum + (f1(x, intensity) * ((b - a) / n));\n  }\n  else\n    if (atoi(argv[1]) == 3)\n  {\n    sum = sum + (f1(x, intensity) * ((b - a) / n));\n  }\n  else\n    if (atoi(argv[1]) == 4)\n  {\n    sum = sum + (f1(x, intensity) * ((b - a) / n));\n  }\n\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: sum) schedule(runtime)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EBcoder/openMP/numint/0"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (n - 1); j++)\n  {\n    wp[i][j] = 0.25 * (((up[i - 1][j] + up[i + 1][j]) + up[i][j - 1]) + up[i][j + 1]);\n    if (my_diff[tid] < fabs(wp[i][j] - up[i][j]))\n      my_diff[tid] = fabs(wp[i][j] - up[i][j]);\n\n  }\n\n}\n\n", "pragma": "omp for schedule(OMP_SCHED)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/Jacobi/2"}
{"code": "for (i = 1; i < n; i++)\n  b[i] = (a[i] + a[i - 1]) / 2.0;\n\n", "pragma": " #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/nowait/0"}
{"code": "for (j = 0; j < m; j++)\n{\n  double qv_j = 0.0;\n  for (k = i; k < m; k++)\n  {\n    qv_j += q[(j * m) + k] * u[k - i];\n  }\n\n  for (k = i; k < m; k++)\n  {\n    q[(j * m) + k] -= (2.0 * qv_j) * u[k - i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/13"}
{"code": "for (int i = 0; i < (((ancho * 3) + pivot) * alto); i += 3)\n{\n  b = *(arr_in + i);\n  g = *((arr_in + i) + 1);\n  r = *((arr_in + i) + 2);\n  unsigned char pixel = ((0.21 * r) + (0.72 * g)) + (0.07 * b);\n  arr_gray[index].b = pixel;\n  arr_gray[index].g = pixel;\n  arr_gray[index].r = pixel;\n  index++;\n  count += 3;\n  if (count == (ancho * 3))\n  {\n    i += pivot;\n    count = 0;\n  }\n\n}\n\n", "pragma": "omp for ordered schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/A01021190/IoTTutorialIan/schedule/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  sumWeights += weights[x];\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sumWeights)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/5"}
{"code": "for (int j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    vol_flux_x[FTNREF2D(j, 1 - k, x_max + 5, x_min - 2, y_min - 2)] = vol_flux_x[FTNREF2D(j, 1 + k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/44"}
{"code": "for (unsigned int i = 0; i < total_cells; i++)\n{\n  fprintf(stdout, \"%u %u %u\\n\", CELL_X(all_cells[i]), CELL_Y(all_cells[i]), CELL_Z(all_cells[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/diogocp/life3d/life3d-mpi/3"}
{"code": "for (i = 0; i < 3; ++i)\n{\n  newCamPos[i] += (oldCamPos[i] - newCamPos[i]) * g_inertia;\n  newCamRot[i] += (oldCamRot[i] - newCamRot[i]) * g_inertia;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SafaeOuajih/CollidingGalaxies/Codes/03_opengl_us3/src/main/7"}
{"code": "for (int n = 1 << 10; n <= (1 << 25); n <<= 1)\n{\n  time = bench(n);\n  gflop = (2.0 * n) * 1.0e-9;\n  double flops = gflop / time;\n  throughput = (((5.0 * n) * (sizeof(double))) * 1.0e-9) / time;\n  printf(\"Software Caclulation N=%d:\\n\\t%.3f GFLOP/s\\n\\t%.3f GB/s\\n\", n, flops, throughput);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/breiters/papi_omp_util/examples/triad/1"}
{"code": "for (int i = j; i < (j + blockSize); i++)\n{\n  A[i] += B[i] + C[i];\n  if (i < (j + 3))\n    printf(\"inner %f %f %f\\n\", B[i], C[i], A[i]);\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_loop/nested_loop/0"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  kinE += ((v[i][0] * v[i][0]) + (v[i][1] * v[i][1])) + (v[i][2] * v[i][2]);\n}\n\n", "pragma": "omp parallel for reduction(+:kinE) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/0"}
{"code": "for (i = 1; i < (n + 1); i++)\n{\n  for (j = 1; j < (n + 1); j++)\n  {\n    for (k = 1; k < (n + 1); k++)\n    {\n      a1[(((i * size) * size) + (j * size)) + k] = (((((((((((((((((((((((((a0[(((i * size) * size) + ((j - 1) * size)) + k] + a0[(((i * size) * size) + ((j + 1) * size)) + k]) + a0[((((i - 1) * size) * size) + (j * size)) + k]) + a0[((((i + 1) * size) * size) + (j * size)) + k]) + a0[((((i - 1) * size) * size) + ((j - 1) * size)) + k]) + a0[((((i - 1) * size) * size) + ((j + 1) * size)) + k]) + a0[((((i + 1) * size) * size) + ((j - 1) * size)) + k]) + a0[((((i + 1) * size) * size) + ((j + 1) * size)) + k]) + a0[(((i * size) * size) + ((j - 1) * size)) + (k - 1)]) + a0[(((i * size) * size) + ((j + 1) * size)) + (k - 1)]) + a0[((((i - 1) * size) * size) + (j * size)) + (k - 1)]) + a0[((((i + 1) * size) * size) + (j * size)) + (k - 1)]) + a0[((((i - 1) * size) * size) + ((j - 1) * size)) + (k - 1)]) + a0[((((i - 1) * size) * size) + ((j + 1) * size)) + (k - 1)]) + a0[((((i + 1) * size) * size) + ((j - 1) * size)) + (k - 1)]) + a0[((((i + 1) * size) * size) + ((j + 1) * size)) + (k - 1)]) + a0[(((i * size) * size) + ((j - 1) * size)) + (k + 1)]) + a0[(((i * size) * size) + ((j + 1) * size)) + (k + 1)]) + a0[((((i - 1) * size) * size) + (j * size)) + (k + 1)]) + a0[((((i + 1) * size) * size) + (j * size)) + (k + 1)]) + a0[((((i - 1) * size) * size) + ((j - 1) * size)) + (k + 1)]) + a0[((((i - 1) * size) * size) + ((j + 1) * size)) + (k + 1)]) + a0[((((i + 1) * size) * size) + ((j - 1) * size)) + (k + 1)]) + a0[((((i + 1) * size) * size) + ((j + 1) * size)) + (k + 1)]) + a0[(((i * size) * size) + (j * size)) + (k - 1)]) + a0[(((i * size) * size) + (j * size)) + (k + 1)]) * fac;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/stencil/2"}
{"code": "for (i = 0; i < (30000000 - 1); i += 2)\n{\n  a[i] = 0.0;\n  a[i + 1] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NotChristianGarcia/Parallel-Computing/labs/lab1/part2/prb_a/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  double _imopVarPre151;\n  double _imopVarPre152;\n  _imopVarPre151 = errnm[m] / (((nx0 - 2) * (ny0 - 2)) * (nz0 - 2));\n  _imopVarPre152 = sqrt(_imopVarPre151);\n  errnm[m] = _imopVarPre152;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/25"}
{"code": "for (j = 0; j <= (n - 1); ++j)\n{\n  for (i = 0; i <= (n - 1); ++i)\n  {\n    if (A[i] < A[j])\n    {\n      R[(i + n) - 1][j] = 1;\n    }\n    else\n    {\n      R[(i + n) - 1][j] = 0;\n    }\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "#pragma omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgrigoras/parallel_algorithms/Lab 7/Lab7_p1_openmp/Hello_parallel/main/5"}
{"code": "for (int i = 0; i < size; i++)\n{\n  img[i] = rand() % 256;\n  norm[i] = (box[i] = (out[i] = 0));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/asmooth-omp/main/0"}
{"code": "for (int i = 0; i < NumberOfBodies; i++)\n{\n  if (merged[i] == (-1))\n  {\n    x[i][0] = x[i][0] + (timeStepSize * v[i][0]);\n    x[i][1] = x[i][1] + (timeStepSize * v[i][1]);\n    x[i][2] = x[i][2] + (timeStepSize * v[i][2]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnabycollins/PSCI/step-4/4"}
{"code": "for (pi = 0, x = 0; x < L; x++)\n{\n  current_weight = beta - ((alpha * step) * ((double) x));\n  for (y = 0; y < L; y++)\n  {\n    actual_particles = random_draw((n_input * (current_weight / total_weight)) / L, parm);\n    for (p = 0; p < actual_particles; p++, pi++)\n    {\n      particles[pi].x = x + 0.5;\n      particles[pi].y = y + 0.5;\n      particles[pi].k = k;\n      particles[pi].m = m;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/OPENMP/PIC/pic/8"}
{"code": "for (i = dim - 1; i >= 0; i--)\n{\n  for (j = dim - 1; j >= (i + 1); j--)\n    x[i] -= U[i][j] * x[j];\n\n  x[i] = x[i] / U[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/numeric/solve-sec/ver-2.0/crout-omp/4"}
{"code": "for (i = 0; i < rows1; i++)\n{\n  for (j = 0; j < columns2; j++)\n  {\n    result[i][j] = 0;\n    for (k = 0; k < columns1; k++)\n    {\n      result[i][j] += matrix1[i][k] * matrix2[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(matrix1, matrix2, result) private(i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/promops/lab/main/3"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  sleep_for(milliseconds(50));\n  k += i;\n  fprintf(stdout, \"k = %d, thread id: %d\\n\", k, omp_get_thread_num());\n}\n\n", "pragma": "\t#pragma omp parallel for firstprivate(k), lastprivate(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/11"}
{"code": "for (i = 2; i < (nx - 2); i++)\n{\n  for (j = 2; j < (ny - 2); j++)\n  {\n    for (k = 2; k < (nz - 2); k++)\n    {\n      f = phi[i][j][k] * phi[i][j][k];\n      phi_xx = (((((((-1.0) / 12.0) * phi[i - 2][j][k]) + ((4.0 / 3.0) * phi[i - 1][j][k])) - ((5.0 / 2.0) * phi[i][j][k])) + ((4.0 / 3.0) * phi[i + 1][j][k])) - ((1.0 / 12.0) * phi[i + 2][j][k])) / (dx * dx);\n      phi_yy = (((((((-1.0) / 12.0) * phi[i][j - 2][k]) + ((4.0 / 3.0) * phi[i][j - 1][k])) - ((5.0 / 2.0) * phi[i][j][k])) + ((4.0 / 3.0) * phi[i][j + 1][k])) - ((1.0 / 12.0) * phi[i][j + 2][k])) / (dy * dy);\n      phi_zz = (((((((-1.0) / 12.0) * phi[i][j][k - 2]) + ((4.0 / 3.0) * phi[i][j][k - 1])) - ((5.0 / 2.0) * phi[i][j][k])) + ((4.0 / 3.0) * phi[i][j][k + 1])) - ((1.0 / 12.0) * phi[i][j][k + 2])) / (dz * dz);\n      f = (((((phi[i - 1][j][k] + phi[i + 1][j][k]) + phi[i][j - 1][k]) + phi[i][j + 1][k]) + phi[i][j][k - 1]) + phi[i][j][k + 1]) / 6.0;\n      f = f * f;\n      phi_xx = ((phi[i - 1][j][k] - (2.0 * phi[i][j][k])) + phi[i + 1][j][k]) / (dx * dx);\n      phi_yy = ((phi[i][j - 1][k] - (2.0 * phi[i][j][k])) + phi[i][j + 1][k]) / (dy * dy);\n      phi_zz = ((phi[i][j][k - 1] - (2.0 * phi[i][j][k])) + phi[i][j][k + 1]) / (dz * dz);\n      temp = ((phi_xx + phi_yy) + phi_zz) - f;\n      res += temp * temp;\n      if (((i == (nx / 2)) && (j == (ny / 2))) && (k == (nz / 2)))\n      {\n        printf(\"%d %d %d %lf\\n\", i, j, k, temp);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/11"}
{"code": "for (i = 0; i < iter; ++i)\n{\n  t1 = omp_get_wtime();\n  step_begin = omp_get_wtime();\n  fill_array(m1, N, 0, 12, i);\n  fill_array(m2, N / 2, 12, 10 * 12, i);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_generate_time);\n  step_begin = omp_get_wtime();\n  map(m1, N, m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_map_time);\n  step_begin = omp_get_wtime();\n  merge(m1, m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_merge_time);\n  step_begin = omp_get_wtime();\n  sort(&m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_sort_time);\n  step_begin = omp_get_wtime();\n  x = reduce(m2, N / 2);\n  step_end = omp_get_wtime();\n  compare_time(step_begin, step_end, &minimal_reduce_time);\n  t2 = omp_get_wtime();\n  compare_time(t1, t2, &minimal_time_ms);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leleyi/Parallel_Computing/lab4/lab4/2"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  if ((score_new[i] - solution[i]) < 0.0)\n  {\n    global_diff -= score_new[i] - solution[i];\n  }\n  else\n  {\n    global_diff += score_new[i] - solution[i];\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:global_diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Filipe-Santos522/CSPH-Labs/lab3/kit_lab3/pagerank - C\u00f3pia/page_rank/3"}
{"code": "for (int i = 0; i < 3; i++)\n  z[i] = x[i] * y[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Parallelization_mpi-omp-simd/par_mpi-omp-simd/pathracer_mpi-omp-simd/9"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j1][k] = lhs[n + 2][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j1][k] = lhs[n + 3][i][j1][k] - (lhs[n + 1][i][j1][k] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j1][k] = rhs[m][i][j1][k] - (lhs[n + 1][i][j1][k] * rhs[m][i][j][k]);\n    fac2 = 1. / lhs[n + 2][i][j1][k];\n    rhs[m][i][j1][k] = fac2 * rhs[m][i][j1][k];\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,i,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/192"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 124; j++)\n  {\n    for (k = 0; k < 124; k++)\n    {\n      temp[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/prateek18597/OpenMP-Programs/3_MatrixMul/0"}
{"code": "for (int i = 0; i < nOctaves; i++)\n{\n  w = gpyr[i * nGpyrLayers].w;\n  h = gpyr[i * nGpyrLayers].h;\n  for (int j = 1; j <= nLayers; j++)\n  {\n    int layer_index = (i * nGpyrLayers) + j;\n    grdPyr[layer_index].init(w, h);\n    rotPyr[layer_index].init(w, h);\n    srcData = gpyr[layer_index].data;\n    grdData = grdPyr[layer_index].data;\n    rotData = rotPyr[layer_index].data;\n    for (int r = 0; r < h; r++)\n    {\n      for (int c = 0; c < w; c++)\n      {\n        dr = get_pixel_f(srcData, w, h, r + 1, c) - get_pixel_f(srcData, w, h, r - 1, c);\n        dc = get_pixel_f(srcData, w, h, r, c + 1) - get_pixel_f(srcData, w, h, r, c - 1);\n        grdData[(r * w) + c] = sqrtf((dr * dr) + (dc * dc));\n        angle = atan2f(dr, dc + FLT_MIN);\n        angle = (angle < 0) ? (angle + _2PI) : (angle);\n        rotData[(r * w) + c] = angle;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/6"}
{"code": "for (int i = 0; i < ROW2; i++)\n{\n  while (!mapG2[i].isEmpty())\n  {\n    int first = mapG2[i].getFirst();\n    if (!mapG1[first].isEmpty())\n    {\n      for (int j = 0; j < ((COL / 32) + 1); j++)\n      {\n        mapG2[i].map[j] ^= mapG1[first].map[j];\n      }\n\n    }\n    else\n    {\n      mapG1[first] = mapG2[i];\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/Grobner/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum_tot += sum_tmp[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anderslaunerbaek/HPC/exercises/automatic_parallelixation/openmp/func/1"}
{"code": "for (iter = 0; iter < stats->num_vertices; iter++)\n{\n  inverselabels[stats->components[iter]] = iter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/connectedComponents/25"}
{"code": "for (int i = 0; i < level; i++)\n  choose_option(instance, ctx, chosen_options[i], -1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Quentin18/exact-cover-parallel/hybrid/exact_cover_hybrid_bfs/0"}
{"code": "for (int i = 33; i < 32000000; i += 7)\n{\n  a[i] = (b[i] * c[i]) * d[i];\n}\n\n", "pragma": "  #pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_codegen/0"}
{"code": "for (int i = 0; i < RowN; i++)\n{\n  Result[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/8"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  koff = nxhd * k;\n  k1 = (nxhd * ny) - koff;\n  t1 = f[k1];\n  f[k1] = 0.5 * (cimagf(f[koff] + t1) + (crealf(f[koff] - t1) * _Complex_I));\n  f[koff] = 0.5 * (crealf(f[koff] + t1) + (cimagf(f[koff] - t1) * _Complex_I));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/45"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  if (fscanf(fp, \"%d\", &_mat(i, j)) == EOF)\n{\n  fclose(fp);\n  return -1;\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlexandrosAlexiou/OpenMP-Exercise/Matrix-Multiplication/mat_mul_inner_for/1"}
{"code": "for (i = 0; i < m; ++i)\n{\n  for (j = 0; j < p; ++j)\n  {\n    addictionProduct(MULT, M1, M2, i, j, n);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(num_threads) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manuel-fidalgo/Parallel-computing-OpenMP/matrix_multiplication/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"%.3f\\n\", answear[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/renanrdgsrodrigues/Progamacao-Paralela/gauss_sequencial/6"}
{"code": "for (unsigned int i_iteration = 0; i_iteration < iteration; i_iteration += 1)\n{\n  update_physics(nb_body, nb_thread);\n  rendering(render, nb_body);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Cjdcoy/parallel-distributed_computing/nbody-simulation/programs/openmp/src/main/2"}
{"code": "for (i = 0; i < curSize; i++)\n{\n  printf(\"%d %f\\n\", heap[i].id, heap[i].weight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/bSuitor/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  local_count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CarlaNunes/Trabalho-1---CAD-2021/par/0"}
{"code": "for (int i = 0; i < A.Rows; i++)\n{\n  for (int j = 0; j < Bt.Rows; j++)\n  {\n    float sum = 0.0f;\n    for (int k = 0; k < A.Cols; k++)\n    {\n      sum += arrayA[i][k] * arrayBt[j][k];\n    }\n\n    arrayD[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rvarunbharadwaj/OpenMP/Prob3/Prob3/Parallel/0"}
{"code": "for (j = jst; j < jend; j++)\n{\n  if (j != jst)\n  {\n    while (flag[j - 1] == 0)\n    {\n      ;\n    }\n\n  }\n\n  if (j != (jend - 1))\n  {\n    while (flag[j] == 1)\n    {\n      ;\n    }\n\n  }\n\n  for (i = ist; i < iend; i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      tv[m] = v[k][j][i][m] - (omega * ((((((((((ldy[j][i][0][m] * v[k][j - 1][i][0]) + (ldx[j][i][0][m] * v[k][j][i - 1][0])) + (ldy[j][i][1][m] * v[k][j - 1][i][1])) + (ldx[j][i][1][m] * v[k][j][i - 1][1])) + (ldy[j][i][2][m] * v[k][j - 1][i][2])) + (ldx[j][i][2][m] * v[k][j][i - 1][2])) + (ldy[j][i][3][m] * v[k][j - 1][i][3])) + (ldx[j][i][3][m] * v[k][j][i - 1][3])) + (ldy[j][i][4][m] * v[k][j - 1][i][4])) + (ldx[j][i][4][m] * v[k][j][i - 1][4])));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      tmat[0][m] = d[j][i][0][m];\n      tmat[1][m] = d[j][i][1][m];\n      tmat[2][m] = d[j][i][2][m];\n      tmat[3][m] = d[j][i][3][m];\n      tmat[4][m] = d[j][i][4][m];\n    }\n\n    tmp1 = 1.0 / tmat[0][0];\n    tmp = tmp1 * tmat[0][1];\n    tmat[1][1] = tmat[1][1] - (tmp * tmat[1][0]);\n    tmat[2][1] = tmat[2][1] - (tmp * tmat[2][0]);\n    tmat[3][1] = tmat[3][1] - (tmp * tmat[3][0]);\n    tmat[4][1] = tmat[4][1] - (tmp * tmat[4][0]);\n    tv[1] = tv[1] - (tv[0] * tmp);\n    tmp = tmp1 * tmat[0][2];\n    tmat[1][2] = tmat[1][2] - (tmp * tmat[1][0]);\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[2][0]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[3][0]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[4][0]);\n    tv[2] = tv[2] - (tv[0] * tmp);\n    tmp = tmp1 * tmat[0][3];\n    tmat[1][3] = tmat[1][3] - (tmp * tmat[1][0]);\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[2][0]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][0]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][0]);\n    tv[3] = tv[3] - (tv[0] * tmp);\n    tmp = tmp1 * tmat[0][4];\n    tmat[1][4] = tmat[1][4] - (tmp * tmat[1][0]);\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[2][0]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][0]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][0]);\n    tv[4] = tv[4] - (tv[0] * tmp);\n    tmp1 = 1.0 / tmat[1][1];\n    tmp = tmp1 * tmat[1][2];\n    tmat[2][2] = tmat[2][2] - (tmp * tmat[2][1]);\n    tmat[3][2] = tmat[3][2] - (tmp * tmat[3][1]);\n    tmat[4][2] = tmat[4][2] - (tmp * tmat[4][1]);\n    tv[2] = tv[2] - (tv[1] * tmp);\n    tmp = tmp1 * tmat[1][3];\n    tmat[2][3] = tmat[2][3] - (tmp * tmat[2][1]);\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][1]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][1]);\n    tv[3] = tv[3] - (tv[1] * tmp);\n    tmp = tmp1 * tmat[1][4];\n    tmat[2][4] = tmat[2][4] - (tmp * tmat[2][1]);\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][1]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][1]);\n    tv[4] = tv[4] - (tv[1] * tmp);\n    tmp1 = 1.0 / tmat[2][2];\n    tmp = tmp1 * tmat[2][3];\n    tmat[3][3] = tmat[3][3] - (tmp * tmat[3][2]);\n    tmat[4][3] = tmat[4][3] - (tmp * tmat[4][2]);\n    tv[3] = tv[3] - (tv[2] * tmp);\n    tmp = tmp1 * tmat[2][4];\n    tmat[3][4] = tmat[3][4] - (tmp * tmat[3][2]);\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][2]);\n    tv[4] = tv[4] - (tv[2] * tmp);\n    tmp1 = 1.0 / tmat[3][3];\n    tmp = tmp1 * tmat[3][4];\n    tmat[4][4] = tmat[4][4] - (tmp * tmat[4][3]);\n    tv[4] = tv[4] - (tv[3] * tmp);\n    v[k][j][i][4] = tv[4] / tmat[4][4];\n    tv[3] = tv[3] - (tmat[4][3] * v[k][j][i][4]);\n    v[k][j][i][3] = tv[3] / tmat[3][3];\n    tv[2] = (tv[2] - (tmat[3][2] * v[k][j][i][3])) - (tmat[4][2] * v[k][j][i][4]);\n    v[k][j][i][2] = tv[2] / tmat[2][2];\n    tv[1] = ((tv[1] - (tmat[2][1] * v[k][j][i][2])) - (tmat[3][1] * v[k][j][i][3])) - (tmat[4][1] * v[k][j][i][4]);\n    v[k][j][i][1] = tv[1] / tmat[1][1];\n    tv[0] = (((tv[0] - (tmat[1][0] * v[k][j][i][1])) - (tmat[2][0] * v[k][j][i][2])) - (tmat[3][0] * v[k][j][i][3])) - (tmat[4][0] * v[k][j][i][4]);\n    v[k][j][i][0] = tv[0] / tmat[0][0];\n  }\n\n  if (j != (jend - 1))\n    flag[j] = 1;\n\n  if (j != jst)\n    flag[j - 1] = 0;\n\n}\n\n", "pragma": "\t#pragma omp for nowait schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/2"}
{"code": "for (i = 0; i < k_cluster_size; i++)\n{\n  for (j = 0; j < k_cluster_size; j++)\n  {\n    if (i != j)\n    {\n      distance = calculate_distance(&k_cluster[i].centroid, &k_cluster[j].centroid);\n      quality += k_cluster[i].diameter / distance;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(distance, j) reduction(+:quality)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanielleKahana/K-means/K_Means/K_Means/k-means/8"}
{"code": "for (int i = 0; i < 25; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    px[j][i] += vy[k][i] * cx[j][k];\n  }\n\n}\n\n", "pragma": "           #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/29"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  ws = 0.0;\n  wp = 0.0;\n  #pragma ivdep\n  for (j = 1; j < nxh; j++)\n  {\n    dkx = dnx * ((float) j);\n    afdt = adt * cimagf(ffc[j + kk]);\n    zt1 = (-cimagf(exyz[2 + (4 * (j + kj))])) + (crealf(exyz[2 + (4 * (j + kj))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (4 * (j + kj))])) + (crealf(exyz[1 + (4 * (j + kj))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[4 * (j + kj)])) + (crealf(exyz[4 * (j + kj)]) * _Complex_I);\n    zt4 = bxyz[4 * (j + kj)] - (dth * (dky * zt1));\n    zt5 = bxyz[1 + (4 * (j + kj))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (4 * (j + kj))] - (dth * ((dkx * zt2) - (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[4 * (j + kj)] + (cdt * (dky * zt1))) - (afdt * cu[4 * (j + kj)]);\n    zt8 = (exyz[1 + (4 * (j + kj))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * (j + kj))]);\n    zt9 = (exyz[2 + (4 * (j + kj))] + (cdt * ((dkx * zt2) - (dky * zt3)))) - (afdt * cu[2 + (4 * (j + kj))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[4 * (j + kj)] = zt7;\n    exyz[1 + (4 * (j + kj))] = zt8;\n    exyz[2 + (4 * (j + kj))] = zt9;\n    at1 = anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    ws += (double) at1;\n    zt4 -= dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) - (dky * zt3));\n    bxyz[4 * (j + kj)] = zt4;\n    bxyz[1 + (4 * (j + kj))] = zt5;\n    bxyz[2 + (4 * (j + kj))] = zt6;\n    at1 = anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    wp += (double) at1;\n    zt1 = (-cimagf(exyz[2 + (4 * (j + k1))])) + (crealf(exyz[2 + (4 * (j + k1))]) * _Complex_I);\n    zt2 = (-cimagf(exyz[1 + (4 * (j + k1))])) + (crealf(exyz[1 + (4 * (j + k1))]) * _Complex_I);\n    zt3 = (-cimagf(exyz[4 * (j + k1)])) + (crealf(exyz[4 * (j + k1)]) * _Complex_I);\n    zt4 = bxyz[4 * (j + k1)] + (dth * (dky * zt1));\n    zt5 = bxyz[1 + (4 * (j + k1))] + (dth * (dkx * zt1));\n    zt6 = bxyz[2 + (4 * (j + k1))] - (dth * ((dkx * zt2) + (dky * zt3)));\n    zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n    zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n    zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n    zt7 = (exyz[4 * (j + k1)] - (cdt * (dky * zt1))) - (afdt * cu[4 * (j + k1)]);\n    zt8 = (exyz[1 + (4 * (j + k1))] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * (j + k1))]);\n    zt9 = (exyz[2 + (4 * (j + k1))] + (cdt * ((dkx * zt2) + (dky * zt3)))) - (afdt * cu[2 + (4 * (j + k1))]);\n    zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n    zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n    zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n    exyz[4 * (j + k1)] = zt7;\n    exyz[1 + (4 * (j + k1))] = zt8;\n    exyz[2 + (4 * (j + k1))] = zt9;\n    at1 = anorm * (((zt7 * conjf(zt7)) + (zt8 * conjf(zt8))) + (zt9 * conjf(zt9)));\n    ws += (double) at1;\n    zt4 += dth * (dky * zt1);\n    zt5 += dth * (dkx * zt1);\n    zt6 -= dth * ((dkx * zt2) + (dky * zt3));\n    bxyz[4 * (j + k1)] = zt4;\n    bxyz[1 + (4 * (j + k1))] = zt5;\n    bxyz[2 + (4 * (j + k1))] = zt6;\n    at1 = anorm * (((zt4 * conjf(zt4)) + (zt5 * conjf(zt5))) + (zt6 * conjf(zt6)));\n    wp += (double) at1;\n    bxyz[4 * ((j + kj) + l1)] = zero;\n    bxyz[1 + (4 * ((j + kj) + l1))] = zero;\n    bxyz[2 + (4 * ((j + kj) + l1))] = zero;\n    exyz[4 * ((j + kj) + l1)] = zero;\n    exyz[1 + (4 * ((j + kj) + l1))] = zero;\n    exyz[2 + (4 * ((j + kj) + l1))] = zero;\n    bxyz[4 * ((j + k1) + l1)] = zero;\n    bxyz[1 + (4 * ((j + k1) + l1))] = zero;\n    bxyz[2 + (4 * ((j + k1) + l1))] = zero;\n    exyz[4 * ((j + k1) + l1)] = zero;\n    exyz[1 + (4 * ((j + k1) + l1))] = zero;\n    exyz[2 + (4 * ((j + k1) + l1))] = zero;\n  }\n\n  afdt = adt * cimagf(ffc[kk]);\n  zt1 = (-cimagf(exyz[2 + (4 * kj)])) + (crealf(exyz[2 + (4 * kj)]) * _Complex_I);\n  zt3 = (-cimagf(exyz[4 * kj])) + (crealf(exyz[4 * kj]) * _Complex_I);\n  zt4 = bxyz[4 * kj] - (dth * (dky * zt1));\n  zt6 = bxyz[2 + (4 * kj)] + (dth * (dky * zt3));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt3 = (-cimagf(zt4)) + (crealf(zt4) * _Complex_I);\n  zt7 = (exyz[4 * kj] + (cdt * (dky * zt1))) - (afdt * cu[4 * kj]);\n  zt9 = (exyz[2 + (4 * kj)] - (cdt * (dky * zt3))) - (afdt * cu[2 + (4 * kj)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt3 = (-cimagf(zt7)) + (crealf(zt7) * _Complex_I);\n  exyz[4 * kj] = zt7;\n  exyz[1 + (4 * kj)] = zero;\n  exyz[2 + (4 * kj)] = zt9;\n  at1 = anorm * ((zt7 * conjf(zt7)) + (zt9 * conjf(zt9)));\n  ws += (double) at1;\n  zt4 -= dth * (dky * zt1);\n  zt6 += dth * (dky * zt3);\n  bxyz[4 * kj] = zt4;\n  bxyz[1 + (4 * kj)] = zero;\n  bxyz[2 + (4 * kj)] = zt6;\n  at1 = anorm * ((zt4 * conjf(zt4)) + (zt6 * conjf(zt6)));\n  wp += (double) at1;\n  bxyz[4 * k1] = zero;\n  bxyz[1 + (4 * k1)] = zero;\n  bxyz[2 + (4 * k1)] = zero;\n  exyz[4 * k1] = zero;\n  exyz[1 + (4 * k1)] = zero;\n  exyz[2 + (4 * k1)] = zero;\n  bxyz[4 * (kj + l1)] = zero;\n  bxyz[1 + (4 * (kj + l1))] = zero;\n  bxyz[2 + (4 * (kj + l1))] = zero;\n  exyz[4 * (kj + l1)] = zero;\n  exyz[1 + (4 * (kj + l1))] = zero;\n  exyz[2 + (4 * (kj + l1))] = zero;\n  bxyz[4 * (k1 + l1)] = zero;\n  bxyz[1 + (4 * (k1 + l1))] = zero;\n  bxyz[2 + (4 * (k1 + l1))] = zero;\n  exyz[4 * (k1 + l1)] = zero;\n  exyz[1 + (4 * (k1 + l1))] = zero;\n  exyz[2 + (4 * (k1 + l1))] = zero;\n  sum3 += ws;\n  sum4 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,dkx,afdt,at1,zt1,zt2,zt3,zt4,zt5,zt6,zt7,zt8, zt9,ws,wp) reduction(+:sum3,sum4)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/33"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dtty2 * speed[i][j - 1][k]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dtty2 * speed[i][j + 1][k]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/14"}
{"code": "for (k = 0; k < iter; k++)\n{\n  initPopulation(population, population_size, x_max, y_max, num_particles);\n  double max_fitness = 0;\n  int stop = 0;\n  int gen = 0;\n  int highest = 0;\n  int prev_highest = 0;\n  int highest_count = 0;\n  clock_t begin = clock();\n  do\n  {\n    prev_highest = highest;\n    highest = breeding(population, population_size, x_max, y_max, num_particles);\n    gen += 1;\n    if (prev_highest == highest)\n    {\n      highest_count++;\n    }\n    else\n    {\n      highest_count = 0;\n    }\n\n  }\n  while (highest_count < 10);\n  double fitness;\n  fitness = population[highest].fitness;\n  double *highest_buffer = 0;\n  if (rank == 0)\n  {\n    highest_buffer = (double *) malloc((sizeof(double)) * numprocs);\n    assert(highest_buffer != 0);\n  }\n\n  MPI_Gather(&fitness, 1, (MPI_Datatype) 0x4c00080b, highest_buffer, 1, (MPI_Datatype) 0x4c00080b, 0, (MPI_Comm) 0x44000000);\n  if (rank == 0)\n  {\n    clock_t end = clock();\n    time_spent += ((double) (end - begin)) / CLOCKS_PER_SEC;\n    printf(\"Time spent in this iteration is %f seconds\\n\", ((double) (end - begin)) / CLOCKS_PER_SEC);\n    int i;\n    double max = fitness;\n    for (i = 0; i < numprocs; i++)\n    {\n      if (highest_buffer[i] > max)\n      {\n        max = highest_buffer[i];\n      }\n\n    }\n\n    printf(\"The highest energy in this iteration is %f\\n\", max);\n    totals[iter] = max;\n    printf(\"# generations= %d \\n\", gen);\n    gen_count += gen;\n    printf(\"---------\");\n  }\n\n  MPI_Barrier((MPI_Comm) 0x44000000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/13"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  nv = cell(ci).getNV();\n  for (d = 0; d < NDIM; d++)\n    ftmp.at(d) = 0.0;\n\n  for (vi = 0; vi < nv; vi++)\n  {\n    for (d = 0; d < NDIM; d++)\n      ftmp.at(d) += cell(ci).vforce(vi, d);\n\n  }\n\n  testForce = 0.0;\n  for (d = 0; d < NDIM; d++)\n    testForce += ftmp.at(d) * ftmp.at(d);\n\n  if (testForce > maxForce)\n    maxForce = testForce;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/28"}
{"code": "for (int j = 0; j < vector.size(); j++)\n{\n  cout << '[';\n  for (i = 0; i < (vector[j].size() - 1); i++)\n    (cout << vector[j][i]) << \"\\t , \";\n\n  ((cout << vector[j][i]) << ']') << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/overloadedmethod/Concurrent-Viterbi-Algorithm-in-MPI-and-OpenMP/FileUtilities/4"}
{"code": "for (int key = 0; key < size; key++)\n{\n  exists[key] = binary_search(array, key, size);\n}\n\n", "pragma": "omp parallel for default(none) shared(array,size,exists)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Binary_Search/0"}
{"code": "for (int i = 0; i < N; i += 4)\n{\n  char first = text[i + 0];\n  char second = text[i + 1];\n  char third = text[i + 2];\n  char fourth = text[i + 3];\n  char group = 0;\n  group += getCodedValue(first);\n  group <<= 2;\n  group += getCodedValue(second);\n  group <<= 2;\n  group += getCodedValue(third);\n  group <<= 2;\n  group += getCodedValue(fourth);\n  coded.push_back(group);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VulovicDanilo/PatternMatching/PatternMatcher/0"}
{"code": "for (i = 0; i < 20; i++)\n  for (j = 0; j < i; j++)\n{\n  A[j] = a[i][j];\n  B[i][j] = A[j];\n}\n\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/6.race3/0"}
{"code": "for (i = 0; i < dim; i++)\n  fscanf(stdin, \"%d \", &A[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/ScalarProduct/ScalarProduct/0"}
{"code": "for (j = x_min - depth; j <= ((x_max + x_inc) + depth); j++)\n{\n  index = (j + depth) + ((k - 1) * ((x_max + x_inc) + (2 * depth)));\n  field[FTNREF2D(j, (y_max + y_inc) + k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)] = top_rcv_buffer[FTNREF1D(index, 1)];\n}\n\n", "pragma": "omp for private(j,index)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/pack_kernel_c/7"}
{"code": "for (int i = 0; i < N2; i++)\n{\n  if ((i > 0) && (i < (N2 - 1)))\n  {\n    srand(time(NULL));\n  }\n\n  for (int j = 0; j < N2; j++)\n  {\n    if ((((i == (N2 - 1)) || (j == (N2 - 1))) || (i == 0)) || (j == 0))\n    {\n      table[i][j] = DEAD;\n    }\n    else\n    {\n      if ((rand() % 2) < 1)\n      {\n        table[i][j] = ALIVE;\n      }\n      else\n      {\n        table[i][j] = DEAD;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnstephenson39/gameoflife_openmp/gol/2"}
{"code": "for (int i = 0; i <= (height - 1); i += 1)\n  for (int j = 0; j <= (linea - 1); j += 3)\n{\n  {\n    tmpBx = 0;\n    tmpGx = 0;\n    tmpRx = 0;\n    tmpBy = 0;\n    tmpGy = 0;\n    tmpRy = 0;\n    for (int s = -1; s <= 1; s++)\n    {\n      for (int t = -1; t <= 1; t++)\n      {\n        filaSobel = s + 1;\n        columnaSobel = t + 1;\n        columnaByte = (t * 3) + j;\n        byte = ((i + s) * linea) + columnaByte;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= (j + (t * 3)))) && (columnaByte <= (linea - 1)))\n        {\n          tmpBx += mxSobel[filaSobel][columnaSobel] * pixels[byte];\n          tmpBy += mySobel[filaSobel][columnaSobel] * pixels[byte];\n        }\n\n        byte += 1;\n        columnaByte += 1;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= columnaByte)) && (columnaByte <= (linea - 1)))\n        {\n          tmpGx += mxSobel[filaSobel][columnaSobel] * pixels[byte];\n          tmpGy += mySobel[filaSobel][columnaSobel] * pixels[byte];\n        }\n\n        byte += 1;\n        columnaByte += 1;\n        if ((((byte >= 0) && (byte <= size)) && (0 <= columnaByte)) && (columnaByte <= (linea - 1)))\n        {\n          tmpRx += mxSobel[filaSobel][columnaSobel] * pixels[byte];\n          tmpRy += mySobel[filaSobel][columnaSobel] * pixels[byte];\n        }\n\n      }\n\n    }\n\n    pixelsN[(i * linea) + j] = (unsigned char) ((abs(tmpBx) + abs(tmpBy)) / w);\n    pixelsN[((i * linea) + j) + 1] = (unsigned char) ((abs(tmpGx) + abs(tmpGy)) / w);\n    pixelsN[((i * linea) + j) + 2] = (unsigned char) ((abs(tmpRx) + abs(tmpRy)) / w);\n  }\n}\n\n\n", "pragma": "    #pragma omp parallel for private (tmpBx, tmpBy, tmpRx, tmpRy, tmpGx, tmpGy) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarZeta-hub/pr-ctica-OpenMP/image-par/image-par/2"}
{"code": "for (i = 0; i < len; i++)\n  sum2 += a[i] * b[i];\n\n", "pragma": "omp parallel for reduction (+:sum2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB097-target-teams-distribute-orig-no/1"}
{"code": "for (int i = 0; i < 8; i++)\n  for (int j = 0; j < 8; j++)\n{\n  temp[i][j] = data[j][i];\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testv2/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  for (i = 0; i < k; i++)\n  {\n    distance(clusters_arr[i].x, clusters_arr[i].y, points_arr[j].x, points_arr[j].y, &dist);\n    if (dist < min_dist)\n    {\n      min_dist = dist;\n      cluster = i;\n    }\n\n  }\n\n  old_x = points_arr[j].cluster_x;\n  old_y = points_arr[j].cluster_y;\n  if (min_dist != MAX_NUM_POINTS)\n  {\n    points_arr[j].cluster_x = clusters_arr[cluster].x;\n    points_arr[j].cluster_y = clusters_arr[cluster].y;\n    clusters_arr[cluster].num_of_points++;\n    if ((old_x == points_arr[j].cluster_x) && (old_y == points_arr[j].cluster_y))\n    {\n      count++;\n    }\n\n  }\n\n  min_dist = MAX_NUM_POINTS;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stefani237/K-MEANS/Initial/func/5"}
{"code": "for (y = 2; y < inner_j; y++)\n{\n  sum = 0;\n  for (fx = -1; fx <= 1; fx++)\n    for (fy = -1; fy <= 1; fy++)\n    sum += local_array_in[((x - fx) * (inner_j + 2)) + (y - fy)] * filter.array[fx + 1][fy + 1];\n\n\n  local_array_out[(x * (inner_j + 2)) + y] = ((int) sum) / filter.sum;\n}\n\n", "pragma": "omp for private(fx,fy,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/main_OMP/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  fprintf(f, fmt, i + 1);\n  fprintf(f, \"%2c   \", s[i]);\n  fprintf(f, fmt, i);\n  fprintf(f, fmt, (i == (n - 1)) ? (0) : (i + 2));\n  fprintf(f, fmt, (pair[i] == i) ? (0) : (pair[i] + 1));\n  fprintf(f, fmt, i + 1);\n  fprintf(f, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/prna-omp/prna/5"}
{"code": "for (i = 1; i < N; i++)\n{\n  if (T[i - 1] > T[i])\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/bubble/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  masking.call_opt(seqs.ptr(i), seqs.length(i));\n}\n\n", "pragma": "#pragma omp parallel for num_threads(config.threads_)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/diamond-omp/masking/13"}
{"code": "for (int i = 0; i <= N; i++)\n  U_[i] = Al[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/104"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int temp = cast_agg->vec_[i];\n  cast_agg->vec_[i] = sum;\n  sum += temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/89"}
{"code": "for (int rw = 0; rw < m_nRows; rw++)\n{\n  if (!FloatEqual(data[rw][2], NoDataValue))\n  {\n    if (FloatEqual(m_1DDataWithRowCol[rw][2], NoDataValue))\n      m_1DDataWithRowCol[rw][2] = 0.0f;\n\n    m_1DDataWithRowCol[rw][0] = data[rw][0];\n    m_1DDataWithRowCol[rw][1] = data[rw][1];\n    if (data[rw][2] >= m_1DDataWithRowCol[rw][2])\n    {\n      m_1DDataWithRowCol[rw][2] = data[rw][2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/base/data/PrintInfo/11"}
{"code": "for (i = 0; i < (BLOWFISH_ROUNDS + 2); i += 2)\n{\n  blowfish_key_enc(P, S, &datal, &datar);\n  P[i] = datal;\n  P[i + 1] = datar;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zagorskid/blowfish-omp/blowfish-omp/blowfish-omp/4"}
{"code": "for (i = 0; i < 3200; i++)\n{\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mogill/ems/Tests/accum_omp/2"}
{"code": "for (i = 0; i < (1 << NUM_BUCKETS_LOG_2); i++)\n  for (k = myid + 1; k < num_procs; k++)\n  bucket_ptrs[i] += bucket_size[k][i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/43"}
{"code": "for (p = 0; p < np; ++p)\n{\n  MPI_Cart_coords(grid, p, 2, proc_coordinates);\n  x_offset = proc_coordinates[0] * block_height;\n  y_offset = proc_coordinates[1] * block_width;\n  for (x = 0; x < block_height; x++)\n  {\n    memcpy(&values[((x_offset + x) * STENCIL_SIZE_X) + y_offset], &data[(((p * (block_width + 2)) * (block_height + 2)) + ((x + 1) * (block_width + 2))) + 1], block_width);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MehdiHALA/Mpi-x-project/src/stencil_all/3"}
{"code": "for (int i = 0; i < body_count; i++)\n{\n  write_position_to_file(P[i].p, fp);\n  for (int j = 0; j < body_count; j++)\n  {\n    if (j != i)\n    {\n      F = sum_vector(F, forca(P[i], P[j]));\n    }\n\n  }\n\n  {\n    P[i].f = F;\n    P[i].a = aceleracao(P[i].f, P[i].m);\n    v_anterior = P[i].v;\n    P[i].v = velocidade(v_anterior, P[i].a, delta_time);\n    p_anterior = P[i].p;\n    P[i].p = posicao(p_anterior, P[i].v, delta_time);\n  }\n  if (i == (body_count - 1))\n  {\n    fprintf(fp, \"\\n\");\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RuiXavierCosta/AC_OpenMP_Gravitation/main/0"}
{"code": "for (j = 0; j < N; ++j)\n  sum += Matr[i][j] * vect[j];\n\n", "pragma": "    #pragma omp paralell for redunction(+ : sum)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carpawell/openmp/3/3/2"}
{"code": "for (int i = 0; i < 32; i++)\n{\n  if (vals[i].maxval > maxval)\n  {\n    maxval = vals[i].maxval;\n    maxloc = vals[i].maxloc;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-3/parallel_not_critical_padding/1"}
{"code": "for (j = 0; j < fftblock; j++)\n{\n  for (i = 0; i < d[0]; i++)\n  {\n    xout[k][j + jj][i].real = y0[i][j].real;\n    xout[k][j + jj][i].imag = y0[i][j].imag;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(fftblock ,i ,jj ,x ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/6"}
{"code": "for (k = left; k < right2; k++)\n{\n  data[k] = aux[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUSTechBruce/Multithread-merge_sort/merge_sort/2"}
{"code": "for (int i = 0; i < g->num_nodes; i++)\n{\n  if (frontier->vertices[i] == frontier_id)\n  {\n    int start_edge = g->outgoing_starts[i];\n    int end_edge = (i == (g->num_nodes - 1)) ? (g->num_edges) : (g->outgoing_starts[i + 1]);\n    for (int neighbor = start_edge; neighbor < end_edge; neighbor++)\n    {\n      int neighbor_node = g->outgoing_edges[neighbor];\n      if (frontier->vertices[neighbor_node] == NOT_FRONTIER_MARKER)\n      {\n        next_frontier_cnt++;\n        distances[neighbor_node] = distances[i] + 1;\n        frontier->vertices[neighbor_node] = frontier_id + 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:next_frontier_cnt)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zonghan0904/2020_Fall_PP/HW3/part2/breadth_first_search/bfs/0"}
{"code": "for (i = 0; i <= m; i++)\n{\n  for (j = 0; j <= n; j++)\n  {\n    if ((i == 0) || (j == 0))\n      partial_arr[i][j] = 0;\n    else\n      if (X[i - 1] == Y[j - 1])\n      partial_arr[i][j] = partial_arr[i - 1][j - 1] + 1;\n    else\n      partial_arr[i][j] = max(partial_arr[i - 1][j], partial_arr[i][j - 1]);\n\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Katamreddys/OpenMpTaskFInal/5.assignment-openmp-advanced/5.assignment-openmp-advanced/lcs/lcs/0"}
{"code": "for (i = 0; i < n; i++)\n  cnt[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/24"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (prefix2[i] != prefix[i + 1][0])\n    cout << \"sdsdsdsdsd\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/prefix_sum_2/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = b[i];\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for map(to:b[:n]) map(from:a[:n])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/already_locked/already_locked/1"}
{"code": "for (int it = 0; it < ntimesrc; ++it)\n{\n  R.write((char *) (&srct[it]), sizeof(Dfloat));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/26"}
{"code": "for (int i = 0; i < M; i++)\n{\n  int u;\n  int v;\n  (cin >> u) >> v;\n  adj[u].push_back(v);\n  rev[v].push_back(u);\n  outdeg[u]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/baseline/3"}
{"code": "for (k = 0; k < taille; k++)\n{\n  result = (result < tab[k]) ? (result) : (tab[k]);\n}\n\n", "pragma": "omp parallel for reduction(min:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex6/4"}
{"code": "for (i = 0; i < N; i++)\n  A[1 + (2 * i)] = A[0 + (2 * i)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PDC-support/openmp-lab-exercises/old_intro_lab/c/sol/part3a.sol/2"}
{"code": "for (sh = 0; sh < sheight; ++sh)\n{\n  printf(\"================= sh : %d ================\\n\", sh);\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    for (h = 0; h < 32; h++)\n    {\n      for (w = 0; w < 32; ++w)\n      {\n        for (c = 0; c < 3; ++c)\n        {\n          tile_buf[c][h][w] = img[(((((sh * 32) + h) * width) + ((sw * 32) + w)) * 3) + c];\n        }\n\n      }\n\n    }\n\n    memcpy((void *) (thread_buf + (sw * 3072)), tile_buf, 3072);\n  }\n\n  printf(\"================= sh : %d, copy complete ================\\n\", sh);\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    int min_diff = 2147483647;\n    int min_i = -1;\n    for (i = 0; i < 60000; ++i)\n    {\n      int diff = 0;\n      for (c = 0; c < 3; ++c)\n      {\n        for (h = 0; h < 32; ++h)\n        {\n          for (w = 0; w < 32; ++w)\n          {\n            int pixel_diff = ((int) thread_buf[(((((sw * 3) + c) * 32) + h) * 32) + w]) - ((int) dataset[(((((i * 3) + c) * 32) + h) * 32) + w]);\n            diff += pixel_diff * pixel_diff;\n          }\n\n        }\n\n      }\n\n      if (min_diff > diff)\n      {\n        min_diff = diff;\n        min_i = i;\n      }\n\n    }\n\n    idx[(sh * swidth) + sw] = min_i;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/A/photomosaic/6"}
{"code": "for (i = 0; i < ncols; i++)\n{\n  clens[i].key = 0;\n  clens[i].val = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/csr/42"}
{"code": "for (int frame = 0; frame < frames; frame++)\n{\n  const double delta = Delta * pow(0.98, frame);\n  const double xMin = xMid - delta;\n  const double yMin = yMid - delta;\n  const double dw = (2.0 * delta) / width;\n  for (int row = 0; row < width; row++)\n  {\n    const double cy = yMin + (row * dw);\n    for (int col = 0; col < width; col++)\n    {\n      const double cx = xMin + (col * dw);\n      double x = cx;\n      double y = cy;\n      int depth = 256;\n      double x2;\n      double y2;\n      do\n      {\n        x2 = x * x;\n        y2 = y * y;\n        y = ((2 * x) * y) + cy;\n        x = (x2 - y2) + cx;\n        depth--;\n      }\n      while ((depth > 0) && ((x2 + y2) < 5.0));\n      pic[(((frame * width) * width) + (row * width)) + col] = (unsigned char) depth;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for num_threads(19) default(none) shared(pic, frames, width)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/masoncruse404/fractal/fractal_omp1/0"}
{"code": "for (j = 0; j < nx; j++)\n{\n  v_cu = _mm_add_ps(_mm_load_ps(&cu[4 * j]), _mm_load_ps(&cu[(4 * j) + kk]));\n  _mm_store_ps(&cu[4 * j], v_cu);\n  _mm_store_ps(&cu[(4 * j) + kk], _mm_setzero_ps());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/24"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (n = 0; n <= 4; n += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/140"}
{"code": "for (i = 1; i <= ((grid_points[0] - 1) - 1); i += 1)\n{\n  for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n  {\n    for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        forcing[i][j][k][m] = (-1.0) * forcing[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/32"}
{"code": "for (size_t i = 0; i < (nbx * nby); ++i)\n{\n  values_px[i] += values_ot[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/39"}
{"code": "for (i = 0; i < 2000; i++)\n{\n  for (j = 0; j < 2000; j++)\n  {\n    result[i][j] = 0;\n    sum = 0;\n    for (k = 0; k < 3000; k++)\n    {\n      sum += mat1[i][k] * mat2[k][j];\n    }\n\n    result[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pradeepsinngh/practice-parallel-programming/openmp/matrix_multiplication_openmp/0"}
{"code": "for (k = 0; k < dims[0][2]; k++)\n{\n  x0 = start;\n  vranlc((2 * 128) * dims[0][1], &x0, 1220703125.0, tmp);\n  t = 1;\n  for (j = 0; j < dims[0][1]; j++)\n    for (i = 0; i < 128; i++)\n  {\n    u0[k][j][i].real = tmp[t++];\n    u0[k][j][i].imag = tmp[t++];\n  }\n\n\n  if (k != dims[0][2])\n    dummy = randlc(&start, an);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/31"}
{"code": "for (part = 0; part < 3; part++)\n{\n  isok1 = 0;\n  words = startWords;\n  repeats = startRepeats;\n  for (p = 0; p < 3; p++)\n  {\n    size_x = words * (sizeof(float));\n    x_cpu = (float *) _mm_malloc(size_x, 16);\n    if (x_cpu == 0)\n    {\n      printf(\" ERROR WILL EXIT\\n\");\n      printf(\" Press Enter\\n\");\n      g = getchar();\n      exit(1);\n    }\n\n    for (i = 0; i < words; i++)\n    {\n      x_cpu[i] = newdata;\n    }\n\n    start_time();\n    runTests();\n    end_time();\n    fpmops = ((float) words) * ((float) opwd);\n    mflops = ((((float) repeats) * fpmops) / 1000000.0f) / ((float) secs);\n    fprintf(outfile, \"%15s %9d %5d %8d %10.6f %8.0f \", title[0], words, opwd, repeats, secs, mflops);\n    printf(\"%15s %9d %5d %8d %10.6f %8.0f \", title[0], words, opwd, repeats, secs, mflops);\n    isok1 = 0;\n    float one = x_cpu[0];\n    if (one == newdata)\n    {\n      isok2 = 1;\n      isok1 = 1;\n    }\n\n    for (i = 1; i < words; i++)\n    {\n      if (one != x_cpu[i])\n      {\n        isok1 = 1;\n        if (count1 < 10)\n        {\n          errors[0][count1] = x_cpu[i];\n          errors[1][count1] = one;\n          erdata[0][count1] = i;\n          erdata[1][count1] = words;\n          erdata[2][count1] = opwd;\n          erdata[3][count1] = repeats;\n          count1 = count1 + 1;\n        }\n\n      }\n\n    }\n\n    if (isok1 == 0)\n    {\n      fprintf(outfile, \" %10.6f   Yes\\n\", x_cpu[0]);\n      printf(\" %10.6f   Yes\\n\", x_cpu[0]);\n    }\n    else\n    {\n      fprintf(outfile, \"   See later   No\\n\");\n      printf(\"   See log     No\\n\");\n    }\n\n    _mm_free(x_cpu);\n    words = words * 10;\n    repeats = repeats / 10;\n    if (repeats < 1)\n      repeats = 1;\n\n  }\n\n  fprintf(outfile, \"\\n\");\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NiramayVaidya/Linux_OpenMP_Benchmark_Results/code_and_results_files/32_bit/openmp/code/OpenMPMFLOPS/2"}
{"code": "for (size_t i = N - 2; i < N; ++i)\n  printf(\"Y[%zu] = %g\\n\", i, Y[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/clang-317896/clang-317896/3"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  data1[i] += i;\n  for (int j = 0; j < 16; j++)\n  {\n    data2[i][j] += i + j;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/target/test_target_imperfect_loop/0"}
{"code": "for (j = 0; j < (innerreps / nthreads); j++)\n{\n  omp_set_lock(&omp_lock);\n  delay(delaylength);\n  omp_unset_lock(&omp_lock);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/syncbench/syncbench/0"}
{"code": "for (int i = 0; i < ALTURA; ++i)\n{\n  for (int j = 0; j < ANCHURA; ++j)\n  {\n    matrizPixeles[i][j].b = (unsigned char) buffer[((i * ANCHURA) + j) + ((ANCHURA * ALTURA) * 2)];\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danielsto/arcos-openmp/Paralela/ARCfmtut_par/2"}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  counters[tid]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kang235/OpenMP/TestParallelFor/0"}
{"code": "for (int i = 0; i < g->num_verts; ++i)\n  visit_counts[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JulieSanw/OpenMP/surf/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruparelmetarya/OpenMP-vs-TBB-A-survey-on-Parallel-Programming-Models/Source-codes/sum-red-openmp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    res[(i * n) + j] = a[(i * n) + j] + b[(i * n) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_strassen/0"}
{"code": "for (i = 0; i < 11; i++)\n{\n  printf(\"Hello World %d\\n\", i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-nowait/0"}
{"code": "for (T i = 0; i < 2; ++i)\n  a = 2;\n\n", "pragma": "#pragma omp target parallel for simd schedule(dynamic) default(none) linear(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/target_parallel_for_simd_ast_print/0"}
{"code": "for (int node = 0; node < node_num; node++)\n{\n  int rnd_node = app_GetUniqueRnd(node, node_num);\n  app_AddEdgeToGraph(graph, node, rnd_node);\n  printf(\"\\nNode.%d  =>  Rnd_Dest_Node: %d\", node, rnd_node);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ata-Pab/Parallel_BFS_OpenMP/parallel_bfs_openmp/4"}
{"code": "for (int d = 0; d < 1; d++)\n{\n  arg1_l[d] = reduct1[(arg1_offset + d) + (item.get_group_linear_id() * 1)];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/sycl/get_min_dt_kernel_kernel/1"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  for (int j = 0; j < 4; j++)\n  {\n    if (dist[i][j] == 99999)\n      printf(\"INF\\t\");\n    else\n      printf(\"%d\\t\", dist[i][j]);\n\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/shortestp/floyd/1"}
{"code": "for (int i = 10; i > 1; i--)\n{\n  a[k]++;\n  k = k + 3;\n}\n\n", "pragma": "  #pragma omp for simd linear(k : 3) schedule(simd, nonmonotonic: dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_simd_codegen/1"}
{"code": "for (uint i = 0; i < input_vec.size(); ++i)\n{\n  normd_scores[i] = std_norm[i] + score[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/5"}
{"code": "for (ii = 1; ii <= nzrow; ii++)\n{\n  i = nzloc[ii];\n  mark[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/26"}
{"code": "for (i = 0; i < 20; i++)\n{\n  realcipher[i] = (atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16) + atoi16[ARCH_INDEX(ciphertext[(i * 2) + 1])];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/citrix_ns_fmt_plug/1"}
{"code": "for (i = 0; i < 1000; i++)\n  F[i] = (double *) malloc((sizeof(double)) * 3);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aryan-jaiswal/many_body_openmp/many_body/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  area += f(a + ((i + 0.5) * step)) * step;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgavrisyuk/OpenMP/main/2"}
{"code": "for (; (i < (N * 2)) && (j < (N * 2)); i = (i + incX) + 4, j = (j + incY) + 4)\n{\n  _mm_store_ps(YP + j, _mm_load_ps(XP + i));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/copy/7"}
{"code": "for (i = 1; i <= 100; ++i)\n{\n  for (j = 1; j <= 100; ++j)\n    prv[i][j] = h[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Jacob_iterations_OpenMP/0"}
{"code": "for (int t = 0; t < 256; t++)\n{\n  omp_init_lock(&lck[t]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/histo_locks/1"}
{"code": "for (i = 0; i < HIgh_h; i++)\n{\n  for (j = 0; j < HIgh_w; j++)\n  {\n    conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + bias_conv15[layer15_index];\n    if (conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] < 0)\n      conv15_data[(((layer15_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/59"}
{"code": "for (i = 0; i < N; ++i)\n{\n  Y[i] += a * X[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/omptrace/examples/axpy/0"}
{"code": "for (unsigned int i = 0; i < size; i += 1)\n{\n  int id = 3;\n  a[i] = (id * i) % 7;\n  b[i] = (id * i) % 13;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mahmoudnabil/openmp/main/0"}
{"code": "for (int j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    yvel1[FTNREF2D(j, (y_max + 1) + k, x_max + 5, x_min - 2, y_min - 2)] = -yvel1[FTNREF2D(j, (y_max + 1) - k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/41"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    for (k = 0; k < N; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnx4015/CompParaleDist/Code/OpenMP/multParalleli/2"}
{"code": "for (i = 0; i < 1000; ++i)\n  iter[i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/worksharing/for/kmp_doacross_check/1"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    C[(i * ldc) + j] *= BETA;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openmpf/openmpf-component-archive/DarknetDetection/darknet_lib/src/gemm/7"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  x[i] = dist(gen);\n  y[i] = 0;\n  y_true[i] = (a * x[i]) + b;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elyaishere/sk_high_performance_computing/openmp/LeastSquares/0"}
{"code": "for (q = 0; q < 1024; q++)\n{\n  forces[q][0] = (forces[q][1] = (forces[q][2] = 0));\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    forces[q][0] += loc_forces[thread][q][0];\n    forces[q][1] += loc_forces[thread][q][1];\n    forces[q][2] += loc_forces[thread][q][2];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwwwwwOwO/Parallel-program/nbody/OpenMP_solver/2"}
{"code": "for (int i = 0; i < n; i++)\n  if (a[i] != b[i])\n{\n  err++;\n  printf(\"Error at %d, expected %lf, got %lf\\n\", i, b[i], a[i]);\n  if (err > 10)\n    return err;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/memory_mgmt_pinned_predefined/memory_mgmt_pinned_predefined/0"}
{"code": "for (i = 0; i < n_images; i++)\n{\n  if (g->SavedImages[i].ImageDesc.ColorMap)\n  {\n    fprintf(stderr, \"Error: application does not support local colormap\\n\");\n    ok = 0;\n    if (ok)\n      colmap = g->SavedImages[i].ImageDesc.ColorMap;\n\n  }\n\n  for (j = 0; (j < (width[i] * height[i])) && ok; j++)\n  {\n    int c;\n    c = g->SavedImages[i].RasterBits[j];\n    p[i][j].r = colmap->Colors[c].Red;\n    p[i][j].g = colmap->Colors[c].Green;\n    p[i][j].b = colmap->Colors[c].Blue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/load_pixels/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = a;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kandasamy73/ECEC413/omp/code_examples/Simple OpenMP programs/omp_work_sharing_construct_single_directive/0"}
{"code": "for (i = 0; i < (k * nr_dimensions); i += nr_dimensions)\n{\n  j = (rand() % size) * nr_dimensions;\n  for (int p = 0; p < nr_dimensions; p++)\n    centroids[i + p] = dataset[j + p];\n\n  printf(\"[%d] - picked: %d\\n\", rank, j / nr_dimensions);\n  print_point(&centroids[i], nr_dimensions);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/17"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for collapse(2)      ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/for_collapse_messages/0"}
{"code": "for (d = 0; d < ((n - c) - 1); d++)\n  if (vetor[d] > vetor[d + 1])\n{\n  troca = vetor[d];\n  vetor[d] = vetor[d + 1];\n  vetor[d + 1] = troca;\n  trocou = 1;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_hybrid/1"}
{"code": "for (i = 0; i < 5; i++)\n{\n  sequential_result[i] = 0;\n  for (j = 0; j < 2; j++)\n  {\n    sequential_result[i] += (*((array + (i * 2)) + j)) * (*(vector + j));\n  }\n\n  if ((*(sequential_result + i)) != (*(result + i)))\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1b_MatrixVectorMult_OpenMP_approach2/1"}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ecryptfs_fmt_plug/1"}
{"code": "for (int i = 0; i < row; i++)\n{\n  for (int j = 0; j < col; j++)\n  {\n    sum[(i * col) + j] = mat1[(i * col) + j] + mat2[(i * col) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, chunk) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/week-8-caches/matrices/0"}
{"code": "for (int i = 1; i < K; i++)\n  tmp_mid[i] += tmp_mid[i - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dreeseaw/CountSort-OpenMP/sorting/1"}
{"code": "for (j = 0; j < d_imopVarPre82[1]; j++)\n{\n  for (ii = 0; ii <= (d_imopVarPre82[0] - fftblock); ii += fftblock)\n  {\n    for (k = 0; k < d_imopVarPre82[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        y0[k][i].real = x_imopVarPre83[k][j][i + ii].real;\n        y0[k][i].imag = x_imopVarPre83[k][j][i + ii].imag;\n      }\n\n    }\n\n    int _imopVarPre261;\n    int _imopVarPre262;\n    _imopVarPre261 = d_imopVarPre82[2];\n    _imopVarPre262 = logd_imopVarPre85[2];\n    cfftz(is_imopVarPre81, _imopVarPre262, _imopVarPre261, y0, y1);\n    for (k = 0; k < d_imopVarPre82[2]; k++)\n    {\n      for (i = 0; i < fftblock; i++)\n      {\n        xout_imopVarPre84[k][j][i + ii].real = y0[k][i].real;\n        xout_imopVarPre84[k][j][i + ii].imag = y0[k][i].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/3"}
{"code": "for (l = 0; l < nz; l++)\n{\n  ll = nnxye * l;\n  for (k = 0; k < ny; k++)\n  {\n    fxyz[(4 * (nx + (nxe * k))) + ll] = fxyz[((4 * nxe) * k) + ll];\n    fxyz[(1 + (4 * (nx + (nxe * k)))) + ll] = fxyz[(1 + ((4 * nxe) * k)) + ll];\n    fxyz[(2 + (4 * (nx + (nxe * k)))) + ll] = fxyz[(2 + ((4 * nxe) * k)) + ll];\n  }\n\n  for (j = 0; j < nx; j++)\n  {\n    fxyz[(4 * (j + (nxe * ny))) + ll] = fxyz[(4 * j) + ll];\n    fxyz[(1 + (4 * (j + (nxe * ny)))) + ll] = fxyz[(1 + (4 * j)) + ll];\n    fxyz[(2 + (4 * (j + (nxe * ny)))) + ll] = fxyz[(2 + (4 * j)) + ll];\n  }\n\n  fxyz[(4 * (nx + (nxe * ny))) + ll] = fxyz[ll];\n  fxyz[(1 + (4 * (nx + (nxe * ny)))) + ll] = fxyz[1 + ll];\n  fxyz[(2 + (4 * (nx + (nxe * ny)))) + ll] = fxyz[2 + ll];\n}\n\n", "pragma": "omp for nowait private(j,k,l,ll)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/22"}
{"code": "for (i = 0; i < (20 + 1); i++)\n{\n  int j;\n  omp_lock_t *my_lcks = &lcks[i * 1000];\n  for (j = 0; j < 1000; j++)\n  {\n    omp_init_lock(&my_lcks[j]);\n  }\n\n  for (j = 0; j < (1000 * 100); j++)\n  {\n    omp_set_lock(&my_lcks[j % 1000]);\n    omp_unset_lock(&my_lcks[j % 1000]);\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static) num_threads(NUM_TASKS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/lock/omp_init_lock/0"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  cast_out->vec_[ai] = (static_cast < ValueType) > 0;\n  for (int aj = 0; aj < this->ncol_; ++aj)\n  {\n    cast_out->vec_[ai] += this->mat_.val[DENSE_IND(ai, aj, this->nrow_, this->ncol_)] * cast_in->vec_[aj];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_dense/0"}
{"code": "for (int i = 0; i < 6; ++i)\n  span = max(span, elap[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/swapping/5"}
{"code": "for (i = 0; i < nmol; i++)\n{\n  for (j = 0; j <= 2; j++)\n  {\n    fgets(line, 80, fp);\n    sscanf(line, \"%s %s %s %lf %lf %lf\", nothing, nothing, nothing, &r[i][j][0], &r[i][j][1], &r[i][j][2]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HrithikRai/Parallelization-of-Energy-Calculation-for-a-box-of-water-molecules/waters_openmp/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  a[i] = (long *) malloc((sizeof(long *)) * 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Magiera/P-M-D/openMP/matrix/5"}
{"code": "for (int i = 0; i < (n - 1); ++i)\n{\n  pthread_mutex_lock(&pivot_mutex);\n  count_threads++;\n  if (count_threads == WORKING_THREADS)\n  {\n    condition_pivot(i, n);\n    distribute_work(i + 1, n);\n    count_threads = 0;\n    pthread_cond_broadcast(&cd);\n  }\n  else\n  {\n    pthread_cond_wait(&cd, &pivot_mutex);\n  }\n\n  pthread_mutex_unlock(&pivot_mutex);\n  for (int j = thread_range[_tid].first; j < thread_range[_tid].second; ++j)\n  {\n    double fac = a[id[j]][i] / a[id[i]][i];\n    for (int k = i + 1; k < n; ++k)\n    {\n      a[id[j]][k] -= a[id[i]][k] * fac;\n    }\n\n    a[id[j]][i] = 0;\n    b[id[j]] -= b[id[i]] * fac;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/gauss_elim/2"}
{"code": "for (int i = 2; i < 5; i++)\n{\n  timeStart = omp_get_wtime();\n  FillingMasParallel(masB, MasLen, i);\n  timeEnd = omp_get_wtime();\n  ((cout << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0442\u043e\u043a\u043e\u0432\") << i) << \": \";\n  ((cout << \"\u0412\u0440\u0435\u043c\u044f \u043f\u0430\u0440\u0430\u043b\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u044b = \") << (timeEnd - timeStart)) << endl;\n  (SaveOut << (timeEnd - timeStart)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/0"}
{"code": "for (z = 0; z < OMP_zMax; z++)\n{\n  for (y = 0; y < OMP_yMax; y += 16)\n  {\n    int ind = OMP_Index(0, y, z);\n    u[ind] *= boundryScale;\n    u[ind + OMP_xMax] *= boundryScale;\n    u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    int temp = (((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax;\n    u[temp] *= boundryScale;\n    u[temp + OMP_xMax] *= boundryScale;\n    u[(temp + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((temp + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    for (x = 1; x < OMP_xMax; x++)\n    {\n      int xyzInd = OMP_Index(x, y, z);\n      u[xyzInd] += u[xyzInd - 1] * nu;\n      u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n      u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      temp = (((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax;\n      u[temp] += u[temp - 1] * nu;\n      u[temp + OMP_xMax] += u[(temp + OMP_xMax) - 1] * nu;\n      u[(temp + OMP_xMax) + OMP_xMax] += u[((temp + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((temp + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n    }\n\n    u[ind] *= boundryScale;\n    u[ind + OMP_xMax] *= boundryScale;\n    u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    temp = (((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax;\n    u[temp] *= boundryScale;\n    u[temp + OMP_xMax] *= boundryScale;\n    u[(temp + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((temp + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n    for (x = OMP_xMax - 2; x >= 0; x--)\n    {\n      int xyzInd = OMP_Index(x, y, z);\n      u[xyzInd] += u[xyzInd + 1] * nu;\n      u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n      u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      temp = (((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax;\n      u[temp] += u[temp + 1] * nu;\n      u[temp + OMP_xMax] += u[(temp + OMP_xMax) + 1] * nu;\n      u[(temp + OMP_xMax) + OMP_xMax] += u[((temp + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((temp + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[(((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[(((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      u[((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((temp + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/loopunroll16/2ompDeblur/0"}
{"code": "for (i = 0; i < 2048; i++)\n  for (j = 0; j < 2048; j++)\n{\n  a[i][j] = 1.1 * ((2 * i) + j);\n  b[i][j] = 1.2 * (i + (2 * j));\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uma07/Matrix-Multipliaction-openMP/mmt/1"}
{"code": "for (int i = 0; i < desc.size(); i++)\n{\n  desc[i] = (desc[i] - mean) / (stdev + 1e-10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zon5566/SIFT-on-OpenMP/sift/8"}
{"code": "for (int i = 0; i < dict_get_word_count(passwords); i++)\n{\n  char *encrypted = dict_get_word(passwords, i);\n  int success = pthread_try_crack(encrypted, dicts, dicts_len, 0, buf, buflen, 0);\n  if (success == 1)\n  {\n    printf(\"%3d: SUCCES: %s <-- %s\\n\", i, encrypted, buf);\n    successes++;\n  }\n  else\n  {\n    printf(\"%3d: FAILED: %s <-- %s\\n\", i, encrypted, \"???\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mnahmad12/PasswordCracking-PThreads-OpenMP/pthread_passcrack/0"}
{"code": "for (int i = 0; i < 256; i++)\n{\n  b[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-ifaces/clang-ifaces/2"}
{"code": "for (int k = 0; k < N; k++)\n{\n  tmp = M[k][k];\n  for (int j = k; j < N; j++)\n  {\n    M[k][j] = M[k][j] / tmp;\n  }\n\n  for (int i = k + 1; i < N; i++)\n  {\n    tmp = M[i][k];\n    for (int j = k + 1; j < N; j++)\n    {\n      M[i][j] = M[i][j] - (tmp * M[k][j]);\n    }\n\n    M[i][k] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/ARMomp/4"}
{"code": "for (i = 0; i < sizeX; ++i)\n{\n  for (j = 0; j < sizeY; ++j)\n  {\n    a[i][j] = (rand() % 30) + 1;\n  }\n\n  b[i] = (rand() % 20) + 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marufdsi/OpenMP_Nested_Parallelism/TestNested/0"}
{"code": "for (j = 1; j <= 10; j++)\n{\n  product *= j;\n}\n\n", "pragma": "omp for schedule(dynamic,1) reduction(*:product)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_reduction/2"}
{"code": "for (int i = 0; i < (time_steps - 1); i++)\n  norm_rand[i] = rand_gen(mean, std_dev);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RajdeepKonwar/stockast/stockast/2"}
{"code": "for (i = 0; i < h; i++)\n{\n  y = (i * yinc) + ymin;\n  x = xmin;\n  for (j = 0; j < w; j++)\n  {\n    pgrid[(i * w) + j] = xy2color(x, y, prof);\n    x += xinc;\n  }\n\n}\n\n", "pragma": "omp parallel for private(x, j, y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/mandel/0"}
{"code": "for (int k = 0; k < n; k++)\n{\n  rh[ir[k] - 1] += 1.0 - rx[k];\n  rh[ir[k]] += rx[k];\n}\n\n", "pragma": "      #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/19"}
{"code": "for (r = 0; r < rows; r++)\n{\n  for (c = 0; c < cols; c++)\n  {\n    *((arr + (r * cols)) + c) = (double) ((rows * c) + c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adhithadias/openmp-mpi-examples/src/ece563/hw6/omp/omp_mm/2"}
{"code": "for (i = 0; i < n; i++)\n  sum += a[i];\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/computingSum/1"}
{"code": "for (int i = 0; i < numDimensions; i++)\n  printf(\"%8.5f\", velocity[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Dynamique_Moleculaire/DynMol_parallel/5"}
{"code": "for (int j = 0; j < CutOffPrint; j++)\n  printf(\"%.2f \", c[i][j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter6/fig6.22-overlap-comp-io/5"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  cast_out->vec_[ai] = cast_in->vec_[ai];\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (this->mat_.col[aj] < ai)\n    {\n      cast_out->vec_[ai] -= this->mat_.val[aj] * cast_out->vec_[this->mat_.col[aj]];\n    }\n    else\n    {\n      if (this->L_diag_unit_ == false)\n      {\n        assert(this->mat_.col[aj] == ai);\n        diag_aj = aj;\n      }\n\n      break;\n    }\n\n  }\n\n  if (this->L_diag_unit_ == false)\n  {\n    cast_out->vec_[ai] /= this->mat_.val[diag_aj];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/23"}
{"code": "for (i = 0; i <= 63; i += 1)\n{\n  for (j = 0; j <= 63; j += 1)\n  {\n    for (k = 0; k <= 4; k += 1)\n    {\n      for (m = 0; m <= 4; m += 1)\n      {\n        a[i][j][k][m] = 0.0;\n        b[i][j][k][m] = 0.0;\n        c[i][j][k][m] = 0.0;\n        d[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/125"}
{"code": "for (int i = 0; i < SIZE; i++)\n  (cout << arr[i]) << ' ';\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wildDoubt/parallel-programming/source/practice4/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  input[i] = rand() % size;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/antonKorobenko/parallel-binsort/binsort_openMp/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  cifar_buf[i] = clCreateBuffer(context, CL_MEM_READ_ONLY, DATA_SIZE, 0, &err);\n  err = clEnqueueWriteBuffer(command_queue[i][0], cifar_buf[i], CL_TRUE, 0, DATA_SIZE, (void *) dataset, 0, 0, write_event[i] + sheight);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/4"}
{"code": "for (i = 0; i < n; i++)\n  x[i] = (x[i] + a) * b;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/biotrump/openmp-simd/openmpmflops/OpenMPMFLOPS/2"}
{"code": "for (int y = 1; y < (height - 1); y++)\n{\n  for (int x = 1; x < (width - 1); x++)\n  {\n    gridA[(y * width) + x] = 0.25 * (((gridB[((y * width) + x) + 1] + gridB[((y * width) + x) - 1]) + gridB[((y + 1) * width) + x]) + gridB[((y - 1) * width) + x]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/te42kyfo/omp_jacobi/main1/1"}
{"code": "for (i = 0; i < 500; i++)\n  u[i] = (float *) malloc(500 * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/array_init_2/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->distances[v] = 4294967295U / 2;\n  stats->parents[v] = 4294967295U;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/0"}
{"code": "for (_index = 0; _index < ((((_b * _b) * _b) - 1) / 2); _index++)\n{\n  z = (_index % _b) - nk;\n  x = ((_index - (_index % (_b * _b))) / (_b * _b)) - nk;\n  y = (((_index % (_b * _b)) - (_index % _b)) / _b) - nk;\n  k_array[ind] = ((2. * 3.14159265358979323846) / L) * sqrt((double) (((x * x) + (y * y)) + (z * z)));\n  scalar_rpy_ewald_recip(k_array[ind], xi, &m2_array[ind]);\n  kvec_array[3 * ind] = ((2. * 3.14159265358979323846) / L) * x;\n  kvec_array[(3 * ind) + 1] = ((2. * 3.14159265358979323846) / L) * y;\n  kvec_array[(3 * ind) + 2] = ((2. * 3.14159265358979323846) / L) * z;\n  ind++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/final/bd_all/5"}
{"code": "for (i = 2; i <= n; ++i)\n  if (isPrimeNumber[i])\n{\n  for (int j = i * i; j <= n; j += i)\n    isPrimeNumber[j] = false;\n\n  primes[primesCounter++] = i;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kamilkolodziejski/put-openmp/put-openmp/2"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if ((particleBC[i] == surface) || (particleType[i] == wall))\n    fprintf(fp, \"%d \", PTYPE[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/139"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  (cout << \"\\n\") << a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/parallel_sorts/bsort/3"}
{"code": "for (int i = 0; i < neurons; i++)\n{\n  for (int j = 0; j < inputsNum; j++)\n  {\n    weightsDelta[(i * inputsNum) + j] += (0.3 * errors[i]) * inputs[j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn06/0"}
{"code": "for (int i = 0; i < 26; i++)\n{\n  count[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/mapreduce-openmp/5"}
{"code": "for (i = 0; i < 10; i++)\n  j = 0;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/inputBug342/0"}
{"code": "for (int i = 0; i < x.size(); i++)\n{\n  a += x[i] * y[i];\n  b += x[i] * x[i];\n  c += y[i] * y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/0"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  gZ[i] = g(Z[i]);\n  gZg[i] = pow(gZ[i], -gamma);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/60"}
{"code": "for (size_t i = 0; i < content.size(); i++)\n{\n  content[i] = mapper(content[i].key);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jayrobo/OpenMP/Lab 4/Word_Count/3"}
{"code": "for (i = 0; i < nx; i++)\n{\n  b[i] += A[i][j] * x[i];\n}\n\n", "pragma": "omp for nowait reduction(+:b[i])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShoeShi/Parallel-Programming-Samples/1OpenMPColumnWiseMat/main/0"}
{"code": "for (i = 0; i < 16; i++)\n{\n  int id = omp_get_thread_num();\n  printf(\"Loop 1 - (%d) gets iteration %d\\n\", id, i);\n}\n\n", "pragma": "omp for schedule(dynamic, 2) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab2/openmp/worksharing/5.ordered/0"}
{"code": "for (i = 0; i < dataSet.n; i++)\n{\n  for (j = 0; j < dataSet.p; j++)\n  {\n    sum = 0;\n    for (k = 0; k < dataSet.m; k++)\n    {\n      sum += dataSet.A[(i * dataSet.m) + k] * dataSet.B[(k * dataSet.p) + j];\n    }\n\n    dataSet.C[(i * dataSet.p) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 200)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gholomia/Parallax/docs/assignment-2/matrix-multiplication/matmul/0"}
{"code": "for (int i = 0; i < (numOfFiles + 2); i++)\n  if (entry = readdir(d))\n{\n  if ((!strcmp(entry->d_name, \".\")) || (!strcmp(entry->d_name, \"..\")))\n    ;\n  else\n    evalute(d, entry, strFinal, dirName);\n\n}\n\n\n", "pragma": "omp for private(entry) schedule(dynamic, 1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ricardoreais/exam-evaluator/exam-evaluator/0"}
{"code": "for (i = 0; i < NUM_POINTS; i++)\n{\n  m1m2Result[i] = 0;\n  mindistance = distanceL1(m1, m2, i, 0);\n  for (j = 1; j < NUM_POINTS; j++)\n  {\n    distance = distanceL1(m1, m2, i, j);\n    if (distance < mindistance)\n    {\n      mindistance = distance;\n      m1m2Result[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexandra182/code-optimization-samples/L1/2"}
{"code": "for (i = 0; i < 35000000; i++)\n{\n  vecX[i] = (i + 1) * 0.35;\n  vecY[i] = (i + 1) * 0.18;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JairoDaniel/Taller_2_OpenMP_Jairo_Ortega/src/saxpy_par/1"}
{"code": "for (int i = 0; i < (nrow + 1); ++i)\n{\n  if (i < (idx + 1))\n  {\n    row_offset[i] = this->mat_.row_offset[i];\n  }\n  else\n  {\n    row_offset[i] = this->mat_.row_offset[i] + shift;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/125"}
{"code": "for (i = 0; i < 10; i++)\n{\n  B++;\n  printf(\"threadID = %d, %d: %d\\n\", omp_get_thread_num(), i, B);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/10"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  double *X = X0 + ((i % cX) * rX);\n  double *Y = Y0 + ((i / cX) * rY);\n  double cc = 0.0;\n  double nn = 0.0;\n  double rc = 0.0;\n  double rn = 0.0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double t;\n    double y;\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    y = (z * W[k]) - rc;\n    t = cc + y;\n    rc = (t - cc) - y;\n    cc = t;\n    y = (z * W[k]) - rn;\n    t = nn + y;\n    rn = (t - nn) - y;\n    nn = t;\n  }\n\n  CC[i] = cc;\n  if (NN != NULL)\n    NN[i] = nn;\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/5"}
{"code": "for (i = 0; i < size; i++)\n{\n  free(mat[i]);\n  free(P[i]);\n  free(L[i]);\n  free(U[i]);\n  free(matTemp[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/12"}
{"code": "for (i = 0; i < middle_filter; i++)\n  for (j = core_matrix; j < s_matrix; j++)\n{\n  sum = 0, count = 0;\n  for (p = 0; p < s_filter; p++)\n    for (q = 0; q < s_filter; q++)\n  {\n    if ((((((i - middle_filter) + p) >= 0) && (((i - middle_filter) + p) < s_matrix)) && (((j - middle_filter) + q) >= 0)) && (((j - middle_filter) + q) < s_matrix))\n    {\n      count++;\n      sum += filter[p][q] * matrix_o[(i - middle_filter) + p][(j - middle_filter) + q];\n    }\n\n  }\n\n\n  matrix_d[i][j] = sum / count;\n}\n\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ichaparroc/convolution-matrix-filter-openmp/convolution-2/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  unsigned char hash[16];\n  unsigned char hex_hash[2 * 16];\n  unsigned char *ptr_src;\n  unsigned char *ptr_dst;\n  MD5_CTX ctx;\n  int i;\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, cur_salt->login_id, cur_salt->login_id_len);\n  MD5_Update(&ctx, saved_key[index], strlen(saved_key[index]));\n  MD5_Final(hash, &ctx);\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, hash, 16);\n  MD5_Update(&ctx, cur_salt->nonces, cur_salt->nonces_len);\n  MD5_Final(hash, &ctx);\n  ptr_src = hash;\n  ptr_dst = hex_hash;\n  for (i = 0; i < 16; ++i)\n  {\n    unsigned char v = *(ptr_src++);\n    *(ptr_dst++) = itoa16_shr_04[ARCH_INDEX(v)];\n    *(ptr_dst++) = itoa16_and_0f[ARCH_INDEX(v)];\n  }\n\n  MD5_Init(&ctx);\n  MD5_Update(&ctx, hex_hash, 2 * 16);\n  MD5_Update(&ctx, cur_salt->prehash_KD, cur_salt->prehash_KD_len);\n  MD5_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DMD5_fmt_plug/0"}
{"code": "for (x = 0; x < W; x++)\n{\n  pr = ((1.5 * (x - (W / 2))) / ((0.5 * zoom) * W)) + moveX;\n  pi = ((y - (H / 2)) / ((0.5 * zoom) * H)) + moveY;\n  newRe = (newIm = (oldRe = (oldIm = 0)));\n  for (i = 0; i < MAXITER; i++)\n  {\n    oldRe = newRe;\n    oldIm = newIm;\n    newRe = ((oldRe * oldRe) - (oldIm * oldIm)) + pr;\n    newIm = ((2 * oldRe) * oldIm) + pi;\n    if (((newRe * newRe) + (newIm * newIm)) > 4)\n      break;\n\n  }\n\n  if (i == MAXITER)\n  {\n    pixels[x][0] = 0;\n    pixels[x][1] = 0;\n    pixels[x][2] = 0;\n  }\n  else\n  {\n    double z = sqrt((newRe * newRe) + (newIm * newIm));\n    int brightness = (256 * log2((1.75 + i) - log2(log2(z)))) / log2((double) MAXITER);\n    pixels[x][0] = brightness;\n    pixels[x][1] = brightness;\n    pixels[x][2] = 255;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(pixels, moveX, moveY, zoom) private(x, pr, pi, newRe, newIm, oldRe, oldIm) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rochii/parallel-mandelbrot/hybrid/scripts/mandelbrot_hybrid_dynamic/0"}
{"code": "for (int i = 2; i <= (number / 2); i++)\n{\n  if ((number % i) == 0)\n  {\n    isPrime = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided,7)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code-mj12/Multithreaded-Codes/OpenMP/q1/0"}
{"code": "for (j = jb * Bsize; j < ((jb + 1) * Bsize); j++)\n{\n  for (k = kb * Bsize; k < ((kb + 1) * Bsize); k++)\n  {\n    Bwrk[((k % Bsize) * Bsize) + (j % Bsize)] = B[(k * Mdim) + j];\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/mm_gpu_block/1"}
{"code": "for (i = 0; i <= (((long) 2000000000) - 1); i += 1)\n{\n  x = (i + 0.5) * interval_width;\n  pi += 1.0 / ((x * x) + 1.0);\n}\n\n", "pragma": "omp parallel for private (x,i) reduction (+:pi)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB065-pireduction-orig-no/0"}
{"code": "for (unsigned int id = 0; id < numDevices[optimalPlatformId]; id++)\n{\n  cl_mem d_x;\n  cl_mem d_y;\n  cl_mem d_z;\n  cl_mem d_tempGPU;\n  cl_mem d_dct8x8Mat;\n  cl_mem d_dct8x8TMat;\n  size_t bytes = (matrixSize * matrixSize) * (sizeof(float));\n  size_t bytes1 = (BLOCK_SIZE * BLOCK_SIZE) * (sizeof(cl_float));\n  d_x = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, nullptr, &error);\n  checkError(error);\n  d_y = clCreateBuffer(context, CL_MEM_WRITE_ONLY, bytes, nullptr, &error);\n  checkError(error);\n  d_z = clCreateBuffer(context, CL_MEM_WRITE_ONLY, bytes, nullptr, &error);\n  checkError(error);\n  d_tempGPU = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, nullptr, &error);\n  checkError(error);\n  d_dct8x8Mat = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes1, nullptr, &error);\n  checkError(error);\n  d_dct8x8TMat = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes1, nullptr, &error);\n  checkError(error);\n  size_t localSize[2];\n  size_t globalSize[2];\n  localSize[0] = BLOCK_SIZE;\n  localSize[1] = BLOCK_SIZE;\n  globalSize[0] = matrixSize;\n  globalSize[1] = matrixSize;\n  cl_command_queue queue = clCreateCommandQueue(context, deviceIDs[optimalPlatformId][id], 0, &error);\n  checkError(error);\n  checkError(clEnqueueWriteBuffer(queue, d_x, CL_TRUE, 0, bytes, h_imgCopy, 0, nullptr, nullptr));\n  checkError(clEnqueueWriteBuffer(queue, d_dct8x8Mat, CL_TRUE, 0, bytes1, dct8x8Matrix, 0, nullptr, nullptr));\n  checkError(clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_x));\n  checkError(clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_y));\n  checkError(clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_dct8x8Mat));\n  checkError(clSetKernelArg(kernel, 3, sizeof(int32_t), &matrixSize));\n  gettimeofday(&start, NULL);\n  checkError(clEnqueueNDRangeKernel(queue, kernel, 2, NULL, globalSize, localSize, 0, NULL, NULL));\n  clFinish(queue);\n  checkError(clEnqueueReadBuffer(queue, d_y, CL_TRUE, 0, bytes, tempGPU, 0, NULL, NULL));\n  cl_command_queue queue1 = clCreateCommandQueue(context, deviceIDs[optimalPlatformId][id], 0, &error);\n  checkError(error);\n  checkError(clEnqueueWriteBuffer(queue1, d_tempGPU, CL_TRUE, 0, bytes, tempGPU, 0, nullptr, nullptr));\n  checkError(clEnqueueWriteBuffer(queue1, d_dct8x8TMat, CL_TRUE, 0, bytes1, dct8x8MatrixTranspose, 0, nullptr, nullptr));\n  checkError(clSetKernelArg(kernel1, 0, sizeof(cl_mem), &d_tempGPU));\n  checkError(clSetKernelArg(kernel1, 1, sizeof(cl_mem), &d_z));\n  checkError(clSetKernelArg(kernel1, 2, sizeof(cl_mem), &d_dct8x8TMat));\n  checkError(clSetKernelArg(kernel1, 3, sizeof(int32_t), &matrixSize));\n  checkError(clEnqueueNDRangeKernel(queue1, kernel1, 2, NULL, globalSize, localSize, 0, NULL, NULL));\n  clFinish(queue1);\n  checkError(clEnqueueReadBuffer(queue, d_z, CL_TRUE, 0, bytes, dctCoeffMatrixGPU, 0, NULL, NULL));\n  gettimeofday(&end, NULL);\n  elapsedTime = (end.tv_sec - start.tv_sec) * 1000.0;\n  elapsedTime += (end.tv_usec - start.tv_usec) / 1000.0;\n  elapsedTime /= 1000.0;\n  printf(\"OpenCL          : %.3f seconds\\n\", elapsedTime);\n  clReleaseMemObject(d_x);\n  clReleaseMemObject(d_y);\n  clReleaseMemObject(d_z);\n  clReleaseMemObject(d_tempGPU);\n  clReleaseMemObject(d_dct8x8Mat);\n  clReleaseMemObject(d_dct8x8TMat);\n  clReleaseCommandQueue(queue);\n  clReleaseCommandQueue(queue1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Raienryu97/parallelizationstudy/DCT/ocl/DCT/1"}
{"code": "for (int i = size - 1; i >= 0; i--)\n{\n  if (vet[i])\n  {\n    out = out + \"1\";\n  }\n  else\n  {\n    out = out + \"0\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danilo94/Genetic-Regulator-Network---With-OpenMP/main/2"}
{"code": "for (i = 1; i <= input; i++)\n{\n  x = m * ((double) ((2 * i) - 1));\n  sum = sum + (1.5 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/feliusps/High-Performance-Computing/OpemMP/p2parallel/0"}
{"code": "for (i = 0; i < (n - 1); i++)\n{\n  for (j = i + 1; j < n; j++)\n  {\n    if (x[j] < x[i])\n    {\n      tmp = x[i];\n      x[i] = x[j];\n      x[j] = tmp;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/1"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  C[i] = (double *) malloc(10000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixcpy/9"}
{"code": "for (l = 0; l < 3; l++)\n{\n  if_temp = 0;\n  if (l == 0)\n  {\n    if_temp = 1;\n  }\n  else\n    if (l == 1)\n  {\n    if (ifntempx[iintempx[l - 1]] == (-1))\n    {\n      if_temp = 1;\n    }\n\n  }\n  else\n    if (l == 2)\n  {\n    if ((ifntempx[iintempx[l - 1]] == (-1)) && (ifntempx[iintempx[l - 2]] == (-1)))\n    {\n      if_temp = 1;\n    }\n\n  }\n\n\n\n  if (if_temp)\n  {\n    if (ifntempx[iintempx[l]] != (-1))\n    {\n      nbe = ifntempx[iintempx[l]];\n      itemp = face_l1[l];\n      while (((l != 1) && (itemp <= face_l2[l])) || ((l == 1) && (itemp >= face_l2[l])))\n      {\n        lc = local_corner[face_a[itemp]][j[l]];\n        temp = cal_intempx[face_a[itemp]][lc];\n        ii = cal_iijj[lc][0];\n        jj = cal_iijj[lc][1];\n        ntemp = sje[nbe][face_a[itemp]][jj][ii];\n        if (ntemp == (-1))\n        {\n          ntemp = sje[nbe][face_a[itemp]][0][0];\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[l]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[itemp] = ntemp;\n            }\n\n          }\n\n        }\n        else\n        {\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[l]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[itemp] = ntemp;\n            }\n\n          }\n\n        }\n\n        itemp += face_ld[l];\n      }\n\n      if (ifntempx[iintempx[face_l1[l]]] != (-1))\n      {\n        nbe = ifntempx[iintempx[face_l1[l]]];\n        itemp = face_l2[l];\n        lc = local_corner[face_a[itemp]][j[face_l1[l]]];\n        temp = cal_intempx[face_a[itemp]][lc];\n        ii = cal_iijj[lc][0];\n        jj = cal_iijj[lc][1];\n        ntemp = sje[nbe][face_a[itemp]][jj][ii];\n        if (ntemp == (-1))\n        {\n          ntemp = sje[nbe][face_a[itemp]][0][0];\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[face_l1[l]]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[l] = ntemp;\n            }\n\n          }\n\n        }\n        else\n        {\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[face_l1[l]]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[l] = ntemp;\n            }\n\n          }\n\n        }\n\n      }\n      else\n        if (ifntempx[iintempx[face_l2[l]]] != (-1))\n      {\n        nbe = ifntempx[iintempx[face_l2[l]]];\n        itemp = face_l1[l];\n        lc = local_corner[face_a[itemp]][j[face_l2[l]]];\n        temp = cal_intempx[face_a[itemp]][lc];\n        ii = cal_iijj[lc][0];\n        jj = cal_iijj[lc][1];\n        ntemp = sje[nbe][face_a[itemp]][jj][ii];\n        if (ntemp == (-1))\n        {\n          ntemp = sje[nbe][face_a[itemp]][0][0];\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[face_l2[l]]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[l] = ntemp;\n            }\n\n          }\n\n        }\n        else\n        {\n          if (ntemp != (-1))\n          {\n            if (ifsame(ntemp, c_f[jjface[face_a[itemp]]][lc], nbe, j[face_l2[l]]))\n            {\n              ntempx[temp] = ntemp;\n              ifntempx[temp] = ntemp;\n              nnb[l] = ntemp;\n            }\n\n          }\n\n        }\n\n      }\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/37"}
{"code": "for (int i = 0; i < NUM; i++)\n{\n  c[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/decl_map_targ/decl_map_targ/0"}
{"code": "for (size_t i = 0; i < n; ++i)\n  p[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/11"}
{"code": "for (i = 0; i < ((int) n_rows_m); i++)\n{\n  for (j = 0; j < ((int) n_cols_m); j++)\n  {\n    t[(j * n_rows_m) + i] = m[(i * n_cols_m) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(i, j) shared(m, n_rows_m, n_cols_m, t) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/7"}
{"code": "for (uint a = 0; a < angles.size(); a++)\n{\n  sumAngle += data->ff.angles->Angle(angles[a].kind);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedronCycle/0"}
{"code": "for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  Bxc[i][j][k] = B0x * tanh((grid->getYC(i, j, k) - (Ly / 2)) / delta);\n  Bxc[i][j][k] += (((B0x / 10.0) * (M_PI / Ly)) * cos(((2 * M_PI) * grid->getXC(i, j, k)) / Lx)) * sin((M_PI * (grid->getYC(i, j, k) - (Ly / 2))) / Ly);\n  Byc[i][j][k] = B0y - ((((B0x / 10.0) * ((2 * M_PI) / Lx)) * sin(((2 * M_PI) * grid->getXC(i, j, k)) / Lx)) * cos((M_PI * (grid->getYC(i, j, k) - (Ly / 2))) / Ly));\n  Bzc[i][j][k] = B0z / cosh((grid->getYC(i, j, k) - (Ly / 2)) / delta);\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/79"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    tmp1 = dt * tz1;\n    tmp2 = dt * tz2;\n    lhs[i][j][k][AA][0][0] = (((-tmp2) * fjac[i][j][k - 1][0][0]) - (tmp1 * njac[i][j][k - 1][0][0])) - (tmp1 * dz1);\n    lhs[i][j][k][AA][0][1] = ((-tmp2) * fjac[i][j][k - 1][0][1]) - (tmp1 * njac[i][j][k - 1][0][1]);\n    lhs[i][j][k][AA][0][2] = ((-tmp2) * fjac[i][j][k - 1][0][2]) - (tmp1 * njac[i][j][k - 1][0][2]);\n    lhs[i][j][k][AA][0][3] = ((-tmp2) * fjac[i][j][k - 1][0][3]) - (tmp1 * njac[i][j][k - 1][0][3]);\n    lhs[i][j][k][AA][0][4] = ((-tmp2) * fjac[i][j][k - 1][0][4]) - (tmp1 * njac[i][j][k - 1][0][4]);\n    lhs[i][j][k][AA][1][0] = ((-tmp2) * fjac[i][j][k - 1][1][0]) - (tmp1 * njac[i][j][k - 1][1][0]);\n    lhs[i][j][k][AA][1][1] = (((-tmp2) * fjac[i][j][k - 1][1][1]) - (tmp1 * njac[i][j][k - 1][1][1])) - (tmp1 * dz2);\n    lhs[i][j][k][AA][1][2] = ((-tmp2) * fjac[i][j][k - 1][1][2]) - (tmp1 * njac[i][j][k - 1][1][2]);\n    lhs[i][j][k][AA][1][3] = ((-tmp2) * fjac[i][j][k - 1][1][3]) - (tmp1 * njac[i][j][k - 1][1][3]);\n    lhs[i][j][k][AA][1][4] = ((-tmp2) * fjac[i][j][k - 1][1][4]) - (tmp1 * njac[i][j][k - 1][1][4]);\n    lhs[i][j][k][AA][2][0] = ((-tmp2) * fjac[i][j][k - 1][2][0]) - (tmp1 * njac[i][j][k - 1][2][0]);\n    lhs[i][j][k][AA][2][1] = ((-tmp2) * fjac[i][j][k - 1][2][1]) - (tmp1 * njac[i][j][k - 1][2][1]);\n    lhs[i][j][k][AA][2][2] = (((-tmp2) * fjac[i][j][k - 1][2][2]) - (tmp1 * njac[i][j][k - 1][2][2])) - (tmp1 * dz3);\n    lhs[i][j][k][AA][2][3] = ((-tmp2) * fjac[i][j][k - 1][2][3]) - (tmp1 * njac[i][j][k - 1][2][3]);\n    lhs[i][j][k][AA][2][4] = ((-tmp2) * fjac[i][j][k - 1][2][4]) - (tmp1 * njac[i][j][k - 1][2][4]);\n    lhs[i][j][k][AA][3][0] = ((-tmp2) * fjac[i][j][k - 1][3][0]) - (tmp1 * njac[i][j][k - 1][3][0]);\n    lhs[i][j][k][AA][3][1] = ((-tmp2) * fjac[i][j][k - 1][3][1]) - (tmp1 * njac[i][j][k - 1][3][1]);\n    lhs[i][j][k][AA][3][2] = ((-tmp2) * fjac[i][j][k - 1][3][2]) - (tmp1 * njac[i][j][k - 1][3][2]);\n    lhs[i][j][k][AA][3][3] = (((-tmp2) * fjac[i][j][k - 1][3][3]) - (tmp1 * njac[i][j][k - 1][3][3])) - (tmp1 * dz4);\n    lhs[i][j][k][AA][3][4] = ((-tmp2) * fjac[i][j][k - 1][3][4]) - (tmp1 * njac[i][j][k - 1][3][4]);\n    lhs[i][j][k][AA][4][0] = ((-tmp2) * fjac[i][j][k - 1][4][0]) - (tmp1 * njac[i][j][k - 1][4][0]);\n    lhs[i][j][k][AA][4][1] = ((-tmp2) * fjac[i][j][k - 1][4][1]) - (tmp1 * njac[i][j][k - 1][4][1]);\n    lhs[i][j][k][AA][4][2] = ((-tmp2) * fjac[i][j][k - 1][4][2]) - (tmp1 * njac[i][j][k - 1][4][2]);\n    lhs[i][j][k][AA][4][3] = ((-tmp2) * fjac[i][j][k - 1][4][3]) - (tmp1 * njac[i][j][k - 1][4][3]);\n    lhs[i][j][k][AA][4][4] = (((-tmp2) * fjac[i][j][k - 1][4][4]) - (tmp1 * njac[i][j][k - 1][4][4])) - (tmp1 * dz5);\n    lhs[i][j][k][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dz1);\n    lhs[i][j][k][BB][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n    lhs[i][j][k][BB][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n    lhs[i][j][k][BB][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n    lhs[i][j][k][BB][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n    lhs[i][j][k][BB][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n    lhs[i][j][k][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dz2);\n    lhs[i][j][k][BB][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n    lhs[i][j][k][BB][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n    lhs[i][j][k][BB][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n    lhs[i][j][k][BB][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n    lhs[i][j][k][BB][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n    lhs[i][j][k][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dz3);\n    lhs[i][j][k][BB][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n    lhs[i][j][k][BB][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n    lhs[i][j][k][BB][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n    lhs[i][j][k][BB][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n    lhs[i][j][k][BB][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n    lhs[i][j][k][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dz4);\n    lhs[i][j][k][BB][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n    lhs[i][j][k][BB][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n    lhs[i][j][k][BB][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n    lhs[i][j][k][BB][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n    lhs[i][j][k][BB][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n    lhs[i][j][k][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dz5);\n    lhs[i][j][k][CC][0][0] = ((tmp2 * fjac[i][j][k + 1][0][0]) - (tmp1 * njac[i][j][k + 1][0][0])) - (tmp1 * dz1);\n    lhs[i][j][k][CC][0][1] = (tmp2 * fjac[i][j][k + 1][0][1]) - (tmp1 * njac[i][j][k + 1][0][1]);\n    lhs[i][j][k][CC][0][2] = (tmp2 * fjac[i][j][k + 1][0][2]) - (tmp1 * njac[i][j][k + 1][0][2]);\n    lhs[i][j][k][CC][0][3] = (tmp2 * fjac[i][j][k + 1][0][3]) - (tmp1 * njac[i][j][k + 1][0][3]);\n    lhs[i][j][k][CC][0][4] = (tmp2 * fjac[i][j][k + 1][0][4]) - (tmp1 * njac[i][j][k + 1][0][4]);\n    lhs[i][j][k][CC][1][0] = (tmp2 * fjac[i][j][k + 1][1][0]) - (tmp1 * njac[i][j][k + 1][1][0]);\n    lhs[i][j][k][CC][1][1] = ((tmp2 * fjac[i][j][k + 1][1][1]) - (tmp1 * njac[i][j][k + 1][1][1])) - (tmp1 * dz2);\n    lhs[i][j][k][CC][1][2] = (tmp2 * fjac[i][j][k + 1][1][2]) - (tmp1 * njac[i][j][k + 1][1][2]);\n    lhs[i][j][k][CC][1][3] = (tmp2 * fjac[i][j][k + 1][1][3]) - (tmp1 * njac[i][j][k + 1][1][3]);\n    lhs[i][j][k][CC][1][4] = (tmp2 * fjac[i][j][k + 1][1][4]) - (tmp1 * njac[i][j][k + 1][1][4]);\n    lhs[i][j][k][CC][2][0] = (tmp2 * fjac[i][j][k + 1][2][0]) - (tmp1 * njac[i][j][k + 1][2][0]);\n    lhs[i][j][k][CC][2][1] = (tmp2 * fjac[i][j][k + 1][2][1]) - (tmp1 * njac[i][j][k + 1][2][1]);\n    lhs[i][j][k][CC][2][2] = ((tmp2 * fjac[i][j][k + 1][2][2]) - (tmp1 * njac[i][j][k + 1][2][2])) - (tmp1 * dz3);\n    lhs[i][j][k][CC][2][3] = (tmp2 * fjac[i][j][k + 1][2][3]) - (tmp1 * njac[i][j][k + 1][2][3]);\n    lhs[i][j][k][CC][2][4] = (tmp2 * fjac[i][j][k + 1][2][4]) - (tmp1 * njac[i][j][k + 1][2][4]);\n    lhs[i][j][k][CC][3][0] = (tmp2 * fjac[i][j][k + 1][3][0]) - (tmp1 * njac[i][j][k + 1][3][0]);\n    lhs[i][j][k][CC][3][1] = (tmp2 * fjac[i][j][k + 1][3][1]) - (tmp1 * njac[i][j][k + 1][3][1]);\n    lhs[i][j][k][CC][3][2] = (tmp2 * fjac[i][j][k + 1][3][2]) - (tmp1 * njac[i][j][k + 1][3][2]);\n    lhs[i][j][k][CC][3][3] = ((tmp2 * fjac[i][j][k + 1][3][3]) - (tmp1 * njac[i][j][k + 1][3][3])) - (tmp1 * dz4);\n    lhs[i][j][k][CC][3][4] = (tmp2 * fjac[i][j][k + 1][3][4]) - (tmp1 * njac[i][j][k + 1][3][4]);\n    lhs[i][j][k][CC][4][0] = (tmp2 * fjac[i][j][k + 1][4][0]) - (tmp1 * njac[i][j][k + 1][4][0]);\n    lhs[i][j][k][CC][4][1] = (tmp2 * fjac[i][j][k + 1][4][1]) - (tmp1 * njac[i][j][k + 1][4][1]);\n    lhs[i][j][k][CC][4][2] = (tmp2 * fjac[i][j][k + 1][4][2]) - (tmp1 * njac[i][j][k + 1][4][2]);\n    lhs[i][j][k][CC][4][3] = (tmp2 * fjac[i][j][k + 1][4][3]) - (tmp1 * njac[i][j][k + 1][4][3]);\n    lhs[i][j][k][CC][4][4] = ((tmp2 * fjac[i][j][k + 1][4][4]) - (tmp1 * njac[i][j][k + 1][4][4])) - (tmp1 * dz5);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(c2 ,c1 ,c3c4 ,con43 ,c4 ,c3 ,c1345 ,k ,j ,i ,tmp1 ,tmp2 ,tmp3 ) lastprivate(tmp1 ,tmp2 ,tmp3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/66"}
{"code": "for (i = 0; i < n; ++i)\n  tmp += evec[i][j] * evec[i][j];\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/3"}
{"code": "for (i = 0; i < numRecords; i++)\n{\n  d_locations[i] = locations[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/nn/nn_omp/1"}
{"code": "for (int i = 0; i < NTIMES; i++)\n{\n  realSum += x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/parallel_no_critical/1"}
{"code": "for (int i = 0; i != 1024; i++)\n{\n  x[i] += y[i] * z[i];\n}\n\n", "pragma": "omp parallel for num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/parallel_for/test_parallel_for_notequals/0"}
{"code": "for (i = 0; i < 8192; ++i)\n{\n  for (j = 0; j < 8192; ++j)\n  {\n    A[i][j] = 1.0f;\n    B[i][j] = 1.0f;\n    C[i][j] = 0.0f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_naive/1"}
{"code": "for (i = 0; i < vec1->N; i++)\n{\n  if (vec1->elt[i] != vec2->elt[i])\n  {\n    nb_diff++;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:nb_diff)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DavidDureau/APP/TD1_OMP/omp_prod_mat_vec/correction/prod_mat_vec_omp/0"}
{"code": "for (int i = 0; i < (gpu_count + 1); i++)\n{\n  tasks[i].id = i;\n  tasks[i].A = &A[start + (sizePerDevice * i)];\n  tasks[i].B = &B[start + (sizePerDevice * i)];\n  tasks[i].C = &C[start + (sizePerDevice * i)];\n  if (i == gpu_count)\n  {\n    tasks[i].size = N - (sizePerDevice * gpu_count);\n  }\n  else\n  {\n    tasks[i].size = sizePerDevice;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rickyboy320/hpc_bench/vector/vector/2"}
{"code": "for (i = 0; i <= 131071; i += 1)\n{\n  x[i] = -1.0e99;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/EP/ep/1"}
{"code": "for (i = 0; i < (blockDimension + 2); i++)\n{\n  for (j = 0; j < (blockDimension + 2); j++)\n  {\n    block[i][j] = '?';\n    newblock[i][j] = '?';\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ippokratoys/Game-Of-Life-MPI-OpenMp-CUDA/openMp/6"}
{"code": "for (; i < size; ++i)\n  data[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarimAboshamia/Frequency-Histogram/main/4"}
{"code": "for (s = 0; s < nsteps; s++)\n{\n  increment_energy(cur, n, 1e-4f);\n  c = count_cells(cur, n);\n  propagate_energy(cur, next, n);\n  Emean = average_energy(next, n);\n  printf(\"%d %f\\n\", c, Emean);\n  float *tmp = cur;\n  cur = next;\n  next = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fam4r/uni-hpc/project/src/omp-earthquake/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  h_a[i] = 0.5;\n  h_b[i] = 0.5;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/minicurso-openmp-wscad-2017/src/example-target/example-target/1"}
{"code": "for (int i = 0; i < image_dim_y; i++)\n  for (int j = 0; j < image_dim_x; j++)\n  output_image(i, j) += total;\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ttsiodras/straylight/src/forward_model_single_psf_dual_resolution/24"}
{"code": "for (i = 0; i < 1000; ++i)\n{\n  C[i] = A[i] * B[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/vector-product/src/vector-product_gpu/1"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n{\n  pbin_max[i] = MIN + (pbin_width * (i + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_histogram/3"}
{"code": "for (n = 0; n < NPOIs; n++)\n{\n  fprintf(fp, \"%s\", idPOI[n]);\n  float dbuf = Node(idxPOI[n], iTime) / 60;\n  if (dbuf < 0.)\n    dbuf = -1.;\n\n  fprintf(fp, \" %6.2f\", dbuf);\n  float ampFactor = 1.;\n  if (flagRunupPOI[n])\n    ampFactor = pow(Node(idxPOI[n], iD), 0.25);\n\n  fprintf(fp, \" %6.3f\\n\", ampFactor * Node(idxPOI[n], iHmax));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/easyWave-omp/main/21"}
{"code": "for (int i = 0; i < 10; ++i)\n  a = i;\n\n", "pragma": "#pragma omp target teams distribute parallel for lastprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang9/tools/clang/test/OpenMP/nvptx_SPMD_codegen/0"}
{"code": "for (int j = 0; j < (n + 1); j++)\n{\n  if (A[i - 1] == B[j - 1])\n  {\n    DP[i][j] = DP[i - 1][j - 1] + 1;\n  }\n  else\n    if (P[c_i][j] == 0)\n  {\n    DP[i][j] = (DP[i - 1][j] > 0) ? (DP[i - 1][j]) : (0);\n  }\n  else\n  {\n    DP[i][j] = (DP[i - 1][j] > (DP[i - 1][P[c_i][j] - 1] + 1)) ? (DP[i - 1][j]) : (DP[i - 1][P[c_i][j] - 1] + 1);\n  }\n\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RayhanShikder/lcs_parallel/Experimental Codes/omp/row_wise_v1/row_wise_v1/1"}
{"code": "for (int i = 1; i <= 4; i++)\n{\n  char str[25] = \"cat (\";\n  char out[25] = \"out (\";\n  int a = i;\n  int tmp = i;\n  int cnt = 0;\n  while (tmp)\n  {\n    tmp = tmp / 10;\n    cnt++;\n  }\n\n  int j = cnt - 1;\n  char pok[25] = \").png\";\n  char lok[25];\n  while (a)\n  {\n    int k = a % 10;\n    lok[j] = (char) ('0' + k);\n    a = a / 10;\n    j--;\n  }\n\n  lok[cnt] = '\\0';\n  strcat(str, lok);\n  strcat(str, pok);\n  strcat(out, lok);\n  strcat(out, pok);\n  char *s = out;\n  char *p = str;\n  read_png_file(p, s);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/Parallel-Programming/negationImageParallel/0"}
{"code": "for (i = 0; i < iter; i++)\n  inum[i] = pow(10, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JamesdeLisle/OpenMP-messing/test2/0"}
{"code": "for (it = vec.begin(); it != vec.end(); it++)\n  (((((((cout << setw(15)) << (index++)) << setw(45)) << \"Article \") << it->second) << setw(55)) << it->first) << endl;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/avats101/ParallelNewsSearch/main/2"}
{"code": "for (j = 0; j <= (m - 1); j += 1)\n{\n  xx = (int) ((-1.0) + (dx * (i - 1)));\n  yy = (int) ((-1.0) + (dy * (j - 1)));\n  u[i][j] = 0.0;\n  f[i][j] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n}\n\n", "pragma": "omp parallel for private (xx,yy,j) firstprivate (alpha,dx,dy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_jacobi_seq/1"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  tmp[i * 2] = (*pI2PQ)[i].index1();\n  tmp[(i * 2) + 1] = (*pI2PQ)[i].index2();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD_Parallel/1"}
{"code": "for (i = 0; i < topoinfo->numR; i++)\n{\n  if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 1)\n  {\n    tmprlt->paras[((3 * i) + 2) + (2 * topoinfo->numG)] = randu(topoinfo->prsrandrange[0][((3 * i) + 2) + (2 * topoinfo->numG)], topoinfo->prsrandrange[1][((3 * i) + 2) + (2 * topoinfo->numG)]);\n  }\n  else\n    if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 2)\n  {\n    tmprlt->paras[((3 * i) + 2) + (2 * topoinfo->numG)] = 1.0 / randu(topoinfo->prsrandrange[0][((3 * i) + 2) + (2 * topoinfo->numG)], topoinfo->prsrandrange[1][((3 * i) + 2) + (2 * topoinfo->numG)]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/70"}
{"code": "for (int i = 0; i < numBlocks; i++)\n{\n  const int dev = i % ndevs;\n  printf(\"device chosen for iteration %d : %d\\n\", i, dev);\n  OMPVV_START_TIMER;\n  {\n    const int NN = blockWork[i];\n    const int startInd = (i % (numBlocks / ndevs)) * NN;\n    const int endInd = ((i % (numBlocks / ndevs)) + 1) * NN;\n    float *temp;\n    b[startInd - 1] = lboundary[i];\n    b[endInd + 1] = rboundary[i];\n    for (int j = startInd; j <= endInd; j++)\n      a[j] = ((b[j] + b[j - 1]) + b[j + 1]) / 3.0;\n\n    temp = b;\n    b = a;\n    a = temp;\n    lboundary[i] = a[startInd - 1];\n    rboundary[i] = a[endInd + 1];\n  }\n  OMPVV_STOP_TIMER;\n}\n\n", "pragma": "#pragma omp for schedule(static, gsz)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/ecp-omp/type2/stencilImb/bench/0"}
{"code": "for (c2 = 0; c2 <= (nj + (-1)); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/76"}
{"code": "for (int j = 0; j < Y_SIZE; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    host_y[(j * n) + i] = 0.0;\n    if (j == 14)\n      host_y[(j * n) + i] = 0.064;\n\n    if (j == 3)\n      host_y[(j * n) + i] = 0.218;\n\n    if (j == 21)\n      host_y[(j * n) + i] = 0.718;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/s3d-omp/S3D/2"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  array[i] = rand_r(&seed) % MAX_RAND;\n}\n\n", "pragma": "omp for schedule(guided, 6000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/domo23/mpr_openmp/random/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"i = %d, threadID = %d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/1"}
{"code": "for (i = i; i < length; i++)\n{\n  array[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sgsdeshp/OpenMP/marketing_research/6"}
{"code": "for (i = 0; i < (sizeof(out.u8)); i++)\n{\n  out.u8[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];\n  p += 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/SybaseASE_fmt_plug/2"}
{"code": "for (int j = 1; j < (N - 1); j++)\n  s->Bt[j] = ((s->Mcoefs2[0][j] * x[j - 1]) + (s->Mcoefs2[1][j] * x[j])) + (s->Mcoefs2[2][j] * x[j + 1]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/131"}
{"code": "for (i = 0; i <= (MAXCOL + 1); i++)\n  printf(\"#\");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuyanFeng1992/Parallel-C/\"GOL\" with OMP and MPI/9"}
{"code": "for (int i = 2; i <= limit; i++)\n{\n  if (mark[i] == true)\n  {\n    primes.push_back(i);\n    for (int j = i; j <= limit; j += i)\n    {\n      mark[j] = false;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wszymkowski/large-scale-computing-course/primes_domenowe/1"}
{"code": "for (int RowId = 0; RowId < RowN; RowId++)\n{\n  for (int ColId = 0; ColId < ColN; ColId++)\n  {\n    out->PutStr(GetStr(m(RowId, ColId), 20, 18));\n    out->PutCh(' ');\n  }\n\n  out->PutCh('\\n');\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/21"}
{"code": "for (i = 0; i < N; i++)\n  resultado[i] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/8/pmm-secuencial/2"}
{"code": "for (i = 0; i < N; i += 2)\n{\n  merge(a + tarr[i], a + tarr[i + 1], tarr[i + 1] - tarr[i], tarr[i + 2] - tarr[i + 1]);\n}\n\n", "pragma": "\t\t#pragma omp parallel for private(i) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/4"}
{"code": "for (int i = 0; i < ((len1 - window) + 1); i++)\n{\n  anchor[i] = s1.substr(i, window);\n  (cout << anchor[i]) << endl;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abhishekcs10/openmp_practice/parallel/0"}
{"code": "for (i = 0; i < max_keys_per_crypt; ++i)\n{\n  mpz_clear(pSRP_CTX[i].z_mod);\n  mpz_clear(pSRP_CTX[i].z_base);\n  mpz_clear(pSRP_CTX[i].z_exp);\n  mpz_clear(pSRP_CTX[i].z_rop);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/clipperz_srp_fmt_plug/2"}
{"code": "for (int k = 0; k < dataSet.nrows; ++k)\n{\n  const size_t kStar = bmus[k];\n  mappings[kStar][dataSet.labels[k]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yoch/sparse-som/src/bsom/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  goto L1;\n  argc++;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/target_teams_distribute_parallel_for_simd_messages/1"}
{"code": "for (j = 0; j < Ny; j++)\n{\n  un[0][j] = 0.0;\n  un[Nx - 1][j] = 0.0;\n  un1[0][j] = 0.0;\n  un1[Nx - 1][j] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/2"}
{"code": "for (uint32_t i = 0; i < nPoints; i++)\n{\n  double xPart = pointX[i] - 0.5;\n  xPart = ((xPart * xPart) * xPart) * xPart;\n  double yPart = pointY[i] - 0.5;\n  yPart = ((yPart * yPart) * yPart) * yPart;\n  double xyDependentPart = xPart + yPart;\n  result[i] = (-20) * xyDependentPart;\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogetherQ3/1"}
{"code": "for (int i = 0; i < SIZE; i++)\n  vector[i] = (rand() % SIZE) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s4mukka/bubblesortparallel/final_project/1"}
{"code": "for (int i = 0; i < mNumberOfThreads; i++)\n  mSearchControlVector[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_continuum/0"}
{"code": "for (int i = 0; i < LEVELS; i++)\n{\n  omp_init_lock(&lock[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DavidCarneros/Arco_OpenMP/histogram/histogram/0"}
{"code": "for (i = m - 1; i >= 0; i--)\n{\n  sum = 0;\n  for (j = i + 1; j < m; j++)\n  {\n    sum += a[i][j] * k[j];\n  }\n\n  k[i] = (b[i] - sum) / a[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaeldcampbell/GaussianEliminationParallel/src/openMPGaussianElimination/2"}
{"code": "for (i = 0; i < 64; ++i)\n  bar(i);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr27499/0"}
{"code": "for (i = n - 1; i >= 1; i--)\n  for (j = i + 1; j <= n; j++)\n  for (k = i + 1; k < j; k++)\n  c[i][j] = MIN(c[i][j], (w[i][j] + c[i][k]) + c[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/markpal/NPDP_Bench/knuth/knut/0"}
{"code": "for (i = 0; i < 100000; i = i + 1)\n{\n  Buyers[i].buyerOrSeller = 1;\n  Buyers[i].quantityHeld = 0;\n  Buyers[i].value = (rand() % 20) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_omp2/1"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  fprintf(fout, \"%ld %ld\\n\", i + 1, communityMap[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadSNAP/1"}
{"code": "for (int i = 0; i < sz; i++)\n{\n  m_lvec[i] = ubuff[i];\n  m_avec[i] = 0;\n  m_bvec[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/15"}
{"code": "for (size_t i = 0; i < 51200000; i++)\n{\n  a[i] = b[i] + val;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/addval/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  for (j = 0; j < len; j++)\n    u[i][j] = 0.5;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB021-reductionmissing-orig-yes/0"}
{"code": "for (int j = 0; j < n; j++)\n{\n  (cout << x[j]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/6_openmp/7"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (j = grid_points[1] - 3; j >= 0; j--)\n  {\n    j1 = j + 1;\n    j2 = j1 + 1;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,i ,j2 ,k ,m ,n )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/187"}
{"code": "for (int i = 0; i < P; ++i)\n{\n  if (i == procId)\n  {\n    generated_by_node[i] = particles_to_gen;\n  }\n  else\n  {\n    generated_by_node[i] = (((workslice < ull) > (((Nparticles, (static_cast < ull) > P, (static_cast < ull) > i)).stop - workslice)) < ull) > ((Nparticles, (static_cast < ull) > P, (static_cast < ull) > i)).start;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/emaballarin/distnbody-hm/main/0"}
{"code": "for (ptrdiff_t i = i_start; i < i_end; ++i)\n{\n  if (pred[i] != (-1))\n  {\n    pred_win.add_request(i - i_start, pred_owner[i - i_start], pred_local[i - i_start], i - i_start);\n  }\n  else\n  {\n    pred_level[i - i_start] = UINT16_MAX;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/validate/2"}
{"code": "for (c3 = 0; c3 < ((N - c1) - 1); c3 += 1)\n  for (c4 = (((0 > ((-c1) + 1)) ? (0) : ((-c1) + 1)) > ((((-N) + c1) + c3) + 3)) ? ((0 > ((-c1) + 1)) ? (0) : ((-c1) + 1)) : ((((-N) + c1) + c3) + 3); c4 <= 1; c4 += 1)\n{\n  if (c4 == 1)\n  {\n    Pbp[c1][(c1 + c3) + 1] += ((Q[0][c1] * Q[(c1 + c3) + 1][N - 1]) * Qbp[c1][(c1 + c3) + 1]) / Q[0][N - 1];\n  }\n  else\n  {\n    for (c5 = 0; c5 <= ((c1 - 1) / 128); c5 += 1)\n      for (c7 = 0; c7 <= ((((N - c1) - c3) - 3) / 16); c7 += 1)\n    {\n      if (N >= (((c1 + c3) + (16 * c7)) + 19))\n      {\n        for (c15 = ((c1 + c3) + (16 * c7)) + 2; c15 <= (((c1 + c3) + (16 * c7)) + 17); c15 += 1)\n          Pbp[c1][(c1 + c3) + 1] += ((((Pbp[128 * c5][c15] * ERT) * Q[(128 * c5) + 1][c1]) * Qbp[c1][(c1 + c3) + 1]) * Q[((c1 + c3) + 1) + 1][c15 - 1]) / ((Qbp[128 * c5][c15] == 0) ? (1) : (Qbp[128 * c5][c15]));\n\n      }\n      else\n      {\n        for (c13 = 128 * c5; c13 <= (((c1 - 1) < ((128 * c5) + 127)) ? (c1 - 1) : ((128 * c5) + 127)); c13 += 1)\n        {\n          if (c13 >= ((128 * c5) + 1))\n            for (c15 = (c1 + c3) + 2; c15 <= (((c1 + c3) + (16 * c7)) + 1); c15 += 1)\n            Pbp[c1][(c1 + c3) + 1] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][(c1 + c3) + 1]) * Q[((c1 + c3) + 1) + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n\n          for (c15 = ((c1 + c3) + (16 * c7)) + 2; c15 < N; c15 += 1)\n            Pbp[c1][(c1 + c3) + 1] += ((((Pbp[c13][c15] * ERT) * Q[c13 + 1][c1]) * Qbp[c1][(c1 + c3) + 1]) * Q[((c1 + c3) + 1) + 1][c15 - 1]) / ((Qbp[c13][c15] == 0) ? (1) : (Qbp[c13][c15]));\n\n        }\n\n      }\n\n    }\n\n\n  }\n\n}\n\n\n", "pragma": "omp parallel for schedule(dynamic , 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_pb2_traco/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    for (int k = 0; k < size; k++)\n    {\n      R[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/godblessedkid/lu-decomp/LU_Master/4"}
{"code": "for (int i = 0; i < result.size(); i++)\n{\n  temp = result[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ysph/parallel-stuff/b_omp/convex_hull/2"}
{"code": "for (int i = 0; i < width; i++)\n{\n  a[i] = rand();\n  if ((a[i] % param) == 0)\n  {\n    control_max = a[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OlegShatin/openmp-homework/11/main/0"}
{"code": "for (int b = 0; b < l->output_shape[0]; ++b)\n{\n  for (int k = 0; k < l->output_shape[1]; ++k)\n  {\n    for (int i = 0; i < l->output_shape[2]; ++i)\n    {\n      for (int j = 0; j < l->output_shape[3]; ++j)\n      {\n        int out_idx = l->output[(((((b * l->output_shape[1]) * l->output_shape[2]) * l->output_shape[3]) + ((k * l->output_shape[2]) * l->output_shape[3])) + (i * l->output_shape[3])) + j];\n        int max_idx = -1;\n        float max = -FLT_MAX;\n        for (int n = 0; n < l->ksize; ++n)\n        {\n          for (int m = 0; m < l->ksize; ++m)\n          {\n            int cur_h = ((i * l->stride) + h_offset) + n;\n            int cur_w = ((j * l->stride) + w_offset) + m;\n            int in_idx = l->input[(((((b * l->input_shape[1]) * l->input_shape[2]) * l->input_shape[3]) + ((k * l->input_shape[2]) * l->input_shape[3])) + (cur_h * l->input_shape[3])) + cur_w];\n            int valid = (((cur_h >= 0) && (cur_h < l->output[2])) && (cur_w >= 0)) && (cur_w < l->output[3]);\n            float val = (valid != 0) ? (l->input[in_idx]) : (-FLT_MAX);\n            max = (val > max) ? (val) : (max);\n            max_idx = (val > max) ? (in_idx) : (max_idx);\n          }\n\n        }\n\n        l->output[out_idx] = max;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysh329/OpenMP-101/pooling/pooling/0"}
{"code": "for (i = 0; i < x; ++i)\n  for (j = 0; j < x; ++j)\n  if (((distance[i][k] * distance[k][j]) != 0) && (i != j))\n  if (((distance[i][k] + distance[k][j]) < distance[i][j]) || (distance[i][j] == 0))\n  distance[i][j] = distance[i][k] + distance[k][j];\n\n\n\n\n", "pragma": "omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/trdiaz/openmpLab2/test/0"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  {\n    ((((cout << \"Thread number \") << me) << \" in place number \") << place) << \" | Processors here: \";\n    for (int p = 0; p < nprocs; p++)\n      (cout << proc_ids[p]) << ' ';\n\n    cout << endl;\n  }\n}\n\n", "pragma": "#pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WalterNadalin/ParallelKDTree/2021Assignment02/src/info/0"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_result = host_result || a[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_or/2"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d : c[%d] = %d\\n\", id, i, c[i]);\n}\n\n", "pragma": "omp for schedule(dynamic,chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yehia67/OpenMP-Examples/vectorAddition/0"}
{"code": "for (int i = 0; i < dots_number; i++)\n{\n  total_sum = total_sum + (y_values[i] * partition);\n}\n\n", "pragma": "#pragma omp parallel for shared(y_values, dots_number, partition) reduction(+:total_sum) default(none) num_threads(threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail11235/openmp/integral/0"}
{"code": "for (i = N - 1; i >= 0; i--)\n{\n  for (j = i + 1; j < N; j++)\n  {\n    Pu[i][j] = ((Q[0][i] * Q[j][N - 1]) * 1) / Q[0][N - 1];\n    for (p = 0; p < i; p++)\n    {\n      for (q = j + 1; q < N; q++)\n      {\n        Pu[i][j] += ((((Pbp[p][q] * ERT) * Q[p + 1][i]) * 1) * Q[j + 1][q - 1]) / ((Qbp[p][q] == 0) ? (1) : (Qbp[p][q]));\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_mcc_traco/7"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    if (j < i)\n      sum_new += S[i][j] * pagerank[j];\n\n    if (j > i)\n      sum += S[i][j] * pagerank_old[j];\n\n  }\n\n  pagerank[i] = (1 / S[i][i]) * ((b - sum_new) - sum);\n  sum = 0.0;\n  sum_new = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  a1[i] = s * 10;\n  a2[i] = i;\n  s = -s;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.51.2/0"}
{"code": "for (int i = 0; i < len; i++)\n{\n  output[idx[i]] = input[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/3"}
{"code": "for (k = 0; k < nz; k++)\n{\n  zeta = ((double) k) / (nz - 1);\n  for (m = 0; m < 5; m++)\n  {\n    rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(nx ,m ,k ,j ,xi ,eta ,zeta ,nx0 ,ny0 ,nz ,ny ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/14"}
{"code": "for (parallel_jndex = 0; parallel_jndex < num_elements; ++parallel_jndex)\n{\n  for (parallel_index = 0; parallel_index < num_elements; ++parallel_index)\n  {\n    for (int kndex = 0; kndex < num_elements; ++kndex)\n    {\n      result[parallel_index][parallel_jndex] = result[parallel_index][parallel_jndex] + (a[parallel_index][kndex] * b[kndex][parallel_jndex]);\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared) private(parallel_index, parallel_jndex)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akhtyamovpavel/ParallelComputationExamples/OpenMP/05-matrix-multiplication/main/1"}
{"code": "for (i = 0; i < 102400; i++)\n{\n  vecA[i] = ((long) i) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/hybrid-openmp-mpi/race-condition/solution/sum/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  free(graph[i]);\n  free(solutionMatrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/avisenna01/Djikstra-OpenMP/src/dijkstra_omp/7"}
{"code": "for (i = 2; i <= (m / 2); i++)\n{\n  if ((m % i) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhiy91/Goldbach_conjecture/goldbach_omp/1"}
{"code": "for (i = 0; i < nb_patterns; i++)\n{\n  int l;\n  l = strlen(argv[i + 3]);\n  if (l <= 0)\n  {\n    fprintf(stderr, \"Error while parsing argument %d\\n\", i + 3);\n    return 1;\n  }\n\n  if (l > max_len_pattern)\n  {\n    max_len_pattern = l;\n  }\n\n  pattern[i] = (char *) malloc((l + 1) * (sizeof(char)));\n  if (pattern[i] == 0)\n  {\n    fprintf(stderr, \"Unable to allocate string of size %d\\n\", l);\n    return 1;\n  }\n\n  strncpy(pattern[i], argv[i + 3], l + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmParallel/2"}
{"code": "for (int ix = 0; ix <= ((int) (mx / 2)); ix++)\n{\n  for (int iy = 0; iy <= ix; iy++)\n  {\n    int iz = (-ix) - iy;\n    if (abs(iz) <= ((int) ((mx + 1) / 2)))\n    {\n      int x = ((int) (mx / 2)) + ix;\n      int y = ((int) (my / 2)) + iy;\n      int z = ((int) (mz / 2)) + iz;\n      bool receptive = false;\n      if (ca[offset(x, y, z, mx)] >= 1)\n      {\n        receptive = true;\n      }\n      else\n      {\n        for (int j = 0; j < 6; j++)\n        {\n          int jx = ix + dx[j];\n          int jy = iy + dy[j];\n          int jz = iz + dz[j];\n          int jxx = ((int) (mx / 2)) + jx;\n          int jyy = ((int) (my / 2)) + jy;\n          int jzz = ((int) (mz / 2)) + jz;\n          if ((((((jxx >= 0) && (jxx <= mx)) && (jyy >= 0)) && (jyy <= my)) && (jzz >= 0)) && (jzz <= mz))\n          {\n            if (ca[offset(jxx, jyy, jzz, mx)] >= 1)\n            {\n              receptive = true;\n              break;\n            }\n\n          }\n\n        }\n\n      }\n\n      if (receptive)\n      {\n        caRep[offset(x, y, z, mx)] = ca[offset(x, y, z, mx)] + gamma;\n        caNRep[offset(x, y, z, mx)] = 0;\n      }\n      else\n      {\n        caRep[offset(x, y, z, mx)] = 0;\n        caNRep[offset(x, y, z, mx)] = ca[offset(x, y, z, mx)];\n      }\n\n      mirror(caRep, mx, ix, iy);\n      mirror(caNRep, mx, ix, iy);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jexom/FlakeGen/OMPflake/OMPflake/1"}
{"code": "for (i = 0; i <= (gridsize + 1); i++)\n  free(grid[1][i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SienaCSISParallelProcessing/openmp-life/life/6"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    result[i] += matrix[(i * n) + j] * vector[i];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m, n, matrix, vector, result) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/USING-OPENMP/mxv/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  for (j = 0; j < nxh; j++)\n  {\n    at1 = cimagf(ffc[j + kk]);\n    for (i = 0; i < 3; i++)\n    {\n      fxyz[i + (3 * (j + kj))] += exyz[i + (3 * (j + kj))] * at1;\n      fxyz[i + (3 * (j + k1))] += exyz[i + (3 * (j + k1))] * at1;\n      fxyz[i + (3 * ((j + kj) + l1))] += exyz[i + (3 * ((j + kj) + l1))] * at1;\n      fxyz[i + (3 * ((j + k1) + l1))] += exyz[i + (3 * ((j + k1) + l1))] * at1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,k1,kk,kj,at1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/22"}
{"code": "for (c2 = nj; c2 <= (nk + (-1)); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/26"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t k;\n  uint32_t src;\n  uint32_t dest;\n  uint64_t weight = DoubleToFixed64(0.0001f);\n  struct Partition *partition = &graph->grid->partitions[(i * totalPartitions) + j];\n  for (k = 0; k < partition->num_edges; ++k)\n  {\n    src = partition->edgeList->edges_array_src[k];\n    dest = partition->edgeList->edges_array_dest[k];\n    vector_output[dest] += MULFixed64V1(weight, vector_input[src]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule (dynamic,arguments->algo_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SPMV/6"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  row_disp[i] = row_disp[i - 1] + row_sendcount[i - 1];\n  col_disp[i] = col_disp[i - 1] + col_sendcount[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/11"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n{\n  x = randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  x += randlc2(&seed, &a);\n  key_array[i] = k * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/2"}
{"code": "for (int i = 0; i < len; i++)\n{\n  for (int j = 0; j < len; j++)\n  {\n    c = ((arr[i][j] - 128) * fact) + 128;\n    d[i][j] = ctruncate(c);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Arrays/contrast_2dserandpar/1"}
{"code": "for (int tid = 0; tid < freqs_shape; tid++)\n{\n  float freq = f[tid];\n  float xc = 0;\n  float xs = 0;\n  float cc = 0;\n  float ss = 0;\n  float cs = 0;\n  float c;\n  float s;\n  for (int j = 0; j < x_shape; j++)\n  {\n    sincosf(freq * x[j], &s, &c);\n    xc += y[j] * c;\n    xs += y[j] * s;\n    cc += c * c;\n    ss += s * s;\n    cs += c * s;\n  }\n\n  float c_tau;\n  float s_tau;\n  float tau = atan2f(2.0f * cs, cc - ss) / (2.0f * freq);\n  sincosf(freq * tau, &s_tau, &c_tau);\n  float c_tau2 = c_tau * c_tau;\n  float s_tau2 = s_tau * s_tau;\n  float cs_tau = (2.0f * c_tau) * s_tau;\n  p[tid] = (0.5f * (((((c_tau * xc) + (s_tau * xs)) * ((c_tau * xc) + (s_tau * xs))) / (((c_tau2 * cc) + (cs_tau * cs)) + (s_tau2 * ss))) + ((((c_tau * xs) - (s_tau * xc)) * ((c_tau * xs) - (s_tau * xc))) / (((c_tau2 * ss) - (cs_tau * cs)) + (s_tau2 * cc))))) * y_dot;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(256) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lombscargle-omp/main/4"}
{"code": "for (i = 0; i < neighbor_nodes->count; i++)\n{\n  global_dest_node = naive_partitioning_convert_to_global_index((neighbor_nodes->addr + i)->dest, local_offset);\n  global_dest_community = *(cd->vertex_community + global_dest_node);\n  weight = (neighbor_nodes->addr + i)->weight;\n  if (global_dest_community == current_community)\n    *current_community_k_i_in += weight;\n  else\n    if (!sorted_linked_list_insert(sll, global_dest_community, weight))\n  {\n    printf(\"Cannot insert node in sorted linked list!\");\n    sorted_linked_list_free(sll);\n    free(sll);\n    return 0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abignoli/find-communities-OpenMP/src/version-parallel-naive-partitioning/4"}
{"code": "for (i = 0; i < N; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < M; j++)\n  {\n    sum += A[i][j] * x[j];\n  }\n\n  y[i] = sum;\n  printf(\"Thread num = %d , calculated %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp for private(j, sum) schedule(dynamic, 2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minyoung-Kim1110/OpenMP/Excercise/matrix_vector_mul/2"}
{"code": "for (i = 1; i <= 100; ++i)\n  for (j = 1; j <= 100; ++j)\n  prv[i][j] = h[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaanknight/Parallel-Programming/Jacob_iterations_OpenMP/3"}
{"code": "for (i = 1; i < size; i++)\n{\n  key = arr[i];\n  j = i - 1;\n  {\n    while ((j >= 0) && (arr[j] > key))\n    {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n\n  }\n  arr[j + 1] = key;\n}\n\n", "pragma": "    #pragma omp prallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anushaasaad/comparsion-of-sorting-algorithms-using-Pthreads-OpenMP/InsertionOpenMP/0"}
{"code": "for (i = i_start; i < n; i++)\n{\n  float *tmp_uold = &uold[(((i + uold_0_offset) * uold_m) + uold_1_offset) + j_start];\n  float *tmp_f = &f[(i * m) + j_start];\n  float *tmp_u = &u[(i * m) + j_start];\n  for (j = j_start; j < m; j++)\n  {\n    float resid = ((((ax * (tmp_uold[uold_m] + tmp_uold[-uold_m])) + (ay * (tmp_uold[-1] * tmp_uold[1]))) + (b * tmp_uold[0])) - (*tmp_f)) / b;\n    *tmp_u = (*tmp_uold = omega * resid);\n    er = er + (resid * resid);\n    tmp_uold++;\n    tmp_f++;\n    tmp_u++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,i) reduction(+:er) num_threads(num_omp_threads)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_cpu_omp_kernel/1"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n{\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n    for (int k = 1; k < (grid->getNZC() - 1); k++)\n  {\n    const double q = q_factor * EMf->getRHOcs(i, j, k, ns);\n    for (int ii = 0; ii < npcelx; ii++)\n      for (int jj = 0; jj < npcely; jj++)\n      for (int kk = 0; kk < npcelz; kk++)\n    {\n      const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n      const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n      const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n      double u;\n      double v;\n      double w;\n      if (y > Ly_upper)\n        sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, (-1.0) * w0);\n      else\n        sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n\n      create_new_particle(u, v, w, q, x, y, z);\n    }\n\n\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = ((float) i) / (n * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurbaaz27/CS433A-Design-Exercises/assignment3/Q2_openmp/1"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  jglob = j;\n  eta = ((double) jglob) / (ny0 - 1);\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    zeta = ((double) k) / (nz - 1);\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (jglob,eta,zeta,j,k,m) firstprivate (ny0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/14"}
{"code": "for (int i = 0; i < 256; i++)\n  normalized[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/3"}
{"code": "for (int i = threadId; i < num_steps; i += privateNumThreads)\n{\n  double x = (i + 0.5) * step;\n  privateSum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnwest/OpenMPConsoleApplication/OpenMPConsoleApplication/OpenMPConsoleApplication/3"}
{"code": "for (int j = 0; j < (keysize / 8); ++j)\n  keyBytes[j] = (bitset < 8) > key[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/0"}
{"code": "for (i = 1; i < n_subprobs; i++)\n{\n  res_offset = ((((int) (i / ((int) sqrt(n_subprobs)))) * subprob_size) * subprob_size) * ((int) sqrt(n_subprobs));\n  res_offset += (i % ((int) sqrt(n_subprobs))) * subprob_size;\n  MPI_Recv(res[0] + res_offset, 1, double_strided_vect, i, generic_tag, 1, (MPI_Status *) 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/14"}
{"code": "for (int j3 = 1; j3 < (m3j - 1); j3++)\n{\n  int i3 = (2 * j3) - d3;\n  for (int j2 = 1; j2 < (m2j - 1); j2++)\n  {\n    int i2 = (2 * j2) - d2;\n    double x1[M];\n    double y1[M];\n    double x2;\n    double y2;\n    for (int j1 = 1; j1 < m1j; j1++)\n    {\n      int i1 = (2 * j1) - d1;\n      x1[i1] = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      y1[i1] = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n    }\n\n    int tmp = 0;\n    for (int j1 = 1; j1 < (m1j - 1); j1++)\n    {\n      tmp += 2;\n      int i1 = (tmp - d1) + 1;\n      int tmp2 = tmp - d1;\n      y2 = ((r[i3][i2][i1] + r[i3 + 2][i2][i1]) + r[i3][i2 + 2][i1]) + r[i3 + 2][i2 + 2][i1];\n      x2 = ((r[i3 + 1][i2][i1] + r[i3 + 1][i2 + 2][i1]) + r[i3][i2 + 1][i1]) + r[i3 + 2][i2 + 1][i1];\n      s[j3][j2][j1] = (((0.5 * r[i3 + 1][i2 + 1][i1]) + (0.25 * ((r[i3 + 1][i2 + 1][i1 - 1] + r[i3 + 1][i2 + 1][i1 + 1]) + x2))) + (0.125 * ((x1[i1 - 1] + x1[i1 + 1]) + y2))) + (0.0625 * (y1[i1 - 1] + y1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(d1,d2,d3) collapse(1) num_threads(threads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment10/real/real/2"}
{"code": "for (i = 0; i < 1000; i++)\n  sum = sum + a[i];\n\n", "pragma": "omp parallel for reduction (+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/varun10221/Time-series_OPENMP/avg/0"}
{"code": "for (int i = 0; i < nelr; i++)\n{\n  mx[i].a = 0.0;\n  mx[i].b = 0.0;\n  my[i].a = 0.0;\n  my[i].b = 0.0;\n  mz[i].a = 0.0;\n  mz[i].b = 0.0;\n  p[i].a = 0.0;\n  p[i].b = 0.0;\n  pe[i].a = 0.0;\n  pe[i].b = 0.0;\n}\n\n", "pragma": "        #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/sycl/calculate_dt_kernel_kernel/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    sum_parallel[i] += vec[j] * mat[i][j];\n  }\n\n}\n\n", "pragma": "                #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saurabhkoshatwar/Analysis-of-the-Execution-Time-Variation-of-OpenMP-based-Applications/src/mat_vec_mul/2"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  a[i] = i;\n  sum = a[i] + sum;\n  xx++;\n  yy--;\n  zz *= a[i];\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:sum,xx) reduction (-:yy) reduction (*:zz)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_reduction/0"}
{"code": "for (int i = 0; i < nelements; i++)\n{\n  if (array_i[i] == array_j[i])\n  {\n    total += array_val[i];\n  }\n\n}\n\n", "pragma": "omp parallel for reduction (+:total) num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LightXEthan/MatrixComputation/operations/1"}
{"code": "for (int z = 0; z < (local_r * columns); ++z)\n{\n  x = z / columns;\n  y = z % columns;\n  for (int i = 0; i < krows; ++i)\n  {\n    for (int j = 0; j < kcolumns; ++j)\n    {\n      b = (y + j) - (kcolumns / 2);\n      if (b < 0)\n        index = columns + b;\n      else\n        if (b > (columns - 1))\n        index = b - columns;\n      else\n        index = b;\n\n\n      output_local_mat[(x * columns) + y] += local_mat[((x + i) * columns) + index] * kernel[(i * kcolumns) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rdb987/2DConvolution/src/hpc_conv_hybrid/8"}
{"code": "for (int k = 0; k < ((int) pset[i].size()); k++)\n  ps.insert(pset[i][k]);\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yeshwanth495/Parallelizing-Apriori-Algorithm/FinalCode/2"}
{"code": "for (int i = 0; i < images.size(); i++)\n{\n  double siftIterStart = currentSeconds();\n  sift_cpu(images[i], kpt_lists[i], true);\n  double siftIterEnd = currentSeconds();\n  ((cout << \"Sift iteration time\") << (siftIterEnd - siftIterStart)) << endl;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_pure_openmp/image_stitching/2"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  timeStart = omp_get_wtime();\n  PiParallelForCritical();\n  timeEnd = omp_get_wtime();\n  time += timeEnd - timeStart;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab2/untitled/pi/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    error += fabs(c[(j * n) + i] - t[(j * n) + i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geziogas/ParallelProgramming-Project/qr_par2/10"}
{"code": "for (l = 0; l <= (ub - 1); l += 1)\n{\n  int l8 = l * 8;\n  real8 h1 = m[((t1 + l8) * 4) + 1];\n  real8 h2 = m[((t1 + l8) * 4) + 2];\n  real8 h3 = m[((t1 + l8) * 4) + 3];\n  nel = nell[l];\n  p[nell[l]] += (d__[l] * 64.) * (((h1 * h1) + (h2 * h2)) + (h3 * h3));\n}\n\n", "pragma": "omp parallel for private (nel,l) firstprivate (ub,t1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_livenessTest/0"}
{"code": "for (int c = lc + 1; (c < 7) && (this->board[lr][lc] == player); ++c)\n{\n  right++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  bar();\n  bar();\n}\n\n", "pragma": "#pragma omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/30"}
{"code": "for (int idx = 0; idx < mm_len; idx++)\n{\n  double nm = n[matids[idx]];\n  p_compact_list[idx] = ((nm * rho_compact_list[idx]) * t_compact_list[idx]) / Vf_compact_list[idx];\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(thx*thy)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/compact/3"}
{"code": "for (int kk = n + (nbh / 2); kk < (n + nbh); kk++)\n{\n  if ((jj * dx) > (L + ((2 * bt) * dx)))\n  {\n    ii++;\n    jj = 0;\n  }\n\n  x[kk] = space2 + (jj * dx);\n  y[kk] = (((space2 + dx) + (bt * dx)) + H) + (ii * dx);\n  jj++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soanagno/sph-openmp/sph/10"}
{"code": "for (m = 3; m < 5; m++)\n{\n  n = ((m - 3) + 1) * 5;\n  for (i = grid_points[0] - 3; i >= 0; i--)\n  {\n    i1 = i + 1;\n    i2 = i + 2;\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      for (k = 1; k <= (grid_points[2] - 2); k++)\n      {\n        rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k])) - (lhs[n + 4][i][j][k] * rhs[m][i2][j][k]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/27"}
{"code": "for (int i = 0; i < nelr; i++)\n{\n  for (int j = 0; j < NVAR; j++)\n    variables[i + (j * nelr)] = ff_variable[j];\n\n}\n\n", "pragma": "\t#pragma omp parallel for default(shared) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LLNL/AutoParBench/benchmarks/original/rodinia_3.1/openmp/cfd/euler3d_cpu/3"}
{"code": "for (int i = 0; i < length; i++)\n{\n  x += i * length;\n  float factor = createRoundingFactor(maxVal[i], length);\n  float s = 0;\n  for (int n = length - 1; n >= 0; n--)\n    s += truncateWithRoundingFactor(factor, x[n]);\n\n  r[i] = s;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for num_teams(256) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/rfs-omp/main/0"}
{"code": "for (i = 0; i < rows; i++)\n  matrix[i] = &data[i * columns];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fgrehm/pucrs-mpi-openmp-master_slave/mpi_master_slave/6"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    fprintf(f, \"%f \", u[(i * npadded) + j]);\n  }\n\n  fprintf(f, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/POISSON/poisson_openmp/11"}
{"code": "for (i = 0; i <= m; i++)\n{\n  w[i] = ((float) rand()) / 32767;\n  w[i] = 0.1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/backprop/src/backprop-AI/1"}
{"code": "for (i = ibeg; i <= ifin1; i++)\n{\n  for (k = ki1; k <= (ki2 - 1); k++)\n  {\n    frc2 = frc2 + (((((((phi1[i][k] + phi1[i + 1][k]) + phi1[i][k + 1]) + phi1[i + 1][k + 1]) + phi2[i][k]) + phi2[i + 1][k]) + phi2[i][k + 1]) + phi2[i + 1][k + 1]);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:frc2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/30"}
{"code": "for (j = 1; j < (m - 1); j++)\n{\n  for (i = 1; i < (n - 1); i++)\n    if (((i + j) % 2) == 0)\n  {\n    newVal = 0.25 * (((grid[j - 1][i] + grid[j + 1][i]) + grid[j][i - 1]) + grid[j][i + 1]);\n    error = max(error, fabs(newVal - grid[j][i]));\n    grid[j][i] = newVal;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/97amarnathk/steadyStateHeat/src/steadyStateHeat/10"}
{"code": "for (sender = 1; sender < mpi_size; sender++)\n{\n  MPI_Recv(loc_slice, glob_size * loc_size, (MPI_Datatype) 0x4c000405, sender, 0, 1, (MPI_Status *) 1);\n  print_slice(loc_slice, glob_size, loc_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denocris/Parallel-Programming/MPIandOpenmp/Mmul_hybrid/2"}
{"code": "for (i = 0; i < 1000; i++)\n  tab1[i] = (tab2[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MahiBegoug/OpenMP-Td1/exo2/1"}
{"code": "for (size_t i = 0; i < Drawings.size(); i++)\n{\n  Drawings[i].Render();\n}\n\n", "pragma": "#pragma omp parallel for num_threads(Params.Simulator.NumThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/FourierDraw/Source/FourierDraw/4"}
{"code": "for (int32_t vi = 0; vi < nvtxs; ++vi)\n{\n  for (ssize_t ei = xadj[vi]; ei < xadj[vi + 1]; ++ei)\n  {\n    if (adjwgt[ei] == 0)\n    {\n      continue;\n    }\n\n    xaii[vi].start++;\n    xaii[adjncy[ei]].start++;\n    edges[edge_ptr].vi = vi;\n    edges[edge_ptr].vj = adjncy[ei];\n    supports[edge_ptr] = adjwgt[ei];\n    edge_ptr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/multistage-peeling/7"}
{"code": "for (i = 0; i < (n / 4); i++)\n{\n  v_b = _mm256_loadu_pd((const double *) (b + (i * 4)));\n  v_a = _mm256_loadu_pd((const double *) (a + (i * 4)));\n  v_a = _mm256_add_pd(v_a, _mm256_mul_pd(v_alpha, v_b));\n  _mm256_storeu_pd(a, v_a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosangelopoulos/LU_OpenMP/lu_simd_avx/0"}
{"code": "for (int phase = 0; phase < m_iNumPhase;)\n{\n  bool phase_success = directionalSplitting(phase);\n  if (!phase_success)\n  {\n    phase = 0;\n    continue;\n  }\n\n  setBoundaryPressureAndVelocity(phase);\n  setGhostPressureAndVelocity(phase);\n  phase++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/0"}
{"code": "for (i = k + 1; i < N; i++)\n{\n  for (j = k + 1; j < N; j++)\n    A[i][j] = A[i][j] - (A[i][k] * A[k][j]);\n\n}\n\n", "pragma": "omp parallel for num_threads(NUMB_CORES) schedule(dynamic, chunksize) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/gaussian_openmp/1"}
{"code": "for (int i = 0; i < board.getCols(); i++)\n{\n  if (board.isColumnEmpty(i))\n  {\n    board.makeMove(i, player);\n    int score = this->alphabetapruning(1, maxDepth, INT_MIN, INT_MAX, false, player);\n    if (score > bestScore)\n    {\n      bestScore = score;\n      bestCol = i;\n    }\n\n    board.undoMove();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SiddarthSingaravel/Connect-four/src/GameAlphaBeta/0"}
{"code": "for (int i = 0; i < omp_get_num_threads(); i++)\n{\n  if (omp_get_thread_num() == 0)\n    for (int i = 0; i < 1000000000; i++)\n    ;\n\n\n  var4 = omp_get_thread_num() * i;\n  printf(\"\\nlastprivate var4=%d * %d \", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for lastprivate(var4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/V6429/openmp_present/presentation/4.Dataenv/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  double a;\n  double b;\n  (fin >> a) >> b;\n  points.push_back(make_pair(a, b));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DanRadulescu962/ProjectAPP/OpenMP/tema/0"}
{"code": "for (i = 0; i < 180; i++)\n  for (j = 0; j < (180 - 1); j++)\n  x_matrix[i][j] = (((double) j) * h) * x_matrix[i][180 - 1];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kunjsong01/parallel_computing/sor_convergence/sor_static_wavefront/sor_wavefront_parallel/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  AA[i] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wolfram18/OpenMP-Practice/OpenMP-Project/Project345/Synchronization/7"}
{"code": "for (i = 1; i < (maxI - 1); i++)\n{\n  for (j = 1; j < (maxJ - 1); j++)\n  {\n    if (!((i + j) & 1))\n      continue;\n\n    C = (i * maxJ) + j;\n    N = ((i - 1) * maxJ) + j;\n    E = (i * maxJ) + (j + 1);\n    S = ((i + 1) * maxJ) + j;\n    W = (i * maxJ) + (j - 1);\n    old = arr[C];\n    new = (((arr[N] + arr[S]) + arr[W]) + arr[E]) / 4.0;\n    if (((((new - old) > 0.0) ? (new - old) : ((-new) - old)) / (((new > 0.0) ? (new) : (-new)) + SMALL)) > eps)\n    {\n      not_precise = 1;\n    }\n\n    arr[C] = new;\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, old, new, C, N, E, S, W) reduction(+:not_precise)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/1"}
{"code": "for (i = 0; i < nodeNum; i++)\n  pr_old[i] = pr[i];\n\n", "pragma": "omp parallel for default(shared) private(i) schedule(auto)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/0"}
{"code": "for (i = 0; i < ((width * height) * 4); i++)\n{\n  if (fabsf(input_sc[i] - input[i]) > 0.01f)\n  {\n    printf(\"ERROR\\n\");\n    exit(1);\n  }\n\n  if (fabsf(output1_sc[i] - output1[i]) > 0.01f)\n  {\n    printf(\"ERROR\\n\");\n    exit(1);\n  }\n\n  if (fabsf(output2_sc[i] - output2[i]) > 0.01f)\n  {\n    printf(\"ERROR\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/avx2/success_simd_12_parallel_blackscholes/3"}
{"code": "for (j = 0; j < M; j++)\n{\n  a = adjacent_to(temp, 0, j, 3, M);\n  if (a == 2)\n    NewBoard(0, j) = Board(0, j);\n\n  if (a == 3)\n    NewBoard(0, j) = 1;\n\n  if (a < 2)\n    NewBoard(0, j) = 0;\n\n  if (a > 3)\n    NewBoard(0, j) = 0;\n\n}\n\n", "pragma": "omp parallel for private(j,a) shared(board,newboard) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/7"}
{"code": "for (int rep = 0; rep < 5; rep++)\n{\n  C = multiply_matrix(A, B, C, N_row, N_col);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aayush-patel-1696/High-Performance-Computing/Matrix Multiplication and Upper Triangulation/OpenMp version/main_omp/0"}
{"code": "for (i = local_pad1R, ip = 0; i < local_pad2R; ++i, ++ip)\n{\n  for (j = local_pad1C, jp = 0; j < local_pad2C; ++j, ++jp)\n  {\n    _Salency[ip][jp] = (_Imap[i][j] + _Omap[i][j]) + _Cmap[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/SaliencyMap/SaliencyMap/5"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  idx1 = offset + i;\n  idx2 = i;\n  c1 = data->seq1[idx1];\n  c2 = data->seq2[idx2];\n  pair_score = get_weight(get_hashtable_sign(c1, c2), data->weights);\n  total_score += pair_score;\n  sub = get_substitute(c1, c2, data->weights, data->is_max);\n  if (sub == NOT_FOUND_CHAR)\n    continue;\n\n  mutant_diff = get_weight(get_hashtable_sign(c1, sub), data->weights) - pair_score;\n  if ((data->is_max && (mutant_diff > best_mutant_diff)) || ((!data->is_max) && (mutant_diff < best_mutant_diff)))\n  {\n    best_mutant_diff = mutant_diff;\n    mt->ch = sub;\n    mt->char_offset = i;\n    mt->offset = offset;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/2"}
{"code": "for (i = 0; i < numV; i++)\n{\n  vertex_cnt[(tid * numV) + i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jk78346/countsort_openmp/01_MP1/code/src/sort/2"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  printf(\"do %d\\n\", i);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenCMISS-Dependencies/opari2/test/data/test3/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  iglob = i;\n  for (j = 0; j < ny; j++)\n  {\n    jglob = j;\n    double *_imopVarPre239;\n    _imopVarPre239 = &u[i][j][0][0];\n    exact(iglob, jglob, 0, _imopVarPre239);\n    double *_imopVarPre242;\n    int _imopVarPre243;\n    _imopVarPre242 = &u[i][j][nz - 1][0];\n    _imopVarPre243 = nz - 1;\n    exact(iglob, jglob, _imopVarPre243, _imopVarPre242);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/0"}
{"code": "for (int cluster = 0; cluster < n_clusters; cluster++)\n{\n  for (int channel = 0; channel < n_channels; channel++)\n  {\n    centers[(cluster * n_channels) + channel] = 0;\n  }\n\n  counts[cluster] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blarc/image-compression-k-means/src/compression_omp/6"}
{"code": "for (j = 0; j < n; j++)\n  for (i = 0; i < m; i++)\n  fprintf(fp, \"%e\\n\", Q[j + (n * (i + (m * 0)))]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/10"}
{"code": "for (int i = 0; i < n; i++)\n{\n  distance[i] = cost[startnode][i];\n  predecessor[i] = startnode;\n  visited[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Akash01010/Dijkstra_OpenMP/dijkstra/6"}
{"code": "for (int i = 0; i < 729; i++)\n{\n  for (int j = 0; j < 729; j++)\n  {\n    a[i][j] = 0.0;\n    b[i][j] = 3.142 * (i + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saultyevil/OpenMP-Affinity-Scheduler/loops/loops_runtime/4"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_total -= a[x] + b[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_subtract/2"}
{"code": "for (int y = 0; y < (N_y + 6); y++)\n{\n  h[2][y] = h[end - 4][y];\n  h[end - 3][y] = h[3][y];\n  h[1][y] = h[end - 5][y];\n  h[end - 2][y] = h[4][y];\n  h[0][y] = h[end - 6][y];\n  h[end - 1][y] = h[5][y];\n}\n\n", "pragma": "    #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anubhav-cs/Numerical-Methods/Shallow Water Flow/shallow_water_openmp/2"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  if (Volts[i] <= 0)\n  {\n    printf(\"*** Voltage[%ld] = %ld\\n\", i, Volts[i]);\n    Volts[i] = 4000;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/reserver/parseInputFiles/6"}
{"code": "for (i = i_peak2; i < i_peak3; i++)\n{\n  if (histogram[i] < bottom3a)\n  {\n    bottom3a = histogram[i];\n    i_bottom3a = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ALB/alb/8"}
{"code": "for (i = 0; i < nMatrix->filas(); i++)\n{\n  for (j = 0; j < nMatrix->columnas(); j++)\n  {\n    switch (op)\n    {\n      case '+':\n        nMatrix->num(num(i, j) + mat->num(i, j), i, j);\n        break;\n\n      case '-':\n        nMatrix->num(num(i, j) - mat->num(i, j), i, j);\n        break;\n\n      case '*':\n        nMatrix->num(num(i, j) * mat->num(i, j), i, j);\n        break;\n\n      case '/':\n        nMatrix->num(num(i, j) / mat->num(i, j), i, j);\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kunkkaharden/Proyecto-de-tesis/source/utiles/matrix/1"}
{"code": "for (i = my_num_init_infected; i < my_num_people; i++)\n{\n  my_states[i] = SUSCEPTIBLE;\n  my_num_susceptible++;\n}\n\n", "pragma": "omp parallel for private(i) reduction(+:my_num_susceptible)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-exercise-solns/pandemic/1"}
{"code": "for (uint32_t i = 0; i < rows; i++)\n{\n  if ((csrNew.pointer[i] == csrNew.pointer[i + 1]) && (csrOld.pointer[i] == csrOld.pointer[i + 1]))\n  {\n    ret.pointer[i + 1] = nnz;\n    continue;\n  }\n\n  prevSize = ret.indices.size();\n  merge(csrNew.indices.begin() + csrNew.pointer[i], csrNew.indices.begin() + csrNew.pointer[i + 1], csrOld.indices.begin() + csrOld.pointer[i], csrOld.indices.begin() + csrOld.pointer[i + 1], back_inserter(ret.indices));\n  nnz += ret.indices.size() - prevSize;\n  ret.pointer[i + 1] = nnz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/thodkatz/sparse-bmm/src/spgemm/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = (double *) malloc((sizeof(double)) * n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aman-1701/Tiled_Matrix_Multiplication_OpenMP/TiledMatrixMultiplication/1"}
{"code": "for (x = 0; x < 10; x++)\n  red += redundancy[x];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/High-Performance-Parallel-Programming/OpenMP/Assignment_1/Assignment1_16EE30025/4"}
{"code": "for (i = 0; i <= 8388607; i += 1)\n{\n  key_buff2[i] = key_array[i];\n  prv_buff1[key_buff2[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/10"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  A[i] = i * 0.0001;\n  B[i] = 0.0;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/vasp1/vasp1/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  (*data)[i] = thread_num;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gjbex/training-material/OpenMP/Allocation/allocation/0"}
{"code": "for (int row = 0; row < Max; row++)\n{\n  for (int col = 0; col < Max; col++)\n  {\n    srand(row + col);\n    A[row][col] = rand() % 1000;\n    B[row][col] = rand() % 1000;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(64)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JanetLau0310/Parallel_computing/OpenMP/SGEMM/w4/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    t = A[i][j];\n    A[i][j] = A[j][i];\n    A[j][i] = t;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(t) schedule(static, n / 32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q1/6"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jz10/OpenMPTest/tests/cpp/TestUnifiedAddress1/0"}
{"code": "for (j = 0; j < 4; j++)\n{\n  avgtime[j] = avgtime[j] / ((double) (10 - 1));\n  if (label[j][0] != 'i')\n  {\n    printf(\"%s%12.1f  %11.6f  %11.6f  %11.6f\\n\", label[j], (1.0E-06 * bytes[j]) / mintime[j], avgtime[j], mintime[j], maxtime[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-EUROfusion/exercises-webinar-4/stream-gpu/stream/1"}
{"code": "for (r = 0; r < 32768; r++)\n  hist[r] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/13"}
{"code": "for (it = 1; it <= it_max; it++)\n{\n  update_norm = 0.0;\n  for (k = 1; k < (nz - 1); k++)\n  {\n    for (j = 1; j < (ny - 1); j++)\n    {\n      for (i = 1; i < (nx - 1); i++)\n      {\n        if ('r' == rb[(i + (j * nx)) + ((k * nx) * ny)])\n        {\n          rem = u[(i + (j * nx)) + ((k * nx) * ny)];\n          u[(i + (j * nx)) + ((k * nx) * ny)] = (f[(i + (j * nx)) + ((k * nx) * ny)] - (((ax * (u[((i - 1) + (j * nx)) + ((k * nx) * ny)] + u[((i + 1) + (j * nx)) + ((k * nx) * ny)])) + (ay * (u[(i + ((j - 1) * nx)) + ((k * nx) * ny)] + u[(i + ((j + 1) * nx)) + ((k * nx) * ny)]))) + (az * (u[(i + (j * nx)) + (((k - 1) * nx) * ny)] + u[(i + (j * nx)) + (((k + 1) * nx) * ny)])))) / d;\n          diff = ((u[(i + (j * nx)) + ((k * nx) * ny)] - rem) >= 0) ? (u[(i + (j * nx)) + ((k * nx) * ny)] - rem) : (-(u[(i + (j * nx)) + ((k * nx) * ny)] - rem));\n          if (diff > update_norm)\n          {\n            update_norm = diff;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  for (k = 1; k < (nz - 1); k++)\n  {\n    for (j = 1; j < (ny - 1); j++)\n    {\n      for (i = 1; i < (nx - 1); i++)\n      {\n        if ('b' == rb[(i + (j * nx)) + ((k * nx) * ny)])\n        {\n          rem = u[(i + (j * nx)) + ((k * nx) * ny)];\n          u[(i + (j * nx)) + ((k * nx) * ny)] = (f[(i + (j * nx)) + ((k * nx) * ny)] - (((ax * (u[((i - 1) + (j * nx)) + ((k * nx) * ny)] + u[((i + 1) + (j * nx)) + ((k * nx) * ny)])) + (ay * (u[(i + ((j - 1) * nx)) + ((k * nx) * ny)] + u[(i + ((j + 1) * nx)) + ((k * nx) * ny)]))) + (az * (u[(i + (j * nx)) + (((k - 1) * nx) * ny)] + u[(i + (j * nx)) + (((k + 1) * nx) * ny)])))) / d;\n          diff = ((u[(i + (j * nx)) + ((k * nx) * ny)] - rem) >= 0) ? (u[(i + (j * nx)) + ((k * nx) * ny)] - rem) : (-(u[(i + (j * nx)) + ((k * nx) * ny)] - rem));\n          if (diff > update_norm)\n          {\n            update_norm = diff;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (0 == (it % io_interval))\n    printf(\" iteration  %5d   norm update %14.4e\\n\", it, update_norm);\n\n  if (update_norm <= tol)\n  {\n    it_used = it;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wilmerhenao/Poisson-OpenMP/serial_hw2/14"}
{"code": "for (int i = 2; i < stroka.length(); i++)\n{\n  if (stroka[i] == ' ')\n  {\n    p = i + 1;\n    break;\n  }\n\n  line.Name += stroka[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shcherbakov-Mikhail/Task3-sem4/functions/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  for (int j = 0; j < 10; j++)\n  {\n    A[i][j] = rand();\n    B[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maitreyeepaliwal/OpenMP/matrixsyn/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  a[i] = 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_update/test_target_update_if/1"}
{"code": "for (data_i = 0; data_i < data_n; data_i++)\n{\n  sum_centroids[(ithread * class_n) + partitioned[data_i]].x += data[data_i].x;\n  sum_centroids[(ithread * class_n) + partitioned[data_i]].y += data[data_i].y;\n  sum_count[(ithread * class_n) + partitioned[data_i]]++;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/7ogic/K-means/kmeans_mpi_openmp/3"}
{"code": "for (int x = 0; x < 256; ++x)\n{\n  free(arr[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative2/3"}
{"code": "for (m = 0; m < 5; m++)\n{\n  Pxi = (xi * Pface[1][0][m]) + ((1.0 - xi) * Pface[0][0][m]);\n  Peta = (eta * Pface[1][1][m]) + ((1.0 - eta) * Pface[0][1][m]);\n  Pzeta = (zeta * Pface[1][2][m]) + ((1.0 - zeta) * Pface[0][2][m]);\n  u[m][i][j][k] = (((((Pxi + Peta) + Pzeta) - (Pxi * Peta)) - (Pxi * Pzeta)) - (Peta * Pzeta)) + ((Pxi * Peta) * Pzeta);\n}\n\n", "pragma": "omp parallel for firstprivate(Pxi ,Peta ,Pzeta ,xi ,eta ,zeta ,m ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/43"}
{"code": "for (unsigned i = 131071; i <= 2147483647; i += 127)\n  a[i] += (foo() + arr[i]) + n;\n\n", "pragma": "#pragma omp parallel for schedule(static, 5) private(arr) default(none) firstprivate(n) shared(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/parallel_for_codegen/0"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    mass_flux_x[FTNREF2D(j, 1 - k, x_max + 5, x_min - 2, y_min - 2)] = mass_flux_x[FTNREF2D(j, 1 + k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/48"}
{"code": "for (i = 0; i < rhs.rows; i++)\n  for (j = 0; j < rhs.cols; j++)\n  help.m[i][j] = x0.m[i][j];\n\n\n", "pragma": "omp for SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/linsolv/2"}
{"code": "for (i = 1; i < (n - 1); i++)\n{\n  neighbor = ((((((r[i - 1] + r[i]) + r[i + 1]) + a[(i * n) - 1]) + a[((i + 2) * n) - 1]) + a[(i * n) - 2]) + a[((i + 2) * n) - 2]) + a[((i + 1) * n) - 2];\n  b[((i + 1) * n) - 1] = find_new_a(a[((i + 1) * n) - 1], neighbor);\n}\n\n", "pragma": "omp for private(i, neighbor) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannisLamp/game-of-life/mpi_openmp/ompi_functions/6"}
{"code": "for (ptrdiff_t i = 0; i < (i_size * j_size); ++i)\n{\n  *(data_ + i) = 0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_matrix/0"}
{"code": "for (int k = 0; k < SDMGeom->L_NodeZ(); k++)\n{\n  for (int j = 0; j < SDMGeom->L_NodeY(); j++)\n  {\n    for (int i = 0; i < HALO.x; i++)\n    {\n      indx1 = (i + (j * HALO.x)) + ((k * NodLoc.y) * HALO.x);\n      indx2 = ((HALO.x + i) + ((j + HALO.y) * SDMGeom->HALO_NodeX())) + (((k + HALO.z) * SDMGeom->HALO_NodeX()) * SDMGeom->HALO_NodeY());\n      BN[indx1] = DomLoc[indx2];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(N_omp)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/7"}
{"code": "for (int row = 0; row < num_rows; row++)\n{\n  for (int col = 0; col < num_cols; col++)\n  {\n    int i = col + (row * num_cols);\n    c[i] = a[i] + b[i];\n  }\n\n}\n\n", "pragma": "      #pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/CMPE275-OpenMP/matrix/src/matrix-parallel/0"}
{"code": "for (unsigned i = 0; i < n_vertices_local; i++)\n{\n  n_successors_tmp = hero_tryread((unsigned *) (&vertices_local[i].n_successors));\n  if (n_successors_max_local < n_successors_tmp)\n    n_successors_max_local = n_successors_tmp;\n\n}\n\n", "pragma": "omp for reduction(max: n_successors_max_local)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pulp-platform/hero-openmp-examples/linked-list/linked-list/3"}
{"code": "for (jz = HALO_Z; jz < (DIM_Z - HALO_Z); jz++)\n{\n  #pragma acc loop independent vector(8)\n  for (jy = HALO_Y; jy < (DIM_Y - HALO_Y); jy++)\n  {\n    #pragma acc loop independent vector(32)\n    for (jx = HALO_X; jx < (DIM_X - HALO_X); jx++)\n    {\n      fn[ADDR_FROM_XYZ(jx, jy, jz)] = ((((((cc * f[ADDR_FROM_XYZ(jx, jy, jz)]) + (ce * f[ADDR_FROM_XYZ(jx + 1, jy, jz)])) + (cw * f[ADDR_FROM_XYZ(jx - 1, jy, jz)])) + (cn * f[ADDR_FROM_XYZ(jx, jy + 1, jz)])) + (cs * f[ADDR_FROM_XYZ(jx, jy - 1, jz)])) + (ct * f[ADDR_FROM_XYZ(jx, jy, jz + 1)])) + (cb * f[ADDR_FROM_XYZ(jx, jy, jz - 1)]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muellermichel/Hybrid-Fortran/examples/diffusion3d/source/diffusion3d/0"}
{"code": "for (int I = 0; I < R; I++)\n{\n  for (int J = 0; J < C; J++)\n  {\n    idx = (I * C) + J;\n    new_element.type = EMPTY;\n    new_element.temp_type = EMPTY;\n    new_element.gen_food = 0;\n    new_element.gen_proc = 0;\n    eco_system[idx] = new_element;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoaoCosta94/Ecosystem_Sim_OpenMP/source/functions/8"}
{"code": "for (i = 3; i <= (grid_points[0] - 4); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/55"}
{"code": "for (int i = i_ini; i < (i_ini + n_part); i++)\n{\n  d[i] = 0.0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n    if (i == Aj[u])\n    d[i] += Ax[u];\n\n\n}\n\n", "pragma": "omp parallel for reduction(+:d[0:n_part])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/12"}
{"code": "for (unsigned int i = 1; i < container.size(); ++i)\n{\n  if ((++it)->second > temp)\n  {\n    temp = it->second;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main/0"}
{"code": "for (int i = 0; i < station->nr; ++i)\n{\n  idx_station_vx[i] = SFindNode(station->pos_vx[i]);\n  idx_station_vy[i] = SFindNode(station->pos_vy[i]);\n  idx_station_vz[i] = SFindNode(station->pos_vz[i]);\n  if (((idx_station_vx[i].x > (-1)) && (idx_station_vx[i].y > (-1))) && (idx_station_vx[i].z > (-1)))\n  {\n    station->FileOpen(i, 1, \"VX\");\n    station->LoadFile(i, \"VX\");\n  }\n\n  if (((idx_station_vy[i].x > (-1)) && (idx_station_vy[i].y > (-1))) && (idx_station_vy[i].z > (-1)))\n  {\n    station->FileOpen(i, 1, \"VY\");\n    station->LoadFile(i, \"VY\");\n  }\n\n  if (((idx_station_vz[i].x > (-1)) && (idx_station_vz[i].y > (-1))) && (idx_station_vz[i].z > (-1)))\n  {\n    station->FileOpen(i, 1, \"VZ\");\n    station->LoadFile(i, \"VZ\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/20"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/23"}
{"code": "for (int _i = 0; _i <= sN; _i++)\n  for (int _k = 0; _k <= K; _k++)\n  if ((_k >= id1_st) && (_k < id1_end))\n  if ((_i >= id2_st) && (_i < id2_end))\n{\n  int bi = 1;\n  int bj = 1;\n  if (sN / mpi_size)\n    bi = _i / (sN / mpi_size);\n\n  if (K / mpi_size)\n    bj = _k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = bi - bj;\n  if (st < 0)\n    st += mpi_size;\n\n  st = (st + mpi_rank) % mpi_size;\n  if (bb == st)\n  {\n    s->rb = bb * (_M / mpi_size);\n    s->re = s->rb + (_M / mpi_size);\n    if (bb == 0)\n      s->rb = 1;\n\n    if (bb == (mpi_size - 1))\n      s->re = _M;\n\n    s->rb = 1;\n    s->re = _M;\n    int aux_size[3] = {0, 0, 0};\n    int aux_size2[3] = {0, 0, 0};\n    s->m3d_c = 1;\n    s->m3d_x = _i;\n    s->m3d_y = _k;\n    s->Bt = s->sBt;\n    s->RS = s->sRS;\n    s->U.set(s->b_U, s->m3d_x, s->m3d_y, s->m3d_c);\n    s->C.set(s->b_C, s->m3d_x, s->m3d_y, s->m3d_c);\n    s->T.set(s->b_T, s->m3d_x, s->m3d_y, s->m3d_c);\n    vmul_T_3d_set_tmp(N, tmp, tmp_n, tmp2, tmp_n2);\n    if (toeplitz_mult_alg == 0)\n    {\n      for (int i = 1; i < _M; i++)\n      {\n        double v = 0.0;\n        for (int j = 1; j < i; j++)\n          v += s->Bt[idx(_i, j, _k)] * s->Tm[1][(i - j) + 1];\n\n        if (space_der == 1)\n          for (int j = i + 1; j < _M; j++)\n          v -= s->Bt[idx(_i, j, _k)] * s->Tm[1][(j - i) + 1];\n\n\n        if (implicit_row_scaling == 1)\n          v /= s->RS[idx(_i, i, _k)];\n\n        r[idx(_i, i, _k)] += v * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n        ;\n      }\n\n    }\n\n    if (toeplitz_mult_alg == 1)\n    {\n      for (int i = 1; i < _M; i++)\n        tmp[1][i] = s->Bt[idx(_i, i, _k)];\n\n      Toeplitz_mult(s->Tm[1] + 1, tmp[1] + 1, tmp[0], _M - 1, 0);\n      for (int i = 1; i < _M; i++)\n      {\n        if (implicit_row_scaling == 1)\n          tmp[0][i - 1] /= s->RS[idx(_i, i, _k)];\n\n        r[idx(_i, i, _k)] += tmp[0][i - 1] * ((s->equation == 0) ? (s->inv_dw_dh(i)) : (1.0));\n        ;\n      }\n\n    }\n\n    if (toeplitz_mult_alg == 2)\n    {\n      aux_size[1] = (aux_size2[1] = 0);\n      Tm_diags_mul_left(_M, s, tmp[1], tmp_n[1], aux_size[1], r, 0, 1, _i, _k);\n      if (space_der == 1)\n        Tm_diags_mul_right(_M, s, tmp2[1], tmp_n2[1], aux_size2[1], r, 1, _i, _k);\n\n      Tm_diags_mul_left(_M, s, coefs[(_i * (K + 1)) + _k], coefs_n[(_i * (K + 1)) + _k], coefs_size[(_i * (K + 1)) + _k], r, 0, 1, _i, _k);\n      if (space_der == 1)\n        Tm_diags_mul_right(_M, s, coefs2[(_i * (K + 1)) + _k], coefs_n2[(_i * (K + 1)) + _k], coefs_size2[(_i * (K + 1)) + _k], r, 1, _i, _k);\n\n    }\n\n  }\n\n}\n\n\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/153"}
{"code": "for (i = 1; i < (M + 1); i++)\n{\n  V(u, i, 0) = V(u, i, N);\n  V(u, i, N + 1) = V(u, i, 1);\n}\n\n", "pragma": "omp parallel for schedule(static) default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongbozhang85/openmp-cuda-advection-solver/openmp/parAdvect/0"}
{"code": "for (k = 1; k <= (*nzv); k++)\n{\n  if (iv[k] == i)\n  {\n    v[k] = val;\n    set = TRUE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/27"}
{"code": "for (i = 0; i < (num_particles - 1); i++)\n{\n  for (j = i + 1; j < num_particles; j++)\n  {\n    x = ((double) box.person[i].x_pos) - ((double) box.person[j].x_pos);\n    y = ((double) box.person[i].y_pos) - ((double) box.person[j].y_pos);\n    r = sqrt((x * x) + (y * y));\n    tmp = 2.0 / r;\n    fitness += pow(tmp, 12) - pow(tmp, 6);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += x_old[dangling_idx[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/casparwb/openmp_pagerank-calculations/read_graph_from_file/3"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = L1; j <= L2; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = u[i][j][k][2];\n      u31 = u[i][j][k][2] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = u[i][j][k][1] * u31;\n      flux[i][j][k][2] = (u[i][j][k][2] * u31) + (0.40e+00 * (u[i][j][k][4] - q));\n      flux[i][j][k][3] = u[i][j][k][3] * u31;\n      flux[i][j][k][4] = ((1.40e+00 * u[i][j][k][4]) - (0.40e+00 * q)) * u31;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/9"}
{"code": "for (int i = 0; i < train_space; i++)\n{\n  double f_rand = 0.02 * ((((double) rand()) / RAND_MAX) - 0.5);\n  int j = train_test_idx[0][i];\n  res[i] = f_rand + fxy(grid(j, 0), grid(j, 1), 0.25, 0.25, 2.0 / m, 2.0 / m, 0.2, 0.1);\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Anson008/Gaussian_Process_Regression/src/gpr/3"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int lam = lambda[i];\n  int idx = ptr[lam] + (cnt[lam]++);\n  i2n[idx] = i;\n  n2i[i] = idx;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/103"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(logFile, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(logFile, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(logFile, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(logFile, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(logFile, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/testsuite/c/omp_for_schedule_static/5"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  b[i] = foo(a, 4);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/CodeThorn/src/tests/ompcfg/Par-20-ParallelForCallFuncParallelFor/1"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  ll = nz - loff;\n  ll = (mz < ll) ? (mz) : (ll);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  edgelz = loff;\n  edgerz = loff + ll;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  ll += 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (j = 0; j < 26; j++)\n  {\n    ncl[j + (26 * l)] = 0;\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    dz = z + (vz * dtc);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx = dx - anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0f;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy = dy - any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0f)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0f;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    if (dz >= edgerz)\n    {\n      if (dz >= anz)\n        dz = dz - anz;\n\n      mm += 18;\n    }\n    else\n      if (dz < edgelz)\n    {\n      if (dz < 0.0f)\n      {\n        dz += anz;\n        if (dz < anz)\n          mm += 9;\n        else\n          dz = 0.0f;\n\n      }\n      else\n      {\n        mm += 9;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (26 * l)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * l))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * l)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * l] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,noff,moff,loff,npp,npoff,nn,mm,ll,nm,ih,nh,x,y,z,vx, vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt, omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, edgelx,edgely,edgelz,edgerx,edgery,edgerz,sum1,sfxyz,sbxyz) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/3"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  phi = data.pseudo_K0RS[(nuc * input.numL) + i] * sqrt(E);\n  if (i == 1)\n    phi -= -atan(phi);\n  else\n    if (i == 2)\n    phi -= atan((3.0 * phi) / (3.0 - (phi * phi)));\n  else\n    if (i == 3)\n    phi -= atan((phi * (15.0 - (phi * phi))) / (15.0 - ((6.0 * phi) * phi)));\n\n\n\n  phi *= 2.0;\n  sigTfactors[i].r = cos(phi);\n  sigTfactors[i].i = -sin(phi);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/7"}
{"code": "for (ix = 0; ix <= (nx - 1); ix++)\n{\n  for (iy = 0; iy <= (ny - 1); iy++)\n  {\n    *((u + (ix * ny)) + iy) = (float) (((ix * ((nx - ix) - 1)) * iy) * ((ny - iy) - 1));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/spirosdelviniotis/parallel_programming/OpenMP/Pure_OpenMP_main/3"}
{"code": "for (j = i; j < len1; j++)\n{\n  if (sumMatrix[i][j] >= maxOpening)\n  {\n    maxOpening = sumMatrix[i][j];\n    end = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nofaralfasi/Parallel-Sequence-Alignment/src/calculations/3"}
{"code": "for (k = 0; k < N; k++)\n{\n  a[k] = 3.0 * k;\n  b[k] = 1.8 * k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/dot_prod/1"}
{"code": "for (int tt = 0; tt < params.maxIters; tt += 2)\n{\n  d2q9_bgk(params, tot_cells, cells, obstacles, av_vels, tt);\n  printf(\"==timestep: %d==\\n\", tt);\n  printf(\"av velocity: %.12E\\n\", av_vels[tt]);\n  printf(\"==timestep: %d==\\n\", tt + 1);\n  printf(\"av velocity: %.12E\\n\", av_vels[tt + 1]);\n  printf(\"tot density: %.12E\\n\", total_density(params, cells));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DramaCow/d2q9-bgk/openmp/d2q9-bgk/8"}
{"code": "for (i = 0; i < nonzeros; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    k = indices[pos++];\n    int now = tempX[(j * max_dim) + k];\n    WhereX[now] = i;\n    tempX[(j * max_dim) + k]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/10"}
{"code": "for (int i = 0; i < objs; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    if (collide(points[i], points[j]))\n    {\n      points[i].killer = j;\n      points[i].killed = true;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for schedule(auto)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Skaidus/p2_AC_2021_22/src/p2/Simulators/AosSimulator/0"}
{"code": "for (i = 0; i < nra; ++i)\n{\n  for (j = 0; j < nra; ++j)\n  {\n    bT[(j * nra) + i] = a[((1 * nra) * nra) + ((i * nra) + j)];\n  }\n\n}\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OcraM17/ParallelMatrix/Mult/1"}
{"code": "for (pos = &ciphertext[28]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETSPLITLM_fmt_plug/1"}
{"code": "for (i = 0; i < node_count; i++)\n{\n  if (i != current)\n  {\n    nodes[i].total_distance = -1;\n    add_unvisited_node(&unvisited_nodes_head, i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YarnSeemannsgarn/University_Innsbruck-Parallel_Systems-Homework_6/programme/dijkstra_openmp/3"}
{"code": "for (int i = 0; i < nconf; i++)\n{\n  dcdreadframe(ax, ay, az, infile, numatm, xbox, ybox, zbox);\n  for (int j = 0; j < numatm; j++)\n  {\n    h_x[(i * numatm) + j] = ax[j];\n    h_y[(i * numatm) + j] = ay[j];\n    h_z[(i * numatm) + j] = az[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openhackathons-org/gpubootcamp/hpc/nways/nways_labs/nways_MD/English/C/source_code/openmp/SOLUTION/rdf/0"}
{"code": "for (i = 0; i < 1; i++)\n{\n  for (j = 0; j < 5; j++)\n  {\n    TOPO[i + 1][j + 1] = count;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/4"}
{"code": "for (int j = 0; j < y_points; j++)\n{\n  u_new[j][0] = 1.0;\n  v_new[j][0] = 1.0;\n  u_new[j][y_points - 1] = 1.0;\n  v_new[j][y_points - 1] = 1.0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D Burgers Equation/2-D_Burgers_Equation/main/4"}
{"code": "for (i = 0; i < size_seq2; i++)\n{\n  if (seq1[i] == seq2[i])\n  {\n    counts.countStars++;\n  }\n  else\n    if (checkSemiOrSemiConservativeGroups1(&seq1[i], &seq2[i], cons_Groups, 9) == 1)\n  {\n    counts.countColons++;\n  }\n  else\n    if (checkSemiOrSemiConservativeGroups1(&seq1[i], &seq2[i], semi_Cons_Groups, 11) == 1)\n  {\n    counts.countDots++;\n  }\n  else\n  {\n    counts.countSpaces++;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnnaML3011/Parallel-implementation-of-Sequence-Alignment-Using-CUDA-MPI-OpenMp-/main/9"}
{"code": "for (int i = 0; i < NUMBER_OF_BINS; i++)\n  local_hashmap.push_back(map_tuple());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramachav/Map-Reduce-Multi-Threaded/Map_Reduce_Code/map_reduce/13"}
{"code": "for (int i = 0; i < N; i++)\n{\n  printf(\"%i \", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/6th/6th/3"}
{"code": "for (u = ((2U * 0x7fffffff) + 1) - 6; u < ((2U * 0x7fffffff) + 1); u += 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/23"}
{"code": "for (int k = 0; k < l; k++)\n  kvalue[k] = sv_coef[k] * k_function(x, model->SV[k], model->param);\n\n", "pragma": "\t\t#pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/76"}
{"code": "for (i = 0; i < tnum; i++)\n{\n  if (terminated[i] == 0)\n    return 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JoseCVieira/ParallelSudoku/omp/sudoku-omp/7"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  if (a[i] != (i + 1))\n    printf(\"%d: a error %d != %d, error %d\\n\", i, a[i], i + 1, ++error);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-enter-nowait/test/9"}
{"code": "for (int i = 0; i < numNodes; i++)\n{\n  if (i == 0)\n  {\n    datasetDisp[i] = 0;\n  }\n  else\n  {\n    sum += pointsPerNode[i - 1];\n    datasetDisp[i] = sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/5"}
{"code": "for (int i = 0; i < NUM_BINS; i++)\n{\n  if (datum < bin_max[i])\n  {\n    bin_num = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TAD-SSE-663/ParallelProgramming/ParallelProgramming/OpenMP/omp_histogram/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  z.arr[i] = arr[i] + k.arr[i];\n  z.arr[i].outp();\n  cout << endl;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector1/0"}
{"code": "for (i = 0; i < rows2; i++)\n{\n  for (j = 0; j < cols2; j++)\n  {\n    b[i][j] = rand();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hiteshbhavsar/OpenMP-Assignment/ConsoleApplication1/OpenMPAssignment/1"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    for (n = 0; n <= 4; n += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i + 1][j][k][n]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/139"}
{"code": "for (ib = 0; ib < len; ib += ibl)\n{\n  for (jb = 0; jb < len; jb += ibl)\n  {\n    for (kb = 0; kb < len; kb += ibl)\n    {\n      for (i = ib; (i < (ib + ibl)) && (i < len); ++i)\n      {\n        for (j = jb; (j < (jb + ibl)) && (j < len); ++j)\n        {\n          for (k = kb; (k < (kb + ibl)) && (k < len); ++k)\n          {\n            localC[(len * i) + j] += A[(len * i) + k] * B[(len * k) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tsuzu/sgx-omp-example/App/App/1"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  A[tt][i] += 3;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-l2-parallel/test/0"}
{"code": "for (int i = 0; i < count; ++i)\n{\n  (out << y[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shivam-anand/matPar/openmp/gauss/3"}
{"code": "for (rowcol = 0; rowcol < N; rowcol++)\n{\n  if (((((mat1[rowcol] == (-28768)) || (mat3[rowcol] == (-28768))) || (mat4[rowcol] <= 0)) || ((mat3[rowcol] * 0.02) < 250.0)) || ((mat3[rowcol] * 0.02) > 360.0))\n  {\n    matOut[rowcol] = -28768;\n    matOut0[rowcol] = -28768;\n    matOut1[rowcol] = -28768;\n  }\n  else\n  {\n    e0 = e_0(mat1[rowcol] * 0.0001, mat2[rowcol] * 0.1);\n    tsw = 0.75 + ((2 * pow(10, -5)) * mat5[rowcol]);\n    lin = Lin(tsw, ta);\n    lout = Lout(e0, mat3[rowcol] * 0.02);\n    lnet = Lnet(lout, lin);\n    kin = Kin(doy, matLat[rowcol], tsw);\n    rnet = Rnet(mat4[rowcol] * 0.001, lnet, kin);\n    g_0 = g0(rnet, mat3[rowcol] * 0.02, mat4[rowcol] * 0.001, mat1[rowcol] * 0.0001);\n    z_0m = z0m(mat2[rowcol] * 0.01);\n    h0 = metiter(a, b, mat3[rowcol] * 0.02, rah_0, z_0m, ustar_0, mat5[rowcol], u200, iteration);\n    dailyN = daily_N(doy, matLat[rowcol]);\n    t0dem = (mat3[rowcol] * 0.02) - (0.00625 * mat5[rowcol]);\n    tadem = t0dem - ((a[iteration] * t0dem) + b[iteration]);\n    metricdtair = ((a[iteration] * mat3[rowcol]) * 0.02) + b[iteration];\n    matOut1[rowcol] = metricdtair;\n    metriceta = ETinst(rnet, g_0, h0, tadem);\n    matOut[rowcol] = metriceta;\n    pmeto = EToPM(mat3[rowcol] * 0.02, mat5[rowcol], u, rnet * 0.0864, rh, 0.6, dailyN);\n    metricevapfr = metriceta / pmeto;\n    if (metricevapfr < 0.0)\n      matOut0[rowcol] = -28768;\n    else\n      matOut0[rowcol] = metricevapfr;\n\n    if (metricevapfr < 0.0)\n      metrictheta = -28768;\n    else\n      metrictheta = soilmoisture(metricevapfr);\n\n    matOut2[rowcol] = metrictheta;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(rowcol, e0, tsw, lin, lout, lnet, kin, rnet, g_0, z_0m, h0, t0dem, tadem, pmeto, dailyN, metricevapfr, metriceta, metricdtair, metrictheta) shared(N, rh, u, a, b, doy, ta, u200, rah_0, ustar_0, iteration, mat1, mat2, mat3, mat4, mat5, matOut2, matOut1, matOut0, matOut, matLat )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/3"}
{"code": "for (int i = 0; i < tam; i++)\n{\n  vetor[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sort/0"}
{"code": "for (int j = 1; j < (this->size_ - 1); ++j)\n{\n  idx = (0 * this->size_) + j;\n  cast_out->vec_[idx] = (((((((static_cast < ValueType) > (((-1) * cast_in->vec_[idx - 1]) + static_cast)) < ValueType) > ((4 * cast_in->vec_[idx]) + static_cast)) < ValueType) > (((-1) * cast_in->vec_[idx + 1]) + static_cast)) < ValueType) > ((-1) * cast_in->vec_[idx + this->size_]);\n  idx = ((this->size_ - 1) * this->size_) + j;\n  cast_out->vec_[idx] = (((((((static_cast < ValueType) > (((-1) * cast_in->vec_[idx - this->size_]) + static_cast)) < ValueType) > (((-1) * cast_in->vec_[idx - 1]) + static_cast)) < ValueType) > ((4 * cast_in->vec_[idx]) + static_cast)) < ValueType) > ((-1) * cast_in->vec_[idx + 1]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_stencil_laplace2d/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  c[i] = a[i] + b[i];\n  printf(\"%d=%d+%d\\n\", c[i], a[i], b[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiuwenhui/openmp_examples/example1/openmpfor/openmpfor1/0"}
{"code": "for (i = 0; i < vector_size; i++)\n{\n  if (vector[i] > max)\n  {\n    max = vector[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nrvru/parallel-lab1/RandomVector/1"}
{"code": "for (int ia = 0; ia < vol_a; ia++)\n{\n  int it_a = ia;\n  int id_a = id_b;\n  int is = 0;\n  int im_a;\n  int ic;\n  for (int i = 0; i < dim_a; i++)\n  {\n    im_a = it_a * shape_a_inv[i];\n    ic = it_a - (im_a * shape_a[i]);\n    id_a += stride_a_g[i] * ic;\n    is += stride_a_l[i] * ic;\n    it_a = im_a;\n  }\n\n  data_out[id_a] = s[is];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olcf-tutorials/openmp_offloading/nested_tnsrtrns/tnsrtrns/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/6th/6th/1"}
{"code": "for (int i = 0; i != N; ++i)\n{\n  for (int j = 0; j != N; ++j)\n  {\n    printf(\"%f \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lll-phill-lll/HPC_openmp/MatMul/1"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  local_sum += (dx * (f(i * dx) + f((i + 1) * dx))) / 2;\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alekseyen/MIPT_parallel_distribution_5sem/mpi:openmp/3/critical/0"}
{"code": "for (int i = 0; i < 1000000; i++)\n{\n  if (dnabig[i] == 'A')\n  {\n    count = count + 1;\n  }\n  else\n  {\n    continue;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/7"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    fprintf(output, \"%f \", result[i][j]);\n  }\n\n  fputs(\"\\n\", output);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jaaasonwu/HeatDistribution/mpi_heat_distribution/6"}
{"code": "for (i = 0; i < nT; i++)\n{\n  int bj = nT / Q;\n  int rj = nT % Q;\n  int cj = 0;\n  int nj = 0;\n  for (j = 0; j < nT; j++)\n  {\n    if (j > i)\n      owner[i][j] = -1;\n    else\n    {\n      if (randDist)\n        owner[i][j] = rand() % nthreads;\n      else\n        if (blockDist)\n        owner[i][j] = (ni * Q) + nj;\n      else\n        owner[i][j] = ((i % P) * Q) + (j % Q);\n\n\n      assert((0 <= owner[i][j]) && (owner[i][j] < nthreads));\n    }\n\n    cj++;\n    if (cj == (bj + (rj > 0)))\n      nj++, cj = 0, rj--;\n\n  }\n\n  ci++;\n  if (ci == (bi + (ri > 0)))\n    ni++, ci = 0, ri--;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhyuchao123/OpenMP-and-CUDA-for-matrix-decomposition/openmp/parCholesky/3"}
{"code": "for (round = 0; round < cKeccakNumberOfRounds; ++round)\n{\n  {\n    BC[0] = (((state[0] ^ state[5]) ^ state[10]) ^ state[15]) ^ state[20];\n    BC[1] = (((state[1] ^ state[6]) ^ state[11]) ^ state[16]) ^ state[21];\n    BC[2] = (((state[2] ^ state[7]) ^ state[12]) ^ state[17]) ^ state[22];\n    BC[3] = (((state[3] ^ state[8]) ^ state[13]) ^ state[18]) ^ state[23];\n    BC[4] = (((state[4] ^ state[9]) ^ state[14]) ^ state[19]) ^ state[24];\n    temp = BC[4] ^ ROL32(BC[1], 1);\n    state[0] ^= temp;\n    state[5] ^= temp;\n    state[10] ^= temp;\n    state[15] ^= temp;\n    state[20] ^= temp;\n    temp = BC[0] ^ ROL32(BC[2], 1);\n    state[1] ^= temp;\n    state[6] ^= temp;\n    state[11] ^= temp;\n    state[16] ^= temp;\n    state[21] ^= temp;\n    temp = BC[1] ^ ROL32(BC[3], 1);\n    state[2] ^= temp;\n    state[7] ^= temp;\n    state[12] ^= temp;\n    state[17] ^= temp;\n    state[22] ^= temp;\n    temp = BC[2] ^ ROL32(BC[4], 1);\n    state[3] ^= temp;\n    state[8] ^= temp;\n    state[13] ^= temp;\n    state[18] ^= temp;\n    state[23] ^= temp;\n    temp = BC[3] ^ ROL32(BC[0], 1);\n    state[4] ^= temp;\n    state[9] ^= temp;\n    state[14] ^= temp;\n    state[19] ^= temp;\n    state[24] ^= temp;\n  }\n  {\n    temp = state[1];\n    BC[0] = state[10];\n    state[10] = ROL32(temp, 1);\n    temp = BC[0];\n    BC[0] = state[7];\n    state[7] = ROL32(temp, 3);\n    temp = BC[0];\n    BC[0] = state[11];\n    state[11] = ROL32(temp, 6);\n    temp = BC[0];\n    BC[0] = state[17];\n    state[17] = ROL32(temp, 10);\n    temp = BC[0];\n    BC[0] = state[18];\n    state[18] = ROL32(temp, 15);\n    temp = BC[0];\n    BC[0] = state[3];\n    state[3] = ROL32(temp, 21);\n    temp = BC[0];\n    BC[0] = state[5];\n    state[5] = ROL32(temp, 28);\n    temp = BC[0];\n    BC[0] = state[16];\n    state[16] = ROL32(temp, 4);\n    temp = BC[0];\n    BC[0] = state[8];\n    state[8] = ROL32(temp, 13);\n    temp = BC[0];\n    BC[0] = state[21];\n    state[21] = ROL32(temp, 23);\n    temp = BC[0];\n    BC[0] = state[24];\n    state[24] = ROL32(temp, 2);\n    temp = BC[0];\n    BC[0] = state[4];\n    state[4] = ROL32(temp, 14);\n    temp = BC[0];\n    BC[0] = state[15];\n    state[15] = ROL32(temp, 27);\n    temp = BC[0];\n    BC[0] = state[23];\n    state[23] = ROL32(temp, 9);\n    temp = BC[0];\n    BC[0] = state[19];\n    state[19] = ROL32(temp, 24);\n    temp = BC[0];\n    BC[0] = state[13];\n    state[13] = ROL32(temp, 8);\n    temp = BC[0];\n    BC[0] = state[12];\n    state[12] = ROL32(temp, 25);\n    temp = BC[0];\n    BC[0] = state[2];\n    state[2] = ROL32(temp, 11);\n    temp = BC[0];\n    BC[0] = state[20];\n    state[20] = ROL32(temp, 30);\n    temp = BC[0];\n    BC[0] = state[14];\n    state[14] = ROL32(temp, 18);\n    temp = BC[0];\n    BC[0] = state[22];\n    state[22] = ROL32(temp, 7);\n    temp = BC[0];\n    BC[0] = state[9];\n    state[9] = ROL32(temp, 29);\n    temp = BC[0];\n    BC[0] = state[6];\n    state[6] = ROL32(temp, 20);\n    temp = BC[0];\n    BC[0] = state[1];\n    state[1] = ROL32(temp, 12);\n    temp = BC[0];\n  }\n  {\n    BC[0] = state[0];\n    BC[1] = state[1];\n    BC[2] = state[2];\n    BC[3] = state[3];\n    BC[4] = state[4];\n    state[0] = BC[0] ^ ((~BC[1]) & BC[2]);\n    state[1] = BC[1] ^ ((~BC[2]) & BC[3]);\n    state[2] = BC[2] ^ ((~BC[3]) & BC[4]);\n    state[3] = BC[3] ^ ((~BC[4]) & BC[0]);\n    state[4] = BC[4] ^ ((~BC[0]) & BC[1]);\n    BC[0] = state[5];\n    BC[1] = state[6];\n    BC[2] = state[7];\n    BC[3] = state[8];\n    BC[4] = state[9];\n    state[5] = BC[0] ^ ((~BC[1]) & BC[2]);\n    state[6] = BC[1] ^ ((~BC[2]) & BC[3]);\n    state[7] = BC[2] ^ ((~BC[3]) & BC[4]);\n    state[8] = BC[3] ^ ((~BC[4]) & BC[0]);\n    state[9] = BC[4] ^ ((~BC[0]) & BC[1]);\n    BC[0] = state[10];\n    BC[1] = state[11];\n    BC[2] = state[12];\n    BC[3] = state[13];\n    BC[4] = state[14];\n    state[10] = BC[0] ^ ((~BC[1]) & BC[2]);\n    state[11] = BC[1] ^ ((~BC[2]) & BC[3]);\n    state[12] = BC[2] ^ ((~BC[3]) & BC[4]);\n    state[13] = BC[3] ^ ((~BC[4]) & BC[0]);\n    state[14] = BC[4] ^ ((~BC[0]) & BC[1]);\n    BC[0] = state[15];\n    BC[1] = state[16];\n    BC[2] = state[17];\n    BC[3] = state[18];\n    BC[4] = state[19];\n    state[15] = BC[0] ^ ((~BC[1]) & BC[2]);\n    state[16] = BC[1] ^ ((~BC[2]) & BC[3]);\n    state[17] = BC[2] ^ ((~BC[3]) & BC[4]);\n    state[18] = BC[3] ^ ((~BC[4]) & BC[0]);\n    state[19] = BC[4] ^ ((~BC[0]) & BC[1]);\n    BC[0] = state[20];\n    BC[1] = state[21];\n    BC[2] = state[22];\n    BC[3] = state[23];\n    BC[4] = state[24];\n    state[20] = BC[0] ^ ((~BC[1]) & BC[2]);\n    state[21] = BC[1] ^ ((~BC[2]) & BC[3]);\n    state[22] = BC[2] ^ ((~BC[3]) & BC[4]);\n    state[23] = BC[3] ^ ((~BC[4]) & BC[0]);\n    state[24] = BC[4] ^ ((~BC[0]) & BC[1]);\n  }\n  state[0] ^= KeccakF_RoundConstants[round];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/keccaktreehash-omp/KeccakTreeGPU/0"}
{"code": "for (int j = 0; j <= _M; j++)\n  for (int k = 0; k <= K; k++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (_M / mpi_size)\n    bi = j / (_M / mpi_size);\n\n  if (K / mpi_size)\n    bj = k / (K / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = (bj + bi) % mpi_size;\n  st = ((mpi_size + st) - mpi_rank) % mpi_size;\n  s->rb = st * (sN / mpi_size);\n  s->re = s->rb + (sN / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = sN + 1;\n\n  for (int i = s->rb; i < s->re; i++)\n  {\n    if (i != 0)\n      r[idx(i, j, k)] += s->Mat_3d[5][idx(i, j, k)] * x[idx(i - 1, j, k)];\n\n    if (i != sN)\n      r[idx(i, j, k)] += s->Mat_3d[6][idx(i, j, k)] * x[idx(i + 1, j, k)];\n\n  }\n\n}\n\n\n", "pragma": "#pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/146"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  if (b[i][i] == 0)\n  {\n    for (int m = i + 1; m < n; m++)\n    {\n      if (b[m][i] != 0)\n      {\n        for (int x = 0; x < (n + 1); x++)\n        {\n          float temp = b[i][x];\n          b[i][x] = b[m][x];\n          b[m][x] = temp;\n        }\n\n        break;\n      }\n\n    }\n\n    if (b[i][i] == 0)\n      x = 0;\n\n  }\n\n  for (int k = 1; k < (n - i); k++)\n  {\n    float l = b[i + k][i] / b[i][i];\n    L[i + k][i] = l;\n    for (int j = 0; j < (n + 1); j++)\n    {\n      b[i + k][j] -= l * b[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/2.LU_Decomposition/LU_openMP_Improvised_Version/1"}
{"code": "for (indice = 0; indice < filasXproceso; indice++)\n{\n  arbolesContagiando = 0;\n  vecinosVisitados = 0;\n  if (indice > 0)\n  {\n    if (matrizLocal[indice - 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 1].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice > 1)\n  {\n    if (matrizLocal[indice - 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice - 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice - 2].fila >= 0)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 1))\n  {\n    if (matrizLocal[indice + 1].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 1].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 1].fila < 800)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < (filasXproceso - 2))\n  {\n    if (matrizLocal[indice + 2].fila == matrizLocal[indice].fila)\n    {\n      if (matrizLocal[indice + 2].color == 3)\n      {\n        arbolesContagiando += 1;\n      }\n\n      if (matrizLocal[indice + 2].fila < 800)\n      {\n        vecinosVisitados += 1;\n      }\n\n    }\n\n  }\n\n  if (indice < 800)\n  {\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + 800].fila)\n    {\n      if (arregloArriba[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((matrizLocal[indice].fila - 1) == arregloArriba[indice + (800 + 1)].fila) && (indice < (800 - 1)))\n    {\n      if (arregloArriba[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + (800 - 1)].fila)\n    {\n      if (arregloArriba[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 800)].fila)\n    {\n      if (matrizLocal[indice + (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 800)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice > (800 - 1)) && (indice < (800 * 2)))\n  {\n    if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n    {\n      if (arregloArriba[indice].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloArriba[indice].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (((indice - (800 + 1)) >= 0) && ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila))\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila >= 0)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (800 * 2)) && (indice < (filasXproceso - (2 * 800))))\n  {\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 800)].fila)\n    {\n      if (matrizLocal[indice + (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 800)].fila)\n    {\n      if (matrizLocal[indice - (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n  }\n\n  if ((indice >= (filasXproceso - (800 * 2))) && (indice < (filasXproceso - 800)))\n  {\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajo].fila)\n    {\n      if (arregloAbajo[indiceAbajo].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajo].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 800].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 + 1)].fila)\n    {\n      if (matrizLocal[indice + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (800 - 1)].fila)\n    {\n      if (matrizLocal[indice + (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice + (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (800 * 2)].fila)\n    {\n      if (matrizLocal[indice - (800 * 2)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 * 2)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if ((indice >= (filasXproceso - 800)) && (indice < filasXproceso))\n  {\n    if (indiceAbajoB == 800)\n    {\n      indiceAbajoB = 0;\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB].fila)\n    {\n      if (arregloAbajo[indiceAbajoB].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if (indiceAbajoB > 0)\n    {\n      if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB - 1].fila)\n      {\n        if (arregloAbajo[indiceAbajoB - 1].color == 3)\n        {\n          arbolesContagiando++;\n        }\n\n        if (arregloAbajo[indiceAbajoB - 1].fila < 800)\n        {\n          vecinosVisitados++;\n        }\n\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB + 1].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 1].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 1].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajoB + 800].fila)\n    {\n      if (arregloAbajo[indiceAbajoB + 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (arregloAbajo[indiceAbajoB + 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 800].fila)\n    {\n      if (matrizLocal[indice - 800].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - 800].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 + 1)].fila)\n    {\n      if (matrizLocal[indice - (800 + 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 + 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (800 - 1)].fila)\n    {\n      if (matrizLocal[indice - (800 - 1)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (800 - 1)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 800)].fila)\n    {\n      if (matrizLocal[indice - (2 * 800)].color == 3)\n      {\n        arbolesContagiando++;\n      }\n\n      if (matrizLocal[indice - (2 * 800)].fila < 800)\n      {\n        vecinosVisitados++;\n      }\n\n    }\n\n    indiceAbajoB++;\n  }\n\n  if (matrizLocal[indice].edad < 157)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.35 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.35;\n    }\n\n  }\n\n  if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.17 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.17;\n    }\n\n  }\n\n  if (matrizLocal[indice].edad >= 1821)\n  {\n    if (matrizLocal[indice].heridas == 1)\n    {\n      susceptibilidad = 0.63 + 0.15;\n    }\n    else\n    {\n      susceptibilidad = 0.63;\n    }\n\n  }\n\n  matrizLocalAux[indice].edad += 1;\n  if (matrizLocal[indice].color == 4)\n  {\n    matrizLocalAux[indice].semanasInfectado += 1;\n    matrizLocalAux[indice].semanasTotales++;\n  }\n\n  if (matrizLocal[indice].semanasInfectado == 3)\n  {\n    matrizLocalAux[indice].color = 3;\n  }\n\n  if (matrizLocal[indice].color == 3)\n  {\n    matrizLocalAux[indice].semanasTotales++;\n    if ((rand() % 100) <= 85)\n    {\n      matrizLocalAux[indice].color = 2;\n      matrizLocalAux[indice].semanasInfectado = 0;\n      matrizLocalAux[indice].semanasTotales += 1;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 2)\n  {\n    if (matrizLocal[indice].semanasTotales <= 8)\n    {\n      matrizLocalAux[indice].semanasTotales++;\n    }\n    else\n    {\n      if (matrizLocal[indice].edad < 157)\n      {\n        if ((rand() % 100) > 3)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n      {\n        if ((rand() % 100) > 15)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 1;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n\n      }\n\n      if (matrizLocal[indice].edad >= 1821)\n      {\n        if ((rand() % 100) > 53)\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasTotales = 0;\n          matrizLocalAux[indice].edad = 57;\n        }\n\n      }\n\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 1)\n  {\n    if (matrizLocal[indice].semanasPodado <= 12)\n    {\n      matrizLocalAux[indice].semanasPodado++;\n    }\n    else\n    {\n      matrizLocalAux[indice].color = 5;\n      matrizLocalAux[indice].semanasPodado = 0;\n    }\n\n  }\n\n  if (matrizLocal[indice].color == 5)\n  {\n    porcentajeEnfermos = (float) (arbolesContagiando / vecinosVisitados);\n    probabilidadContagio = (((float) (porcentajeEnfermos + susceptibilidad)) * 0.60) + 0.07;\n    if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n    {\n      matrizLocalAux[indice].color = 4;\n    }\n\n  }\n\n  if (semana > 0)\n  {\n    probHeridas = rand() % 101;\n    if ((matrizLocal[indice].edad < 157) && (probHeridas < 23))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if (((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821)) && (probHeridas < 8))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n    if ((matrizLocal[indice].edad >= 1821) && (probHeridas < 37))\n    {\n      matrizLocalAux[indice].heridas = 1;\n    }\n    else\n    {\n      matrizLocalAux[indice].heridas = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(indice,indiceAbajoB, susceptibilidad, porcentajeEnfermos, probabilidadContagio, probHeridas, arbolesContagiando, vecinosVisitados) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalHibrido800/1"}
{"code": "for (l = 0; l < m; l++)\n{\n  ffx[0][l] = Q[i + (n * (l + (m * 1)))];\n  ffx[1][l] = (pow(Q[i + (n * (l + (m * 1)))], 2) / Q[i + (n * (l + (m * 0)))]) + ((g * pow(Q[i + (n * (l + (m * 0)))], 2)) / 2.0);\n  ffx[2][l] = (Q[i + (n * (l + (m * 1)))] * Q[i + (n * (l + (m * 2)))]) / Q[i + (n * (l + (m * 0)))];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ShallowWater/shwater2d/0"}
{"code": "for (i = 2; i < N; i++)\n{\n  F[i] = Fibon(i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMPFibon/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = (i + 0.5) * h;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Homagn/openmp_cpp_course/Homagni_assn5/Task1/OMP_PI/main/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  if (i == j)\n    S[i][j] = 1.0 - S[i][j];\n  else\n    S[i][j] = 0.0 - S[i][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yiapou13/PageRank/pagerank_gs_parallel/6"}
{"code": "for (i = 0; i < 100; i += 1)\n  A[i]++;\n\n", "pragma": "omp for schedule(ompss_dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_ompss.dg/c/success_for_slicer_01/0"}
{"code": "for (unsigned int i = 0; i < nthreads; ++i)\n{\n  integration_result += thread_sum[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkmashaev/OpenMP_Lab2/ParallelSolution/for_tid/2"}
{"code": "for (int i = 0; i < this->pixels.size(); i++)\n{\n  pixels_out.push_back(this->pixels[i].r);\n  pixels_out.push_back(this->pixels[i].g);\n  pixels_out.push_back(this->pixels[i].b);\n  pixels_out.push_back(this->pixels[i].a);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MenesesGHZ/glitch/lib/glitch/0"}
{"code": "for (i = 0; i < neuron->n_weights; i++)\n{\n  result += neuron->weights[i] * data[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/generic_alg/src/NeuralNet/4"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  *(mat + (j + (i * n))) = (10.0 * rand()) / 32767;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sixeye/OPENMP_EXERCISES/QUESTION_7/QUESTION_7-b/TD_OPENMP_07b/3"}
{"code": "for (int j = 0; j < N; j++)\n{\n  unsigned int ii = (morton_codes[j] >> sft) & 0x07;\n  permutation_vector[BinCursor[ii]] = index[j];\n  sorted_morton_codes[BinCursor[ii]] = morton_codes[j];\n  BinCursor[ii]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/radix_sort/4"}
{"code": "for (int i = 0; i < systems[s].system_size; i++)\n{\n  systems[s].variable_value_t[i] = 0;\n  min = min(min, systems[s].variable_value_prev_t[i]);\n  max = max(max, systems[s].variable_value_prev_t[i]);\n}\n\n", "pragma": "        #pragma omp parallel for default(shared) schedule(static) reduction(min: min) reduction(max: max)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.2/multiple_system_solver/1"}
{"code": "for (row = xoffset + 1; row < ((xoffset + 1) + myxsize); row++)\n{\n  MPI_Recv(&u[0][row][yoffset + 1], 1, row_type, source, msgtype, 1, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/panosfoto/parallel_heat/mpi/mpi_heat_improved_persistent_stat/2"}
{"code": "for (i = 0; i < 8; i++)\n{\n  realcipher[i] = (atoi16[ARCH_INDEX(newCiphertextPointer[i * 2])] * 16) + atoi16[ARCH_INDEX(newCiphertextPointer[(i * 2) + 1])];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapB_fmt_plug/6"}
{"code": "for (ii = 0; ii < 10; ii = ii + ((int) (0.8 - 0.45)))\n  c[ii] = a[ii];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/33"}
{"code": "for (i = 0; i < 5; i++)\n{\n  int t_rank = omp_get_thread_num();\n  if (finish[i] == 0)\n  {\n    int canFinish = 1;\n    for (j = 0; j < 4; j++)\n    {\n      if (need[i][j] > avail[j])\n      {\n        canFinish = 0;\n        break;\n      }\n\n    }\n\n    if (canFinish)\n    {\n      sleep(1);\n      ans[ind++] = i;\n      for (y = 0; y < 4; y++)\n        avail[y] += alloc[i][y];\n\n      finish[i] = 1;\n      safe_processes += 1;\n    }\n\n  }\n\n  printf(\"Thread %d | Process %d | No. of Safe Processes: %d\\n\", t_rank, i, safe_processes);\n}\n\n", "pragma": "omp parallel for schedule(dynamic, 1) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephloochunhoe/parallel-computing/A1/Parallel_Bankers_Algorithm/0"}
{"code": "for (i = 0; i < 64; i++)\n  j += 2;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/_Atomic-2/2"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  C[i] = A[i] + B[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(A, B, C)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ci-monk/parallel-programing/code/sum_array_in_parallel/0"}
{"code": "for (j = 0; j < 1000; j++)\n{\n  for (i = 0; i < 1000; i++)\n  {\n    mresult[i][j] = mresult[i][j] + (matrixa[i][k] * matrixb[k][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,i) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Willster419/parallel_computing_uac/PAC2/counters2omp_ww/0"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    arrayX[x] = xe;\n    arrayY[x] = ye;\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(arrayX, arrayY, xe, ye) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/1"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  offspring1[i] = p1[i];\n  offspring2[i] = p2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/3"}
{"code": "for (i = q->head; i < q->tail; i++)\n{\n  v = q->Stack[i];\n  setBitAtomic(b, v);\n}\n\n", "pragma": "omp parallel for default(none) shared(q,b) private(v,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/arrayStack/1"}
{"code": "for (i = 0; i < 1024; i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    for (k = 0; k < 1024; k++)\n    {\n      int slope_coefficient;\n      int linear_coefficient;\n      int ret;\n      ret = 0;\n      slope_coefficient = points[j].y - points[i].y;\n      if ((points[j].x - points[i].x) != 0)\n      {\n        slope_coefficient = slope_coefficient / (points[j].x - points[i].x);\n        linear_coefficient = points[i].y - (points[i].x * slope_coefficient);\n        if (((slope_coefficient != 0) && (linear_coefficient != 0)) && (points[k].y == ((points[k].x * slope_coefficient) + linear_coefficient)))\n        {\n          ret = 1;\n        }\n\n      }\n\n      if (ret == 1)\n      {\n        parallel_lines[i % p] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/collinear-list/src/collinear-list_gpu/0"}
{"code": "for (int i = 0; i < vector_len; i++)\n{\n  printf(\"%d\\n\", result[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmpi_calculate_matrix/src/Dong_ziqi/3"}
{"code": "for (int i = 0; i < k; i++)\n{\n  copy_point(points[i], medoids[i]);\n  copy_point(points[i], best_medoids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/treyvian/Kmeans-with-OpenMP/src/kmedoids/kmedoids/2"}
{"code": "for (int ii = HALO_PAD; ii < (z - HALO_PAD); ++ii)\n{\n  for (int jj = HALO_PAD - depth; jj < HALO_PAD; ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (x - HALO_PAD); ++kk)\n    {\n      int bufIndex = ((kk - HALO_PAD) + ((jj - (HALO_PAD - depth)) * _chunk.innerX)) + (((ii - HALO_PAD) * depth) * _chunk.innerX);\n      field[(((ii * y) * x) + (jj * x)) + kk] = buffer[bufIndex];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_pack_kernel/9"}
{"code": "for (int ii = 0; ii < 10; ++ii)\n{\n  vec[ii] = ii;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fdcl-gwu/openmp_example/src/vector/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  int idx = (c0 * index) + (c1 * i);\n  int slice_idx = i * M;\n  for (int j = 0; j < M; ++j)\n  {\n    raw[idx] = slice[slice_idx];\n    ++slice_idx;\n    idx += c2;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/Grid3D/1"}
{"code": "for (i = 0; i < totalPartitions; ++i)\n{\n  grid->partitions[i].edgeList = newEdgeList(grid->partitions[i].num_edges);\n  grid->partitions[i].edgeList->num_vertices = grid->partitions[i].num_vertices;\n  grid->partitions[i].num_edges = 0;\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(totalPartitions,grid)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/grid/5"}
{"code": "for (int row = 0; row < rowCount; row++)\n{\n  sprintf(s, \"%s\\t\\t\\t\\t\\t\", s);\n  for (int columns = 0; columns < columnCount; columns++)\n  {\n    sprintf(s, \"%s%d\\t\", s, matrix[row][columns]);\n  }\n\n  sprintf(s, \"%s\\n\", s);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Examples/openmp/2"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n  for (int j = 0; j < sizeOfItems; ++j)\n{\n  if (maxInLines[i] != 0)\n    weights[i][j] /= maxInLines[i];\n  else\n  {\n    weights[i][j] = 0;\n  }\n\n}\n\n\n", "pragma": "\t#pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/serial/2"}
{"code": "for (numOfThreads = 1; numOfThreads <= 16; ++numOfThreads)\n{\n  max = MaxSearch(arr, height, length, true);\n  printf(\"%f\\n\", runtime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimamelnik22/OpenMP-tasks/task1test/0"}
{"code": "for (int i = 0; i < M; i++)\n  for (int j = 0; j < K; j++)\n  if (Ht[(i * K) + j] < eps)\n  Ht[(i * K) + j] = eps;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artecs-group/nmf-openmp/src/main/12"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  int bi = normalizeNum * arr[i];\n  buckets[bi].push_back(arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_2_Sorting/cpu_parallel_sort/4"}
{"code": "for (int i = 1; i <= N_a; ++i)\n{\n  for (int j = 1; j <= N_b; ++j)\n  {\n    if (H[i][j] > max.val)\n    {\n      max.val = H[i][j];\n      max.p.row = i;\n      max.p.col = j;\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for reduction(max: max)\t", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/1"}
{"code": "for (i = 1; i <= n; ++i)\n{\n  cur = AtrowIndex[i];\n  AtrowIndex[i] = accumulationRows;\n  accumulationRows += cur;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexanderflegontov/OpenMPAnalyzer/omp_prog/Bicgm/8"}
{"code": "for (i = 0; i < icompact_num_mesh; i++)\n{\n  i_target = MC_compact_ind[i];\n  for (j = 0; j < MC_ind[i_target]; j++)\n  {\n    i_particle = MC[(20 * i_target) + j];\n    for (k = j + 1; k < MC_ind[i_target]; k++)\n    {\n      k_particle = MC[(20 * i_target) + k];\n      inum_collision += CollisionDetect(i_particle, k_particle, X, V, V_old, F);\n    }\n\n    if ((i_target + 1) < imax_num_mesh)\n    {\n      for (k = 0; k < MC_ind[i_target + 1]; k++)\n      {\n        k_particle = MC[(20 * (i_target + 1)) + k];\n        inum_collision += CollisionDetect(i_particle, k_particle, X, V, V_old, F);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i_target,j,i_particle,k_particle,k) reduction(+:inum_collision)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/DEM/C/dem/2"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (getBit(bitmapCurr, v))\n  {\n    degree = graph->vertices[v].out_degree;\n    nodes = graph->vertices[v].outNodes;\n    uint32_t j;\n    for (j = 0; j < degree; j++)\n    {\n      uint32_t u = nodes->dest;\n      uint32_t w = 1;\n      nodes = nodes->next;\n      if (arguments->algo_numThreads == 1)\n        activeVertices += bellmanFordRelax(v, u, w, stats, bitmapNext);\n      else\n        activeVertices += bellmanFordAtomicRelax(v, u, w, stats, bitmapNext);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(nodes,degree,v) shared(graph,stats,bitmapNext,bitmapCurr) reduction(+ : activeVertices) schedule (dynamic,128)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/13"}
{"code": "for (i = 0; i < result->rows; ++i)\n  for (k = 0; k < a->rows; ++k)\n{\n  conjT = conjTN + (row_size * omp_get_thread_num());\n  for (ii = 0; ii < result->rows; ++ii)\n    conjT[ii] = conj(a->data[k][ii]);\n\n  for (j = 0; j < result->cols; ++j)\n  {\n    result->data[i][j] += conjT[i] * b->data[k][j];\n  }\n\n}\n\n\n", "pragma": "omp parallel for private(i, j, k, ii, conjT)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Avbey/sc_modeling_lab/src/m_omp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  r[i] = 1 / sqrt((double) N);\n  v0[i] = (v1[i] = 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/78"}
{"code": "for (int i = 1; i <= mu; i++)\n{\n  double wnum = log(mu + 1) - log(i);\n  double wdem = mu * log(mu + 1);\n  for (int j = 1; j <= mu; j++)\n  {\n    wdem -= log(j);\n  }\n\n  w[i - 1] = wnum / wdem;\n  mueffdem = mueffdem + (w[i - 1] * w[i - 1]);\n}\n\n", "pragma": "    #pragma omp parallel for shared(mu)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souradipp76/Parallel_LSBBO_Algorithm/R1ES_omp_alt/3"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  uint32_t key[1][8];\n  int i;\n  for (i = 0; i < 1; ++i)\n  {\n    pbkdf2_sha256((unsigned char *) saved_key[i + index], strlen(saved_key[i + index]), cur_salt->salt, cur_salt->salt_length, cur_salt->iterations, (unsigned char *) key[i], 32, 0);\n  }\n\n  for (i = 0; i < 1; ++i)\n  {\n    AES_KEY akey;\n    AES_set_encrypt_key((unsigned char *) key[i], 256, &akey);\n    AES_ecb_encrypt((unsigned char *) \"lastpass rocks\\x02\\x02\", (unsigned char *) crypt_out[i + index], &akey, AES_ENCRYPT);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lastpass_fmt_plug/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    *((mat + (i * N)) + j) = 2 + (rand() % 6);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/provaEsame/1"}
{"code": "for (i = 0; i < dims[2][0]; i++)\n{\n  ii = (((((i + 1) + xstart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (256 / 2)) % 256) - (256 / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (128 / 2)) % 128) - (128 / 2);\n      indexmap[k][j][i] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/23"}
{"code": "for (int i = ib * 8; i < ((ib + 1) * 8); i++)\n{\n  for (int k = kb * 8; k < ((kb + 1) * 8); k++)\n  {\n    Awrk[((i % 8) * 8) + (k % 8)] = A[(i * Pdim) + k];\n  }\n\n}\n\n", "pragma": "omp for collapse(2) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tomdeakin/programming-gpu-openmp-book/Source/code_for_book/C/mm_gpu_block_allocate_directive/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = rand() % 10;\n    b[i][j] = rand() % 10;\n    c[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/add19/Parallel-Programming/parallel_matrix/1"}
{"code": "for (int i = 0; i < (256 * PAD); i += PAD)\n{\n  if (hist[i])\n  {\n    double val = (((double) (hist[i] - cumulativeMin)) / ((double) ((height * width) - 1))) * 255.0;\n    normalized[i] = round(val);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/12"}
{"code": "for (int i = 0; i < nov; i += 1)\n{\n  starti = xadj[i];\n  endi = xadj[i + 1];\n  double rsum = 0;\n  for (int j = starti; j < endi; j++)\n  {\n    rsum += 1 * cv[adj[j]];\n  }\n\n  rv[i] = 1 / rsum;\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided) private(starti, endi)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/buraksekili/Sinkhorn-Knopp-scaling/cpu/main/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  T[i] = N - i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mujtabaasif/OpenMP/OpenMP_Lab1/bubble/2"}
{"code": "for (k = 0; k < 3; k++)\n  v[j][k] += (F[j][k] * delta_t) / 2;\n\n", "pragma": "\t\t\t#pragma omp parallel for shared(v,j,delta_t) private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/siddhanthaldar/N-Body-Simulator/manybody-sim-program/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < M; j++)\n  {\n    A[(i * M) + j] = i + j;\n    b[j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Livingwind/CS475-Parallel-Programming/PA1/mat_vec/1"}
{"code": "for (int k = 0; k < 10; ++k)\n{\n  for (int x = 0; x < 10; ++x)\n    foo();\n\n}\n\n", "pragma": "  #pragma omp for lastprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/for_private_messages/5"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  Normal = rGeometry[i].FastGetSolutionStepValue(NORMAL);\n  double NormNormal = norm_2(Normal);\n  if (NormNormal != 0)\n    Normal /= NormNormal;\n\n  Corner = Center - Vertices[i];\n  if (norm_2(Corner))\n    Corner /= norm_2(Corner);\n\n  double projection = inner_prod(Corner, Normal);\n  if (projection > 0)\n  {\n    if (projection < slope)\n    {\n      numouter++;\n    }\n    else\n    {\n      if (projection < extra)\n        numextra++;\n\n    }\n\n  }\n\n  double coplanar = inner_prod(Coplanar, Normal);\n  if (coplanar > 0)\n  {\n    numsamedirection++;\n  }\n\n  if (coplanar > extra)\n  {\n    numcoplanar++;\n  }\n\n  if (fabs(coplanar) <= ortho)\n  {\n    numorthogonal++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/8"}
{"code": "for (int i = 0; i < b_vec.size(); i++)\n{\n  (((cout << b_vec[i].first) << \"  \") << b_vec[i].second) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amy090912/Word-Count-with-MapReduce-and-openMP/lab4b3/5"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  if (i < (10000 / 2))\n  {\n    NofRows[i] = 1;\n  }\n  else\n  {\n    NofRows[i] = 1000;\n  }\n\n  itotal_NOR += NofRows[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/SpMV_IB/C/spmv_ib/0"}
{"code": "for (i = 0; i < n_centroids; i++)\n{\n  new_centroid_x[i] = 0;\n  new_centroid_y[i] = 0;\n  new_centroids_n_points[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Luca-Ferrera/k-means/app_mp_mpi/0"}
{"code": "for (a = 0; a < 2; a++)\n  for (b = 0; b < x; b++)\n  for (c = 0; c < y; c++)\n  data[a][b][c] = 0.0;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MikeAndroulakis/MPI-simulation-program/mpi_openmp/3"}
{"code": "for (i = 0; i < nodeNum; i++)\n  free(matrix[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/polizois/parallel_pageRank/pagerank_gs_omp/6"}
{"code": "for (j = 0; j < N; j++)\n{\n  printf(\" %5.2f,\", y[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/GuassianElimination_Parallell/6"}
{"code": "for (i = low; i <= high; i += multiple)\n{\n  prime[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/4_parallel_sieve/parallel_sieve/0"}
{"code": "for (int j = 0; j < uncropped_dim.y; j++)\n{\n  const uint8_t * const curr_line_end = getDataUncropped(uncropped_dim.x - 1, j) + bpp;\n  PoisonMemoryRegion(curr_line_end, padding);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/common/RawImage/1"}
{"code": "for (i = 0; i < 9; ++i)\n{\n  for (j = 0; j < 9; ++j)\n  {\n    puzzle[8 - i][j] = puzzle[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Blu-J/sudoku-openmp/sudoku/9"}
{"code": "for (int i = 0; i < 100; i++)\n  b[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vladislav-koval/openmp-lab/1-3/1"}
{"code": "for (int i = 0; i < (N + 1); i++)\n{\n  scanf(\"%llu\", &dimensions[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10203/fast_matrix/2"}
{"code": "for (j = 0; j < (nj + 2); j++)\n{\n  i = 0;\n  i2d = i + ((ni + 2) * j);\n  temp1_h[i2d] = temp_bl + (((temp_tl - temp_bl) * ((double) j)) / ((double) (nj + 1)));\n  i = ni + 1;\n  i2d = i + ((ni + 2) * j);\n  temp1_h[i2d] = temp_br + (((temp_tr - temp_br) * ((double) j)) / ((double) (nj + 1)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcarter108/cisc372_proj/heat_omp/3"}
{"code": "for (i = 0; i < 64; i++)\n  s6 += i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/distribute-1/7"}
{"code": "for (int i = 0; i <= nv; i++)\n  visited[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/souravmohapatra/parallel_bfs/bfs_parallel/0"}
{"code": "for (k = 0; k < (3 + 1); k++)\n{\n  matrix[j][k] = matrix[j][k] - (ratio * matrix[i][k]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jasha16/HPC/gaussOMP/1"}
{"code": "for (f = 0; f < TOPEF; f++)\n{\n  n = (rand() % TOPEF) + 1;\n  v[f] = n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/0"}
{"code": "for (i = PosB - 1; i > relmaxpos[1]; --i)\n{\n  MaxA[MaxAcounter] = dash;\n  ++MaxAcounter;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kaserashi/Parallelization-of-Smith-Waterman-Algorithm/parallelcode/7"}
{"code": "for (i = 0; i < N; i += 4)\n{\n  incx = i * incX;\n  incy = i * incY;\n  x = _mm_load_ps(X + incx);\n  y = _mm_load_ps(Y + incy);\n  _mm_store_ps(Y + incy, x);\n  _mm_store_ps(X + incx, y);\n}\n\n", "pragma": "omp for schedule(static) private(incx, incy)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/swap/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  destination[i] = source[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) private(i) shared(source, destination, n) schedule(guided)  ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DhruvSrikanth/N-Body-Simulation/final-version/nbody/0"}
{"code": "for (i = 0; i < 4; ++i)\n  for (j = 0; j < 4; ++j)\n  for (k = 0; k < 4; ++k)\n  printf(\"do %d\\n\", i);\n\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenCMISS-Dependencies/opari2/test/data/test3/5"}
{"code": "for (int i = 0; i <= N; i++)\n  Al[i] = U_[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/103"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    *((b + (i * n)) + j) = rand();\n    *((b1 + (i * n)) + j) = *((b + (i * n)) + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/27"}
{"code": "for (k = 1; k < (nz - 1); k++)\n{\n  for (j = jst; j < jend; j++)\n  {\n    for (i = 0; i < nx; i++)\n    {\n      flux[i][0] = rsd[k][j][i][1];\n      u21 = rsd[k][j][i][1] / rsd[k][j][i][0];\n      q = (0.50 * (((rsd[k][j][i][1] * rsd[k][j][i][1]) + (rsd[k][j][i][2] * rsd[k][j][i][2])) + (rsd[k][j][i][3] * rsd[k][j][i][3]))) / rsd[k][j][i][0];\n      flux[i][1] = (rsd[k][j][i][1] * u21) + (C2 * (rsd[k][j][i][4] - q));\n      flux[i][2] = rsd[k][j][i][2] * u21;\n      flux[i][3] = rsd[k][j][i][3] * u21;\n      flux[i][4] = ((C1 * rsd[k][j][i][4]) - (C2 * q)) * u21;\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (tx2 * (flux[i + 1][m] - flux[i - 1][m]));\n      }\n\n    }\n\n    for (i = ist; i < nx; i++)\n    {\n      tmp = 1.0 / rsd[k][j][i][0];\n      u21i = tmp * rsd[k][j][i][1];\n      u31i = tmp * rsd[k][j][i][2];\n      u41i = tmp * rsd[k][j][i][3];\n      u51i = tmp * rsd[k][j][i][4];\n      tmp = 1.0 / rsd[k][j][i - 1][0];\n      u21im1 = tmp * rsd[k][j][i - 1][1];\n      u31im1 = tmp * rsd[k][j][i - 1][2];\n      u41im1 = tmp * rsd[k][j][i - 1][3];\n      u51im1 = tmp * rsd[k][j][i - 1][4];\n      flux[i][1] = ((4.0 / 3.0) * tx3) * (u21i - u21im1);\n      flux[i][2] = tx3 * (u31i - u31im1);\n      flux[i][3] = tx3 * (u41i - u41im1);\n      flux[i][4] = ((((0.50 * (1.0 - (C1 * C5))) * tx3) * ((((u21i * u21i) + (u31i * u31i)) + (u41i * u41i)) - (((u21im1 * u21im1) + (u31im1 * u31im1)) + (u41im1 * u41im1)))) + (((1.0 / 6.0) * tx3) * ((u21i * u21i) - (u21im1 * u21im1)))) + (((C1 * C5) * tx3) * (u51i - u51im1));\n    }\n\n    for (i = ist; i < iend; i++)\n    {\n      frct[k][j][i][0] = frct[k][j][i][0] + ((dx1 * tx1) * ((rsd[k][j][i - 1][0] - (2.0 * rsd[k][j][i][0])) + rsd[k][j][i + 1][0]));\n      frct[k][j][i][1] = (frct[k][j][i][1] + (((tx3 * C3) * C4) * (flux[i + 1][1] - flux[i][1]))) + ((dx2 * tx1) * ((rsd[k][j][i - 1][1] - (2.0 * rsd[k][j][i][1])) + rsd[k][j][i + 1][1]));\n      frct[k][j][i][2] = (frct[k][j][i][2] + (((tx3 * C3) * C4) * (flux[i + 1][2] - flux[i][2]))) + ((dx3 * tx1) * ((rsd[k][j][i - 1][2] - (2.0 * rsd[k][j][i][2])) + rsd[k][j][i + 1][2]));\n      frct[k][j][i][3] = (frct[k][j][i][3] + (((tx3 * C3) * C4) * (flux[i + 1][3] - flux[i][3]))) + ((dx4 * tx1) * ((rsd[k][j][i - 1][3] - (2.0 * rsd[k][j][i][3])) + rsd[k][j][i + 1][3]));\n      frct[k][j][i][4] = (frct[k][j][i][4] + (((tx3 * C3) * C4) * (flux[i + 1][4] - flux[i][4]))) + ((dx5 * tx1) * ((rsd[k][j][i - 1][4] - (2.0 * rsd[k][j][i][4])) + rsd[k][j][i + 1][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][j][1][m] = frct[k][j][1][m] - (dssp * ((((+5.0) * rsd[k][j][1][m]) - (4.0 * rsd[k][j][2][m])) + rsd[k][j][3][m]));\n      frct[k][j][2][m] = frct[k][j][2][m] - (dssp * (((((-4.0) * rsd[k][j][1][m]) + (6.0 * rsd[k][j][2][m])) - (4.0 * rsd[k][j][3][m])) + rsd[k][j][4][m]));\n    }\n\n    for (i = 3; i < (nx - 3); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[k][j][i][m] = frct[k][j][i][m] - (dssp * ((((rsd[k][j][i - 2][m] - (4.0 * rsd[k][j][i - 1][m])) + (6.0 * rsd[k][j][i][m])) - (4.0 * rsd[k][j][i + 1][m])) + rsd[k][j][i + 2][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      frct[k][j][nx - 3][m] = frct[k][j][nx - 3][m] - (dssp * (((rsd[k][j][nx - 5][m] - (4.0 * rsd[k][j][nx - 4][m])) + (6.0 * rsd[k][j][nx - 3][m])) - (4.0 * rsd[k][j][nx - 2][m])));\n      frct[k][j][nx - 2][m] = frct[k][j][nx - 2][m] - (dssp * ((rsd[k][j][nx - 4][m] - (4.0 * rsd[k][j][nx - 3][m])) + (5.0 * rsd[k][j][nx - 2][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  Ksat[i] = 1e-6 + (((1.0 - 1e-6) * i) / size);\n  psi[i] = (-100.0) + ((101.0 * i) / size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/vanGenuchten-omp/main/1"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  x = i;\n  y = i;\n  y = i + 1;\n}\n\n", "pragma": "omp parallel for private (x,y,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_output_dep2/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (i > 0)\n  {\n    if ((i % ((int) sqrt(n))) == 0)\n    {\n      offset = n * i;\n      counter = offset;\n    }\n    else\n    {\n      offset += sqrt(n);\n      counter = offset;\n    }\n\n  }\n\n  a = 0;\n  for (int j = 0; j < sqrt(n); j++)\n  {\n    for (int k = 0; k < sqrt(n); k++)\n    {\n      matrixRepresentation[i][a] = this->representation.at((j + k) + counter);\n      a++;\n    }\n\n    counter += n - 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shay9000/Genetic-Algorithm-Sudoku-Solver/src/genetic/0"}
{"code": "for (i = 0; i < cube_size; i++)\n{\n  graph_lock[i] = (omp_lock_t *) malloc(cube_size * (sizeof(omp_lock_t)));\n  for (j = 0; j < cube_size; j++)\n  {\n    omp_init_lock(&graph_lock[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/3"}
{"code": "for (i = 0; i < width; i++)\n{\n  Compl z;\n  Compl c;\n  int repeats;\n  double temp;\n  double lengthsq;\n  for (j = 0; j < height; j++)\n  {\n    z.real = 0.0;\n    z.imag = 0.0;\n    c.real = (-2.0) + (((double) i) * (4.0 / ((double) width)));\n    c.imag = (-2.0) + (((double) j) * (4.0 / ((double) height)));\n    repeats = 0;\n    lengthsq = 0.0;\n    while ((repeats < 100000) && (lengthsq < 4.0))\n    {\n      temp = ((z.real * z.real) - (z.imag * z.imag)) + c.real;\n      z.imag = ((2 * z.real) * z.imag) + c.imag;\n      z.real = temp;\n      lengthsq = (z.real * z.real) + (z.imag * z.imag);\n      repeats++;\n    }\n\n    omp_set_lock(&lock);\n    XSetForeground(display, gc, (1024 * 1024) * (repeats % 256));\n    XDrawPoint(display, window, gc, i, j);\n    omp_unset_lock(&lock);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) schedule(dynamic, 2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markdtw/parallel-programming/mandelbrot-set/openmp_dynamic/0"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint(c);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) firstprivate(eps) private(c, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/solutions/mandel_par/0"}
{"code": "for (int k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (int j = x_min; j <= x_max; j++)\n  {\n    vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = ((0.25 * dt) * yarea[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) * (((yvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + yvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_flux_calc/1"}
{"code": "for (i = id; i <= l; i++)\n{\n  cout << ((char) xans[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel/1"}
{"code": "for (size_t ivert = 0; ivert < nverts; ++ivert)\n{\n  m_verts[ivert][0] = m_vertsx_GPU[ivert];\n  m_verts[ivert][1] = m_vertsy_GPU[ivert];\n  m_verts[ivert][2] = m_vertsz_GPU[ivert];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/SurfMeshSmooth/Mesh/4"}
{"code": "for (ant = 0; ant < 4; ant++)\n{\n  singleAntTour(ant);\n  clearAntMask(ant);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n  vector[i] = (rand() % 100) + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kfu218/OpenMP/theme 3/ex10/0"}
{"code": "for (h = (i = 0); i < nclusters; h += width / nclusters, i++)\n{\n  for (j = 0; j < nchannels; j++)\n  {\n    c[i][j] = data[h / width][h % width][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kyeongan/k-means-function/omp/1"}
{"code": "for (p = 0; p < size; p++)\n{\n  fputc(image_red[p], fp);\n  fputc(image_grn[p], fp);\n  fputc(image_blu[p], fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/22"}
{"code": "for (col = 0; col < 95100; col++)\n{\n  dEo1[col] = dEo11[col] * dneto11[col];\n  col = col + 4;\n}\n\n", "pragma": "omp parallel for shared(col)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IshanBorkar/Backpropagation_OpenMP_Project_and_SpagoBI/omp_largeprojectcode_1G/19"}
{"code": "for (unsigned i = 0; i < m_hashNum; i++)\n{\n  size_t normalizedValue = (rol(varSeed, i) ^ hVal) % m_size;\n  unsigned char bit = bitMask[normalizedValue % bitsPerChar];\n  if ((m_filter[normalizedValue / bitsPerChar] & bit) == 0)\n    return false;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcgsc/abyss/vendor/btl_bloomfilter/pythonInterface/BloomFilter_pythonwrapper/5"}
{"code": "for (int i = 0; i < Nparticles; i++)\n{\n  int index = -1;\n  int x;\n  for (x = 0; x < Nparticles; x++)\n  {\n    if (CDF[x] >= u[i])\n    {\n      index = x;\n      break;\n    }\n\n  }\n\n  if (index == (-1))\n  {\n    index = Nparticles - 1;\n  }\n\n  xj[i] = arrayX[index];\n  yj[i] = arrayY[index];\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particlefilter-omp/main/10"}
{"code": "for (int i = 0; i < npts; i++)\n{\n  xmod[i] = i;\n  ymod[i] = (a * xmod[i]) + b;\n  yerr[i] = abs(ymod[i]) * 0.1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ncrump/HPC/sample_posterior_c_omp/1"}
{"code": "for (int i = 0; i < n; ++i)\n  f(a, b, i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/implicit_declare_target_codegen/0"}
{"code": "for (int i = 1; i < (NX + 1); i++)\n{\n  for (int j = 1; j < (NY + 1); j++)\n  {\n    roc_u[i][j] = (((-calc_vel_x(y_axis[j])) * (u_val[i][j] - u_val[i - 1][j])) / DIST_X) - ((VEL_Y * (u_val[i][j] - u_val[i][j - 1])) / DIST_Y);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nmac-dev/parallel-2D-advection/src/advection2D/5"}
{"code": "for (int channel = 0; channel < target_nc; channel++)\n{\n  for (int y = 0; y < target_h; y++)\n  {\n    for (int x = 0; x < target_w; x++)\n    {\n      int id = (x + (y * target_w)) + ((channel * target_w) * target_h);\n      if (boundryPixelArray[id] == BOUNDRY)\n      {\n        if (x < (*boundBoxMinX))\n        {\n          *boundBoxMinX = x;\n        }\n\n        if (x > (*boundBoxMaxX))\n        {\n          *boundBoxMaxX = x;\n        }\n\n        if (y < (*boundBoxMinY))\n        {\n          *boundBoxMinY = y;\n        }\n\n        if (y > (*boundBoxMaxY))\n        {\n          *boundBoxMaxY = y;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/2"}
{"code": "for (size_t i = 0; i < 10240; i++)\n{\n  if (ref[i] != a[i])\n  {\n    printf(\"Bad results :-(((\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fritschnils/tp-parallelisation/tp2/tp2_3_enumeration_sort/8"}
{"code": "for (size_t i = 0; i < rows; i++)\n{\n  fscanf(flist, \"%*d: %d\", &j);\n  while (j != (-1))\n  {\n    matrix[i][j] = 1.0;\n    outdeg[i]++;\n    fscanf(flist, \"%d\", &j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stergion/pagerank_gs/pagerank_gs_omp/4"}
{"code": "for (int i = 0; i < n1; ++i)\n{\n  for (int j = 0; j < n2; j++)\n  {\n    global_w1[i][j] /= NUM_THREADS;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oke-aditya/parallel_neural_networks/openmp_mnist/training_private_nn/2"}
{"code": "for (k = 3; k <= (nz - 4); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/121"}
{"code": "for (index = 0; index < level; ++index)\n{\n  particle_number *= 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chivier/ompfuns/bottom/aos/3"}
{"code": "for (int i = 0; i < half_genes; i += 2)\n{\n  copy(genes[i + half_genes], genes[i]);\n  copy(genes[(i + 1) + half_genes], genes[i + 1]);\n  for (int j = 0; j < (no_points / 2); j++)\n  {\n    int x = genes[i + half_genes][j];\n    int index = 0;\n    while (genes[i + 1][index] != x)\n    {\n      index++;\n    }\n\n    int temp = genes[i + 1][j];\n    genes[i + 1][j] = genes[i + 1][index];\n    genes[i + 1][index] = temp;\n  }\n\n  for (int j = no_points / 2; j < no_points; j++)\n  {\n    int x = genes[(i + 1) + half_genes][j];\n    int index = 0;\n    while (genes[i][index] != x)\n    {\n      index++;\n    }\n\n    int temp = genes[i][j];\n    genes[i][j] = genes[i][index];\n    genes[i][index] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sumasree98/travelling-salesman-genetic-algorithm/tsp_parallel/3"}
{"code": "for (int i = 0; i < NODE; i++)\n{\n  graph[i] = (int *) malloc(NODE * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/actumn/dijkstra-openmp/dijkstra/1"}
{"code": "for (i = rb; i < re; i++)\n  p_g[0][i] = p_g[0][i] + (beta * p_g[iter - j][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/26"}
{"code": "for (i = 0; i < nd; i++)\n{\n  dr[(i * nppadded) + p2] = pos[(i * nppadded) + p1] - pos[(i * nppadded) + p2];\n  d = d + (dr[(i * nppadded) + p2] * dr[(i * nppadded) + p2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/MD/md_openmp/3"}
{"code": "for (int i = 0; i < TAMANHO; i++)\n{\n  a[i] = rand() % 100;\n  b[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/borinvini/ComputacaoParalela/4-soma/SomaLoopConstruct/SomaLoopConstruct/Origem/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  int tid1 = omp_get_thread_num();\n  a[i] = b[i] * c[i];\n  count++;\n  x++;\n  printf(\"tid=%d,a[%d]=%d, count=%d, x=%d\\n\", tid1, i, a[i], count, x);\n}\n\n", "pragma": "omp for schedule(static,5) firstprivate(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bhuvaneswar005/OpenMP/Assignment 4/Code/fptp/1"}
{"code": "for (i = 0; i < ant_num; i++)\n{\n  ants[i].tour_step = 0;\n  memset(ants[i].visited, '\\0', city_num);\n  ants[i].at_city = rand() % city_num;\n  ants[i].visited[ants[i].at_city] = '1';\n  ants[i].tour[0] = ants[i].at_city;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blueskyson/parallel-programming-2021-homework/hw6/h6_problem1/10"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  for (int j = 0; j < 10000; j++)\n  {\n    float sumDist = 0;\n    for (int k = 0; k < 8; k++)\n    {\n      for (int q = 0; q < 10000; q++)\n      {\n        if (ants[k].route[q] == j)\n        {\n          if (ants[k].route[q - 1] == i)\n          {\n            sumDist += ants[k].pathLength;\n          }\n\n          break;\n        }\n\n      }\n\n    }\n\n    if (sumDist != 0)\n      pheromones[i][j] = ((1 - 0.5) * pheromones[i][j]) + (1.0 / sumDist);\n    else\n      pheromones[i][j] = (1 - 0.5) * pheromones[i][j];\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project3/Ant-Colony/2"}
{"code": "for (i = 0; i < numPoints; i++)\n{\n  tid = omp_get_thread_num();\n  threadDiameterOffset = tid * numClusters;\n  for (j = i + 1; j < numPoints; j++)\n  {\n    if (pToCR[i] == pToCR[j])\n    {\n      dist = euclidDistanceForQuality(numDims, points + (i * numDims), points + (j * numDims));\n      if (dist > diametersThreads[threadDiameterOffset + pToCR[i]])\n        diametersThreads[threadDiameterOffset + pToCR[i]] = dist;\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, tid, dist, threadDiameterOffset) shared(diametersThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amitlevy21/kMeans_200055986/kMeans_200055986/quality/1"}
{"code": "for (int i = 0; i < smallImageHeight; i++)\n{\n  for (int j = 0; j < (smallImageWidth * 4); j++)\n  {\n    smallImageMatrix[i][j] = smallImageBuffer[rot];\n    rot++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aksha/Breast-Tumor-Detection/ravicha_ImageSearch/7"}
{"code": "for (i = 1; (i < MAX_ITER) && (((z_r *= z_r) + (z_i *= z_i)) < 4.0); i++)\n{\n  z_r += p_r - z_i;\n  z_i = p_i + work;\n  work = (2.0 * z_r) * z_i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/seiji19761225/mandelbrot/misc/mandelbrot/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  new_img[i] = new_temp[image[i]];\n}\n\n", "pragma": "omp parallel for num_threads(thread_num)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vijay-72/Openmp-Image-Inversion/parallel_code/0"}
{"code": "for (j = nrows; j >= 1; j--)\n{\n  rowstr[j + 1] = rowstr[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/CG/cg/24"}
{"code": "for (i = 1; i < counter_size; i++)\n{\n  count[i] += count[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Jessinra/IF3230-Radix-Sort-OpenMP/src/radix_sort/2"}
{"code": "for (i = 0; i < self->params.max_keys_per_crypt; i++)\n  inbuffer[i].length = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/wpapsk_fmt_plug/1"}
{"code": "for (index = 0; index < count; index += 3)\n{\n  int i;\n  int j;\n  if (keys_changed)\n  {\n    char *k0 = saved_key[index];\n    char *k1 = saved_key[index + 1];\n    char *k2 = saved_key[index + 2];\n    unsigned char digest16[3][16];\n    domino_big_md_3((unsigned char *) k0, strlen(k0), (unsigned char *) k1, strlen(k1), (unsigned char *) k2, strlen(k2), digest16[0], digest16[1], digest16[2]);\n    for (i = 0, j = 6; i < 14; i++, j += 2)\n    {\n      const char *hex2 = hex_table[ARCH_INDEX(digest16[0][i])];\n      digest34[index][j] = hex2[0];\n      digest34[index][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[1][i])];\n      digest34[index + 1][j] = hex2[0];\n      digest34[index + 1][j + 1] = hex2[1];\n      hex2 = hex_table[ARCH_INDEX(digest16[2][i])];\n      digest34[index + 2][j] = hex2[0];\n      digest34[index + 2][j + 1] = hex2[1];\n    }\n\n  }\n\n  if (salt_changed)\n  {\n    digest34[index + 2][0] = (digest34[index + 1][0] = (digest34[index][0] = cur_salt->salt[0]));\n    digest34[index + 2][1] = (digest34[index + 1][1] = (digest34[index][1] = cur_salt->salt[1]));\n    digest34[index + 2][2] = (digest34[index + 1][2] = (digest34[index][2] = cur_salt->salt[2]));\n    digest34[index + 2][3] = (digest34[index + 1][3] = (digest34[index][3] = cur_salt->salt[3]));\n    digest34[index + 2][4] = (digest34[index + 1][4] = (digest34[index][4] = cur_salt->salt[4]));\n    digest34[index + 2][5] = (digest34[index + 1][5] = (digest34[index][5] = '('));\n  }\n\n  domino_big_md_3_34(digest34[index], digest34[index + 1], digest34[index + 2], (unsigned char *) crypt_out[index], (unsigned char *) crypt_out[index + 1], (unsigned char *) crypt_out[index + 2]);\n  for (i = 0; i < 3; i++)\n  {\n    unsigned char buffer[22 + 1] = {0};\n    unsigned char tmp_hash[(22 + 1) + 3] = {0};\n    memcpy(tmp_hash, cur_salt->salt, 5);\n    memcpy(tmp_hash + 5, crypt_out[index + i], 16);\n    domino_encode(tmp_hash, buffer);\n    sprintf((char *) tmp_hash, \"(G%s)\", buffer);\n    pbkdf2_sha1(tmp_hash, 22, cur_salt->salt, 16, cur_salt->iterations, (unsigned char *) crypt_out_real[index + i], 8, 0);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/DOMINOSEC8_fmt_plug/0"}
{"code": "for (int i = 0; i < cast_G->size_; ++i)\n{\n  cast_G->vec_[i] = -2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/112"}
{"code": "for (i = 0; i < 100; i++)\n{\n  for (j = 0; j < 100; j++)\n    a[i][j] += 1;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB095-doall2-taskloop-orig-yes/0"}
{"code": "for (i = kxpi - 1; i < kxpt; i++)\n{\n  koff = nyv * i;\n  for (k = 0; k < ny; k++)\n  {\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      t = g[k1 + koff];\n      g[k1 + koff] = g[k + koff];\n      g[k + koff] = t;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indy; m++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = sct[kmr * j];\n        t = s * g[j2 + koff];\n        g[j2 + koff] = g[j1 + koff] - t;\n        g[j1 + koff] += t;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,koff,s,t)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/19"}
{"code": "for (i = 0; i < 500000; i++)\n{\n  data[i] = i * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phgoff/openmp/forloop22/1"}
{"code": "for (int j = 0; j < nbthreads; j++)\n{\n  for (int i = j * granularity; i < ((j + 1) * granularity); i++)\n  {\n    if (i == (j * granularity))\n    {\n      pr[i + 1] = 0 + arr[i];\n    }\n    else\n    {\n      pr[i + 1] = pr[i] + arr[i];\n    }\n\n    pointer = i;\n    temp[j + 1] = pr[i + 1];\n  }\n\n  index[j + 1] = ((j + 1) * granularity) + 1;\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nkalyanpurr/openMP/prefixsum/prefixsum/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  p[i] = z[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/exercise1/main/main/8"}
{"code": "for (unsigned int i = 1; i < (image->height - 1); ++i)\n{\n  for (unsigned int j = 1; j < (image->width - 1); ++j)\n  {\n    if (image->matrix[i][j].r > maxVal)\n    {\n      maxVal = image->matrix[i][j].r;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for reduction(max:maxVal)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/craciunoiuc/parallel-architectures/OpenMP_version/filters/double-treshold_filter_openMP/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  (cout << arr[i]) << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Onyaxoxo/OpenMP-FEFU-/5/1"}
{"code": "for (wI = 0; wI < BIGN_MATR; wI++)\n{\n  if (scanf(\"%lf\", &aMatr[wI]) != 1)\n  {\n    fprintf(stderr, \"erreur lors de la lecture de la matrice \u00e0 l'indice %d\\n\", wI);\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrb/12"}
{"code": "for (i_imopVar110 = 1; i_imopVar110 < (grid_points[0] - 1); i_imopVar110++)\n{\n  for (k_imopVar112 = 1; k_imopVar112 < (grid_points[2] - 1); k_imopVar112++)\n  {\n    for (m_imopVar113 = 0; m_imopVar113 < 5; m_imopVar113++)\n    {\n      rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] = rhs[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113] - (dssp * (((u[i_imopVar110][j_imopVar111 - 2][k_imopVar112][m_imopVar113] - (4.0 * u[i_imopVar110][j_imopVar111 - 1][k_imopVar112][m_imopVar113])) + (6.0 * u[i_imopVar110][j_imopVar111][k_imopVar112][m_imopVar113])) - (4.0 * u[i_imopVar110][j_imopVar111 + 1][k_imopVar112][m_imopVar113])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/19"}
{"code": "for (i = 0; i < n3all; i++)\n{\n  if ((i % 3) == 0)\n    virial += f[i] * x[i / 3];\n  else\n    if ((i % 3) == 1)\n    virial += f[i] * y[i / 3];\n  else\n    virial += f[i] * z[i / 3];\n\n\n}\n\n", "pragma": "#pragma omp parallel for private(i) default(none) reduction(+:virial)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apawloski/miniMD-omp/thermo/3"}
{"code": "for (int i = 0; i < A_m; i++)\n{\n  for (int j = 0; j < B_n; j++)\n  {\n    for (int k = 0; k < A_n; k++)\n    {\n      (*C)(i, j) += (*A)(i, k) * (*B)(k, j);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for num_threads(numthreads) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/murraycutforth/openMP-matrix-multiplication/matmult/6"}
{"code": "for (i = 0; i < DEV_NUM; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    err = clFlush(command_queue[i][j]);\n    checkError(err, 378);\n    err = clFinish(command_queue[i][j]);\n    checkError(err, 380);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/C/photomosaic/11"}
{"code": "for (j = 0; j < _N; j++)\n{\n  WikCkj = 0.0;\n  for (k = 0; k < _K; k++)\n  {\n    WikCkj += _W[(index_i * _K) + k] * _C[j + (k * _N)];\n  }\n\n  obs_ij = _observation[index_i][j];\n  if (obs_ij != (-1))\n  {\n    yipi[j] = obs_ij - (1 / (1 + exp(-WikCkj)));\n  }\n  else\n  {\n    yipi[j] = (rand() % 2) - (1 / (1 + exp(-WikCkj)));\n  }\n\n  sum += _C[(index_k * _N) + j] * yipi[j];\n}\n\n", "pragma": "\t#pragma omp parallel for private(j,k,WikCkj,yipi) reduction (+:sum)\t", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/afarasat/ParallelSparseMatrixFactorization_OpenMP/solution/6"}
{"code": "for (i = 0; i < strp_sent; i++)\n{\n  MPI_Recv(&cc1, strp_rows * ncols, (MPI_Datatype) 0x4c00080b, -2, -1, 1, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Tommyhillpicker/DistributedMatrixMult/mmult_mpi_omp/3"}
{"code": "for (i = 0; i < P; i++)\n{\n  offset_start[i] = 0;\n  offset_end[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/vertex/3"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    matrix[(i * n) + j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/muniz034/open-mp/src/USING-OPENMP/mxv/1"}
{"code": "for (ant = 0; ant < 4; ant++)\n{\n  antStart[ant] = rand() % 10000;\n  Route[ant][0] = antStart[ant];\n  cityTaken[ant][antStart[ant]] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex7/ant_colony_parallel/5"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Vector %d [\", i);\n  for (j = 0; j < 100000; j++)\n  {\n    printf(\"%d \", bag_of_tasks[i][j]);\n  }\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yukioichida/parallel-programming/openmp_vs_mpi/sort_vector_omp/2"}
{"code": "for (int i = 0; i < n; ++i)\n  m += arr[i];\n\n", "pragma": "omp parallel for reduction(+:m)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucaszm7/IPPD_OpenMP_RPC_RMI_MPI/IPPD_OpenMP/sort/0"}
{"code": "for (i = 0; i < taille; i++)\n{\n  tab[i] = rand() % 20;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LexaHoods/OPENMP/ex6/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  for (j = 0; j < dim; j++)\n  {\n    fscanf(stdin, \"%d \", &A[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigovimieiro/OpenCodes/Programming/Parallel programming/OpenMP/MatrixMultiplication/matrixMult/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  if (type[i] == 1)\n  {\n    int pts[HASHES];\n    for (int j = 0; j < HASHES; ++j)\n    {\n      int addr = 0;\n      int p = primes[j];\n      long long cur = 1;\n      for (int k = s[i].length() - 1; k >= 0; --k)\n      {\n        addr = (addr + (cur * ((s[i][k] - 'a') + 1))) % MOD;\n        cur = (cur * p) % MOD;\n      }\n\n      addr %= SZ;\n      pts[j] = addr;\n    }\n\n    sort(pts, pts + HASHES);\n    for (int j = 0; j < HASHES; ++j)\n    {\n      omp_set_nest_lock(&lck[pts[j]]);\n    }\n\n    for (int j = 0; j < HASHES; ++j)\n    {\n      MARK(pts[j]);\n    }\n\n    for (int j = 0; j < HASHES; ++j)\n    {\n      omp_unset_nest_lock(&lck[pts[j]]);\n    }\n\n  }\n  else\n  {\n    bool found = true;\n    for (int j = 0; j < HASHES; j += 2)\n    {\n      int addr = 0;\n      int p = primes[j];\n      long long cur = 1;\n      for (int k = s[i].length() - 1; k >= 0; --k)\n      {\n        addr = (addr + (cur * ((s[i][k] - 'a') + 1))) % MOD;\n        cur = (cur * p) % MOD;\n      }\n\n      addr %= SZ;\n      if (!SET(addr))\n      {\n        found = false;\n        break;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/likecs/Concurrent-Bloom-Filters/bloom-n-par/2"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner <= rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner <= theta_max))\n  {\n    ph_dens_calc = ((4.0 / 3.0) * hydroElementVolume(hydro_data, i)) * (((((hydro_data->gamma[i] * num_dens_coeff) * hydro_data->temp[i]) * hydro_data->temp[i]) * hydro_data->temp[i]) / ph_weight_adjusted);\n    *(ph_dens + j) = gsl_ran_poisson(rand, ph_dens_calc);\n    ph_tot += *(ph_dens + j);\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mclib/6"}
{"code": "for (i = ini; i < fin; i++)\n  z[i] = x[i] + y[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eisten1996/OpenMP/semana02/eje01/eje01/3"}
{"code": "for (int j = 0; j < 8; ++j)\n{\n  fprintf(stdout, \"-\\n\");\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fengbingchun/CUDA_Test/demo/Simd_Test/funset_openmp/5"}
{"code": "for (j = 0; j < 100; j++)\n{\n  for (i = -200; i < 200; i += 7)\n    a_known_value++;\n\n  for (i = 200; i >= (-200); i -= 7)\n    b_known_value++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq/runtime/test/env/kmp_set_dispatch_buf/0"}
{"code": "for (int i = 1; i <= m_db->color_num(); i++)\n{\n  int this_col = (vertex_numbers + ((col_edge - 1) * m_db->color_num())) + i;\n  Remove_Single_Col(dl, this_col);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wadmes/OpenMPL_based/src/mpl/SimpleMPL/20"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%d \", a2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miaohuihui1995/parallel/omp/ex0/22"}
{"code": "for (i = 0; i < nvtxs; i++)\n{\n  if (nopen == 0)\n  {\n    gk_i32pqInsert(queue, ot[0], 1);\n    nopen++;\n  }\n\n  if ((v = gk_i32pqGetTop(queue)) == (-1))\n  {\n    gk_errexit(SIGERR, \"The priority queue got empty ahead of time [i=%d].\\n\", i);\n  }\n\n  if (perm[v] != (-1))\n  {\n    gk_errexit(SIGERR, \"The perm[%d] has already been set.\\n\", v);\n  }\n\n  perm[v] = i;\n  if (ot[pos[v]] != v)\n  {\n    gk_errexit(SIGERR, \"Something went wrong [ot[pos[%d]]!=%d.\\n\", v, v);\n  }\n\n  if (pos[v] >= nopen)\n  {\n    gk_errexit(SIGERR, \"The position of v is not in open list. pos[%d]=%d is >=%d.\\n\", v, pos[v], nopen);\n  }\n\n  ot[pos[v]] = ot[nopen - 1];\n  pos[ot[nopen - 1]] = pos[v];\n  if (ntodo > nopen)\n  {\n    ot[nopen - 1] = ot[ntodo - 1];\n    pos[ot[ntodo - 1]] = nopen - 1;\n  }\n\n  nopen--;\n  ntodo--;\n  for (j = xadj[v]; j < xadj[v + 1]; j++)\n  {\n    u = adjncy[j];\n    if (perm[u] == (-1))\n    {\n      if (degrees[u] == 0)\n      {\n        ot[pos[u]] = ot[nopen];\n        pos[ot[nopen]] = pos[u];\n        ot[nopen] = u;\n        pos[u] = nopen;\n        nopen++;\n        level[u] = level[v] + 1;\n        gk_i32pqInsert(queue, u, 0);\n      }\n\n      degrees[u]++;\n      switch (type)\n      {\n        case 1:\n          gk_i32pqUpdate(queue, u, (1000 * (i + 1)) + degrees[u]);\n          break;\n\n        case 2:\n          gk_i32pqUpdate(queue, u, degrees[u]);\n          break;\n\n        case 3:\n          wdegrees[u] += i;\n          gk_i32pqUpdate(queue, u, wdegrees[u]);\n          break;\n\n        case 4:\n          ;\n          break;\n\n        case 5:\n          gk_i32pqUpdate(queue, u, -((1000 * level[u]) - degrees[u]));\n          break;\n\n        case 6:\n          gk_i32pqUpdate(queue, u, (i + 1) * degrees[u]);\n          break;\n\n        default:\n          ;\n\n      }\n\n    }\n\n  }\n\n  if (type == 4)\n  {\n    for (j = 0; j < nopen; j++)\n    {\n      u = ot[j];\n      if (perm[u] != (-1))\n      {\n        gk_errexit(SIGERR, \"For i=%d, the open list contains a closed vertex: ot[%zd]=%d, perm[%d]=%d.\\n\", i, j, u, u, perm[u]);\n      }\n\n      sod[u] += degrees[u];\n      if ((i < 1000) || ((i % 25) == 0))\n      {\n        gk_i32pqUpdate(queue, u, sod[u]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lreis2415/SEIMS/seims/src/metis/GKlib/graph/12"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < ((i + r) + 1); j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n  for (j = (n - r) + i; j < n; j++)\n  {\n    sigma[(i * n) + j] = s_min + ((s_max - s_min) * drand48());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/antonisstou/Optimization-of-C-program-by-rearrange-computations-and-parallelization-with-openmp/i_lif1d_omp/2"}
{"code": "for (unsigned i = 0; i < size_h; ++i)\n{\n  float sum = 0;\n  for (unsigned j = 0; j < size_v; ++j)\n  {\n    sum += (myRBM.Vp[j] - dataRBM.Vp[j]) * myRBM.W[i][j];\n  }\n\n  myRBM.biasH[i] += log(q / (1 - q)) - (avg_vis_val * sum);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/14"}
{"code": "for (j = 0; j < n; j++)\n  z[j] = (a[j] + a[j + 1]) * 0.5;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/C\u00f3digos Listas/Lista 3/L3Q7/3"}
{"code": "for (i_imopVarPre93 = ist; i_imopVarPre93 <= iend; i_imopVarPre93++)\n{\n  for (j_imopVarPre94 = jst; j_imopVarPre94 <= jend; j_imopVarPre94++)\n  {\n    for (k_imopVarPre95 = 1; k_imopVarPre95 <= (nz0 - 2); k_imopVarPre95++)\n    {\n      sum0 = sum0 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][0] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][0]);\n      sum1 = sum1 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][1] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][1]);\n      sum2 = sum2 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][2] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][2]);\n      sum3 = sum3 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][3] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][3]);\n      sum4 = sum4 + (v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][4] * v[i_imopVarPre93][j_imopVarPre94][k_imopVarPre95][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/20"}
{"code": "for (i = kxpi - 1; i < kxpt; i++)\n{\n  koff = (3 * nyv) * i;\n  for (k = 0; k < ny; k++)\n  {\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      t1 = g[(3 * k1) + koff];\n      t2 = g[(1 + (3 * k1)) + koff];\n      t3 = g[(2 + (3 * k1)) + koff];\n      g[(3 * k1) + koff] = g[(3 * k) + koff];\n      g[(1 + (3 * k1)) + koff] = g[(1 + (3 * k)) + koff];\n      g[(2 + (3 * k1)) + koff] = g[(2 + (3 * k)) + koff];\n      g[(3 * k) + koff] = t1;\n      g[(1 + (3 * k)) + koff] = t2;\n      g[(2 + (3 * k)) + koff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indy; m++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = conjf(sct[kmr * j]);\n        t1 = s * g[(3 * j2) + koff];\n        t2 = s * g[(1 + (3 * j2)) + koff];\n        t3 = s * g[(2 + (3 * j2)) + koff];\n        g[(3 * j2) + koff] = g[(3 * j1) + koff] - t1;\n        g[(1 + (3 * j2)) + koff] = g[(1 + (3 * j1)) + koff] - t2;\n        g[(2 + (3 * j2)) + koff] = g[(2 + (3 * j1)) + koff] - t3;\n        g[(3 * j1) + koff] += t1;\n        g[(1 + (3 * j1)) + koff] += t2;\n        g[(2 + (3 * j1)) + koff] += t3;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,koff,s,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/24"}
{"code": "for (unsigned short l_tg = 0; l_tg < i_nTgs; l_tg++)\n{\n  o_elLay.timeGroups[l_tg].inner.size = i_nTgElsIn[l_tg];\n  o_elLay.timeGroups[l_tg].send.resize(1);\n  o_elLay.timeGroups[l_tg].send[0].size = i_nTgElsSe[l_tg];\n  o_elLay.timeGroups[l_tg].receive.resize(1);\n  o_elLay.timeGroups[l_tg].receive[0].size = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/mesh/EdgeV/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  ue[k][m] = dtemp[m];\n}\n\n", "pragma": "omp parallel for firstprivate(m ,k ,j ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/29"}
{"code": "for (itr1 = Dynamic_1.begin(); itr1 != Dynamic_1.end(); itr1++)\n{\n  (((cout << itr1->first) << '\\t') << itr1->second) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hassan-Ashfaq/Parallel-Distributed-Algorithms-Designing/Q1/8"}
{"code": "for (i = 0; i < (SIZE * SIZE); i++)\n{\n  int x = i % SIZE;\n  int y = i / SIZE;\n  int val = inp[x][y];\n  if (val > 0)\n    populate_f(x, y, val, forward_map);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shivgarg/sudoku/sudoku/12"}
{"code": "for (int i = 0; i < n_balls; i++)\n{\n  B[i].calc_force(B);\n  B[i].update_vel_half();\n  B[i].update_pos();\n  B[i].update_vel_full();\n}\n\n", "pragma": "\t\t#pragma omp parallel for num_threads(threads) shared(B)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/harsh-99/Parallel_programming/openmp/as_3/many-body-sim-program/5"}
{"code": "for (i = 0; i < 19; i++)\n{\n  printf(\"At thread %d\\n\", omp_get_thread_num());\n  for (j = i + 1; j < 20; j++)\n  {\n    if (a[i] > a[j])\n    {\n      int t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/niyasc/parallal-programming/openmp/sort/1"}
{"code": "for (int ii = 0; ii < g2g_source_len; ++ii)\n{\n  g2g_source[ii] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/10"}
{"code": "for (i = 0; i < num_cells; i++)\n{\n  printf(\"\\tCell %d, Pos(%f,%f), Mov(%f,%f), Choose_mov(%f,%f,%f), Storage: %f, Age: %d\\n\", i, cells[i].pos_row, cells[i].pos_col, cells[i].mov_row, cells[i].mov_col, cells[i].choose_mov[0], cells[i].choose_mov[1], cells[i].choose_mov[2], cells[i].storage, cells[i].age);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HylianPablo/Paralela2020/PRACTICA1 - OPENMP/OpenMP - Version final/backup/9"}
{"code": "for (int i = 0; i < res.Size(); ++i)\n{\n  res[i] /= d;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/vector-and-matrix-operations/parallel_vector/7"}
{"code": "for (i = 1; i < (m - 1); i++)\n  for (j = (i + 1) % 2; j < ((n / 2) - (i % 2)); j++)\n{\n  v = 0.25 * (((black[i - 1][j] + black[i + 1][j]) + black[i][j - ((i + 1) % 2)]) + black[i][j + (i % 2)]);\n  red[i][j] = v;\n}\n\n\n", "pragma": "omp for schedule(OMP_SCHED)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/RedBlack_GaussSeidel/9"}
{"code": "for (int ind1 = 0; ind1 < (N + 2); ind1++)\n{\n  for (int ind2 = 0; ind2 < (N + 2); ind2++)\n  {\n    value = recvarray[(ind2 + (ind1 * (N + 2))) + shift_face];\n    fill_array3d(array3d, N, ind2, 0, ind1, value);\n  }\n\n}\n\n", "pragma": "\t\t\t\t\t#pragma omp parallel for private(value)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/array3d/7"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  weights[x] = weights[x] * exp(likelihood[x]);\n}\n\n", "pragma": "omp parallel for shared(Nparticles, weights, likelihood) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_particlefilter/ex_particle_OPENMP_seq/4"}
{"code": "for (size_t i = 0; i < input_->size(); ++i)\n  output[i] = (*input_)[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/14"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  show(u, w, h);\n  if (i == (iter / 2))\n  {\n    time1_local = omp_get_wtime();\n  }\n\n  evolve(u, w, h);\n  if (i == (iter / 2))\n  {\n    time2_local = omp_get_wtime();\n    elapsed_local = time2_local - time1_local;\n    printf(\"Evolve function time > %f \\n\", elapsed_local);\n  }\n\n  usleep(200000);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdodovic/OpenMP-Multithread-Framework/task3_gameoflife/gameoflife_omp/gameoflife/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = bt * r1;\n      t2 = 0.5 * (r4 + r5);\n      rhs[0][i][j][k] = bt * (r4 - r5);\n      rhs[1][i][j][k] = -r3;\n      rhs[2][i][j][k] = r2;\n      rhs[3][i][j][k] = (-t1) + t2;\n      rhs[4][i][j][k] = t1 + t2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(r1 ,r2 ,r3 ,r4 ,r5 ,t1 ,t2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/41"}
{"code": "for (k = ki1; k < ki2; k++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    phi1[k][i] = C2 * (u[k][jbeg][i][4] - ((0.50 * (((u[k][jbeg][i][1] * u[k][jbeg][i][1]) + (u[k][jbeg][i][2] * u[k][jbeg][i][2])) + (u[k][jbeg][i][3] * u[k][jbeg][i][3]))) / u[k][jbeg][i][0]));\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/pintgr/2"}
{"code": "for (int i = 0; (i < 2) && (scanf(\"%d %u %u\", &N[i][0], &keys[i].key1[0], &keys[i].key2[0]) == 3); i++)\n{\n  local_work_size[i][0] = 1 << 10;\n  dynamic_link_params(&kernel[i], &keys[i], N[i]);\n  has_task[i] = 1;\n  padsum[i] = enqueueCommand(&keys[i], &commandQueue[i], &kernel[i], 1, global_work_size[i], local_work_size[i], group_number[i], N[i], &group_offsets[i], &group_stride_workload[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (!visited[i])\n  {\n    if ((cost[nextnode][i] != 2147483647) && ((mini.mindistance + cost[nextnode][i]) < distance[i]))\n    {\n      distance[i] = mini.mindistance + cost[nextnode][i];\n      predecessor[i] = nextnode;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Akash01010/Dijkstra_OpenMP/dijkstra/1"}
{"code": "for (j = 1; j <= n2; j++)\n{\n  sum = 0.0;\n  for (k = 0; k <= n1; k++)\n  {\n    sum += conn_gpu[(k * n2) + j] * l1[k];\n  }\n\n  l2_gpu[j] = 1.0 / (1.0 + exp(-sum));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/backprop/src/backprop/2"}
{"code": "for (int nbcpu = 1; nbcpu <= maxthreads; nbcpu++)\n{\n  omp_set_num_threads(nbcpu);\n  double t0 = omp_get_wtime();\n  MakeHisto(histo, table, N);\n  double t1 = omp_get_wtime();\n  CheckHisto(histo);\n  ((cout << \"nb cores = \") << nbcpu) << endl;\n  for (int i = 0; i < 10; i++)\n  {\n    histo[i] = 0;\n  }\n\n  ((cout << \"Time spent = \") << (t1 - t0)) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Histogramme/Histo_reduction/1"}
{"code": "for (arg = 0; arg < 10; ++arg)\n  s.s += arg;\n\n", "pragma": "omp parallel for reduction(+ : s)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/tools/clang/test/OpenMP/declare_reduction_messages/0"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      forcing[i][j][k][m] = (-1.0) * forcing[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (m,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/33"}
{"code": "for (j = 1; j <= ((lastcol - firstcol) + 1); j++)\n{\n  p[j] = r[j] + (beta * p[j]);\n}\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/CG/cg/12"}
{"code": "for (i = 0; i < stripSize; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    double suma_parcial = 0;\n    for (k = 0; k < N; k++)\n    {\n      suma_parcial += A[(i * N) + k] * B[(j * N) + k];\n    }\n\n    AB[(i * N) + j] = suma_parcial;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k) nowait", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pastorsin/sistemas-paralelos/entregas/e3/pruebas/5-for/3"}
{"code": "for (i = 1; i <= m; i++)\n  for (j = 1; j <= n; j++)\n{\n  t[i][0] = 10.0;\n  t[i][n + 1] = 140.0;\n  t[0][j] = 20.0;\n  t[m + 1][j] = 100.0;\n}\n\n\n", "pragma": "omp for nowait schedule(static) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ashish10alex/openmp-jacobi/jacobi_parallel_validation/0"}
{"code": "for (int j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    vol_flux_y[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = -vol_flux_y[FTNREF2D(j, 1 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/52"}
{"code": "for (i = ibeg; i <= ifin; i++)\n{\n  iglob = i;\n  for (j = jbeg; j <= jfin; j++)\n  {\n    jglob = j;\n    k = ki1;\n    phi1[i][j] = C2 * (u[i][j][k][4] - ((0.50 * ((pow2(u[i][j][k][1]) + pow2(u[i][j][k][2])) + pow2(u[i][j][k][3]))) / u[i][j][k][0]));\n    k = ki2;\n    phi2[i][j] = C2 * (u[i][j][k][4] - ((0.50 * ((pow2(u[i][j][k][1]) + pow2(u[i][j][k][2])) + pow2(u[i][j][k][3]))) / u[i][j][k][0]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(ibeg ,ifin ,j ,jbeg ,ki1 ,ki2 ,jfin ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/51"}
{"code": "for (i = (-N) / 2; i < 0; i++)\n  kx[i + N] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amarnathpg123/NavierStokes_Solver_MPI_OpenMP/nse3dMpiOpenMp/1"}
{"code": "for (iter = 0; iter < num_iterations; iter++)\n{\n  double elt;\n  elt = timer();\n  int sum = 0;\n  int i;\n  for (i = 0; i < n; i++)\n  {\n    sum += A[i];\n  }\n\n  elt = timer() - elt;\n  avg_elt += elt;\n  assert(sum == (3 * (n / 2)));\n  fprintf(stderr, \"%9.3lf\\n\", elt * 1e3);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/omp/sum_omp/5"}
{"code": "for (i = 0; i < len; i++)\n  a[i] = a[i] + a[0];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/truedepsingleelement-orig-yes/0"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x_px[i], nbins, xmin, xmax, edges);\n  for (ssize_t j = 0; j < nw; ++j)\n  {\n    w_ij = w_px(i, j);\n    values_px(bin, j) += w_ij;\n    variances_px(bin, j) += w_ij * w_ij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/7"}
{"code": "for (int i = 0; i < (dim * dim); i++)\n{\n  if ((i % dim) == 0)\n  {\n    printf(\"\\n\");\n  }\n\n  printf(\": %f\", M[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZdravkoDimitrovArnaudov/PPCTR/p3/src/matmul/3"}
{"code": "for (i3 = 1; i3 <= ((n3 - 1) - 1); i3 += 1)\n{\n  for (i2 = 1; i2 <= ((n2 - 1) - 1); i2 += 1)\n  {\n    for (i1 = 0; i1 <= (n1 - 1); i1 += 1)\n    {\n      u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n      u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 <= ((n1 - 1) - 1); i1 += 1)\n    {\n      r[i3][i2][i1] = ((v[i3][i2][i1] - (a[0] * u[i3][i2][i1])) - (a[2] * ((u2[i1] + u1[i1 - 1]) + u1[i1 + 1]))) - (a[3] * (u2[i1 - 1] + u2[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/21"}
{"code": "for (unsigned i = 0; i < count; ++i)\n{\n  float distanceSquared = (pos.x - pPoints[i].x) * (pos.x - pPoints[i].x);\n  distanceSquared += (pos.y - pPoints[i].y) * (pos.y - pPoints[i].y);\n  distanceSquared += (pos.z - pPoints[i].z) * (pos.z - pPoints[i].z);\n  value = min(value, distanceSquared);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xkrejc70/mit-AVS-project2/parallel_builder/loop_mesh_builder/0"}
{"code": "for (uint64_t i = 0; i < len; i++)\n{\n  if (output[i] != acc)\n  {\n    log_error(\"Wrong result\");\n    return false;\n  }\n\n  acc += input[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/openmp/test_scan_CPU/0"}
{"code": "for (int i = M; i < Nth; i++)\n  Num[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/2"}
{"code": "for (j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    vol_flux_x[FTNREF2D(j, y_max + k, x_max + 5, x_min - 2, y_min - 2)] = vol_flux_x[FTNREF2D(j, y_max - k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/45"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int j = 0; j < 10; ++j)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/1"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  long head = tmpEdgeList[i].head;\n  long tail = tmpEdgeList[i].tail;\n  double weight = tmpEdgeList[i].weight;\n  long Where = edgeListPtr[head] + __sync_fetch_and_add(&added[head], 1);\n  edgeList[Where].head = head;\n  edgeList[Where].tail = tail;\n  edgeList[Where].weight = weight;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/10"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  if (A[i] != 1)\n  {\n    printf(\"Error at A[%d], h = %lf, d = %lf\\n\", i, (double) 1, A[i]);\n    fail = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_loop_trunk/nested_loop/1"}
{"code": "for (int i = 0; i < (c.M1_HEIGHT / chunk); i++)\n{\n  for (int j = 0; j < (c.M2_WIDTH / chunk); j++)\n  {\n    float *temp_result = (float *) calloc(chunk * chunk, sizeof(float));\n    for (int oc = 0; oc < (c.M1_WIDTH / chunk); oc++)\n    {\n      for (int ci = 0; ci < chunk; ci++)\n      {\n        for (int cj = 0; cj < chunk; cj++)\n        {\n          cm1[(ci * chunk) + cj] = m1[((((i * chunk) + ci) * c.M1_WIDTH) + (oc * chunk)) + cj];\n          cm2[(cj * chunk) + ci] = m2[((((oc * chunk) + cj) * c.M2_WIDTH) + (j * chunk)) + ci];\n        }\n\n      }\n\n      for (int ci = 0; ci < chunk; ci++)\n      {\n        for (int cj = 0; cj < chunk; cj++)\n        {\n          for (int ic = 0; ic < chunk; ic++)\n          {\n            temp_result[(ci * chunk) + cj] += cm1[(ci * chunk) + ic] * cm2[(ic * chunk) + cj];\n          }\n\n        }\n\n      }\n\n    }\n\n    for (int ci = 0; ci < chunk; ci++)\n    {\n      for (int cj = 0; cj < chunk; cj++)\n      {\n        result[((((i * chunk) + ci) * c.M2_WIDTH) + (j * chunk)) + cj] = temp_result[(ci * chunk) + cj];\n      }\n\n    }\n\n    free(temp_result);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YJHMITWEB/HPC-on-matrix/general_matrix_multiply/general_matrix_multiply/cpu/0"}
{"code": "for (int c = 0; c < curNeurons; c++)\n{\n  double myError = 0.0;\n  for (int n = 0; n < nextNeurons; n++)\n  {\n    myError += nextWeights[(n * curNeurons) + c] * nextErrors[n];\n  }\n\n  curErrors[c] = myError * NeuronOutputDerivative(curOutputs[c]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/4. Neural networks/nn04/5"}
{"code": "for (i = 0; i < 8; i++)\n{\n  tour_barrier_init(i, &team[i].myrounds);\n  team[i].parity = 0;\n  team[i].sense = (boolean) 1;\n}\n\n", "pragma": "omp parallel for private(i) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/barrier/shannon_tour_on_shark/0"}
{"code": "for (i = 0; i < (1 << 21); i++)\n  prv_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/27"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  result += vector[i] * vector[i];\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dross0/Parallel-Programming-Labs/Lab2/var1/2"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    Dxu[IDX(3, j, k)] = ((((-3.0) * u[IDX(3, j, k)]) + (4.0 * u[IDX(4, j, k)])) - u[IDX(5, j, k)]) * idx_by_2;\n    if (betax[IDX(4, j, k)] > 0.0)\n    {\n      Dxu[IDX(4, j, k)] = ((((-3.0) * u[IDX(4, j, k)]) + (4.0 * u[IDX(5, j, k)])) - u[IDX(6, j, k)]) * idx_by_2;\n    }\n    else\n    {\n      Dxu[IDX(4, j, k)] = ((-u[IDX(3, j, k)]) + u[IDX(5, j, k)]) * idx_by_2;\n    }\n\n    if (betax[IDX(5, j, k)] > 0.0)\n    {\n      Dxu[IDX(5, j, k)] = ((((((-3.0) * u[IDX(4, j, k)]) - (10.0 * u[IDX(5, j, k)])) + (18.0 * u[IDX(6, j, k)])) - (6.0 * u[IDX(7, j, k)])) + u[IDX(8, j, k)]) * idx_by_12;\n    }\n    else\n    {\n      Dxu[IDX(5, j, k)] = ((u[IDX(3, j, k)] - (4.0 * u[IDX(4, j, k)])) + (3.0 * u[IDX(5, j, k)])) * idx_by_2;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/26"}
{"code": "for (n = start + 1; n <= end; ++n)\n{\n  for (i = 0; i < size; ++i)\n  {\n    for (j = 0; j < size; ++j)\n    {\n      float acc = 0;\n      for (k = 0; k < size; ++k)\n      {\n        acc = acc + (Y[n - 1][i][k] * X[n][k][j]);\n      }\n\n      Y[n][i][j] = acc;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joshtburris/CS-475-PA2/MMScan/1"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  vector_b[i] = (1 + (i % 1024)) / 2.0;\n  for (j = 0; j < SIZE; j++)\n  {\n    matrix_a[i][j] = (1 + ((i * j) % 1024)) / 2.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/magiciiboy/openmp-matmul/Inner Product (Matrix-Vector Multiplication)/Both/matVecMul_both_simple/2"}
{"code": "for (int i = 0; i < 1600; i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/farit2000/OpenMP_tests/tasks/8/0"}
{"code": "for (int row = 0; row < row_len; row++)\n{\n  int ans = test_data[row].back();\n  test_data[row].pop_back();\n  float pred = predict(test_data[row]);\n  if ((ans * pred) > 0)\n  {\n    correct += 1.0;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static) reduction (+:correct)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/L1FE0FJ4Y/Parallel_Ensemble_Classifier/svm/4"}
{"code": "for (int i = 1; i < (nxn - 1); i++)\n  for (int j = 1; j < (nyn - 1); j++)\n{\n  imageX[i][j][nzn - 2] = vectorX.get(i, j, nzn - 2);\n  imageY[i][j][nzn - 2] = vectorY.get(i, j, nzn - 2);\n  imageZ[i][j][nzn - 2] = vectorZ.get(i, j, nzn - 2) - ((((Ez[i][j][nzn - 2] - (susxz[i][j] * vectorX.get(i, j, nzn - 2))) - (susyz[i][j] * vectorY.get(i, j, nzn - 2))) - (((Jzh[i][j][nzn - 2] * dt) * th) * FourPI)) / suszz[i][j]);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/98"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = nx - noff;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = ny - moff;\n  mm = (my < mm) ? (my) : (mm);\n  edgelx = noff;\n  edgerx = noff + nn;\n  edgely = moff;\n  edgery = moff + mm;\n  ih = 0;\n  nh = 0;\n  nn += 1;\n  mm += 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[4 * (i + (lxv * j))] = fxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[1 + (4 * (i + (lxv * j)))] = fxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[2 + (4 * (i + (lxv * j)))] = fxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[4 * (i + (lxv * j))] = bxy[4 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[1 + (4 * (i + (lxv * j)))] = bxy[1 + (4 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[2 + (4 * (i + (lxv * j)))] = bxy[2 + (4 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      nn = x;\n      mm = y;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      n[j] = 4 * ((nn - noff) + (lxv * (mm - moff)));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      s1[j] = amx * amy;\n      s1[j + 32] = dxp * amy;\n      s1[j + (2 * 32)] = amx * dyp;\n      s1[j + (3 * 32)] = dxp * dyp;\n      t[j] = x;\n      t[j + 32] = y;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      nn = n[j];\n      mm = nn + (4 * (lxv - 2));\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      #pragma ivdep\n      for (i = 0; i < 4; i++)\n      {\n        if (i > 1)\n          nn = mm;\n\n        dx += sfxy[(4 * i) + nn] * s1[j + (32 * i)];\n        dy += sfxy[(1 + (4 * i)) + nn] * s1[j + (32 * i)];\n        dz += sfxy[(2 + (4 * i)) + nn] * s1[j + (32 * i)];\n        ox += sbxy[(4 * i) + nn] * s1[j + (32 * i)];\n        oy += sbxy[(1 + (4 * i)) + nn] * s1[j + (32 * i)];\n        oz += sbxy[(2 + (4 * i)) + nn] * s1[j + (32 * i)];\n      }\n\n      s1[j] = dx;\n      s1[j + 32] = dy;\n      s1[j + (2 * 32)] = dz;\n      s2[j] = ox;\n      s2[j + 32] = oy;\n      s2[j + (2 * 32)] = oz;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      dx = qtmh * s1[j];\n      dy = qtmh * s1[j + 32];\n      dz = qtmh * s1[j + (2 * 32)];\n      acx = ppart[((j + joff) + (2 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (3 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (4 * nppmx)) + npoff] + dz;\n      sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n      omxt = qtmh * s2[j];\n      omyt = qtmh * s2[j + 32];\n      omzt = qtmh * s2[j + (2 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      s1[j] = x + (vx * dtc);\n      s1[j + 32] = y + (vy * dtc);\n      s2[j] = vx;\n      s2[j + 32] = vy;\n      s2[j + (2 * 32)] = vz;\n    }\n\n    #pragma novector\n    for (j = 0; j < 32; j++)\n    {\n      dx = s1[j];\n      dy = s1[j + 32];\n      mm = 0;\n      if (dx >= edgerx)\n      {\n        if (dx >= anx)\n          dx -= anx;\n\n        mm = 2;\n      }\n      else\n        if (dx < edgelx)\n      {\n        if (dx < 0.0f)\n        {\n          dx += anx;\n          if (dx < anx)\n            mm = 1;\n          else\n            dx = 0.0;\n\n        }\n        else\n        {\n          mm = 1;\n        }\n\n      }\n\n\n      if (dy >= edgery)\n      {\n        if (dy >= any)\n          dy -= any;\n\n        mm += 6;\n      }\n      else\n        if (dy < edgely)\n      {\n        if (dy < 0.0)\n        {\n          dy += any;\n          if (dy < any)\n            mm += 3;\n          else\n            dy = 0.0;\n\n        }\n        else\n        {\n          mm += 3;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = s2[j];\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = s2[j + 32];\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = s2[j + (2 * 32)];\n      if (mm > 0)\n      {\n        ncl[(mm + (8 * k)) - 1] += 1;\n        ih += 1;\n        if (ih <= ntmax)\n        {\n          ihole[2 * (ih + ((ntmax + 1) * k))] = (j + joff) + 1;\n          ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n        }\n        else\n        {\n          nh = 1;\n        }\n\n      }\n\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (lxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * lxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * lxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    mm = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        dx -= anx;\n\n      mm = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0f)\n      {\n        dx += anx;\n        if (dx < anx)\n          mm = 1;\n        else\n          dx = 0.0;\n\n      }\n      else\n      {\n        mm = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        dy -= any;\n\n      mm += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          mm += 3;\n        else\n          dy = 0.0;\n\n      }\n      else\n      {\n        mm += 3;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n    if (mm > 0)\n    {\n      ncl[(mm + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = mm;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  sum2 += sum1;\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,noff,moff,npp,npoff,ipp,joff,nps,nn,mm,nm,ih,nh,x,y, vx,vy,vz,dxp,dyp,amx,amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt, omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9,edgelx,edgely, edgerx,edgery,sum1,sfxy,sbxy,n,s1,s2,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/7"}
{"code": "for (i = 0; i < hydro_data->num_elements; i++)\n{\n  hydroCoordinateToSpherical(&r_grid_innercorner, &theta_grid_innercorner, fabs(hydro_data->r0[i]) - (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) - (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) - (0.5 * hydro_data->r2_size[i]));\n  hydroCoordinateToSpherical(&r_grid_outercorner, &theta_grid_outercorner, fabs(hydro_data->r0[i]) + (0.5 * hydro_data->r0_size[i]), fabs(hydro_data->r1[i]) + (0.5 * hydro_data->r1_size[i]), fabs(hydro_data->r2[i]) + (0.5 * hydro_data->r2_size[i]));\n  if ((((rmin <= r_grid_outercorner) && (r_grid_innercorner < rmax)) && (theta_grid_outercorner >= theta_min)) && (theta_grid_innercorner < theta_max))\n  {\n    el_dens = hydro_data->dens[i] / M_P;\n    b_field = calcB(el_dens, hydro_data->temp[i]);\n    nu_c = calcCyclotronFreq(b_field);\n    dimlesstheta = calcDimlessTheta(hydro_data->temp[i]);\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      fr_dum = nu_c;\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = gsl_rng_uniform(rand) * M_PI;\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      hydroVectorToCartesian(boost, hydro_data->v0[i], hydro_data->v1[i], hydro_data->v2[i], hydro_data->r0[i], hydro_data->r1[i], hydro_data->r2[i]);\n      *(boost + 0) *= -1;\n      *(boost + 1) *= -1;\n      *(boost + 2) *= -1;\n      lorentzBoost(boost, p_comv, l_boost, 'p', fPtr);\n      idx = *((null_ph_indexes + count_null_indexes) - 1);\n      (*ph_orig)[idx].p0 = *(l_boost + 0);\n      (*ph_orig)[idx].p1 = *(l_boost + 1);\n      (*ph_orig)[idx].p2 = *(l_boost + 2);\n      (*ph_orig)[idx].p3 = *(l_boost + 3);\n      (*ph_orig)[idx].comv_p0 = *(p_comv + 0);\n      (*ph_orig)[idx].comv_p1 = *(p_comv + 1);\n      (*ph_orig)[idx].comv_p2 = *(p_comv + 2);\n      (*ph_orig)[idx].comv_p3 = *(p_comv + 3);\n      hydroCoordinateToMcratCoordinate(&cartesian_position_rand_array, hydro_data->r0[i], hydro_data->r1[i], hydro_data->r2[i]);\n      (*ph_orig)[idx].r0 = cartesian_position_rand_array[0];\n      (*ph_orig)[idx].r1 = cartesian_position_rand_array[1];\n      (*ph_orig)[idx].r2 = cartesian_position_rand_array[2];\n      (*ph_orig)[idx].s0 = 1;\n      (*ph_orig)[idx].s1 = 0;\n      (*ph_orig)[idx].s2 = 0;\n      (*ph_orig)[idx].s3 = 0;\n      (*ph_orig)[idx].num_scatt = 0;\n      (*ph_orig)[idx].weight = ph_weight_adjusted;\n      (*ph_orig)[idx].nearest_block_index = 0;\n      (*ph_orig)[idx].type = CS_POOL_PHOTON;\n      ph_tot++;\n      count_null_indexes--;\n      if ((count_null_indexes == 0) || (ph_tot == null_ph_count))\n      {\n        i = hydro_data->num_elements;\n      }\n\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mc_cyclosynch/16"}
{"code": "for (ii = 0; ii < (max_1d_pts * num_omp_threads); ii++)\n{\n  za_x_off_diag[ii] = (-z_alpha_reduced) * z_alpha_x_contrib;\n  za_y_off_diag[ii] = (-z_alpha_reduced) * z_alpha_y_contrib;\n  za_z_off_diag[ii] = (-z_alpha_reduced) * z_alpha_z_contrib;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-richards/HPC_Code/3d_hybrid/12"}
{"code": "for (i = 0; i < threadCount; i++)\n{\n  _patchI[i] = (i == 0) ? ((float *) buffer) : (_Iy[i - 1] + patchLen);\n  _patchJ[i] = _patchI[i] + srcPatchLen;\n  _Ix[i] = _patchJ[i] + patchLen;\n  _Iy[i] = _Ix[i] + patchLen;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/3"}
{"code": "for (i = 0; i < count; i++)\n{\n  for (j = 0; j < rows; j++)\n    data[i][j] -= mean[j];\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/akuldr67/OpenMP-CovarianceMatrix/cov/2"}
{"code": "for (size_t i = 0; i < txt.length(); i++)\n{\n  hashs_t[i] = ((txt[i] - 'a') + 1) * pPower[i];\n  if (i)\n    hashs_t[i] += hashs_t[i - 1];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mserebryaakov/study-parallel-programming/Lab3-OpenMP/1"}
{"code": "for (i = 1000; i <= max; i += 1000)\n{\n  stime = serial(primes, i);\n  reset(primes, i);\n  mptime = mp(primes, i, max_procs);\n  reset(primes, i);\n  fprintf(plot, \"%d %lf\\n\", i, stime / mptime);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/sieve/1"}
{"code": "for (i = 1; i < 20000; i++)\n  printf(\"%d - %d    %d \\n\", from[i], i, graph[i][from[i]]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Parth-31/Parallel-Prims-Algorithm-using-OpenMP/Code/primspar/2"}
{"code": "for (int i = 0; i < rows; i++)\n  for (int j = 0; j < cols; j++)\n  Mat[(i * cols) + j] = 1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/mpi/matrixMulti/gemm/0"}
{"code": "for (i = 0; i < t; i++)\n{\n  if (gofor || goreturn)\n  {\n    gofor = 0;\n    continue;\n  }\n\n  if ((i >= residue) && (delta == 0))\n  {\n    continue;\n  }\n  else\n    if (i < residue)\n  {\n    local_l = i * (delta + 1);\n    local_u = (local_l + delta) + 1;\n  }\n  else\n    if ((i >= residue) && (delta > 0))\n  {\n    local_l = (i * delta) + residue;\n    local_u = local_l + delta;\n  }\n\n\n\n  p1 = (void *) (((const char *) base) + ((global_l + local_l) * size));\n  comp1 = (*compar)(key, p1);\n  p2 = (void *) (((const char *) base) + (((global_l + local_u) - 1) * size));\n  comp2 = (*compar)(key, p2);\n  if (comp1 == 0)\n  {\n    p = p1;\n    goreturn = 1;\n  }\n  else\n    if ((comp1 > 0) && (comp2 <= 0))\n  {\n    global_u = global_l + local_u;\n    global_l = global_l + local_l;\n    gofor = 1;\n  }\n\n\n  np = omp_get_thread_num();\n}\n\n", "pragma": "omp parallel for private(np,i,local_l,local_u,p1,p2,comp1,comp2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kylexu1005/Parallel-Binary-Search/pbsearch/0"}
{"code": "for (size_t i = 0; i < size; i++)\n{\n  sum_val += x[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidmallasen/Hello_OpenMP/ParallelSum/sum/0"}
{"code": "for (int i = offset; i < (offset + num_samples_per_mat[m]); i++)\n{\n  double E = SD.p_energy_samples[i];\n  int mat = SD.mat_samples[i];\n  double macro_xs_vector[4] = {0};\n  calculate_macro_xs(macro_xs_vector, mat, E, in, SD);\n  double max = -DBL_MAX;\n  int max_idx = 0;\n  for (int j = 0; j < 4; j++)\n  {\n    if (macro_xs_vector[j] > max)\n    {\n      max = macro_xs_vector[j];\n      max_idx = j;\n    }\n\n  }\n\n  verification += max_idx + 1;\n}\n\n", "pragma": "omp parallel for schedule(dynamic,100) reduction(+:verification)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/3"}
{"code": "for (int i = 0; i < sec; i++)\n{\n  ((cout << \"Section \") << (i + 1)) << endl;\n  for (j = 0; j < items; j++)\n  {\n    cin >> allitems[(i * items) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/prgm2/0"}
{"code": "for (unsigned i = 0; i < num_h_neurons; ++i)\n{\n  myRBM.W.at(i).resize(num_v_neurons);\n  myRBM.dW.at(i).resize(num_v_neurons);\n  myRBM.dW_last.at(i).resize(num_v_neurons);\n  for (unsigned j = 0; j < num_v_neurons; ++j)\n  {\n    float start_weight = distribution(generator);\n    norm += start_weight;\n    myRBM.W.at(i).at(j) = start_weight;\n    myRBM.dW.at(i).at(j) = 0;\n    myRBM.dW_last.at(i).at(j) = 0;\n    if (i == num_h_neurons)\n    {\n    }\n\n    if (j == num_v_neurons)\n    {\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jbalma/BoltzmannBaby/DeepNet/0"}
{"code": "for (uint32_t i = 0; i < nPoints; i++)\n{\n  double xPart = pointX[i] - 0.5;\n  xPart = xPart * xPart;\n  double yPart = pointY[i] - 0.5;\n  yPart = yPart * yPart;\n  double xyDependentPart = xPart + yPart;\n  result[i] = 1 - xyDependentPart;\n}\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/CUDA-OpenMP_Gaussian_Process_Regression_With_Hyper_Parameters/Stage2AllTogether/1"}
{"code": "for (i = 1; i < (N - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    x_tmp[i][j] = ((((x[i - 1][j] + x[i + 1][j]) + x[i][j - 1]) + x[i][j + 1]) + ((delta * delta) * b[i][j])) * 0.25;\n    d += (x_tmp[i][j] * x_tmp[i][j]) - (x[i][j] * x[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j) reduction(+:d)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlievin/HPC-Assignement2-OpenMP/jacobi/0"}
{"code": "for (int i = 0; i <= K; i++)\n{\n  gY[i] = g(Y[i]);\n  gYg[i] = pow(gY[i], -gamma);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/62"}
{"code": "for (i = 1; i < n; i++)\n  A[i] = &A[0][i * n];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Backward-Substitution/parallel/2"}
{"code": "for (int l = 0; l < 100; l++)\n{\n  for (int i = 0; i < 100; i++)\n  {\n    A = CreateArray(temp);\n    start = omp_get_wtime();\n    shellSortSequential(A, length);\n    end = omp_get_wtime();\n    instanceTotal = end - start;\n    total += instanceTotal;\n  }\n\n  ntotal = total / 100;\n  newtotal += ntotal;\n  newtotal = newtotal / 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Matt-st/Parallel_shell_sort/ShellOpenMP/0"}
{"code": "for (int shift = 0; shift < Size; shift++)\n{\n  float sum = 0.;\n  for (int i = 0; i < Size; i++)\n  {\n    sum += A[i] * A[i + shift];\n  }\n\n  if (((shift >= 1) && (shift <= 512)) && (j == 0))\n  {\n    Sums[shift] = sum;\n    printf(\"Shift Number: %d\\tSum: %5.2lf\\n\", shift, sum);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WSchiller/Signal_Autocorrelation/OpenMP/OpenMP/0"}
{"code": "for (int i = 1; i < (bsize / tr_num); i++)\n{\n  for (int j = 1; j < (tr_num + 1); j++)\n  {\n    BP(find(BP == ((i * tr_num) + j))).fill(j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/2"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  a += i;\n}\n\n", "pragma": "omp parallel for reduction(+:a)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/nested_par3/nested_par3/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = 4 * (ie / 4); i < ie; i++)\n    {\n      int pp = IDX(i, j, k);\n      DzDzu[pp] = (((((-u[pp - (2 * n)]) + (16.0 * u[pp - n])) - (30.0 * u[pp])) + (16.0 * u[pp + n])) - u[pp + (2 * n)]) * idz_sqrd_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/21"}
{"code": "for (int i = 0; i < Num_calc; i++)\n  gemv(i % num_devices, N, 1.0f, manyA[i], manyV[i], manyVout[i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ye-luo/openmp-target/hands-on/gemv/54-gemv-omp-target-many-matrices-multi-devices/gemv-omp-target-many-matrices-multi-devices/0"}
{"code": "for (int i = 0; i < ((int) check.size()); ++i)\n{\n  check[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/OpenMPHW/parallel/main/4"}
{"code": "for (int i = 0; i < ((int) genePool.size()); i++)\n{\n  prFitness = cFitness;\n  cFitness += genePool.at(i).fitness;\n  for (double j = ((double) prFitness) / ratio; j < (((double) cFitness) / ratio); j++)\n  {\n    rouletteWheel.push_back(i);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shay9000/Genetic-Algorithm-Sudoku-Solver/src/genetic/9"}
{"code": "for (i = 0; i < lines; i++)\n{\n  realCoord = positiveReal;\n  for (j = 0; j < columns; j++)\n  {\n    iterations = 0;\n    realTemp = realCoord;\n    imagTemp = imagCoord;\n    arg = (realCoord * realCoord) + (imagCoord * imagCoord);\n    while ((arg < 4) && (iterations < 40))\n    {\n      realTemp2 = ((realTemp * realTemp) - (imagTemp * imagTemp)) - realCoord;\n      imagTemp = ((2 * realTemp) * imagTemp) - imagCoord;\n      realTemp = realTemp2;\n      arg = (realTemp * realTemp) + (imagTemp * imagTemp);\n      iterations += 1;\n    }\n\n    if (drawToConsole)\n    {\n      switch (iterations % 4)\n      {\n        case 0:\n          image[(i * columns) + j] = '.';\n          break;\n\n        case 1:\n          image[(i * columns) + j] = 'o';\n          break;\n\n        case 2:\n          image[(i * columns) + j] = '0';\n          break;\n\n        case 3:\n          image[(i * columns) + j] = '@';\n          break;\n\n      }\n\n    }\n\n    realCoord = positiveReal - ((j + 1) * realStep);\n  }\n\n  imagCoord = positiveImaginary - ((i + 1) * imaginaryStep);\n}\n\n", "pragma": "        #pragma omp parallel for private(i,j,realCoord,imagCoord,realTemp,imagTemp,realTemp2,arg,iterations) ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pterolex/MandelbrotConsole/mandelbrot_openmp/0"}
{"code": "for (i = 1; i < (1 << 23); i++)\n  if (key_array[i - 1] > key_array[i])\n  j++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/34"}
{"code": "for (i = lb; i < ub; i += stride)\n{\n  printf(\" %02d : team %02d of %02d teams : thread %03d of %03d threads NO_ORDER\\n\", i, omp_get_team_num(), omp_get_num_teams(), omp_get_thread_num(), omp_get_num_threads());\n  output[(i - lb) / stride] = omp_get_wtime();\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/schedule/schedule/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (dssp * (((((-4.0) * u[k - 1][j][i][m]) + (6.0 * u[k][j][i][m])) - (4.0 * u[k + 1][j][i][m])) + u[k + 2][j][i][m]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/BT/rhs/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  cout << i;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiuwenhui/openmp_examples/example1/for/openmpfor/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  v1[i] = i;\n  v2[i] = 0;\n  for (j = 0; j < N; j++)\n    m[i][j] = i + j;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P2/10/pvm-OpenMP-reduction/1"}
{"code": "for (int r = 0; r < SIZE; r++)\n  matrixB[r] = (int *) malloc(SIZE * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nehabhoi/openMP/openmp/5"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    weights[x] = weights[x] * exp(likelihood[x]);\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(Nparticles, weights, likelihood) private(x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/4"}
{"code": "for (i = 0; i < 100; i++)\n  x[i] = i / 3;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Sobika2531/Parallel-Programming-Laboratory/OpenMP/atomic/1"}
{"code": "for (iel = 0; iel < nelt; iel++)\n{\n  r_init(tmult[iel][0][0], NXYZ, 1.0);\n  for (iface = 0; iface < NSIDES; iface++)\n  {\n    facev(tmult[iel], iface, 0.0);\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/3"}
{"code": "for (int i = 0; i < size(); i++)\n{\n  data()[i] = vec1.data()[i] - vec2.data()[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_sub_d/3"}
{"code": "for (i = 0; i < num_rows; i++)\n  if (CF_marker_x[i] == fpt)\n  y_data[i] *= beta;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/csr_matvec/12"}
{"code": "for (i = 0; i < max_array_num; i++)\n{\n  tc = max_array[i].col;\n  tr = max_array[i].row;\n  end = tc;\n  tmp = -1;\n  cnt = 0;\n  while (tmp != 0)\n  {\n    performance->total_traceback_steps++;\n    if ((array[tr - 1][tc - 1] >= array[tr][tc - 1]) && (array[tr - 1][tc - 1] >= array[tr - 1][tc]))\n    {\n      tmp = array[tr - 1][tc - 1];\n      t1[0] = q[tr - 1];\n      t1[1] = '\\0';\n      t2[0] = d[tc - 1];\n      t2[1] = '\\0';\n      tc = tc - 1;\n      tr = tr - 1;\n      cnt++;\n    }\n    else\n      if ((array[tr][tc - 1] >= array[tr - 1][tc - 1]) && (array[tr][tc - 1] >= array[tr - 1][tc]))\n    {\n      tmp = array[tr][tc - 1];\n      t1[0] = '-';\n      t1[1] = '\\0';\n      t2[0] = d[tc - 1];\n      t2[1] = '\\0';\n      tc = tc - 1;\n      tr = tr;\n      cnt++;\n    }\n    else\n      if ((array[tr - 1][tc] >= array[tr - 1][tc - 1]) && (array[tr - 1][tc] >= array[tr][tc - 1]))\n    {\n      tmp = array[tr - 1][tc];\n      t1[0] = q[tr - 1];\n      t1[1] = '\\0';\n      t2[0] = '-';\n      t2[1] = '\\0';\n      tc = tc;\n      tr = tr - 1;\n      cnt++;\n    }\n\n\n\n    s1_t = (char *) realloc(s1, (sizeof(char)) * (strlen(t1) + cnt));\n    s1 = s1_t;\n    s2_t = (char *) realloc(s2, (sizeof(char)) * (strlen(t2) + cnt));\n    s2 = s2_t;\n    if (cnt == 1)\n    {\n      strcpy(s1, t1);\n      strcpy(s2, t2);\n    }\n    else\n    {\n      strcat(s1, t1);\n      strcat(s2, t2);\n    }\n\n    start = tc;\n  }\n\n  sequence_array[i].end = end;\n  sequence_array[i].start = start;\n  sequence_array[i].score = max_array[0].num;\n  sequence_array[i].count = max_array_num;\n  sequence_array[i].s1 = (char *) malloc((strlen(s1) + 1) * (sizeof(char)));\n  strcpy(sequence_array[i].s1, s1);\n  reverse(sequence_array[i].s1);\n  sequence_array[i].s2 = (char *) malloc((strlen(s2) + 1) * (sizeof(char)));\n  strcpy(sequence_array[i].s2, s2);\n  reverse(sequence_array[i].s2);\n  free(s1);\n  free(s2);\n  s1 = 0;\n  s2 = 0;\n  s1_t = 0;\n  s2_t = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kkasfikis/Smith-Waterman-/myProj_OMP_FG/8"}
{"code": "for (i = 0; i < nBags; i++)\n{\n  if (fscanf(file, \"%d %d\", &bagCoords[i].x, &bagCoords[i].y) != 2)\n  {\n    printf(\"Error: missing or invalid definition of coordinate %d.\\n\", i);\n    exit(-1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jtkarlsen/parallel-traveling-salesman/RaceTrap/RaceTrap/0"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < cols; j++)\n  {\n    fscanf(f, \"%f\", &mat[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/25"}
{"code": "for (part = 0; part < n; part++)\n{\n  scanf(\"%lf\", &curr[part].m);\n  scanf(\"%lf\", &curr[part].s[0]);\n  scanf(\"%lf\", &curr[part].s[1]);\n  scanf(\"%lf\", &curr[part].v[0]);\n  scanf(\"%lf\", &curr[part].v[1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch6/omp_nbody_basic/3"}
{"code": "for (i = 0; i < r1; ++i)\n  for (j = 0; j < c2; ++j)\n{\n  result[i][j] = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/irajeshegde/OMP-Programs/LA/p6/3"}
{"code": "for (int i = 0; i < Len; i++)\n{\n  Vec[i] = Rnd.GetUniDev();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/35"}
{"code": "for (i = 0; i < SIZE; i++)\n  for (j = 0; j < SIZE; j++)\n  random[i][j] = (rand() % range) + (i * j);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/Matrix-inverse-LUP/inverse_non_parallelized/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  frct[i][j][k][m] = frct[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (tz2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/47"}
{"code": "for (int i = 0; i < nrOfIds; i++)\n{\n  for (int j = 0; j < nrOfPhotosPerId; j++)\n  {\n    for (int e = 0; e < histogramSize; e++)\n    {\n      training_set[i][j][e] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AlbaMustafaj/Parallel-Computing-Projetcs/Project 3-Parallel Face Recognition/lbp_omp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\" thread %d suma a[%d]=%d suma=%d \\n\", omp_get_thread_num(), i, a[i], suma);\n}\n\n", "pragma": "omp parallel for firstprivate(suma) lastprivate(suma) schedule(dynamic,chunk)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/2/scheduled-clause/0"}
{"code": "for (int i = 0; i < numDimensions; i++)\n{\n  position[i] = p[i];\n  velocity[i] = v[i];\n  acceleration[i] = a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Dynamique_Moleculaire/DynMol_parallel/0"}
{"code": "for (i = 0; i < NUM_KEYS; i++)\n  key_buff2[i] = key_array[i];\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/IS/is/3"}
{"code": "for (int j = first; j < (index - 1); j += 2)\n{\n  if (hullx[j] > hullx[j + 1])\n  {\n    temp = hullx[j];\n    hullx[j] = hullx[j + 1];\n    hullx[j + 1] = temp;\n    temp = hully[j];\n    hully[j] = hully[j + 1];\n    hully[j + 1] = temp;\n  }\n  else\n    if (hullx[j + 1] == hullx[j])\n  {\n    if (hully[j] > hully[j + 1])\n    {\n      temp = hully[j];\n      hully[j] = hully[j + 1];\n      hully[j + 1] = temp;\n    }\n\n  }\n\n\n}\n\n", "pragma": "        #pragma omp parallel for shared(first,hullx,hully)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/hybrid/con_hull/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    for (int k = 0; k < N; ++k)\n    {\n      C[i + (j * N)] += A[i + (k * N)] * B[j + (k * N)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/mpi/matmat_omp/1"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  fscanf(file, \"%ld %ld %lf\", &Si, &Ti, &Twt);\n  assert((Si >= 0) && (Si < NV));\n  assert((Ti >= 0) && (Ti < NV));\n  edgeListTmp[i].head = Si;\n  edgeListTmp[i].tail = Ti;\n  edgeListTmp[i].weight = fabs(Twt);\n  edgeListPtr[Si]++;\n  edgeListPtr[Ti]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/13"}
{"code": "for (i = 0; i < P; i++)\n  a[i] = &p[i * Q];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nilayladke/Game-Of-Life-Project/omp/0"}
{"code": "for (i = 0; i < n; i++)\n  sum = sum + i;\n\n", "pragma": "omp parallel for default(shared) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lhzhuxian/openMP/histogram/test/0"}
{"code": "for (i = 0; i < row; ++i)\n{\n  for (j = 0; j < col; ++j)\n  {\n    matrix[i][j] = counter;\n    printf(\"%d \", matrix[i][j]);\n    counter++;\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlaaMensh/openMPI-with-files/OMP/Matrix-vector multiplication&20160060/0"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < SMALLN_MATR; wJ += 2)\n  {\n    wV1 = _mm_load_pd(&aMatr1[wI][wJ]);\n    wV2 = _mm_load_pd(&aMatr2[wI][wJ]);\n    wV3 = _mm_add_pd(wV1, wV2);\n    _mm_store_pd(&aMatr3[wI][wJ], wV3);\n  }\n\n}\n\n", "pragma": "omp parallel for private(wI, wJ, wV1, wV2, wV3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/1"}
{"code": "for (int i = 0; i < 20000; ++i)\n{\n  sum++;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qiuwenhui/openmp_examples/example1/atomic/openmpatomic/0"}
{"code": "for (i = 0; i < (ROWSIZE / np); i++)\n{\n  for (j = 0; j < COLSIZE; j++)\n  {\n    for (k = 0; k < COLSIZE; k++)\n    {\n      recC(i, j) += recA(i, k) * pB(k, j);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j,k) shared(recA,pB,recC)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anitsure/SREC_workshop/ex3_mpi_mm_gpu_omp/mm/0"}
{"code": "for (vj = startv; vj < (nvtxs - maxhmsize); vj++)\n{\n  if (((xadj[vj + 1] - uxadj[vj]) == 1) || (xadj[vj] == uxadj[vj]))\n    continue;\n\n  if ((xadj[vj + 1] - uxadj[vj]) > (1 << l2))\n  {\n    for (++l2; (xadj[vj + 1] - uxadj[vj]) > (1 << l2); l2++)\n      ;\n\n    hmsize = (1 << (l2 + 4)) - 1;\n  }\n\n  for (nc = 0, ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n  {\n    vk = adjncy[ej];\n    for (l = vk & hmsize; hmap[l] != 0; l = (l + 1) & hmsize, nc++)\n      ;\n\n    hmap[l] = vk;\n  }\n\n  nlocal = 0;\n  if (nc > 0)\n  {\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (ei = uxadj[vi]; adjncy[ei] > vj; ei++)\n      {\n        vk = adjncy[ei];\n        for (l = vk & hmsize; (hmap[l] != 0) && (hmap[l] != vk); l = (l + 1) & hmsize)\n          ;\n\n        if (hmap[l] == vk)\n          nlocal++;\n\n      }\n\n      nprobes += ei - uxadj[vi];\n    }\n\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n    {\n      vk = adjncy[ej];\n      for (l = vk & hmsize; hmap[l] != vk; l = (l + 1) & hmsize)\n        ;\n\n      hmap[l] = 0;\n    }\n\n  }\n  else\n  {\n    for (ej = xadj[vj], ejend = uxadj[vj]; ej < ejend; ej++)\n    {\n      vi = adjncy[ej];\n      for (eiend = uxadj[vi]; adjncy[eiend] > vj; eiend++)\n        ;\n\n      for (ei = uxadj[vi]; ei < eiend; ei++)\n      {\n        vk = adjncy[ei];\n        nlocal += hmap[vk & hmsize] == vk;\n      }\n\n      nprobes += ei - uxadj[vi];\n    }\n\n    for (ej = uxadj[vj], ejend = xadj[vj + 1] - 1; ej < ejend; ej++)\n      hmap[adjncy[ej] & hmsize] = 0;\n\n  }\n\n  if (nlocal > 0)\n    ntriangles += nlocal;\n\n}\n\n", "pragma": "omp for schedule(dynamic,SBSIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/16"}
{"code": "for (size_t i = 0; i < h_prevelentColocationCount2; i++)\n{\n  for (size_t j = 0; j < degree; j++)\n  {\n    if (inner[j] != h_prevalantColocations2[(i * degree) + j])\n    {\n      flag = false;\n      break;\n    }\n\n    flag = true;\n  }\n\n  if (flag)\n  {\n    return i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spatialdatasciencegroup/OpenMP_Colocation/Codes/colocationFinder/13"}
{"code": "for (i = 0; i < 5; ++i)\n{\n  sum = 0.0;\n  for (j = 0; j < num; ++j)\n  {\n    S1[j] = 0;\n    for (k = 0; k < num; ++k)\n    {\n      if (H[(j * num) + k])\n        S1[j] += S[k];\n\n    }\n\n    sum += S1[j];\n  }\n\n  sum = 1.0 / (sum + 0.00001);\n  for (j = 0; j < num; ++j)\n  {\n    S[j] = S1[j] * sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/28"}
{"code": "for (j = e; j < m; j++)\n{\n  mj0 = m * j;\n  t = A + j;\n  c0 = C + mj0;\n  for (k = 0; k < w; k += 4)\n  {\n    km0 = k * m;\n    km1 = (k + 1) * m;\n    km2 = (k + 2) * m;\n    km3 = (k + 3) * m;\n    b00 = _mm_load1_ps(t + km0);\n    b01 = _mm_load1_ps(t + km1);\n    b02 = _mm_load1_ps(t + km2);\n    b03 = _mm_load1_ps(t + km3);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km1), b01));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km2), b02));\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km3), b03));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n      *((C + i) + mj0) += (*((A + i) + km1)) * (*(t + km1));\n      *((C + i) + mj0) += (*((A + i) + km2)) * (*(t + km2));\n      *((C + i) + mj0) += (*((A + i) + km3)) * (*(t + km3));\n    }\n\n  }\n\n  for (k = w; k < n; k++)\n  {\n    km0 = k * m;\n    b00 = _mm_load1_ps(t + km0);\n    for (i = 0; i < e; i += 4)\n    {\n      s = A + i;\n      c00 = _mm_loadu_ps(c0 + i);\n      c00 = _mm_add_ps(c00, _mm_mul_ps(_mm_loadu_ps(s + km0), b00));\n      _mm_storeu_ps(c0 + i, c00);\n    }\n\n    for (i = e; i < m; i++)\n    {\n      *((C + i) + mj0) += (*((A + i) + km0)) * (*(t + km0));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(t,s,c0,km0,km1,km2,km3,j,k,i,mj0,c00,b00,b01,b02,b03)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zzpanda/CS61C-Proj3-Matrix-Decryption-/proj3-4-4-out/1"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  result[i] += 1.0;\n  for (j = 0; j < i; j++)\n  {\n    const double distance = metric(ndata, data, data, mask, mask, weights, i, j, transpose);\n    if (distance < cutoff)\n    {\n      const double dweight = exp(exponent * log(1 - (distance / cutoff)));\n      result[i] += dweight;\n      result[j] += dweight;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/74"}
{"code": "for (i = 1; i < 1000; i++)\n{\n  x = sqrt(b[i]) - 1;\n  a[i] = ((x * x) + (2 * x)) + 1;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/simoatze/archer_race_examples/data-race03/1"}
{"code": "for (int i = 0; i < no_variables; i++)\n{\n  var_list[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdkul22/satsolve/satool_omp/8"}
{"code": "for (int i = 0; i < new_sudoku->n; i++)\n{\n  new_sudoku->grid[i] = (uint8_t *) malloc(new_sudoku->n * (sizeof(uint8_t)));\n  if (new_sudoku->grid[i] == 0)\n    print_error(\"Could not allocate space\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/openmp/bin/sudoku-omp_bfsv1/1"}
{"code": "for (int i = 0; i < Nc; i += 1)\n{\n  Classes[i].clear();\n  Classes[i].reserve(((int) N) / Nc);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(NUM_THR) schedule(dynamic, 10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AndreasKaratzas/k-means-parallel/k-means-parallel/Class/0"}
{"code": "for (int j = first; j < (size - 1); j += 2)\n{\n  if (array[j] > array[j + 1])\n    swap(&array[j], &array[j + 1]);\n\n}\n\n", "pragma": "omp parallel for default(none) shared(size,array,first)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gopal-panigrahi/parallel-programs/Bubble_sort_Serial_Parallel/0"}
{"code": "for (int k = 0; k < this->matA.getColumns(); ++k)\n{\n  partialSum += this->matA.get(i, k) * this->matB.get(k, j);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:partialSum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/contrerasmiguel/matrix-multiplication/openmp/main/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"%d\\t\", graf[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/7"}
{"code": "for (int p1 = 0; p1 < divider; p1++)\n{\n  if (p1 == dp)\n    break;\n\n  for (int y1 = 0; y1 < divider; y1++)\n    for (int x1 = 0; x1 < divider; x1++)\n    sum += *(((matrixdata + ((x * divider) + x1)) + (((y * divider) + y1) * DtCol)) + ((((p * divider) + p1) * DtCol) * DtRow));\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/27"}
{"code": "for (int i = 0; i < y_points; i++)\n{\n  for (int j = 0; j < x_points; j++)\n  {\n    *((u + (i * x_points)) + j) = *((u_new + (i * x_points)) + j);\n    *((v + (i * x_points)) + j) = *((v_new + (i * x_points)) + j);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/Dynamic_Memory_Allocation/2-D_NonLinear_Convection/2-D_Nonlinear_Convection_Dynamic/main/5"}
{"code": "for (int i = 0; i < model->no_clusters; i++)\n{\n  cluster_count[i] = 0;\n  for (int c = 0; c < model->columns; c++)\n  {\n    sum_cluster_columns[(i * model->columns) + c] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajshrestha86/kmeans-clusterize/openmp/kmeans_omp/2"}
{"code": "for (int kk = 0; kk < (N + 2); kk += 2)\n{\n  for (int jj = 0; jj < (N + 2); jj += 2)\n  {\n    fill_array3d(new_X, N / 2, 0, jj / 2, kk / 2, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/11"}
{"code": "for (int i = 0; i < data.conf.input_length; ++i)\n{\n  sum += (p_array_a[i] - p_mean_a) * (p_array_b[i] - p_mean_b);\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/2"}
{"code": "for (long i = 0; i < people.size(); i++)\n{\n  people[i].setInteraction(setInteractionNum());\n  simulateDailyInteraction(i);\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(runtime) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rskim47/disease-propagation/simulation/7"}
{"code": "for (int j = 0; j < result.cols; j++)\n{\n  int sum = 0;\n  for (int k = 0; k < width; k++)\n  {\n    sum += first.data[row][k] * second.data[k][j];\n  }\n\n  result.data[row][j] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vladimercury/cpp-multithreading/main/0"}
{"code": "for (int i = 0; i < total; i++)\n{\n  ((cout << \"< \") << alignmentHash) << endl;\n  ((((cout << \">(\") << answers_hash[i].size()) << \") \") << answers_hash[i]) << endl;\n  alignmentHash = calculate(alignmentHash.append(answers_hash[i]));\n  (cout << alignmentHash) << endl;\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel1/5"}
{"code": "for (c2 = 0; c2 <= ((((n + (-1)) * 16) < 0) ? ((16 < 0) ? (-((((-(n + (-1))) + 16) + 1) / 16)) : (-((((-(n + (-1))) + 16) - 1) / 16))) : ((n + (-1)) / 16)); c2++)\n{\n  for (c15 = 16 * c2; c15 <= ((((16 * c2) + 15) < (n + (-1))) ? ((16 * c2) + 15) : (n + (-1))); c15++)\n  {\n    X[n - 1][c15] = X[n - 1][c15] / B[n - 1][c15];\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2 ,c15 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB044-adi-tile-no/8"}
{"code": "for (int i = 0; i < row_size; ++i)\n{\n  for (int j = 0; j < col_size; ++j)\n  {\n    int count = countNeighbours(i, j);\n    if ((count <= 1) || (count >= 4))\n    {\n      copy_board[i][j] = DEAD;\n    }\n    else\n    {\n      copy_board[i][j] = ALIVE;\n      alive += 1;\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:alive) if(OPENMP_ENABLED)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MrHohn/ParallelComputing-hands-on/assginment3/game-of-life/openmp/GameOfLife/2"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  tmp = tmp + (qbnew[0][0][i - 1] * tx[0][i][0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/9"}
{"code": "for (j = 0; j < 50; j++)\n{\n  start_time = omp_get_wtime();\n  int ramp = _mm_setr_ps(0.5, 1.5, 2.5, 3.5);\n  int one = _mm_load1_ps(&scalar_one);\n  int four = _mm_load1_ps(&scalar_four);\n  int vstep = _mm_load1_ps(&step);\n  int sum = _mm_load1_ps(&scalar_zero);\n  int xvec;\n  int denom;\n  int eye;\n  for (i = 0; i < num_steps; i = i + 4)\n  {\n    ival = (float) i;\n    eye = _mm_load1_ps(&ival);\n    xvec = _mm_mul_ps(_mm_add_ps(eye, ramp), vstep);\n    denom = _mm_add_ps(_mm_mul_ps(xvec, xvec), one);\n    sum = _mm_add_ps(_mm_div_ps(four, denom), sum);\n  }\n\n  _mm_store_ps(&vsum[0], sum);\n  pi = step * (((vsum[0] + vsum[1]) + vsum[2]) + vsum[3]);\n  run_time = omp_get_wtime() - start_time;\n  ave += run_time;\n  if (run_time < min)\n    min = run_time;\n\n  if (run_time > max)\n    max = run_time;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ATPESC/OMP_Exercises/Solutions/pi_vec/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  int dis = distLine(p1, p2, points[i]);\n  if (dis > max_dis)\n  {\n    max_dis = dis;\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/A1P2_solution/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  x1[i] = ((DATA_TYPE) i) / SIZE;\n  x2[i] = (((DATA_TYPE) i) + 1) / SIZE;\n  y1[i] = (((DATA_TYPE) i) + 3) / SIZE;\n  y2[i] = (((DATA_TYPE) i) + 4) / SIZE;\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/MVT/mvt/2"}
{"code": "for (int i = 0; i < 15; ++i)\n{\n  critical_values[i] = .5 * (stats[floor((niter - 1) * probas[i])] + stats[floor((niter - 1) * probas[i]) + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/olmallet81/URT/R/RcppURT/src/UnitRoot/0"}
{"code": "for (i = 0; i < size; ++i)\n{\n  for (j = 0; j < size; ++j)\n  {\n    board[i][j] = auxBoard[i][j];\n  }\n\n}\n\n", "pragma": "omp for private(h,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bernardoduarte/PPD/OpenMP/assignments/02_game_of_life/prog/1"}
{"code": "for (i = 1; i < N; i++)\n{\n  for (j = 1; j < N; j++)\n  {\n    utmp[i][j] = u[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/federhub/HPC-MPI-OpenMP-/Code/Solutions/poisson_omp/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  diameter = clusters[points[i].clusterID].diameter;\n  for (j = i + 1; j < N; j++)\n    if (points[i].clusterID == points[j].clusterID)\n  {\n    distance = sqrt((pow(points[i].x - points[j].x, 2) + pow(points[i].y - points[j].y, 2)) + pow(points[i].z - points[j].z, 2));\n    if (diameter < distance)\n      diameter = distance;\n\n  }\n\n\n  clusters[points[i].clusterID].diameter = diameter;\n}\n\n", "pragma": "#pragma omp for private (diameter)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SlavKhizverg/Parallel-Computation---written-in-C-using-openMP-and-MPI/ParallelProject/Source/5"}
{"code": "for (int i = 0; i < num_threads; i++)\n{\n  pthread_join(id[i], &statusp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1_pthreads/1"}
{"code": "for (int ieta = 0; ieta < eta_pts; ieta++)\n{\n  etaValues[ieta] = eta_tab->get(1, ieta + 1);\n  etaWeights[ieta] = eta_tab->get(2, ieta + 1) * delta_eta;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/13"}
{"code": "for (j = 0; j < 4; j++)\n{\n  for (i = 1; i < 2; i++)\n  {\n    ic = (*f[i])(ivals[2 * j], ivals[(2 * j) + 1], approx[j], rf[j]);\n    printf(\"%10s [ 0,1] num: %+lf, an: %lf\\n\", names[i], ic, (*If[j])(ivals[(2 * j) + 1]) - (*If[j])(ivals[2 * j]));\n  }\n\n  clock_t end1 = clock();\n  timeSpentSequential = ((double) (end1 - begin1)) / CLOCKS_PER_SEC;\n  printf(\"\\n\");\n  printf(\"time it takes normal: %f\\n\", timeSpentSequential);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tristingreenstein/Optimization-Techniques-using-Parallel-Task-in-OpenMP/Integration/5"}
{"code": "for (int j = 124; j < 125; j++)\n  a = 1;\n\n", "pragma": "\t#pragma omp parallel for shared(b, a, d) period(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/filippobrizzi/soma/source_exctractor/test_cases/Test/omp_test/0"}
{"code": "for (int i2 = 0; i2 < CONNMAX; ++i2)\n  clients[i2] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruslancheb/juliakernel/juliakernel/main/0"}
{"code": "for (j = 0; j < SIZE; j++)\n{\n  for (i = 0; i < SIZE; i++)\n  {\n    s[j] = s[j] + (r[i] * A[(i * SIZE) + j]);\n  }\n\n}\n\n", "pragma": "omp distribute parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/BICG/bicg/0"}
{"code": "for (i = 0; i < tlines; ++i)\n{\n  for (j = 0; j < trows; ++j)\n  {\n    if (world[(i * trows) + j] == 1)\n    {\n      attrset(COLOR_PAIR(2) | WA_BOLD);\n      mvaddch(i, j, '@');\n    }\n\n    if (world[(i * trows) + j] == 0)\n    {\n      attrset(COLOR_PAIR(1) | WA_NORMAL);\n      mvaddch(i, j, ' ');\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/batmac/conway-ncurses-openmp/nlife/4"}
{"code": "for (size_t d = 0; d < dimensions; ++d)\n{\n  new_position[d] = ((centroids[c1][d] + centroids[c2][d]) + centroids[c3][d]) / 3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/2"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  tmp_qsSub[CVT_INT(m_subbsnID[i])] += m_cellFlow[i][0];\n  m_OL_Flow[i] = m_cellFlow[i][0];\n  m_OL_Flow[i] = ((m_OL_Flow[i] * m_TimeStep) * 1000.f) / m_cellArea;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IUH_OL/IUH_OL/4"}
{"code": "for (i = 0; i < 4; i = i + 1)\n{\n  for (j = 0; j < 4; j = j + 1)\n  {\n    a[i][j] = 0.;\n    for (k = 0; k < 4; k = k + 1)\n    {\n      a[i][j] = a[i][j] + (b[i][k] * c[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/christangga/OpenMPI-Exploration/matriks/1"}
{"code": "for (int i = 0; i < halfSize; i++)\n  findMax(maxIterations, numbers[i], &sum);\n\n", "pragma": "omp parallel for shared(halfSize,maxIterations,numbers) reduction(+:sum) num_threads(NUM_THREADS)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ozamzaleg/Parallel_Computation_MPI_OpenMP/functions/0"}
{"code": "for (i = 0; i < cs.engineLength; i++)\n  cs.engineID[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/snmp_fmt_plug/1"}
{"code": "for (l = 0; l < mxyz1; l++)\n{\n  loff = l / mxy1;\n  k = l - (mxy1 * loff);\n  loff = mz * loff;\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[l];\n  npoff = (idimp * nppmx) * l;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  ll = ((mz < (nz - loff)) ? (mz) : (nz - loff)) + 1;\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sfxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = fxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sfxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sfxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = fxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  for (k = 0; k < ll; k++)\n  {\n    for (j = 0; j < mm; j++)\n    {\n      #pragma ivdep\n      for (i = 0; i < nn; i++)\n      {\n        sbxyz[4 * ((i + (mxv * j)) + (mxyv * k))] = bxyz[4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff)))];\n        sbxyz[1 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[1 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n        sbxyz[2 + (4 * ((i + (mxv * j)) + (mxyv * k)))] = bxyz[2 + (4 * (((i + noff) + (nxv * (j + moff))) + (nxyv * (k + loff))))];\n      }\n\n    }\n\n  }\n\n  sum1 = 0.0;\n  ipp = npp / 32;\n  for (m = 0; m < ipp; m++)\n  {\n    joff = 32 * m;\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = ppart[(j + joff) + npoff];\n      y = ppart[((j + joff) + nppmx) + npoff];\n      z = ppart[((j + joff) + (2 * nppmx)) + npoff];\n      nn = x;\n      mm = y;\n      ll = z;\n      dxp = x - ((float) nn);\n      dyp = y - ((float) mm);\n      dzp = z - ((float) ll);\n      n[j] = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n      amx = 1.0f - dxp;\n      amy = 1.0f - dyp;\n      dx1 = dxp * dyp;\n      dyp = amx * dyp;\n      amx = amx * amy;\n      amz = 1.0f - dzp;\n      amy = dxp * amy;\n      s[j] = amx * amz;\n      s[j + 32] = amy * amz;\n      s[j + (2 * 32)] = dyp * amz;\n      s[j + (3 * 32)] = dx1 * amz;\n      s[j + (4 * 32)] = amx * dzp;\n      s[j + (5 * 32)] = amy * dzp;\n      s[j + (6 * 32)] = dyp * dzp;\n      s[j + (7 * 32)] = dx1 * dzp;\n      t[j] = x;\n      t[j + 32] = y;\n      t[j + (2 * 32)] = z;\n    }\n\n    for (j = 0; j < 32; j++)\n    {\n      dx = 0.0f;\n      dy = 0.0f;\n      dz = 0.0f;\n      ox = 0.0f;\n      oy = 0.0f;\n      oz = 0.0f;\n      #pragma ivdep\n      for (i = 0; i < 8; i++)\n      {\n        dx += sfxyz[n[j] + mn[i]] * s[j + (32 * i)];\n        dy += sfxyz[(1 + n[j]) + mn[i]] * s[j + (32 * i)];\n        dz += sfxyz[(2 + n[j]) + mn[i]] * s[j + (32 * i)];\n        ox += sbxyz[n[j] + mn[i]] * s[j + (32 * i)];\n        oy += sbxyz[(1 + n[j]) + mn[i]] * s[j + (32 * i)];\n        oz += sbxyz[(2 + n[j]) + mn[i]] * s[j + (32 * i)];\n      }\n\n      s[j] = dx;\n      s[j + 32] = dy;\n      s[j + (2 * 32)] = dz;\n      s[j + (3 * 32)] = ox;\n      s[j + (4 * 32)] = oy;\n      s[j + (5 * 32)] = oz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      x = t[j];\n      y = t[j + 32];\n      z = t[j + (2 * 32)];\n      dx = qtmh * s[j];\n      ;\n      dy = qtmh * s[j + 32];\n      dz = qtmh * s[j + (2 * 32)];\n      acx = ppart[((j + joff) + (3 * nppmx)) + npoff] + dx;\n      acy = ppart[((j + joff) + (4 * nppmx)) + npoff] + dy;\n      acz = ppart[((j + joff) + (5 * nppmx)) + npoff] + dz;\n      p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n      gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n      qtmg = qtmh * gami;\n      sum1 += (gami * p2) / (1.0f + gami);\n      omxt = qtmg * s[j + (3 * 32)];\n      omyt = qtmg * s[j + (4 * 32)];\n      omzt = qtmg * s[j + (5 * 32)];\n      omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n      anorm = 2.0f / (1.0f + omt);\n      omt = 0.5f * (1.0f - omt);\n      rot4 = omxt * omyt;\n      rot7 = omxt * omzt;\n      rot8 = omyt * omzt;\n      rot1 = omt + (omxt * omxt);\n      rot5 = omt + (omyt * omyt);\n      rot9 = omt + (omzt * omzt);\n      rot2 = omzt + rot4;\n      rot4 -= omzt;\n      rot3 = (-omyt) + rot7;\n      rot7 += omyt;\n      rot6 = omxt + rot8;\n      rot8 -= omxt;\n      vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n      vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n      vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n      p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n      dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n      s[j] = x + (vx * dtg);\n      s[j + 32] = y + (vy * dtg);\n      s[j + (2 * 32)] = z + (vz * dtg);\n      s[j + (3 * 32)] = vx;\n      s[j + (4 * 32)] = vy;\n      s[j + (5 * 32)] = vz;\n    }\n\n    #pragma vector aligned\n    for (j = 0; j < 32; j++)\n    {\n      dx = s[j];\n      dy = s[j + 32];\n      dz = s[j + (2 * 32)];\n      vx = s[j + (3 * 32)];\n      vy = s[j + (4 * 32)];\n      vz = s[j + (5 * 32)];\n      if (ipbc == 2)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n        if ((dz < edgelz) || (dz >= edgerz))\n        {\n          dz = t[j + (2 * 32)];\n          vz = -vz;\n        }\n\n      }\n      else\n        if (ipbc == 3)\n      {\n        if ((dx < edgelx) || (dx >= edgerx))\n        {\n          dx = t[j];\n          vx = -vx;\n        }\n\n        if ((dy < edgely) || (dy >= edgery))\n        {\n          dy = t[j + 32];\n          vy = -vy;\n        }\n\n      }\n\n\n      ppart[(j + joff) + npoff] = dx;\n      ppart[((j + joff) + nppmx) + npoff] = dy;\n      ppart[((j + joff) + (2 * nppmx)) + npoff] = dz;\n      ppart[((j + joff) + (3 * nppmx)) + npoff] = vx;\n      ppart[((j + joff) + (4 * nppmx)) + npoff] = vy;\n      ppart[((j + joff) + (5 * nppmx)) + npoff] = vz;\n    }\n\n  }\n\n  nps = 32 * ipp;\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    z = ppart[(j + (2 * nppmx)) + npoff];\n    nn = x;\n    mm = y;\n    ll = z;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    dzp = z - ((float) ll);\n    nm = 4 * (((nn - noff) + (mxv * (mm - moff))) + (mxyv * (ll - loff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    dx1 = dxp * dyp;\n    dyp = amx * dyp;\n    amx = amx * amy;\n    amz = 1.0f - dzp;\n    amy = dxp * amy;\n    nn = nm;\n    dx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    dy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    dz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = amz * ((dx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4]));\n    dy = amz * ((dy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4]));\n    dz = amz * ((dz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sfxyz[nn]) + (amy * sfxyz[nn + 4]);\n    acy = (amx * sfxyz[nn + 1]) + (amy * sfxyz[(nn + 1) + 4]);\n    acz = (amx * sfxyz[nn + 2]) + (amy * sfxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    dx = dx + (dzp * ((acx + (dyp * sfxyz[mm])) + (dx1 * sfxyz[mm + 4])));\n    dy = dy + (dzp * ((acy + (dyp * sfxyz[mm + 1])) + (dx1 * sfxyz[(mm + 1) + 4])));\n    dz = dz + (dzp * ((acz + (dyp * sfxyz[mm + 2])) + (dx1 * sfxyz[(mm + 2) + 4])));\n    nn = nm;\n    ox = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    oy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    oz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = amz * ((ox + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4]));\n    oy = amz * ((oy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4]));\n    oz = amz * ((oz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4]));\n    nn += 4 * mxyv;\n    acx = (amx * sbxyz[nn]) + (amy * sbxyz[nn + 4]);\n    acy = (amx * sbxyz[nn + 1]) + (amy * sbxyz[(nn + 1) + 4]);\n    acz = (amx * sbxyz[nn + 2]) + (amy * sbxyz[(nn + 2) + 4]);\n    mm = nn + (4 * mxv);\n    ox = ox + (dzp * ((acx + (dyp * sbxyz[mm])) + (dx1 * sbxyz[mm + 4])));\n    oy = oy + (dzp * ((acy + (dyp * sbxyz[mm + 1])) + (dx1 * sbxyz[(mm + 1) + 4])));\n    oz = oz + (dzp * ((acz + (dyp * sbxyz[mm + 2])) + (dx1 * sbxyz[(mm + 2) + 4])));\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (3 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (4 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (5 * nppmx)) + npoff] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0f / sqrtf(1.0f + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0f + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    p2 = ((vx * vx) + (vy * vy)) + (vz * vz);\n    dtg = dtc / sqrtf(1.0f + (p2 * ci2));\n    dx = x + (vx * dtg);\n    dy = y + (vy * dtg);\n    dz = z + (vz * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n      if ((dz < edgelz) || (dz >= edgerz))\n      {\n        dz = z;\n        vz = -vz;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = dz;\n    ppart[(j + (3 * nppmx)) + npoff] = vx;\n    ppart[(j + (4 * nppmx)) + npoff] = vy;\n    ppart[(j + (5 * nppmx)) + npoff] = vz;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,m,noff,moff,loff,npp,npoff,ipp,joff,nps,nn,mm,ll,nm,x, y,z,vx,vy,vz,dxp,dyp,dzp,amx,amy,amz,dx1,dx,dy,dz,ox,oy,oz,acx,acy,acz, omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4,rot5,rot6,rot7,rot8,rot9, p2,gami,qtmg,dtg,sum1,sfxyz,sbxyz,n,s,t) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/vmbpush3/12"}
{"code": "for (size_t i = 0; i < parts.size(); i++)\n{\n  parts[i].part_size = M;\n  parts[i].begin = &data[i * M];\n  parts[i].end = parts[i].begin + (M - 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/keyzj-archive/dev_sort/HeapSort/src/workspace/0"}
{"code": "for (i = 0; i < N; i++)\n  b[i] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/8/pmm-secuencial/1"}
{"code": "for (int j = 0; j < sizey; j++)\n{\n  for (int i = 0; i < sizex; i++)\n  {\n    if (fabs(cc.rho_ave[i + (sizex * j)] - mc.rho_ave[i + (sizex * j)]) > 0.0001)\n    {\n      printf(\"1. cell-centric and material-centric values are not equal! (%f, %f, %d, %d)\\n\", cc.rho_ave[i + (sizex * j)], mc.rho_ave[i + (sizex * j)], i, j);\n      return false;\n    }\n\n    for (int mat = 0; mat < Nmats; mat++)\n    {\n      if (fabs(cc.p[((i + (sizex * j)) * Nmats) + mat] - mc.p[((ncells * mat) + i) + (sizex * j)]) > 0.0001)\n      {\n        printf(\"2. cell-centric and material-centric values are not equal! (%f, %f, %d, %d, %d)\\n\", cc.p[((i + (sizex * j)) * Nmats) + mat], mc.p[((ncells * mat) + i) + (sizex * j)], i, j, mat);\n        return false;\n      }\n\n      if (fabs(cc.rho_mat_ave[((i + (sizex * j)) * Nmats) + mat] - mc.rho_mat_ave[((ncells * mat) + i) + (sizex * j)]) > 0.0001)\n      {\n        printf(\"3. cell-centric and material-centric values are not equal! (%f, %f, %d, %d, %d)\\n\", cc.rho_mat_ave[((i + (sizex * j)) * Nmats) + mat], mc.rho_mat_ave[((ncells * mat) + i) + (sizex * j)], i, j, mat);\n        return false;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/9"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (calculated[i] == (-1))\n  {\n    double tmp_coff = A[(i * n) + j] / A[(max_index * n) + j];\n    A[(i * n) + j] = 0;\n    for (int k = j + 1; k < n; k++)\n    {\n      A[(i * n) + k] -= tmp_coff * A[(max_index * n) + k];\n    }\n\n    b[i] -= tmp_coff * b[max_index];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(num_threads) shared(A, b) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bupingxx/Parallel-linear-equations-solver/src/gauss2/6"}
{"code": "for (int i = 0; i < array_size; i++)\n{\n  sum += a[i] * b[i];\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UoB-HPC/BabelStream/src/omp/OMPStream/7"}
{"code": "for (size_t i = 0; i < n; i++)\n  free(*(db + i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CGHoussem/OpenMP-Sorting/src/utility/9"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < (5 + 1); j++)\n  {\n    printf(\" %.2f \", matrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/newomp/2"}
{"code": "for (i = 0; i < (1048576 * 64); i++)\n{\n  B[i] = A[i] * 2;\n}\n\n", "pragma": "omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/openmp_example/test/0"}
{"code": "for (int u = 0; u < K; u++)\n{\n  for (int p = 0; p < (DIM + 1); p++)\n  {\n    finalFinalCenters[u][p] = finalCenters[0][u][p];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hejohns/kmeans/kmeans/2"}
{"code": "for (int i = 0; i < half; i++)\n{\n  for (int j = 0; j < half; j++)\n  {\n    C[(i * n) + j] = C11[(i * half) + j];\n    C[(i * n) + (j + half)] = C12[(i * half) + j];\n    C[((i + half) * n) + j] = C21[(i * half) + j];\n    C[((i + half) * n) + (j + half)] = C22[(i * half) + j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andochiwa/OpenMP/hw/multi_vector_strassen/4"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/28"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    C[i][j] = A[i][j] - B[i][j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Soubhagyabehera/strassen-matrix-multiplication-parallel-program/strassens-matrix-mul/1"}
{"code": "for (index = 0; index < count; index += SIMD_COEF_64 * SIMD_PARA_SHA512)\n{\n  SHA512_CTX ctx;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, &saved_salt, 4);\n  SHA512_Update(&ctx, saved_key[index], saved_len[index]);\n  SHA512_Final((unsigned char *) crypt_out[index], &ctx);\n}\n\n", "pragma": "omp parallel for default(none) private(index) shared(count, saved_salt, saved_key, saved_len, crypt_out)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/XSHA512_fmt_plug/4"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float prevPageRank = stats->pageRanks[v];\n  float nextPageRank = stats->base_pr + (stats->damp * Fixed32ToFloat(pageRanksNext[v]));\n  stats->pageRanks[v] = nextPageRank;\n  pageRanksNext[v] = 0;\n  double error = fabs(nextPageRank - prevPageRank);\n  error_total += error / graph->num_vertices;\n  if (error >= arguments->epsilon)\n  {\n    activeVertices++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) shared(arguments, pageRanksNext,stats) reduction(+ : error_total, activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/15"}
{"code": "for (i = 0; i < vecLen; i++)\n{\n  printf(\"Enter Vector values [%d] : \", i);\n  scanf(\"%d\", vector + i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Omama-mostafa/parallel-OpenMP-Matrix-Vector-Multiplication/Matrix_Vector/2"}
{"code": "for (i = j + 1; i < n; i++)\n{\n  xfac = (double) fabs(a[i][j]);\n  if (xfac > amax)\n  {\n    amax = xfac;\n    m = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhuamachuco/OpenMP/exercise5-5/2"}
{"code": "for (int i, I = omp_get_max_threads(); i < I; i++)\n{\n  (((cout << \" Hello ( \") << i) << \" ) \") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/midNight-jam/openmp_lessons/parallel_loop/2"}
{"code": "for (j = 2; j < (block_dim - 2); j++)\n{\n  for (z = 2; z < (block_dim - 2); z++)\n  {\n    neighbors = 0;\n    neighbors += (((((((a[j - 1][z - 1] - '0') + (a[j - 1][z] - '0')) + (a[j - 1][z + 1] - '0')) + (a[j][z + 1] - '0')) + (a[j + 1][z + 1] - '0')) + (a[j + 1][z] - '0')) + (a[j + 1][z - 1] - '0')) + (a[j][z - 1] - '0');\n    if ((a[j][z] == '0') && (neighbors == 3))\n    {\n      b[j][z] = '1';\n    }\n    else\n      if (a[j][z] == '1')\n    {\n      if (neighbors < 2)\n      {\n        b[j][z] = '0';\n      }\n      else\n        if (neighbors < 4)\n      {\n        b[j][z] = '1';\n      }\n      else\n      {\n        b[j][z] = '0';\n      }\n\n\n    }\n    else\n      b[j][z] = '0';\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,1) num_threads(8) private(z ,neighbors)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoRouv/game-of-life/GOLOpenMP/golOpenMP/0"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  ru1 = c3c4 * rho_i[i][j][k];\n  cv[j] = vs[i][j][k];\n  int _imopVarPre1347;\n  double _imopVarPre1348;\n  int _imopVarPre1349;\n  double _imopVarPre1350;\n  int _imopVarPre1357;\n  double _imopVarPre1358;\n  int _imopVarPre1359;\n  double _imopVarPre1360;\n  int _imopVarPre1453;\n  double _imopVarPre1454;\n  int _imopVarPre1455;\n  double _imopVarPre1456;\n  int _imopVarPre1463;\n  double _imopVarPre1464;\n  _imopVarPre1347 = (dymax + ru1) > dy1;\n  if (_imopVarPre1347)\n  {\n    _imopVarPre1348 = dymax + ru1;\n  }\n  else\n  {\n    _imopVarPre1348 = dy1;\n  }\n\n  _imopVarPre1349 = (dy5 + (c1c5 * ru1)) > _imopVarPre1348;\n  if (_imopVarPre1349)\n  {\n    _imopVarPre1350 = dy5 + (c1c5 * ru1);\n  }\n  else\n  {\n    _imopVarPre1357 = (dymax + ru1) > dy1;\n    if (_imopVarPre1357)\n    {\n      _imopVarPre1358 = dymax + ru1;\n    }\n    else\n    {\n      _imopVarPre1358 = dy1;\n    }\n\n    _imopVarPre1350 = _imopVarPre1358;\n  }\n\n  _imopVarPre1359 = (dy3 + (con43 * ru1)) > _imopVarPre1350;\n  if (_imopVarPre1359)\n  {\n    _imopVarPre1360 = dy3 + (con43 * ru1);\n  }\n  else\n  {\n    _imopVarPre1453 = (dymax + ru1) > dy1;\n    if (_imopVarPre1453)\n    {\n      _imopVarPre1454 = dymax + ru1;\n    }\n    else\n    {\n      _imopVarPre1454 = dy1;\n    }\n\n    _imopVarPre1455 = (dy5 + (c1c5 * ru1)) > _imopVarPre1454;\n    if (_imopVarPre1455)\n    {\n      _imopVarPre1456 = dy5 + (c1c5 * ru1);\n    }\n    else\n    {\n      _imopVarPre1463 = (dymax + ru1) > dy1;\n      if (_imopVarPre1463)\n      {\n        _imopVarPre1464 = dymax + ru1;\n      }\n      else\n      {\n        _imopVarPre1464 = dy1;\n      }\n\n      _imopVarPre1456 = _imopVarPre1464;\n    }\n\n    _imopVarPre1360 = _imopVarPre1456;\n  }\n\n  rhoq[j] = _imopVarPre1360;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/SP/sp-wrongSVE/1"}
{"code": "for (i = 0; i < (N - 16); i++)\n{\n  result += b[i] * ((b[i + 1] + (b[i + 2] * b[i + 3])) + ((b[i + 4] + (b[i + 5] * b[i + 6])) * ((b[i + 7] + (b[i + 8] * b[i + 9])) + ((b[i + 10] + (b[i + 11] * b[i + 12])) * (b[i + 13] + (b[i + 14] * b[i + 15]))))));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/success_simd_20_denorm_ub/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  if (omp[i] != seq[i])\n  {\n    puts(\"not equal\");\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ysph/parallel-stuff/b_omp/quick_sort/4"}
{"code": "for (int i = 0; i < 1024; i++)\n{\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (1 + (y[i] * z[i])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/parallel_for/test_parallel_for_notequals/2"}
{"code": "for (i = 0; i < ni; i++)\n{\n  for (j = 0; j < nj; j++)\n  {\n    diff += (C[i][j] - Cans[i][j]) * (C[i][j] - Cans[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicklyz/Distributed-and-Parallel-Computing/lab1/mmul_main/0"}
{"code": "for (int i = 16; i <= 256; i *= 2)\n{\n  omp_set_num_threads(i);\n  x_core_histogram_time = CalculateHistogram();\n  (((((((out1 << i) << \"\\t\") << i) << \"\\t\") << (one_core_histogram_time / x_core_histogram_time)) << \"\\t\") << x_core_histogram_time) << endl;\n  out1.flush();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jonaias/Programacao-concorrente/src/main/4"}
{"code": "formula.append(number(de) + \"x^3 \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/65"}
{"code": "for (int i = 0; i < (V - 1); i++)\n{\n  if ((a.route[i + 1] - 65) == (a.route[i] - 65))\n    return INT_MAX;\n\n  if (map_copy[a.route[i] - 65][a.route[i + 1] - 65] == INT_MAX)\n    return INT_MAX;\n\n  f += map_copy[a.route[i] - 65][a.route[i + 1] - 65];\n  for (int j = 0; j < V; j++)\n    map_copy[j][a.route[i] - 65] = INT_MAX;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize_tsp_ga/7"}
{"code": "for (i = id; i < num_steps; i += numthreads)\n{\n  x = (i + 0.5) * step;\n  partial_sum += (+4.0) / (1.0 + (x * x));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SUMUKHA-PK/Heterogenous-Parallel-Computing/A5/Q6/Q6/0"}
{"code": "for (j = 1; j <= nj; j++)\n{\n  delta[j] = 1.0;\n  delta[j] = (1.0 - output[j]) * (target[j] - output[j]);\n  errsum += (delta[j] > 0.0) ? (delta[j]) : ((-1) * delta[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/tests/UniBenchBack/benchmarks/Rodinia/backprop/src/backprop-AI/3"}
{"code": "for (i = 0; i < bin_count; i++)\n{\n  bin_max = bin_maxes[i];\n  bin_min = (i == 0) ? (min_meas) : (bin_maxes[i - 1]);\n  printf(\"%.3f-%.3f:\\t\", bin_min, bin_max);\n  for (j = 0; j < bin_counts[i]; j++)\n    printf(\"X\");\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brenda151295/OpenMP/ejercicio1/3"}
{"code": "for (int i = w.start; i < w.end; i++)\n{\n  Pole pole = data.poles[(nuc * data.max_num_poles) + i];\n  RSComplex E_c = {E, 0};\n  RSComplex dopp_c = {dopp, 0};\n  RSComplex Z = c_mul(c_sub(E_c, pole.MP_EA), dopp_c);\n  RSComplex faddeeva = fast_nuclear_W(Z);\n  sigT += c_mul(pole.MP_RT, c_mul(faddeeva, sigTfactors[pole.l_value])).r;\n  sigA += c_mul(pole.MP_RA, faddeeva).r;\n  sigF += c_mul(pole.MP_RF, faddeeva).r;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/RSBench/openmp-threading/simulation/6"}
{"code": "for (i = 0; i < p; i++)\n{\n  displs[i] = offset;\n  scounts[i] = (i == 0) ? ((avg + extra) * col) : (avg * col);\n  if (i == 0)\n    offset += (avg + extra) * col;\n  else\n    offset += avg * col;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/exam_final/final/2"}
{"code": "for (i = 0; i < 15; i++)\n{\n  if (arr == 0)\n    exit(1);\n\n  int j;\n  for (j = 0; j < 2; j++)\n  {\n    arr->x[j] = rand() % 100;\n  }\n\n  wp[i] = *arr;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ImolaFodor/kdtree-parallel-construct/kdtree_build_2_tasks_openmp/3"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"Iteraci\u00f3n: %d\\n\", i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiegoAndresRa/openMP/ejercicio7/0"}
{"code": "for (int i = 0; i < n1; ++i)\n  que0[num0++] = I[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziqi-zhang/Parallel-DAG-Traversal/openmp/3"}
{"code": "for (unsigned int j = 0; j < fc.p_bindings.size(); ++j)\n{\n  if (i == get_pidx(fc.p_bindings[j][2], fc.p_bindings[j][3]))\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/djm2131/correlator-fit/src/fitter/6"}
{"code": "for (int it = 0; it < 256; ++it)\n{\n  omp_init_lock(&lck[it]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JingruGao09/OpenMP_Performance/histogram_locks/histo_locks/2"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  int u = randperm[i];\n  int v = randperm[i + 1];\n  if (u < v)\n  {\n    adj_matrix[u][v] = 1;\n  }\n  else\n  {\n    adj_matrix[v][u] = 1;\n  }\n\n  num_edges++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_multithread/1"}
{"code": "for (y = 0; y < height; y++)\n{\n  int index = ((3 * width) * y) + (x * 3);\n  float x_origin = ((((float) x) / width) * 3.25) - 2;\n  float y_origin = ((((float) y) / width) * 2.5) - 1.25;\n  float xi = 0.0;\n  float yi = 0.0;\n  int iteration = 0;\n  int max_iteration = 256;\n  while ((((xi * xi) + (yi * yi)) <= 4) && (iteration < max_iteration))\n  {\n    float xtemp = ((xi * xi) - (yi * yi)) + x_origin;\n    yi = ((2 * xi) * yi) + y_origin;\n    xi = xtemp;\n    iteration++;\n  }\n\n  if (iteration == max_iteration)\n  {\n    out[index] = 0;\n    out[index + 1] = 0;\n    out[index + 2] = 0;\n  }\n  else\n  {\n    out[index] = iteration;\n    out[index + 1] = iteration;\n    out[index + 2] = iteration;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cleversonledur/MandelbrotSet/MandelBrot/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (i == j)\n      A[i][j] = 5.0;\n    else\n      A[i][j] = 2.0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUMB_CORES) schedule(dynamic, chunksize) collapse (2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/gaussian_openmp/4"}
{"code": "for (i = 0; i < chunksize; i++)\n{\n  subArr[i].x_pos = posTemp[i * 2];\n  subArr[i].y_pos = posTemp[(i * 2) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project2/Hybrid/hybrid/2"}
{"code": "for (int i = 0; i < x_mi_length; i++)\n{\n  fill_n(mImage[i], y_mi_length, 0);\n}\n\n", "pragma": "#pragma omp parallel for num_threads(thread_count) shared(mImage)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/SaliencyMap/Cuda/tools/Filter/Filter/1"}
{"code": "for (int i = 0; i < 11; i++)\n  printf(\"%d \", RESULT[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MerendaFrancoN/OpenMP-Learning/Ejercicio-5/ejercicio5/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    }\n\n    lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n    }\n\n    fac2 = 1. / lhs[n + 2][i][j][k1];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(fac1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/111"}
{"code": "for (i = 0; i < (n + 1); i++)\n{\n  temp = matrix[(r1 * (n + 1)) + i];\n  matrix[(r1 * (n + 1)) + i] = matrix[(r2 * (n + 1)) + i];\n  matrix[(r2 * (n + 1)) + i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/robcronin/OpenMP-Applications/gauss/9"}
{"code": "for (iteration = 1; iteration <= 10; iteration += 1)\n{\n  if ('A' != 'S')\n    printf(\"        %d\\n\", iteration);\n\n  rank(iteration);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/13"}
{"code": "for (i = 0; i < cs.salt_length; i++)\n  cs.salt[i] = (atoi16[ARCH_INDEX(q[2 * i])] << 4) | atoi16[ARCH_INDEX(q[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/vtp_fmt_plug/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  printf(\"Big bucket id: %d\\t elems: \", i);\n  for (j = 0; j < bigBuckets[i].len; j++)\n  {\n    printf(\"%d \", bigBuckets[i].elems[j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg1/12"}
{"code": "for (j = ki + 10; j < (ji - 10); j++)\n  for (i = ji; i < ki; i++)\n  for (k = 0; k < 5; k += 2)\n  l++;\n\n\n\n", "pragma": "omp parallel for reduction(+: l) collapse(3)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/4"}
{"code": "for (i = 1; i < (nx + 1); i++)\n{\n  belta[1] = c / b_1;\n  y_temp[1] = f[i][1] / b_1;\n  for (j = 2; j < ny; j++)\n  {\n    belta[j] = c / (b - (a * belta[j - 1]));\n    y_temp[j] = (f[i][j] - (a * y_temp[j - 1])) / (b - (a * belta[j - 1]));\n  }\n\n  y_temp[ny] = (f[i][ny] - (a * y_temp[ny - 1])) / (b_n - (a * belta[ny - 1]));\n  U[i][ny] = y_temp[ny];\n  for (j = ny - 1; j >= 1; j--)\n  {\n    U[i][j] = y_temp[j] - (belta[j] * U[i][j + 1]);\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j,belta,y_temp) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/ADI-OpenMP-example/Numerical Tests on Simple Systems/openmp version/baseline03/5"}
{"code": "for (i = 0; i < (4 * 20); i++)\n{\n  if (!test_omp_critical(i))\n  {\n    num_failed++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project/openmp/runtime/test/critical/omp_critical_with_hint/0"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"%d \", a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture5/Loop_construct_implicit_barrier/Loop_construct_implicit_barrier/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (q == 0.0)\n    q = (d[i] - x) - (fabs(off[i]) / DBL_EPSILON);\n  else\n    q = (d[i] - x) - ((off[i] * off[i]) / q);\n\n  if (q < 0.0)\n    k++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/Bisection/12"}
{"code": "for (j = k; j >= 0; j--)\n{\n  for (r = 0., i = 0; i <= k; i++)\n    if (i != j)\n    r += (mat[j][i] >= 0.) ? (mat[j][i]) : (-mat[j][i]);\n\n\n  if (r == 0.)\n  {\n    scal[k] = (double) j;\n    if (j != k)\n    {\n      for (i = 0; i <= k; i++)\n      {\n        double t;\n        t = mat[i][j];\n        mat[i][j] = mat[i][k];\n        mat[i][k] = t;\n      }\n\n      for (i = m; i < n; i++)\n      {\n        double t;\n        t = mat[j][i];\n        mat[j][i] = mat[k][i];\n        mat[k][i] = t;\n      }\n\n    }\n\n    k--;\n    iter = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/5"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n{\n  psum += a[i];\n  pprod *= a[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dodiaz/OpenMPBasics/OpenMPBasics/Basics/6"}
{"code": "for (unsigned i = 0; i < input.size(); i++)\n{\n  input[i] = i * mul;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/1"}
{"code": "for (i = 0; i < (384 - 2); ++i)\n  for (j = 0; j < (512 - 2); ++j)\n  *((*(greenmeanfilteredmatrix + i)) + j) = ((((((((0.111111 * (*((*(greenmatrix + i)) + j))) + (0.111111 * (*(((*(greenmatrix + i)) + j) + 1)))) + (0.111111 * (*(((*(greenmatrix + i)) + j) + 2)))) + (0.111111 * (*((*((greenmatrix + i) + 1)) + j)))) + (0.111111 * (*(((*((greenmatrix + i) + 1)) + j) + 1)))) + (0.111111 * (*(((*((greenmatrix + i) + 1)) + j) + 2)))) + (0.111111 * (*((*((greenmatrix + i) + 2)) + j)))) + (0.111111 * (*(((*((greenmatrix + i) + 2)) + j) + 1)))) + (0.111111 * (*(((*((greenmatrix + i) + 2)) + j) + 2)));\n\n\n", "pragma": "omp parallel for default(none) shared(greenmeanfilteredmatrix, greenmatrix) private(i, j) num_threads(NUM_THREADS[num_threads_index]) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/elixir-code/HPC-Lab/OpenMP/Exercise-3/codes/with-sections/meanfilter3x3/1"}
{"code": "for (j = 0; j < n; j++)\n  printf(\"%d\\n\", c[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amir-saadat/Scientific-computing/lab7/matvec_part6/6"}
{"code": "for (i = -5; i < 5; i += 2)\n{\n  printf(\"Hello world %d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for/3"}
{"code": "for (int i = 0; i < NUM; i++)\n{\n  int tid = __builtin_amdgcn_workitem_id_x();\n  b[i] = run(tid, 0);\n}\n\n", "pragma": "#pragma omp target parallel for map(tofrom:b[0:NUM])", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/func-ptr/func-ptr/0"}
{"code": "for (i = 1; i < points->num; i++)\n{\n  bool to_open = (((float) lrand48()) / ((float) INT_MAX)) < (points->p[i].cost / z);\n  if (to_open)\n  {\n    (*kcenter)++;\n    open = true;\n    for (int k = k1; k < k2; k++)\n    {\n      float distance = dist(points->p[i], points->p[k], points->dim);\n      if ((distance * points->p[k].weight) < points->p[k].cost)\n      {\n        points->p[k].cost = distance * points->p[k].weight;\n        points->p[k].assign = i;\n      }\n\n    }\n\n    open = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/6"}
{"code": "for (i = 0; i < matA.l; i++)\n{\n  matA.mat[i] = (float *) malloc(matA.c * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/mult_matriz/main/1"}
{"code": "for (int i = 0; i < (threadid + 1); i++)\n{\n  partial_sum += partial_prefix_sum[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HarichandanaParimi/OpenMP_Loop/prefixsum/prefixsum/1"}
{"code": "for (i = n - 2; i >= 0; i--)\n{\n  sum = b[i];\n  for (j = i + 1; j < n; j++)\n    sum = sum - (a[i][j] * b[j]);\n\n  b[i] = sum / a[i][i];\n}\n\n", "pragma": "#pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kielfriedt/Multithreading/OpenMP/MatSolv/3"}
{"code": "for (int i = 0; i < bsz; ++i)\n  for (int j = 0; j < bsz; ++j)\n  for (int k = 0; k < bsz; ++k)\n  C[IDX(i, j)] -= A[IDX(i, k)] * B[IDX(k, j)];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zooltd/LU-decomposition/lu/6"}
{"code": "for (i = 1; i <= m; i++)\n{\n  tid = omp_get_thread_num();\n  nthreads = omp_get_num_threads();\n  printf(\"third for loop: %d, id = %d\\n\", nthreads, tid);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter6/nf/2"}
{"code": "for (i = 0; i < (width * height); i++)\n{\n  retval[i] = (float) out[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zonghan0904/2020_Fall_PP/Final_Project/OpenMP/omp/0"}
{"code": "for (i = 0; i <= (numsteps - 1); ++i)\n{\n  double x = (i + 0.5) * stepsize;\n  sum += 1.0 / ((x * x) + 1.0);\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darksocrates/OpenMP_play/forpi/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Entrez un element du tableau---------- \\n\");\n  scanf(\"%f\", &tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hermannwilfried694/OpenMP1/max1/1"}
{"code": "for (idx_t i = 0; i < F; ++i)\n{\n  for (idx_t j = i; j < F; ++j)\n  {\n    rv[j + (i * F)] = 1.;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/17"}
{"code": "for (k = curr_body + 1; k < n; k++)\n{\n  force_qk[0] = bodies[curr_body].s[0] - bodies[k].s[0];\n  force_qk[1] = bodies[curr_body].s[1] - bodies[k].s[1];\n  dist = sqrt((force_qk[0] * force_qk[0]) + (force_qk[1] * force_qk[1]));\n  dist = (dist * dist) * dist;\n  force_qk[0] *= (((-G) * bodies[curr_body].m) * bodies[k].m) / dist;\n  force_qk[1] *= (((-G) * bodies[curr_body].m) * bodies[k].m) / dist;\n  force[curr_body][0] += force_qk[0];\n  force[curr_body][1] += force_qk[1];\n  force[k][0] -= force_qk[0];\n  force[k][1] -= force_qk[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/8"}
{"code": "for (int i = 0; i < n; ++i)\n  graf[i] = (int *) malloc(n * (sizeof(int)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doddyaditya/OpenMP/src/dijkstraomp/5"}
{"code": "for (int i = 0; i < omp_get_num_threads(); i++)\n{\n  {\n    for (int i = 0; i < loceven.size(); i++)\n    {\n      even.push_back(loceven[i]);\n    }\n\n  }\n}\n\n", "pragma": "#pragma omp for ordered schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xsovao/openmp/openmp/openmp/3"}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  lwidth = ((lwidth * 10) + buffer[i]) - '0';\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/41"}
{"code": "for (i = 0; i < tam_vetor; i++)\n{\n  if (i == (tam_vetor - 1))\n    printf(\"%d.\", vetor[i]);\n  else\n    printf(\"%d, \", vetor[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aulospl/TrabConcorrente/PRSR/3"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  A[k][i] = A[k][i] / A[k][k];\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/0"}
{"code": "for (c2 = 0; c2 <= (n + (-1)); c2++)\n{\n  A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n  B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB055-jacobi2d-parallel-no/1"}
{"code": "for (int i = 0; i < NMAX; i++)\n{\n  a[i] = rand() % 100;\n  b[i] = rand() % 100;\n  c[i] = rand() % 100;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Betorov/OpenMpLabs/Labs4/Labs4/0"}
{"code": "for (int i = 0; i < 100; i++)\n  xpay(alpha, x, y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/test/vector_blas/xpay/2"}
{"code": "for (i = 0; i < part; i++)\n{\n  if (L[i] == x)\n  {\n    lcount++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) shared(part) reduction(+:lcount)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMPsearchCLV/0"}
{"code": "for (int idx = 0; idx < ((int) 1000); idx++)\n  results[idx] = coeff * pData[idx];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/pr46032/0"}
{"code": "for (i = 1; i <= nt; i += 1)\n{\n  err = (sums[i].real - vdata_real_a[i]) / vdata_real_a[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n  err = (sums[i].imag - vdata_imag_a[i]) / vdata_imag_a[i];\n  if (fabs(err) > epsilon)\n  {\n    *verified = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/31"}
{"code": "for (int i = 0; i < (array_size / 2); i++)\n{\n  t[i] = numbers[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/utshomomen/openmpshell/openmpshell/openmpshel2/1"}
{"code": "for (int i = m - (m % 4); i < m; i++)\n{\n  for (int j = m - (m % 4); j < m; j++)\n  {\n    *((C + (i * m)) + j) /= 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubhamsinha92/Matrix-Multiplication-Project/sgemm-openmp/2"}
{"code": "for (int l = 0; l < threads; l++)\n{\n  t = 0;\n  ((cout << \"Thread no \") << omp_get_thread_num()) << endl;\n  int start = dev * l;\n  int stop = (dev * (l + 1)) + 1;\n  for (int i = start; i < (start + pattlength); i++)\n  {\n    t = ((d * t) + text[i]) % prime;\n  }\n\n  for (int i = start; (i < stop) && (i < textlength); i++)\n  {\n    c = 0;\n    if (p == t)\n    {\n      for (int j = 0; j < pattlength; j++)\n      {\n        c++;\n        if (text[i + j] != pattern[j])\n          break;\n\n      }\n\n      if (c == pattlength)\n      {\n        total = total + 1;\n      }\n\n    }\n\n    if (i < (textlength - pattlength))\n    {\n      t = ((d * (t - (text[i] * h))) + text[i + pattlength]) % prime;\n      if (t < 0)\n        t = t + prime;\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for private(c,t) reduction(+:total)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RadhikaBailurkar/OpenMP/PatternSearch/2"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  p[i][i] = 1;\n  for (int j = 0; j < SIZE; j++)\n  {\n    a1[i][j] = 0;\n    r[i][j] = 0;\n    if (i != j)\n    {\n      p[i][j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/Matrix-inverse-LUP/inverse_non_parallelized/7"}
{"code": "for (box = 0; box < level->num_my_boxes; box++)\n{\n  int i;\n  int j;\n  int k;\n  const int jStride = level->my_boxes[box].jStride;\n  const int kStride = level->my_boxes[box].kStride;\n  const int ghosts = level->my_boxes[box].ghosts;\n  const int dim_i = level->my_boxes[box].dim;\n  const int dim_j = level->my_boxes[box].dim;\n  const int dim_k = level->my_boxes[box].dim;\n  for (k = 0; k <= dim_k; k++)\n  {\n    for (j = 0; j <= dim_j; j++)\n    {\n      for (i = 0; i <= dim_i; i++)\n      {\n        int ijk = ((i + ghosts) + ((j + ghosts) * jStride)) + ((k + ghosts) * kStride);\n        double x = hLevel * (((double) (i + level->my_boxes[box].low.i)) + 0.5);\n        double y = hLevel * (((double) (j + level->my_boxes[box].low.j)) + 0.5);\n        double z = hLevel * (((double) (k + level->my_boxes[box].low.k)) + 0.5);\n        double A;\n        double B;\n        double Bx;\n        double By;\n        double Bz;\n        double Bi;\n        double Bj;\n        double Bk;\n        double U;\n        double Ux;\n        double Uy;\n        double Uz;\n        double Uxx;\n        double Uyy;\n        double Uzz;\n        A = 1.0;\n        B = 1.0;\n        Bx = 0.0;\n        By = 0.0;\n        Bz = 0.0;\n        Bi = 1.0;\n        Bj = 1.0;\n        Bk = 1.0;\n        evaluateU(x, y, z, &U, &Ux, &Uy, &Uz, &Uxx, &Uyy, &Uzz, level->boundary_condition.type == BC_PERIODIC);\n        double F = ((a * A) * U) - (b * ((((Bx * Ux) + (By * Uy)) + (Bz * Uz)) + (B * ((Uxx + Uyy) + Uzz))));\n        level->my_boxes[box].vectors[VECTOR_BETA_I][ijk] = Bi;\n        level->my_boxes[box].vectors[VECTOR_BETA_J][ijk] = Bj;\n        level->my_boxes[box].vectors[VECTOR_BETA_K][ijk] = Bk;\n        level->my_boxes[box].vectors[VECTOR_ALPHA][ijk] = A;\n        level->my_boxes[box].vectors[VECTOR_F][ijk] = F;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/operators/problem.p4/2"}
{"code": "for (int py = 0; py < nPixX; py++)\n{\n  for (int px = 0; px < nPixY; px++)\n  {\n    const int pos = (((nPixX * nPixY) * nz) + (py * nPixY)) + px;\n    int coordA = (py * nPixYMap) + px;\n    int coordB = ((py + 1) * nPixYMap) + px;\n    int coordC = coordA + 1;\n    int coordD = coordB + 1;\n    double gamma = atan(((d_pObjX[py] + (dx / 2.0)) - tubeX) / (rtubeZ - d_pObjZ[nz]));\n    double alpha = atan(((d_pObjY[px] + (dy / 2.0)) - rtubeY) / (rtubeZ - d_pObjZ[nz]));\n    double dA;\n    double dB;\n    double dC;\n    double dD;\n    dA = d_sliceI[coordA];\n    dB = d_sliceI[coordB];\n    dC = d_sliceI[coordC];\n    dD = d_sliceI[coordD];\n    if ((dC == 0) && (dD == 0))\n    {\n      dC = dA;\n      dD = dB;\n    }\n\n    d_pVolume[pos] += (((dD - dC) - dB) + dA) * (((du * dv) * dz) / (((cos(alpha) * cos(gamma)) * dx) * dy));\n  }\n\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for collapse(2) thread_limit(BLOCK_SIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/7"}
{"code": "for (int i = 0; i < nCol; i++)\n{\n  distance += pow(point[i] - centroid[i], 2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/0"}
{"code": "for (int j = 1; j < (SIZE + 1); j++)\n{\n  mean[j] = 0.0;\n  for (int i = 1; i < (SIZE + 1); i++)\n  {\n    mean[j] += data[(i * (SIZE + 1)) + j];\n  }\n\n  mean[j] /= 3214212.01;\n}\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/COVAR/covar/0"}
{"code": "for (int n = 0; n < length; n++)\n{\n  fscanf(fp, \"%d %d %lf\", &i, &j, &value);\n  matrix[n].i = i;\n  matrix[n].j = j;\n  matrix[n].value = value;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mvhv/mpi-openmp-matrix/mmMPI/1"}
{"code": "for (int i = 0; i < rows1; i++)\n{\n  matrix1[i] = (int *) malloc((sizeof(int)) * columns1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/promops/lab/main/0"}
{"code": "for (int i = da; i < a; ++i)\n{\n  for (int j = 0; j < input->d; ++j)\n  {\n    x_new[j] = input->x[(i * input->d) + j] + (((input->r[(sup->r_i + (i * input->d)) + j] * 2) - 1) * sup->stepind_curr);\n  }\n\n  float f_new_i = evaluate_f(x_new, input->c, 0, input->d);\n  float delta_f_i = f_new_i - sup->f_curr[i];\n  if (delta_f_i < 0)\n  {\n    sup->delta_f[i] = delta_f_i;\n    sup->f_curr[i] = f_new_i;\n    for (int j = 0; j < input->d; ++j)\n    {\n      sup->delta_x[(i * input->d) + j] = x_new[j] - input->x[(i * input->d) + j];\n      input->x[(i * input->d) + j] = x_new[j];\n    }\n\n  }\n  else\n  {\n    for (int j = 0; j < input->d; ++j)\n      sup->delta_x[(i * input->d) + j] = 0;\n\n    sup->delta_f[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/11"}
{"code": "for (i = 0; i < lenC; i++)\n{\n  C[i] = 0;\n}\n\n", "pragma": "omp parallel for private(i) shared(n, C, lenC)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/duinobot2/OMPCountingSort/ProjectCountingSortFinal1/src/countingsort/1"}
{"code": "for (int i = 0; i < (geom1->n_grid_r - 1); i++)\n  for (int k = 0; k < (geom1->n_grid_z - 1); k++)\n{\n  double alpha_t = (time1->delta_t * (((e_phi[i + 1][k] + e_phi[i][k]) / ((2.0 * dr) * (i + 0.5))) + ((e_phi[i + 1][k] - e_phi[i][k]) / dr))) / MAGN_CONST;\n  field_z_half_time[i][k] = field_z[i][k] - (alpha_t / 2);\n  field_z[i][k] = field_z[i][k] - alpha_t;\n}\n\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/hField/8"}
{"code": "for (j = 0; j < k; ++j)\n{\n  printf(\"error: %f\\n\", errorHistory[j]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/als-movie-recommender/C/main/3"}
{"code": "for (i = 0; i < n; ++i)\n{\n  sum += x[i] * y[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/andrinr/uzh-hpc/exercise_session_10/basics/dot_openacc/1"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < width; k++)\n    {\n      double x = a[(i * width) + k];\n      double y = b[(k * width) + j];\n      sum += x * y;\n    }\n\n    c[(i * width) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GustavoLR548/CPguacamole/Tarefa20/mm/mm/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  {\n    int j;\n    a[0] += 2;\n    a[1] += 3;\n    b[2] *= 2;\n    f[3] += 8;\n    g[1] += 9;\n    g[2] += 10;\n    h[0] += 11;\n    k[1][1] += 13;\n    k[2][1] += 15;\n    m[1] += 16;\n    r[2] += 8;\n    s[1] *= 2;\n    t[2][1] *= 2;\n    t[3][1] *= 2;\n    for (j = 0; j < 2; j++)\n    {\n      {\n        m[1] += 6;\n        r[2] += 7;\n        q[1][0] += 17;\n        q[2][0] += 19;\n        a[0] += 4;\n        a[1] += 5;\n        b[3] *= 2;\n        b[4] *= 2;\n        f[3] += 18;\n        g[1] += 29;\n        g[2] += 18;\n        h[0] += 19;\n        s[2] *= 2;\n        t[2][0] *= 2;\n        t[3][0] *= 2;\n        foo(n, c, d, m, r, o, p, q);\n        r[3] += 18;\n        o[1] += 29;\n        o[2] += 18;\n        p[0] += 19;\n        c[0] += 4;\n        c[1] += 5;\n        d[0] *= 2;\n        e[1] += 6;\n        f[2] += 7;\n        k[1][0] += 17;\n        k[2][0] += 19;\n      }\n    }\n\n    r[3] += 8;\n    o[1] += 9;\n    o[2] += 10;\n    p[0] += 11;\n    q[1][1] += 13;\n    q[2][1] += 15;\n    b[3] *= 2;\n    c[0] += 4;\n    c[1] += 9;\n    d[0] *= 2;\n    e[1] += 16;\n    f[2] += 8;\n  }\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reinaldoasf/libgomp/testsuite/libgomp.c-c++-common/task-reduction-7/0"}
{"code": "for (int i = 0; i < reconstructed_matrix.size(); i++)\n{\n  for (int j = 0; j < reconstructed_matrix[i].size(); j++)\n  {\n    matrixfile_output << reconstructed_matrix[i][j];\n    matrixfile_output << \" \";\n  }\n\n  matrixfile_output << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vishalbidawatka/IPSC_Image_Compression_Decompression_PCA_Openmp/Parallel_pca/15"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  r += A[linha][i] * solucao[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vmunidario/Algoritmo_Jacobi/omp_jacobi/8"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  out[i] = work(arr[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Baltoli/skeletons/examples/map/0"}
{"code": "for (mat_col = 0; mat_col < local_B->n_bar; mat_col++)\n{\n  for (mat_row = 0; mat_row < local_B->n_bar; mat_row++)\n    *(temp + mat_row) = *((local_B->entries + (local_B->n_bar * mat_row)) + mat_col);\n\n  MPI_Send(temp, local_B->n_bar, (MPI_Datatype) 0x4c00080b, 0, 0, grid->comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/11"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = volume[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] + (((vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)] - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) + vol_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) - vol_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]);\n    post_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = pre_vol[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - (vol_flux_y[FTNREF2D(j, k + 1, x_max + 4, x_min - 2, y_min - 2)] - vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_cell/4"}
{"code": "for (int i = 0; i < 128; i++)\n{\n  x[i] = i + 1;\n  y[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/openmp/declare_variant_if/declare_variant_if/2"}
{"code": "for (i = 1; i < (bitmask + 1); ++i)\n{\n  vertex_count[digits / granularity][i] += vertex_count[digits / granularity][i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/15"}
{"code": "for (i = j + 1; i < n; i++)\n{\n  for (k = 0; k < j; k++)\n  {\n    L[(i * n) + j] = L[(i * n) + j] - (L[(i * n) + k] * L[(j * n) + k]);\n  }\n\n  L[(i * n) + j] = L[(i * n) + j] / L[(j * n) + j];\n}\n\n", "pragma": "omp parallel for shared(L) private(i, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Harshs27/Brownian_dynamics_parallel_implementation/final/bd_omp_myc/1"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    w[i][j] = (((u[i - 1][j] + u[i + 1][j]) + u[i][j - 1]) + u[i][j + 1]) / 4.0;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NelsonNew/SPP-Project-OpenMP/Aufgabe 4/heated-plate-parallel/8"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n      fprintf(stderr, \"OK\\n\");\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(stderr, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(stderr, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(stderr, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static/4"}
{"code": "for (i = 0; i < numThreads; i++)\n  printf(\"%d  \", B[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GiosueOrefice/Parallel_computing/provaEsame/4"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    C[i][j] = 0.0f;\n    for (k = 0; k < SIZE; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(i,j,k) shared(A,B,C)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarcusGitAccount/CPD-openmp/homework/matrix_matrix_mul/2"}
{"code": "for (int row = 0; row < n; row++)\n{\n  int deg = 0;\n  for (int col = 0; col < n; col++)\n    deg += matrix[row][col];\n\n  degree[row] = deg;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manolismih/sparseMatPerm/parallel/0"}
{"code": "for (size_t i = 0; i < g.n_edge_ranges; ++i)\n{\n  char *newmsg;\n  {\n    asprintf(&newmsg, \"%s%s[len=%zu]\", msg, (i == 0) ? (\"\") : (\", \"), g.edge_ranges[i].compressed_size);\n    xfree(msg);\n    msg = newmsg;\n  }\n  nedges_local += g.edge_ranges[i].compressed_size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/11"}
{"code": "for (int m = 0, f = 0; m <= nm; ++m)\n{\n  for (int u = 0; u < num_bases; ++u)\n  {\n    const int k = basis_k_list[u];\n    const int j = basis_j_list[u];\n    if ((m == 0) && (k < 0))\n      continue;\n\n    if ((max_r >= 0) && (abs(m - k) > max_r))\n      continue;\n\n    index_lookup_table[(m * num_bases) + u] = raw_feat_j_list.size();\n    raw_feat_j_list.emplace_back(j);\n    raw_feat_k_list.emplace_back(k);\n    raw_feat_m_list.emplace_back(m);\n    raw_feat_r_list.emplace_back(k - m);\n    raw_feat_basis_list.emplace_back(u);\n    ++f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/2"}
{"code": "for (i = 0; i < n; i += 4)\n{\n  v1 = _mm_load_ps(&x[i]);\n  absval = _mm_andnot_ps(SIGNMASK, v1);\n  zero = _mm_set1_ps(1.0);\n  add = _mm_dp_ps(absval, zero, 0xFF);\n  _mm_store_ps(tmp, add);\n  asum += tmp[0];\n}\n\n", "pragma": "omp parallel for schedule(static) reduction(+:asum) reduction(+:tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/asum/2"}
{"code": "for (int i = 0; i < target_cells_size_; i++)\n{\n  target_cells_[i].numberPoints = 0;\n  target_cells_[i].mean[0] = 0;\n  target_cells_[i].mean[1] = 0;\n  target_cells_[i].mean[2] = 0;\n  memset(target_cells_[i].invCovariance.data, 0, ((sizeof(double)) * 3) * 3);\n  target_cells_[i].invCovariance.data[2][0] = 1.0;\n  target_cells_[i].invCovariance.data[1][1] = 1.0;\n  target_cells_[i].invCovariance.data[0][2] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/esa-tu-darmstadt/daphne-benchmark/src/OpenMP-offload-Jetson/ndt_mapping/kernel/13"}
{"code": "for (int k = 0; k < rows; k++)\n{\n  sum += matrix_a[i][k] * matrix_b[k][j];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Goginet/openmp/main/2"}
{"code": "for (int k = 0; k < n; k += 2 * level)\n{\n  int initial = k;\n  int center = k + (level - 1);\n  int rear = k + ((2 * level) - 1);\n  if (center >= n)\n  {\n    center = ((k + n) - 1) / 2;\n    rear = n - 1;\n  }\n  else\n    if (rear >= n)\n  {\n    rear = n - 1;\n  }\n\n\n  merge(arr, initial, center, rear);\n}\n\n", "pragma": "        #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/mergesort/mergesort/2"}
{"code": "for (index = 0; index < stateVecSize; index++)\n{\n  targetBit = extractBit_copy(targetQubit, index + (chunkId * chunkSize));\n  if (targetBit)\n  {\n    stateRealLo = stateVecReal[index];\n    stateImagLo = stateVecImag[index];\n    stateVecReal[index] = (cosAngle * stateRealLo) - (sinAngle * stateImagLo);\n    stateVecImag[index] = (sinAngle * stateRealLo) + (cosAngle * stateImagLo);\n  }\n\n}\n\n", "pragma": "omp parallel for default (none) shared (stateVecSize, stateVecReal,stateVecImag ) private (index,targetBit,stateRealLo,stateImagLo) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josthoma/Distributed-Quantum-Computing/QuEST/testCode/eceBenchmark_0812/1"}
{"code": "for (long j = start; j <= finish; j++)\n{\n  return_val += sin(j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/10_omp_sin_sum/1"}
{"code": "for (j = 0; j < ny; j++)\n{\n  for (i = 0; i < nx; i++)\n  {\n    udiff[i][j] = unew[i][j] - uexact[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/poisson/4"}
{"code": "for (z = 0; z < OMP_zMax; z++)\n{\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, z);\n      u[ind] *= postScale;\n      u[ind + 1] *= postScale;\n      u[ind + 2] *= postScale;\n      u[ind + 3] *= postScale;\n      u[ind + 4] *= postScale;\n      u[ind + 5] *= postScale;\n      u[ind + 6] *= postScale;\n      u[ind + 7] *= postScale;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/oompDeblur/0"}
{"code": "for (i = 0; i < 3; i++)\n  move[i] = pusher->v.velocity[i] * movetime;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jrk/QuakeTM/server/sv_phys/5"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    if (grid[i][j] == 1)\n      k++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DAToneli/highlife/golomp/2"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n  uold[i][j] = u[i][j];\n\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/inputJacobi/1"}
{"code": "for (int a = 0; a < N; a++)\n{\n  for (int b = 0; b < N; b++)\n    printf(\"%g \", C[(a * N) + b]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LauraLaureus/ParallelBigMultiplication/BigMultParalelized/BigMultParalelized/Source/9"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*cclass) == 'U')\n  {\n    printf(\"          %2d%20.13e\\n\", m, xcr[m]);\n  }\n  else\n    if (xcrdif[m] > epsilon)\n  {\n    *verified = 0;\n    printf(\" FAILURE: %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n  else\n  {\n    printf(\"          %2d%20.13e%20.13e%20.13e\\n\", m, xcr[m], xcrref[m], xcrdif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/18"}
{"code": "for (i = 0; i < n3local; i++)\n{\n  const double vx = 0.5 * (v[i] + vold[i]);\n  t += vx * vx;\n}\n\n", "pragma": "#pragma omp parallel for private(i) default(none) reduction(+:t)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apawloski/miniMD-omp/thermo/2"}
{"code": "for (i = 0; i < firstPartSize; i++)\n{\n  firstPart[i] = dataArray[positionLeft + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rektplorer64/ITCS443-A1_OpenMP_Bucket_Sort/main/2"}
{"code": "for (int k = 0; k < N; k++)\n{\n  for (int n = 0; n < N; n++)\n  {\n    Xr_o[k] += (xr[n] * cos(((n * k) * PI2) / N)) + ((idft * xi[n]) * sin(((n * k) * PI2) / N));\n    Xi_o[k] += (((-idft) * xr[n]) * sin(((n * k) * PI2) / N)) + (xi[n] * cos(((n * k) * PI2) / N));\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dd2356/OpenMP/OpenMP/exercise_3/src/dft/0"}
{"code": "for (int i = 0; i < imageWidth; i++)\n{\n  for (int j = 0; j < imageWidth; j++)\n  {\n    bool isCelPrime = isprime(ulam_get_map(i, j, imageWidth));\n    if (isCelPrime)\n    {\n      image[i][j][0] = 255;\n      image[i][j][1] = 255;\n      image[i][j][2] = 255;\n    }\n    else\n    {\n      image[i][j][0] = 0;\n      image[i][j][1] = 0;\n      image[i][j][2] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) schedule(dynamic) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/karlosos/obliczenia_wielkiej_mocy/lab_8_ulam_sierpinski_taskwait/spirala_openmp_update/1"}
{"code": "for (int i = 0; i < NumberOfBodies; i++)\n{\n  if (merged[i] == (-1))\n  {\n    remainingBodies++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnabycollins/PSCI/step-4/6"}
{"code": "for (int i = 1; i < array_size; ++i)\n{\n  if (((cur_sum *= a[i]) % modul) != 0)\n  {\n    cur_sum = (a[i] * cur_sum) % modul;\n  }\n\n  cur_sum *= a[i];\n}\n\n", "pragma": "#pragma omp parallel for shared(a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OlegDydy/kamyshnikov_omp/App_1/App_1/0"}
{"code": "for (idx_t m = 1; m < tt->nmodes; ++m)\n{\n  ncols *= tt->dims[(mode + m) % tt->nmodes];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sptensor/12"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) + 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, 0, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, yval, z);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x += 8)\n    {\n      int ind = OMP_Index(x, y, 0);\n      u[ind] *= boundryScale;\n      u[ind + 1] *= boundryScale;\n      u[ind + 2] *= boundryScale;\n      u[ind + 3] *= boundryScale;\n      u[ind + 4] *= boundryScale;\n      u[ind + 5] *= boundryScale;\n      u[ind + 6] *= boundryScale;\n      u[ind + 7] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (y = 0; y < OMP_yMax; y++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, y, zval)] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/mompDeblur/0"}
{"code": "for (int i = 0; i < clusterIndices.size(); i++)\n{\n  clusters.push_back(dataset[clusterIndices[i]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/8"}
{"code": "for (int y = 1; y < lastLine; ++y)\n{\n  SimulateLine(y - 1, y, y + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StefanRadlwimmer/GameOfLife/GOL/src/GameOfLife/GameOfLifeOpenMP/0"}
{"code": "for (m = 0; m < np1; m++)\n{\n  fft_data_local[2 * m] = f[m][j][k].Re;\n  fft_data_local[(2 * m) + 1] = f[m][j][k].Im;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/LTic/local_shape_transfer/5"}
{"code": "for (j = 0; j < dims[2][1]; j++)\n{\n  jj = (((((j + 1) + ystart[2]) - 2) + (NY / 2)) % NY) - (NY / 2);\n  ij2 = (jj * jj) + ii2;\n  for (k = 0; k < dims[2][2]; k++)\n  {\n    kk = (((((k + 1) + zstart[2]) - 2) + (NZ / 2)) % NZ) - (NZ / 2);\n    indexmap[k][j][i] = (kk * kk) + ij2;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(k ,j ,ii ,ii2 ,jj ,ij2 ,kk ,indexmap ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/1"}
{"code": "for (i = 0; i < lenx; i++)\n{\n  for (j = 0; j < leny; j++)\n  {\n    sum += field[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stfc/PSycloneBench/benchmarks/shallow/OMP/shallow_base_openmp_v3/18"}
{"code": "for (idx_t m = 0; m < ngraphs; ++m)\n{\n  nvtxs += graphs[m]->nvtxs;\n  ncon += graphs[m]->nedges;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/7"}
{"code": "for (ii = 0; ii <= 5; ii += 1)\n{\n  int llidx = lidx[ii];\n  o1[lidx[ii]] += volnew_o8;\n  o2[lidx[ii]] += volold_o8;\n}\n\n", "pragma": "omp parallel for private (ii) firstprivate (volnew_o8,volold_o8)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_foo/1"}
{"code": "for (toss = 0; toss < number_of_tosses; toss++)\n{\n  x = (2 * my_drand(&seed)) - 1;\n  y = (2 * my_drand(&seed)) - 1;\n  distance_squared = (x * x) + (y * y);\n  if (distance_squared <= 1)\n  {\n    number_in_circle++;\n  }\n\n}\n\n", "pragma": "omp for private(x,y,distance_squared)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysimonov/C-concurrent/OpenMP/lab3part1/0"}
{"code": "for (i = 0; i < sc_threads; i++)\n  MEM_FREE(pseudo_rands[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/6"}
{"code": "for (i = 0; i < 4; i++)\n  for (j = 0; j < 4; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "omp for schedule (dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirankumarhere/OpenMP/Matrix_mult/matrix_mult_unblocked/1"}
{"code": "for (j = 2; j < (n - 2); j++)\n  for (i = 2; i < (n - 2); i++)\n  out[i + (j * n)] = (float) 0.0;\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/Stencil/stencil/0"}
{"code": "for (j = 0; j < ysz; j++)\n{\n  for (i = 0; i < xsz; i++)\n  {\n    uint32_t pixel;\n    double r;\n    double g;\n    double b;\n    r = (g = (b = 0.0));\n    for (s = 0; s < samples; s++)\n    {\n      struct vec3 col = trace(get_primary_ray(i, j, s), 0);\n      r += col.x;\n      g += col.y;\n      b += col.z;\n    }\n\n    r = r * rcp_samples;\n    g = g * rcp_samples;\n    b = b * rcp_samples;\n    pixel = (((((uint32_t) (((r < 1.0) ? (r) : (1.0)) * 255.0)) & 0xff) << 0) | ((((uint32_t) (((g < 1.0) ? (g) : (1.0)) * 255.0)) & 0xff) << 8)) | ((((uint32_t) (((b < 1.0) ? (b) : (1.0)) * 255.0)) & 0xff) << 16);\n    fb[i + (j * xsz)] = pixel;\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) private(i,j,s) schedule(dynamic,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/c-ray/c-ray/9"}
{"code": "for (m = 0; m < 5; m++)\n{\n  if ((*class_npb) == 'U')\n  {\n    printf(\"          %2d%20.13E\\n\", m + 1, xce[m]);\n  }\n  else\n    if (xcedif[m] <= epsilon)\n  {\n    printf(\"          %2d%20.13E%20.13E%20.13E\\n\", m + 1, xce[m], xceref[m], xcedif[m]);\n  }\n  else\n  {\n    *verified = FALSE;\n    printf(\" FAILURE: %2d%20.13E%20.13E%20.13E\\n\", m + 1, xce[m], xceref[m], xcedif[m]);\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/36"}
{"code": "for (int i = size - 2; i >= 0; i--)\n{\n  double sum = 0;\n  for (int j = i + 1; j < size; j++)\n  {\n    sum += M[(i * size) + j] * b[j];\n  }\n\n  b[i] = (b[i] - sum) / M[(i * size) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LukasZahradnik/cpp-gauss/main/1"}
{"code": "for (i = 0; i <= 4; i += 1)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << 23) - 1)))\n    switch ('A')\n  {\n    case 'S':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'W':\n      if (i < 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'A':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'B':\n      if (((i == 1) || (i == 2)) || (i == 4))\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'C':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/12"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    if ((i == (j - 1)) || (i == (j + 1)))\n      a[i][j] = 1.0;\n    else\n      if (i != j)\n      a[i][j] = 0.0;\n    else\n      a[i][j] = 0.0;\n\n\n    sum += a[i][j];\n  }\n\n  a[i][i] = sum;\n  x[i] = 1.0;\n  x_k[i] = 1.0;\n  k_x[i] = 2.0;\n  if (i == 0)\n    max_b = (b[i] = 10.0);\n  else\n    b[i] = 0.0;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/p-burgess/TCP-and-parallel/openMP/sor/0"}
{"code": "for (int i = 0; i < point_count; i++)\n{\n  ungrpd_pnts_indr_host[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qtclustering-omp/QTC/0"}
{"code": "for (int i = 0; i < rows; i++)\n  matrix[i] = calloc(columns, sizeof(int));\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dargmuesli/parallel-processing/part-1_openmp/a_numbers/1"}
{"code": "for (int i = 0; i < nStreams; ++i)\n  cudaStreamCreate(&stream[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lapesd/dynemol/dynemol/GPU_Interface/0"}
{"code": "for (int i = 0; i < g->n; i++)\n{\n  levels[i] = NOT_VISITED_MARKER;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vulq/Flo/cpupar/5"}
{"code": "for (i = 0; i < len; i++)\n  for (j = 0; j < len; j++)\n  printf(\"%lf\", a[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Dawncc/dataracebench/DRB003-antidep2-orig-yes/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  z[i] = i * i;\n  y[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cwhelchel/ocl_tiny/ocl_tiny04/ocl_tiny04/tiny04/2"}
{"code": "for (i = 0; i < numOfProducts; i++)\n{\n  coordsProducts[i] = allProducts[i].coordinates;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/maayankrasno/Kmeans/kmeans/19"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (k = 1; k <= (nz - 2); k++)\n  {\n    for (j = jst; j <= jend; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n      }\n\n    }\n\n    L2 = ny - 1;\n    for (j = jst; j <= L2; j++)\n    {\n      tmp = 1.0 / u[i][j][k][0];\n      u21j = tmp * u[i][j][k][1];\n      u31j = tmp * u[i][j][k][2];\n      u41j = tmp * u[i][j][k][3];\n      u51j = tmp * u[i][j][k][4];\n      tmp = 1.0 / u[i][j - 1][k][0];\n      u21jm1 = tmp * u[i][j - 1][k][1];\n      u31jm1 = tmp * u[i][j - 1][k][2];\n      u41jm1 = tmp * u[i][j - 1][k][3];\n      u51jm1 = tmp * u[i][j - 1][k][4];\n      flux[i][j][k][1] = ty3 * (u21j - u21jm1);\n      flux[i][j][k][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n      flux[i][j][k][3] = ty3 * (u41j - u41jm1);\n      flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * (((pow2(u21j) + pow2(u31j)) + pow2(u41j)) - ((pow2(u21jm1) + pow2(u31jm1)) + pow2(u41jm1)))) + (((1.0 / 6.0) * ty3) * (pow2(u31j) - pow2(u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n    }\n\n    for (j = jst; j <= jend; j++)\n    {\n      rsd[i][j][k][0] = rsd[i][j][k][0] + ((dy1 * ty1) * ((u[i][j - 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j + 1][k][0]));\n      rsd[i][j][k][1] = (rsd[i][j][k][1] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][1] - flux[i][j][k][1]))) + ((dy2 * ty1) * ((u[i][j - 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j + 1][k][1]));\n      rsd[i][j][k][2] = (rsd[i][j][k][2] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][2] - flux[i][j][k][2]))) + ((dy3 * ty1) * ((u[i][j - 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j + 1][k][2]));\n      rsd[i][j][k][3] = (rsd[i][j][k][3] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][3] - flux[i][j][k][3]))) + ((dy4 * ty1) * ((u[i][j - 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j + 1][k][3]));\n      rsd[i][j][k][4] = (rsd[i][j][k][4] + (((ty3 * C3) * C4) * (flux[i][j + 1][k][4] - flux[i][j][k][4]))) + ((dy5 * ty1) * ((u[i][j - 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j + 1][k][4]));\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][1][k][m] = rsd[i][1][k][m] - (dssp * ((((+5.0) * u[i][1][k][m]) - (4.0 * u[i][2][k][m])) + u[i][3][k][m]));\n      rsd[i][2][k][m] = rsd[i][2][k][m] - (dssp * (((((-4.0) * u[i][1][k][m]) + (6.0 * u[i][2][k][m])) - (4.0 * u[i][3][k][m])) + u[i][4][k][m]));\n    }\n\n    jst1 = 3;\n    jend1 = ny - 4;\n    for (j = jst1; j <= jend1; j++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j - 2][k][m] - (4.0 * u[i][j - 1][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j + 1][k][m])) + u[i][j + 2][k][m]));\n      }\n\n    }\n\n    for (m = 0; m < 5; m++)\n    {\n      rsd[i][ny - 3][k][m] = rsd[i][ny - 3][k][m] - (dssp * (((u[i][ny - 5][k][m] - (4.0 * u[i][ny - 4][k][m])) + (6.0 * u[i][ny - 3][k][m])) - (4.0 * u[i][ny - 2][k][m])));\n      rsd[i][ny - 2][k][m] = rsd[i][ny - 2][k][m] - (dssp * ((u[i][ny - 4][k][m] - (4.0 * u[i][ny - 3][k][m])) + (5.0 * u[i][ny - 2][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/77"}
{"code": "for (unsigned int i = 0; i < number; i++)\n{\n  if (is_alive[i])\n  {\n    dump_position_to_old_single(i);\n    half_step_pos_single(t, i);\n    back_position_to_rz_single(i);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for shared(e_fld, h_fld, t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/particles/10"}
{"code": "for (i = 0; i < N; i++)\n{\n  x = rannum();\n  y = rannum();\n  if (((x * x) + (y * y)) < r)\n  {\n    sum = sum + 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for private(x,y) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davestampf/OpenMPTutorialFull/MonteCarlo/parallel/montecarlo/0"}
{"code": "for (int i = 0; i < (N - 1); i++)\n{\n  if (A[i] > A[i + 1])\n    sorted = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mijapa/OpenMP/BucketSort/main/1"}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  int attempt = 0;\n  double ktests[3];\n  int domoretests = 1;\n  while (domoretests)\n  {\n    double start = omp_get_wtime();\n    thrMM(A, B, C);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n    if (attempt < 3)\n    {\n      ktests[attempt] = elapsed;\n    }\n    else\n    {\n      insertTest(elapsed, ktests);\n    }\n\n    if (attempt == 20)\n      domoretests = 0;\n\n    if ((attempt >= 5) && withinTol(ktests))\n      domoretests = 0;\n\n    attempt++;\n  }\n\n  for (int i = 0; i < 3; i++)\n    printf(\"# %f\\n\", ktests[i]);\n\n  printf(\"# attempts: %d\\n\", attempt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_main/1"}
{"code": "for (p1 = word, p2 = (word + strlen(word)) - 2; p2 > p1; ++p1, --p2)\n{\n  *p1 ^= *p2;\n  *p2 ^= *p1;\n  *p1 ^= *p2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xyderos/palindromes/palindromes/1"}
{"code": "for (i = 0; i < (14 * 14); i++)\n{\n  random = randInRange(0, 1);\n  if (random == 0)\n  {\n    a = randInRange(0, 14);\n    b = randInRange(0, 14);\n    field[(14 * a) + b] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FuzeProg/Game-of-Life-OMP/gol/2"}
{"code": "for (i = 1; i <= 46; i++)\n{\n  R46 = 0.5 * R46;\n  T46 = 2.0 * T46;\n}\n\n", "pragma": "omp parallel for reduction(*: R46, T46)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/NPB3.0-omp-c/IS/is/1"}
{"code": "for (k = 8; k > 0; k--)\n{\n  indice = lectura_caracteres[0] % 2;\n  lectura_caracteres[0] = lectura_caracteres[0] / 2;\n  lectura_binario[k - 1] = digitos_binario[indice];\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chuucks/C-Multi-Parallel-programing-with-and-OpenMp-and-MPI/encriptador_paralelo/1"}
{"code": "for (i = 0; i < 100; ++i)\n  for (j = 0; j < 100; ++j)\n{\n  bark();\n}\n\n\n", "pragma": "omp parallel for ordered(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/sink-1/2"}
{"code": "for (int i = 0; i < m; i++)\n{\n  swap(vect[i][0], vect[i][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/B23579/Kd-tree-implementation/MPI_kd_tree/0"}
{"code": "for (thread = 0; thread < thread_num; thread++)\n{\n  printf(\"  %8d  %12d  %12d  %12d\\n\", thread, result_seq[thread], result_par[thread], result_seq[thread] - result_par[thread]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/ziggurat_openmp_original/6"}
{"code": "for (size_t i = mid; i < len; ++i)\n  begin[i] += sum;\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/sync/1"}
{"code": "for (n = nzi - 1; n < nzt; n++)\n{\n  nn = nxhyd * n;\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (i = 0; i < ny; i++)\n      {\n        joff = (nxhd * i) + nn;\n        t1 = f[j1 + joff];\n        f[j1 + joff] = f[j + joff];\n        f[j + joff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = sct[kmr * j];\n        for (i = 0; i < ny; i++)\n        {\n          joff = (nxhd * i) + nn;\n          t2 = t1 * f[j2 + joff];\n          f[j2 + joff] = f[j1 + joff] - t2;\n          f[j1 + joff] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxyz / nx;\n  ani = 0.5 / ((((float) nx) * ((float) ny)) * ((float) nz));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < ny; k++)\n    {\n      joff = (nxhd * k) + nn;\n      t2 = conjf(f[(nxh - j) + joff]);\n      t1 = f[j + joff] + t2;\n      t2 = (f[j + joff] - t2) * t3;\n      f[j + joff] = ani * (t1 + t2);\n      f[(nxh - j) + joff] = ani * conjf(t1 - t2);\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nxhd * k) + nn;\n    f[nxhh + joff] = ani * conjf(f[nxhh + joff]);\n    f[joff] = ani * ((crealf(f[joff]) + cimagf(f[joff])) + ((crealf(f[joff]) - cimagf(f[joff])) * _Complex_I));\n  }\n\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nxhd * k) + nn;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (nxhd * k1) + nn;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[i + k1];\n        f[i + k1] = f[i + joff];\n        f[i + joff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (nxhd * (j + k1)) + nn;\n        j2 = (nxhd * (j + k2)) + nn;\n        t1 = sct[kmr * j];\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[i + j2];\n          f[i + j2] = f[i + j1] - t2;\n          f[i + j1] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    joff = nxhd * k;\n    k1 = ((nxhd * ny) - joff) + nn;\n    joff += nn;\n    t1 = f[k1];\n    f[k1] = 0.5 * (cimagf(f[joff] + t1) + (crealf(f[joff] - t1) * _Complex_I));\n    f[joff] = 0.5 * (crealf(f[joff] + t1) + (cimagf(f[joff] - t1) * _Complex_I));\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,nn,joff,ani,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/25"}
{"code": "for (i = 0; i < M; i++)\n  for (j = 0; j < N; j++)\n  out[(i * N) + j] -= lr * in[(i * N) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philorfa/Parallel-OpenMP-CUDA-FPGAs/CPU-GPU/linalg/6"}
{"code": "for (i = -1; i < world_size; i++)\n{\n  for (j = 0; j < world_size; j++)\n  {\n    if (i == (-1))\n    {\n      printf(\"|%d\", j % 10);\n    }\n    else\n    {\n      printf(\"%c\", '|');\n      switch (world_indexer[i][j].type)\n      {\n        case 1:\n          printf(\"%c\", 's');\n          break;\n\n        case 2:\n          printf(\"%c\", 'w');\n          break;\n\n        case 3:\n          printf(\"%c\", 't');\n          break;\n\n        case 4:\n          printf(\"%c\", 'i');\n          break;\n\n        case 5:\n          printf(\"%c\", '$');\n          break;\n\n        default:\n          printf(\"%c\", ' ');\n          break;\n\n      }\n\n    }\n\n  }\n\n  printf(\"|\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfcorreia/squirrels/src/wolves-squirrels-omp/4"}
{"code": "for (j = 4; j >= 0; j--)\n{\n  result_3[i][j] = (i * 10) + j;\n  printf(\"%d, %d\\n\", i, j);\n}\n\n", "pragma": "#pragma omp parallel for firstprivate(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tianyi93/hpxMP_mirror/tests/openmp/unit/for_decrement/3"}
{"code": "for (uint block = 0; block < numBlocks; ++block)\n{\n  iterator begin = keys.begin() + (block * blockSize);\n  iterator end;\n  if (((block + 1) * blockSize) >= keys.size())\n    end = keys.end();\n  else\n    end = keys.begin() + ((block + 1) * blockSize);\n\n  radixSortParallelHistoBlock(begin, end, &blockHistograms[block * numBuckets], startBit, numBits);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/solution/radixsort_solution/2"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < N; j++)\n  if (i == j)\n  B[i][j] = m;\nelse\n  B[i][j] = m - abs(A[i][j]);\n\n\n\n", "pragma": "omp for schedule(static, num_of_lines) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Coursal/OpenMP-Strictly-Diagonally-Dominant/sdd/2"}
{"code": "for (int filter_len = 16; filter_len <= listsize; filter_len *= 2)\n  printf(\"MAX THREADS: %d\", omp_get_max_threads());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/neurodata/ndlib/c_version/filterCutoutOMPCache/1"}
{"code": "for (i = 1; i < (((L / 1) + 2) - 1); i++)\n{\n  j = 1;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    got[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    got[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n  j = ((L / NODESY) + 2) - 2;\n  ii = ((((i + j) % 2) * ((L / 1) + 2)) + i) / 2;\n  if (ii < (((L / 1) + 2) / 2))\n    get[i] = whites[ii][j].data;\n  else\n    if (ii >= (((L / 1) + 2) / 2))\n    get[i] = blacks[ii - (((L / 1) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/87"}
{"code": "for (int j = 0; j < n; j++)\n{\n  printf(\"Hello from thread #%d iteration i#%d j#%d\\n\", omp_get_thread_num(), i, j);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/nest/1"}
{"code": "for (int ac = 1; ac < argc; ac++)\n{\n  if (MATCH(\"-s\"))\n  {\n    Threshold = atoi(argv[++ac]);\n  }\n  else\n    if (MATCH(\"-t\"))\n  {\n    numThreads = atoi(argv[++ac]);\n  }\n  else\n    if (MATCH(\"-i\"))\n  {\n    filename = argv[++ac];\n  }\n  else\n    if (MATCH(\"-o\"))\n  {\n    outputname = argv[++ac];\n  }\n  else\n  {\n    printf(\"Usage: %s [-i < filename>] [-s <threshold>] [-t <numThreads>] [-o outputfilename]\\n\", argv[0]);\n    return -1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mebegu/Parallel-Image-Segmentation/imseg_serial/1"}
{"code": "for (k = 0; k < 500; k++)\n{\n  for (i = 0; i < 500; i++)\n    for (j = 0; j < 500; j++)\n    c3[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Assignments/2/LA2/10"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    c.r = ((-2.0) + ((2.5 * ((double) i)) / ((double) 1000))) + eps;\n    c.i = ((1.125 * ((double) j)) / ((double) 1000)) + eps;\n    testpoint();\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(c,eps)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/mandel/0"}
{"code": "for (n = 0; n < (k + 1); n++)\n{\n  m = k - n;\n  for (x = 0; x < chunk_size; x++)\n    for (y = 0; y < chunk_size; y++)\n  {\n    i = (x + 1) + (n * chunk_size);\n    j = (y + 1) + (m * chunk_size);\n    e = A[i][j];\n    A[i][j] = (((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.;\n    E[n][m] = (E[n][m] > fabs(e - A[i][j])) ? (E[n][m]) : (fabs(e - A[i][j]));\n  }\n\n\n}\n\n", "pragma": "omp parallel for shared(A, E, k) private(n, m, x, y, i, j, e)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artem-bondar/parallel-programming/sor_2d_omp/0"}
{"code": "for (int i = (N / 4) * 3; i < N; i++)\n{\n  sp = a[i] + b[i];\n  if (sp != 0)\n  {\n    total *= sp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab5/Source/7"}
{"code": "for (int ipart = 0; ipart < npart; ipart++)\n{\n  for (int ipT = 0; ipT < pT_tab_length; ipT++)\n  {\n    for (int iphip = 0; iphip < phi_tab_length; iphip++)\n    {\n      for (int iy = 0; iy < y_pts; iy++)\n      {\n        long long int iS3D = ((long long int) ipart) + (((long long int) npart) * (((long long int) ipT) + (((long long int) pT_tab_length) * (((long long int) iphip) + (((long long int) phi_tab_length) * ((long long int) iy))))));\n        double dN_pTdpTdphidy_tmp = 0.0;\n        for (int icell = 0; icell < endFO; icell++)\n        {\n          long long int iSpectra = ((long long int) icell) + (((long long int) endFO) * iS3D);\n          dN_pTdpTdphidy_tmp += dN_pTdpTdphidy_all[iSpectra];\n        }\n\n        dN_pTdpTdphidy[iS3D] += dN_pTdpTdphidy_tmp;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/4"}
{"code": "for (int i = 0; i < (n * n); i += n)\n{\n  LAPACK_dlarnv(&intONE, &ISEED[0], &n, &matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cterboven/OpenMP-tutorial-SC21/tasking-exercises/00-worksharing/cholesky-for-opt/cholesky/0"}
{"code": "for (i = 1; i < n; i++)\n{\n  pi += h * f(h * (i - 0.5));\n}\n\n", "pragma": "omp parallel for reduction(+:pi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UniversityProjects/Cineca_Parallel_Computing/OpenMP_Code/pi/0"}
{"code": "for (i = 1; i < (NARRAY - 1); i += 2)\n{\n  if (v2[i] > v2[i + 1])\n  {\n    tmp = v2[i + 1];\n    v2[i + 1] = v2[i];\n    v2[i] = tmp;\n  }\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelmcs/metodos-de-ordenamiento-OPENMP/trabajofinaltodoenunoparalelo/main/3"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    b[(i * n) + j] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dangets/openmp_examples/MatxVec/1"}
{"code": "for (size_t i = 0; i < N; i++)\n  vec[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziminyuri/AMP-OpenMP/AMP/15"}
{"code": "for (int d_node = 0; d_node < (*dangling_count); d_node++)\n{\n  W += (*x)[(*D)[d_node]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/10"}
{"code": "for (int ii = 0; ii < N; ii += Nb)\n{\n  for (int kk = 0; kk < N; kk += Nb)\n  {\n    for (int jj = 0; jj < N; jj += Nb)\n    {\n      for (int i = ii; i < min(ii + Nb, N); i++)\n      {\n        for (int k = kk; k < min(kk + Nb, N); k++)\n        {\n          float r = A[(i * N) + k];\n          for (int j = jj; j < min(jj + Nb, N); j++)\n          {\n            C[(i * N) + j] += r * B[(k * N) + j];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_main_blocked/0"}
{"code": "for (p = 0; p < Np; p++)\n{\n  int I0 = MPM_Mesh.I0[p];\n  Locality_I0 = FEM_Mesh.NodalLocality_0[MPM_Mesh.I0[p]];\n  while (Locality_I0 != 0)\n  {\n    if (FEM_Mesh.ActiveNode[Locality_I0->Idx] == 0)\n    {\n      FEM_Mesh.ActiveNode[Locality_I0->Idx] = 1;\n    }\n\n    Locality_I0 = Locality_I0->next;\n  }\n\n  if ((Driver_EigenErosion == 1) || (Driver_EigenSoftening == 1))\n  {\n    push__SetLib__(&FEM_Mesh.List_Particles_Node[I0], p);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/migmolper/NL-PartSol/nl-partsol/src/Nodes/aLME/18"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < S[i].curSize; j++)\n  {\n    int a = S[i].heap[j].id;\n    weight += S[i].heap[j].weight;\n    count++;\n    if ((a != (-1)) && (!S[a].find_id(i)))\n    {\n      ((((cout << \"(\") << i) << \",\") << a) << \") :\";\n      for (int k = 0; k < S[i].curSize; k++)\n        ((((cout << S[i].heap[k].id) << \"(\") << S[i].heap[k].weight) << \")\") << \" \";\n\n      cout << \" I \";\n      for (int k = 0; k < S[a].curSize; k++)\n        ((((cout << S[a].heap[k].id) << \"(\") << S[a].heap[k].weight) << \")\") << \" \";\n\n      cout << endl;\n      cout << \"i: \";\n      for (int k = 0; k < n; k++)\n        if ((k != i) && S[k].find_id(i))\n        (cout << k) << \" \";\n\n\n      cout << endl;\n      cout << \"a: \";\n      for (int k = 0; k < n; k++)\n        if ((k != a) && S[k].find_id(a))\n        (cout << k) << \" \";\n\n\n      cout << endl;\n      cout << \"i: \";\n      for (int k = g->verPtr[i]; k < g->verPtr[i + 1]; k++)\n        (((cout << g->verInd[k].id) << \" \") << g->verInd[k].weight) << \",\";\n\n      cout << endl;\n      cout << \"a: \";\n      for (int k = g->verPtr[a]; k < g->verPtr[a + 1]; k++)\n        (((cout << g->verInd[k].id) << \" \") << g->verInd[k].weight) << \",\";\n\n      cout << endl;\n      flag = true;\n      break;\n    }\n\n  }\n\n  if (flag)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/bSuitor/1"}
{"code": "for (i = 0; i < (num_of_iterations + 1); i++)\n{\n  int j = 0;\n  for (j = 0; j < K; j++)\n  {\n    fprintf(fout, \"%f %f %f, \", *(iterative_centroids + (((i * K) + j) * 3)), *((iterative_centroids + (((i * K) + j) * 3)) + 1), *((iterative_centroids + (((i * K) + j) * 3)) + 2));\n  }\n\n  fprintf(fout, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/13"}
{"code": "for (i = 0; i < 10; i++)\n{\n  for (j = 0; j < 10; j++)\n  {\n    int id = omp_get_thread_num();\n    printf(\"my id is %i\\n\", id);\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) collapse(2) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zhyuchao123/OpenMP-and-CUDA-for-matrix-decomposition/ompexample1/0"}
{"code": "for (int i = 0; i < m; i++)\n  for (int j = 0; j < n; j++)\n  A[i][j] += B[i];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/3"}
{"code": "for (i = 0; i <= num; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/debajitdatta2k/Introduction-to-omp/ParallelizeSimpleCode/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  d[i] = a[i] * b[i];\n  printf(\"Thread %d: d[%d]= %f\\n\", tid, i, d[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/omp_workshare2/1"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  x[i] = 0.00001 * i;\n  y[i] = 0.00033 * i;\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-273738/clang-273738/0"}
{"code": "for (j = jst; j < jend; j++)\n{\n  for (i = ist; i < iend; i++)\n  {\n    for (n = 0; n < 5; n++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        a[j][i][n][m] = 0.0;\n        b[j][i][n][m] = 0.0;\n        c[j][i][n][m] = 0.0;\n        d[j][i][n][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/ssor/0"}
{"code": "for (int i = 0; i < NX; i++)\n{\n  solution[i] = sin(((i * DX) * 2) * M_PI);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omi14098/Parallel-PDE-solvers/1D/omp1DPDE/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  output[i] = ((((((bucket1[i] + bucket2[i]) + bucket3[i]) + bucket4[i]) + bucket5[i]) + bucket6[i]) + bucket7[i]) + bucket8[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/24"}
{"code": "for (int i = 0; i < 50; i++)\n{\n  if (omp_get_num_threads() == 1)\n  {\n    A[omp_get_thread_num() + (i % 2)] += 1;\n    temp[omp_get_thread_num() + (i % 2)] += 2;\n  }\n  else\n  {\n    A[omp_get_thread_num()] += 1;\n    temp[omp_get_thread_num()] += 2;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/omptests/t-data-sharing-many-teams/test/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  tablica[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bett-it/Primes_numbers_OpenMP/prime_number_parr1/2"}
{"code": "for (int i = 0; i < (file_length - 1); i++)\n{\n  P[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carmi94/ProgettoPP/period/1"}
{"code": "for (i = 1; i < (m - 1); i++)\n{\n  for (j = 1; j < (m - 1); j++)\n  {\n    V[transformer(i, j)] = V_new[transformer(i, j)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juanclopezr/openmp_first/openmpi/1"}
{"code": "for (j = 0; j < (((int) temp_chromosome.size()) - 1); j++)\n{\n  city_pair.insert(temp_chromosome[j]);\n  city_pair.insert(temp_chromosome[j + 1]);\n  fitness_sum += this->cost_table[city_pair];\n  city_pair.clear();\n}\n\n", "pragma": "#pragma omp parallel for private(j, city_pair) reduction(+: fitness_sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/khai22/tsp-GA/population-omp/13"}
{"code": "for (i = r2; i < (sz + r2); i++)\n{\n  for (j = c2; j < (sz + c2); j++)\n  {\n    r[i][j] = p[(i - r2) + r1][(j - c2) + c1] + q[i - r2][j - c2];\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LalitDhupar/Large-Matrix-Multiplication-Using-OpenMP/Large_Matrix_Multplication_OpenMP/2"}
{"code": "for (i = 0; i < 50000000; i++)\n{\n  A[i] = ((i * 25) % 65536) + 33;\n  B[i] = (((i + 50000000) / 2) % 457) - 17;\n  C[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(A, B, C) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdelcampo/OpenMP-Samples/Lab3_OpenMP/Test2_Secciones/iniArraysBucles/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  matrix[i] = (int *) malloc(size * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KunxiSun/matrix_multiplication_and_openmp_in_c_2/src/q1-avg/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/10"}
{"code": "for (i = 0; i < N; ++i)\n{\n  corr[i] = tmp_corr[y[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prip-lab/MSU-LatentAFIS/matching/matcher/15"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < n; ++j)\n  {\n    for (k = 0; k < n; ++k)\n    {\n      sum += a[(i * n) + k] * b[(k * n) + j];\n    }\n\n    c[(i * n) + j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/situkangsayur/MatrixMxNOpenMP/multiplication/1"}
{"code": "for (i = 0; i < nlmo; i++)\n{\n  (*observations)[i][0] += rand() * sqrt(R[0][0]);\n  (*observations)[i][1] += rand() * sqrt(R[1][1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/6"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-c\") == 0)\n  {\n    CUTOFF = atoi(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE] -c CUTOFF\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/0"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    if (processedData[i][j] != processedDataParallel[i][j])\n      return false;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MUKUL821/Picturesque--Image-Processing/imageold/5"}
{"code": "for (k = 1; k < 10; k++)\n  if (puc_posar(i, j, k, thread))\n{\n  taules[thread].taula[i][j] = k;\n  if (j < 8)\n    s += recorrer(i, j + 1, thread);\n  else\n    if (i < 8)\n    s += recorrer(i + 1, 0, thread);\n  else\n    s++;\n\n\n  taules[thread].taula[i][j] = 0;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_DaudenV2/5"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Recv(temp, observRows, MPI_INT, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, &status);\n  for (z = 0; z < observRows; z++)\n  {\n    if (temp[z] != (observRows + 1))\n    {\n      finalPath[z] = temp[z];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/12"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  a[i] = (double *) malloc(1000 * (sizeof(double)));\n  b[i] = (double *) malloc(1000 * (sizeof(double)));\n  c[i] = (double *) malloc(1000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/valeroclemente/AdvanceComputerArchitecture/OpenMP_linux_codes/MulMatOpenmp_linux/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (((arr_A[i] % 2) == 0) && (arr_C[i] != 0))\n    num = arr_B[i] / arr_C[i];\n  else\n    num = arr_B[i] + arr_A[i];\n\n  if (num != 0)\n  {\n    omp_set_lock(&lock);\n    product *= num;\n    omp_unset_lock(&lock);\n  }\n\n}\n\n", "pragma": "#pragma omp for private(num)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DariaVoo/OpenMP_MPI/OpenMP/lab6/0"}
{"code": "for (i = bestOffs2 - SCANWIND; i < end; i++)\n{\n  if (i == bestOffs2)\n    continue;\n\n  corr = (float) calcCrossCorr(refPos + (channels * i), pMidBuffer, norm);\n  float tmp = ((float) (((2 * i) - seekLength) - 1)) / ((float) seekLength);\n  corr = (corr + 0.1f) * (1.0f - ((0.25f * tmp) * tmp));\n  if (corr > bestCorr)\n  {\n    bestCorr = corr;\n    bestOffs = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OpenMPT/openmpt/include/soundtouch/source/SoundTouch/TDStretch/3"}
{"code": "for (j = 0; j < 2000; j++)\n  for (k = 0; k < 2000; k++)\n  for (i = k; i < 2000; i++)\n  c[j][i] = c[j][i] + (a[k][i] * b[k][j]);\n\n\n\n", "pragma": "omp for schedule(guided, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dianchengwangCHN/ParallelComputingLab/PA2/PA2-p3/pa2-p3/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  d[i] = 1.0 / c[i];\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adityakaria/5-Sem/pc/lab2/q1/no-wait/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  sum = 0;\n  #pragma GCC ivdep\n  for (j = 0; j < 1000; j++)\n    sum += a[i][j] * b[i][j];\n\n}\n\n", "pragma": "omp parallel for private(j,sum) schedule(static,50)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Exercise4/addMAt/addMat_omp/1"}
{"code": "for (n = 0; n < N; n++)\n{\n  for (m = 0; m < M; m++)\n  {\n    k = COL_MAJOR_INDEX_2D(M, N, m, n);\n    sk = s[k];\n    i = (int) ceil(((sk - dataMin) / (dataMax - dataMin)) * MAP_RGB_SIZE);\n    i = MIN(MAP_RGB_SIZE - 1, MAX(0, i));\n    j = ROW_MAJOR_INDEX_3D(N, M, 4, n, m, 0);\n    data[j + 0] = mapRGB[i][0];\n    data[j + 1] = mapRGB[i][1];\n    data[j + 2] = mapRGB[i][2];\n    data[j + 3] = MAP_RGB_COL_MAX;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcduta/programming/reaction-diffusion/src/renderer/1"}
{"code": "for (i = 0, k = 0; i < count; i++)\n  if (status[i])\n{\n  if (i > k)\n  {\n    pA[k] = pA[i];\n    pB[k] = pB[i];\n  }\n\n  k++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pabloinigoblasco/lukas-kanade-openmp-sse2/lukas-kanade-openmp-sse2/Codigo/cv/src/cvlkpyramid/9"}
{"code": "for (int i = 0; i < (LENGTH + RADIUS); i++)\n  a[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/stencil1d-omp/stencil_1d/0"}
{"code": "for (int k = 0; k < (0x01 << 16); k++)\n{\n  dx[k] = DRAND();\n  dy[k] = DRAND();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/seiji19761225/mandelbrot/05.adaptive_antialiasing/02.cpu_vector/mandelbrot/1"}
{"code": "for (i = 0; i < r; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    printf(\"Reg: %d - Cid %d:menor: %.0lf, maior:%.0lf, mediana:%.2lf, media:%.2lf e DP:%.2lf\\n\", i, j, menor[(i * c) + j], maior[(i * c) + j], mediana[(i * c) + j], media[(i * c) + j], dp[(i * c) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-zanetti/Metricas-Estatisticas-OpenMP-C/parallel_mestatisticas_openmp/14"}
{"code": "for (int x = 0; x < MAP_SIZE; x++)\n{\n  for (int y = 0; y < MAP_SIZE; y++)\n  {\n    target[x][y][0] = image[((x * MAP_SIZE) + y) * 4];\n    target[x][y][1] = image[(((x * MAP_SIZE) + y) * 4) + 1];\n    target[x][y][2] = image[(((x * MAP_SIZE) + y) * 4) + 2];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dan-Yeh/Parallel-Programming/A_Star_Navigator/VideoOutput/2"}
{"code": "for (int i = 0; i < LIMIT; i++)\n{\n  avg += A[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jrengdahl/bmomp/omp5/0"}
{"code": "for (int i = 0; i < 2; ++i)\n  ratio[i] = (((float) (cur[i] - old[i])) * 100) / old[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/coarsening/9"}
{"code": "for (i = 0; i < max_num_threads; i++)\n{\n  free(arr[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JingruGao09/OpenMP_Performance/histogram_creative/histo_creative/3"}
{"code": "for (int i = 0; i < 102400; i++)\n{\n  res += vecC[i] * vecB[i];\n}\n\n", "pragma": "omp target teams distribute parallel for reduction(+:res)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/summerschool/gpu-openmp/sum-dot/solution/sum-dot/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  val = 0.0;\n  for (int j = 0; j < n; j++)\n  {\n    val += A[i][j] * x[j];\n  }\n\n  val -= b[i];\n  error += pow(val, 2.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DelSquared/OpenMP-Matrix-Multiplication-Parallelisation-Comarison/Parallel/Parallel/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  m[i] = (((pmax[i] - ss[i]) + q[i]) + ((smax[i] - ps[i]) + q[i])) - q[i];\n  max_sum = (i == 0) ? (m[i]) : ((m[i] > max_sum) ? (m[i]) : (max_sum));\n}\n\n", "pragma": "\t#pragma omp for schedule(static,chunk) reduction(max:max_sum)  ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rodrigogbranco/extendedmss/seq1d_perumalla_openmp/6"}
{"code": "for (p = &buf[3]; p <= (&buf[63]); p += 2)\n  p[-2] = 6;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-5/1"}
{"code": "for (int j = 0; j < ((int) pJ->GetY()); j++)\n{\n  for (int i = 0; i < ((int) pJ->GetX()); i++)\n  {\n    if (!pJ->GetValue(i, j).isCond2D(CT_SOLID_2D))\n    {\n      if (pJ->GetValue(i, j).isCond2D(CT_WALL_LAW_2D) || pJ->GetValue(i, j).isCond2D(CT_WALL_NO_SLIP_2D))\n      {\n        ij.SetXY(i, j);\n        WallNodes->AddElement(&ij);\n      }\n\n    }\n\n  }\n\n  if (isPrint == 1)\n  {\n    ((((*f_str) << \"Scan \") << ((100 * j) / MaxY)) << \"% nodes\\r\") << flush;\n  }\n  else\n    if (isPrint == 2)\n  {\n    ((((*f_str) << \"Scan \") << ((100 * j) / MaxY)) << \"% nodes\\n\") << flush;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergeas67/OpenHyperFLOW2D/OpenHyperFLOW2D/libDEEPS2D/deeps2d_core/8"}
{"code": "for (int i = 0; i < 10; ++i)\n  ;\n\n", "pragma": "  #pragma omp target teams distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/target_teams_distribute_parallel_for_simd_messages/0"}
{"code": "for (int i = 0; i < buffer_arr[6]; i++)\n{\n  for (int j = 0; j < buffer_arr[7]; j++)\n  {\n    tempo_arr[top] = vect[i][j];\n    top++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/4"}
{"code": "for (i = 2; i < (f + 3); i++)\n  for (j = d + 1; j >= 0; j--)\n  for (k = 0; k < d; k++)\n  for (l = 0; l < (d + 2); l++)\n{\n  if (!e)\n    abort();\n\n}\n\n\n\n\n", "pragma": "omp for collapse(2) ordered(4) lastprivate (i, j, k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/doacross-2/0"}
{"code": "for (int i = left; i <= right; i++)\n{\n  if (dist(v[i], target) < b)\n  {\n    index = i;\n    printf(\"index = %d io sono %d \\n\", index, omp_get_thread_num());\n    b = dist(v[index], target);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Francesc0rtu/Parallel-kd-tree/test/04-for/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    a[(i * n) + j] = (n * i) + (j + 1);\n    if (j > i)\n    {\n      u[(i * n) + j] = a[(i * n) + j];\n      l[(i * n) + j] = 0.0;\n    }\n    else\n      if (j == i)\n    {\n      u[(i * n) + j] = a[(i * n) + j];\n      l[(i * n) + j] = 1.0;\n    }\n    else\n    {\n      u[(i * n) + j] = 0.0;\n      l[(i * n) + j] = a[(i * n) + j];\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NisargGB/Multi-threaded-LU-Decomposition/pthread_sections/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = 1.0;\n  b[i] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Clark0/NSCC_OpenMP/dotProd/1"}
{"code": "for (int pos = newLoc; pos < 7; pos++)\n{\n  x = temp[pos].x;\n  y = temp[pos].y;\n  if (ocean[y][x].type == 0)\n  {\n    found = 1;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JJ0421/Planet-Wa-Tor/Finale/4"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp4gbf6lcl.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/unibas-dmi-hpc/LB4OMP/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (i = 0; (fscanf(fptr, \"%d\", &age) != EOF) && (i < size); ++i)\n{\n  data[i] = age;\n  mn = min(mn, age);\n  mx = max(mx, age);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarimAboshamia/Frequency-Histogram/main/3"}
{"code": "for (j = 0; j < 3; j++)\n{\n  float sum = 0;\n  for (i = 0; i < 1000; i++)\n    sum += v[i][j];\n\n  sum /= 1000;\n  for (i = 0; i < 1000; i++)\n    v[i][j] -= sum;\n\n  sum = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/fjc/4"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vSoundSpeed[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/55"}
{"code": "for (i = MM - 1; i >= m1; i--)\n{\n  z[j3[i][1]][j2[i][1]][j1[i][1]] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/26"}
{"code": "for (j = 1; j <= ((grid_points[1] - 1) - 1); j += 1)\n{\n  for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((u[i - 2][j][k][m] - (4. * u[i - 1][j][k][m])) + (5.0 * u[i][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/91"}
{"code": "for (i = 0; i < ((int) n_a); i++)\n{\n  result[i] = a[i] * (*b);\n}\n\n", "pragma": "omp parallel for default(none) private(i) shared(a, n_a, b, n_b, result) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanbgd/Matrices-C/matrices_1d_openmp/19"}
{"code": "for (i = 1; i < (N - 1); i++)\n  for (j = 1; j < (N - 1); j++)\n{\n  nbrs = ((((((previous[i + 1][j + 1] + previous[i + 1][j]) + previous[i + 1][j - 1]) + previous[i][j - 1]) + previous[i][j + 1]) + previous[i - 1][j - 1]) + previous[i - 1][j]) + previous[i - 1][j + 1];\n  if ((nbrs == 3) || ((previous[i][j] + nbrs) == 3))\n    current[i][j] = 1;\n  else\n    current[i][j] = 0;\n\n}\n\n\n", "pragma": "omp parallel for shared(N, previous, current) private(i, j, nbrs)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PanosAntoniadis/pps-ntua/Lab1/ex1/parallel/GoL_p/0"}
{"code": "for (c1 = 0; c1 <= (n + (-1)); c1++)\n{\n  for (c2 = 0; c2 <= (n + (-1)); c2++)\n  {\n    X[c1][c2] = ((((double) c1) * (c2 + 1)) + 1) / n;\n    A[c1][c2] = ((((double) c1) * (c2 + 2)) + 2) / n;\n    B[c1][c2] = ((((double) c1) * (c2 + 3)) + 3) / n;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1 ,c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB043-adi-parallel-no/0"}
{"code": "for (size_t i = 0; i < data_size; ++i)\n{\n  for (size_t d = 0; d < dimensions; ++d)\n  {\n    centroids[clusters[i]][d] += data[i][d];\n  }\n\n  ++clusters_sizes[clusters[i]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shubhamwattamwar94/Implementation-of-K-Means-Clustering-Algorithm-using-Parallel-Computation-Cluster/kmeans/5"}
{"code": "for (i = 0; i < 7; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/3"}
{"code": "for (int i = 0; i < N; ++i)\n  maxi = max(maxi, min_per_row[i]);\n\n", "pragma": "\t#pragma omp parallel for schedule(static) reduction(max:maxi)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pchenik/OpenMP_Tasks/Task9/main/0"}
{"code": "for (i = 0; i < 8192; i++)\n{\n  x1[i] = ((float) i) / 8192;\n  x2[i] = (((float) i) + 1) / 8192;\n  y1[i] = (((float) i) + 3) / 8192;\n  y2[i] = (((float) i) + 4) / 8192;\n  for (j = 0; j < 8192; j++)\n    A[(i * 8192) + j] = (((float) i) * j) / 8192;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/6"}
{"code": "for (i = 0; i < 8; i++)\n  if (((((x + dC[i][0]) <= 7) && ((x + dC[i][0]) >= 0)) && ((y + dC[i][1]) <= 7)) && ((y + dC[i][1]) >= 0))\n  if ((conf.mat[x + dC[i][0]][y + dC[i][1]] * mode) == 'c')\n  return 1;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/6"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  int x = vec[i];\n  int found = 0;\n  for (int j = 0; j < 10000; j++)\n  {\n    if (x == copy[j])\n    {\n      found = 1;\n      copy[j] = -1;\n      break;\n    }\n\n  }\n\n  if (!found)\n  {\n    printf(\"Vectorul rezultat nu e acelasi cu cel original!\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/florin-alistar/AlistarSerbanFlorin_Tema1_OpenMP/radix/5"}
{"code": "for (int it = 0; it < learning_set_count; ++it)\n{\n  ((((cout << \"to: \") << learning_set[it].str()) << \" is: \") << learning_set[it].dist) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bartekmp/AW_KNN/AW_1/main_fast2/2"}
{"code": "for (int i = 0; i < shared_params[SEQ_PER_PROC_POSIT]; i++)\n{\n  MPI_Send(pref_sum_arr[i], shared_params[SEQ_LEN_POSIT], MPI_DOUBLE, MASTER_PROC_RANK, TAG, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/15"}
{"code": "for (int ColN = 0; ColN < Cols; ColN++)\n{\n  double Factor = (StdVec[ColN] == 0.0) ? (1.0) : (StdVec[ColN].Val);\n  LinComb(1.0 / Factor, Mat, ColN, ((-1.0) * MeanVec[ColN]) / Factor, Ones, TempRes);\n  for (int RowN = 0; RowN < Rows; RowN++)\n  {\n    Res.At(RowN, ColN) = TempRes[RowN];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/31"}
{"code": "for (int i = 1; i < (g_populationSize / 2); i++)\n{\n  selectParents(&fatherIndex, &motherIndex);\n  spawn = performCrossover(fatherIndex, motherIndex);\n  mutate(spawn);\n  newPopulation[i * 2] = spawn[0];\n  newPopulation[(i * 2) + 1] = spawn[1];\n  spawn.empty();\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jontelarsson94/OpenMPGeneticAlgorithm/MainWithOpenMP/main/6"}
{"code": "for (i = 0; i < 40; i++)\n  pi += sum[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/pi_omp/1"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  sum += arr[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ishanjogalekar/Parallel-distributed-computing-programs/Programs/array2/0"}
{"code": "for (int i = 0; i < A.Rows; i++)\n{\n  for (int j = 0; j < BT.Cols; j++)\n  {\n    float sum = 0.0f;\n    for (int k = 0; k < A.Cols; k++)\n    {\n      sum += arrayA[i][k] * arrayBT[j][k];\n    }\n\n    arrayC[i][j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/haniyeka/Parallel-Programming/Assignment3/Prob3/Prob3/Parallel/3"}
{"code": "for (i = 1; i < (n - 1); i += 2)\n{\n  if (a[i] > a[i + 1])\n  {\n    tmp = a[i + 1];\n    a[i + 1] = a[i];\n    a[i] = tmp;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timbo-rafa/parallel_programming/count_sort/count_sort_paralelo/1"}
{"code": "for (i = 0; i <= 16; i++)\n{\n  if (i == 0)\n  {\n    chaveCD56[i] = chaveC16[i];\n    chaveCD56[i] = chaveCD56[i] << 28;\n    chaveCD56[i] = chaveCD56[i] | chaveD16[i];\n    continue;\n  }\n\n  if ((((i == 1) || (i == 2)) || (i == 9)) || (i == 16))\n  {\n    chaveC16[i] = rotateleft(chaveC16[i - 1], 28, 1) & 0xFFFFFFF;\n    chaveCD56[i] = chaveC16[i];\n    chaveCD56[i] = chaveCD56[i] << 28;\n    chaveD16[i] = rotateleft(chaveD16[i - 1], 28, 1) & 0xFFFFFFF;\n    chaveCD56[i] = chaveCD56[i] | chaveD16[i];\n  }\n  else\n  {\n    chaveC16[i] = rotateleft(chaveC16[i - 1], 28, 2) & 0xFFFFFFF;\n    chaveCD56[i] = chaveC16[i];\n    chaveCD56[i] = chaveCD56[i] << 28;\n    chaveD16[i] = rotateleft(chaveD16[i - 1], 28, 2) & 0xFFFFFFF;\n    ;\n    chaveCD56[i] = chaveCD56[i] | chaveD16[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brNX/DES/DES/3"}
{"code": "for (i = 1; i < (m - 1); i++)\n  for (j = (i + 1) % 2; j < ((n / 2) - (i % 2)); j++)\n{\n  v = 0.25 * (((black[i - 1][j] + black[i + 1][j]) + black[i][j - ((i + 1) % 2)]) + black[i][j + (i % 2)]);\n  if (diff < fabs(v - red[i][j]))\n    diff = fabs(v - red[i][j]);\n\n  red[i][j] = v;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/glgerard/HeatedPlate2D/src/RedBlack_GaussSeidel/15"}
{"code": "for (i = 0; i < k; i++)\n{\n  clusters_arr[i].x = points_arr[i].x;\n  clusters_arr[i].y = points_arr[i].y;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stefani237/K-MEANS/Initial/func/2"}
{"code": "for (int k = 0; k < N; k++)\n{\n  for (j = 0; j < N; j++)\n  {\n    for (i = 0; i < N; i++)\n    {\n      val = ((double) random()) / RAND_MAX;\n      fill_array3d(array, N, i, j, k, val);\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i, j, val)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/src/multigrid/0"}
{"code": "for (int i = 0; i < 800; i++)\n  input[i] = (double) ((10 - (rand() % 10)) * 0.01);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShamsArfeen/ANN-OpenMP-OpenACC-MPI/ann_mpi_omp/8"}
{"code": "for (i = ibeg; i <= ifin; i++)\n{\n  iglob = i;\n  for (k = ki1; k <= ki2; k++)\n  {\n    phi2[i][k] = 0.40e+00 * (u[i][jfin][k][4] - ((0.50 * (((u[i][jfin][k][1] * u[i][jfin][k][1]) + (u[i][jfin][k][2] * u[i][jfin][k][2])) + (u[i][jfin][k][3] * u[i][jfin][k][3]))) / u[i][jfin][k][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/LU/lu_single/16"}
{"code": "for (col = 0; col <= (public.in2_sub2_sqr_cols - 1); col += 1)\n{\n  for (row = 0; row <= (public.in2_sub2_sqr_rows - 1); row += 1)\n  {\n    ori_row = (row + public.in2_sub_cumh_sel_rowlow) - 1;\n    ori_col = (col + public.in2_sub_cumh_sel_collow) - 1;\n    temp = private.d_in2_sub[(ori_col * public.in2_sub_rows) + ori_row];\n    ori_row = (row + public.in2_sub_cumh_sel2_rowlow) - 1;\n    ori_col = (col + public.in2_sub_cumh_sel2_collow) - 1;\n    temp2 = private.d_in2_sub[(ori_col * public.in2_sub_rows) + ori_row];\n    temp2 = temp - temp2;\n    private.d_in2_sub2_sqr[(col * public.in2_sub2_sqr_rows) + row] = temp2 * temp2;\n    private.d_conv[(col * public.in2_sub2_sqr_rows) + row] = private.d_conv[(col * public.in2_sub2_sqr_rows) + row] - ((temp2 * in_final_sum) / public.in_mod_elem);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/16"}
{"code": "for (i = 0; i < cM->columns; i++)\n{\n  cM->NoneZero[i] = &b2[nTotalNoneZero];\n  nTotalNoneZero += cM->nNoneZero[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mapa17/teacup/teacup_tools/12"}
{"code": "for (int rank = 0; rank < mpisize; rank++)\n{\n  int shift_ii = (rank % size_per_dim) * (N + 1);\n  int shift_jj = ((rank / size_per_dim) % size_per_dim) * (N + 1);\n  int shift_kk = (rank / (size_per_dim * size_per_dim)) * (N + 1);\n  for (int kk = 0; kk < (N + 2); kk++)\n  {\n    for (int jj = 0; jj < (N + 2); jj++)\n    {\n      for (int ii = 0; ii < (N + 2); ii++)\n      {\n        recv_residual[((ii + (jj * (N + 2))) + ((kk * (N + 2)) * (N + 2))) + (rank * oldsize)] = e_2h[((ii + shift_ii) + ((jj + shift_jj) * (N0 + 2))) + (((kk + shift_kk) * (N0 + 2)) * (N0 + 2))];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/multigrid/4"}
{"code": "for (j = itn; j < nxh; j++)\n{\n  dkx = dnx * ((float) j);\n  afdt = adt * cimagf(ffc[j]);\n  zt1 = (-cimagf(exyz[2 + (4 * j)])) + (crealf(exyz[2 + (4 * j)]) * _Complex_I);\n  zt2 = (-cimagf(exyz[1 + (4 * j)])) + (crealf(exyz[1 + (4 * j)]) * _Complex_I);\n  zt5 = bxyz[1 + (4 * j)] + (dth * (dkx * zt1));\n  zt6 = bxyz[2 + (4 * j)] - (dth * (dkx * zt2));\n  zt1 = (-cimagf(zt6)) + (crealf(zt6) * _Complex_I);\n  zt2 = (-cimagf(zt5)) + (crealf(zt5) * _Complex_I);\n  zt8 = (exyz[1 + (4 * j)] - (cdt * (dkx * zt1))) - (afdt * cu[1 + (4 * j)]);\n  zt9 = (exyz[2 + (4 * j)] + (cdt * (dkx * zt2))) - (afdt * cu[2 + (4 * j)]);\n  zt1 = (-cimagf(zt9)) + (crealf(zt9) * _Complex_I);\n  zt2 = (-cimagf(zt8)) + (crealf(zt8) * _Complex_I);\n  exyz[4 * j] = zero;\n  exyz[1 + (4 * j)] = zt8;\n  exyz[2 + (4 * j)] = zt9;\n  at1 = anorm * ((zt8 * conjf(zt8)) + (zt9 * conjf(zt9)));\n  ws += (double) at1;\n  zt5 += dth * (dkx * zt1);\n  zt6 -= dth * (dkx * zt2);\n  bxyz[4 * j] = zero;\n  bxyz[1 + (4 * j)] = zt5;\n  bxyz[2 + (4 * j)] = zt6;\n  at1 = anorm * ((zt5 * conjf(zt5)) + (zt6 * conjf(zt6)));\n  wp += (double) at1;\n  bxyz[4 * (j + k1)] = zero;\n  bxyz[1 + (4 * (j + k1))] = zero;\n  bxyz[2 + (4 * (j + k1))] = zero;\n  exyz[4 * (j + k1)] = zero;\n  exyz[1 + (4 * (j + k1))] = zero;\n  exyz[2 + (4 * (j + k1))] = zero;\n  bxyz[4 * (j + l1)] = zero;\n  bxyz[1 + (4 * (j + l1))] = zero;\n  bxyz[2 + (4 * (j + l1))] = zero;\n  exyz[4 * (j + l1)] = zero;\n  exyz[1 + (4 * (j + l1))] = zero;\n  exyz[2 + (4 * (j + l1))] = zero;\n  bxyz[4 * ((j + k1) + l1)] = zero;\n  bxyz[1 + (4 * ((j + k1) + l1))] = zero;\n  bxyz[2 + (4 * ((j + k1) + l1))] = zero;\n  exyz[4 * ((j + k1) + l1)] = zero;\n  exyz[1 + (4 * ((j + k1) + l1))] = zero;\n  exyz[2 + (4 * ((j + k1) + l1))] = zero;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/53"}
{"code": "for (rowIndex_2 = 0; rowIndex_2 < rows; rowIndex_2++)\n{\n  for (columnIndex_2 = 0; columnIndex_2 < columns; columnIndex_2 += columns - 1)\n  {\n    matrix[(rowIndex_2 * columns) + columnIndex_2] = createInvalidCell();\n  }\n\n}\n\n", "pragma": "omp for schedule(static) private(rowIndex_2, columnIndex_2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MerendaFrancoN/SSDyP-GameOfLife/src/base_utils/matrix_utils/1"}
{"code": "for (int i = 0; i < MAX; i++)\n{\n  sum_p += A[i] * B[i];\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+:sum_p)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nghialuffy/OpenMP-Exercises/Bai6/Bai6/1"}
{"code": "for (i = 0; i < ncommpartner; i++)\n{\n  const int dest = commpartner[i];\n  const int sendcount = comap->sendcount[dest];\n  if (sendcount > 0)\n  {\n    int *sendindex = comap->sendindex[dest];\n    for (j = 0; j < sendcount; j++)\n      for (col = 0; col < ncols; col++)\n      sendbuf[i][(j * ncols) + col] = mat[sendindex[j]][col];\n\n\n  }\n\n}\n\n", "pragma": "omp for COMM_SCHEDULE", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/MPI_OpenMP_threads/linsolv/src/exchange_matrix/0"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  printf(\"i=%d a[%d]=%d\\n\", i, i, a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB024-simdtruedep-orig-yes/2"}
{"code": "for (i = 0; i < tamanho; i++)\n  vetor[i] = b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denisrosas/openmp/radixsort/1"}
{"code": "for (i = 0; i < 1024; i++)\n  a[i] = (i & 31) + (i / 128);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-6/1"}
{"code": "for (int nThread = 1; nThread <= 4; nThread++)\n{\n  printf(\"Number of Threads: %d \\n\", nThread);\n  omp_set_num_threads(nThread);\n  naiveMultiplication(1000);\n  blockMultiplication(1000);\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshan14/matrix-multiplication-openMP/MatrixMultiplication/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = aptr;\n  aptr += n;\n  for (j = 0; j < n; ++j)\n  {\n    a[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Cathy272272272/Comparision-among-serial-pthread-and-OpenMP-via-Julia-Set/OpenMp/2"}
{"code": "for (int i = 0; i < N; i++)\n  visited[i + offset] = temp[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deevashwer/Heterogeneous-GPU-Connected-Components/OpenCL-Implementation/Heterogeneous-OpenCL/1"}
{"code": "for (i = 0; i < (n / 16); i++)\n  U[i][i] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/1"}
{"code": "for (c2 = nm; c2 <= (nj + (-1)); c2++)\n{\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/71"}
{"code": "for (int i = -2; i <= 2; i++)\n{\n  for (int j = -2; j <= 2; j++)\n  {\n    double temp_res = 1 / (((((5 * (i + 2)) + j) + 3) + pow(x - (16 * j), 6)) + pow(y - (16 * i), 6));\n    result += abs(temp_res);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dubovyk/OpenMP_integrate/main/0"}
{"code": "for (j = 0; j < height; j++)\n{\n  for (i = 0; i < width; i++)\n  {\n    red = (gre = (blu = 0));\n    for (k = -n; k <= n; k++)\n    {\n      for (l = -n; l <= n; l++)\n      {\n        if (((((i + k) >= 0) && ((i + k) < width)) && ((j + l) >= 0)) && ((j + l) < height))\n        {\n          p = &pixel[((j + l) * width) + (i + k)];\n          red += p->rgb.r;\n          gre += p->rgb.g;\n          blu += p->rgb.b;\n        }\n\n      }\n\n    }\n\n    p = &pixels[(j * width) + i];\n    p->rgb.r = red / (((2 * n) + 1) * ((2 * n) + 1));\n    p->rgb.g = gre / (((2 * n) + 1) * ((2 * n) + 1));\n    p->rgb.b = blu / (((2 * n) + 1) * ((2 * n) + 1));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WalrusNine/Trab02-Grupo01-B/Trab02-Grupo01-B/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    if (A[i][j] != B[i][j])\n    {\n      same = false;\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/cpu_parallel_convolution/6"}
{"code": "for (int i = 0; i < size; i++)\n  printf(\"x[%d]: %f\\n\", i, x[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bikashtudu/LU-Factorisation/LU_Parallel/18"}
{"code": "for (n = 0; n < Nopt; n++)\n{\n  m = maturities[n] - 1;\n  swapval = (B[m] + (swaprates[n] * S[m])) - 1.f;\n  if (swapval < 0)\n  {\n    v += (-100.f) * swapval;\n    S_b[m] += (-100.f) * swaprates[n];\n    B_b[m] += -100.f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/libor-omp/main/6"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((5.0 * u[i][j][k][m]) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/116"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp0ky3znba.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/exaloop/openmp/runtime/test/affinity/format/affinity_values/0"}
{"code": "for (int j = 0; j < ((int) thr0); j++)\n{\n  result[thr1 + counter1] = res1[j];\n  counter1++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmitrygx/OpenMP_MPI_Radix_Sort/OMP_MPI_Task6/sort/8"}
{"code": "for (int i = 0; i < ((int) imageSize[box]); i++)\n{\n  cosMolRef[*thisMol][i] = 0.0;\n  sinMolRef[*thisMol][i] = 0.0;\n  for (uint j = 0; j < thisKind.NumAtoms(); j++)\n  {\n    if (particleHasNoCharge[startAtom + j])\n    {\n      continue;\n    }\n\n    double dotProduct = Dot(mols.MolStart(*thisMol) + j, kx[box][i], ky[box][i], kz[box][i], molCoords);\n    cosMolRef[*thisMol][i] += thisKind.AtomCharge(j) * cos(dotProduct);\n    sinMolRef[*thisMol][i] += thisKind.AtomCharge(j) * sin(dotProduct);\n  }\n\n  sumRnew[box][i] += lambdaCoef * cosMolRef[*thisMol][i];\n  sumInew[box][i] += lambdaCoef * sinMolRef[*thisMol][i];\n}\n\n", "pragma": "      #pragma omp parallel for default(none) shared(box, lambdaCoef, molCoords, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/EwaldCached/1"}
{"code": "for (int i = 0; i < num_threads; i++)\n{\n  long long window_value = 0;\n  long long msd = 1;\n  for (int j = 0; j < k; j++)\n  {\n    window_value *= 4;\n    window_value += value(line[(i * read) + j]);\n    msd *= 4;\n  }\n\n  msd /= 4;\n  while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n  {\n    ;\n  }\n\n  for (int j = (i * read) + 1; j < min((i + 1) * read, (len_line - k) + 1); j++)\n  {\n    window_value -= value(line[j - 1]) * msd;\n    window_value *= 4;\n    window_value += value(line[(j + k) - 1]);\n    while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n    {\n      ;\n    }\n\n  }\n\n  if (i == (num_threads - 1))\n  {\n    for (int j = min((i + 1) * read, (len_line - k) + 1); j < ((len_line - k) + 1); j++)\n    {\n      window_value -= value(line[j - 1]) * msd;\n      window_value *= 4;\n      window_value += value(line[(j + k) - 1]);\n      while (!compare_and_swap(&hash_map[window_value], hash_map[window_value], hash_map[window_value] + 1))\n      {\n        ;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(guided, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atharva1707/K-mer-counting-using-Bloom-filter/main/1"}
{"code": "for (long pidx_darts_counter_temp896 = *pidx; (pidx_darts_counter_temp896 < endRange) && (pidx_darts_counter_temp896 < this->inputsTPParent->lastIteration896); pidx_darts_counter_temp896++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp896], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/30"}
{"code": "for (int i = 1; i < k; i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    n_cells[task_id] = ((long) local_genes_len[i]) * ((long) local_genes_len[j]);\n    total_cells += n_cells[task_id];\n    task_id++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing5/test/2"}
{"code": "for (int i = 1; i < (ny - 1); i++)\n  vector[nx - 2][i][nz - 2] += vector[nx - 1][i][nz - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/26"}
{"code": "for (i = 0; i < n; i++)\n{\n  accuracy += pow(mean_m[i] - estimatedValue, 2) / (n * (n - 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtchaos/C-Python_class_exercise/numerical_calculation/2D_Ising_model/parallel_metropolice_montecarlo2/1"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  x[i] = ((double) rand()) / 32767;\n  y[i] = ((double) rand()) / 32767;\n}\n\n", "pragma": "omp for ordered schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fmorenovr/ComputerScience_UNI/CC301-Algoritmos_Paralelos/Clase_8/Ejercicio_3/piMontecarlo_openmp/0"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  if (i == 4)\n    continue;\n\n  currentCell = neighbors[i];\n  if (currentCell.state != STATE_INVALID)\n    neighborsSize++;\n\n  if (currentCell.state == STATE_RED)\n    contagiousCellsProportion += 1.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MerendaFrancoN/SSDyP-GameOfLife/src/hybrid_openmp_mpi/matrix_MPI_OpenMP/2"}
{"code": "for (k = 0; k < ny; k++)\n{\n  for (j = 0; j < nx; j++)\n  {\n    for (i = 0; i < ndim; i++)\n    {\n      amu[i + (ndim * (j + (nxe * k)))] += amu[(i + (ndim * (j + (nxe * k)))) + (nnxye * nz)];\n      amu[(i + (ndim * (j + (nxe * k)))) + (nnxye * nz)] = 0.0;\n    }\n\n  }\n\n  for (i = 0; i < ndim; i++)\n  {\n    amu[i + ((ndim * nxe) * k)] += amu[(i + (ndim * (nx + (nxe * k)))) + (nnxye * nz)];\n    amu[(i + (ndim * (nx + (nxe * k)))) + (nnxye * nz)] = 0.0;\n  }\n\n}\n\n", "pragma": "omp for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/1"}
{"code": "for (i = 0; i < world->num_bodies; i++)\n{\n  for (j = 0; j < world->num_bodies; j++)\n  {\n    if (i == j)\n    {\n      continue;\n    }\n\n    diff_x = world->bodies[j].x - world->bodies[i].x;\n    diff_y = world->bodies[j].y - world->bodies[i].y;\n    d = sqrt((diff_x * diff_x) + (diff_y * diff_y));\n    if (d < 25)\n    {\n      d = 25;\n    }\n\n    d_cubed = (d * d) * d;\n    force_x[i] += (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_x;\n    force_y[i] += (10.0 * ((world->bodies[i].m * world->bodies[j].m) / d_cubed)) * diff_y;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) shared(world,force_x,force_y) private(diff_x,diff_y,d,d_cubed,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YuanshengHu/Parallel-and-Distributed-Programming/2/nbody_openMP/0"}
{"code": "for (it = 0; it < num_its; it++)\n{\n  int ix;\n  int iy;\n  int ir;\n  for (ix = 0; ix < n; ix++)\n  {\n    for (iy = 0; iy < m; iy++)\n    {\n      int offset = (((ix + radius) * u_dimY) + radius) + iy;\n      REAL *temp_u = &u[offset];\n      REAL *temp_uold = &uold[offset];\n      REAL result = temp_uold[0] * coeff[0];\n      for (ir = 1; ir <= radius; ir++)\n      {\n        result += coeff[ir] * temp_uold[ir];\n        result += coeff[-ir] * temp_uold[-ir];\n        result += coeff[(-ir) * coeff_dimX] * temp_uold[(-ir) * u_dimY];\n        result += coeff[ir * coeff_dimX] * temp_uold[ir * u_dimY];\n      }\n\n      *temp_u = result / count;\n    }\n\n  }\n\n  REAL *tmp = uold;\n  uold = u;\n  u = tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/stencil2d/stencil2d/2"}
{"code": "for (i = 0; i < vec.size(); i++)\n{\n  sum += vec[i];\n  sum_red++;\n}\n\n", "pragma": "    #pragma omp parallel for shared(sum) reduction(+: sum_red)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LuckThemAll/parallel-programming/OpenMP/task2/2"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  x[i] = x0 + (i * dx);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/svretina/OpenMP-projects/wave/0"}
{"code": "for (int i = 1; i < (ny - 1); i++)\n  vector[nx - 2][i][1] += vector[nx - 1][i][0];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/29"}
{"code": "for (i = 0; i < threads; i++)\n{\n  tarr[i] = (i * size) / threads;\n  tarr[threads] = size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Prashanth-Billa/CREW-Sort-OpenMP/CREWSORT/7"}
{"code": "for (; i < ie; i++)\n{\n  Add(data()[i], vec1.hi[i], vec1.lo[i], (-1) * vec2.data()[i], (-1) * 0.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/t-hishinuma/DD-AVX_v3/src/vector/arithmetic/vector_sub_d/2"}
{"code": "for (int i = 0; i < I.n_source_regions_per_node; i++)\n{\n  Source *src = &params.sources[i];\n  float adjust = (((norm_factor * 4) * M_PI) * I.fai) / src->vol;\n  for (int k = 0; k < I.fai; k++)\n    for (int g = 0; g < I.n_egroups; g++)\n    src->fine_flux[k][g] *= adjust;\n\n\n}\n\n", "pragma": "omp parallel for default(none) shared(I, params) private(norm_factor) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/3"}
{"code": "for (j = 0; j < c; j++)\n{\n  if (weight[0] > j)\n  {\n    total[0][j] = 0;\n    use[0][j] = 0;\n  }\n  else\n  {\n    total[0][j] = profit[0];\n    use[0][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pengjuntc/knapsack-openmp/knap_para/6"}
{"code": "for (i = 0; i < 5; i++)\n  printf(\"i :%d THREAD :%d\\n\", i, omp_get_thread_num());\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sheetal804/Parallel-Processing-Repo/HiPC Data/16_49 25-05-2014/HiPC Data/praveen/Untitled Folder/Praveen/codes/parallel/DIRECTIVE/single/0"}
{"code": "for (i = 0; i < N; i++)\n  printf(\"%5d\", G[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMPsearchP2P/2"}
{"code": "for (j = 1; j <= nodesCount; ++j)\n{\n  if ((distance[k][j] != (-1)) && ((distance[i][j] == (-1)) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n  {\n    distance[i][j] = distance[i][k] + distance[k][j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Serena-Chenzz/openmp_project1A/para_static/1"}
{"code": "for (size_t index = fluidStartIndex; index < fluidEndIndex; index++)\n{\n  size_t rnSz = 0;\n  size_t rsSz = 0;\n  size_t lnSz = 0;\n  size_t lsSz = 0;\n  size_t nrSz = 0;\n  size_t nlSz = 0;\n  size_t srSz = 0;\n  size_t slSz = 0;\n  size_t neiListStartIndex = index * maxNeiNum;\n  size_t neiListEndIndex = neiListStartIndex + neighbourListSize[index];\n  double x0 = positionX[index];\n  double y0 = positionY[index];\n  for (size_t i = neiListStartIndex; i < neiListEndIndex; i++)\n  {\n    size_t neiIndex = neighbourList[i];\n    double x1 = positionX[neiIndex];\n    double y1 = positionY[neiIndex];\n    setListInOneDir2D(neiIndex, x0, x1, y0, y1, rn, rnSz, rs, rsSz, ln, lnSz, ls, lsSz);\n    setListInOneDir2D(neiIndex, y0, y1, x0, x1, nr, nrSz, nl, nlSz, sr, srSz, sl, slSz);\n  }\n\n  setListInOneDir2D(index, maxNeiNumInOneDir, rn, rnSz, rs, rsSz, neighbourListRight, neighbourListRightSize);\n  setListInOneDir2D(index, maxNeiNumInOneDir, ln, lnSz, ls, lsSz, neighbourListLeft, neighbourListLeftSize);\n  setListInOneDir2D(index, maxNeiNumInOneDir, nr, nrSz, nl, nlSz, neighbourListNorth, neighbourListNorthSize);\n  setListInOneDir2D(index, maxNeiNumInOneDir, sr, srSz, sl, slSz, neighbourListSouth, neighbourListSouthSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/13"}
{"code": "for (int i = 0; i < WDOT_SIZE; i++)\n{\n  host_molwt[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/s3d-omp/S3D/1"}
{"code": "for (int i = 0; i < 4000000; i++)\n{\n  a[i] = ((float) rand()) / 32767;\n  b[i] = ((float) rand()) / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/koiking213/openmp_benchmark/add_contiguous/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k += 1)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/54"}
{"code": "for (int i = 0; i < nsegments; i++)\n{\n  fscanf(fp, \"%d\", &ilvecshare[i]);\n  printf(\"ilvecshare[%d] = %d\\n\", i, ilvecshare[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdafibuzzaman/openmp-task-distributed/lobpcg_dist/7"}
{"code": "for (int i = 0; i < nprocs; i++)\n  omp_init_lock(&locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/18"}
{"code": "for (i = 0; i < file_size; i++)\n{\n  omp_set_lock(&locks[buffer[i] - 0]);\n  freq[buffer[i] - 0]++;\n  omp_unset_lock(&locks[buffer[i] - 0]);\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ChristosDeretzis/High-Performance-Computing/OpenMP/Character_Frequency/char_freq_par_locks/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  index = (i * N) + now_col;\n  if (ok(mask, i) && check_obstacle(index, obstacle))\n  {\n    local_mask = update_mask(*mask, i);\n    sol_num += fastNQueens(N, now_col + 1, obstacle, &local_mask);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/10202/fast_n_queens/1"}
{"code": "for (i = 1; i <= wf.n1; i++)\n{\n  (vector < complex) > v_1D(wf.n2 + 2), wf_1D(wf.n2 + 2);\n  for (j1 = 0; j1 < (wf.n2 + 2); j1++)\n  {\n    const int index = wf.in2(j1, i);\n    v_1D[j1] = p.ABV_V[index];\n    wf_1D[j1] = wf.wave[index];\n  }\n\n  (vector < complex) > tridag_mid(wf.n2 + 2), wf_1D_rightside(wf.n2 + 2);\n  for (j2 = 1; j2 <= wf.n2; j2++)\n  {\n    if (gauge == lengthgauge)\n    {\n      arg_B = 0.;\n      arg_V = (idt * .5) * (((-wf.x2[j2]) * field) + v_1D[j2]);\n    }\n    else\n      if (gauge == velocitygauge)\n    {\n      arg_B = f_arg_B * ((-field) * one_by_lightC_au);\n      arg_V = (idt * .5) * v_1D[j2];\n    }\n\n\n    tridag_low_Fast = arg_A - arg_B;\n    tridag_mid[j2] = (1. - (2. * arg_A)) + arg_V;\n    tridag_upp_Fast = arg_A + arg_B;\n    wf_1D_rightside[j2] = (((-tridag_low_Fast) * wf_1D[j2 - 1]) + (((1. + (2. * arg_A)) - arg_V) * wf_1D[j2])) - (tridag_upp_Fast * wf_1D[j2 + 1]);\n    if (j2 == 1)\n    {\n      if (wf.symmetry_x2 == 1)\n      {\n        tridag_mid[j2] = ((1. - arg_A) - arg_B) + arg_V;\n        wf_1D_rightside[j2] = (((-tridag_low_Fast) * wf_1D[j2 - 1]) + ((((1. + arg_A) + arg_B) - arg_V) * wf_1D[j2])) - (tridag_upp_Fast * wf_1D[j2 + 1]);\n      }\n\n      if (wf.symmetry_x2 == (-1))\n      {\n        tridag_mid[j2] = ((1. - (3. * arg_A)) + arg_B) + arg_V;\n        wf_1D_rightside[j2] = (((-tridag_low_Fast) * wf_1D[j2 - 1]) + ((((1. + (3. * arg_A)) - arg_B) - arg_V) * wf_1D[j2])) - (tridag_upp_Fast * wf_1D[j2 + 1]);\n      }\n\n    }\n\n  }\n\n  (vector < complex) > wf_1D_solution(wf.n2 + 2), gam(wf.n2 + 2);\n  Tridag_Fast(tridag_low_Fast, tridag_mid, tridag_upp_Fast, wf_1D_rightside, wf_1D_solution, gam);\n  for (j3 = 1; j3 <= wf.n2; j3++)\n  {\n    wf.wave[wf.in2(j3, i)] = wf_1D_solution[j3];\n  }\n\n}\n\n", "pragma": "    #pragma omp for private(i, j1, j2, j3, arg_V, arg_B, tridag_low_Fast, tridag_upp_Fast)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shaohao99/tdse_1plus1D/tdse_1plus1D.intel.cpu/npsflib-parallel/libsrc/Cartesian2D/6"}
{"code": "for (i = 0; i < 20; i++)\n{\n  a[i] = i;\n  b[i] = 2 * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/courspolytech/Presentation-exemplesOMP/sources/parallelfor+/1"}
{"code": "for (int i = 0; i < 992; i++)\n{\n  C[i] = 2;\n  D[i] = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-update/test/2"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/8"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 5; j++)\n  if (A[i][j].y.l[3][3] != 10)\n  abort();\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/shared-1/2"}
{"code": "for (unsigned long long nn = 1; nn < num_iter; nn++)\n{\n  for (unsigned long long i = 0; i < nel; i++)\n  {\n    areas[i + (nn * nel)] = areas[i];\n    for (unsigned long long j = 0; j < NNB; j++)\n    {\n      elements_surrounding_elements[(i + (j * nelr)) + (nn * nel)] = elements_surrounding_elements[i + (j * nelr)];\n      for (unsigned long long k = 0; k < NDIM; k++)\n        normals[(i + ((j + (k * NNB)) * nelr)) + (nn * nel)] = normals[i + ((j + (k * NNB)) * nelr)];\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/cfd/euler3d_gpu/2"}
{"code": "for (int i = 0; i < n2; ++i)\n{\n  printf(\"%d \", O[i]);\n  int x = O[i];\n  int cnt = 0;\n  for (int j = 0; (j < 10) && (info[(x * n2) + i].top[j] != (-1)); ++j)\n    ++cnt;\n\n  printf(\"%d \", cnt);\n  for (int j = 0; j < cnt; ++j)\n    printf(\"%d \", info[(x * n2) + i].top[j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziqi-zhang/Parallel-DAG-Traversal/openmp/5"}
{"code": "for (xx = -1; xx <= 1; xx++)\n{\n  for (yy = -1; yy <= 1; yy++)\n  {\n    if ((xx != 0) || (yy != 0))\n    {\n      adj += grid[((x + xx) + size) % size][((y + yy) + size) % size];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SgtSwagrid/supercomputing/02 - Conway+RDF/life/4"}
{"code": "for (l = 0; l < num_tasks; l++)\n{\n  for (i = 0; i < n_p; i++)\n  {\n    for (j = 0; j < n_p; j++)\n    {\n      for (k = 0; k < n; k++)\n      {\n        C[(j * n) + k] += A[((j * n) + i) + currentRow] * B[(i * n) + k];\n      }\n\n    }\n\n  }\n\n  if (num_tasks > 1)\n  {\n    if (rank == 0)\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, num_tasks - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, rank + 1, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n    else\n      if (rank == (num_tasks - 1))\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, rank - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, 0, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n    else\n    {\n      MPI_Sendrecv(B, n * n_p, (MPI_Datatype) 0x4c00040a, rank - 1, l, tempBuf, n * n_p, (MPI_Datatype) 0x4c00040a, rank + 1, l, (MPI_Comm) 0x44000000, &Stat);\n    }\n\n\n    if (currentRow == (n - n_p))\n    {\n      currentRow = 0;\n    }\n    else\n    {\n      currentRow += n_p;\n    }\n\n  }\n  else\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/johnboulder/PSU-CMPSC450-Parallel-Programming/CMPSC450_HW3/matmul1d/3"}
{"code": "for (int i = 0; i < numBuckets; i++)\n{\n  buckets[i] = bubbleSort(buckets[i]);\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jalexisrdv/aceleracion-bubble-sort-openmp/main/3"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i - 1][j][k]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i + 1][j][k])) + u[m][i + 2][j][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/100"}
{"code": "for (i = 0; i < (num_particles / 512); ++i)\n{\n  int j;\n  for (j = 0; j < 512; j++)\n  {\n    forces[i].x[j] = 0;\n    forces[i].y[j] = 0;\n    forces[i].z[j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_39_nbody/5"}
{"code": "for (int i = 0; i < myRows; i++)\n{\n  for (int j = 0; j < WORLD_SIZE; j++)\n  {\n    if (myWorld[i][j] == ALIVE)\n      computeNeigh(myWorld, newWorld, upper, below, i, j, myRows, windDirection, windForce);\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parrallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattNot/fireEmulation/main/2"}
{"code": "for (int f = 0; f < num_raw_features; ++f)\n{\n  spat_memoiser[f].resize(num_pixels);\n  spat_memoiser_valid[f].resize(num_pixels);\n  fill(spat_memoiser_valid[f].begin(), spat_memoiser_valid[f].end(), false);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/5"}
{"code": "for (it = 0; it < total_its; it++)\n{\n  omp_offloading_start(__off_info__);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/axpy/axpy_ompacc/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"schedule(dynamic, %d): iter %d on thread %d\\n\", chunk, i, omp_get_thread_num());\n}\n\n", "pragma": "  #pragma omp parallel for schedule(dynamic, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/base_schedule/4"}
{"code": "for (j = 0; j < 3; j++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/nesting-1/0"}
{"code": "for (int i = 0; i < length; ++i)\n{\n  this->data[i] = this->data[i] + other_mat->data[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishig25/2017Block2/project/openmp/5"}
{"code": "for (int index = 0; index < n; index++)\n{\n  if (pos_index_[index] < 0)\n    continue;\n\n  int i = index / n_cols_;\n  int j = index % n_cols_;\n  flow_out_num_[index] = 0;\n  int flow_dir = flowdir_matrix_[index];\n  if (((flow_dir & 1) && (j != (n_cols_ - 1))) && (flowdir_matrix_[index + 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if ((((flow_dir & 2) && (i != (n_rows_ - 1))) && (j != (n_cols_ - 1))) && (flowdir_matrix_[(index + n_cols_) + 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if (((flow_dir & 4) && (i != (n_rows_ - 1))) && (flowdir_matrix_[index + n_cols_] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if ((((flow_dir & 8) && (i != (n_rows_ - 1))) && (j != 0)) && (flowdir_matrix_[(index + n_cols_) - 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if (((flow_dir & 16) && (j != 0)) && (flowdir_matrix_[index - 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if ((((flow_dir & 32) && (i != 0)) && (j != 0)) && (flowdir_matrix_[(index - n_cols_) - 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if (((flow_dir & 64) && (i != 0)) && (flowdir_matrix_[index - n_cols_] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n  if ((((flow_dir & 128) && (i != 0)) && (j != (n_cols_ - 1))) && (flowdir_matrix_[(index - n_cols_) + 1] != dir_nodata_))\n  {\n    flow_out_num_[index]++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/grid_layering/GridLayering/5"}
{"code": "for (int r = 0; r < N; r++)\n{\n  for (int c = 0; c < N; c++)\n  {\n    if (grid1[r][c] < 0)\n    {\n      if (grid[r][c] >= 0)\n      {\n        destroyed_MTs++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:destroyed_MTs)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CI4822-EneMar2020/BombingField/src/0"}
{"code": "for (int ib = 0; ib < M; ib++)\n{\n  posns[ib] = ((((float) N) / 2.0) - (((float) M) / 2.0)) + ((float) ib);\n  grid[(int) round(posns[ib])] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WarwickRSE/OpenMPExamples/Solutions/Repulsion/2"}
{"code": "for (int i = 0; i < 32; i++)\n{\n  double tour = trailDistance(i);\n  if ((i == 0) || (tour < minTour))\n    minTour = tour;\n\n  double depositAmount = 100 / tour;\n  for (int j = 0; j < (10000 - 1); j++)\n    T[ants[i].trail[j]][ants[i].trail[j + 1]] += depositAmount;\n\n  T[ants[i].trail[10000 - 1]][ants[i].trail[0]] += depositAmount;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/athvasilopoulos/openmp-ML-projects/TSP/ants_parallel/8"}
{"code": "for (int i = 2; i < (n - 1); i++)\n{\n  b = createMatrix(p[i], p[i + 1], i);\n  a = matrix_mult(a, b, p[0], p[i], p[i + 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/3"}
{"code": "for (i = 0; i < N; i++)\n  printf_s(\"4: Thread: %d, a[%d] = %d\\n\", omp_get_thread_num(), i, a[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_programing_CSharp/LU9_barrierCriticalMasterOrdered/LU9/MasterAndCritical/3"}
{"code": "for (i = 0; i < num_cells; i++)\n{\n  for (j = 0; j < 3; j++)\n    cells[i].random_seq[j] = (unsigned short) nrand48(init_random_seq);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HylianPablo/Paralela2020/PRACTICA1 - OPENMP/OpenMP - Version final/backup/7"}
{"code": "for (i = 0; i < order; i++)\n{\n  pos = i * max_dim;\n  for (j = 0; j < dimensionality[i]; j++)\n  {\n    k = CountX[pos];\n    CountX[pos] = now;\n    tempX[pos++] = now;\n    now += k;\n  }\n\n  CountX[pos] = now;\n  tempX[pos] = now;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/P-Tucker/P-Tucker/2"}
{"code": "for (i = 0; i < 20; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adil-waqar/openmp/openmp/omp_workshare1/1"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  A[i] = (double *) malloc(10000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixcpy/7"}
{"code": "for (int i = 1; i < n; i++)\n{\n  if (((burst_remaining[i] > 0) && (p[i].arrival_time <= current_time)) && (mark[i] == 0))\n  {\n    q.push(i);\n    mark[i] = 1;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/rr_parallel/1"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  check_columns_fn(&i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dasosjt/openMP/SudokuValidatorPthread/3"}
{"code": "for (j = x_min - depth; j <= (x_max + depth); j++)\n{\n  #pragma ivdep\n  for (k = 1; k <= depth; k++)\n  {\n    pressure[FTNREF2D(j, 1 - k, x_max + 4, x_min - 2, y_min - 2)] = pressure[FTNREF2D(j, 0 + k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/update_halo_kernel_c/16"}
{"code": "for (unsigned i = 0; i < n; ++i)\n{\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/0"}
{"code": "for (i = 0; i < L; i++)\n  for (k = 0; k < ((250 * 1024) / 256); k++)\n  C[(i * ((250 * 1024) / 256)) + k] = ((-((float) L)) * ((250 * 1024) / 256)) * ((250 * 1024) / 256);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 2/matmul/13"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rsd[i][j][k][m] = rsd[i][j][k][m] - (ty2 * (flux[i][j + 1][k][m] - flux[i][j - 1][k][m]));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (ty2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/106"}
{"code": "for (int k = 1; k <= ((int) m_flowInIndex[id][0]); ++k)\n{\n  int flowInID = (int) m_flowInIndex[id][k];\n  if (m_streamLink[id] > 0)\n  {\n    qUp += m_q[flowInID];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/IKW_IF/InterFlow_IKW/1"}
{"code": "for (k = i + 1; k < 2000; k++)\n{\n  for (d = 2000; d >= i; d--)\n  {\n    MA[k][d] -= MA[k][i] * MA[i][d];\n  }\n\n}\n\n", "pragma": "omp for private(d)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-10/2"}
{"code": "for (size_t i = 0; i < pman.masses.size(); i++)\n{\n  basenode.addParticle(&pman.masses[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/physbuzz/galaxysim/src/main/0"}
{"code": "for (i = 0; i < no_of_vertices; i++)\n{\n  pagerank[i] *= sum;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shubham166/pagerank-clusters/02.openmp_implementaion/pagerank/3"}
{"code": "for (i = 0; i < k; i++)\n{\n  for (j = 0; j < k; j++)\n  {\n    x = i - ksize;\n    y = j - ksize;\n    kernel[i][j] = exp((-((x * x) + (y * y))) / ((2.0 * sigma) * sigma)) / sqrt(((2.0 * PI) * sigma) * sigma);\n    sum += kernel[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/Conv/0"}
{"code": "for (i = rb; i < re; i++)\n  c[1] += p_q[0][i] * p_w[1][i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/12"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    matrix_1[i][j] = i + j;\n    matrix_2[i][j] = i - j;\n    matrix_ans[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Barten74/Parallel-OpenMP-/OpenMP_task4/OpenMPtaks4/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  char buffer[seq_length[i]];\n  memcpy(buffer, genes[i].c_str(), seq_length[i]);\n  MPI_Bcast(buffer, seq_length[i], MPI_CHAR, root, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing11/p1/1"}
{"code": "for (int j = first; j < (N - 1); j += 2)\n{\n  if (A[j] > A[j + 1])\n  {\n    swap(A[j], A[j + 1]);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for default(none),shared(A,first)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/serial/par_bubble/0"}
{"code": "for (int i = 0; i < (CITIES - 1); i++)\n{\n  xd = map[a.route[i]].x - map[a.route[i + 1]].x;\n  yd = map[a.route[i]].y - map[a.route[i + 1]].y;\n  d = d + ((int) (sqrt((xd * xd) + (yd * yd)) + 0.5));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cecibrus/tp-tsp-ga/parallelize/11"}
{"code": "for (u = ((2U * 0x7fffffff) + 1) - 6; u == ((2U * 0x7fffffff) + 1); u++)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-2/7"}
{"code": "for (p = 0; p < size; p++)\n{\n  (*image_red)[p] = (unsigned char) fgetc(fp);\n  (*image_grn)[p] = (unsigned char) fgetc(fp);\n  (*image_blu)[p] = (unsigned char) fgetc(fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/21"}
{"code": "for (j = 0; j < image->height; j++)\n{\n  for (i = 0; i < image->width; i++)\n  {\n    if (grayscale)\n    {\n      fwrite(&image->pixel[(j * image->width) + i].grs.i, sizeof(unsigned char), 1, fp);\n    }\n    else\n    {\n      fwrite(&image->pixel[(j * width) + i].rgb.r, sizeof(unsigned char), 1, fp);\n      fwrite(&image->pixel[(j * width) + i].rgb.g, sizeof(unsigned char), 1, fp);\n      fwrite(&image->pixel[(j * width) + i].rgb.b, sizeof(unsigned char), 1, fp);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/WalrusNine/Trab02-Grupo01-B/Trab02-Grupo01-B/5"}
{"code": "for (i = 1; i < size; i++)\n{\n  index += D_C(NODE_N - 1, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bn-omp/kernels/9"}
{"code": "for (int i = 0; i < num_steps; i++)\n{\n  double x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bnwest/OpenMPConsoleApplication/OpenMPConsoleApplication/OpenMPConsoleApplication/0"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      s = s + (r[i3][i2][i1] * r[i3][i2][i1]);\n      double _imopVarPre444;\n      double _imopVarPre445;\n      _imopVarPre444 = r[i3][i2][i1];\n      _imopVarPre445 = fabs(_imopVarPre444);\n      if (_imopVarPre445 > tmp)\n      {\n        tmp = _imopVarPre445;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/0"}
{"code": "for (i = 1; i < (cache->num_buckets - 1); ++i)\n{\n  cache->thresholds[i] = cache->thresholds[i - 1] * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraphSim/00_graph_bench/src/cache/cache/38"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    d[i][j] = (rand() % 100) + 1;\n    printf(\"%d \", d[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/barnet30/OpenMPtasts/ompTasks/task10/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int eval = evalLine(points[minx_ind], points[maxx_ind], points[i]);\n  if (eval < 0)\n    rig1.pb(points[i]);\n  else\n    if (eval > 0)\n    rig2.pb(points[i]);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/A1P2_solution/3"}
{"code": "for (short i = 0; i < height; i++)\n{\n  for (short j = 0; j < width; j++)\n  {\n    int energy = 0;\n    if (i > 0)\n    {\n      energy += abs(imageMap[i][j].red - imageMap[i - 1][j].red);\n      energy += abs(imageMap[i][j].blue - imageMap[i - 1][j].blue);\n      energy += abs(imageMap[i][j].green - imageMap[i - 1][j].green);\n    }\n\n    if (i < (height - 1))\n    {\n      energy += abs(imageMap[i][j].red - imageMap[i + 1][j].red);\n      energy += abs(imageMap[i][j].blue - imageMap[i + 1][j].blue);\n      energy += abs(imageMap[i][j].green - imageMap[i + 1][j].green);\n    }\n\n    if (j > 0)\n    {\n      energy += abs(imageMap[i][j].red - imageMap[i][j - 1].red);\n      energy += abs(imageMap[i][j].blue - imageMap[i][j - 1].blue);\n      energy += abs(imageMap[i][j].green - imageMap[i][j - 1].green);\n    }\n\n    if (j < (width - 1))\n    {\n      energy += abs(imageMap[i][j].red - imageMap[i][j + 1].red);\n      energy += abs(imageMap[i][j].blue - imageMap[i][j + 1].blue);\n      energy += abs(imageMap[i][j].green - imageMap[i][j + 1].green);\n    }\n\n    energyMap[i][j] = energy;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tjp77/Seam-Carver/Seam Carver/6"}
{"code": "for (int i = 0; i < (w * h); i++)\n{\n  if (fabsf(r_dst[i] - h_dst[i]) > 1e-3)\n  {\n    ok = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bilateral-omp/main/3"}
{"code": "for (i = 0; i <= (n - 1); i += 1)\n{\n  for (j = 1; j <= (m - 1); j += 1)\n  {\n    b[i][j] = b[i][j - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j) firstprivate (n,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_outer_only/0"}
{"code": "for (unsigned i = 0; i < a->getFeatures()->size(); i++)\n{\n  temporary += (a->getFeatures()->at(i) - b->getFeatures()->at(i)) * (a->getFeatures()->at(i) - b->getFeatures()->at(i));\n}\n\n", "pragma": "    #pragma omp parallel for shared(temporary, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/anitakowalczyk/parallel-programming-CUDA-OpenMP-MPI/OpenMP/knn/0"}
{"code": "for (int i = 0; i < numHidden2Nodes; ++i)\n{\n  free(layer2_weights[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/19"}
{"code": "for (int i = 0; i < nl; i++)\n{\n  tab[i] = (double *) malloc(nc * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.3/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  MPI_Scatterv(data, ele_in_col_bloc, col_bloc_pref, MPI_data, col_data, ele_in_row_bloc[i], MPI_data, i, MPI_COMM_WORLD);\n  col_data += ele_in_row_bloc[i];\n  MPI_Scatterv(all_pos, ele_in_col_bloc, col_bloc_pref, MPI_pos, col_all_pos, ele_in_row_bloc[i], MPI_pos, i, MPI_COMM_WORLD);\n  col_all_pos += ele_in_row_bloc[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prakharg24/openmpi_openmp_2d_sort/2d_sort/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[(i * n) + j] = fabs(sin((double) rand()));\n    a1_A[(i * n) + j] = (a2_A[(i * n) + j] = (a2_a1_A[(i * n) + j] = 0.));\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MickiFoerster/spl-transformer/test-suite/plain-parallel-hessian/ror/1"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < P; j++)\n  {\n    fprintf_s(fp, \"%d \", result[i][j]);\n  }\n\n  fprintf_s(fp, \"\\r\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frank11158/PL_Matrix_Multiplication/Strassen/Strassen/0"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 150; j++)\n  a[i][j] = i + j;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajidamro/eclipse-workspace/omp_mm/MatrixMultiplication/0"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  for (int j = 0; j < N; ++j)\n  {\n    double sum = 0.0;\n    for (int k = 0; k < N; ++k)\n    {\n      sum += A[(i * N) + k] * B[(k * N) + j];\n    }\n\n    C[(i * N) + j] = sum;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(P)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abelgeringer-beep/OpenMP/OpenMP/ElsoOpenMP/1"}
{"code": "for (int i = 0; i < num_threads; ++i)\n{\n  buffer[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/novoseltcev/miet-open-mp/Lab1/src/main/0"}
{"code": "for (i = 0; i < col; i++)\n{\n  fscanf(fp, \"%lf\", &b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mattm401/pDAMGES/parallel/3"}
{"code": "for (unsigned int i = 2; i < (x_size - 2); i++)\n  for (unsigned int j = 2; j < (y_size - 2); j++)\n{\n  b1 = ((((((x - 1) * (x - 2)) * (x + 1)) * (y - 1)) * (y - 2)) * (y + 1)) / 4;\n  b2 = ((((((-x) * (x + 1)) * (x - 2)) * (y - 1)) * (y - 2)) * (y + 1)) / 4;\n  b3 = ((((((-(x - 1)) * (x - 2)) * (x + 1)) * y) * (y - 2)) * (y + 1)) / 4;\n  b4 = (((((x * (x - 2)) * (x + 1)) * y) * (y - 2)) * (y + 1)) / 4;\n  b5 = ((((((-x) * (x - 1)) * (x - 2)) * (y - 1)) * (y - 2)) * (y + 1)) / 12;\n  b6 = ((((((-(x - 1)) * (x - 2)) * (x + 1)) * y) * (y - 2)) * (y - 1)) / 12;\n  b7 = (((((x * (x - 2)) * (x - 1)) * y) * (y - 2)) * (y + 1)) / 12;\n  b8 = (((((x * (x - 2)) * (x + 1)) * y) * (y - 2)) * (y - 1)) / 12;\n  b9 = (((((x * (x - 1)) * (x + 1)) * (y - 1)) * (y - 2)) * (y + 1)) / 12;\n  b10 = ((((((x - 1) * (x - 2)) * (x + 1)) * y) * (y - 1)) * (y + 1)) / 12;\n  b11 = (((((x * (x - 2)) * (x - 1)) * y) * (y - 2)) * (y - 1)) / 36;\n  b12 = ((((((-x) * (x - 1)) * (x + 1)) * y) * (y - 2)) * (y + 1)) / 12;\n  b13 = ((((((-x) * (x - 2)) * (x + 1)) * y) * (y - 1)) * (y + 1)) / 12;\n  b14 = ((((((-x) * (x - 1)) * (x + 1)) * y) * (y - 2)) * (y - 1)) / 36;\n  b15 = ((((((-x) * (x - 2)) * (x - 1)) * y) * (y - 1)) * (y + 1)) / 36;\n  b16 = (((((x * (x - 1)) * (x + 1)) * y) * (y - 1)) * (y + 1)) / 36;\n  b[i][j] = (((((((((((((((b1 * a[i][j]) + (b2 * a[i][j + 1])) + (b3 * a[i + 1][j])) + (b4 * a[i + 1][j + 1])) + (b5 * a[i][j - 1])) + (b6 * a[i - 1][j])) + (b7 * a[i + 1][j - 1])) + (b8 * a[i - 1][j + 1])) + (b9 * a[i][j + 2])) + (b10 * a[i + 2][j])) + (b11 * a[i - 1][j - 1])) + (b12 * a[i + 1][j + 2])) + (b13 * a[i + 2][j + 1])) + (b14 * a[i - 1][j + 2])) + (b15 * a[i + 2][j - 1])) + (b16 * a[i + 2][j + 2]);\n}\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/lib/3"}
{"code": "for (size_t ivert = 0; ivert < nverts; ++ivert)\n{\n  if (m_boundVert[ivert])\n    continue;\n\n  m_vertidxs_GPU[ninterior] = ivert;\n  m_vertadjOffsets_GPU[ninterior] = offset;\n  size_t offsetOrig = m_vertadjOffsets[ivert];\n  size_t offsetOrigNxt = m_vertadjOffsets[ivert + 1];\n  size_t size = offsetOrigNxt - offsetOrig;\n  for (size_t i = 0; i < size; ++i)\n  {\n    m_vertadj_GPU[offset + i] = m_vertadj[offsetOrig + i];\n  }\n\n  offset += size;\n  ++ninterior;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/codearxiv/SurfMeshSmooth/Mesh/3"}
{"code": "for (int i = 0; i < procs; i++)\n{\n  sumnnz[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimikout3/Parallel-BiCGSTAB-/parallel/10"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        u[i][j][k][m] = u[i][j][k][m] + rhs[i][j][k][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/BT/bt/0"}
{"code": "for (n = 0; n < length; n++)\n{\n  rev = _bit_reverse(n, bits);\n  _complex_mov(dataIn[rev], dataOut[n]);\n}\n\n", "pragma": "omp for private(rev) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/immanuelsavio/Parallel-Processing-Using-OpenMP/radix2/0"}
{"code": "for (int i = 0; i < testsSize; i++)\n  for (int j = 0; j < 9; j++)\n  myfile >> input[count++];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/svd3x3-omp/main/2"}
{"code": "for (npy_intp i = 0; i < xsize; ++i)\n{\n  xdata[i] = op->apply(xdata[i]);\n}\n\n", "pragma": "  #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gregvw/mpops/operations/0"}
{"code": "for (int i = 0; i < N; i++)\n  for (int j = 0; j < K; j++)\n  if (W[(i * K) + j] < eps)\n  W[(i * K) + j] = eps;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/artecs-group/nmf-openmp/src/main/11"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  printf(\"y[%d] = %f\\n\", i, y[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PurplePachyderm/openmp-gputool/tests/1"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  fscanf(file, \"%d %d %d\\n\", &k[i][0], &k[i][1], &k[i][2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisKarampas/Image_Convolution/src/main/4"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  b++;\n}\n\n", "pragma": "  #pragma omp target parallel for depend(inout:a) map(tofrom:b) if(a) device(a+b) private(argc) firstprivate(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/uasys/openmp-split/llvm/tools/clang/test/OpenMP/target_parallel_for_depend_codegen/0"}
{"code": "for (int i = 1; i < x_points; i++)\n{\n  u_new[i] = u[i] - (((c * del_t) / del_x) * (u[i] - u[i - 1]));\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/1-D Linear Convection/main/0"}
{"code": "for (i = 1; i <= (2048 - 2); i++)\n  for (j = 1 + (i % 2); j <= (2048 - 2); j += 2)\n  if (((i + j) % 2) == 0)\n{\n  double b;\n  b = w * (((((A[i - 1][j] + A[i + 1][j]) + A[i][j - 1]) + A[i][j + 1]) / 4.) - A[i][j]);\n  A[i][j] = A[i][j] + b;\n}\n\n\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AVasK/SuperPCs_OpenMP/redb_2d_parallel_final/3"}
{"code": "for (int i = 0; i < num_nodes; ++i)\n{\n  distance[i] = INF;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jinyeom/openmp-bellman-ford/src/main/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  printf(\"%d\\n\", c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lephin/C-parallel-programming.-OpenMP/Hello/2"}
{"code": "for (int ejecuciones = 0; ejecuciones < 5; ejecuciones++)\n{\n  tiempoInicial = clock();\n  if (proceso == 0)\n  {\n    matrizCampo = (arbol *) malloc(tamanioFinal * (sizeof(arbol)));\n    int random;\n    fila = -1;\n    for (int i = 0; i < tamanioFinal; i++)\n    {\n      random = rand() % 101;\n      matrizCampo[i].semanasInfectado = 0;\n      matrizCampo[i].semanasTotales = 0;\n      matrizCampo[i].semanasPodado = 0;\n      if (random < 65)\n      {\n        matrizCampo[i].color = 5;\n      }\n      else\n      {\n        if ((random >= 65) && (random < 70))\n        {\n          matrizCampo[i].color = 3;\n        }\n        else\n        {\n          if ((random >= 70) && (random < 80))\n          {\n            matrizCampo[i].color = 4;\n          }\n          else\n          {\n            if ((random >= 80) && (random <= 100))\n            {\n              matrizCampo[i].color = 2;\n            }\n\n          }\n\n        }\n\n      }\n\n      if (random < 30)\n      {\n        matrizCampo[i].edad = 52;\n      }\n      else\n      {\n        if ((random >= 30) && (random < 80))\n        {\n          matrizCampo[i].edad = 157;\n        }\n        else\n        {\n          if ((random >= 80) && (random <= 100))\n          {\n            matrizCampo[i].edad = 1821;\n          }\n\n        }\n\n      }\n\n      if ((i % 500) == 0)\n      {\n        fila++;\n      }\n\n      matrizCampo[i].fila = fila;\n      matrizCampo[i].heridas = 0;\n    }\n\n  }\n\n  MPI_Scatter(matrizCampo, filasXproceso * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, matrizLocal, filasXproceso * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, 0, (MPI_Comm) 0x44000000);\n  int filasAbajo = filasXproceso - (2 * 500);\n  int arbolesContagiando;\n  int vecinosVisitados;\n  int indiceAbajo = 0;\n  int indiceAbajoB = 0;\n  int cambioEstado;\n  int probHeridas;\n  int tratamiento;\n  int cambio;\n  int indice = 0;\n  int randomParaSano;\n  float susceptibilidad;\n  float probabilidadContagio;\n  float porcentajeEnfermos;\n  if (proceso == 0)\n  {\n    for (int h = 0; h < (500 * 2); h++)\n    {\n      arregloArriba[h].color = 10;\n      arregloArriba[h].fila = -5;\n    }\n\n  }\n\n  if (proceso == (cantProcesos - 1))\n  {\n    for (int i = 0; i < (500 * 2); i++)\n    {\n      arregloAbajo[i].color = 10;\n      arregloAbajo[i].fila = 500 + 5;\n    }\n\n  }\n\n  for (int semana = 0; semana < 1200; semana++)\n  {\n    indiceAbajo = 0;\n    indiceAbajoB = 0;\n    filasAbajo = filasXproceso - (2 * 500);\n    if (proceso != 0)\n    {\n      for (int i = 0; i < (500 * 2); i++)\n      {\n        arregloAuxA[i].color = matrizLocal[i].color;\n        arregloAuxA[i].edad = matrizLocal[i].edad;\n        arregloAuxA[i].fila = matrizLocal[i].fila;\n        arregloAuxA[i].heridas = matrizLocal[i].heridas;\n        arregloAuxA[i].semanasInfectado = matrizLocal[i].semanasInfectado;\n        arregloAuxA[i].semanasPodado = matrizLocal[i].semanasPodado;\n        arregloAuxA[i].semanasTotales = matrizLocal[i].semanasTotales;\n      }\n\n    }\n\n    if (proceso != (cantProcesos - 1))\n    {\n      for (int j = 0; j < (500 * 2); j++)\n      {\n        arregloAuxB[j].color = matrizLocal[filasAbajo].color;\n        arregloAuxB[j].edad = matrizLocal[filasAbajo].edad;\n        arregloAuxB[j].fila = matrizLocal[filasAbajo].fila;\n        arregloAuxB[j].heridas = matrizLocal[filasAbajo].heridas;\n        arregloAuxB[j].semanasInfectado = matrizLocal[filasAbajo].semanasInfectado;\n        arregloAuxB[j].semanasPodado = matrizLocal[filasAbajo].semanasPodado;\n        arregloAuxB[j].semanasTotales = matrizLocal[filasAbajo].semanasTotales;\n        filasAbajo++;\n      }\n\n    }\n\n    if (proceso != 0)\n    {\n      MPI_Isend(arregloAuxA, tamReparto * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, proceso - 1, 0, (MPI_Comm) 0x44000000, &request);\n      MPI_Wait(&request, &status);\n    }\n\n    if (proceso != (cantProcesos - 1))\n    {\n      MPI_Irecv(arregloAbajo, tamReparto * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, proceso + 1, 0, (MPI_Comm) 0x44000000, &request);\n      MPI_Wait(&request, &status);\n    }\n\n    if (proceso != (cantProcesos - 1))\n    {\n      MPI_Isend(arregloAuxB, tamReparto * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, proceso + 1, 0, (MPI_Comm) 0x44000000, &request);\n      MPI_Wait(&request, &status);\n    }\n\n    if (proceso != 0)\n    {\n      MPI_Irecv(arregloArriba, tamReparto * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, proceso - 1, 0, (MPI_Comm) 0x44000000, &request);\n      MPI_Wait(&request, &status);\n    }\n\n    for (indice = 0; indice < filasXproceso; indice++)\n    {\n      arbolesContagiando = 0;\n      vecinosVisitados = 0;\n      if (indice > 0)\n      {\n        if (matrizLocal[indice - 1].fila == matrizLocal[indice].fila)\n        {\n          if (matrizLocal[indice - 1].color == 3)\n          {\n            arbolesContagiando += 1;\n          }\n\n          if (matrizLocal[indice - 1].fila >= 0)\n          {\n            vecinosVisitados += 1;\n          }\n\n        }\n\n      }\n\n      if (indice > 1)\n      {\n        if (matrizLocal[indice - 2].fila == matrizLocal[indice].fila)\n        {\n          if (matrizLocal[indice - 2].color == 3)\n          {\n            arbolesContagiando += 1;\n          }\n\n          if (matrizLocal[indice - 2].fila >= 0)\n          {\n            vecinosVisitados += 1;\n          }\n\n        }\n\n      }\n\n      if (indice < (filasXproceso - 1))\n      {\n        if (matrizLocal[indice + 1].fila == matrizLocal[indice].fila)\n        {\n          if (matrizLocal[indice + 1].color == 3)\n          {\n            arbolesContagiando += 1;\n          }\n\n          if (matrizLocal[indice + 1].fila < 500)\n          {\n            vecinosVisitados += 1;\n          }\n\n        }\n\n      }\n\n      if (indice < (filasXproceso - 2))\n      {\n        if (matrizLocal[indice + 2].fila == matrizLocal[indice].fila)\n        {\n          if (matrizLocal[indice + 2].color == 3)\n          {\n            arbolesContagiando += 1;\n          }\n\n          if (matrizLocal[indice + 2].fila < 500)\n          {\n            vecinosVisitados += 1;\n          }\n\n        }\n\n      }\n\n      if (indice < 500)\n      {\n        if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + 500].fila)\n        {\n          if (arregloArriba[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloArriba[indice + 500].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if (((matrizLocal[indice].fila - 1) == arregloArriba[indice + (500 + 1)].fila) && (indice < (500 - 1)))\n        {\n          if (arregloArriba[indice + (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloArriba[indice + (500 + 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == arregloArriba[indice + (500 - 1)].fila)\n        {\n          if (arregloArriba[indice + (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloArriba[indice + (500 - 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n        {\n          if (arregloArriba[indice].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloArriba[indice].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 500].fila)\n        {\n          if (matrizLocal[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + 500].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 - 1)].fila)\n        {\n          if (matrizLocal[indice + (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 - 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 + 1)].fila)\n        {\n          if (matrizLocal[indice + (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 + 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 500)].fila)\n        {\n          if (matrizLocal[indice + (2 * 500)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (2 * 500)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n      }\n\n      if ((indice > (500 - 1)) && (indice < (500 * 2)))\n      {\n        if ((matrizLocal[indice].fila - 2) == arregloArriba[indice].fila)\n        {\n          if (arregloArriba[indice].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloArriba[indice].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 500].fila)\n        {\n          if (matrizLocal[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + 500].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 - 1)].fila)\n        {\n          if (matrizLocal[indice + (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 - 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 + 1)].fila)\n        {\n          if (matrizLocal[indice + (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 + 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 500].fila)\n        {\n          if (matrizLocal[indice - 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - 500].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 - 1)].fila)\n        {\n          if (matrizLocal[indice - (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 - 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if (((indice - (500 + 1)) >= 0) && ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 + 1)].fila))\n        {\n          if (matrizLocal[indice - (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 + 1)].fila >= 0)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n      }\n\n      if ((indice >= (500 * 2)) && (indice < (filasXproceso - (2 * 500))))\n      {\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 500].fila)\n        {\n          if (matrizLocal[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 + 1)].fila)\n        {\n          if (matrizLocal[indice + (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 + 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 - 1)].fila)\n        {\n          if (matrizLocal[indice + (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 - 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 2) == matrizLocal[indice + (2 * 500)].fila)\n        {\n          if (matrizLocal[indice + (2 * 500)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (2 * 500)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 500].fila)\n        {\n          if (matrizLocal[indice - 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 + 1)].fila)\n        {\n          if (matrizLocal[indice - (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 + 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 - 1)].fila)\n        {\n          if (matrizLocal[indice - (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 - 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 500)].fila)\n        {\n          if (matrizLocal[indice - (2 * 500)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (2 * 500)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n      }\n\n      if ((indice >= (filasXproceso - (500 * 2))) && (indice < (filasXproceso - 500)))\n      {\n        if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajo].fila)\n        {\n          if (arregloAbajo[indiceAbajo].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloAbajo[indiceAbajo].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + 500].fila)\n        {\n          if (matrizLocal[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 + 1)].fila)\n        {\n          if (matrizLocal[indice + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == matrizLocal[indice + (500 - 1)].fila)\n        {\n          if (matrizLocal[indice + (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice + (500 - 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 500].fila)\n        {\n          if (matrizLocal[indice - 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 + 1)].fila)\n        {\n          if (matrizLocal[indice - (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 + 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 - 1)].fila)\n        {\n          if (matrizLocal[indice - (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 - 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (500 * 2)].fila)\n        {\n          if (matrizLocal[indice - (500 * 2)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 * 2)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        indiceAbajoB++;\n      }\n\n      if ((indice >= (filasXproceso - 500)) && (indice < filasXproceso))\n      {\n        if (indiceAbajoB == 500)\n        {\n          indiceAbajoB = 0;\n        }\n\n        if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB].fila)\n        {\n          if (arregloAbajo[indiceAbajoB].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloAbajo[indiceAbajoB].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if (indiceAbajoB > 0)\n        {\n          if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB - 1].fila)\n          {\n            if (arregloAbajo[indiceAbajoB - 1].color == 3)\n            {\n              arbolesContagiando++;\n            }\n\n            if (arregloAbajo[indiceAbajoB - 1].fila < 500)\n            {\n              vecinosVisitados++;\n            }\n\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 1) == arregloAbajo[indiceAbajoB + 1].fila)\n        {\n          if (arregloAbajo[indiceAbajoB + 1].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloAbajo[indiceAbajoB + 1].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila + 2) == arregloAbajo[indiceAbajoB + 500].fila)\n        {\n          if (arregloAbajo[indiceAbajoB + 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (arregloAbajo[indiceAbajoB + 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - 500].fila)\n        {\n          if (matrizLocal[indice - 500].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - 500].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 + 1)].fila)\n        {\n          if (matrizLocal[indice - (500 + 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 + 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 1) == matrizLocal[indice - (500 - 1)].fila)\n        {\n          if (matrizLocal[indice - (500 - 1)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (500 - 1)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        if ((matrizLocal[indice].fila - 2) == matrizLocal[indice - (2 * 500)].fila)\n        {\n          if (matrizLocal[indice - (2 * 500)].color == 3)\n          {\n            arbolesContagiando++;\n          }\n\n          if (matrizLocal[indice - (2 * 500)].fila < 500)\n          {\n            vecinosVisitados++;\n          }\n\n        }\n\n        indiceAbajoB++;\n      }\n\n      if (matrizLocal[indice].edad < 157)\n      {\n        if (matrizLocal[indice].heridas == 1)\n        {\n          susceptibilidad = 0.35 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.35;\n        }\n\n      }\n\n      if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n      {\n        if (matrizLocal[indice].heridas == 1)\n        {\n          susceptibilidad = 0.17 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.17;\n        }\n\n      }\n\n      if (matrizLocal[indice].edad >= 1821)\n      {\n        if (matrizLocal[indice].heridas == 1)\n        {\n          susceptibilidad = 0.63 + 0.15;\n        }\n        else\n        {\n          susceptibilidad = 0.63;\n        }\n\n      }\n\n      matrizLocalAux[indice].edad += 1;\n      if (matrizLocal[indice].color == 4)\n      {\n        matrizLocalAux[indice].semanasInfectado += 1;\n        matrizLocalAux[indice].semanasTotales++;\n      }\n\n      if (matrizLocal[indice].semanasInfectado == 3)\n      {\n        matrizLocalAux[indice].color = 3;\n      }\n\n      if (matrizLocal[indice].color == 3)\n      {\n        matrizLocalAux[indice].semanasTotales++;\n        if ((rand() % 100) <= 85)\n        {\n          matrizLocalAux[indice].color = 2;\n          matrizLocalAux[indice].semanasInfectado = 0;\n          matrizLocalAux[indice].semanasTotales += 1;\n        }\n\n      }\n\n      if (matrizLocal[indice].color == 2)\n      {\n        if (matrizLocal[indice].semanasTotales <= 8)\n        {\n          matrizLocalAux[indice].semanasTotales++;\n        }\n        else\n        {\n          if (matrizLocal[indice].edad < 157)\n          {\n            if ((rand() % 100) > 3)\n            {\n              matrizLocalAux[indice].color = 5;\n              matrizLocalAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizLocalAux[indice].color = 1;\n              matrizLocalAux[indice].semanasTotales = 0;\n            }\n\n          }\n\n          if ((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821))\n          {\n            if ((rand() % 100) > 15)\n            {\n              matrizLocalAux[indice].color = 5;\n              matrizLocalAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizLocalAux[indice].color = 1;\n              matrizLocalAux[indice].semanasTotales = 0;\n            }\n\n          }\n\n          if (matrizLocal[indice].edad >= 1821)\n          {\n            if ((rand() % 100) > 53)\n            {\n              matrizLocalAux[indice].color = 5;\n              matrizLocalAux[indice].semanasTotales = 0;\n            }\n            else\n            {\n              matrizLocalAux[indice].color = 5;\n              matrizLocalAux[indice].semanasTotales = 0;\n              matrizLocalAux[indice].edad = 57;\n            }\n\n          }\n\n        }\n\n      }\n\n      if (matrizLocal[indice].color == 1)\n      {\n        if (matrizLocal[indice].semanasPodado <= 12)\n        {\n          matrizLocalAux[indice].semanasPodado++;\n        }\n        else\n        {\n          matrizLocalAux[indice].color = 5;\n          matrizLocalAux[indice].semanasPodado = 0;\n        }\n\n      }\n\n      if (matrizLocal[indice].color == 5)\n      {\n        porcentajeEnfermos = (float) (arbolesContagiando / vecinosVisitados);\n        probabilidadContagio = (((float) (porcentajeEnfermos + susceptibilidad)) * 0.60) + 0.07;\n        if (probabilidadContagio < ((rand() % 1001) / 1000.f))\n        {\n          matrizLocalAux[indice].color = 4;\n        }\n\n      }\n\n      if (semana > 0)\n      {\n        probHeridas = rand() % 101;\n        if ((matrizLocal[indice].edad < 157) && (probHeridas < 23))\n        {\n          matrizLocalAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizLocalAux[indice].heridas = 0;\n        }\n\n        if (((matrizLocal[indice].edad >= 157) && (matrizLocal[indice].edad < 1821)) && (probHeridas < 8))\n        {\n          matrizLocalAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizLocalAux[indice].heridas = 0;\n        }\n\n        if ((matrizLocal[indice].edad >= 1821) && (probHeridas < 37))\n        {\n          matrizLocalAux[indice].heridas = 1;\n        }\n        else\n        {\n          matrizLocalAux[indice].heridas = 0;\n        }\n\n      }\n\n    }\n\n    MPI_Barrier((MPI_Comm) 0x44000000);\n    MPI_Gather(matrizLocalAux, filasXproceso * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, matrizCampo, filasXproceso * (sizeof(arbol)), (MPI_Datatype) 0x4c00010d, 0, (MPI_Comm) 0x44000000);\n  }\n\n  tiempoFinal = clock();\n  double segundos = ((double) (tiempoFinal - tiempoInicial)) / CLOCKS_PER_SEC;\n  printf(\"EL TIEMPO DE EJECUCION DE LA VUELTA  %d FUE: %f\\n\", ejecuciones, segundos);\n  tiempototal += tiempoFinal - tiempoInicial;\n  fila = -1;\n  free((void *) matrizCampo);\n}\n\n", "pragma": "omp parallel for private(ejecuciones) num_threads(10)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leivagaston/PracticoFinalDistribuidos/PracticoFinalHibrido500/0"}
{"code": "for (unsigned int i = 0; i < n_grid1; i++)\n{\n  e_fld->field_phi[i][0] = E_fi_left;\n  e_fld->field_phi[i][n_grid2 - 1] = E_fi_right;\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/boundaryMaxwellConditions/0"}
{"code": "for (c = 0; c < size; c++)\n{\n  for (d = 0; d < size; d++)\n  {\n    struct v *data = (struct v *) malloc(sizeof(struct v));\n    if (data == 0)\n    {\n      printf(\"Failed to allocate memory\\n\");\n      exit(1);\n    }\n\n    data->i = c;\n    data->j = d;\n    pthread_create((tid + (c * size)) + d, &attr, runner, data);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MeghanaVankadari/Gemm_parallel/gemm_parallel/4"}
{"code": "for (long int i = 0; i < N; ++i)\n{\n  for (long int j = 0; j < N; ++j)\n  {\n    CheckEqual(C[(i * N) + j], COptim[(i * N) + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/desmond-rn/hpc-algorithms/TP9/tests/matrix/2"}
{"code": "for (int startBit = 0; startBit < 32; startBit += 2 * numBits)\n{\n  radixSortParallelPass(keys, keys_tmp, numBits, startBit, blockSize);\n  radixSortParallelPass(keys_tmp, keys, numBits, startBit + numBits, blockSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/8"}
{"code": "for (int j = 0; j < k; j++)\n{\n  for (int h = 0; h < dimPoint; h++)\n  {\n    centroids[j].dimensions[h] = 0;\n  }\n\n}\n\n", "pragma": "#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcocalamai/Parallel-Kmeans-OpenMP-and-Cuda/src/KMeans_OpenMP/3"}
{"code": "for (i = 0; i < dim; i++)\n{\n  y[i] = 0.0;\n  x[i] = 0.0;\n  for (j = 0; j < dim; j++)\n    y[i] += mat[i][j] * rez[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_gj/bench/6"}
{"code": "for (m = 0; m < 5; m++)\n{\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((5.0 * u[m][i][j][k]) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/ICC_Cost/NPB3.0-omp-c/SP/sp/11"}
{"code": "for (int cont = 0; cont < contours.size(); cont++)\n{\n  ROI = boundingRect(contours[cont]);\n  if (((((ROI.width > 20) && (ROI.width < 100)) && (ROI.height > 35)) && (ROI.height < 150)) && (ROI.x > (prevROI.x + prevROI.width)))\n  {\n    selected_ROI.push_back(cont);\n    prevROI = ROI;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmaarij/Parallelized-Number-Plate-Detection-System-using-OpenCV-OpenMP/main/0"}
{"code": "for (int i = 0; i < this->nrow_; ++i)\n{\n  int row_begin = this->mat_.row_offset[i];\n  int row_end = this->mat_.row_offset[i + 1];\n  if (workspace[i])\n  {\n    float omega_row = omega.vec_[i];\n    for (int j = row_begin; j < row_end; ++j)\n    {\n      if (cast_S->vec_[j])\n      {\n        int col = this->mat_.col[j];\n        if (workspace[col])\n        {\n          float omega_col = omega.vec_[col];\n          if (omega_row > omega_col)\n          {\n            cast_cf->vec_[col] = 0;\n          }\n          else\n            if (omega_row < omega_col)\n          {\n            cast_cf->vec_[i] = 0;\n          }\n\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(dynamic, 1024)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/106"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  if (arr[i] > max)\n  {\n    max = arr[i];\n    maxIndex = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arianhaddadi/Parallel-Programming/OpenMP/main/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  sums += a[i] * b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AnomDevgun/ParallelComputing/openMP/vecprod/2"}
{"code": "for (fase = 0; fase < TOPEF; fase++)\n{\n  if ((fase % 2) == 0)\n    for (i = 1; i < TOPEF; i += 2)\n  {\n    if (v2[i - 1] > v2[i])\n    {\n      tmp = v2[i - 1];\n      v2[i - 1] = v2[i];\n      v2[i] = tmp;\n    }\n\n  }\n\n  else\n    for (i = 1; i < (TOPEF - 1); i += 2)\n  {\n    if (v2[i] > v2[i + 1])\n    {\n      tmp = v2[i + 1];\n      v2[i + 1] = v2[i];\n      v2[i] = tmp;\n    }\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mcupo/OrdenamientoParaleloOpenMP/arrays/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float cx4 = cx[i][4];\n  float px4 = px[i][4];\n  float px5 = px[i][5];\n  float px6 = px[i][6];\n  float px7 = px[i][7];\n  float px8 = px[i][8];\n  float px9 = px[i][9];\n  float px10 = px[i][10];\n  float px11 = px[i][11];\n  float px12 = px[i][12];\n  px[i][4] = cx4;\n  px[i][5] = cx4 - px4;\n  px[i][6] = (cx4 - px4) - px5;\n  px[i][7] = ((cx4 - px4) - px5) - px6;\n  px[i][8] = (((cx4 - px4) - px5) - px6) - px7;\n  px[i][9] = ((((cx4 - px4) - px5) - px6) - px7) - px8;\n  px[i][10] = (((((cx4 - px4) - px5) - px6) - px7) - px8) - px9;\n  px[i][11] = ((((((cx4 - px4) - px5) - px6) - px7) - px8) - px9) - px10;\n  px[i][13] = ((((((((cx4 - px4) - px5) - px6) - px7) - px8) - px9) - px10) - px11) - px12;\n  px[i][12] = (((((((cx4 - px4) - px5) - px6) - px7) - px8) - px9) - px10) - px11;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenmai/Livermore_Omp/kernel/14"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  for (int i = 0; i < 1000000; i++)\n  {\n    randomnumber = rand() % 6;\n    dnabig[i] = dna[randomnumber];\n  }\n\n  replacecharacters(dnabig);\n  countA(dnabig);\n  end = clock();\n  total_time = ((double) (end - start)) / CLOCKS_PER_SEC;\n  nDynamic1[j] = total_time;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/induraj2020/A11--DNA-sequencing/02_tryout_openmp/2"}
{"code": "for (i = 0; i <= ((m - 1) - 1); i += 1)\n{\n  if (ten[i][ind] > ten[i + 1][ind])\n  {\n    temp = ten[i + 1][ind];\n    ten[i + 1][ind] = ten[i][ind];\n    ten[i][ind] = temp;\n    j_temp = j1[i + 1][ind];\n    j1[i + 1][ind] = j1[i][ind];\n    j1[i][ind] = j_temp;\n    j_temp = j2[i + 1][ind];\n    j2[i + 1][ind] = j2[i][ind];\n    j2[i][ind] = j_temp;\n    j_temp = j3[i + 1][ind];\n    j3[i + 1][ind] = j3[i][ind];\n    j3[i][ind] = j_temp;\n  }\n  else\n  {\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/33"}
{"code": "for (i = 0; i < 5; i++)\n  printf(\"%d, %d, %d\\n\", a[i], b[i], c[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/nowait/3"}
{"code": "for (int i = 0; i < 2; ++i)\n{\n  free(x[i]);\n  free(z[i]);\n  free(r[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yattroman/nsu-opp-mpi-openmp-labs/laboratory-2/version-2/main/3"}
{"code": "for (i = 0; i < 5; i++)\n  partial_verify_vals[i] = key_array[test_index_array[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  float err = (a[i] == 0.0) ? (b[i]) : ((b[i] - a[i]) / a[i]);\n  if (((err > 0) ? (err) : (-err)) > 0.00001)\n    abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.54.6/2"}
{"code": "for (j = 0; j < 256; j++)\n  for (i = 0; i < 256; i++)\n{\n  tmp_fftw[k][i][j][0] = in_fftw[k][j][i][0];\n  tmp_fftw[k][i][j][1] = in_fftw[k][j][i][1];\n}\n\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dumitrux/Parallelism-FIB/Laboratorio/Lab1/Material-lab1/lab1/3dfft/3dfft_omp/2"}
{"code": "for (j = i; j < N; j++)\n{\n  rands = myRand(i, j);\n  adjacency[i][j] = rands;\n  adjacency[j][i] = rands;\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Nersle/parallelProgramingProject/bfs/bfsMPI/1"}
{"code": "for (y = 0; y < height; y++)\n  row_pointers[y] = (int *) malloc(png_get_rowbytes(png_ptr, info_ptr));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lagodiuk/raytracing-render/render/src/canvas/4"}
{"code": "for (int p = 0; p < nproc; p++)\n{\n  gl_number_of_centers_to_close += (int) work_mem[(p * stride) + K];\n  gl_cost_of_opening_x += work_mem[((p * stride) + K) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/14"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    (cout << \" \") << result[i][j];\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dpalominop/ConvolutionOpenMP/convolucion/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  sumalocal += a[i];\n  printf(\"thread %d suma de a[%d]=%d sumalocal=%d\\n\", tid, i, a[i], sumalocal);\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica1/master/0"}
{"code": "for (int i = 0; i < x.size(); ++i)\n  samples.push_back(rand() % x.size());\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/10"}
{"code": "for (int ci = 1; ci < NCELLS; ci++)\n{\n  system_mass += cell(ci).getNV();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/92"}
{"code": "for (i3 = d3; i3 <= (mm3 - 1); i3++)\n{\n  for (i2 = d2; i2 <= (mm2 - 1); i2++)\n  {\n    for (i1 = d1; i1 <= (mm1 - 1); i1++)\n    {\n      u[((2 * i3) - d3) - 1][((2 * i2) - d2) - 1][((2 * i1) - d1) - 1] = u[((2 * i3) - d3) - 1][((2 * i2) - d2) - 1][((2 * i1) - d1) - 1] + z[i3 - 1][i2 - 1][i1 - 1];\n    }\n\n    for (i1 = 1; i1 <= (mm1 - 1); i1++)\n    {\n      u[((2 * i3) - d3) - 1][((2 * i2) - d2) - 1][((2 * i1) - t1) - 1] = u[((2 * i3) - d3) - 1][((2 * i2) - d2) - 1][((2 * i1) - t1) - 1] + (0.5 * (z[i3 - 1][i2 - 1][i1] + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n  }\n\n  for (i2 = 1; i2 <= (mm2 - 1); i2++)\n  {\n    for (i1 = d1; i1 <= (mm1 - 1); i1++)\n    {\n      u[((2 * i3) - d3) - 1][((2 * i2) - t2) - 1][((2 * i1) - d1) - 1] = u[((2 * i3) - d3) - 1][((2 * i2) - t2) - 1][((2 * i1) - d1) - 1] + (0.5 * (z[i3 - 1][i2][i1 - 1] + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n    for (i1 = 1; i1 <= (mm1 - 1); i1++)\n    {\n      u[((2 * i3) - d3) - 1][((2 * i2) - t2) - 1][((2 * i1) - t1) - 1] = u[((2 * i3) - d3) - 1][((2 * i2) - t2) - 1][((2 * i1) - t1) - 1] + (0.25 * (((z[i3 - 1][i2][i1] + z[i3 - 1][i2 - 1][i1]) + z[i3 - 1][i2][i1 - 1]) + z[i3 - 1][i2 - 1][i1 - 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/4"}
{"code": "for (i = 0; i < (size * size); i++)\n  C[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dc-fukuoka/gpumm/cpu/mm/2"}
{"code": "for (int mat = 1; mat < (cc.Nmats / 2); mat++)\n{\n  for (int j = (sizey / 2) - 3; j < ((sizey / 2) - 1); j++)\n    for (int i = 2; i < (5 + overlap_i); i++)\n  {\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[((((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n  }\n\n\n  for (int j = sizey / 2; j < (((sizey / 2) + 2) + overlap_j); j++)\n    for (int i = 2; i < 5; i++)\n  {\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) + (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/5"}
{"code": "for (i = 0; i < size; i++)\n{\n  if (v[i])\n  {\n    free(v[i]);\n    v[i] = NULL;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pesfahanian/Parallel_Strassen/Strassan Matrix Multiplication Final/7"}
{"code": "for (int i = 0; i < 17; i++)\n{\n  for (int j = 0; j < 17; j++)\n  {\n    printf(\": %d \", mat2[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alanhenschel/The-game-of-life-parallel/jogo_da_vida/2"}
{"code": "for (ix = 1; ix < 10; ix++)\n{\n  LScale = TID + ix;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.58-critical-region-minval/0"}
{"code": "for (int i = 0; i < V; i++)\n{\n  dist[i] = INT_MAX;\n  visited[i] = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danyalfaro/Dijkstra/Dijkstra/2"}
{"code": "for (unsigned i = 2; i <= n; i += 1)\n{\n  result *= i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joeladams/patternlets/patternlets/openMP/09.reduction-userDefined/reduction2/0"}
{"code": "for (j = 0; j <= (grid_points[1] - 1); j++)\n{\n  ru1 = c3c4 * rho_i[i][j][k];\n  cv[j] = vs[i][j][k];\n  rhoq[j] = max(dy3 + (con43 * ru1), max(dy5 + (c1c5 * ru1), max(dymax + ru1, dy1)));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/9"}
{"code": "for (int i = 0; i < (nX - 1); i++)\n{\n  if (distances[i] <= median)\n  {\n    nInner++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/vptree/src/vptree_openmp/5"}
{"code": "for (int i = 0; i < (((SIZE / TILEX) * SIZE) / TILEY); i++)\n{\n  TABLE_READ[i] = 0;\n  TABLE_WRITE[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/38"}
{"code": "for (i = T_INIT; i < T_LAST; i++)\n{\n  timer_clear(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/0"}
{"code": "for (int n = 0; n < numseeds; n++)\n{\n  int ox = kseedsx[n];\n  int oy = kseedsy[n];\n  int oind = (oy * m_width) + ox;\n  int storeind = oind;\n  for (int i = 0; i < 8; i++)\n  {\n    int nx = ox + dx8[i];\n    int ny = oy + dy8[i];\n    if ((((nx >= 0) && (nx < m_width)) && (ny >= 0)) && (ny < m_height))\n    {\n      int nind = (ny * m_width) + nx;\n      if (edges[nind] < edges[storeind])\n      {\n        storeind = nind;\n      }\n\n    }\n\n  }\n\n  if (storeind != oind)\n  {\n    kseedsx[n] = storeind % m_width;\n    kseedsy[n] = storeind / m_width;\n    kseedsl[n] = m_lvec[storeind];\n    kseedsa[n] = m_avec[storeind];\n    kseedsb[n] = m_bvec[storeind];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/icelostnfound/Slic_Opencv_Openmp/Slic/SLIC/4"}
{"code": "for (i = lower; i > upper; i -= stride)\n{\n  a[i] = i * 2;\n  printf(\"Iteration %2d is carried out by thread %2d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/ompfor4/0"}
{"code": "for (i = 0; i < dimension; i++)\n{\n  for (j = 0; j < dimension; j++)\n  {\n    for (k = 0; k < dimension; k++)\n    {\n      C[i][j] = C[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abu-abraham/open-MP/examples/matmult/4"}
{"code": "for (j = 0; j <= (COLUMNS + 1); j++)\n{\n  Temperature_last[0][j] = 0.0;\n  Temperature_last[ROWS + 1][j] = (100.0 / COLUMNS) * j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brianzy/OpenMp/simple_for_loop/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  D[0][i] = (t[i] == a[0]) ? (1) : (0);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pranshumaheshwari/Parallel-String-Matching/parallel_shift_and/1"}
{"code": "for (int i = 0; i < num_nodes; ++i)\n{\n  for (int j = 0; j < num_nodes; ++j)\n  {\n    if (((nodes_distance[i][k] * nodes_distance[k][j]) != 0) && (i != j))\n    {\n      possible_short_dist = nodes_distance[i][k] + nodes_distance[k][j];\n      if ((nodes_distance[i][j] <= possible_short_dist) && (nodes_distance[i][j] != 0))\n      {\n        continue;\n      }\n\n      nodes_distance[i][j] = possible_short_dist;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/intesar-gist/floyd_warshall_openmp/floyd_warshall_openmp/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m_imopVar133 = 0; m_imopVar133 < 5; m_imopVar133++)\n    {\n      rhs[i][j][k][m_imopVar133] = rhs[i][j][k][m_imopVar133] - (dssp * ((u[i][j - 2][k][m_imopVar133] - (4. * u[i][j - 1][k][m_imopVar133])) + (5. * u[i][j][k][m_imopVar133])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/69"}
{"code": "for (i = 0; i < n; i++)\n  y[i] = (a[i] * x[i]) + b[i];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/daseibert2/OpenMP_Exercises/daxpy/0"}
{"code": "for (int i = -win_radius; i <= win_radius; i++)\n{\n  r = kptr_i + i;\n  if ((r <= 0) || (r >= (h - 1)))\n    continue;\n\n  for (int j = -win_radius; j <= win_radius; j++)\n  {\n    c = kptc_i + j;\n    if ((c <= 0) || (c >= (w - 1)))\n      continue;\n\n    magni = grdData[(r * w) + c];\n    angle = rotData[(r * w) + c];\n    fbin = (angle * nBins) / _2PI;\n    weight = expf((((i - d_kptr) * (i - d_kptr)) + ((j - d_kptc) * (j - d_kptc))) * exp_factor);\n    bin = (int) (fbin - 0.5f);\n    float d_fbin = (fbin - 0.5f) - bin;\n    float mw = weight * magni;\n    float dmw = d_fbin * mw;\n    tmpHist[(bin + nBins) % nBins] += mw - dmw;\n    tmpHist[(bin + 1) % nBins] += dmw;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/src/ezsift/11"}
{"code": "for (i = 0; i < 50; i++)\n{\n  parse[i][0] = atof(dataX[i][0]);\n  parse[i][1] = atof(dataX[i][3]);\n  parse[i][2] = atof(dataX[i][4]);\n  parse[i][2] = (2016 - parse[i][2]) * 365;\n  parse[i][3] = atof(dataX[i][5]);\n}\n\n", "pragma": "omp for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adnanhf/Kompar/DTubes Paralel/0"}
{"code": "for (step = 1; step <= 100; step++)\n{\n  forces = memset(forces, 0, 100 * (sizeof(vect_t)));\n  {\n    for (q = 0, i = 0; q < 500; q++, i++)\n    {\n      pos[q][X] = ((rand() / ((double) 32767)) * 2) - 1;\n      pos[q][Y] = ((rand() / ((double) 32767)) * 2) - 1;\n      old_pos[i][X] = pos[q][X];\n      old_pos[i][Y] = pos[q][Y];\n      vel[q][X] = ((rand() / ((double) 32767)) * 2) - 1;\n      vel[q][Y] = ((rand() / ((double) 32767)) * 2) - 1;\n      mass[q] = fabs(((rand() / ((double) 32767)) * 2) - 1);\n    }\n\n  }\n  for (q = 0; q < 500; q++)\n  {\n    {\n      for (k = 0; k < 500; k++)\n      {\n        if (k > q)\n        {\n          x_diff = pos[q][X] - pos[k][X];\n          y_diff = pos[q][Y] - pos[k][Y];\n          dist = sqrt((x_diff * x_diff) + (y_diff * y_diff));\n          dist_cubed = (dist * dist) * dist;\n          force_qk[q][X] = (((6.674e-11 * mass[q]) * mass[k]) / dist_cubed) * x_diff;\n          force_qk[q][Y] = (((6.674e-11 * mass[q]) * mass[k]) / dist_cubed) * y_diff;\n          forces[q][X] += force_qk[q][X];\n          forces[q][Y] += force_qk[q][Y];\n          forces[k][X] -= force_qk[q][X];\n          forces[k][Y] -= force_qk[q][Y];\n        }\n\n      }\n\n    }\n  }\n\n  {\n    for (h = 0; h < 500; h++)\n    {\n      pos[h][X] += 0.05 * vel[h][X];\n      pos[h][Y] += 0.05 * vel[h][Y];\n      vel[h][X] += (0.05 / mass[h]) * forces[h][X];\n      vel[h][Y] += (0.05 / mass[h]) * forces[h][Y];\n    }\n\n  }\n}\n\n", "pragma": "omp parallel shared(forces, force_qk,mass,pos,dist,dist_cubed,x_diff,y_diff) private(q,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gibchikafa/openmp/third_law(Parallel)/0"}
{"code": "for (c2 = (nj > nm) ? (nj) : (nm); c2 <= (nk + (-1)); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/20"}
{"code": "for (int i = 0; i <= sN; i++)\n  for (int k = 0; k <= K; k++)\n  for (int j = st; j < end; j++)\n  A[idx(i, j, k)] = B[idx(i, j, k)];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/111"}
{"code": "for (int i = 1; i <= n; i++)\n  scanf(\"%d\", &h[i].a);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/1640675651/openmp_test/sellman_mp_v2.0/1"}
{"code": "for (int i = 0; i < lda; i++)\n{\n  int i_pos = ((((i / 8) * 8) * lda) + (0 * 8)) + (i % 8);\n  for (int j = 0; j < lda; j++)\n  {\n    dest[i_pos + (j * 8)] = src[(j * lda) + i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/0"}
{"code": "for (n = n_start; n <= n_stop; n += 1)\n{\n  int i;\n  for (i = 0; i < dim; ++i)\n  {\n    xdim[i] = sample_interval(a, b);\n  }\n\n  funcL_sum += funcL(xdim);\n}\n\n", "pragma": "omp parallel for private(xdim) reduction(+: funcL_sum) num_threads(threads_tot)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mtduman/DSC520_Prj_OpenMP/hw4_p3e9/0"}
{"code": "for (int i = 1; i < (grid->getNXC() - 1); i++)\n  for (int j = 1; j < (grid->getNYC() - 1); j++)\n  for (int k = 1; k < (grid->getNZC() - 1); k++)\n{\n  const double q = q_factor * EMf->getRHOcs(i, j, k, ns);\n  u0 = EMf->getJxs(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (u0 > c)\n  {\n    (cout << \"DRIFT VELOCITY x > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  v0 = EMf->getJys(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (v0 > c)\n  {\n    (cout << \"DRIFT VELOCITY y > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  w0 = EMf->getJzs(i, j, k, ns) / EMf->getRHOns(i, j, k, ns);\n  if (w0 > c)\n  {\n    (cout << \"DRIFT VELOCITY z > c : B init field too high!\") << endl;\n    MPI_Abort(MPI_COMM_WORLD, 2);\n  }\n\n  for (int ii = 0; ii < npcelx; ii++)\n    for (int jj = 0; jj < npcely; jj++)\n    for (int kk = 0; kk < npcelz; kk++)\n  {\n    double u;\n    double v;\n    double w;\n    sample_maxwellian(u, v, w, uth, vth, wth, u0, v0, w0);\n    const double x = ((ii + .5) * (dx / npcelx)) + grid->getXN(i, j, k);\n    const double y = ((jj + .5) * (dy / npcely)) + grid->getYN(i, j, k);\n    const double z = ((kk + .5) * (dz / npcelz)) + grid->getZN(i, j, k);\n    create_new_particle(u, v, w, q, x, y, z);\n  }\n\n\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/7"}
{"code": "for (j = 0; j < m; j++)\n  for (i = 0; i < n; i++)\n  uold[i + (m * j)] = u[i + (m * j)];\n\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shayany/openmp/applications/c_Jacobi/c_jacobi01/0"}
{"code": "for (i = 1; i < Nx; i++)\n{\n  for (j = 1; j < Ny; j++)\n  {\n    u[i][j] = (((u_1[i][j] * (1 - (2 * g))) + (dt * V(x[i], y[j]))) + ((0.5 * g) * (((u_1[i + 1][j] + u_1[i][j + 1]) + u_1[i - 1][j]) + u_1[i][j - 1]))) + ((0.5 * pow(dt, 2)) * f(x[i], y[j], 0));\n  }\n\n}\n\n", "pragma": "omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/esmyrnio/wave_2D_solver/2dWaveSolver/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"[\");\n  for (j = 0; j < n; j++)\n    printf(\" %10.6f \", phi[(j * n) + i]);\n\n  printf(\"]\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/obernardocosta/High-Performance-Computing-HPC/OPEN_MP/3/heatdiff/2"}
{"code": "for (col = 0; col < LX1; col++)\n{\n  i = 0;\n  tmp[col][i] = tmor[col][i];\n  for (i = 1; i < (LX1 - 1); i++)\n  {\n    for (j = 0; j < LX1; j++)\n    {\n      tmp[col][i] = tmp[col][i] + (qbnew[0][j][i - 1] * tmor[col][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/transfer/15"}
{"code": "for (i = 0; i < 102400; i++)\n{\n  psum += vecA[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/csc-training/hybrid-openmp-mpi/reduction/solution/sum/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = i; j < size; j++)\n  {\n    if (i == j)\n      arr[(size * i) + j] = 1;\n    else\n    {\n      double bin = ((double) rand()) / 32767;\n      if (bin <= (0.01 * density))\n        arr[(size * i) + j] = 1;\n      else\n        arr[(size * i) + j] = 0;\n\n    }\n\n  }\n\n  for (int j = 0; j < i; j++)\n    arr[(size * i) + j] = arr[(size * j) + i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/13"}
{"code": "for (i = MAX_COLS - 1; i >= 0; --i)\n{\n  output[count[(iArray[i] / iExp) % 10] - 1] = iArray[i];\n  count[(iArray[i] / iExp) % 10]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/josh-windsor/OpenMP-SIMD-Sorting/MAPS Assignement 1 Josh Windsor/Sort Out for Assignment/12"}
{"code": "for (edge_t e = G->begin[source]; e < G->begin[source + 1]; e++)\n{\n  node_t d = G->node_idx[e];\n  if ((comm[d] == commId) && (visited[commpos[d]] == 0))\n  {\n    stacklist[sortedSize] = d;\n    visited[commpos[d]] = 1;\n    sortedSize++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/preprocess/8"}
{"code": "for (k = 0; k < 8; k++)\n{\n  next_x = x + xMove[k];\n  next_y = y + yMove[k];\n  if (isSafe(next_x, next_y, sol))\n  {\n    sol[next_x][next_y] = movei;\n    if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n      return 1;\n    else\n      sol[next_x][next_y] = -1;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saikrishna315/Implementation-of-Classical-Problems-using-OpenMp/NKnights tour/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  mean[i][0] = meantemp[i][0];\n  mean[i][1] = meantemp[i][1];\n  mean[i][2] = meantemp[i][2];\n  mean[i][3] = meantemp[i][3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MohamedAhmedIsmail/Kmeans-OpenMp-and-Sequential/K-MeansDC/Source/3"}
{"code": "for (int i = 0; i < solution_set.size(); i++)\n{\n  ((cout << \"solution \") << i) << \" : \";\n  for (int j = 0; j < solution_set[j].size(); j++)\n  {\n    (cout << solution_set[i][j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mdkul22/satsolve/satool_omp/7"}
{"code": "for (n = 2; n <= num; ++n)\n  fac *= n;\n\n", "pragma": "omp parallel for reduction(*:fac)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/simpajj/go-parallel-benchmarks/src/component-factorial/component-factorial/0"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    for (n = 0; n <= 4; n += 1)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (lhs[i][j][k][2][m][n] * rhs[i][j + 1][k][n]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/144"}
{"code": "for (int i = 0; i < m; i++)\n  if (Y[i] != Y_golden[i])\n  errorcount_parallel_avx512++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/XiaosongAI/Parallel-SpMV/spmv_avx512/1"}
{"code": "for (long long i = 0; i < n; i++)\n  if (vxv[i] != (v1[i] * v2[i]))\n{\n  err++;\n  printf(\"vxv[%lld] = %lf, should be %lf\\n\", i, vxv[i], v1[i] * v2[i]);\n  if (err > 10)\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/target_nowait/target_nowait/1"}
{"code": "for (j = 0; j < K; j++)\n  if (i != j)\n{\n  devidedDistances += clusters[i].diameter / sqrt((pow(clusters[i].centerX - clusters[j].centerX, 2) + pow(clusters[i].centerY - clusters[j].centerY, 2)) + pow(clusters[i].centerZ - clusters[j].centerZ, 2));\n}\n\n\n", "pragma": "#pragma omp parallel for reduction(+ : devidedDistances)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SlavKhizverg/Parallel-Computation---written-in-C-using-openMP-and-MPI/ParallelProject/Source/8"}
{"code": "for (i = 0; i < numParticles; i++)\n{\n  jsum = 0.0;\n  for (j = 0; j != i; j++)\n  {\n    if (i == j)\n      continue;\n\n    difference = calcDistance(p[i], p[j]) - distanceMean;\n    jsum += difference * difference;\n  }\n\n  isum += jsum / (numParticles - 1);\n}\n\n", "pragma": "omp for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mmccammo/parallelProg/particles/7"}
{"code": "for (i = 0; i < nrow; i++)\n{\n  for (j = 0; j < ncol; j++)\n  {\n    printf(\"%8.2e \", *((ary + (size * i)) + j));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gaussian-omp/gaussianElim/12"}
{"code": "for (i = 0; i < 2048; i++)\n{\n  for (j = 0; j < 2048; j++)\n  {\n    grid[i][j] = newgrid[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patricia-souza/JogoVidaOpenMP/Critical/4"}
{"code": "for (int i = 0; i < FRAMES_PER_BUFFER; i++)\n{\n  data->monoDelay[(posActual + i) % DELAY_SIZE] = in[i];\n}\n\n", "pragma": "    #pragma omp parallel for shared(in, data, posActual)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SurturTawers/OpenMP-ReverbDSP/reverbParalelo/0"}
{"code": "for (register int s = 0; s < getNOP(); s++)\n{\n  temp = u[s];\n  temp2 = v[s];\n  u[s] = (temp * cos(theta)) + (v[s] * sin(theta));\n  v[s] = ((-temp) * sin(theta)) + (temp2 * cos(theta));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/23"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = (double) rand_double(1.0);\n  y = (double) rand_double(1.0);\n  if (((x * x) + (y * y)) <= 1)\n  {\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mishal23/parallel-programming-openmp/value-of-pi/value-of-pie-random-generator/0"}
{"code": "for (int i = 0; i < bmiHeader.biHeight; i++)\n{\n  for (int j = 0; j < bmiHeader.biWidth; j++)\n  {\n    putc(rgb[i][j].rgbRed, oFile);\n    putc(rgb[i][j].rgbGreen, oFile);\n    putc(rgb[i][j].rgbBlue, oFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab3/2/2"}
{"code": "for (int i = 0; i < arrSize; i++)\n{\n  a[i] = 3.0;\n  b[i] = 2.0;\n  c[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/benchmarks/ecp-omp/type1/structuredGrid/bench_stencil/1"}
{"code": "for (k = 1; k <= (n - 1); k++)\n  local_integral += f(a + (k * h));\n\n", "pragma": "#pragma omp parallel for private(local_integral) default(shared)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/poodarchu/parallel-computing/OpenMP+MPI/trapezoidal_integral/0"}
{"code": "for (i = lower; i < upper; i += stride)\n{\n  k_3++;\n}\n\n", "pragma": "omp for schedule(static,chunksize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/inputOmpfor/2"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmppu_qfd8m.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang8/projects/openmp/runtime/test/affinity/format/affinity_values/6"}
{"code": "for (int i = 0; i < layerHeight; i++)\n{\n  for (int j = 0; j < layerWidth; j++)\n  {\n    backValues[i][j] = ((-(desiredOutput - max((double) 0, output))) * max((double) 0, output)) * (1 - max((double) 0, output));\n  }\n\n}\n\n", "pragma": "    #pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/trainer/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  s->Bt = s->sBt;\n  s->Bt[i] = s->Mcoefs_3d[1][1][i] * x[i];\n  if ((i - (sN + 2)) >= 0)\n    s->Bt[i] += s->Mcoefs_3d[1][0][i] * x[i - (sN + 2)];\n\n  if ((i + (sN + 2)) < N)\n    s->Bt[i] += s->Mcoefs_3d[1][2][i] * x[i + (sN + 2)];\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/151"}
{"code": "for (c = 0; c < size; ++c)\n{\n  if (outgoing_reqs_active[c])\n  {\n    int flag;\n    MPI_Test(&outgoing_reqs[c], &flag, (MPI_Status *) 1);\n    if (flag)\n      outgoing_reqs_active[c] = 0;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/bfs_simple/3"}
{"code": "for (i = 0; i < NUM_OF_NODES; i++)\n{\n  for (j = 0; j < NUM_OF_NODES; j++)\n  {\n    P[i][j] = (options.c * P[i][j]) + ((1 - options.c) * options.v[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anapt/PageRank/src/parallel/8"}
{"code": "for (int i = 0; i < chromo_length; i++)\n  if (chro1.genes[i] != chro2.genes[i])\n  sum++;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/14"}
{"code": "for (i = 0; i < grid_size; i++)\n{\n  for (int j = 0; j < grid_size; j++)\n  {\n    grid_arr[i][j] = grid_arr_temp[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/LR8/LR8_0/3"}
{"code": "for (grupoId = 0; grupoId < gap; grupoId++)\n  for (i = gap + grupoId; i < (n - grupoId); i += gap)\n{\n  int key = arr[i];\n  j = i - gap;\n  while ((j >= 0) && (arr[j] > key))\n  {\n    arr[j + gap] = arr[j];\n    j -= gap;\n  }\n\n  arr[j + gap] = key;\n}\n\n\n", "pragma": "omp parallel for private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Trees-Over-The-Lake/OpenMP-ACIII/Shell Sort/parallel/0"}
{"code": "for (int i = 0; i < dim->rows; i++)\n{\n  for (int j = 0; j < dim->columns; j++)\n    first->cells[i][j] = second->cells[i][j];\n\n}\n\n", "pragma": "omp parallel for collapse(2) schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pawellski/parallel-wire-world/Game/2"}
{"code": "for (i = 0; i < clustar_num; i++)\n  fscanf(fc, \"%d %d\", &cluster[i].x, &cluster[i].y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AhmedeZ2001/K-means-Clustering/2/6"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  printf(\"%d -> \", Route[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GeoSko/Neural-Network-K-means-and-Ant-Colony-Optimization-implemetations-with-C-and-OpenMP/Ant Colony Optimization/ex2/tsp2/4"}
{"code": "for (int i = 0; i < num_objs; i++)\n  objs[i].allocate_on_device();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jtramm/omp_target_issues/alloc/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  a[i] = i + 3;\n  for (int j = 0; j < n; j++)\n    b[i][j] = a[i];\n\n}\n\n", "pragma": "omp parallel for shared (n, a, b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr39154/2"}
{"code": "for (var = 0; var < taskList.size(); var++)\n{\n  int min = 0;\n  int lmax = var;\n  int up = min + (rand() % ((lmax - min) + 1));\n  for (int var2 = 0; var2 < up; var2++)\n  {\n    lmax = lmax - 1;\n    int rand2 = min + (rand() % ((lmax - min) + 1));\n    bool t = false;\n    for (unsigned int var3 = 0; var3 < taskList[var].deplist.size(); var3++)\n    {\n      if (taskList[var].deplist[var3] == rand2)\n      {\n        t = true;\n        break;\n      }\n\n    }\n\n    if (!t)\n    {\n      taskList[var].deplist.push_back(rand2);\n    }\n\n  }\n\n  sort(taskList[var].deplist.begin(), taskList[var].deplist.end());\n}\n\n", "pragma": "#pragma omp parallel for private(var)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/deepsidhu1313/exploiting_parallelism_in_GA_task_scheduler_using_openMP/GeneticAlgo/src/GeneticAlgo/11"}
{"code": "for (i = 0; i < _PB_N; i++)\n{\n  for (j = 0; j < _PB_N; j++)\n    C[i][j] += 42;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/utilities/template-for-new-benchmark/3"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  dky = dny * ((float) k);\n  v_dky = _mm_mul_ps(v_dny, _mm_cvtepi32_ps(_mm_set1_epi32(k)));\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  v_wp = _mm_set1_pd(0.0);\n  for (j = 0; j < nxhs; j += 2)\n  {\n    v_at1 = _mm_load_ps((float *) (&ffc[j + kk]));\n    v_at1 = _mm_mul_ps(v_at1, _mm_shuffle_ps(v_at1, v_at1, 177));\n    v_it = _mm_add_epi32(_mm_set1_epi32(j), v_j);\n    v_at2 = _mm_mul_ps(v_dnx, _mm_cvtepi32_ps(v_it));\n    v_at2 = _mm_mul_ps(v_at1, v_at2);\n    v_at3 = _mm_mul_ps(v_dky, v_at1);\n    v_zt1 = _mm_load_ps((float *) (&q[j + kj]));\n    v_zt1 = _mm_mul_ps(v_zt1, v_m);\n    v_zt1 = _mm_shuffle_ps(v_zt1, v_zt1, 177);\n    v_zt2 = _mm_load_ps((float *) (&q[j + k1]));\n    v_zt2 = _mm_mul_ps(v_zt2, v_m);\n    v_zt2 = _mm_shuffle_ps(v_zt2, v_zt2, 177);\n    if (j == 0)\n    {\n      v_at4 = _mm_castsi128_ps(_mm_set_epi32(-1, -1, 0, 0));\n      v_zt1 = _mm_and_ps(v_zt1, v_at4);\n      v_zt2 = _mm_and_ps(v_zt2, v_at4);\n    }\n\n    v_at4 = _mm_mul_ps(v_at2, v_zt1);\n    v_zt4 = _mm_mul_ps(v_at3, v_zt1);\n    v_at4 = _mm_mul_ps(v_at2, v_zt1);\n    v_zt4 = _mm_mul_ps(v_at3, v_zt1);\n    v_zt3 = _mm_shuffle_ps(v_at4, v_zt4, 68);\n    v_zt4 = _mm_shuffle_ps(v_at4, v_zt4, 238);\n    _mm_store_ps((float *) (&fxy[2 * (j + kj)]), v_zt3);\n    _mm_store_ps((float *) (&fxy[2 * ((j + 1) + kj)]), v_zt4);\n    v_at4 = _mm_mul_ps(v_at2, v_zt2);\n    v_zt4 = _mm_sub_ps(v_zero, _mm_mul_ps(v_at3, v_zt2));\n    v_zt3 = _mm_shuffle_ps(v_at4, v_zt4, 68);\n    v_zt4 = _mm_shuffle_ps(v_at4, v_zt4, 238);\n    _mm_store_ps((float *) (&fxy[2 * (j + k1)]), v_zt3);\n    _mm_store_ps((float *) (&fxy[2 * ((j + 1) + k1)]), v_zt4);\n    v_at4 = _mm_mul_ps(v_zt1, v_zt1);\n    v_at4 = _mm_add_ps(v_at4, _mm_mul_ps(v_zt2, v_zt2));\n    v_at4 = _mm_mul_ps(v_at1, v_at4);\n    v_d = _mm_cvtps_pd(v_at4);\n    v_wp = _mm_add_pd(v_wp, v_d);\n    v_it = _mm_srli_si128((int) v_at4, 8);\n    v_d = _mm_cvtps_pd((int) v_it);\n    v_wp = _mm_add_pd(v_wp, v_d);\n  }\n\n  it = (1 > nxhs) ? (1) : (nxhs);\n  for (j = it; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxy[(2 * j) + (2 * kj)] = at2 * zt1;\n    fxy[(1 + (2 * j)) + (2 * kj)] = at3 * zt1;\n    fxy[(2 * j) + (2 * k1)] = at2 * zt2;\n    fxy[(1 + (2 * j)) + (2 * k1)] = (-at3) * zt2;\n    wp += at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n  }\n\n  _mm_store_pd(&dd[0], v_wp);\n  for (j = 1; j < 2; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum1 += wp + dd[0];\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp,v_it,v_dky,v_at1, v_at2,v_at3,v_at4,v_zt1,v_zt2,v_zt3,v_zt4,v_wp,v_d,dd) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmpic2/ssempush2/2"}
{"code": "for (i = 0; i < n; i++)\n  b[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P1/2/single-modificado/1"}
{"code": "for (int i = 0; i < file_size; i++)\n{\n  freq[buffer[i] - 0]++;\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: freq) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NickDeca/OpenMp/char_freq_paral/0"}
{"code": "for (i = 0; i < n; ++i)\n  temp += x[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi/main/0"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EhsanAmiryousefi/MasterThesis/llvm/tools/clang/test/OpenMP/nesting_of_regions/13"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  ASvec.push_back((shared_ptr < AbstractState) > factory(\"HEOS\", \"CO2\"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhenhaochu/CoolProp_openmp_test/main/0"}
{"code": "for (uint64_t k = 0; k < l; k++)\n  for (uint64_t j = 0; j < n; j++)\n  Bt[(j * l) + k] = B[(k * n) + j];\n\n\n", "pragma": "    #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JGU-HPC/parallelprogrammingbook/chapter3/matrix_matrix_mult_transposed/matrix_mult/0"}
{"code": "for (i = 0; i < 32; i++)\n{\n  printf(\"Thread %d: Calculating row %d\\n\", tid, i);\n  for (j = 0; j < 32; j++)\n  {\n    for (k = 0; k < 32; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reissmann/openmp_talk/matrix/0"}
{"code": "for (i = 0; i < xx; i += 2)\n  temp[i >> 1] = input[i] + input[i + 1];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/Old/2"}
{"code": "for (long i = 0; i < N1; i++)\n{\n  if (C2[i] == (-1))\n  {\n    C2[i] = nC2;\n    found = true;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilityClusterComparisonMetrics/3"}
{"code": "for (j = 1; j <= LOOPCOUNT; j++)\n{\n  sum = sum + j;\n}\n\n", "pragma": "omp for schedule(dynamic, 1) reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/tests/test_for_reduction/0"}
{"code": "for (int i = 0; i < nNodes; ++i)\n{\n  int nodeDegree = nodes[i].nNeighbors;\n  int nodeColor = nodes[i].color;\n  if (nodeDegree > maxNodeDegree)\n    maxNodeDegree = nodeDegree;\n\n  if (nodeColor > maxColorUsed)\n    maxColorUsed = nodeColor;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JulianArmour/openmp_test/q2/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  array[i] = i * val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/benman1/parallel_reduction_example/reduction/0"}
{"code": "for (i = 0; i < dim; i++)\n{\n  if (i != k)\n  {\n    temp = mat1[i][k] / mat1[k][k];\n    for (j = k + 1; j < dim; j++)\n      mat1[i][j] -= temp * mat1[k][j];\n\n    y1[i] -= temp * y1[k];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/parallel_laboratory/parallel/SharedMemory-GJ/bench-omp/0"}
{"code": "for (i = 0; i < 10; i++)\n  for (j = 0; j < 10; j++)\n{\n  r = r + 1;\n  p = q;\n  dosomething(a, n, p + q);\n  p = q;\n  s = (i * 10) + j;\n}\n\n\n", "pragma": "omp target teams distribute parallel for device (n + 1) num_teams (n + 4) if (n != 6)map (from: n) map (alloc: a[2:o-2]) default(shared) private (p) firstprivate (q) shared (n) reduction (+: r) thread_limit (n * 2) dist_schedule (static, 4) collapse (2) num_threads (n + 4) proc_bind (spread) lastprivate (s) schedule (static, 8)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr61486-2/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    (cout << z[((((t % 3) * size) * size) + (i * size)) + j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shirley1988/Wave-Simulation/mpdWave/3"}
{"code": "for (i = 0; i < (dimensionSize + 1); i++)\n{\n  AllWeights[i] = (double *) calloc(dimensionSize + 1, sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vigalva/Parallel-Preceptron-Algorithm/FinaleParallelProject/MyApp/12"}
{"code": "for (int i = 1; i < ARR_SIZE; ++i)\n{\n  if (histogram[i] != 0)\n    printf(\"%d: %d\\n\", i, histogram[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NaorFahima/Parallel-And-Distributed-Computing/Exercise 3/histogram/5"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  if (hDist[i] > 0)\n    printf(\"I = %d, count = %d, fraction = %f\\n\", i, hDist[i], ((real_t) hDist[i]) / ((real_t) hsize));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/8"}
{"code": "for (i = 0; i < N; i++)\n{\n  result += pow(x[i], 2);\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:result) private(i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aidandos/high_performance_computing/assignment4/miniapp_openmp/linalg/1"}
{"code": "for (i = 0; i < nRows; i = i + 1)\n{\n  totThreads = omp_get_num_threads();\n  for (j = 0; j < nCols; j = j + 1)\n  {\n    T[j][i] = A[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlainKubwayo/ompmatrixtranspose/matrix_transpose/0"}
{"code": "for (i = 1; i < (M - 1); i++)\n{\n  for (j = 1; j < (N - 1); j++)\n  {\n    if (obtd_diff < fabs(w[i][j] - u[i][j]))\n    {\n      obtd_diff = fabs(w[i][j] - u[i][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abhin-kakkad/SteadyStateHeatEquation/Project_parallel/9"}
{"code": "for (i = 0; i < (input->d - 1); i++)\n  printf(\"%f,\", input->xh[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/14"}
{"code": "for (int i = 1; i < max_cols; i++)\n{\n  for (int j = 1; j < max_rows; j++)\n  {\n    referrence_cpu[(i * max_cols) + j] = blosum62[input_itemsets_cpu[i * max_cols]][input_itemsets_cpu[j]];\n    referrence_gpu[(i * max_cols) + j] = blosum62[input_itemsets_gpu[i * max_cols]][input_itemsets_gpu[j]];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/Rodinia/nw/src/needle/4"}
{"code": "for (int i = 0; i < min(array1.size(), array2.size()); i++)\n{\n  scalar_product = scalar_product + (array1[i] * array2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mikhail11235/openmp/scalar_product/0"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (j = 1; j < (grid_points[1] - 1); j++)\n  {\n    for (k = 1; k < (grid_points[2] - 1); k++)\n    {\n      wijk = ws[i][j][k];\n      wp1 = ws[i][j][k + 1];\n      wm1 = ws[i][j][k - 1];\n      rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n      rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n      rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n      rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n      rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(wijk, wp1, wm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/57"}
{"code": "for (int i = 0; i < n; i++)\n{\n  mx += bodies[i].m * bodies[i].v[0];\n  my += bodies[i].m * bodies[i].v[1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DiWu9/UnionCS-CSC333-Parallel/csc333-final-project/OMP_Nbody/9"}
{"code": "for (int i = 0; i < m; i++)\n{\n  b[i] = -b[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/27"}
{"code": "for (int j = 0; j < m; j++)\n{\n  double prediction = predict_one(x[j], theta);\n  double diff = prediction - y[j];\n  errors_x1_sum += diff;\n  errors_x2_sum += diff * x[j];\n}\n\n", "pragma": "omp parallel for simd reduction(+:errors_x1_sum, errors_x2_sum) firstprivate(theta, m, x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/IlyaCES/openmp_openmpi_labs/kursach/c/linear_regression/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < (i + 1); j++)\n  {\n    fin >> L[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gurbaaz27/CS433A-Design-Exercises/assignment1/Q2/0"}
{"code": "for (int j = 0; j < layers[nOfLayers - 1].nOfNeurons; j++)\n{\n  layers[nOfLayers - 1].neurons[j].out = exp(layers[nOfLayers - 1].neurons[j].net) / (1 + sumNet);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/8"}
{"code": "for (i = k; i < rows; i++)\n{\n  for (j = k; j < cols; j++)\n  {\n    grad_x = 0, grad_y = 0;\n    for (m = -k; m <= k; m++)\n    {\n      for (n = -k; n <= k; n++)\n      {\n        grad_x += img[((i + m) * cols) + (j + n)] * sobel_h[((m + k) * filter_sz) + (n + k)];\n        grad_y += img[((i + m) * cols) + (j + n)] * sobel_v[((m + k) * filter_sz) + (n + k)];\n      }\n\n    }\n\n    grad = sqrt((grad_x * grad_x) + (grad_y * grad_y));\n    if (grad > 255)\n      G_x[(i * cols) + j] = 255;\n    else\n      G_x[(i * cols) + j] = grad;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhattagoutham/parallel-programming/1_edge_detection/sobel_omp/2"}
{"code": "for (i = 0; i < mat->size; ++i)\n{\n  m[i][i] = 1.0;\n}\n\n", "pragma": "omp parallel for private(i) shared(m, mat)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DementevVV/openmp-inverse/src/matrix/1"}
{"code": "for (i = 0; i < 1024; ++i)\n{\n  OMPVV_TEST_AND_SET(errors, a[i] != 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/target_teams_distribute_parallel_for/test_target_teams_distribute_parallel_for_map_from/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  fscanf(f, \"%i\", &tab[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pangoso/OpenMP-Bitonic-Sort/bitonic_sort_par/2"}
{"code": "for (curr_coord = 0; curr_coord < exam_coords; curr_coord++)\n{\n  if (process_coords(file_ptr) == 0)\n    valid_collisions++;\n\n  if ((max_nsecs != (-1)) && (calculate_difference(start, current, 0) > max_nsecs))\n  {\n    clock_gettime(CLOCK_MONOTONIC, &current);\n    printf(\"Reached maximum time limit.\\n\");\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AlexKasapis/OpenMP/Examine/4"}
{"code": "for (unsigned int k = 0; k < 256; ++k)\n{\n  arr[k] = (long *) malloc(N * (sizeof(long)));\n  for (unsigned int curThread = 0; curThread < N; ++curThread)\n  {\n    arr[k][curThread] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dankleying/openmp/histogram/histo_creative2/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %i at itr %i \\n\", omp_get_thread_num(), i);\n  x[i] = (double) i;\n}\n\n", "pragma": "omp for schedule(dynamic,8)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mdh266/OpenMP_Practice/array3/0"}
{"code": "for (int i = 0; i < comp_list.size(); i++)\n{\n  ((((cout << \"p1 \") << comp_list[i].p1.x) << \" \") << comp_list[i].p1.y) << endl;\n  ((((cout << \"p2 \") << comp_list[i].p2.x) << \" \") << comp_list[i].p2.y) << endl;\n  for (int j = 0; j < comp_list[i].v.size(); j++)\n  {\n    (((cout << comp_list[i].v[j].x) << \" \") << comp_list[i].v[j].y) << \", \";\n  }\n\n  cout << endl;\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/saketdingliwal/openMP/quick_3/0"}
{"code": "for (i = 0; i < NX; i++)\n{\n  psum += vecA[i];\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/hybrid/reduction/solution/sum/0"}
{"code": "for (size_t i = 0; i < x; i++)\n{\n  for (size_t j = 0; j < y; j++)\n  {\n    C[(i * y) + j] = 0;\n    for (size_t k = 0; k < z; k++)\n    {\n      C[(i * y) + j] += A[(i * z) + k] * B[(k * z) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/3"}
{"code": "for (i = 0; i < r; i++)\n{\n  sum[i] = (float *) malloc(c * (sizeof(float)));\n  diff[i] = (float *) malloc(c * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dhanya-Abhirami/Parallel-and-Distributed-Computing-Lab/Assignment2/lab2_2/4"}
{"code": "for (size_t i = 0; i < count; ++i)\n{\n  a[i] = value;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drons/nbody/nbody/nbody_engine_openmp/1"}
{"code": "for (i = 0; i < t; i++)\n  pos[i] = (pos[i >> 1] >> 1) | ((i & 1) << (n0 - 1));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Alexhaoge/FFT-MPI-OpenMP-CUDA/OpenMP_fft_v1/6"}
{"code": "for (y = 1; y < (100 - 1); y++)\n{\n  const float weights[] = {3, 5, 7, 9, 11, 13, 15, 17, 19};\n  #pragma clang loop unroll_count(UNROLL_COUNT)\n  for (x = 1; x < (256 - 1); x++)\n  {\n    arraySol[x + (y * 256)] = ((((((((weights[0] * array[((x + (y * 256)) - 256) - 1]) + (weights[1] * array[(x + (y * 256)) - 256])) + (weights[2] * array[((x + (y * 256)) - 256) + 1])) + (weights[3] * array[(x + (y * 256)) - 1])) + (weights[4] * array[x + (y * 256)])) + (weights[5] * array[(x + (y * 256)) + 1])) + (weights[6] * array[((x + (y * 256)) + 256) - 1])) + (weights[7] * array[(x + (y * 256)) + 256])) + (weights[8] * array[((x + (y * 256)) + 256) + 1]);\n  }\n\n}\n\n", "pragma": "omp target parallel for map(to:array[:N]) map(from:arraySol[:N]) private(x,y)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hal-lab-u-tokyo/CGRAOmp/share/samples/conv/conv/0"}
{"code": "for (int j = 0; j < BCols; ++j)\n{\n  for (int i = 0; i < ARows; ++i)\n  {\n    int value = 0;\n    for (int k = 0; k < ACols; ++k)\n    {\n      value += matrixA[(i * ACols) + k] * matrixB[(k * BCols) + j];\n    }\n\n    if (matrixC[(i * BCols) + j] != value)\n    {\n      ++n_errors;\n      printf(\"\\tError: Matrices miscompare devC[%d,%d]-hostC: %d\\n\", i, j, matrixC[(i * BCols) + j] - value);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/hip-openmp/matrixmul_omp_for/matrixmul/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tony-yang/learning-openmp/03_computing_sum_incorrect/0"}
{"code": "for (digit = _start; digit < _end; ++digit)\n{\n  digits[digit] = 0;\n  for (j = 0; j < nthread; j++)\n    aux[j][digit] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonardocreatus/Progama-oParalela-OpenMP/reduction2/0"}
{"code": "for (i = 0; i < lin; i++)\n{\n  matriz[i] = (int *) calloc(col, sizeof(int));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoborgesdeoliveira/Matrix-Multiplication-and-Sum-with-OpenMP-and-PThreads/Matrizes OpenMP/matriz2d/5"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < n1; i1++)\n    {\n      r1[i1] = ((r[i3][i2 - 1][i1] + r[i3][i2 + 1][i1]) + r[i3 - 1][i2][i1]) + r[i3 + 1][i2][i1];\n      r2[i1] = ((r[i3 - 1][i2 - 1][i1] + r[i3 - 1][i2 + 1][i1]) + r[i3 + 1][i2 - 1][i1]) + r[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      u[i3][i2][i1] = ((u[i3][i2][i1] + (c[0] * r[i3][i2][i1])) + (c[1] * ((r[i3][i2][i1 - 1] + r[i3][i2][i1 + 1]) + r1[i1]))) + (c[2] * ((r2[i1] + r1[i1 - 1]) + r1[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for      ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/10"}
{"code": "for (int i = 0; i < data.Len(); i++)\n{\n  double zi = data[i].Key;\n  int yi = data[i].Dat;\n  double e = exp(((-A) * zi) + B);\n  double denum = 1.0 + e;\n  double prob = (yi > 0) ? (1.0 / denum) : (e / denum);\n  J -= log((prob < 1e-20) ? (1e-20) : (prob));\n  sum_all_PyNeg += e / denum;\n  sum_all_ziPyNeg += (zi * e) / denum;\n  if (yi < 0)\n  {\n    sum_yNeg_zi += zi;\n    sum_yNeg_1 += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/90"}
{"code": "for (int i = 0; i < n; i++)\n{\n  (((((((((((((((((cout << p[i].pid) << \"\\t\") << p[i].arrival_time) << \"\\t\") << p[i].burst_time) << \"\\t\") << p[i].start_time) << \"\\t\") << p[i].completion_time) << \"\\t\") << p[i].turnaround_time) << \"\\t\") << p[i].waiting_time) << \"\\t\") << p[i].response_time) << \"\\t\") << \"\\n\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DroneGj/CPU_Scheduling_Parallel_Execution/CPP-Codes/Parallel/fcfs_parallel/2"}
{"code": "for (unsigned int i = 1; i <= (M.mesh.y_coordinates.size() - 1); i++)\n{\n  axpy(&M.thomas_denomy[i], M.thomas_constant1, M.thomas_cy[i - 1]);\n  M.thomas_cy[i] /= M.thomas_denomy[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rheiland/PhysiCell_clang_openmp/BioFVM/BioFVM_solvers/1"}
{"code": "for (j = jst; j <= jend; j += 1)\n{\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    flux[i][j][k][0] = u[i][j][k][3];\n    u41 = u[i][j][k][3] / u[i][j][k][0];\n    q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n    flux[i][j][k][1] = u[i][j][k][1] * u41;\n    flux[i][j][k][2] = u[i][j][k][2] * u41;\n    flux[i][j][k][3] = (u[i][j][k][3] * u41) + (0.40e+00 * (u[i][j][k][4] - q));\n    flux[i][j][k][4] = ((1.40e+00 * u[i][j][k][4]) - (0.40e+00 * q)) * u41;\n  }\n\n  for (k = 1; k <= (nz - 2); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (tz2 * (flux[i][j][k + 1][m] - flux[i][j][k - 1][m]));\n    }\n\n  }\n\n  for (k = 1; k <= (nz - 1); k += 1)\n  {\n    tmp = 1.0 / u[i][j][k][0];\n    u21k = tmp * u[i][j][k][1];\n    u31k = tmp * u[i][j][k][2];\n    u41k = tmp * u[i][j][k][3];\n    u51k = tmp * u[i][j][k][4];\n    tmp = 1.0 / u[i][j][k - 1][0];\n    u21km1 = tmp * u[i][j][k - 1][1];\n    u31km1 = tmp * u[i][j][k - 1][2];\n    u41km1 = tmp * u[i][j][k - 1][3];\n    u51km1 = tmp * u[i][j][k - 1][4];\n    flux[i][j][k][1] = tz3 * (u21k - u21km1);\n    flux[i][j][k][2] = tz3 * (u31k - u31km1);\n    flux[i][j][k][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n    flux[i][j][k][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((1.40e+00 * 1.40e+00) * tz3) * (u51k - u51km1));\n  }\n\n  for (k = 1; k <= (nz - 2); k += 1)\n  {\n    rsd[i][j][k][0] = rsd[i][j][k][0] + ((dz1 * tz1) * ((u[i][j][k - 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k + 1][0]));\n    rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][1] - flux[i][j][k][1]))) + ((dz2 * tz1) * ((u[i][j][k - 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k + 1][1]));\n    rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][2] - flux[i][j][k][2]))) + ((dz3 * tz1) * ((u[i][j][k - 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k + 1][2]));\n    rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][3] - flux[i][j][k][3]))) + ((dz4 * tz1) * ((u[i][j][k - 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k + 1][3]));\n    rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][4] - flux[i][j][k][4]))) + ((dz5 * tz1) * ((u[i][j][k - 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k + 1][4]));\n  }\n\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][1][m] = rsd[i][j][1][m] - (dssp * ((((+5.0) * u[i][j][1][m]) - (4.0 * u[i][j][2][m])) + u[i][j][3][m]));\n    rsd[i][j][2][m] = rsd[i][j][2][m] - (dssp * (((((-4.0) * u[i][j][1][m]) + (6.0 * u[i][j][2][m])) - (4.0 * u[i][j][3][m])) + u[i][j][4][m]));\n  }\n\n  for (k = 3; k <= (nz - 4); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = rsd[i][j][k][m] - (dssp * ((((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])) + u[i][j][k + 2][m]));\n    }\n\n  }\n\n  for (m = 0; m <= 4; m += 1)\n  {\n    rsd[i][j][nz - 3][m] = rsd[i][j][nz - 3][m] - (dssp * (((u[i][j][nz - 5][m] - (4.0 * u[i][j][nz - 4][m])) + (6.0 * u[i][j][nz - 3][m])) - (4.0 * u[i][j][nz - 2][m])));\n    rsd[i][j][nz - 2][m] = rsd[i][j][nz - 2][m] - (dssp * ((u[i][j][nz - 4][m] - (4.0 * u[i][j][nz - 3][m])) + (5.0 * u[i][j][nz - 2][m])));\n  }\n\n}\n\n", "pragma": "omp parallel for private (q,u41,tmp,u21k,u31k,u41k,u51k,u21km1,u31km1,u41km1,u51km1,j,k,m) firstprivate (nz)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/114"}
{"code": "for (i = 1; i < K; i++)\n{\n  double dist;\n  sum = 0.0;\n  for (j = 0; j < total_values; j++)\n  {\n    sum += pow(clusters[i].getCentralValue(j) - point.getValue(j), 2.0);\n  }\n\n  dist = sqrt(sum);\n  if (dist < min_dist)\n  {\n    min_dist = dist;\n    id_cluster_center = i;\n  }\n\n}\n\n", "pragma": "#pragma omp for private(i,j) reduction(+:sum) collapse(1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bhabesh-chanduka/Parallel-K-Means/kmeans_omp/4"}
{"code": "for (int i = 0; i < vol_size; i++)\n{\n  if (data_threshold_h[i])\n  {\n    hist_h[ivf_h[i] + (ivg_h[i] * 256)] += 1;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/spm-omp/main/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sum = absum_vector(sum, vec[i]);\n}\n\n", "pragma": "omp parallel for reduction(absumv: sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cheshie/ParallelComputingSEM2OMP/lab11/lab11/0"}
{"code": "for (int i = 0; i < bHeight; i++)\n  for (int j = 0; j < bWidth; j++)\n  scanf(\"%d\", &B[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/ImageMatch/main/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  HMACMD5Context ctx;\n  unsigned char authKey[20];\n  unsigned char out[20];\n  if (cur_salt->authProtocol == 1)\n  {\n    snmp_usm_password_to_key_md5((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_md5_init_rfc2104(authKey, 16, &ctx);\n    hmac_md5_update(cur_salt->salt, cur_salt->salt_length, &ctx);\n    hmac_md5_final(out, &ctx);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n    else\n      cracked[index] = 0;\n\n  }\n  else\n    if (cur_salt->authProtocol == 2)\n  {\n    snmp_usm_password_to_key_sha((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_sha1(authKey, 20, cur_salt->salt, cur_salt->salt_length, out, 12);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n    else\n      cracked[index] = 0;\n\n  }\n  else\n    if (cur_salt->authProtocol == 0)\n  {\n    cracked[index] = 0;\n    snmp_usm_password_to_key_md5((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_md5_init_rfc2104(authKey, 16, &ctx);\n    hmac_md5_update(cur_salt->salt, cur_salt->salt_length, &ctx);\n    hmac_md5_final(out, &ctx);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n    {\n      cracked[index] = 1;\n      continue;\n    }\n\n    snmp_usm_password_to_key_sha((const uint8_t *) saved_key[index], strlen(saved_key[index]), cur_salt->engineID, cur_salt->engineLength, authKey);\n    hmac_sha1(authKey, 20, cur_salt->salt, cur_salt->salt_length, out, 12);\n    if (memcmp(out, cur_salt->msgAuthenticationParameters, 12) == 0)\n      cracked[index] = 1;\n\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/snmp_fmt_plug/0"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 2)\n    {\n      int pp = IDX(i, j, k);\n      if (betaz[pp] > 0.0)\n      {\n        Dzu[pp] = ((((((-3.0) * u[pp - n]) - (10.0 * u[pp])) + (18.0 * u[pp + n])) - (6.0 * u[pp + (2 * n)])) + u[pp + (3 * n)]) * idz_by_12;\n      }\n      else\n      {\n        Dzu[pp] = (((((-u[pp - (3 * n)]) + (6.0 * u[pp - (2 * n)])) - (18.0 * u[pp - n])) + (10.0 * u[pp])) + (3.0 * u[pp + n])) * idz_by_12;\n      }\n\n      if (betaz[pp + 1] > 0.0)\n      {\n        Dzu[pp + 1] = ((((((-3.0) * u[(pp + 1) - n]) - (10.0 * u[pp + 1])) + (18.0 * u[(pp + 1) + n])) - (6.0 * u[(pp + 1) + (2 * n)])) + u[(pp + 1) + (3 * n)]) * idz_by_12;\n      }\n      else\n      {\n        Dzu[pp + 1] = (((((-u[(pp + 1) - (3 * n)]) + (6.0 * u[(pp + 1) - (2 * n)])) - (18.0 * u[(pp + 1) - n])) + (10.0 * u[pp + 1])) + (3.0 * u[(pp + 1) + n])) * idz_by_12;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/16"}
{"code": "for (i = 0; i < (1000 + 1); ++i)\n{\n  if (tids[i] == lasttid)\n  {\n    tmp_count++;\n    fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n    continue;\n  }\n\n  if ((tids[i] == ((lasttid + 1) % threads)) || (tids[i] == (-1)))\n  {\n    if (tmp_count == chunk_size)\n    {\n      tmp_count = 1;\n      lasttid = tids[i];\n    }\n    else\n    {\n      if (tids[i] == (-1))\n      {\n        if (i == 1000)\n        {\n          fprintf(stderr, \"Last thread had chunk size %d\\n\", tmp_count);\n          break;\n        }\n        else\n        {\n          fprintf(stderr, \"ERROR: Last thread (thread with number -1) was found before the end.\\n\");\n          result = 0;\n        }\n\n      }\n      else\n      {\n        fprintf(stderr, \"ERROR: chunk size was %d. (assigned was %d)\\n\", tmp_count, chunk_size);\n        result = 0;\n      }\n\n    }\n\n  }\n  else\n  {\n    fprintf(stderr, \"ERROR: Found thread with number %d (should be inbetween 0 and %d).\", tids[i], threads - 1);\n    result = 0;\n  }\n\n  fprintf(stderr, \"%d: %d \\n\", i, tids[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_static/6"}
{"code": "for (i = 0; i < n_local_vertices; i++)\n{\n  const unsigned start = local_vertex_offsets[i];\n  const unsigned end = local_vertex_offsets[i + 1];\n  assert(start <= end);\n  local_vertex_offsets[i] = writing_index;\n  qsort(neighbors + start, end - start, sizeof(*neighbors), compare_uint64_t);\n  uint64_t reading_index = start;\n  while (reading_index < end)\n  {\n    unsigned j = reading_index + 1;\n    while ((j < end) && (neighbors[j] == neighbors[reading_index]))\n    {\n      j++;\n    }\n\n    neighbors[writing_index++] = neighbors[reading_index];\n    reading_index = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/oshmem/main-single-mailbox-atomics/14"}
{"code": "for (j = jend; j >= jst; j += -1)\n{\n  tmp1 = 1.0 / u[i][j][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n  d[i][j][0][1] = 0.0;\n  d[i][j][0][2] = 0.0;\n  d[i][j][0][3] = 0.0;\n  d[i][j][0][4] = 0.0;\n  d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n  d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n  d[i][j][1][2] = 0.0;\n  d[i][j][1][3] = 0.0;\n  d[i][j][1][4] = 0.0;\n  d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n  d[i][j][2][1] = 0.0;\n  d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n  d[i][j][2][3] = 0.0;\n  d[i][j][2][4] = 0.0;\n  d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n  d[i][j][3][1] = 0.0;\n  d[i][j][3][2] = 0.0;\n  d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n  d[i][j][3][4] = 0.0;\n  d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k][1] * u[i][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k][2] * u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k][3] * u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n  d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n  d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n  d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n  d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n  tmp1 = 1.0 / u[i + 1][j][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  a[i][j][0][0] = ((-dt) * tx1) * dx1;\n  a[i][j][0][1] = dt * tx2;\n  a[i][j][0][2] = 0.0;\n  a[i][j][0][3] = 0.0;\n  a[i][j][0][4] = 0.0;\n  a[i][j][1][0] = ((dt * tx2) * (((-(u[i + 1][j][k][1] * tmp1)) * (u[i + 1][j][k][1] * tmp1)) + (((0.40e+00 * 0.50) * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i + 1][j][k][1]));\n  a[i][j][1][1] = (((dt * tx2) * ((2.0 - 0.40e+00) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n  a[i][j][1][2] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][2] * tmp1));\n  a[i][j][1][3] = (dt * tx2) * ((-0.40e+00) * (u[i + 1][j][k][3] * tmp1));\n  a[i][j][1][4] = (dt * tx2) * 0.40e+00;\n  a[i][j][2][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][2]));\n  a[i][j][2][1] = (dt * tx2) * (u[i + 1][j][k][2] * tmp1);\n  a[i][j][2][2] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n  a[i][j][2][3] = 0.0;\n  a[i][j][2][4] = 0.0;\n  a[i][j][3][0] = ((dt * tx2) * ((-(u[i + 1][j][k][1] * u[i + 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i + 1][j][k][3]));\n  a[i][j][3][1] = (dt * tx2) * (u[i + 1][j][k][3] * tmp1);\n  a[i][j][3][2] = 0.0;\n  a[i][j][3][3] = (((dt * tx2) * (u[i + 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n  a[i][j][3][4] = 0.0;\n  a[i][j][4][0] = ((dt * tx2) * ((((0.40e+00 * (((u[i + 1][j][k][1] * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) * tmp2) - (1.40e+00 * (u[i + 1][j][k][4] * tmp1))) * (u[i + 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * (u[i + 1][j][k][1] * u[i + 1][j][k][1])) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][2] * u[i + 1][j][k][2]))) - (((c34 - c1345) * tmp3) * (u[i + 1][j][k][3] * u[i + 1][j][k][3]))) - ((c1345 * tmp2) * u[i + 1][j][k][4])));\n  a[i][j][4][1] = ((dt * tx2) * ((1.40e+00 * (u[i + 1][j][k][4] * tmp1)) - ((0.50 * 0.40e+00) * (((((3.0 * u[i + 1][j][k][1]) * u[i + 1][j][k][1]) + (u[i + 1][j][k][2] * u[i + 1][j][k][2])) + (u[i + 1][j][k][3] * u[i + 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i + 1][j][k][1]);\n  a[i][j][4][2] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][2] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][2]);\n  a[i][j][4][3] = ((dt * tx2) * (((-0.40e+00) * (u[i + 1][j][k][3] * u[i + 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i + 1][j][k][3]);\n  a[i][j][4][4] = (((dt * tx2) * (1.40e+00 * (u[i + 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n  tmp1 = 1.0 / u[i][j + 1][k][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  b[i][j][0][0] = ((-dt) * ty1) * dy1;\n  b[i][j][0][1] = 0.0;\n  b[i][j][0][2] = dt * ty2;\n  b[i][j][0][3] = 0.0;\n  b[i][j][0][4] = 0.0;\n  b[i][j][1][0] = ((dt * ty2) * ((-(u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][1]));\n  b[i][j][1][1] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n  b[i][j][1][2] = (dt * ty2) * (u[i][j + 1][k][1] * tmp1);\n  b[i][j][1][3] = 0.0;\n  b[i][j][1][4] = 0.0;\n  b[i][j][2][0] = ((dt * ty2) * (((-(u[i][j + 1][k][2] * tmp1)) * (u[i][j + 1][k][2] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j + 1][k][2]));\n  b[i][j][2][1] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][1] * tmp1));\n  b[i][j][2][2] = (((dt * ty2) * ((2.0 - 0.40e+00) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n  b[i][j][2][3] = (dt * ty2) * ((-0.40e+00) * (u[i][j + 1][k][3] * tmp1));\n  b[i][j][2][4] = (dt * ty2) * 0.40e+00;\n  b[i][j][3][0] = ((dt * ty2) * ((-(u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j + 1][k][3]));\n  b[i][j][3][1] = 0.0;\n  b[i][j][3][2] = (dt * ty2) * (u[i][j + 1][k][3] * tmp1);\n  b[i][j][3][3] = (((dt * ty2) * (u[i][j + 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n  b[i][j][3][4] = 0.0;\n  b[i][j][4][0] = ((dt * ty2) * ((((0.40e+00 * (((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + (u[i][j + 1][k][2] * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) * tmp2) - (1.40e+00 * (u[i][j + 1][k][4] * tmp1))) * (u[i][j + 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j + 1][k][1] * u[i][j + 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j + 1][k][2] * u[i][j + 1][k][2]))) - (((c34 - c1345) * tmp3) * (u[i][j + 1][k][3] * u[i][j + 1][k][3]))) - ((c1345 * tmp2) * u[i][j + 1][k][4])));\n  b[i][j][4][1] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][1] * u[i][j + 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][1]);\n  b[i][j][4][2] = ((dt * ty2) * ((1.40e+00 * (u[i][j + 1][k][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j + 1][k][1] * u[i][j + 1][k][1]) + ((3.0 * u[i][j + 1][k][2]) * u[i][j + 1][k][2])) + (u[i][j + 1][k][3] * u[i][j + 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j + 1][k][2]);\n  b[i][j][4][3] = ((dt * ty2) * (((-0.40e+00) * (u[i][j + 1][k][2] * u[i][j + 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j + 1][k][3]);\n  b[i][j][4][4] = (((dt * ty2) * (1.40e+00 * (u[i][j + 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n  tmp1 = 1.0 / u[i][j][k + 1][0];\n  tmp2 = tmp1 * tmp1;\n  tmp3 = tmp1 * tmp2;\n  c[i][j][0][0] = ((-dt) * tz1) * dz1;\n  c[i][j][0][1] = 0.0;\n  c[i][j][0][2] = 0.0;\n  c[i][j][0][3] = dt * tz2;\n  c[i][j][0][4] = 0.0;\n  c[i][j][1][0] = ((dt * tz2) * ((-(u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][1]));\n  c[i][j][1][1] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n  c[i][j][1][2] = 0.0;\n  c[i][j][1][3] = (dt * tz2) * (u[i][j][k + 1][1] * tmp1);\n  c[i][j][1][4] = 0.0;\n  c[i][j][2][0] = ((dt * tz2) * ((-(u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k + 1][2]));\n  c[i][j][2][1] = 0.0;\n  c[i][j][2][2] = (((dt * tz2) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n  c[i][j][2][3] = (dt * tz2) * (u[i][j][k + 1][2] * tmp1);\n  c[i][j][2][4] = 0.0;\n  c[i][j][3][0] = ((dt * tz2) * (((-(u[i][j][k + 1][3] * tmp1)) * (u[i][j][k + 1][3] * tmp1)) + ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k + 1][3]));\n  c[i][j][3][1] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][1] * tmp1));\n  c[i][j][3][2] = (dt * tz2) * ((-0.40e+00) * (u[i][j][k + 1][2] * tmp1));\n  c[i][j][3][3] = ((((dt * tz2) * (2.0 - 0.40e+00)) * (u[i][j][k + 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n  c[i][j][3][4] = (dt * tz2) * 0.40e+00;\n  c[i][j][4][0] = ((dt * tz2) * ((((0.40e+00 * (((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) * tmp2) - (1.40e+00 * (u[i][j][k + 1][4] * tmp1))) * (u[i][j][k + 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k + 1][1] * u[i][j][k + 1][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k + 1][2] * u[i][j][k + 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k + 1][3] * u[i][j][k + 1][3]))) - ((c1345 * tmp2) * u[i][j][k + 1][4])));\n  c[i][j][4][1] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][1] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][1]);\n  c[i][j][4][2] = ((dt * tz2) * (((-0.40e+00) * (u[i][j][k + 1][2] * u[i][j][k + 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k + 1][2]);\n  c[i][j][4][3] = ((dt * tz2) * ((1.40e+00 * (u[i][j][k + 1][4] * tmp1)) - ((0.50 * 0.40e+00) * ((((u[i][j][k + 1][1] * u[i][j][k + 1][1]) + (u[i][j][k + 1][2] * u[i][j][k + 1][2])) + ((3.0 * u[i][j][k + 1][3]) * u[i][j][k + 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k + 1][3]);\n  c[i][j][4][4] = (((dt * tz2) * (1.40e+00 * (u[i][j][k + 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n}\n\n", "pragma": "omp parallel for private (tmp1,tmp2,tmp3,j) firstprivate (k,r43,c1345,c34,tx1,tx2,ty1,ty2,tz1,tz2,dx1,dx2,dx3,dx4,dx5,dy1,dy2,dy3,dy4,dy5,dz1,dz2,dz3,dz4,dz5,dt)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/60"}
{"code": "for (int i = YlowerLimit; i <= YupperLimit; i++)\n{\n  for (int j = XlowerLimit; j <= XupperLimit; j++)\n  {\n    pixels.push_back((double) rgb_image[i][j][color]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kausthubtm/Parallel-Image-Processing/filters/openMP/medianFilterOpenMP/0"}
{"code": "for (int i = 0; i < x; i++)\n  ;\n\n", "pragma": "omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/flang-cavium/flang9/tools/clang/test/AST/ast-dump-openmp-distribute-parallel-for-simd/0"}
{"code": "for (i = 0; i <= nSize; i++)\n{\n  j = (numLinks = 0);\n  while (myGraph[i].hyperlinks[numLinks] != (-1))\n  {\n    numLinks++;\n  }\n\n  numLinks--;\n  if (numLinks < 0)\n  {\n  }\n  else\n  {\n    for (j = 0; j < K; j++)\n    {\n      coinToss = ((double) rand_r(&seed)) / ((double) 32767);\n      if (coinToss >= dampingRatio)\n      {\n        randomNode = (rand_r(&seed) % ((nSize + 1) - 0)) + 0;\n        myGraph[randomNode].pagerank++;\n        if (DEBUG)\n        {\n          if (myGraph[randomNode].hyperlinks[0] == (-1))\n          {\n            puts(\"-=0=-={Found NonTargetable NODE: Empty links, treat as random page\");\n          }\n\n          printf(\"Rank=%d\\t\\t|randomNode=%d\\t\\t| myGraph[%d].pagerank++ = %d (current value)\\n\", myRank, randomNode, randomNode, myGraph[randomNode].pagerank);\n        }\n\n      }\n      else\n      {\n        randomNode = (rand_r(&seed) % ((numLinks + 1) - 0)) + 0;\n        myTargetNode = myGraph[i].hyperlinks[randomNode];\n        myGraph[myTargetNode].pagerank++;\n        if (DEBUG)\n        {\n          if (myGraph[i].hyperlinks[randomNode] == (-1))\n          {\n            puts(\"-=0=-={ERROR: Went out of bounds on array using rand\");\n          }\n\n          printf(\"Rank=%d\\t\\t|randomNode=%d \\t\\t|  Target=%d  \\t|  myGraph[myGraph[%d].hyperlinks[%d]].pagerank++ = %d (current value)\\n\", myRank, randomNode, myTargetNode, i, randomNode, myGraph[myTargetNode].pagerank);\n          if (i == 4038)\n          {\n            puts(\"=====================[ DEBUG ]=====================\");\n            printf(\"Debug Test at i = %d\\n\", i);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n  if (DEBUG)\n  {\n    if ((i % 10000) == 0)\n    {\n      puts(\"=====================[ DEBUG ]=====================\");\n      printf(\"Debug Test at i = %d\\n\", i);\n    }\n\n    if (i == 4038)\n    {\n      puts(\"=====================[ DEBUG ]=====================\");\n      printf(\"Debug Test at i = %d\\n\", i);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManuelBerrueta/cpts411_PageRankEstimator/pagerankestimator/0"}
{"code": "for (i = 0; i < 1700; i++)\n{\n  for (j = 0; j < 1700; j++)\n  {\n    G[i][j] = 0;\n    C[i][j] = 100 * 100;\n    D[i][j] = 100 * 100;\n    P[i][j] = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dmitrybbch/parallelized-floyd-warshall/floydwarshall/0"}
{"code": "for (int irch = 0; irch <= m_nReaches; irch++)\n{\n  tmp_chDaylen[irch] = 0.f;\n  tmp_chSr[irch] = 0.f;\n  tmp_chTemp[irch] = 0.f;\n  tmp_chCellCount[irch] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NutrCH_QUAL2E/NutrCH_QUAL2E/0"}
{"code": "for (i = 0; i < 10000; ++i)\n{\n  matrix = transpose(matrix, n, m);\n  j = n;\n  n = m;\n  m = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/haalon-old/mpi-openmp/par/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  (cout << (*(tabletest + i))) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/Tri_Pair_Impair/TriPI_openmp_pair/4"}
{"code": "for (i = 0; i <= (nx - 1); i += 1)\n{\n  iglob = i;\n  xi = ((double) iglob) / (nx0 - 1);\n  for (j = 0; j <= (ny - 1); j += 1)\n  {\n    jglob = j;\n    eta = ((double) jglob) / (ny0 - 1);\n    for (k = 0; k <= (nz - 1); k += 1)\n    {\n      zeta = ((double) k) / (nz - 1);\n      for (m = 0; m <= 4; m += 1)\n      {\n        rsd[i][j][k][m] = (((((((((((ce[m][0] + (ce[m][1] * xi)) + (ce[m][2] * eta)) + (ce[m][3] * zeta)) + ((ce[m][4] * xi) * xi)) + ((ce[m][5] * eta) * eta)) + ((ce[m][6] * zeta) * zeta)) + (((ce[m][7] * xi) * xi) * xi)) + (((ce[m][8] * eta) * eta) * eta)) + (((ce[m][9] * zeta) * zeta) * zeta)) + ((((ce[m][10] * xi) * xi) * xi) * xi)) + ((((ce[m][11] * eta) * eta) * eta) * eta)) + ((((ce[m][12] * zeta) * zeta) * zeta) * zeta);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (iglob,jglob,xi,eta,zeta,i,j,k,m) firstprivate (nx0)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/13"}
{"code": "for (int i = 0; i < counter; i++)\n{\n  imgP.process(myImage, outImage);\n  myImage = outImage;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/coolis/OpenMP_ImageBlur/main/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n  ;\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/ordered-3/0"}
{"code": "for (int i = 0; i < outerSize; i++)\n{\n  for (int j = d - 1; j >= 0; j--)\n  {\n    outerX[i + (j * outerSize)] = X[((int) outerX[i]) + (j * n)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gonidelis/vantage_point_tree/vptree/src/vptree_openmp/6"}
{"code": "for (int i = 0; i < N; i++)\n{\n  fprintf(filePtr, \"%.8f\\t%.8f\\t%.8f\\n\", X[i * 3], X[(i * 3) + 1], X[(i * 3) + 2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theompek/Parallel_Programming_Projects/clustering_tree_radix_sort/src/1OpenMP/datasets/2"}
{"code": "for (i = 0; i < 4; i++)\n  if (buffer[i] != ' ')\n  width = ((width * 10) + buffer[i]) - '0';\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/33"}
{"code": "for (int i = 0; i < size; i++)\n{\n  for (int j = 0; j < size; j++)\n  {\n    if ((((i == 0) || (j == 0)) || (j == (size - 1))) || (i == (size - 1)))\n    {\n      z[((size + i) * size) + j] = 0;\n    }\n    else\n    {\n      z[((size + i) * size) + j] = z[(i * size) + j] + ((((c * c) / 2) * pow(dt / dd, 2)) * ((((z[((i + 1) * size) + j] + z[((i - 1) * size) + j]) + z[((i * size) + j) + 1]) + z[((i * size) + j) - 1]) - (4.0 * z[(i * size) + j])));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shirley1988/Wave-Simulation/mpdWave/6"}
{"code": "for (j = 0; j < Ny; j++)\n  y[j] = 0 + (j * dy);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/6"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  f = phi1[i] * phi1[i];\n  phi1_xx = ((phi1[i - 1] - (2.0 * phi1[i])) + phi1[i + 1]) / (dx * dx);\n  phi1_res[i] = phi1_xx - f;\n  f = 0.0;\n  phi2_xx = ((phi2[i - 1] - (2.0 * phi2[i])) + phi2[i + 1]) / (dx * dx);\n  phi2_res[i] = phi2_xx - f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/0"}
{"code": "for (int y = 0; y < height; y++)\n{\n  float scaled_x = (((1.f - (-2.5f)) / width) * x) - 2.5f;\n  float scaled_y = (((1.f - (-1.f)) / height) * y) - 1.f;\n  int iteration = 0;\n  while ((((scaled_x * scaled_x) + (scaled_y * scaled_y)) <= (R * R)) && (iteration < max_iteration))\n  {\n    float xtemp = (scaled_x * scaled_x) - (scaled_y * scaled_y);\n    scaled_y = ((2 * scaled_x) * scaled_y) + cy;\n    scaled_x = xtemp + cx;\n    iteration += 1;\n  }\n\n  pixels->data[(y * pixels->rows) + x] = iteration;\n}\n\n", "pragma": "omp for schedule(dynamic, 32)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jackfine0062/mandelbrotHPC/mandelbrot_openmp/0"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    a[i][j] = a[i][j] + 1;\n    printf(\"test i=%d j=%d\\n\", i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB094-doall2-ordered-orig-no/0"}
{"code": "for (int i = 0; i < maxShellType; ++i)\n{\n  tmp[0] = typeChar[i];\n  for (int j = 0; j < maxShellType; ++j)\n  {\n    tmp[1] = typeChar[j];\n    for (int k = 0; k < maxShellType; ++k)\n    {\n      tmp[2] = typeChar[k];\n      for (int l = 0; l < maxShellType; ++l)\n      {\n        tmp[3] = typeChar[l];\n        typeStr4[index] = tmp;\n        ++index;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ProteinDF/ProteinDF/src/libpdf/DfCD/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%2d \", profit[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pengjuntc/knapsack-openmp/knap_para/3"}
{"code": "for (i = 1; i <= T_LAST; i++)\n{\n  printf(\"  %-8s:%9.3f  (%6.2f%%)\\n\", t_names[i], trecs[i], (trecs[i] * 100.) / tmax);\n  if (i == T_RHS)\n  {\n    t = (trecs[T_RHSX] + trecs[T_RHSY]) + trecs[T_RHSZ];\n    printf(\"    --> %8s:%9.3f  (%6.2f%%)\\n\", \"sub-rhs\", t, (t * 100.) / tmax);\n    t = trecs[T_RHS] - t;\n    printf(\"    --> %8s:%9.3f  (%6.2f%%)\\n\", \"rest-rhs\", t, (t * 100.) / tmax);\n  }\n  else\n    if (i == T_ZSOLVE)\n  {\n    t = (trecs[T_ZSOLVE] - trecs[T_RDIS1]) - trecs[T_RDIS2];\n    printf(\"    --> %8s:%9.3f  (%6.2f%%)\\n\", \"sub-zsol\", t, (t * 100.) / tmax);\n  }\n  else\n    if (i == T_RDIS2)\n  {\n    t = trecs[T_RDIS1] + trecs[T_RDIS2];\n    printf(\"    --> %8s:%9.3f  (%6.2f%%)\\n\", \"redist\", t, (t * 100.) / tmax);\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/2"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  do_step(spins, neighs, tstar, N, h, energy, gen, ran_u, ran_pos, m);\n  w_output(output, tstar, N, m);\n  (cout << tstar) << endl;\n  tstar -= deltat_crit;\n}\n\n", "pragma": "    #pragma omp parallel for schedule(dynamic) num_threads(4) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srtcdmry/Paralleling-ising-model-with-openmp/ising/1"}
{"code": "for (i = 0; i < 1000000; i++)\n{\n  media += arr[i];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FacundoDecena/SSPP-TP7/ejercicio8/ejercicio8Paralelo/3"}
{"code": "for (int ii = 0; ii < n_particles; ii++)\n{\n  size_t randnumX = 0;\n  size_t randnumY = 0;\n  float displacementX = 0.0f;\n  float displacementY = 0.0f;\n  size_t iter = 0;\n  while (iter < nIterations)\n  {\n    randnumX = randomX[(iter * n_particles) + ii];\n    randnumY = randomY[(iter * n_particles) + ii];\n    displacementX = (((float) randnumX) / 1000.0f) - 0.0495f;\n    displacementY = (((float) randnumY) / 1000.0f) - 0.0495f;\n    particleX[ii] += displacementX;\n    particleY[ii] += displacementY;\n    float dX = particleX[ii] - truncf(particleX[ii]);\n    float dY = particleY[ii] - truncf(particleY[ii]);\n    int iX = floorf(particleX[ii]);\n    int iY = floorf(particleY[ii]);\n    if ((((particleX[ii] < grid_size) && (particleY[ii] < grid_size)) && (particleX[ii] >= 0)) && (particleY[ii] >= 0))\n    {\n      if (((dX * dX) + (dY * dY)) <= (radius * radius))\n      {\n        map[(((ii * grid_size) * grid_size) + (iY * grid_size)) + iX]++;\n      }\n\n    }\n\n    iter++;\n  }\n\n}\n\n", "pragma": "  #pragma omp teams distribute parallel for simd thread_limit(256) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/particle-diffusion-omp/motionsim/2"}
{"code": "for (int i = 0; i < (10000 - 1); i++)\n{\n  float min = 1000000;\n  float minn[2];\n  int th = -1;\n  int thh[2];\n  for (int j = 0; j < 10000; j++)\n  {\n    int flag = 1;\n    for (int k = 0; k < i; k++)\n    {\n      if (j == diad[k])\n      {\n        flag = 0;\n        break;\n      }\n\n    }\n\n    if (((dist[diad[i]][j] != 0) && (flag == 1)) && (min > dist[diad[i]][j]))\n    {\n      min = dist[diad[i]][j];\n      minn[1] = minn[0];\n      minn[0] = min;\n      th = j;\n      thh[1] = thh[0];\n      thh[0] = th;\n    }\n\n  }\n\n  int d = rand() % 2;\n  diad[i + 1] = thh[d];\n  tdist = tdist + minn[d];\n}\n\n", "pragma": "omp parallel for reduction(+:tdist)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitrisbro/ParallelC/TravelSalesmanProblem/version5/0"}
{"code": "for (int i = 1; i < p; i++)\n{\n  if (!conv[i])\n  {\n    converged = 0;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ahalyasanjiv/Parallel-Programming-LTDP/viterbi/viterbi_ltdp_openmp/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  c[i] = (double *) malloc(n * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TharinduRusira/ParallelMatrix/mat_utils/1"}
{"code": "for (int j = 0; j < (n - 1); j = j + 2)\n{\n  if (arr[j] > arr[j + 1])\n  {\n    temp = arr[j + 1];\n    arr[j + 1] = arr[j];\n    arr[j] = temp;\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for schedule(runtime) private(temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shiva49814/OpenMPTasks/bubblesort/2"}
{"code": "formula.append((\"- \" + number((-1) * gg)) + \"*F( T + 273.15) \")\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/107"}
{"code": "for (int i = 0; i < valB.size(); ++i)\n{\n  bitString.append(to_string(((((valB[i] ^ valB[(i + 4) % 8]) ^ valB[(i + 5) % 8]) ^ valB[(i + 6) % 8]) ^ valB[(i + 7) % 8]) ^ staticByte[i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tdemchuk/parallel-aes/parallel/OpenMP-2/14"}
{"code": "for (int w = 0; w < numberOfWeights; ++w)\n{\n  weights[w] = 0.7 * (rand() / ((double) 32767));\n  if (w % 2)\n  {\n    weights[w] = -weights[w];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dhawal777/Handwritten-Digit-Recoganization-by-ANN-in-openmp/nn/1"}
{"code": "for (shift = 0; shift < 512; shift++)\n{\n  printf(\"%f\\n\", Sums[shift]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tanyakhemani/parallel-programming/project7B/openmp1/2"}
{"code": "for (int i = s0; i < e0; i++)\n{\n  int neighbour_1 = adj[i];\n  int s1 = xadj[neighbour_1];\n  int e1 = xadj[neighbour_1 + 1];\n  for (int j = s1; j < e1; j++)\n  {\n    int neighbour_2 = adj[j];\n    if (neighbour_2 == index)\n      continue;\n\n    int s2 = xadj[neighbour_2];\n    int e2 = xadj[neighbour_2 + 1];\n    for (int k = s2; k < e2; k++)\n    {\n      int neighbour_3 = adj[k];\n      if (neighbour_3 == index)\n        continue;\n\n      if (neighbour_3 == neighbour_1)\n        continue;\n\n      int s3 = xadj[neighbour_3];\n      int e3 = xadj[neighbour_3 + 1];\n      for (int n = s3; n < e3; n++)\n      {\n        int neighbour_4 = adj[n];\n        if (neighbour_4 == index)\n          continue;\n\n        if (neighbour_4 == neighbour_1)\n          continue;\n\n        if (neighbour_4 == neighbour_2)\n          continue;\n\n        int s4 = xadj[neighbour_4];\n        int e4 = xadj[neighbour_4 + 1];\n        for (int o = s4; o < e4; o++)\n        {\n          int neighbour_5 = adj[o];\n          if (neighbour_5 == index)\n          {\n            localcount += 1;\n            break;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/3"}
{"code": "for (int j = 0; j < channels; j++)\n{\n  i--;\n  lnorm += (mixingPos[i] * mixingPos[i]) >> overlapDividerBits;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/tags/1.25.01.00/include/soundtouch/source/SoundTouch/TDStretch/4"}
{"code": "for (i = 0; i < my_height_incr_2; i++)\n{\n  for (j = 0; j < mult; j++)\n  {\n    my_image_after[i][j] = my_image_before[i][mult + j];\n    my_image_after[i][my_width_incr_1 + j] = my_image_before[i][my_width + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/6"}
{"code": "for (int i = y_min; i <= y_max; i++)\n{\n  if ((max_overlap_horiz[i] < min_max) || ((max_overlap_horiz[i] == min_max) && (horizontal[i] < min_agg)))\n  {\n    best = i;\n    min_max = max_overlap_horiz[best];\n    min_agg = horizontal[best];\n    new_bendy1 = i;\n    new_bendx1 = wire.x1;\n    new_bendx1 = -1;\n    new_bendy1 = -1;\n    new_bendx2 = -1;\n    new_bendy2 = -1;\n    if (!((wire.y1 == wire.y2) && (i == wire.y1)))\n    {\n      new_bendy1 = i;\n      if (i == wire.y1)\n      {\n        new_bendx1 = wire.x2;\n      }\n      else\n      {\n        new_bendx1 = wire.x1;\n      }\n\n      if ((i != wire.y1) && (i != wire.y2))\n      {\n        new_bendx2 = wire.x2;\n        new_bendy2 = i;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jenniferleeny/openMP/code/wireroute/1"}
{"code": "for (int i = 0; i < normalizeNum; i++)\n{\n  buckets[i].clear();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_2_Sorting/cpu_parallel_sort/0"}
{"code": "for (; depth < (nmodes - 1); ++depth)\n{\n  left = fptr[depth][left];\n  right = fptr[depth][right];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/graph/4"}
{"code": "for (i = 0; i < lines; i++)\n{\n  for (j = 0; j < samples; j++)\n  {\n    rgb[(((i * 3) * samples) + (j * 3)) + 0] = (Uint8) (data[((i * offset) + (j * bands)) + R] * rescaleFactorR);\n    rgb[(((i * 3) * samples) + (j * 3)) + 1] = (Uint8) (data[((i * offset) + (j * bands)) + G] * rescaleFactorG);\n    rgb[(((i * 3) * samples) + (j * 3)) + 2] = (Uint8) (data[((i * offset) + (j * bands)) + B] * rescaleFactorB);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/johnMinelli/Parallel-KMeans/dataManager/1"}
{"code": "for (int i = 0; i < number_of_elements; ++i)\n{\n  CalculateElementalDistances(*r_elements[i], rIntersectedObjects[i]);\n}\n\n", "pragma": "            #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/processes/calculate_discontinuous_distance_to_skin_process/2"}
{"code": "for (k = 0; k <= (nz - 1); k += 1)\n{\n  flux[i][j][k][0] = rsd[i][j][k][3];\n  u41 = rsd[i][j][k][3] / rsd[i][j][k][0];\n  q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n  flux[i][j][k][1] = rsd[i][j][k][1] * u41;\n  flux[i][j][k][2] = rsd[i][j][k][2] * u41;\n  flux[i][j][k][3] = (rsd[i][j][k][3] * u41) + (0.40e+00 * (rsd[i][j][k][4] - q));\n  flux[i][j][k][4] = ((1.40e+00 * rsd[i][j][k][4]) - (0.40e+00 * q)) * u41;\n}\n\n", "pragma": "omp parallel for private (q,u41,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/45"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int j = jb; j < je; j++)\n  {\n    for (int i = ib; i < ie; i += 2)\n    {\n      int pp = IDX(i, j, k);\n      Dxu[pp] = (((u[pp - 2] - (8.0 * u[pp - 1])) + (8.0 * u[pp + 1])) - u[pp + 2]) * idx_by_12;\n      Dxu[pp + 1] = (((u[pp - 1] - (8.0 * u[pp])) + (8.0 * u[pp + 2])) - u[pp + 3]) * idx_by_12;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_2/bssn/src/derivs/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (v[i] > max_val)\n    max_val = v[i];\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(numThreads) reduction(max:max_val)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment1/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    fprintf(file, \"%.2lf \", matrix[i][j]);\n  }\n\n  fprintf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KManolov3/parallel-matrix-mult/parallel-matrix-multiply/main/6"}
{"code": "for (int i = 0; i < (N + 1); i++)\n{\n  residual += fabsl(y[i] - next[i]);\n}\n\n", "pragma": "omp parallel for num_threads(threads) shared(y, next) reduction(+: residual)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/cyclic_reduction/main/2"}
{"code": "for (int j = 0; j < m; j++)\n{\n  for (int i = 0; i < n; i++)\n  {\n    a(i, j) = (i + (j * 0.2)) + 0.01;\n    b(i, j) = ((i * 0.3) + (j * 0.5)) + 0.01;\n    a_ref(i, j) = b(i, j);\n    b_ref(i, j) = a(i, j);\n  }\n\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for simd collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yasahi-hpc/P3-miniapps/tests/openmp/test_view/5"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (j = 0; j < N; ++j)\n  {\n    double cij = C[(j * lda) + i];\n    for (k = 0; k < K; ++k)\n    {\n      cij += A[(k * lda) + i] * B[(j * lda) + k];\n    }\n\n    C[(j * lda) + i] = cij;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/matmul/blocked/1"}
{"code": "for (int k = y_min - 2; k <= (y_max + 2); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    xarea[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = celldy[FTNREF1D(k, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_initialise_chunk/9"}
{"code": "for (int i = 0; i < N; i++)\n{\n  (cout << array[i]) << \"\\t\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahgauravraj/openmp_programs/test/2"}
{"code": "for (int k = 0; k < (params.ny * params.nx); k += step)\n{\n  for (int ii = k; ii < (k + step); ii++)\n  {\n    const int y_n = (ii > ((params.ny - 1) * params.nx)) ? ((-(params.ny - 1)) * params.nx) : (params.nx);\n    const int x_e = (((ii + 1) % params.nx) == 0) ? (1 - params.nx) : (1);\n    const int y_s = (ii < params.nx) ? (params.nx * (params.ny - 1)) : (-params.nx);\n    const int x_w = ((ii % params.nx) == 0) ? (params.nx - 1) : (-1);\n    float sp[9];\n    sp[0] = cells->speed0[ii];\n    sp[1] = cells->speed1[ii + x_w];\n    sp[2] = cells->speed2[ii + y_s];\n    sp[3] = cells->speed3[x_e + ii];\n    sp[4] = cells->speed4[ii + y_n];\n    sp[5] = cells->speed5[(ii + x_w) + y_s];\n    sp[6] = cells->speed6[(ii + x_e) + y_s];\n    sp[7] = cells->speed7[(ii + x_e) + y_n];\n    sp[8] = cells->speed8[(ii + x_w) + y_n];\n    const float local_density = (((((((sp[0] + sp[3]) + sp[4]) + sp[1]) + sp[2]) + sp[7]) + sp[8]) + sp[5]) + sp[6];\n    const float u_x = (((sp[1] + sp[5]) + sp[8]) - ((sp[3] + sp[6]) + sp[7])) / local_density;\n    const float u_y = (((sp[2] + sp[5]) + sp[6]) - ((sp[4] + sp[7]) + sp[8])) / local_density;\n    tot_u += (!obstacles[ii]) ? (sqrtf((u_x * u_x) + (u_y * u_y))) : (0);\n    tot_cells += (!obstacles[ii]) ? (1) : (0);\n    float u[9];\n    u[1] = u_x;\n    u[2] = u_y;\n    u[3] = -u_x;\n    u[4] = -u_y;\n    u[5] = u_x + u_y;\n    u[6] = (-u_x) + u_y;\n    u[7] = (-u_x) - u_y;\n    u[8] = u_x - u_y;\n    const float op = ((u_x * u_x) + (u_y * u_y)) * 1.5f;\n    tmp_cells->speed0[ii] = (obstacles[ii]) ? (sp[0]) : (sp[0] + (params.omega * (((w0 * local_density) * (1.f - op)) - sp[0])));\n    tmp_cells->speed1[ii] = (obstacles[ii]) ? (sp[3]) : (sp[1] + (params.omega * (((w1 * local_density) * ((1.f + (u[1] * (3.0f + (u[1] * 4.5f)))) - op)) - sp[1])));\n    tmp_cells->speed2[ii] = (obstacles[ii]) ? (sp[4]) : (sp[2] + (params.omega * (((w1 * local_density) * ((1.f + (u[2] * (3.0f + (u[2] * 4.5f)))) - op)) - sp[2])));\n    tmp_cells->speed3[ii] = (obstacles[ii]) ? (sp[1]) : (sp[3] + (params.omega * (((w1 * local_density) * ((1.f + (u[3] * (3.0f + (u[3] * 4.5f)))) - op)) - sp[3])));\n    tmp_cells->speed4[ii] = (obstacles[ii]) ? (sp[2]) : (sp[4] + (params.omega * (((w1 * local_density) * ((1.f + (u[4] * (3.0f + (u[4] * 4.5f)))) - op)) - sp[4])));\n    tmp_cells->speed5[ii] = (obstacles[ii]) ? (sp[7]) : (sp[5] + (params.omega * (((w2 * local_density) * ((1.f + (u[5] * (3.0f + (u[5] * 4.5f)))) - op)) - sp[5])));\n    tmp_cells->speed6[ii] = (obstacles[ii]) ? (sp[8]) : (sp[6] + (params.omega * (((w2 * local_density) * ((1.f + (u[6] * (3.0f + (u[6] * 4.5f)))) - op)) - sp[6])));\n    tmp_cells->speed7[ii] = (obstacles[ii]) ? (sp[5]) : (sp[7] + (params.omega * (((w2 * local_density) * ((1.f + (u[7] * (3.0f + (u[7] * 4.5f)))) - op)) - sp[7])));\n    tmp_cells->speed8[ii] = (obstacles[ii]) ? (sp[6]) : (sp[8] + (params.omega * (((w2 * local_density) * ((1.f + (u[8] * (3.0f + (u[8] * 4.5f)))) - op)) - sp[8])));\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:tot_cells,tot_u)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarcGoulding/openMP/d2q9-bgk/2"}
{"code": "for (i = 0; i < 5; i++)\n  j = i;\n\n", "pragma": "omp parallel for lastprivate (i, j) num_threads (8) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr35196/0"}
{"code": "for (int i = 0; i < 2000; i++)\n{\n  for (int j = 0; j < 2000; j++)\n  {\n    double sum = 0;\n    for (int k = 0; k < 2000; k++)\n    {\n      sum += A[i][k] * B[k][j];\n    }\n\n    C[i][j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KunxiSun/matrix_multiplication_and_openmp_in_c_2/src/q1-avg/0"}
{"code": "for (j = 0; j < sheight; j++)\n{\n  err = clEnqueueReadBuffer(command_queue[2], output[j], CL_TRUE, 0, DB_OUT_SIZE, (void *) (idx + (DB_OUT_COUNT * j)), 1, kernel_event + j, read_event + j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/B/photomosaic/3"}
{"code": "for (int k = 0; k < num_vertices; k++)\n{\n  if (cheap[k] != (-1))\n  {\n    if (!same(ufind_sets, edges[k].source, edges[k].dest))\n    {\n      int source = find(ufind_sets, edges[cheap[k]].source);\n      int dest = find(ufind_sets, edges[cheap[k]].dest);\n      printf(\"Edge %d->%d included in MST\\n\", edges[cheap[k]].source, edges[cheap[k]].dest, edges[cheap[k]].weight);\n      union_sets(ufind_sets, source, dest);\n      sum[k] = edges[cheap[k]].weight;\n      comp[k] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic,1000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jow105/PARALLELIZING-BORUVKA-S-ALGORITHM/15418finalproject/boruvka_lock_free_init/3"}
{"code": "for (int jj = internal_ystart; jj <= internal_ystop; jj++)\n{\n  for (int ji = internal_xstart; ji <= internal_xstop; ji++)\n  {\n    continuity_code(ji, jj, width, ssha_t, sshn_t, sshn_u, sshn_v, hu, hv, un, vn, rdt, area_t);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stfc/PSycloneBench/benchmarks/nemo/nemolite2d/manual_versions/psykal_cpp/time_step_omp/0"}
{"code": "for (x = 0; x < 10; x++)\n  x = x;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/enforcer/0"}
{"code": "for (int i = 0; i < (2 * nzz); i++)\n{\n  (fin >> row[i]) >> col[i];\n  i++;\n  row[i] = col[i - 1];\n  col[i] = row[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgegito/vertexwise-triangle-counting/src/v4/v4_omp/0"}
{"code": "for (size_t l_pg = 0; l_pg < l_physicalGroups.size(); l_pg++)\n{\n  if (l_physicalGroups[l_pg].first == (l_nDis - 1))\n  {\n    m_physicalGroupsFa.push_back(l_physicalGroups[l_pg].second);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/tools/edge_v/src/io/Gmsh/4"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  temp[i] = b[i] + c[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB159-nobarrier-orig-gpu-no/0"}
{"code": "for (i = id, sum[id] = 0; i < num_steps; i = i + NUM_THREADS)\n{\n  x = (i + 0.5) * step;\n  sum[id] += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moomnightstar/openmp/openmppi/0"}
{"code": "for (int i = 0; i < (thread_num + 1); i++)\n{\n  local_sum_val += thread_local_sum[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravmkumar31/OpenMP/4.assignment-openmp-loop/4.assignment-openmp-loop/prefixsum/prefixsum/1"}
{"code": "for (int i = 0; i < edge_list.size(); i++)\n{\n  if (!((((node_level[edge_list[i].x] == (-1)) && (node_level[edge_list[i].y] == (-1))) || ((node_level[edge_list[i].x] != (-1)) && (node_level[edge_list[i].y] != (-1)))) || (abs(node_level[edge_list[i].x] - node_level[edge_list[i].y]) <= 1)))\n  {\n    printf(\"err: -3\\n\");\n    printf(\"e: %d %d, l: %d %d\\n\", edge_list[i].x, edge_list[i].y, node_level[edge_list[i].x], node_level[edge_list[i].y]);\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/20"}
{"code": "for (int mat = (cc.Nmats / 2) + 1; mat < cc.Nmats; mat++)\n{\n  for (int j = (sizey / 2) - 3; j < ((sizey / 2) - 1); j++)\n    for (int i = 2; i < 5; i++)\n  {\n    cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n    cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n  for (int j = sizey / 2; j < ((sizey / 2) + 2); j++)\n    for (int i = 2; i < 4; i++)\n  {\n    if ((i < 3) && (only_8 < 6))\n    {\n      cc.rho[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.rho[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    }\n\n    if ((i == 2) && (only_8 == 0))\n    {\n      cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.t[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.p[(((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.rho[((((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat) - 1] = 1.0;\n      cc.t[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n      cc.p[(((((mat * width) - i) + (sizex * j)) * cc.Nmats) - (cc.Nmats / 2)) + mat] = 1.0;\n    }\n\n    if (((mat >= (cc.Nmats - 8)) && (j == ((sizey / 2) + 1))) && (i == 3))\n      if ((only_8++) >= 4)\n    {\n      break;\n    }\n\n\n    cc.rho[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.t[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.p[((((((mat * width) + i) - 2) + (sizex * j)) * cc.Nmats) + mat) - 1] = 1.0;\n    cc.rho[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.t[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n    cc.p[((((mat * width) - i) + (sizex * j)) * cc.Nmats) + mat] = 1.0;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/multimat/6"}
{"code": "for (i = 0; i < d[0]; i++)\n{\n  y0[i][j].real = x[k][j + jj][i].real;\n  y0[i][j].imag = x[k][j + jj][i].imag;\n}\n\n", "pragma": "omp parallel for firstprivate(fftblock ,i ,jj ,x ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/FT/ft/5"}
{"code": "for (int i = 0; i < N; ++i)\n  for (int j = 0; j < N; ++j)\n{\n  for (int k = 0; k < N; ++k)\n    result[i][j] += matA[i][k] * matB[k][j];\n\n}\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GayanSandaruwan/Concurrent-Matrix-Multiplication/Matrix Multiplication-Parellel/main/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = grid_points[2] - 3; k >= 0; k--)\n    {\n      k1 = k + 1;\n      k2 = k + 2;\n      rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j][k1])) - (lhs[n + 4][i][j][k] * rhs[m][i][j][k2]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(k1, k2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/117"}
{"code": "for (i = 0; i < r; i++)\n{\n  newi = i * r;\n  for (j = 0; j < c; j++)\n  {\n    newj = j * c;\n    total = 0;\n    for (k = 0; k < c; k++)\n    {\n      total += ONEDA[newi + k] * ONEDB[newj + k];\n    }\n\n    mul[i][j] = total;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ajit-Kumar/Concurrent_Programming/matrix/4"}
{"code": "for (jj = 0; jj < 2048; jj += 64)\n{\n  for (kk = 0; kk < 2048; kk += 64)\n  {\n    for (i = 0; i < 2048; i++)\n    {\n      for (j = jj; j < (((jj + 64) < 2048) ? (jj + 64) : (2048)); j++)\n      {\n        sum = 0.0;\n        for (k = kk; k < (((kk + 64) < 2048) ? (kk + 64) : (2048)); k++)\n        {\n          sum += A[i][k] * B[k][j];\n        }\n\n        C[i][j] += sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(kk,i,j,k,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atanu151/Matrix-Multiplication/main/1"}
{"code": "for (int f = 0; f < num_coupled_images; ++f)\n  omp_init_lock(&coupled_images_creation_locks[f]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/9"}
{"code": "for (int i = 0; i < 2; i++)\n  Head[i] = (Tail[i] = 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/elena1905/ParallelIsingModel/src/worm/two_threads/Worm/1"}
{"code": "for (j = 0; j < n2; j++)\n{\n  R[j].tail = arr[(m + 1) + j].tail;\n  R[j].weight = arr[(m + 1) + j].weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/Utility/utilitySparsificationFunctions/1"}
{"code": "for (c = low; c <= high; c++)\n{\n  if (my_list2[c - low] == 0)\n  {\n    if (is_printing)\n    {\n      printf(\"%d \", c);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aaronweeden/pi2018-hybrid-examples/sieve/5"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  for (int j = 0; j < 100000; j++)\n  {\n    int i = 10;\n    i++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/snailZjk/openMP/Dijkstra/Dijkstra/0"}
{"code": "for (c = 0; c < nc; c++)\n{\n  if (MATRIX_RECT_NC(mask, r, c, nc))\n  {\n    sum++;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/winnow/2"}
{"code": "for (i = 0; i < K; i++)\n  for (j = 0; j < N; j++)\n  matrixB[(i * K) + j] = (drand48() * 2.0) - 1.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/lds-prob3/lds-prob3/1"}
{"code": "for (int i = rank * slices; i < ((rank + 1) * slices); i++)\n{\n  double temp = ((double) i) / slices;\n  partial_sum += sqrt(1 - (temp * temp)) / slices;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hsnuonly/ParallelProgramming/lab2/lab2/0"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  cout << result_vector[i];\n  cout << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw8/main/5"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  const double *residuals1_prolonged = &data0[5 * n_op];\n  const double *residuals1_prolonged_wsum = &data1[1 * n_op];\n  const double *residuals2 = &data2[5 * n_op];\n  double *variables2 = &data3[5 * n_op];\n  for (int i = 0; i < NVAR; i++)\n  {\n    variables2[i] += residuals2[i] - (residuals1_prolonged[i] / (*residuals1_prolonged_wsum));\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/down_v2_kernel_post_omp4kernel_func/0"}
{"code": "for (i = 0; i < (M * 2); i += incX + 1)\n{\n  r.REEL = 0;\n  r.IMAG = 0;\n  indice = i * M;\n  for (j = 0; j < (M * 2); j += incY + 1)\n  {\n    r.IMAG += (AP[indice + j] * (*((XP + i) + 1))) + ((*(XP + i)) * AP[(indice + j) + 1]);\n    r.REEL += (AP[indice + j] * (*(XP + i))) - (AP[(indice + j) + 1] * (*((XP + i) + 1)));\n  }\n\n  dcomplexe temp;\n  temp.REEL = *(YP + i);\n  temp.IMAG = *((YP + i) + 1);\n  *(YP + i) = ((temp.REEL * bv->REEL) - (temp.IMAG * bv->IMAG)) + ((av->REEL * r.REEL) - (av->IMAG * r.IMAG));\n  *((YP + i) + 1) = ((temp.REEL * bv->IMAG) + (temp.IMAG * bv->REEL)) + ((av->REEL * r.IMAG) + (av->IMAG * r.REEL));\n}\n\n", "pragma": "omp for schedule(static) private(i, j, r, indice)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemv/2"}
{"code": "for (im = 0; im < nmor; im++)\n{\n  ppmor[im] = dpcmor[im] * rmor[im];\n  rho_aux = rho_aux + (rmor[im] * ppmor[im]);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/diffuse/4"}
{"code": "for (uint32_t i = 0; i < rows; ++i)\n{\n  for (uint32_t j = 0; j < cols; ++j)\n  {\n    this->operator()(i, j) = rhs[i][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/0"}
{"code": "for (i = 0; i < mxn; i++)\n{\n  A[i] = ((((double) random()) / 32767) * 2.0) - 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Levysantiago/processamento_Paralelo/src/paralelo/1"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[1][32];\n  int i;\n  if (cur_salt->type == 0)\n  {\n    for (i = 0; i < 1; ++i)\n      pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), cur_salt->salt, cur_salt->saltlen, cur_salt->iterations, master[i], 32, 0);\n\n  }\n  else\n    if (cur_salt->type == 1)\n  {\n    int t = omp_get_thread_num();\n    if (t >= max_threads)\n    {\n      failed = -1;\n      continue;\n    }\n\n    yescrypt_params_t params = {.N = cur_salt->N, .r = cur_salt->r, .p = cur_salt->p};\n    for (i = 0; i < 1; ++i)\n    {\n      if (yescrypt_kdf(0, &local[t], (const uint8_t *) saved_key[index + i], strlen(saved_key[index + i]), (const uint8_t *) cur_salt->salt, strlen((const char *) cur_salt->salt), &params, master[i], 32))\n      {\n        failed = (errno) ? (errno) : (EINVAL);\n      }\n\n    }\n\n  }\n  else\n    if (cur_salt->type == 2)\n  {\n    if (new_keys)\n    {\n      for (i = 0; i < 1; ++i)\n      {\n        pbkdf2_sha256((unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), (unsigned char *) saved_key[index + i], strlen(saved_key[index + i]), 2000, master[i], 16, 0);\n      }\n\n      for (i = 0; i < 1; ++i)\n      {\n        memcpy(saved_presale[index + i], master[i], 32);\n      }\n\n    }\n    else\n    {\n      for (i = 0; i < 1; ++i)\n        memcpy(master[i], saved_presale[index + i], 32);\n\n    }\n\n  }\n\n\n\n  if ((cur_salt->type == 0) || (cur_salt->type == 1))\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      Keccak_HashInstance hash;\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, master[i] + 16, 16 * 8);\n      Keccak_HashUpdate(&hash, cur_salt->ct, cur_salt->ctlen * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n  else\n  {\n    for (i = 0; i < 1; ++i)\n    {\n      AES_KEY akey;\n      Keccak_HashInstance hash;\n      unsigned char iv[16];\n      unsigned char seed[4096];\n      int padbyte;\n      int datalen;\n      AES_set_decrypt_key(master[i], 128, &akey);\n      memcpy(iv, cur_salt->encseed, 16);\n      AES_cbc_encrypt(cur_salt->encseed + 16, seed, cur_salt->eslen - 16, &akey, iv, AES_DECRYPT);\n      if (check_pkcs_pad(seed, cur_salt->eslen - 16, 16) < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      padbyte = seed[(cur_salt->eslen - 16) - 1];\n      datalen = (cur_salt->eslen - 16) - padbyte;\n      if (datalen < 0)\n      {\n        memset(crypt_out[index + i], 0, 16);\n        continue;\n      }\n\n      Keccak_HashInitialize(&hash, 1088, 512, 256, 0x01);\n      Keccak_HashUpdate(&hash, seed, datalen * 8);\n      Keccak_HashUpdate(&hash, dpad.data, 1 * 8);\n      Keccak_HashFinal(&hash, (unsigned char *) crypt_out[index + i]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ethereum_fmt_plug/0"}
{"code": "for (int i = 0; i < n; ++i)\n  xhi[i] = b / a[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/liranpeng/E3SM-pritch-multiCRM-openmp4.5/components/homme/src/share/compose/compose_cedr/4"}
{"code": "for (int i = 0; i < N; i++)\n{\n  int sp = a[i] + b[i];\n  if (sp != 0)\n    total *= sp;\n\n  cout << total;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaximD20/OpenMP/lab4/Source/1"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  scnts[i] = ssizes[i];\n  rcnts[i] = rsizes[i];\n  sdispls[i] = spos;\n  rdispls[i] = rpos;\n  spos += scnts[i];\n  rpos += rcnts[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/5"}
{"code": "for (int i = 0; i < source->size; i++)\n{\n  reversesource->tab[i] = source->tab[(source->size - i) - 1];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      D[i][i] = A[i][i];\n    }\n    else\n    {\n      D[i][j] = 0.0;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gyucheonheo/jacobi/jacobi_mp/0"}
{"code": "for (int i = 0; i < limit; i++)\n{\n  for (int j = 0; j < limit; j++)\n  {\n    if (points[i].w < points[j].w)\n    {\n      float area = (points[j].z + 1.0f) * (points[j].z + 1.0f);\n      float w = fmaxf(0.0f, (fminf(points[i].x + points[i].z, points[j].x + points[j].z) - fmaxf(points[i].x, points[j].x)) + 1.0f);\n      float h = fmaxf(0.0f, (fminf(points[i].y + points[i].z, points[j].y + points[j].z) - fmaxf(points[i].y, points[j].y)) + 1.0f);\n      nmsbitmap[(i * MAX_DETECTIONS) + j] = (((w * h) / area) < 0.3f) && (points[j].z != 0);\n    }\n\n  }\n\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nms-omp/main/1"}
{"code": "for (i = 0; i < 10; i++)\n{\n  x = i;\n  y = 0;\n  for (j = 0; j < 10; j++)\n  {\n    y = j;\n    sum += y;\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:sum) firstprivate(x) lastprivate(x, y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/pr49897-2/0"}
{"code": "for (unsigned i = 100; i < 10; i += 10)\n{\n  a += 1;\n  aa += 1;\n  aaa += 1;\n  b[2] += 1;\n}\n\n", "pragma": "  #pragma omp target parallel for if(target: n>50)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  D = HuHuCAR_In(P, D, datanew.col(i).head(cov_num), cov_num, level_num, omega, p);\n  assignew(i) = D(D.n_rows - 1, 0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/11"}
{"code": "for (size_t i = 0; i < mainMatrix->size(); i++)\n{\n  const size_t n = getNeighborhood(i);\n  if (mainMatrix->test(i) && ((n == 2) || (n == 3)))\n    supportMatrix->set(i, true);\n  else\n    if ((!mainMatrix->test(i)) && (n == 3))\n    supportMatrix->set(i, true);\n  else\n    supportMatrix->set(i, false);\n\n\n}\n\n", "pragma": "            #pragma omp parallel for default(none) shared(mainMatrix, supportMatrix) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kwrx/Game-of-Life/src/gol/0"}
{"code": "for (i = 0; i < m; i++)\n  for (j = 0; j < n; j++)\n  A[(i * n) + j] = random() / ((double) 32767);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_mat_vect/1"}
{"code": "for (int i = 1; i <= n_columns; i++)\n{\n  if (nodes[i].inc_degree == 0)\n  {\n    create_task(i);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kounelisagis/OpenMP-Topological-Sorting-Algorithm/parallel/0"}
{"code": "for (i = 0; i < nelements; i++)\n{\n  double distance;\n  k = tclusterid[i];\n  if (counts[k] == 1)\n    continue;\n\n  distance = metric(ndata, data, cdata, mask, cmask, weight, i, k, transpose);\n  for (j = 0; j < nclusters; j++)\n  {\n    double tdistance;\n    if (j == k)\n      continue;\n\n    tdistance = metric(ndata, data, cdata, mask, cmask, weight, i, j, transpose);\n    if (tdistance < distance)\n    {\n      distance = tdistance;\n      counts[tclusterid[i]]--;\n      tclusterid[i] = j;\n      counts[j]++;\n    }\n\n  }\n\n  total += distance;\n}\n\n", "pragma": "omp for schedule(dynamic, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/0"}
{"code": "for (j = my_start; j <= my_end; j++)\n{\n  for (i = 0; i < ((int) floor(WIDTH / 1.0)); i++)\n  {\n    next_ptr[j - my_start][i] = .25 * ((((get_val_par(U_Curr_Above, current_ptr, U_Curr_Below, my_rank, i - 1, j) + get_val_par(U_Curr_Above, current_ptr, U_Curr_Below, my_rank, i + 1, j)) + get_val_par(U_Curr_Above, current_ptr, U_Curr_Below, my_rank, i, j - 1)) + get_val_par(U_Curr_Above, current_ptr, U_Curr_Below, my_rank, i, j + 1)) - (pow(1.0, 2) * f(i, j)));\n    enforce_bc_par(next_ptr, my_rank, i, j);\n  }\n\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/357r4bd/2d-heat/src/openmp-2dheat/0"}
{"code": "for (i = 0; i < bar_num; i++)\n{\n  bar_maxes[i] = (interval * ((float) (i + 1))) + min_value;\n  local_bar_counts[i] = 0;\n}\n\n", "pragma": "omp parallel for shared(interval,bar_maxes) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bahaa29/OpenMP_with_mpi-compute-hisogram/A3/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  different = a[i] != b[i];\n  if (different)\n    exit;\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/CMPE275-OpenMP/matrix/src/matrix-better/1"}
{"code": "for (row = 0; row < m; row++)\n  for (col = 0; col < p; col++)\n  printf(\"%f : \", T[(row * p) + col]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bhaskariitm/OpenMP-codes/Code/8"}
{"code": "for (i = 0; i < controlLines; i++)\n{\n  int controlNum = controlInput[i][0];\n  int textNum = controlInput[i][1];\n  int patternNum = controlInput[i][2];\n  processData(controlNum, textNum, patternNum, textLength[textNum], textData[textNum], patternLength[patternNum], patternData[patternNum]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amckenna41/OMP-MPI-parallel-programming/omp/project_OMP/3"}
{"code": "for (int i = 0; i < m_matdim; i++)\n{\n  testaccumulator1 += m_testmatrix->GetElem(0, i);\n  testaccumulator2 += m_testmatrix->GetElem(10, i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fpaboim/gpufem/src/Test/SPRmatrixTest/3"}
{"code": "for (int i = 0; i < number_of_particles; i++)\n{\n  mListOfSphericParticles[i]->CollectCalculateRightHandSide(r_process_info);\n}\n\n", "pragma": "            #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_strategies/strategies/explicit_solver_strategy/3"}
{"code": "for (int ColN = 0; ColN < Cols; ColN++)\n{\n  int KeyN = 0;\n  for (int RowN = 0; RowN < Rows; RowN++)\n  {\n    Z.At(RowN, ColN) = p * X.At(RowN, ColN);\n    if ((KeyN < Y[ColN].Len()) && (Y[ColN][KeyN].Key == RowN))\n    {\n      Z.At(RowN, ColN) += q * Y[ColN][KeyN].Dat;\n      KeyN++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/47"}
{"code": "for (int i = 0; i < 2; i++)\n{\n  for (int j = 0; j < 2; j++)\n  {\n    printf(\"%d \\n\", c[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yehia67/OpenMP-Examples/matrixMultiplicationParallel/1"}
{"code": "for (int i; i < 10; i++)\n  c[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/8"}
{"code": "for (int row = 0; row <= Rows; row++)\n{\n  for (int col = 0; col <= Cols; col++)\n  {\n    board[row][col] = false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TyropeDeMotorChope/Homework-3-OpenMP-/hw3_WHILE/5"}
{"code": "for (i = 1; i <= n; i++)\n{\n  T[((n + 1) * n2) + i] = (Tnew[((n + 1) * n2) + i] = (i * top) / (n + 1));\n  T[((i * n2) + n) + 1] = (Tnew[((i * n2) + n) + 1] = (i * top) / (n + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nowke/hpc_lab/12_laplace/laplace/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n    for (k = 0; k < N; k++)\n    C[i][j] += A[i][k] * B[k][j];\n\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kalaranjaniv/Multi-threading-using-OpenMP/Program Project 2/matrixcpy/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  sum[i] = vec1[i] + vec2[i];\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aman-Chopra/CUDA-vs-OpenMP/Vec_Add/vector_add_openmp/0"}
{"code": "for (l1 = -3; l1 < 4; l1++)\n{\n  for (l2 = -3; l2 < 4; l2++)\n  {\n    for (l3 = -3; l3 < 4; l3++)\n    {\n      if (((abs(l1) > 1) || (abs(l2) > 1)) || (abs(l3) > 1))\n      {\n        Ktable[ncell] = ninteract;\n        ninteract++;\n      }\n\n      ncell++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/17"}
{"code": "for (i = 0; i < count; ++i)\n{\n  CRC32_t crc = crcsalt;\n  unsigned char *p = (unsigned char *) saved_key[i];\n  while (*p)\n    crc = jtr_crc32(crc, *(p++));\n\n  crcs[i] = crc;\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/crc32_fmt_plug/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  if (kc[j] == m)\n  {\n    cenx[m] = x[j] + cenx[m];\n    ceny[m] = y[j] + ceny[m];\n    xcnt++;\n  }\n\n}\n\n", "pragma": "            #pragma omp parallel for shared(kc,cenx,ceny,xcnt,m,j)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/kMeans/5"}
{"code": "for (int j = 1; j <= height; ++j)\n{\n  for (int i = 1; i <= width; ++i)\n  {\n    image.read(&number, sizeof(char));\n    if (number == 0)\n    {\n      d[i][j] = 0;\n    }\n    else\n    {\n      d[i][j] = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/16"}
{"code": "for (j = 0; j < totalPartitions; ++j)\n{\n  uint32_t i;\n  for (i = 0; i < totalPartitions; ++i)\n  {\n    if (getBit(graph->grid->activePartitionsMap, (i * totalPartitions) + j) && graph->grid->partitions[(i * totalPartitions) + j].num_edges)\n    {\n      breadthFirstSearchPartitionGraphGridBitmap(graph, &graph->grid->partitions[(i * totalPartitions) + j], FrontierBitmapCurr, FrontierBitmapNext, stats);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/12"}
{"code": "for (size_t i = 0; i < POPULATION_CNT; i++)\n{\n  for (size_t j = 0; j < row; j++)\n  {\n    parent[i].binaryValue += to_string(BinaryRand());\n    parent[i].benefit += atof(content[(j * column) + 3].c_str()) * (parent[i].binaryValue[j] - '0');\n    parent[i].cost += (atof(content[(j * column) + 1].c_str()) * COST_PER_AREA) * (parent[i].binaryValue[j] - '0');\n    parent[i].fitnessValue = parent[i].benefit;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EasternGD/Road-maintainance-project-OpenMP/src/function/3"}
{"code": "for (i = 0; i < k; i++)\n  rgids[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/10"}
{"code": "for (j = 0; j < dim; j++)\n  for (k = 0; k < dim; k++)\n  c[i][j] += a[i][k] * b[k][j];\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lakhanjhawar/Parallel_Programming-Multithreading-Openmp-MPI-/Openmp/matrix2loops/1"}
{"code": "for (int j = 0; j < N; j++)\n{\n  c_col_0 = _mm_load_sd((C + i) + (j * lda));\n  int a_row_k_first_half;\n  int A_pos = ((((i / STRIDE) * STRIDE) * lda) + (0 * STRIDE)) + (i % STRIDE);\n  for (int k = 0; k < K; k++)\n  {\n    a_row_k_first_half = _mm_load_sd((A + A_pos) + (k * STRIDE));\n    b_k0 = _mm_set1_pd(B[k + (j * lda)]);\n    c_col_0 = _mm_fmadd_sd(a_row_k_first_half, b_k0, c_col_0);\n  }\n\n  _mm_store_sd((C + i) + (j * lda), c_col_0);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/dgemm-blocked/16"}
{"code": "for (unsigned i = 0; i < nvert; i++)\n{\n  pagerank[i] = scale;\n  last[i] = 0.0;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmitrime/pagerank-omp/pagerank/1"}
{"code": "for (unsigned int i = 0; i < num_cycle; i++)\n{\n  for (int j = 1; j < np; j++)\n  {\n    int info[] = {((j + i) + 1) % np, (((j - i) - 1) + np) % np};\n    MPI_Send((void *) info, 2, MPI_INT, j, TAG_TRANSFER_INFO, MPI_COMM_WORLD);\n  }\n\n  mat[i + 1] = mpi_compute_matrix(desc_array, local_nel, nel, np, myrank, (i + 1) % np, ((np - i) - 1) % np);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcotinacci/image-clustering/mpi_routines/11"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  c[i] = i + 1.01;\n  o1[i] = i + 1.01;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB050-functionparameter-orig-no/0"}
{"code": "for (c = align; (*c) != '\\0'; c++)\n  switch (*c)\n{\n  case '+':\n    putchar(*(b++));\n    break;\n\n  case '!':\n\n  case '=':\n    putchar(*(b++));\n    c++;\n    break;\n\n  default:\n    putchar(' ');\n    break;\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vsoriap/HOPE-in-Memory/Parallel_Vec_RecTasks/hirschberg_omp/15"}
{"code": "for (int from = Xi; from < (Xi + n); from++)\n{\n  for (int to = Xj; to < (Xj + n); to++)\n  {\n    if (((from != to) && (from != via)) && (to != via))\n    {\n      omp_set_lock(&dist_locks[from][to]);\n      dist[from][to] = min(dist[from][to], dist[from][via] + dist[via][to]);\n      omp_unset_lock(&dist_locks[from][to]);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shahzebp/floyd_warshall_parallel/openmp/1-recursive/2"}
{"code": "for (row = 0; row < m; row++)\n  for (col = 0; col < p; col++)\n  T[(row * p) + col] = 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bhaskariitm/OpenMP-codes/Code/2"}
{"code": "for (long i = 0; i < NV; i++)\n{\n  verT[i] = false;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/FullSyncOptimization/parallelLouvainMethodEarlyTerminate/0"}
{"code": "for (int i = 1; i < div; i++)\n{\n  x = inicio + (i * step);\n  ResLocal += f(x);\n}\n\n", "pragma": "omp parallel for default(none) shared(step, div, st, f) private(x) reduction(+: ResLocal)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rescurib/Notas_Computo_Paralelo/MemoriaCompartida/Sec_03/Ejemplo_3_4_OpenMP/0"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    wijk = ws[i][j][k];\n    wp1 = ws[i][j][k + 1];\n    wm1 = ws[i][j][k - 1];\n    rhs[i][j][k][0] = (rhs[i][j][k][0] + (dz1tz1 * ((u[i][j][k + 1][0] - (2.0 * u[i][j][k][0])) + u[i][j][k - 1][0]))) - (tz2 * (u[i][j][k + 1][3] - u[i][j][k - 1][3]));\n    rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dz2tz1 * ((u[i][j][k + 1][1] - (2.0 * u[i][j][k][1])) + u[i][j][k - 1][1]))) + (zzcon2 * ((us[i][j][k + 1] - (2.0 * us[i][j][k])) + us[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][1] * wp1) - (u[i][j][k - 1][1] * wm1)));\n    rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dz3tz1 * ((u[i][j][k + 1][2] - (2.0 * u[i][j][k][2])) + u[i][j][k - 1][2]))) + (zzcon2 * ((vs[i][j][k + 1] - (2.0 * vs[i][j][k])) + vs[i][j][k - 1]))) - (tz2 * ((u[i][j][k + 1][2] * wp1) - (u[i][j][k - 1][2] * wm1)));\n    rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dz4tz1 * ((u[i][j][k + 1][3] - (2.0 * u[i][j][k][3])) + u[i][j][k - 1][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[i][j][k + 1][3] * wp1) - (u[i][j][k - 1][3] * wm1)) + ((((u[i][j][k + 1][4] - square[i][j][k + 1]) - u[i][j][k - 1][4]) + square[i][j][k - 1]) * c2)));\n    rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dz5tz1 * ((u[i][j][k + 1][4] - (2.0 * u[i][j][k][4])) + u[i][j][k - 1][4]))) + (zzcon3 * ((qs[i][j][k + 1] - (2.0 * qs[i][j][k])) + qs[i][j][k - 1]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[i][j][k + 1][4] * rho_i[i][j][k + 1]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j][k - 1][4] * rho_i[i][j][k - 1])))) - (tz2 * ((((c1 * u[i][j][k + 1][4]) - (c2 * square[i][j][k + 1])) * wp1) - (((c1 * u[i][j][k - 1][4]) - (c2 * square[i][j][k - 1])) * wm1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(wijk, wp1, wm1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/58"}
{"code": "for (i = 1; i < size; i++)\n{\n  if (a[i] < a[i - 1])\n  {\n    printf(\"\\nError: at loc %li, %lf < %lf \\n\", i, a[i], a[i - 1]);\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hkominos/OpenMp_Lab/Bin_Packing/2"}
{"code": "for (int I = 0; I < q; I++)\n  process_ranks[I] = (it * 16) + I;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LefterisKarampas/Image_Convolution/src/main/14"}
{"code": "for (i = 0; i < 5; i++)\n{\n  k = partial_verify_vals[i];\n  if ((0 <= k) && (k <= ((1 << 20) - 1)))\n    switch ('A')\n  {\n    case 'S':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'W':\n      if (i < 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 2)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'A':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - (iteration - 1)))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'B':\n      if (((i == 1) || (i == 2)) || (i == 4))\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n    case 'C':\n      if (i <= 2)\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] + iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n    else\n    {\n      if (key_buff1[k - 1] != (test_rank_array[i] - iteration))\n      {\n        printf(\"Failed partial verification: iteration %d, test key %d\\n\", iteration, i);\n      }\n      else\n        passed_verification++;\n\n    }\n\n      break;\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/IS/is_single/4"}
{"code": "for (int j = 0; j < 10; ++j)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/nesting_of_regions/28"}
{"code": "for (int j = 0; j < K; j++)\n{\n  for (int t = 0; t < M; t++)\n  {\n    res_matrix[i][j] += matrix1[i][t] * matrix2[t][j];\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sergere15/OpenMP_tasks/Task2/1"}
{"code": "for (i1 = 0; i1 < n1; i1++)\n{\n  u[i3][n2 - 1][i1] = u[i3][1][i1];\n  u[i3][0][i1] = u[i3][n2 - 2][i1];\n}\n\n", "pragma": "omp parallel for firstprivate(n3 ,i1 ,i2 ,u ,n1 ,n2 ,i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/MG/mg/17"}
{"code": "for (i = 0; i < color_data.size(); i++)\n{\n  color_map[color_data[i]]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PhoenixNazarov/AutoContrast-pnm-OpenMp/modules/Pgp/0"}
{"code": "for (size_t time_point = 0; time_point < mesh->time_points; ++time_point)\n{\n  for (size_t space_point = 0; space_point < mesh->space_points; ++space_point)\n  {\n    fprintf(output, format, mesh_Get(mesh, time_point, space_point));\n    fprintf(output, \";\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  particles[i].ax = (particles[i].ay = 0);\n  for (int j = 0; j < n; j++)\n    apply_force(particles[i], particles[j], &dmin, &davg, &navg);\n\n}\n\n", "pragma": "            #pragma omp for reduction (+:navg) reduction(+:davg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Kfoury/Parallel_Particles_Simulation/serialmp/0"}
{"code": "for (I = 0; I < M; I++)\n  for (J = 0; J < N; J++)\n{\n  UNEW[I + 1][J] = (UOLD[I + 1][J] + ((TDTS8 * (Z[I + 1][J + 1] + Z[I + 1][J])) * (((CV[I + 1][J + 1] + CV[I][J + 1]) + CV[I][J]) + CV[I + 1][J]))) - (TDTSDX * (H[I + 1][J] - H[I][J]));\n  VNEW[I][J + 1] = (VOLD[I][J + 1] - ((TDTS8 * (Z[I + 1][J + 1] + Z[I][J + 1])) * (((CU[I + 1][J + 1] + CU[I][J + 1]) + CU[I][J]) + CU[I + 1][J]))) - (TDTSDY * (H[I][J + 1] - H[I][J]));\n  PNEW[I][J] = (POLD[I][J] - (TDTSDX * (CU[I + 1][J] - CU[I][J]))) - (TDTSDY * (CV[I][J + 1] - CV[I][J]));\n}\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel/1"}
{"code": "for (int i = 0; i < weeksNo; i++)\n  borPunt->accidents[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvalore/openmp-mpi-backup/PartialParallelWithMPI/21"}
{"code": "for (k = 0; k < mxyp1; k++)\n{\n  noffp = k / mx1;\n  moffp = my * noffp;\n  noffp = mx * (k - (mx1 * noffp));\n  nppp = kpic[k];\n  nn = nx - noffp;\n  nn = (mx < nn) ? (mx) : (nn);\n  mm = nyp - moffp;\n  mm = (my < mm) ? (my) : (mm);\n  ih = 0;\n  nh = 0;\n  edgelx = noffp;\n  edgerx = noffp + nn;\n  edgely = noff + moffp;\n  edgery = (noff + moffp) + mm;\n  for (j = 0; j < 8; j++)\n  {\n    ncl[j + (8 * k)] = 0;\n  }\n\n  for (j = 0; j < nppp; j++)\n  {\n    dx = ppart[idimp * (j + (nppmx * k))];\n    dy = ppart[1 + (idimp * (j + (nppmx * k)))];\n    ist = 0;\n    if (dx >= edgerx)\n    {\n      if (dx >= anx)\n        ppart[idimp * (j + (nppmx * k))] = dx - anx;\n\n      ist = 2;\n    }\n    else\n      if (dx < edgelx)\n    {\n      if (dx < 0.0)\n      {\n        dx += anx;\n        if (dx < anx)\n          ist = 1;\n        else\n          dx = 0.0;\n\n        ppart[idimp * (j + (nppmx * k))] = dx;\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n\n    if (dy >= edgery)\n    {\n      if (dy >= any)\n        ppart[1 + (idimp * (j + (nppmx * k)))] = dy - any;\n\n      ist += 6;\n    }\n    else\n      if (dy < edgely)\n    {\n      if (dy < 0.0)\n      {\n        dy += any;\n        if (dy < any)\n          ist += 3;\n        else\n          dy = 0.0;\n\n        ppart[1 + (idimp * (j + (nppmx * k)))] = dy;\n      }\n      else\n      {\n        ist += 3;\n      }\n\n    }\n\n\n    if (ist > 0)\n    {\n      ncl[(ist + (8 * k)) - 1] += 1;\n      ih += 1;\n      if (ih <= ntmax)\n      {\n        ihole[2 * (ih + ((ntmax + 1) * k))] = j + 1;\n        ihole[1 + (2 * (ih + ((ntmax + 1) * k)))] = ist;\n      }\n      else\n      {\n        nh = 1;\n      }\n\n    }\n\n  }\n\n  if (nh > 0)\n  {\n    *irc = ih;\n    ih = -ih;\n  }\n\n  ihole[(2 * (ntmax + 1)) * k] = ih;\n}\n\n", "pragma": "omp parallel for private(j,k,noffp,moffp,nppp,nn,mm,ih,nh,ist,dx,dy,edgelx,edgely, edgerx,edgery)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/5"}
{"code": "for (; i < leftLen; i++)\n{\n  result[i + j] = left[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zilmarij/Hybrid_MPI-OpenMP_based_Sorting/sort/12"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= x_max; j++)\n  {\n    vol_flux_y[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] = ((0.25 * dt) * yarea[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)]) * (((yvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] + yvel0[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + yvel1[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/flux_calc_kernel_c/1"}
{"code": "for (i = 1; i <= n; i++)\n{\n  dp[0][i] = i * pgap;\n}\n\n", "pragma": "        #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/sequence-alignment-openMP/seqalign_parallel11/0"}
{"code": "for (j = 2; j < (n - 2); j += tile_size)\n{\n  for (i = 2; i < (n - 2); i += tile_size)\n  {\n    for (jt = j; jt < MIN(n - 2, j + tile_size); jt++)\n    {\n      for (it = i; it < MIN(n - 2, i + tile_size); it++)\n      {\n        for (jj = -2; jj <= 2; jj++)\n          out[it + (jt * n)] += weight[0 + 2][jj + 2] * in[it + ((jt + jj) * n)];\n\n        for (ii = -2; ii < 0; ii++)\n          out[it + (jt * n)] += weight[ii + 2][0 + 2] * in[(it + ii) + (jt * n)];\n\n        for (ii = 1; ii <= 2; ii++)\n          out[it + (jt * n)] += weight[ii + 2][0 + 2] * in[(it + ii) + (jt * n)];\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/ParResKernels/OPENMP/Stencil/stencil/7"}
{"code": "for (int i = OMPC_SCHEDULE_unknown + 1; i < NUM_OPENMP_SCHEDULE_KINDS; ++i)\n{\n  Values += \"'\";\n  Values += getOpenMPSimpleClauseTypeName(OMPC_schedule, i);\n  Values += \"'\";\n  switch (i)\n  {\n    case NUM_OPENMP_SCHEDULE_KINDS - 2:\n      Values += \" or \";\n      break;\n\n    case NUM_OPENMP_SCHEDULE_KINDS - 1:\n      break;\n\n    default:\n      Values += Sep;\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/9"}
{"code": "for (uint32_t i = 0; i != m_StitchRelation.size(); i++)\n{\n  TSE += m_StitchRelation[i].size();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/limbo018/OpenMPL/src/SimpleMPL/2"}
{"code": "for (k = 0; k < nz; k++)\n{\n  for (i = 0; i < hs; i++)\n  {\n    z = ((k_beg + k) + 0.5) * dz;\n    if (fabs(z - ((3 * zlen) / 4)) <= (zlen / 16))\n    {\n      ind_r = (((ID_DENS * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + i;\n      ind_u = (((ID_UMOM * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + i;\n      ind_t = (((ID_RHOT * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + i;\n      state[ind_u] = (state[ind_r] + hy_dens_cell[k + hs]) * 50.;\n      state[ind_t] = ((state[ind_r] + hy_dens_cell[k + hs]) * 298.) - hy_dens_theta_cell[k + hs];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for private(z,ind_r,ind_u,ind_t) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-omp/main/7"}
{"code": "for (int i = 0; i < keys.size(); ++i)\n{\n  uint key = (keys[i] >> startBit) & mask;\n  ++histogramRadixFrequency[key];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kyleniemeyer/2012-04_Stanford_CME213/hw/hw4/programming/radixsort/9"}
{"code": "for (unsigned int i = 0; i < velocity_estimated.size(); i++)\n{\n  velocity_estimated[i] = (max_allowed_velocity / norm_velocity) * velocity_estimated[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/multiaxial_control_module_generalized_2d_utilities/4"}
{"code": "for (int ls = 0; ls < (n - 1); ls += 2 * len)\n{\n  int mid = compare((ls + len) - 1, n - 1);\n  int right = compare((ls + (2 * len)) - 1, n - 1);\n  merge(arr, ls, mid, right);\n}\n\n", "pragma": "        #pragma omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akarsh3007/Parallel-Computing/Assignment-4/openmp/mergesort/2"}
{"code": "for (i = 0; i < result->m; i++)\n{\n  for (j = 0; j < result->n; j++)\n  {\n    if (sqrt((float) (((i - radius) * (i - radius)) + ((j - radius) * (j - radius)))) <= radius)\n      m_set_val(result, i, j, 1.0);\n    else\n      m_set_val(result, i, j, 0.0);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/6"}
{"code": "for (uint32_t i = 0; i < AES_BLOCKLEN; i += 1)\n  printf(\"%.2X \", key[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ZulNaar/MPCrypt/source/3"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    if ((((i * nx) + j) % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%0.2lf \", ex[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Fedor1533/FDTD-2D-solution-openMP-/fdtd-2d/6"}
{"code": "for (j = 0; j <= (len - 1); j += 1)\n{\n  a[i][j] += a[i + 1][j];\n}\n\n", "pragma": "omp parallel for private (j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB003-antidep2-orig-yes/2"}
{"code": "for (unsigned int i = 0; i < (((2048 / 1) + 2) / 2); i++)\n{\n  int h_before;\n  int h_after;\n  int delta_E;\n  byte spin_old;\n  byte spin_new;\n  byte spin_neigh_x;\n  byte spin_neigh_y;\n  byte spin_neigh_z;\n  byte spin_neigh_w;\n  for (unsigned int j = 0; j < ((2048 / 5) + 2); j++)\n  {\n    if (write[i][j].isGhost == 1)\n    {\n      spin_old = write[i][j].data;\n      spin_neigh_x = read[i][j].data;\n      spin_neigh_y = read[i][j + 1].data;\n      spin_neigh_z = read[i][j - 1].data;\n      spin_neigh_w = read[i + ((2 * (color ^ (j % 2))) - 1)][j].data;\n      h_before = (((-(spin_old == spin_neigh_x)) - (spin_old == spin_neigh_y)) - (spin_old == spin_neigh_z)) - (spin_old == spin_neigh_w);\n      spin_new = (spin_old + ((byte) (1 + (rand_MWC_co(&x_l, &a_l) * (Q - 1))))) % Q;\n      h_after = (((-(spin_new == spin_neigh_x)) - (spin_new == spin_neigh_y)) - (spin_new == spin_neigh_z)) - (spin_new == spin_neigh_w);\n      delta_E = h_after - h_before;\n      float p = rand_MWC_co(&x_l, &a_l);\n      if ((delta_E <= 0) || (p <= table_expf_temp[delta_E]))\n      {\n        write[i][j].data = spin_new;\n      }\n\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/52"}
{"code": "for (j = 0; j < length; j++)\n{\n  a[j] = 0.0;\n  b[j] = 2.0;\n  c[j] = 2.0;\n}\n\n", "pragma": "omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Nstream/nstream/0"}
{"code": "for (int bucket = 0; bucket < NUM_BUCKETS; bucket++)\n{\n  uint32_t index = local_bucket_offsets[bucket];\n  for (int chunk = 0; chunk < CHUNKS_PER_PE; chunk++)\n  {\n    memcpy(&my_local_bucketed_keys[index], my_local_bucketed_keys_chunk[chunk][bucket], (sizeof(KEY_TYPE)) * local_bucket_sizes_chunk[chunk][bucket]);\n    index += local_bucket_sizes_chunk[chunk][bucket];\n  }\n\n  local_bucket_offsets[bucket] = index;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/11"}
{"code": "for (int k = 0; k < 2; k++)\n  for (int j = 0; j < 500; j++)\n{\n  outputlayer[k][j] = outputlayer[k][j] + (errRate * (errout[k] * forpassl3[j]));\n}\n\n\n", "pragma": "omp for schedule(dynamic,5)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/8"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  if (i != me)\n    MPI_Sendrecv(scdata.data() + spos, ssizes[i], MPI_GRAPH_TYPE, i, CommunityTag, rcdata.data() + rpos, rsizes[i], MPI_GRAPH_TYPE, i, CommunityTag, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);\n\n  spos += ssizes[i];\n  rpos += rsizes[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/6"}
{"code": "for (int ll = 0; ll < NUM_VARS; ll++)\n{\n  for (int s = 0; s < sten_size; s++)\n  {\n    int inds = ((((ll * (nz + (2 * hs))) * (nx + (2 * hs))) + ((k + hs) * (nx + (2 * hs)))) + i) + s;\n    stencil[s] = state[inds];\n  }\n\n  vals[ll] = ((((-stencil[0]) / 12) + ((7 * stencil[1]) / 12)) + ((7 * stencil[2]) / 12)) - (stencil[3] / 12);\n  d3_vals[ll] = (((-stencil[0]) + (3 * stencil[1])) - (3 * stencil[2])) + stencil[3];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/miniWeather-sycl/main/0"}
{"code": "for (int i = 0; i < (max + 1); i++)\n{\n  sumFinal += pagerankArray[i];\n  (((outputFile << i) << \"\\t\") << pagerankArray[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soumitraj/OpenMP-MPI/Task1/task1/2"}
{"code": "for (int i = 0; i < sz; i++)\n  for (int j = 0; j < sz; j++)\n  an[(i * sz) + j] = 0.;\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MickiFoerster/spl-transformer/test-suite/utilities/1"}
{"code": "for (size_t i = 0; i < 40000; i++)\n{\n  if ((node_distance_array[i] < tmp_dist) && (visited_nodes_array[i] == 0))\n  {\n    tmp_node = i;\n    tmp_dist = node_distance_array[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Minjian/SSSP_OpenMP_CUDA/source_code/serial_and_openmp_sssp/0"}
{"code": "for (int i = 0; i < bufferReaderSize; i++)\n{\n  buffer = bufferReader[i];\n  bufferWriter[i] = thread_encryption(buffer);\n}\n\n", "pragma": "omp parallel for schedule(nonmonotonic : dynamic, 100) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arthurhoch/des-cipher-openmp/src/des/2"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      wijk = ws[k][j][i];\n      wp1 = ws[k + 1][j][i];\n      wm1 = ws[k - 1][j][i];\n      rhs[k][j][i][0] = (rhs[k][j][i][0] + (dz1tz1 * ((u[k + 1][j][i][0] - (2.0 * u[k][j][i][0])) + u[k - 1][j][i][0]))) - (tz2 * (u[k + 1][j][i][3] - u[k - 1][j][i][3]));\n      rhs[k][j][i][1] = ((rhs[k][j][i][1] + (dz2tz1 * ((u[k + 1][j][i][1] - (2.0 * u[k][j][i][1])) + u[k - 1][j][i][1]))) + (zzcon2 * ((us[k + 1][j][i] - (2.0 * us[k][j][i])) + us[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][1] * wp1) - (u[k - 1][j][i][1] * wm1)));\n      rhs[k][j][i][2] = ((rhs[k][j][i][2] + (dz3tz1 * ((u[k + 1][j][i][2] - (2.0 * u[k][j][i][2])) + u[k - 1][j][i][2]))) + (zzcon2 * ((vs[k + 1][j][i] - (2.0 * vs[k][j][i])) + vs[k - 1][j][i]))) - (tz2 * ((u[k + 1][j][i][2] * wp1) - (u[k - 1][j][i][2] * wm1)));\n      rhs[k][j][i][3] = ((rhs[k][j][i][3] + (dz4tz1 * ((u[k + 1][j][i][3] - (2.0 * u[k][j][i][3])) + u[k - 1][j][i][3]))) + ((zzcon2 * con43) * ((wp1 - (2.0 * wijk)) + wm1))) - (tz2 * (((u[k + 1][j][i][3] * wp1) - (u[k - 1][j][i][3] * wm1)) + ((((u[k + 1][j][i][4] - square[k + 1][j][i]) - u[k - 1][j][i][4]) + square[k - 1][j][i]) * c2)));\n      rhs[k][j][i][4] = ((((rhs[k][j][i][4] + (dz5tz1 * ((u[k + 1][j][i][4] - (2.0 * u[k][j][i][4])) + u[k - 1][j][i][4]))) + (zzcon3 * ((qs[k + 1][j][i] - (2.0 * qs[k][j][i])) + qs[k - 1][j][i]))) + (zzcon4 * (((wp1 * wp1) - ((2.0 * wijk) * wijk)) + (wm1 * wm1)))) + (zzcon5 * (((u[k + 1][j][i][4] * rho_i[k + 1][j][i]) - ((2.0 * u[k][j][i][4]) * rho_i[k][j][i])) + (u[k - 1][j][i][4] * rho_i[k - 1][j][i])))) - (tz2 * ((((c1 * u[k + 1][j][i][4]) - (c2 * square[k + 1][j][i])) * wp1) - (((c1 * u[k - 1][j][i][4]) - (c2 * square[k - 1][j][i])) * wm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/BT/bt/8"}
{"code": "for (j = ((0x7fffffffffffffffLL * 2ULL) + 1) - 3; j >= (0x7fffffffffffffffLL + 70ULL); j -= 0x7fffffffffffffffLL + 50ULL)\n{\n  if (j == (((0x7fffffffffffffffLL * 2ULL) + 1) - 3))\n    set(3, 0);\n  else\n    e = 1;\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-6/3"}
{"code": "for (j = ny - 1; j >= 0; j--)\n{\n  for (i = 0; i < nx; i++)\n  {\n    tmp = x[j + (ny * i)];\n    if ((xmin < 0) || (xmax > thresh))\n    {\n      tmp = (int) ((thresh * (fabs(tmp - xmin) / (xmax - xmin))) + 0.5);\n    }\n    else\n    {\n      tmp = (int) (fabs(tmp) + 0.5);\n    }\n\n    grey = tmp;\n    fprintf(fp, \"%3d \", grey);\n    if (0 == ((k + 1) % PIXPERLINE))\n      fprintf(fp, \"\\n\");\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cvetkovic/mups/dz1/za_predaju/dz1z4/2"}
{"code": "for (i = id; i < num_steps; i += lnthreads)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mateoochoa/Examples_Openmp/integral/main/3"}
{"code": "for (int i = 0; i < Ntot; i++)\n{\n  cell_z = floor(z[i] / grid.dz);\n  cell_r = floor(r[i] / grid.dr);\n  hz = (z[i] - (cell_z * grid.dz)) / grid.dz;\n  hr = (r[i] - (cell_r * grid.dr)) / grid.dr;\n  rho[(cell_z * Nr) + cell_r] += ((charge * (1 - hz)) * (1 - hr)) / node_volume[(cell_z * Nr) + cell_r];\n  rho[((cell_z + 1) * Nr) + cell_r] += ((charge * hz) * (1 - hr)) / node_volume[((cell_z + 1) * Nr) + cell_r];\n  rho[(((cell_z + 1) * Nr) + cell_r) + 1] += ((charge * hz) * hr) / node_volume[(((cell_z + 1) * Nr) + cell_r) + 1];\n  rho[((cell_z * Nr) + cell_r) + 1] += ((charge * (1 - hz)) * hr) / node_volume[((cell_z * Nr) + cell_r) + 1];\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SmirnovVladimir95/CPP_RZ_PIC_Openmp/Particles/Interpolation/2"}
{"code": "for (i = 1; i < (p - 1); i++)\n{\n  for (j = chunkSize; j < (((i - 1) * chunkSize) + 1); j++)\n  {\n    m |= a[j];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeNishino/openmp-tests/main/2"}
{"code": "for (int i = 0; i < L1; i++)\n{\n  for (int j = 0; j < C2; j++)\n  {\n    for (int k = 0; k < X; k++)\n    {\n      Result[i][j] = (M1[i][k] * M2[k][j]) + Result[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static,2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ayoubmundia/ProduitMatricielle/thread/3"}
{"code": "for (i = 0; i < (NGROUPS / 10); i++)\n{\n  for (j = 0; j < 10; j++)\n    printf(\"%9.2f\", compact[(10 * i) + j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Botxan/Parallel-K-means-Clustering/parallel/gengroups_p/14"}
{"code": "for (long j = 0; j < numtasks; ++j)\n{\n  V[j] = j;\n}\n\n", "pragma": "#pragma omp parallel for schedule(runtime) num_threads(nworkers)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/perf_parfor2/0"}
{"code": "for (i = 0; i < NCA; i++)\n  for (j = 0; j < NCB; j++)\n  b[i][j] = i * j;\n\n\n", "pragma": "#pragma omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Boussetta/Introduction-to-OpenMP/MatrixMultiply/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmppdh6fo8g.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhuber6/cgo2022-artifacts/llvm-project12/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (int i = 0; i < centersCount_in; ++i)\n{\n  dist_t = distance(freqTable_in, index_in, clouds[i].center_index);\n  if (dist_t < dist)\n  {\n    dist = dist_t;\n    which = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyarbean/RcppKmeans/src/rcpp_kmeans/4"}
{"code": "for (i = 1; i < (((2048 / NODESX) + 2) - 1); i++)\n{\n  j = 1;\n  ii = ((((i + j) % 2) * ((2048 / NODESX) + 2)) + i) / 2;\n  if (ii < (((2048 / NODESX) + 2) / 2))\n    got[i] = whites[ii][j].data;\n  else\n    if (ii >= (((2048 / NODESX) + 2) / 2))\n    got[i] = blacks[ii - (((2048 / NODESX) + 2) / 2)][j].data;\n\n\n  j = ((2048 / 5) + 2) - 2;\n  ii = ((((i + j) % 2) * ((2048 / NODESX) + 2)) + i) / 2;\n  if (ii < (((2048 / NODESX) + 2) / 2))\n    get[i] = whites[ii][j].data;\n  else\n    if (ii >= (((2048 / NODESX) + 2) / 2))\n    get[i] = blacks[ii - (((2048 / NODESX) + 2) / 2)][j].data;\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/106"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < m; j++)\n{\n  xx = (int) ((-1.0) + ((*dx) * (i - 1)));\n  yy = (int) ((-1.0) + ((*dy) * (j - 1)));\n  u[j + (i * m)] = 0.0;\n  uold[j + (i * m)] = 0.0;\n  f[j + (i * m)] = (((((-1.0) * alpha) * (1.0 - (xx * xx))) * (1.0 - (yy * yy))) - (2.0 * (1.0 - (xx * xx)))) - (2.0 * (1.0 - (yy * yy)));\n}\n\n\n", "pragma": "omp parallel for private(xx,yy,j,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/jacobi-ompacc-multiGPU/0"}
{"code": "for (int m = -kernel_div_2; m <= kernel_div_2; m++)\n{\n  for (int n = -kernel_div_2; n <= kernel_div_2; n++)\n  {\n    kernel[m + kernel_div_2][n + kernel_div_2] = gauss_2D(m, n, sigma);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ema2159/OpenCVCUDAImageProcessing/Exercise1/OpenCV/convolutionGauss/gaussFilter/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n    (outputFile << data[(i * size) + j]) << \"\\t\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daverynties/Floyd-Warshall-Algorithm-using-OpenMP/floyd_known/2"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    map_cost[i][j] = 1000000000000;\n    if (fricc[i][j] < 0.0)\n    {\n      map_cost[i][j] = -9999;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for private(i,j) collapse(2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OctavioSaul/OpenMP_proyect/cost_dist/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  acc += x[i * inc_x] * y[i * inc_y];\n}\n\n", "pragma": "omp parallel for reduction(+:acc)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ekloberdanz/ekblas/ekblas/0"}
{"code": "for (i = 0; i < comm->num_sends; i++)\n  printf(\"%2d \", comm->send_sizes[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/2"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    n = ((m - 3) + 1) * 5;\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k]);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/168"}
{"code": "for (j = 0; j < t; j++)\n{\n  mergeSort(arr, count, j * batch_size, ((j + 1) * batch_size) - 1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Akash01010/MergeSort_OpenMP/mergeSort/0"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = (((vel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * node_mass_pre[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + mom_flux[FTNREF2D(j - 1, k, x_max + 5, x_min - 2, y_min - 2)]) - mom_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) / node_mass_post[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP/advec_mom_kernel_c/8"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    matrix_a[i][j] = ((float) rand()) / RAND_MAX;\n    matrix_b[i][j] = ((float) rand()) / RAND_MAX;\n    matrix_r[i][j] = 0.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darek74123/PR-OpenMP-Project/Code/matrix-slower/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) Inertia[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/116"}
{"code": "for (k = 0; k < K; ++k)\n{\n  cblas_sscal(M, 1.0f / nassign[k], (float *) PyArray_GETPTR2(pycentroids, k, 0), inc_centroids);\n  cblas_saxpy(M, -1, PyArray_GETPTR2(pycentroids, k, 0), inc_centroids, PyArray_GETPTR2(pycentroids_bak, k, 0), inc_centroids);\n  convergence[k] = cblas_snrm2(M, PyArray_GETPTR2(pycentroids_bak, k, 0), inc_centroids);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/danielhauagge/pykmeans/pykmeans/2"}
{"code": "for (i = 0; i < local_A->n_bar; i++)\n  for (j = 0; j < local_A->n_bar; j++)\n  *((local_A->entries + (local_A->n_bar * i)) + j) = 0.0E0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/15"}
{"code": "for (i = 0; i < num_rows; i++)\n{\n  (((cout << i) << \" = \") << pr[i]) << endl;\n  sum += pr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/pagerank/src/omp_pagerank_v1/7"}
{"code": "for (unsigned int block = 0; block < totalBlocks; block++)\n{\n  if (((nx > 1) && (ny > 1)) && (nz > 1))\n  {\n    field[block] = zfp_field_3d(&off_arr[((block * MIN_BLOCK_SIZE) * ny) * nx], type, nx, ny, block_dim[block]);\n  }\n  else\n  {\n    field[block] = zfp_field_2d(&off_arr[(block * MIN_BLOCK_SIZE) * nx], type, nx, block_dim[block]);\n  }\n\n  zfp_stream_rewind(zfp[block]);\n  if (!zfp_decompress(zfp[block], field[block]))\n  {\n    (Logger->Error() << \"Decompression failed\") << '\\n';\n    exit(EXIT_FAILURE);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/utils/compressor/Compressor/6"}
{"code": "for (size_t q = offset + 1; q < w; ++q)\n{\n  if (isinf(img_row[q]))\n    continue;\n\n  float s = parabola_intersect(img_row, v[k], q);\n  while ((k > 0) && (s <= z[k - 1]))\n  {\n    --k;\n    s = parabola_intersect(img_row, v[k], q);\n  }\n\n  z[k] = s;\n  ++k;\n  v[k] = q;\n  h[k] = img_row[q];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chaquator/chaq-sdfgen/openmp/df/2"}
{"code": "for (i = 0; i < imax_num_mesh; i++)\n{\n  MC_ind[i] = 0;\n  MC_compact_ind[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moruku36/openmp/OpenMP_Samples/Answer/DEM/C/dem/3"}
{"code": "for (int jj = 0; jj < params.ny; jj++)\n{\n  for (int ii = 0; ii < params.nx; ii++)\n  {\n    float tp[9];\n    int y_n = (jj + 1) % params.ny;\n    int x_e = (ii + 1) % params.nx;\n    int y_s = (jj == 0) ? ((jj + params.ny) - 1) : (jj - 1);\n    int x_w = (ii == 0) ? ((ii + params.nx) - 1) : (ii - 1);\n    tp[0] = cells->speeds[0][ii + (jj * params.nx)];\n    tp[1] = cells->speeds[1][x_w + (jj * params.nx)];\n    tp[2] = cells->speeds[2][ii + (y_s * params.nx)];\n    tp[3] = cells->speeds[3][x_e + (jj * params.nx)];\n    tp[4] = cells->speeds[4][ii + (y_n * params.nx)];\n    tp[5] = cells->speeds[5][x_w + (y_s * params.nx)];\n    tp[6] = cells->speeds[6][x_e + (y_s * params.nx)];\n    tp[7] = cells->speeds[7][x_e + (y_n * params.nx)];\n    tp[8] = cells->speeds[8][x_w + (y_n * params.nx)];\n    float local_density = (((((((tp[0] + tp[1]) + tp[2]) + tp[3]) + tp[4]) + tp[5]) + tp[6]) + tp[7]) + tp[8];\n    float u_x = (((tp[1] + tp[5]) + tp[8]) - ((tp[3] + tp[6]) + tp[7])) / local_density;\n    float u_y = (((tp[2] + tp[5]) + tp[6]) - ((tp[4] + tp[7]) + tp[8])) / local_density;\n    float u_sq = (u_x * u_x) + (u_y * u_y);\n    float u[9];\n    u[0] = 0;\n    u[1] = u_x;\n    u[2] = u_y;\n    u[3] = -u_x;\n    u[4] = -u_y;\n    u[5] = u_x + u_y;\n    u[6] = (-u_x) + u_y;\n    u[7] = (-u_x) - u_y;\n    u[8] = u_x - u_y;\n    tmp_cells->speeds[0][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[0]) : (tp[0] + (params.omega * ((((4.f / 9.f) * local_density) * (1.f - (1.5f * u_sq))) - tp[0])));\n    tmp_cells->speeds[1][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[3]) : (tp[1] + (params.omega * ((((1.f / 9.f) * local_density) * (((1.f + (3 * u[1])) + (4.5f * (u[1] * u[1]))) - (1.5f * u_sq))) - tp[1])));\n    tmp_cells->speeds[2][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[4]) : (tp[2] + (params.omega * ((((1.f / 9.f) * local_density) * (((1.f + (3 * u[2])) + (4.5f * (u[2] * u[2]))) - (1.5f * u_sq))) - tp[2])));\n    tmp_cells->speeds[3][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[1]) : (tp[3] + (params.omega * ((((1.f / 9.f) * local_density) * (((1.f + (3 * u[3])) + (4.5f * (u[3] * u[3]))) - (1.5f * u_sq))) - tp[3])));\n    tmp_cells->speeds[4][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[2]) : (tp[4] + (params.omega * ((((1.f / 9.f) * local_density) * (((1.f + (3 * u[4])) + (4.5f * (u[4] * u[4]))) - (1.5f * u_sq))) - tp[4])));\n    tmp_cells->speeds[5][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[7]) : (tp[5] + (params.omega * ((((1.f / 36.f) * local_density) * (((1.f + (3 * u[5])) + (4.5f * (u[5] * u[5]))) - (1.5f * u_sq))) - tp[5])));\n    tmp_cells->speeds[6][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[8]) : (tp[6] + (params.omega * ((((1.f / 36.f) * local_density) * (((1.f + (3 * u[6])) + (4.5f * (u[6] * u[6]))) - (1.5f * u_sq))) - tp[6])));\n    tmp_cells->speeds[7][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[5]) : (tp[7] + (params.omega * ((((1.f / 36.f) * local_density) * (((1.f + (3 * u[7])) + (4.5f * (u[7] * u[7]))) - (1.5f * u_sq))) - tp[7])));\n    tmp_cells->speeds[8][ii + (jj * params.nx)] = (obstacles[(jj * params.nx) + ii]) ? (tp[6]) : (tp[8] + (params.omega * ((((1.f / 36.f) * local_density) * (((1.f + (3 * u[8])) + (4.5f * (u[8] * u[8]))) - (1.5f * u_sq))) - tp[8])));\n  }\n\n}\n\n", "pragma": "omp parallel for shared(cells, tmp_cells, obstacles)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jerrykress/Lattice-Boltzmann-OpenMP/d2q9-bgk/0"}
{"code": "for (int i = 0; i < size_array; i++)\n{\n  if (array[i] < small)\n  {\n    small = array[i];\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openMP_profiler/31"}
{"code": "for (__pyx_t_11 = 0; __pyx_t_11 < __pyx_t_9; __pyx_t_11 += 1)\n{\n  __pyx_v_i = __pyx_t_11;\n  __pyx_v_p[__pyx_v_i] = Py_None;\n  Py_INCREF(Py_None);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/td3a_cpp/td3a_cpp/tutorial/td_mul_cython/6"}
{"code": "for (int i = 0, ii = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%d \", ii);\n  ii++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/121"}
{"code": "for (i = 0; i < 128; i++)\n{\n  the_points[i].x = i * 3;\n  the_points[i].y = i * 2;\n  for (j = 0; j < 128; j++)\n  {\n    selected_cpu[(i * 128) + j].position = 0;\n    selected_cpu[(i * 128) + j].value = 100000.00;\n    selected_gpu[(i * 128) + j].position = 0;\n    selected_gpu[(i * 128) + j].value = 100000.00;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/k-nearest/src/k-nearest_gpu/2"}
{"code": "for (i = 0; i < array_length; i++)\n{\n  if (((((*(r + i)) > (r_inj - (C_LIGHT / fps))) && ((*(r + i)) < (r_inj + (C_LIGHT / fps)))) && ((*(theta + i)) < theta_max)) && ((*(theta + i)) > theta_min))\n  {\n    for (j = 0; j < (*(ph_dens + k)); j++)\n    {\n      y_dum = 1;\n      yfr_dum = 0;\n      while (y_dum > yfr_dum)\n      {\n        fr_dum = (gsl_rng_uniform_pos(rand) * 6.3e11) * (*(temps + i));\n        y_dum = gsl_rng_uniform_pos(rand);\n        if (spect == 'w')\n        {\n          yfr_dum = ((1.0 / 1.29e31) * pow(fr_dum / (*(temps + i)), 3.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n        else\n        {\n          fr_max = (C_LIGHT * (*(temps + i))) / 0.29;\n          bb_norm = pow(fr_max / (*(temps + i)), 2.0) / (exp(((PL_CONST * fr_max) / K_B) / (*(temps + i))) - 1);\n          yfr_dum = ((1.0 / bb_norm) * pow(fr_dum / (*(temps + i)), 2.0)) / (exp((PL_CONST * fr_dum) / (K_B * (*(temps + i)))) - 1);\n        }\n\n      }\n\n      position_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_phi = (gsl_rng_uniform(rand) * 2) * M_PI;\n      com_v_theta = acos((gsl_rng_uniform(rand) * 2) - 1);\n      *(p_comv + 0) = (PL_CONST * fr_dum) / C_LIGHT;\n      *(p_comv + 1) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * cos(com_v_phi);\n      *(p_comv + 2) = (((PL_CONST * fr_dum) / C_LIGHT) * sin(com_v_theta)) * sin(com_v_phi);\n      *(p_comv + 3) = ((PL_CONST * fr_dum) / C_LIGHT) * cos(com_v_theta);\n      *(boost + 0) = ((-1) * (*(vx + i))) * cos(position_phi);\n      *(boost + 1) = ((-1) * (*(vx + i))) * sin(position_phi);\n      *(boost + 2) = (-1) * (*(vy + i));\n      lorentzBoost(boost, p_comv, l_boost, 'p');\n      (*ph)[ph_tot].p0 = *(l_boost + 0);\n      (*ph)[ph_tot].p1 = *(l_boost + 1);\n      (*ph)[ph_tot].p2 = *(l_boost + 2);\n      (*ph)[ph_tot].p3 = *(l_boost + 3);\n      (*ph)[ph_tot].r0 = (*(x + i)) * cos(position_phi);\n      (*ph)[ph_tot].r1 = (*(x + i)) * sin(position_phi);\n      (*ph)[ph_tot].r2 = *(y + i);\n      (*ph)[ph_tot].num_scatt = 0;\n      ph_tot++;\n    }\n\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/PARALLELIZE/mclib/5"}
{"code": "for (unsigned i = 0; i < raw_feat_frequency_creation_thread_lock.size(); ++i)\n  omp_destroy_lock(&raw_feat_frequency_creation_thread_lock[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/11"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  int m1count = matrix.ia[i + 1] - matrix.ia[i];\n  for (int j = 0; j < matrix2.cols; j++)\n  {\n    int dp = 0;\n    int m1pos = matrix.ia[i];\n    int m1seen = 0;\n    int m2count = matrix2.ia[j + 1] - matrix2.ia[j];\n    int m2pos = matrix2.ia[j];\n    int m2seen = 0;\n    while ((m1seen != m1count) && (m2seen != m2count))\n    {\n      if (matrix.ja[m1pos] == matrix2.ja[m2pos])\n      {\n        dp += matrix.nnz.i[m1pos++] * matrix2.nnz.i[m2pos++];\n        m1seen++;\n        m2seen++;\n      }\n      else\n        if (matrix.ja[m1pos] < matrix2.ja[m2pos])\n      {\n        m1seen++;\n        m1pos++;\n      }\n      else\n      {\n        m2seen++;\n        m2pos++;\n      }\n\n\n    }\n\n    if (dp != 0)\n    {\n      result_local[i].elements[result_local[i].count].value.i = dp;\n      result_local[i].elements[result_local[i].count].x = i;\n      result_local[i].elements[result_local[i].count++].y = j;\n    }\n\n  }\n\n  totalcount += result_local[i].count;\n}\n\n", "pragma": "omp parallel for reduction(+:totalcount) shared(matrix,matrix2) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/8"}
{"code": "for (long i = 0; i < NE; i++)\n{\n  __sync_fetch_and_add(&edgeListPtr[edgeListTmp[i].head + 1], 1);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadPajekFormat/3"}
{"code": "for (size_t i = round(size / 2); i < size; i++)\n{\n  max_ = max(A[i], B[i]);\n  C[i] = max_;\n  sum = sum + max_;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/georgy228/Open-MP/5/5/Source/1"}
{"code": "for (t = j; t < size2; t++, k++)\n  temp[k] = B[t];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/susheelsagar/OpenMP/quicksort/7"}
{"code": "for (unsigned int i = 0; s[i] != 0; ++i)\n{\n  x <<= 3;\n  x ^= s[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_NarrowPerfectHash/nph/0"}
{"code": "for (int i = 0; i < firsttable->size; i++)\n{\n  climbing->current[i + firsttable->size] = firsttable->current[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nadaelabdellaoui20/prog-para-sous-tableau-maximal/src/el-abdellaoui/7"}
{"code": "for (size_t i = 0; i < 351; i++)\n{\n  d[i] = a[i] + c[i];\n  printf(\"%g %d %d\\n\", d[i], i, omp_get_thread_num());\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SeyfGoumeida/OpenMP/Exo2/1"}
{"code": "for (int k = 0; k < active_size; k++)\n{\n  G[k] += (Q_i[k] * delta_alpha_i) + (Q_j[k] * delta_alpha_j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/7"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  ((cout << \"i = \") << i) << endl;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mangosroom/learn-openmp/cmake_example/main/0"}
{"code": "for (i = 0; i < 200; i++)\n{\n  for (j = 0; j < 1080; j++)\n  {\n    for (k = 0; k < 1080; k++)\n    {\n      if (video[i][j][k] < seuil)\n        videoseuil[i][j][k] = 0;\n      else\n        videoseuil[i][j][k] = 1;\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(4) private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodneyAboue/openmp2/main/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  omp_set_lock(&mylock);\n  a += 1;\n  omp_unset_lock(&mylock);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jiang-Fuyou/OpenMPSimpleTutorials/SimpleTest10/simple_test_10/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  dot_prod += a[i] * b[i];\n}\n\n", "pragma": "omp for reduction(+:dot_prod)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/madrinathapa/High-Performance-Computing/Assignment_2/dot_prod/0"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  r = dot2(a, b);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/15"}
{"code": "for (int i = 0; i < people_count; ++i)\n{\n  for (int j = k; j < sample_count_per_person; ++j)\n  {\n    sprintf(buff, \"%d.%d.txt\", i + 1, j + 1);\n    int found_person_id = find_closest(histogram_array, people_count, k, 256, histogram_array[i][j]);\n    found_people_array[i][j] = (u_int8_t) found_person_id;\n    if (found_person_id == i)\n      correct_count++;\n    else\n      incorrect_count++;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/egebasturk/Parallel-Computing-Projects/Project3/cs426_project3_code/lbp_omp/3"}
{"code": "for (r = lb; r < ub; r++)\n{\n  for (c = 3 / 2; c < (C - (3 / 2)); c++)\n  {\n    S = 0;\n    t = (r * R) + c;\n    for (i = (-K) / 2; i <= (K / 2); i++)\n    {\n      for (j = (-K) / 2; j <= (K / 2); j++)\n      {\n        k = ((r + i) * R) + (c + j);\n        data = In_Img[k];\n        w = ((i + 1) * K) + (j + 1);\n        coeff = Kernel[w];\n        S = S + ((int) (coeff * data));\n      }\n\n    }\n\n    S = S >> 7;\n    S = (S > 255) ? (255) : (S);\n    S = (S < 0) ? (0) : (S);\n    Out_Img[t] = (uint8_t) S;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EEESlab/hsdes_mcu_conv_openmp_template/conv_kernel/0"}
{"code": "for (i = kxpi - 1; i < kxpt; i++)\n{\n  koff = (3 * nyv) * i;\n  for (k = 0; k < ny; k++)\n  {\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      t1 = g[(3 * k1) + koff];\n      t2 = g[(1 + (3 * k1)) + koff];\n      t3 = g[(2 + (3 * k1)) + koff];\n      g[(3 * k1) + koff] = g[(3 * k) + koff];\n      g[(1 + (3 * k1)) + koff] = g[(1 + (3 * k)) + koff];\n      g[(2 + (3 * k1)) + koff] = g[(2 + (3 * k)) + koff];\n      g[(3 * k) + koff] = t1;\n      g[(1 + (3 * k)) + koff] = t2;\n      g[(2 + (3 * k)) + koff] = t3;\n    }\n\n  }\n\n  ns = 1;\n  for (m = 0; m < indy; m++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        s = sct[kmr * j];\n        t1 = s * g[(3 * j2) + koff];\n        t2 = s * g[(1 + (3 * j2)) + koff];\n        t3 = s * g[(2 + (3 * j2)) + koff];\n        g[(3 * j2) + koff] = g[(3 * j1) + koff] - t1;\n        g[(1 + (3 * j2)) + koff] = g[(1 + (3 * j1)) + koff] - t2;\n        g[(2 + (3 * j2)) + koff] = g[(2 + (3 * j1)) + koff] - t3;\n        g[(3 * j1) + koff] += t1;\n        g[(1 + (3 * j1)) + koff] += t2;\n        g[(2 + (3 * j1)) + koff] += t3;\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,m,ns,ns2,km,kmr,k1,k2,j1,j2,koff,s,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/23"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  tmp1 = dt * tx1;\n  tmp2 = dt * tx2;\n  lhs[i][j][k][AA][0][0] = (((-tmp2) * fjac[i - 1][j][k][0][0]) - (tmp1 * njac[i - 1][j][k][0][0])) - (tmp1 * dx1);\n  lhs[i][j][k][AA][0][1] = ((-tmp2) * fjac[i - 1][j][k][0][1]) - (tmp1 * njac[i - 1][j][k][0][1]);\n  lhs[i][j][k][AA][0][2] = ((-tmp2) * fjac[i - 1][j][k][0][2]) - (tmp1 * njac[i - 1][j][k][0][2]);\n  lhs[i][j][k][AA][0][3] = ((-tmp2) * fjac[i - 1][j][k][0][3]) - (tmp1 * njac[i - 1][j][k][0][3]);\n  lhs[i][j][k][AA][0][4] = ((-tmp2) * fjac[i - 1][j][k][0][4]) - (tmp1 * njac[i - 1][j][k][0][4]);\n  lhs[i][j][k][AA][1][0] = ((-tmp2) * fjac[i - 1][j][k][1][0]) - (tmp1 * njac[i - 1][j][k][1][0]);\n  lhs[i][j][k][AA][1][1] = (((-tmp2) * fjac[i - 1][j][k][1][1]) - (tmp1 * njac[i - 1][j][k][1][1])) - (tmp1 * dx2);\n  lhs[i][j][k][AA][1][2] = ((-tmp2) * fjac[i - 1][j][k][1][2]) - (tmp1 * njac[i - 1][j][k][1][2]);\n  lhs[i][j][k][AA][1][3] = ((-tmp2) * fjac[i - 1][j][k][1][3]) - (tmp1 * njac[i - 1][j][k][1][3]);\n  lhs[i][j][k][AA][1][4] = ((-tmp2) * fjac[i - 1][j][k][1][4]) - (tmp1 * njac[i - 1][j][k][1][4]);\n  lhs[i][j][k][AA][2][0] = ((-tmp2) * fjac[i - 1][j][k][2][0]) - (tmp1 * njac[i - 1][j][k][2][0]);\n  lhs[i][j][k][AA][2][1] = ((-tmp2) * fjac[i - 1][j][k][2][1]) - (tmp1 * njac[i - 1][j][k][2][1]);\n  lhs[i][j][k][AA][2][2] = (((-tmp2) * fjac[i - 1][j][k][2][2]) - (tmp1 * njac[i - 1][j][k][2][2])) - (tmp1 * dx3);\n  lhs[i][j][k][AA][2][3] = ((-tmp2) * fjac[i - 1][j][k][2][3]) - (tmp1 * njac[i - 1][j][k][2][3]);\n  lhs[i][j][k][AA][2][4] = ((-tmp2) * fjac[i - 1][j][k][2][4]) - (tmp1 * njac[i - 1][j][k][2][4]);\n  lhs[i][j][k][AA][3][0] = ((-tmp2) * fjac[i - 1][j][k][3][0]) - (tmp1 * njac[i - 1][j][k][3][0]);\n  lhs[i][j][k][AA][3][1] = ((-tmp2) * fjac[i - 1][j][k][3][1]) - (tmp1 * njac[i - 1][j][k][3][1]);\n  lhs[i][j][k][AA][3][2] = ((-tmp2) * fjac[i - 1][j][k][3][2]) - (tmp1 * njac[i - 1][j][k][3][2]);\n  lhs[i][j][k][AA][3][3] = (((-tmp2) * fjac[i - 1][j][k][3][3]) - (tmp1 * njac[i - 1][j][k][3][3])) - (tmp1 * dx4);\n  lhs[i][j][k][AA][3][4] = ((-tmp2) * fjac[i - 1][j][k][3][4]) - (tmp1 * njac[i - 1][j][k][3][4]);\n  lhs[i][j][k][AA][4][0] = ((-tmp2) * fjac[i - 1][j][k][4][0]) - (tmp1 * njac[i - 1][j][k][4][0]);\n  lhs[i][j][k][AA][4][1] = ((-tmp2) * fjac[i - 1][j][k][4][1]) - (tmp1 * njac[i - 1][j][k][4][1]);\n  lhs[i][j][k][AA][4][2] = ((-tmp2) * fjac[i - 1][j][k][4][2]) - (tmp1 * njac[i - 1][j][k][4][2]);\n  lhs[i][j][k][AA][4][3] = ((-tmp2) * fjac[i - 1][j][k][4][3]) - (tmp1 * njac[i - 1][j][k][4][3]);\n  lhs[i][j][k][AA][4][4] = (((-tmp2) * fjac[i - 1][j][k][4][4]) - (tmp1 * njac[i - 1][j][k][4][4])) - (tmp1 * dx5);\n  lhs[i][j][k][BB][0][0] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][0][0])) + ((tmp1 * 2.0) * dx1);\n  lhs[i][j][k][BB][0][1] = (tmp1 * 2.0) * njac[i][j][k][0][1];\n  lhs[i][j][k][BB][0][2] = (tmp1 * 2.0) * njac[i][j][k][0][2];\n  lhs[i][j][k][BB][0][3] = (tmp1 * 2.0) * njac[i][j][k][0][3];\n  lhs[i][j][k][BB][0][4] = (tmp1 * 2.0) * njac[i][j][k][0][4];\n  lhs[i][j][k][BB][1][0] = (tmp1 * 2.0) * njac[i][j][k][1][0];\n  lhs[i][j][k][BB][1][1] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][1][1])) + ((tmp1 * 2.0) * dx2);\n  lhs[i][j][k][BB][1][2] = (tmp1 * 2.0) * njac[i][j][k][1][2];\n  lhs[i][j][k][BB][1][3] = (tmp1 * 2.0) * njac[i][j][k][1][3];\n  lhs[i][j][k][BB][1][4] = (tmp1 * 2.0) * njac[i][j][k][1][4];\n  lhs[i][j][k][BB][2][0] = (tmp1 * 2.0) * njac[i][j][k][2][0];\n  lhs[i][j][k][BB][2][1] = (tmp1 * 2.0) * njac[i][j][k][2][1];\n  lhs[i][j][k][BB][2][2] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][2][2])) + ((tmp1 * 2.0) * dx3);\n  lhs[i][j][k][BB][2][3] = (tmp1 * 2.0) * njac[i][j][k][2][3];\n  lhs[i][j][k][BB][2][4] = (tmp1 * 2.0) * njac[i][j][k][2][4];\n  lhs[i][j][k][BB][3][0] = (tmp1 * 2.0) * njac[i][j][k][3][0];\n  lhs[i][j][k][BB][3][1] = (tmp1 * 2.0) * njac[i][j][k][3][1];\n  lhs[i][j][k][BB][3][2] = (tmp1 * 2.0) * njac[i][j][k][3][2];\n  lhs[i][j][k][BB][3][3] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][3][3])) + ((tmp1 * 2.0) * dx4);\n  lhs[i][j][k][BB][3][4] = (tmp1 * 2.0) * njac[i][j][k][3][4];\n  lhs[i][j][k][BB][4][0] = (tmp1 * 2.0) * njac[i][j][k][4][0];\n  lhs[i][j][k][BB][4][1] = (tmp1 * 2.0) * njac[i][j][k][4][1];\n  lhs[i][j][k][BB][4][2] = (tmp1 * 2.0) * njac[i][j][k][4][2];\n  lhs[i][j][k][BB][4][3] = (tmp1 * 2.0) * njac[i][j][k][4][3];\n  lhs[i][j][k][BB][4][4] = (1.0 + ((tmp1 * 2.0) * njac[i][j][k][4][4])) + ((tmp1 * 2.0) * dx5);\n  lhs[i][j][k][CC][0][0] = ((tmp2 * fjac[i + 1][j][k][0][0]) - (tmp1 * njac[i + 1][j][k][0][0])) - (tmp1 * dx1);\n  lhs[i][j][k][CC][0][1] = (tmp2 * fjac[i + 1][j][k][0][1]) - (tmp1 * njac[i + 1][j][k][0][1]);\n  lhs[i][j][k][CC][0][2] = (tmp2 * fjac[i + 1][j][k][0][2]) - (tmp1 * njac[i + 1][j][k][0][2]);\n  lhs[i][j][k][CC][0][3] = (tmp2 * fjac[i + 1][j][k][0][3]) - (tmp1 * njac[i + 1][j][k][0][3]);\n  lhs[i][j][k][CC][0][4] = (tmp2 * fjac[i + 1][j][k][0][4]) - (tmp1 * njac[i + 1][j][k][0][4]);\n  lhs[i][j][k][CC][1][0] = (tmp2 * fjac[i + 1][j][k][1][0]) - (tmp1 * njac[i + 1][j][k][1][0]);\n  lhs[i][j][k][CC][1][1] = ((tmp2 * fjac[i + 1][j][k][1][1]) - (tmp1 * njac[i + 1][j][k][1][1])) - (tmp1 * dx2);\n  lhs[i][j][k][CC][1][2] = (tmp2 * fjac[i + 1][j][k][1][2]) - (tmp1 * njac[i + 1][j][k][1][2]);\n  lhs[i][j][k][CC][1][3] = (tmp2 * fjac[i + 1][j][k][1][3]) - (tmp1 * njac[i + 1][j][k][1][3]);\n  lhs[i][j][k][CC][1][4] = (tmp2 * fjac[i + 1][j][k][1][4]) - (tmp1 * njac[i + 1][j][k][1][4]);\n  lhs[i][j][k][CC][2][0] = (tmp2 * fjac[i + 1][j][k][2][0]) - (tmp1 * njac[i + 1][j][k][2][0]);\n  lhs[i][j][k][CC][2][1] = (tmp2 * fjac[i + 1][j][k][2][1]) - (tmp1 * njac[i + 1][j][k][2][1]);\n  lhs[i][j][k][CC][2][2] = ((tmp2 * fjac[i + 1][j][k][2][2]) - (tmp1 * njac[i + 1][j][k][2][2])) - (tmp1 * dx3);\n  lhs[i][j][k][CC][2][3] = (tmp2 * fjac[i + 1][j][k][2][3]) - (tmp1 * njac[i + 1][j][k][2][3]);\n  lhs[i][j][k][CC][2][4] = (tmp2 * fjac[i + 1][j][k][2][4]) - (tmp1 * njac[i + 1][j][k][2][4]);\n  lhs[i][j][k][CC][3][0] = (tmp2 * fjac[i + 1][j][k][3][0]) - (tmp1 * njac[i + 1][j][k][3][0]);\n  lhs[i][j][k][CC][3][1] = (tmp2 * fjac[i + 1][j][k][3][1]) - (tmp1 * njac[i + 1][j][k][3][1]);\n  lhs[i][j][k][CC][3][2] = (tmp2 * fjac[i + 1][j][k][3][2]) - (tmp1 * njac[i + 1][j][k][3][2]);\n  lhs[i][j][k][CC][3][3] = ((tmp2 * fjac[i + 1][j][k][3][3]) - (tmp1 * njac[i + 1][j][k][3][3])) - (tmp1 * dx4);\n  lhs[i][j][k][CC][3][4] = (tmp2 * fjac[i + 1][j][k][3][4]) - (tmp1 * njac[i + 1][j][k][3][4]);\n  lhs[i][j][k][CC][4][0] = (tmp2 * fjac[i + 1][j][k][4][0]) - (tmp1 * njac[i + 1][j][k][4][0]);\n  lhs[i][j][k][CC][4][1] = (tmp2 * fjac[i + 1][j][k][4][1]) - (tmp1 * njac[i + 1][j][k][4][1]);\n  lhs[i][j][k][CC][4][2] = (tmp2 * fjac[i + 1][j][k][4][2]) - (tmp1 * njac[i + 1][j][k][4][2]);\n  lhs[i][j][k][CC][4][3] = (tmp2 * fjac[i + 1][j][k][4][3]) - (tmp1 * njac[i + 1][j][k][4][3]);\n  lhs[i][j][k][CC][4][4] = ((tmp2 * fjac[i + 1][j][k][4][4]) - (tmp1 * njac[i + 1][j][k][4][4])) - (tmp1 * dx5);\n}\n\n", "pragma": "omp parallel for firstprivate(c2 ,c1 ,c3c4 ,con43 ,c1345 ,i ,k ,j ,tmp1 ,tmp2 ,tmp3 ) lastprivate(tmp1 ,tmp2 ,tmp3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/58"}
{"code": "for (search = 0; search < num_searchers; search++)\n{\n  int search_flag = 0;\n  int parent = search;\n  int follows_to = searchers[parent].follows;\n  while (!search_flag)\n  {\n    if (follows_to == parent)\n      search_flag = 1;\n    else\n    {\n      parent = follows_to;\n      follows_to = searchers[parent].follows;\n    }\n\n  }\n\n  searchers[search].follows = follows_to;\n}\n\n", "pragma": "omp for private(search)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/4"}
{"code": "for (c1 = nj; c1 <= (((((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) < (nm + (-1))) ? (((ni + (-1)) < (nk + (-1))) ? (ni + (-1)) : (nk + (-1))) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (((nj + (-1)) < (nl + (-1))) ? (nj + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = nl; c2 <= (nj + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  }\n\n  for (c2 = nj; c2 <= (((nk + (-1)) < (nl + (-1))) ? (nk + (-1)) : (nl + (-1))); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n  for (c2 = (nj > nl) ? (nj) : (nl); c2 <= (nk + (-1)); c2++)\n  {\n    A[c1][c2] = (((double) c1) * c2) / ni;\n  }\n\n  for (c2 = nk; c2 <= (nl + (-1)); c2++)\n  {\n    D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c1, c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/dataracebench/DRB041-3mm-parallel-no/4"}
{"code": "for (size_t i = 0; i < output_size; i++)\n  checksum += value[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/contract-omp/main/4"}
{"code": "for (i = 1; i < tamano; ++i)\n{\n  if (min > vector[i])\n  {\n    min = vector[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franBec/SDyP-OpenMP/p6/0"}
{"code": "for (int i = displs[p] + (counts[p] / 2); i < (displs[p] + counts[p]); i++)\n{\n  for (int j = 0; j < i; j++)\n  {\n    acc_bar(bodies, i, j, accX, accY);\n  }\n\n}\n\n", "pragma": "omp parallel for reduction(+:accX,accY)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nelorth/nbody/src/nbody/parallel/3"}
{"code": "for (int x = startthread[rank]; x < (endthread[rank] + 1); x++)\n{\n  MPI_Send(&user_matrix[x], k, MPI_INT, 0, rank, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Hari555Y/Parallel-Programming/HNSW_Google/A3_code/a3/11"}
{"code": "for (int i = 0; i < k; i++)\n{\n  data.insert(data.end(), bkt[0][i].begin(), bkt[0][i].end());\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/sampleSort/sort_sample/6"}
{"code": "for (p = 0; p < len; p++)\n{\n  int x = 1;\n  for (int t = p + 1; t < len; t++)\n    x *= base;\n\n  buffer[p] = (num / x) + '0';\n  num -= (buffer[p] - '0') * x;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/opencl/util/utility/0"}
{"code": "for (int y = 1; y < (context->WindowSize.Height - 1); ++y)\n{\n  for (int x = 1; x < (context->WindowSize.Width - 1); ++x)\n  {\n    int topLeftIndex = Get1DIndexFrom2D(x - 1, y + 1, context->WindowSize.Width - 1);\n    int topMidleIndex = Get1DIndexFrom2D(x, y + 1, context->WindowSize.Width - 1);\n    int topRighIndex = Get1DIndexFrom2D(x + 1, y + 1, context->WindowSize.Width - 1);\n    int midleLeftIndex = Get1DIndexFrom2D(x - 1, y, context->WindowSize.Width - 1);\n    int midleRightIndex = Get1DIndexFrom2D(x + 1, y, context->WindowSize.Width - 1);\n    int botLeftIndex = Get1DIndexFrom2D(x - 1, y - 1, context->WindowSize.Width - 1);\n    int botMidleIndex = Get1DIndexFrom2D(x, y - 1, context->WindowSize.Width - 1);\n    int botRightIndex = Get1DIndexFrom2D(x + 1, y - 1, context->WindowSize.Width - 1);\n    unsigned int aliveNeighbours = 0;\n    if (context->LastFrame[topLeftIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[topMidleIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[topRighIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[midleLeftIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[midleRightIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[botLeftIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[botMidleIndex] != 0)\n      ++aliveNeighbours;\n\n    if (context->LastFrame[botRightIndex] != 0)\n      ++aliveNeighbours;\n\n    const int currentPointIndex = Get1DIndexFrom2D(x, y, context->WindowSize.Width - 1);\n    if (aliveNeighbours == 3)\n    {\n      context->CurrentFrame[currentPointIndex] = 255;\n    }\n    else\n      if ((aliveNeighbours < 2) || (aliveNeighbours > 3))\n    {\n      context->CurrentFrame[currentPointIndex] = 0;\n    }\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rewlion/Concurrency/OpenMP-GameLife/source/Task2/main/1"}
{"code": "for (i = 0; i < simu_opts->numOE; i++)\n{\n  sprintf(OEIDname, \"%d\", simu_opts->OEID[i]);\n  strcat(configname, \"_\");\n  strcat(configname, OEIDname);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/8"}
{"code": "for (i = 0; i < m; i++)\n{\n  temp = x[i];\n  x[i] = y[i];\n  y[i] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamaradanceva/OpenMP-profiling-optimization-tool/openmp_algorithm/29"}
{"code": "for (j = 0; j < n; j++)\n{\n  b[j] = a[j];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/c_veccopy/omp_veccopy/0"}
{"code": "for (i = 0; i < 4; i++)\n{\n  err = clReleaseMemObject(cifar_buf[i]);\n  checkError(err, 397);\n  for (j = 0; j < num_rows[i]; j++)\n  {\n    err = clReleaseMemObject(img_buf[i][j]);\n    checkError(err, 400);\n    err = clReleaseMemObject(output[i][j]);\n    checkError(err, 402);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/D/photomosaic/11"}
{"code": "for (x = 1; x < nx; ++x)\n{\n  for (y = 1; y < ny; ++y)\n  {\n    sum = 0;\n    sum -= grid_current[((x - 1) * size_y) + y] / (hx * hx);\n    sum -= grid_current[((x + 1) * size_y) + y] / (hx * hx);\n    sum -= grid_current[(x * size_y) + (y - 1)] / (hy * hy);\n    sum -= grid_current[(x * size_y) + (y + 1)] / (hy * hy);\n    grid_next[(x * size_y) + y] = (f[(x * size_y) + y] - sum) / (((2 / (hx * hx)) + (2 / (hy * hy))) + (((2 * M_PI) * 2) * M_PI));\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bazk/rbgs/rbgs/1"}
{"code": "for (q = 0; q < 8; q++)\n{\n  for (r = 0; r < 40; r++)\n  {\n    for (n = 0; n < 313; n++)\n    {\n      for (m = 0; m < 173; m++)\n      {\n        for (l = 0; l < 5; l++)\n        {\n          for (k = 0; k < 5; k++)\n          {\n            y[(((r * 173) * 313) + (m * 313)) + n] += in_layer[((((q * 177) * 317) + ((m + k) * 317)) + n) + l] * weight[((((r * 8) + q) * 25) + (k * 5)) + l];\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-tavana/CNN_OPENMP/conv_layer4/7"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  while ((ch = fgetc(fpin)) != EOF)\n  {\n    fputc(ch, fpout);\n    if (ch == '\\n')\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zemi-B/OpenMP/src/main1/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  TempX[i] = F[i];\n  for (g = 0; g < N; g++)\n  {\n    if (i != g)\n      TempX[i] -= A[i][g] * X[g];\n\n  }\n\n  TempX[i] /= A[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nmatkheev/Jacobi_omp/main/4"}
{"code": "for (int i = 1; i < size; ++i)\n{\n  (cout << \", \") << arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CSalih/Parallel-Programming/Assignment4/Task3/Mergesort/3"}
{"code": "for (i = 0; i < nelem; i++)\n{\n  dmin = DBL_MAX;\n  for (j = 0; j < NGRUPOS; j++)\n  {\n    adis = gendist(elem[i], cent[j]);\n    if (adis < dmin)\n    {\n      dmin = adis;\n      ngrupo = j;\n    }\n\n  }\n\n  popul[i] = ngrupo;\n}\n\n", "pragma": "omp parallel for private(i, j, adis, dmin, ngrupo) schedule(dynamic,2) num_threads(32)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/fun_p/0"}
{"code": "for (i = 0; i < K; i++)\n{\n  sv[i].Key = Abs(d[i + 1]);\n  sv[i].Dat = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/84"}
{"code": "for (i = 0; i < (NumberOfProcecess - 1); i++)\n{\n  vetorQuantidades[i] = proporcao * orderOfMatrix;\n  vetorDisplacements[i] = (proporcao * orderOfMatrix) * i;\n  vetorQuantidadesB[i] = proporcao;\n  vetorDisplacementsB[i] = proporcao * i;\n}\n\n", "pragma": "omp parallel for private(i) num_threads(numberOfThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/jacobi-MPI-OpenMP/jacobi-mpi/0"}
{"code": "for (long window = M + 1; window <= N; window += M)\n{\n  memset(prime, true, M);\n  if (base != window)\n  {\n    base = window;\n    for (long k = 0; k < n_factor; k++)\n    {\n      striker[k] = ((((base + factor[k]) - 1) / factor[k]) * factor[k]) - base;\n    }\n\n  }\n\n  long limit = min((window + M) - 1, N) - base;\n  for (long k = 0; k < n_factor; k++)\n  {\n    striker[k] = mark_multiples(prime, striker[k], factor[k], limit) - M;\n  }\n\n  for (long p = 0; p <= limit; p++)\n  {\n    if (prime[p] == true)\n    {\n      count++;\n    }\n\n  }\n\n  base += M;\n}\n\n", "pragma": "        #pragma omp for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nowke/hpc_lab/4_parallel_sieve/parallel_sieve/5"}
{"code": "for (int i = 0; i < geom1->n_grid_r; i++)\n  for (int k = 0; k < geom1->n_grid_z; k++)\n  rho[i][k] = 0.;\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cosmonaut-ok/pdp3/src/chargeDensity/1"}
{"code": "for (i = 0; i < bestIndivsNo;)\n{\n  random = nextParticipantNo + (rand() % (individualsNo - nextParticipantNo));\n  if (!isInIntArray(group, bestIndivsNo, random))\n    group[i++] = random;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/16"}
{"code": "for (int j = last_recvs[rank]; j < mpi_recvs[rank].size(); j++)\n  if (mpi_recvs[rank][j].done == 1)\n  last_recvs[rank] = j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/4"}
{"code": "for (int i = 0; i < NB_WORDS; i++)\n{\n  int strSize = 1 + (rand() % STRING_MAX_SIZE);\n  array[i] = (char *) malloc(strSize * (sizeof(char)));\n  gen_random(array[i], strSize);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SaraKasim/TP_OpenMP/mapreduce-openmp/7"}
{"code": "for (int i = 0; i < 3; ++i)\n{\n  (KRATOS_ERROR_IF(mHighPoint[i] < mLowPoint[i]) << \"Check limits of the Bounding Box, minimum coordinates exceed maximum coordinates.\") << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DEMApplication/custom_utilities/create_and_destroy/8"}
{"code": "for (l = lt; l >= 1; l--)\n{\n  r[l] = (double ***) malloc(m3[l] * (sizeof(double **)));\n  for (k = 0; k < m3[l]; k++)\n  {\n    r[l][k] = (double **) malloc(m2[l] * (sizeof(double *)));\n    for (j = 0; j < m2[l]; j++)\n    {\n      r[l][k][j] = (double *) malloc(m1[l] * (sizeof(double)));\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/4"}
{"code": "for (int i = 0; i < x_points; i++)\n{\n  u_new[idx(0, i)] = 1.0;\n  v_new[idx(0, i)] = 1.0;\n  u_new[idx(y_points - 1, i)] = 1.0;\n  v_new[idx(y_points - 1, i)] = 1.0;\n}\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(256) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/burger-omp/main/4"}
{"code": "for (int j = 0; j < copys[n][nOfLayers - 1].nOfNeurons; j++)\n{\n  for (int i = 0; i < copys[n][nOfLayers - 1].nOfNeurons; i++)\n  {\n    if (i == j)\n    {\n      I = 1;\n    }\n    else\n    {\n      I = 0;\n    }\n\n    sum += ((target[i] / copys[n][nOfLayers - 1].neurons[i].out) * copys[n][nOfLayers - 1].neurons[j].out) * (I - copys[n][nOfLayers - 1].neurons[i].out);\n  }\n\n  copys[n][nOfLayers - 1].neurons[j].delta = -sum;\n  sum = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/13"}
{"code": "for (int j = 1; j < n; j++)\n{\n  for (int i = 1; i < n; i++)\n  {\n    int temp = checkNeighbours(x, i, j);\n    result[i][j] = temp;\n  }\n\n}\n\n", "pragma": "omp parallel for shared (n)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gokaytitrek/openmp-gameoflife/main/0"}
{"code": "for (t = 0; t < 10; t++)\n  ++t;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/1"}
{"code": "for (int i = 0; i < (w * h); ++i)\n{\n  img[i] = rgb_to_ycbcr(img[i][0], img[i][1], img[i][2]);\n  mx = max(mx, img[i][0]);\n  mn = min(mn, img[i][0]);\n}\n\n", "pragma": "#pragma omp parallel for \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sw1tcherrr/OpenMP-Luma-Normalizer/normalizer/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n  assert(pre[i] == test[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/scan/lab_scan_frag/scan_frag/6"}
{"code": "for (int i = 0; i < size; i++)\n{\n  x[i] = 1.0;\n  y[i] = 2.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/allgebra/examples/clang_omp_offloading/omp_offloading/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  calculated[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bupingxx/Parallel-linear-equations-solver/src/gauss2/4"}
{"code": "for (size_t i = 0; i < arguments.iterations; i++)\n{\n  mean += nanos[i];\n  cpu_time_mean += cpu_clocks[i];\n  if (arguments.verbose && (!arguments.silent))\n  {\n    printf(\"real time per iteration = %ld sec %ld nsec \\t cpu_time = %lf\\n\", t_times[i].tv_sec, t_times[i].tv_nsec, cpu_clocks[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-programming-hwr/benchmark-openMP/main/3"}
{"code": "for (i = 0; i < size; i++)\n{\n  l[i][i] = 1;\n  for (j = 0; j < size; j++)\n  {\n    a_p[i][j] = a[i][j];\n    if (i != j)\n      l[i][j] = 0;\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for   ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HexRebuilt/ACA_matrix-optimization/code/inverse/7"}
{"code": "for (i = 0; i < (*h); i++)\n{\n  for (j = 0; j < (*w); j++)\n  {\n    if (j == ((*w) - 1))\n      fprintf(f, \"%hhu %hhu %hhu\\n\", rgb[(i * (*w)) + j].red, rgb[(i * (*w)) + j].green, rgb[(i * (*w)) + j].blue);\n    else\n      fprintf(f, \"%hhu %hhu %hhu\\t\", rgb[(i * (*w)) + j].red, rgb[(i * (*w)) + j].green, rgb[(i * (*w)) + j].blue);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wutaosamuel/mosaic_OpenMP-CUDA/src/mosaic/6"}
{"code": "for (i = 0; i < ((int) (*n_theta_j)); i++)\n{\n  strcpy(copied_str, value);\n  (*frm2)[i] = strtol(copied_str, buf2, 10) + (*frm0)[i];\n  value = strtok_r(0, \" \", &context);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/Src/mcrat_io/5"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValue = 0;\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = qBlue(srcImage->pixel(jj + j, ii + i));\n        pixelValue += weight[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    if (pixelValue > 255)\n      pixelValue = 255;\n\n    if (pixelValue < 0)\n      pixelValue = 0;\n\n    dstImage->setPixel(jj, ii, QColor(pixelValue, pixelValue, pixelValue).rgba());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/sobel/sobel1/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%d \", a[i]);\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ponsheng/OpenMPRewriter/test/offload_array/3"}
{"code": "for (int i = 0; i < nr; i++)\n{\n  for (int j = 0; j < nc; j++)\n  {\n    B(i, j) = remainder(A(i, j), bsize);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/6"}
{"code": "for (int i = 2; i < 15; i++)\n{\n  if (first_it)\n  {\n    while (1)\n    {\n      if (id == check)\n      {\n        omp_set_lock(&simple_lock);\n        if (first_it == 2)\n        {\n          buff3 = a[i - 2];\n          buff2 = a[i - 1];\n          buff1 = a[i];\n          a[i] = ((buff3 * buff2) * buff1) / 3;\n          first_it--;\n        }\n        else\n        {\n          buff3 = buff2;\n          buff2 = buff1;\n          buff1 = a[i];\n          a[i] = ((buff3 * buff2) * buff1) / 3;\n          first_it--;\n        }\n\n        if (check != 0)\n        {\n          check--;\n        }\n        else\n        {\n          check = num_of_p - 1;\n        }\n\n        omp_unset_lock(&simple_lock);\n        break;\n      }\n\n    }\n\n  }\n  else\n  {\n    buff3 = buff2;\n    buff2 = buff1;\n    buff1 = a[i];\n    a[i] = ((buff3 * buff2) * buff1) / 3;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilkoch008/OpenMP_tasks/task3/main/0"}
{"code": "for (int j = 1; j < max_cols; j++)\n{\n  input_itemsets_seq[j] = (-j) * penalty;\n  input_itemsets_par[j] = (-j) * penalty;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DusanKrdzic/MUPS/OpenMP/nw/7"}
{"code": "for (i = 0; i < m; i++)\n  printf(\"%4.1f \", y[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_mat_vect/5"}
{"code": "for (int i = 0; i < wym; i++)\n{\n  for (int j = 0; j < row_per_proc; j++)\n  {\n    pizzaslice[i][j] = smallslice[i + (j * wym)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aenyewedien/GameOfLife/game/1"}
{"code": "for (i = 0; i < NX; i++)\n{\n  sum += vecA[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(shared) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/hybrid/race-condition/solution/sum/1"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n    printf(\"%6.2f   \", c[i][j]);\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/karan9360/openmp_matrix/Assignment3 /Parallel/parallel/1"}
{"code": "for (int i = 3; i <= sqr; i += 2)\n{\n  if ((x % i) == 0)\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/labs/Lab6/Software/OpenMP/next_prime/1"}
{"code": "for (i = 0; i < (num_particles - 1); i++)\n{\n  fprintf(f, \"%d,%d\\t\", box.person[i].x_pos, box.person[i].y_pos);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/blessedchitamba/biomolecular_simulation/mpi_particle/1"}
{"code": "for (unsigned int i = 0; i < node_no; ++i)\n{\n  float *node = mappedNodes + (i * dimension_no);\n  float *fv = forceVectors + (i * dimension_no);\n  for (unsigned k = 0; k < dimension_no; ++k)\n    node[k] += move_factor * fv[k];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmjakt/R-SOD/src/sod/DistanceMapper/6"}
{"code": "for (i = 0; i < steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPComputePI/Ex4ComputePI/0"}
{"code": "for (int i = 0; i < elements; i++)\n{\n  backward(i, start, step, y, alpha, beta, gamma, F);\n}\n\n", "pragma": "omp parallel for num_threads(threads) shared(alpha, beta, gamma, F, elements, start, step, y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/cyclic_reduction/main/4"}
{"code": "for (int itr = 0; itr < num_itrs; itr++)\n{\n  for (int i = 1; i < y_points; i++)\n  {\n    for (int j = 1; j < x_points; j++)\n    {\n      u_new[i][j] = (u[i][j] - ((u[i][j] * (del_t / del_x)) * (u[i][j] - u[i][j - 1]))) - ((v[i][j] * (del_t / del_x)) * (u[i][j] - u[i - 1][j]));\n      v_new[i][j] = (v[i][j] - ((u[i][j] * (del_t / del_x)) * (v[i][j] - v[i][j - 1]))) - ((v[i][j] * (del_t / del_x)) * (v[i][j] - v[i - 1][j]));\n    }\n\n  }\n\n  for (int i = 0; i < x_points; i++)\n  {\n    u_new[0][i] = 1.0;\n    v_new[0][i] = 1.0;\n    u_new[x_points - 1][i] = 1.0;\n    v_new[x_points - 1][i] = 1.0;\n  }\n\n  for (int j = 0; j < y_points; j++)\n  {\n    u_new[j][0] = 1.0;\n    v_new[j][0] = 1.0;\n    u_new[j][y_points - 1] = 1.0;\n    v_new[j][y_points - 1] = 1.0;\n  }\n\n  for (int i = 0; i < y_points; i++)\n  {\n    for (int j = 0; j < x_points; j++)\n    {\n      u[i][j] = u_new[i][j];\n      v[i][j] = v_new[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soumyasen1809/OpenMP_C_12_steps_to_Navier_Stokes/2-D NonLinear Convection/2D_NonLinear_Convection/main/1"}
{"code": "for (int i = 0; i < numbers; ++i)\n{\n  float rand_x = get_random_number(a, b);\n  float rand_y = get_random_number(a, b);\n  float distance = sqrt((((double) (rand_x - 0.0)) * (rand_x - 0.0)) + ((rand_y - 0.0) * (rand_y - 0.0)));\n  if (distance < radius)\n  {\n    counter += 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vasi1796/parallel_processing_lab/monte_carlo_pi/src/main/0"}
{"code": "for (int i = 0; (i < S) && ((start + i) <= n); i++)\n{\n  if (block[i])\n    result++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amanikiruga/parallelized-prime-sieve/src/segmented_eratosthenes_openmp/0"}
{"code": "for (int i = 0; i < nb.nodes; ++i)\n{\n  graph[i].shrink_to_fit();\n  int deg = ((int) graph[i].size()) - 1;\n  deg_max_local = max(deg, deg_max_local);\n  deg_sum_local += deg;\n}\n\n", "pragma": "#pragma omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/rmat/1"}
{"code": "for (i = 5; i <= sqr_lim; i++)\n{\n  if (is_prime[i])\n  {\n    n = i * i;\n    for (j = n; j <= limit; j += n)\n    {\n      is_prime[j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OlegShatin/openmp-homework/15/main/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n    if (b[i][j] != (i + 3))\n    abort();\n\n\n  if (a[i] != (i + 3))\n    abort();\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr39154/7"}
{"code": "for (int i = 2; i <= 16; i *= 2)\n{\n  ((cout << \"Number threads: \") << i) << endl;\n  start_time = omp_get_wtime();\n  result = integral(a, b, N, true, i);\n  time = omp_get_wtime() - start_time;\n  ((cout << \"result with omp: \") << result) << endl;\n  ((cout << \"time: \") << time) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/integral/2"}
{"code": "for (i = 0; i < simu_opts->num_stability; i++)\n{\n  printf(\"%d -- %d\\n\", i + 1, maintmprlt->cnt_store[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/51"}
{"code": "for (j = 0; j < n; j++)\n{\n  pts.emplace_back(dim_all[j], j);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/8"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  for (int j = 0; j < 5; j++)\n  {\n    printf(\"Enter element %d of second matrix:\", k);\n    scanf(\"%d\", &b[i][j]);\n    k++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/flush1/4"}
{"code": "for (int i = 0; i < n; i++)\n  sum += array[i];\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kfu218/OpenMP/theme 2/ex6/0"}
{"code": "for (int j = 0; j < numRows; j++)\n{\n  for (int i = 0; i < numCols; i++)\n  {\n    float amb_temp = 80.0;\n    int c = i + (j * numCols);\n    int xy = numCols * numRows;\n    int W = (i == 0) ? (c) : (c - 1);\n    int E = (i == (numCols - 1)) ? (c) : (c + 1);\n    int N = (j == 0) ? (c) : (c - numCols);\n    int S = (j == (numRows - 1)) ? (c) : (c + numCols);\n    float temp1;\n    float temp2;\n    float temp3;\n    temp1 = (temp2 = tIn[c]);\n    temp3 = tIn[c + xy];\n    tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n    c += xy;\n    W += xy;\n    E += xy;\n    N += xy;\n    S += xy;\n    for (int k = 1; k < (layers - 1); ++k)\n    {\n      temp1 = temp2;\n      temp2 = temp3;\n      temp3 = tIn[c + xy];\n      tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n      c += xy;\n      W += xy;\n      E += xy;\n      N += xy;\n      S += xy;\n    }\n\n    temp1 = temp2;\n    temp2 = temp3;\n    tOut[c] = ((((((((cc * temp2) + (cw * tIn[W])) + (ce * tIn[E])) + (cs * tIn[S])) + (cn * tIn[N])) + (cb * temp1)) + (ct * temp3)) + (stepDivCap * pIn[c])) + (ct * amb_temp);\n  }\n\n}\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hotspot3D-omp/3D/0"}
{"code": "for (i = 0; i < Xs->dim; i++)\n  v_set_val(XY, i, v_get_val(Xs, i) * v_get_val(Ys, i));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/find_ellipse/27"}
{"code": "for (i = 1; i < n; i++)\n  ImgDst[i] = ImgDst[i - 1] + m;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical1/imagenes/6"}
{"code": "for (int i = 0; i < kRows; i++)\n{\n  kernel[i] = (int *) malloc(kCols * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/putlurusurya/ImageProcessingUsingOpenmpMpi/codes/Operation on Arrays/convolution2D/omp/2"}
{"code": "for (int i = 0; i < mat_size; i++)\n{\n  for (int j = 0; j < mat_size; j++)\n  {\n    fprintf(file, \"%d \", P_mat[i][j]);\n  }\n\n  fprintf(file, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp_latest/1"}
{"code": "for (int k = 0; k < NUMOUT; k++)\n{\n  SumO = 0.0;\n  for (int j = 0; j < NUMHID; j++)\n    SumO += Hidden[p][j] * WeightHO[k][j];\n\n  Output[p][k] = 1.0 / (1.0 + exp(-SumO));\n  Error += (0.5 * (Target[p][k] - Output[p][k])) * (Target[p][k] - Output[p][k]);\n  DeltaO[k] = ((Target[p][k] - Output[p][k]) * Output[p][k]) * (1.0 - Output[p][k]);\n}\n\n", "pragma": "omp for private(SumO) reduction(+:Error)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dsoldevila/CAP/OpenMP/nn-vo/1"}
{"code": "for (unsigned int i = 0; i < input.length(); i++)\n{\n  if (((input[i] == 'o') || (input[i] == 'b')) || (input[i] == '$'))\n  {\n    token = input.substr(beginToken, (i - beginToken) + 1);\n    tokens.push_back(token);\n    beginToken = i + 1;\n  }\n  else\n    if (input[i] == '\\n')\n  {\n    beginToken = i + 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nils-wisiol/gameoflife-openmp/src/gameoflife-openmp-stitch/0"}
{"code": "for (i = 0; i < 10000; i++)\n  a[i] = (b[i] = i * 1.0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sc3260s18/openmp/parallel-for/for-loop/1"}
{"code": "for (unsigned i = 0; i < nvert; i++)\n  err += fabs(pagerank[i] - last[i]);\n\n", "pragma": "        #pragma omp parallel for reduction(+:err)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmitrime/pagerank-omp/pagerank/6"}
{"code": "for (int iv = 0; iv < NUMNODES; iv++)\n{\n  for (int iu = 0; iu < NUMNODES; iu++)\n  {\n    float z = Height(iu, iv);\n    if (iv == 0)\n    {\n      if ((iu == 0) || (iu == (NUMNODES - 1)))\n        volume += z * quarterTileArea;\n      else\n        volume += z * halfTileArea;\n\n    }\n    else\n      if (iu == 0)\n    {\n      if ((iv == 0) || (iv == (NUMNODES - 1)))\n        volume += z * quarterTileArea;\n      else\n        volume += z * halfTileArea;\n\n    }\n    else\n      volume += z * fullTileArea;\n\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for collapse(2) default(none), shared(fullTileArea, halfTileArea, quarterTileArea), reduction(+:volume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vrastello/Parallel-Programming/proj2_rastellv/project2/0"}
{"code": "for (i = 0; i < N; i++)\n  b[i] = i;\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/examples/tools/ompt/veccopy-ompt-target-tracing/veccopy-ompt-target-tracing/1"}
{"code": "for (i = 0, x = 1; i < Size; ++i, ++x)\n{\n  k = 0;\n  for (j = 0; j < Size; ++j)\n  {\n    n = puzzle[(j * Size) + i];\n    if ((((n == x) || (n == (x + Size))) || (n == (x + (Size * 2)))) || (n == (x + (Size * 3))))\n    {\n      temp[k++] = n;\n    }\n\n  }\n\n  md = GetDistance(temp, md, k);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohadesehjm/Multicore-Npuzzle/15p/6"}
{"code": "for (i = 0; i < array_length; i++)\n{\n  if (((((*(r + i)) > (r_inj - (C_LIGHT / fps))) && ((*(r + i)) < (r_inj + (C_LIGHT / fps)))) && ((*(theta + i)) < theta_max)) && ((*(theta + i)) > theta_min))\n  {\n    ph_dens_calc = ((((((num_dens_coeff * 2.0) * M_PI) * (*(x + i))) * pow(*(temps + i), 3.0)) * pow(*(szx + i), 2.0)) / ph_weight_adjusted) * pow(pow(1.0 - (pow(*(vx + i), 2) + pow(*(vy + i), 2)), 0.5), -1);\n    *(ph_dens + j) = gsl_ran_poisson(rand, ph_dens_calc);\n    ph_tot += *(ph_dens + j);\n    j++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/mclib/8"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  assign_points_to_centers(centers, data, assignments, args);\n  recompute_centers(centers, data, assignments);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par3/1"}
{"code": "for (int iter = 0; iter < 1000; iter++)\n{\n  temp = ((z.r * z.r) - (z.i * z.i)) + c.r;\n  z.i = ((z.r * z.i) * 2) + c.i;\n  z.r = temp;\n  if (((z.r * z.r) + (z.i * z.i)) > 4.0)\n  {\n    num++;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Adaickalavan/OpenMP-Tim-Mattson/apps/mandel/1"}
{"code": "for (i = 0; i < datasize; i++)\n  y[i][data[i][0]] = 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/20"}
{"code": "for (i = 0; i < 100; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name print#0#0\n  for (j = 0; j < 100; j++)\n  {\n    printf(\"%lf\\n\", a[i][j]);\n  }\n\n  printf(\"%lf\\n\", v_out[i]);\n  printf(\"%lf\\n\", v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB061-matrixvector1-orig-no/4"}
{"code": "for (int iter = 0; iter < niter; iter++)\n{\n  double den = 0.0;\n  for (int i = 0; i < size; i++)\n  {\n    double dot_mat_vec = 0;\n    double dot_vec_mat = 0;\n    for (int j = 0; j < size; j++)\n    {\n      dot_mat_vec += Ainv_GJ[i][j] * u[j];\n      dot_vec_mat += Ainv_GJ[j][i] * v[j];\n    }\n\n    result_mat_vec[i] = dot_mat_vec;\n    result_vec_mat[i] = dot_vec_mat;\n    den += dot_vec_mat * u[i];\n  }\n\n  for (int k = 0; k < size; k++)\n    for (int l = 0; l < size; l++)\n    Ainv_GJ[k][l] - ((result_mat_vec[k] * result_vec_mat[l]) / (1 + den));\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/11"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n  {\n    a[i][j] = 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fmorenovr/ComputerScience_UCSP/MCC103-Computacion_Paralela_y_Distribuida/Labo_1_Convolution/cpu_parallel_convolution/0"}
{"code": "for (i = 1; i < sh->inum; i++)\n{\n  fprintf(fpkernel, \", int dac_i%d\", i);\n  fprintf(fpdacrt, \", int\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wusspsj/dacc/pass2omp/0"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  dists[tid] += abs(arr[i] - centers[tid]);\n}\n\n", "pragma": "        #pragma omp for reduction(+:dists[tid])", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sand47/ME759-CUDA-Assignments/HW09/cluster/0"}
{"code": "for (int iA = 1; iA < (matrixA->nb_rows + 1); iA++)\n{\n  for (int jB = 1; jB < (matrixB->nb_cols + 1); jB++)\n  {\n    int sum = 0;\n    for (int iter = 1; iter < (matrixA->nb_cols + 1); iter++)\n    {\n      sum = sum + getElemFromMatrix(iA, iter, matrixA), getElemFromMatrix(iter, jB, matrixB);\n    }\n\n    setElemToMatrix(iA, jB, matrixResult, sum);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/walayd/matrix_computation_openmp/larabi/8"}
{"code": "for (int j = 0; j < size; j++)\n{\n  for (int jj = j + 1; jj < size; jj++)\n  {\n    if (output[j] > output[jj])\n    {\n      printf(\"Fail to schedule in order.\\n\");\n      free(output);\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/schedule/schedule/2"}
{"code": "for (i = 0; i < dim; i++)\n{\n  b += d[i] * g[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mazury/Parallel-Programming-C-Project/conjugate-gradient-openmp/6"}
{"code": "for (j = 1; j < (grid_points[1] - 1); j++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/87"}
{"code": "for (i = 0; i < nThreads; i++)\n{\n  for (j = i * patronesPorHilo; j < ((i * patronesPorHilo) + patronesPorHilo); j++)\n  {\n    performEpoch(trainDataset->inputs[j], trainDataset->outputs[j], i);\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/refastron20/Redes-Neuronales-OPENMP/la2/MultilayerPerceptron/25"}
{"code": "for (size_t i = 0; i < len; i++)\n  vec_ptr[i] = vec_ptr[i] * omp_get_team_num();\n\n", "pragma": "  #pragma omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Platforms/OMPTarget/map_structure/1"}
{"code": "for (int i = data_start; i < data_end; i++)\n{\n  center_counts[assignments[i]]++;\n  for (int j = 0; j < ((int) centers[assignments[i]].size()); j++)\n  {\n    centers[assignments[i]][j] += data[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_parakmeans/1"}
{"code": "for (int i = 0; i < this->max_iter; i++)\n{\n  for (int c = 0; c < points.size(); c++)\n  {\n    Point newPoint = updatePoint(copied_points[c], points);\n    copied_points[c] = newPoint;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/francidellungo/Mean_Shift/MeanShift/2"}
{"code": "for (i = 0; i < n; i++)\n  c[i] = a[i] + b[i];\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/compparalela/openmp/omp8/if/0"}
{"code": "for (size_t i = 0; i < n_basis; ++i)\n{\n  for (size_t j = 0; j < n_basis; ++j)\n  {\n    for (size_t k = 0; k < n_basis; ++k)\n    {\n      for (size_t l = 0; l < n_basis; ++l)\n      {\n        G[(i * n_basis) + j] += P[(k * n_basis) + l] * two_elec_int_in_mem(i, j, k, l);\n        G[(i * n_basis) + j] -= (0.5 * P[(k * n_basis) + l]) * two_elec_int_in_mem(i, k, j, l);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philljj/ghf/src/g_matrix/1"}
{"code": "for (j = 3 * 1; j <= ((grid_points[1] - (3 * 1)) - 1); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * ((((u[m][i][j - 2][k] - (4.0 * u[m][i][j - 1][k])) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j + 1][k])) + u[m][i][j + 2][k]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i ,j ,k ,dssp ,m )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/123"}
{"code": "for (size_t i = 0; i < n_basis; ++i)\n{\n  for (size_t j = 0; j < n_basis; ++j)\n  {\n    for (size_t k = 0; k < n_basis; ++k)\n    {\n      for (size_t l = 0; l < n_basis; ++l)\n      {\n        G[(i * n_basis) + j] += P[(k * n_basis) + l] * two_elec_int(i, j, k, l);\n        G[(i * n_basis) + j] -= (0.5 * P[(k * n_basis) + l]) * two_elec_int(i, k, j, l);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/philljj/ghf/src/g_matrix/2"}
{"code": "for (i = 0; i < nr_points; i++)\n{\n  closest_centroid = 0;\n  d_min = distance(&dataset[i * nr_dimensions], &centroids[0], nr_dimensions);\n  for (j = 1; j < nr_centroids; j++)\n  {\n    d_temp = distance(&dataset[i * nr_dimensions], &centroids[j * nr_dimensions], nr_dimensions);\n    if (d_temp < d_min)\n    {\n      closest_centroid = j;\n      d_min = d_temp;\n    }\n\n  }\n\n  points_accumulator_thread[closest_centroid]++;\n  for (j = 0; j < nr_dimensions; j++)\n  {\n    coordinates_accumulator_thread[(closest_centroid * nr_dimensions) + j] += dataset[(i * nr_dimensions) + j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(nr_threads) schedule(static) reduction(+: points_accumulator_thread[:nr_centroids], coordinates_accumulator_thread[:nr_centroids*nr_dimensions]) private(d_min, d_temp, closest_centroid, j, i) shared(dataset, centroids, nr_points, nr_centroids, nr_dimensions)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/15"}
{"code": "for (int i = 0; i < NNZ; i++)\n{\n  (cout << val[i]) << \"\\t\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/torbjoernk/openMP-Examples/matxvec_sparse/matxvec_sparse/3"}
{"code": "for (int j = 1; j <= n; j++)\n{\n  for (int k = 1; k <= (n / 2); k++)\n  {\n    if ((((int) pow(2, k)) % ((int) pow(2, L))) == 0)\n    {\n      c[i][j][2 * k] = c[i][j][2 * k] + c[i][j][(2 * k) - ((int) pow(2, L - 1))];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/MatricesCREW/4"}
{"code": "for (i = 0; i < numOfCenters; i++)\n{\n  for (j = i + 1; j < numOfCenters; j++)\n  {\n    sum += (diameters[i] + diameters[j]) / difference(&allCenters[i], &allCenters[j]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for  private(j) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/roiedanino/K-Means-Parallel-Implementation/kMeansRoieDanino/Kmeans_Parallel/1"}
{"code": "for (v = 0; v < V; v++)\n{\n  if ((((!sptSet[v]) && graph[u][v]) && (dist[u] != INT_MAX)) && ((dist[u] + graph[u][v]) < dist[v]))\n    dist[v] = dist[u] + graph[u][v];\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for private(v) shared(dist, sptSet, graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SaiKarthik2000/OpenMP-Parallelization-of-Dynamic-Programming-and-Greedy-Algorithms/dijkstra-path/dijkstras-parallel/1"}
{"code": "for (int64_t i = c + 1; i <= a; i++)\n  sum += (cache.phi < (-1)) > ((x / primes[i], i - 1));\n\n", "pragma": "    #pragma omp for nowait schedule(dynamic, 16)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primecount/src/phi/2"}
{"code": "for (int i = 0; i < ParticleCount; i++)\n{\n  srand(clock());\n  X[i].x = minXValue + (rand() % ((maxXValue - minXValue) + 1));\n  X[i].y = minXValue + (rand() % ((maxXValue - minXValue) + 1));\n  V[i].x = minVValue + (rand() % ((maxVValue - minVValue) + 1));\n  V[i].y = minVValue + (rand() % ((maxVValue - minVValue) + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmreLks/Particle-Swarm-Optimization/Pso_Parallel/3"}
{"code": "for (unsigned i = OMPC_PROC_BIND_unknown + 1; i < NUM_OPENMP_PROC_BIND_KINDS; ++i)\n{\n  Values += \"'\";\n  Values += getOpenMPSimpleClauseTypeName(OMPC_proc_bind, i);\n  Values += \"'\";\n  switch (i)\n  {\n    case NUM_OPENMP_PROC_BIND_KINDS - 2:\n      Values += \" or \";\n      break;\n\n    case NUM_OPENMP_PROC_BIND_KINDS - 1:\n      break;\n\n    default:\n      Values += Sep;\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/Sema/SemaOpenMP/8"}
{"code": "for (i = 0; i < 214700000; i++)\n{\n  int threadid = omp_get_thread_num();\n  if (x[i] > mval[threadid])\n  {\n    mval[threadid] = x[i];\n    mloc[threadid] = i;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndreJSON/hpc/lab1/maxloc_false_sharing/0"}
{"code": "for (i = 0; i < 47; i++)\n{\n  free(matrix[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/31"}
{"code": "for (k = 0; k < 10; k++)\n  printf(\"%9d\", histo[k]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/16"}
{"code": "for (int r = lr - 1, c = lc + 1; ((r >= 0) && (c < 7)) && (this->board[lr][lc] == player); --r, ++c)\n{\n  down++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_board/8"}
{"code": "for (i = 1; i < 16000000; i++)\n{\n  data[i] = data[i] + (i * 1.0);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/array/par_array/1"}
{"code": "for (int i = 0; i < chromo_length; i++)\n  printf(\"%d_\", ptr_chromosome->genes[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/6"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (!strcmp(\"-help\", argv[i]))\n  {\n    write_usage(argv[0]);\n    exit(0);\n  }\n  else\n    if ((!strcmp(\"-threads\", argv[i])) && ((++i) < argc))\n  {\n    N = atoi(argv[i]);\n  }\n  else\n    if ((!strcmp(\"-ichunk\", argv[i])) && ((++i) < argc))\n  {\n    ichunk = atoi(argv[i]);\n  }\n  else\n    if ((!strcmp(\"-jchunk\", argv[i])) && ((++i) < argc))\n  {\n    jchunk = atoi(argv[i]);\n  }\n  else\n    if ((!strcmp(\"-inp\", argv[i])) && ((++i) < argc))\n  {\n    inp = argv[i];\n  }\n  else\n    if ((!strcmp(\"-res\", argv[i])) && ((++i) < argc))\n  {\n    res = argv[i];\n  }\n  else\n  {\n    fprintf(stdout, \"Unrecognized argument \\\"%s\\\"\\n\", argv[i]);\n    write_usage(argv[0]);\n    return -1;\n  }\n\n\n\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ilyankou/heat-conduction-solver/stencil/2"}
{"code": "for (j = 0; j <= (ny + 1); j++)\n{\n  for (i = 0; i <= (nx + 1); i++)\n  {\n    sum_err += Uerror[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoux85/ADI-OpenMP-example/Numerical Tests on Simple Systems/No OpenMP Version/baseline00/5"}
{"code": "for (psum = 0, vi = viend - 1; vi >= vistart; vi--)\n{\n  if ((psum += nxadj[vi + 1] - nxadj[vi]) >= chunksize)\n  {\n    chunkptr[--nchunks] = vi;\n    psum = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/13"}
{"code": "for (i = 0; i < n; i++)\n{\n  rng = uni();\n  if (rng < density)\n  {\n    road[i] = 1;\n  }\n  else\n  {\n    road[i] = 0;\n  }\n\n  ncar += road[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bbw7561135/OpenMP-Workshop/traffic/trafficlib/1"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-r\") == 0)\n    ref = strtof(argv[i + 1], 0);\n  else\n    if (strcmp(argv[i], \"-v\") == 0)\n    verbose = 1;\n  else\n    if (strcmp(argv[i], \"-t\") == 0)\n    tol = strtof(argv[i + 1], 0);\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hailuy/os_week10/findvals/0"}
{"code": "for (search = 0; search < num_searchers; search++)\n{\n  searchers[search].follows = trails[(((int) searchers[search].pos_row) * columns) + ((int) searchers[search].pos_col)];\n}\n\n", "pragma": "omp for private(search)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jhoncabanilla/Pr-ctica-OpenMP/src/mejor/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  x = a;\n  x += h * (i + 0.5);\n  s += f(x);\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:x,s)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PawelMlyniec/Parallel_programming_UPV/practical1/integral/1"}
{"code": "for (int p = 0; p < m; p++)\n{\n  int butterflyOffset = 1 << (p + 1);\n  int butterflySize = butterflyOffset >> 1;\n  double alpha = ((-2.0) * PI) / butterflyOffset;\n  double wR = cos(alpha);\n  double wI = sin(alpha);\n  for (int i = 0; i < (size / butterflyOffset); i++)\n  {\n    double uR = 1.0;\n    double uI = 0.0;\n    double uRtmp;\n    int offset = i * butterflyOffset;\n    for (int j = 0; j < butterflySize; j++)\n    {\n      double temR = (_mas[(2 * ((j + offset) + butterflySize)) * step] * uR) - (_mas[((2 * ((j + offset) + butterflySize)) * step) + 1] * uI);\n      double temI = (_mas[(2 * ((j + offset) + butterflySize)) * step] * uI) + (_mas[((2 * ((j + offset) + butterflySize)) * step) + 1] * uR);\n      _mas[(2 * ((j + offset) + butterflySize)) * step] = _mas[(2 * (j + offset)) * step] - temR;\n      _mas[((2 * ((j + offset) + butterflySize)) * step) + 1] = _mas[((2 * (j + offset)) * step) + 1] - temI;\n      _mas[(2 * (j + offset)) * step] += temR;\n      _mas[((2 * (j + offset)) * step) + 1] += temI;\n      uRtmp = uR;\n      uR = (uR * wR) - (uI * wI);\n      uI = (uI * wR) + (uRtmp * wI);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/12. filter (effective parallel)/fft/0"}
{"code": "for (int i = srow; i < (lrow + 1); i++)\n{\n  for (int j = scol; j < (lcol + 1); j++)\n  {\n    float val = 0;\n    float bval = 0;\n    float gval = 0;\n    int x = 0;\n    for (int k = i - 1; k <= (i + 1); k++)\n    {\n      int y = 0;\n      for (int l = (bytes * j) - bytes; l <= ((bytes * j) + bytes); l += bytes)\n      {\n        val += t0[((bytes * (cols + 2)) * k) + l] * h[x][y];\n        if (bytes == 3)\n        {\n          gval += t0[(((bytes * (cols + 2)) * k) + l) + 1] * h[x][y];\n          bval += t0[(((bytes * (cols + 2)) * k) + l) + 2] * h[x][y];\n        }\n\n        y++;\n      }\n\n      x++;\n    }\n\n    (*t1)[((bytes * (cols + 2)) * i) + (bytes * j)] = val;\n    if ((flag && (!check)) && 0)\n      check = check_similarity(t0, t1, ((bytes * (cols + 2)) * i) + (bytes * j));\n\n    if (bytes == 3)\n    {\n      (*t1)[(((bytes * (cols + 2)) * i) + (bytes * j)) + 1] = gval;\n      (*t1)[(((bytes * (cols + 2)) * i) + (bytes * j)) + 2] = bval;\n      if ((flag && (!check)) && 0)\n      {\n        check = check_similarity(t0, t1, (((bytes * (cols + 2)) * i) + (bytes * j)) + 1);\n        check = check_similarity(t0, t1, (((bytes * (cols + 2)) * i) + (bytes * j)) + 2);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(1) collapse(2) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NickLekkas01/img-convolution/src/imgconv/0"}
{"code": "for (unsigned int i = 0; i < (280 * 30); ++i)\n{\n  m_date.push_back(i);\n  m_open.push_back(f);\n  m_high.push_back(f);\n  m_low.push_back(f);\n  m_close.push_back(f);\n  f++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miroslavkrajcir/OpenMP/OpenMP/OpenMP/0"}
{"code": "for (int i = 0; i < numMutar; i++)\n{\n  int index = aleatorio(num_pixels - 1);\n  actual->imagen[index].r = aleatorio(max);\n  actual->imagen[index].g = aleatorio(max);\n  actual->imagen[index].b = aleatorio(max);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/franlopez499/parallel-genetic-algorithm/src/ga/7"}
{"code": "for (int i = 0; i < floor(0.8 * datasize); i++)\n{\n  x_train.push_back(data[i]);\n  y_train.push_back(y[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tayal1996/Parallel-Implementation-of-Artificial-Neural-Networks-for-Hand-written-Recognition-OpenMP/mainIPSC/22"}
{"code": "for (i = k + 1; i < size; ++i)\n{\n  for (j = k; j < (size + 1); ++j)\n  {\n    if (j == k)\n      temp = A[i][k] / A[k][k];\n\n    A[i][j] = A[i][j] - (temp * A[k][j]);\n  }\n\n}\n\n", "pragma": "omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sakolkar/Gauss-Jordan-Elimination/src/main/1"}
{"code": "for (int r = 1; r < nr_rows; r++)\n{\n  for (int c = 1; c < nr_cols; c++)\n  {\n    if (sequential_matrix[r][c] != parallel_matrix[r][c])\n    {\n      solutionCorrect = false;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/FatbardhKadriu/OpenMP-StencilCode/src/stencil/3"}
{"code": "for (int i = 0; i < nUsers; i++)\n  for (int j = 0; j < nFeatures; j++)\n  L[i][j] = (((double) random()) / ((double) 32767)) / ((double) nFeatures);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joaopalet/matFact-CPD/openmp/matFact-omp/5"}
{"code": "for (y = 0; y < 2048; y++)\n{\n  convolution_transform(x, y, kernel, kernel_half_size, kernel_size, bias, size_pix);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tino415/papp-openmp/main_mpi/1"}
{"code": "for (i = 1; i < (rows - 1); i++)\n{\n  for (j = 1; j < (columns - 1); j++)\n  {\n    if ((step % 2) == 0)\n    {\n      residual_temporal = surfaceCopy[(i * columns) + j] - surface[(i * columns) + j];\n    }\n    else\n    {\n      residual_temporal = surface[(i * columns) + j] - surfaceCopy[(i * columns) + j];\n    }\n\n    if (residual_temporal > global_residual)\n    {\n      global_residual = residual_temporal;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SantiagoBlascoArnaiz/ParalelaOMP/extinguishing/1"}
{"code": "for (int k = 0; k < M; k++)\n{\n  tmp_edge_list[k].x = p_v[tmp_edge_list[k].x];\n  tmp_edge_list[k].y = p_v[tmp_edge_list[k].y];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/9"}
{"code": "for (i = 3 * jumper; i <= x; i += twice_jump)\n{\n  int l = i / jumper;\n  if (l & 1)\n    input[i - 1][0] += input[((l - 1) * jumper) - 1][0];\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/inplace_no_rec/2"}
{"code": "for (int k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (int j = x_min - 2; j <= (x_max + 2); j++)\n  {\n    node_flux[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = 0.25 * (((mass_flux_x[FTNREF2D(j, k - 1, x_max + 5, x_min - 2, y_min - 2)] + mass_flux_x[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)]) + mass_flux_x[FTNREF2D(j + 1, k - 1, x_max + 5, x_min - 2, y_min - 2)]) + mass_flux_x[FTNREF2D(j + 1, k, x_max + 5, x_min - 2, y_min - 2)]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_advec_mom/4"}
{"code": "for (j_imopVarPre84 = 1; j_imopVarPre84 <= ((lastrow - firstrow) + 1); j_imopVarPre84++)\n{\n  sum = 0.0;\n  for (k_imopVarPre85 = rowstr[j_imopVarPre84]; k_imopVarPre85 < rowstr[j_imopVarPre84 + 1]; k_imopVarPre85++)\n  {\n    sum = sum + (a[k_imopVarPre85] * p[colidx[k_imopVarPre85]]);\n  }\n\n  q[j_imopVarPre84] = sum;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/14"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  avg += A[i];\n}\n\n", "pragma": "omp parallel for reduction (+:avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deborasetton/cpar-openmp-mpi-examples/openmp/v09.2_eg01_reduction/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  x[i] = 0.0;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/35"}
{"code": "for (int i = 0; i < height; i++)\n{\n  tab[i] = (int *) malloc(width * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jacob273/JG.TechLearning.OpenMP/lab1/multiplication/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    double diff = (A[(i * n) + j] - B[(i * n) + j]) / A[(i * n) + j];\n    if (diff < 0)\n      diff = -diff;\n\n    if (diff > error)\n      error = diff;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/matmul/matmul_mdev/4"}
{"code": "for (a = a_sta; a < a_end; a++)\n{\n  for (b = b_sta; b < b_end; b++)\n  {\n    for (c = c_sta; c < c_end; c++)\n    {\n      if (vector[even][(i + a) - 1][(j + b) - 1][(k + c) - 1] == 1)\n        n++;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skku-multicore-hw/Project1_gol_openmp/process/1"}
{"code": "for (int i = ny / 3; i < ny; i++)\n  costarr[(i * nx) + xx] = COST_OBS;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROSPPaaS/navfn_openmp/src/navfn_omp/3"}
{"code": "for (k = 0; k < (l / u_f1); k++)\n{\n  thread_counter[omp_get_thread_num()] += 1;\n  for (int x = k * u_f1; x < ((k + 1) * u_f1); x++)\n  {\n    __builtin_assume_aligned(mset, 64);\n    __builtin_assume_aligned(nset, 64);\n    if (mset[i][x] != nset[j][x])\n      partialDistVector[omp_get_thread_num()] += 1;\n    else\n      partialDistVector[omp_get_thread_num()] += 0;\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mpaltsai/OpenMP/project_3_omp_fg_vectorized/1"}
{"code": "for (int nCntLA = 0; nCntLA < nLinA; nCntLA++)\n  for (int nCntLX = 0; nCntLX < nColA; nCntLX++)\n  for (int nCntCB = 0; nCntCB < nColB; nCntCB++)\n  aMatrizC[nCntLA][nCntCB] += aMatrizA[nCntLA][nCntLX] * aMatrizB[nCntLX][nCntCB];\n\n\n\n", "pragma": "omp parallel for num_threads(nMaxThread) shared (nLinA, nColA,nColB,aMatrizA,aMatrizB,aMatrizC)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacksjm/c-matrix-openmp/matriz-operacoes-openmp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  array1[i] = (array2[i] = i + 1);\n}\n\n", "pragma": "   #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/IndianShifu/Parallel-Algorithm/Parallel and Distributed Algorithm/Parallel Algos/Prac2/PrefixSumBoth/0"}
{"code": "for (i = 0; i < l; i++)\n  zeros[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/29"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < (*K); j++)\n  {\n    W[(i * (*K)) + j] = U[(i * N) + j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse (2) schedule (static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arpanmangal/Parallel-PCA/lab2_omp/19"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n    (cout << arr[i][j]) << \" \";\n\n  (cout << \"\\n\") << \" \";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ziminyuri/AMP-OpenMP/AMP/12"}
{"code": "for (i = 0; i < n; i++)\n  v[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eisten1996/OpenMP/semana02/eje01/eje01/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  sum += (2 * i) + 1;\n}\n\n", "pragma": "#pragma omp parallel for reduction (+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/9th/9th/7"}
{"code": "for (i = 0; i < s; i++)\n{\n  int j;\n  for (j = 0; j < s; j++)\n  {\n    int m;\n    for (m = j + 1; m < s; m++)\n    {\n      if (selected[(i * s) + j].value > selected[(i * s) + m].value)\n      {\n        sel_points aux;\n        aux = selected[(i * s) + j];\n        selected[(i * s) + j] = selected[(i * s) + m];\n        selected[(i * s) + m] = aux;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gleisonsdm/OpenMP_benchmarks/DawnCC_BENCHS/UniBenchV2/mgBench/other-nearest/src/other-nearest_gpu/4"}
{"code": "for (int i = 0; i < repeat; ++i)\n  simps_parallel(fvals, x, N, num_threads);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/astrophpeter/C-OpenMP-MPI/homework3/src/integrate/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = i;\n  dsum = dsum + i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bhuvaneswar005/OpenMP/Assignment 3/Code/reductionclause_for/0"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * (((u[i][j][k - 2][m] - (4.0 * u[i][j][k - 1][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i][j][k + 1][m])));\n}\n\n", "pragma": "omp parallel for private (m) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/128"}
{"code": "for (i = 0; i < N; i++)\n  a[i] = (double *) malloc(N * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/8/pmm-secuencial/0"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpbmr7_ij0.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rutgers-apl/omp-racer/openmp/runtime/test/affinity/format/affinity_values/3"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  res[i] = scalar * vector[i];\n}\n\n", "pragma": "    #pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yattroman/nsu-opp-mpi-openmp-labs/laboratory-2/version-2/mv/mvOperations_l2_2nd/4"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int m = 0; m < 256; ++m)\n  {\n    mean[i].elements[m] = tep[i].elements[m] / count1[i];\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/VictorYaoHZ/openmp/omp+neon+kmeans/0"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  c[i] = a[i] * b[i];\n  sume += c[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sume)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/array product & sum/0"}
{"code": "for (size_t core = 0; core < coreNum; core++)\n{\n  for (iters[core] = core * sectionNum; (iters[core] < ((core + 1) * sectionNum)) && (iters[core] < m); iters[core]++)\n  {\n    double coeff = train.first.row(iters[core]) * theta;\n    coeff = (1.0 / m) * (g(coeff) - train.second(iters[core]));\n    sumInCore[core] += coeff * train.first.row(iters[core]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhuangqh/LR-x/LR/0"}
{"code": "for (int i = 1; i < tmp1; i++)\n{\n  for (int j = 1; j < (i + N); j++)\n  {\n    tmpsum1 += (j + pow(x + j, 1 / 4.)) / (((2 * i) * j) - 1);\n  }\n\n  sum += 1 / tmpsum1;\n  tmpsum1 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sirozu/Examples-of-MPI-OpenMp/OpenMP/11"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  colwise[0][i] = this->board[i][0];\n  colwise[1][i] = this->board[i][1];\n  colwise[2][i] = this->board[i][2];\n  diagonal1[i] = this->board[i][i];\n  diagonal2[i] = this->board[i][2 - i];\n  p = checkWin(this->board[i]);\n  if (p != (-1))\n  {\n    return p;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/tictactoe_root/1"}
{"code": "for (int i = 0; i < n1; ++i)\n{\n  for (int j = 0; j < n2; ++j)\n  {\n    int sign = rand() % 2;\n    w1[i][j] = ((double) (rand() % 6)) / 10.0;\n    if (sign == 1)\n    {\n      w1[i][j] = -w1[i][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/6"}
{"code": "for (int i = 0; i < 200; i++)\n{\n  for (int j = 0; j < 200; j++)\n  {\n    assert(C[i][j] == P[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidjmstewart/CAB401-OpenMP/matMult-comparison/6"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  ++x;\n  ++y;\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for simd default(firstprivate) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/target_teams_distribute_parallel_for_simd_default_messages/0"}
{"code": "for (int i = 1; i < size; i++)\n{\n  int y = (i * size) + t;\n  pivots_sent[i - 1] = pivots_recvd[y];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zilmarij/Hybrid_MPI-OpenMP_based_Sorting/sort/6"}
{"code": "for (i2 = 0; i2 < n2; i2++)\n{\n  for (i1 = 0; i1 < n1; i1++)\n  {\n    z[i3][i2][i1] = 0.0;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(i3 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/MG/mg/10"}
{"code": "for (int i = 1; i < rank_num; i++)\n{\n  ack_info[0] = 1;\n  MPI_Send(ack_info, 1, MPI_INT, i, 66, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArthurLCW/Heat-Simulation/codes/csc4005-assignment-4-bonus/csc4005-imgui/src/main/7"}
{"code": "for (int i = 0; i <= cnt; i++)\n{\n  trace_cnt = 0;\n  I = StartPointI[i];\n  J = StartPointJ[i];\n  for (int i = 0; i < (traceback_length * length1); i++)\n  {\n    Q_traceback[i] = '\\0';\n    D_traceback[i] = '\\0';\n  }\n\n  index = J + (I * (length1 + 1));\n  index_hor = (J - 1) + (I * (length1 + 1));\n  index_vert = J + ((I - 1) * (length1 + 1));\n  index_diag = (J - 1) + ((I - 1) * (length1 + 1));\n  while (((ScoringMatrix[index_diag] != 0) || (ScoringMatrix[index_hor] != 0)) || (ScoringMatrix[index_vert] != 0))\n  {\n    index = J + (I * (length1 + 1));\n    index_hor = (J - 1) + (I * (length1 + 1));\n    index_vert = J + ((I - 1) * (length1 + 1));\n    index_diag = (J - 1) + ((I - 1) * (length1 + 1));\n    if ((ScoringMatrix[index_diag] >= ScoringMatrix[index_hor]) && (ScoringMatrix[index_diag] >= ScoringMatrix[index_vert]))\n    {\n      Q_traceback[trace_cnt] = FirstString[J - 1];\n      D_traceback[trace_cnt] = SecondString[I - 1];\n      trace_cnt++;\n      Traceback_Steps++;\n      I--;\n      J--;\n    }\n    else\n      if (ScoringMatrix[index_hor] >= ScoringMatrix[index_vert])\n    {\n      Q_traceback[trace_cnt] = FirstString[J - 1];\n      D_traceback[trace_cnt] = '-';\n      trace_cnt++;\n      Traceback_Steps++;\n      J--;\n    }\n    else\n    {\n      Q_traceback[trace_cnt] = '-';\n      D_traceback[trace_cnt] = SecondString[I - 1];\n      trace_cnt++;\n      Traceback_Steps++;\n      I--;\n    }\n\n\n  }\n\n  Stop = StartPointI[i] - 1;\n  Start = I;\n  fprintf(fp1, \"\\nPair %d :\\n\", pair);\n  fprintf(fp1, \"\\nMatch %d [Score: %d,Start: %d,Stop: %d]\\n\", i + 1, MaxValue, Start, Stop);\n  fprintf(fp1, \"D: %s \\n\", reverseConstString(D_traceback));\n  fprintf(fp1, \"Q: %s \\n\", reverseConstString(Q_traceback));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chrz95/OpenMP_Parallelism/main_OMP_Coarse/4"}
{"code": "for (i = 0; i < 8; i++)\n  printf(\"\\t  %c\", i + 'a');\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hennimohammed/parallel_chess_engine/src/move_reorder_vs_beam_search/31"}
{"code": "for (t1 = 1; t1 <= (N - 1); t1++)\n{\n  for (t2 = 0; t2 <= floor(((double) (t1 - 1)) / ((double) 16)); t2++)\n  {\n    for (t3 = 0; t3 <= t2; t3++)\n    {\n      if (((t1 >= (l + 1)) && (t2 == 0)) && (t3 == 0))\n      {\n        Qbp[0 + 0][t1] = (Q[(0 + 0) + 1][t1 - 1] * ERT) * paired(0 + 0, t1 - 1);\n        ;\n        Q[0][t1] = Q[0][t1 - 1];\n        ;\n        Q[0][t1] += Q[0][0 + 0] * Qbp[0 + 0][t1];\n        ;\n      }\n\n      if (t3 == 0)\n      {\n        for (t4 = (1 > (16 * t2)) ? (1) : (16 * t2); t4 <= ((((16 * t2) + 15) < ((t1 - l) - 1)) ? ((16 * t2) + 15) : ((t1 - l) - 1)); t4++)\n        {\n          Qbp[0 + t4][t1] = (Q[(0 + t4) + 1][t1 - 1] * ERT) * paired(0 + t4, t1 - 1);\n          ;\n          Q[t4][t1] = Q[t4][t1 - 1];\n          ;\n          Q[t4][t1] += Q[t4][0 + t4] * Qbp[0 + t4][t1];\n          ;\n          for (t5 = 1; t5 <= ((15 < t4) ? (15) : (t4)); t5++)\n          {\n            Qbp[t5 + (t4 - t5)][t1] = (Q[(t5 + (t4 - t5)) + 1][t1 - 1] * ERT) * paired(t5 + (t4 - t5), t1 - 1);\n            ;\n            Q[t4 - t5][t1] += Q[t4 - t5][t5 + (t4 - t5)] * Qbp[t5 + (t4 - t5)][t1];\n            ;\n          }\n\n        }\n\n      }\n\n      if (t3 == 0)\n      {\n        for (t4 = ((16 * t2) > (t1 - l)) ? (16 * t2) : (t1 - l); t4 <= (((t1 - 1) < ((16 * t2) + 15)) ? (t1 - 1) : ((16 * t2) + 15)); t4++)\n        {\n          Q[t4][t1] = Q[t4][t1 - 1];\n          ;\n        }\n\n      }\n\n      if (t3 >= 1)\n      {\n        for (t4 = 16 * t2; t4 <= ((((16 * t2) + 15) < ((t1 - l) - 1)) ? ((16 * t2) + 15) : ((t1 - l) - 1)); t4++)\n        {\n          for (t5 = 16 * t3; t5 <= ((t4 < ((16 * t3) + 15)) ? (t4) : ((16 * t3) + 15)); t5++)\n          {\n            Qbp[t5 + (t4 - t5)][t1] = (Q[(t5 + (t4 - t5)) + 1][t1 - 1] * ERT) * paired(t5 + (t4 - t5), t1 - 1);\n            ;\n            Q[t4 - t5][t1] += Q[t4 - t5][t5 + (t4 - t5)] * Qbp[t5 + (t4 - t5)][t1];\n            ;\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mcc/mcc/2"}
{"code": "for (j = jend; j >= jst; j += -1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    tv[i][j][m] = omega * (((((udz[i][j][m][0] * v[i][j][k + 1][0]) + (udz[i][j][m][1] * v[i][j][k + 1][1])) + (udz[i][j][m][2] * v[i][j][k + 1][2])) + (udz[i][j][m][3] * v[i][j][k + 1][3])) + (udz[i][j][m][4] * v[i][j][k + 1][4]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/6"}
{"code": "for (v = ref_stats->num_vertices - topk; v < ref_stats->num_vertices; v++)\n{\n  fprintf(fptr, \"| %-14u | %-14u | %-10.15lf | \", v, ref_stats->realRanks[v], ref_stats->pageRanks[ref_stats->realRanks[v]]);\n  fprintf(fptr, \"| %-14u | %-14u | %-10.15lf | \\n\", v, stats->realRanks[v], stats->pageRanks[stats->realRanks[v]]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/35"}
{"code": "for (int32_t tx = 0; tx < new_triangles; ++tx)\n{\n  const int32_t t = tx + found_triangles;\n  triangle_buf[t].edge_b = lgraph_maps[triangle_buf[t].edge_b];\n  const int32_t uw = supports[triangle_buf[t].edge_a];\n  const int32_t vw = supports[triangle_buf[t].edge_b];\n  h_index[t] = gk_min(uw, vw);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/K-Truss/src/and/7"}
{"code": "for (i = 0; i < (3 * (colsNumber / sqrt_comm_sz)); i = i + 3)\n{\n  for (int c = 0; c <= 2; c++)\n  {\n    bottomRow[i + c] = myArray[(rowsNumber / sqrt_comm_sz) - 1][i + c];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/7"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlusInverse->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/12"}
{"code": "for (int i = 0; i < s; i++)\n{\n  printf(\"  | \");\n  for (int j = 0; j < s; j++)\n  {\n    printf(\"%d\\t\", matrix[i][j]);\n  }\n\n  printf(\" |\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nehabhoi/openMP/openmp/2"}
{"code": "for (i = 0; i < M; i += incX)\n{\n  x = X[i];\n  indice = i * M;\n  for (j = 0; j < M; j += incY)\n  {\n    r += A[indice + j] * x;\n  }\n\n  Y[i] = (beta * Y[i]) + (alpha * r);\n}\n\n", "pragma": "omp parallel for schedule(static) private(indice,r)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tozenda/mn-openmp/src/gemv/1"}
{"code": "for (int itr1 = 0; itr1 < row; itr1++)\n{\n  for (int itr2 = 0; itr2 < col; itr2++)\n  {\n    printf(\"%d  \", matrix[itr1][itr2]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulsonone1234/OpenMP-and-MPI-Assignment/assignmnet2_MPI_implementation/2"}
{"code": "for (i = public.endoPoints; i <= (public.allPoints - 1); i += 1)\n{\n  private[i].point_no = i - public.endoPoints;\n  private[i].in_pointer = private[i].point_no * public.in_mod_elem;\n  private[i].d_Row = public.d_epiRow;\n  private[i].d_Col = public.d_epiCol;\n  private[i].d_tRowLoc = public.d_tEpiRowLoc;\n  private[i].d_tColLoc = public.d_tEpiColLoc;\n  private[i].d_T = public.d_epiT;\n}\n\n", "pragma": "omp parallel for private (i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/1"}
{"code": "for (int k = y_min - depth; k <= ((y_max + 1) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    yvel1[FTNREF2D(1 - j, k, x_max + 5, x_min - 2, y_min - 2)] = yvel1[FTNREF2D(1 + j, k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/42"}
{"code": "for (int i = 0; i < 1000; ++i)\n{\n  for (int j = 0; j < 1000; ++j)\n  {\n    c[i][j] = mul(a, b, i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/winAPI/openmp1/lab1/2"}
{"code": "for (digits = 0; digits < 32; digits += granularity)\n{\n  for (i = edges - 1; i >= 0; --i)\n  {\n    key = graph->sorted_edges_array[i].src;\n    key = (key >> digits) & bitmask;\n    pos = --vertex_count[digits / granularity][key];\n    sorted_edges_array[pos] = graph->sorted_edges_array[i];\n  }\n\n  temp = graph->sorted_edges_array;\n  graph->sorted_edges_array = sorted_edges_array;\n  sorted_edges_array = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smdupor/ParallelRadix/src-fullyTuned/sort/16"}
{"code": "for (unsigned int i = 0; i < MasterSlaveConstraintIds.size(); i++)\n{\n  iterator it = root_model_part->MasterSlaveConstraints().find(MasterSlaveConstraintIds[i]);\n  if (it != root_model_part->MasterSlaveConstraintsEnd())\n    aux.push_back(*it.base());\n  else\n    ((KRATOS_ERROR << \"the master-slave constraint with Id \") << MasterSlaveConstraintIds[i]) << \" does not exist in the root model part\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/kratos/sources/model_part/4"}
{"code": "for (int i = 0; i < 4; i++)\n{\n  printf(\"Enter v[%d]: \", i);\n  scanf(\"%f\", &v[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/harjyotbagga/Parallel-and-Distributed-Computing/OpenMP/dot_product/2"}
{"code": "for (i = lower; i <= upper; i++)\n{\n  sum += euler(i);\n}\n\n", "pragma": "omp parallel for schedule(guided) reduction(+: sum) num_threads(n_threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maxburton/DPT-coursework/OpenMP/totientRangeParallel/0"}
{"code": "for (int i = 0; i < iter; i++)\n{\n  linear_result = linear_operation(w, h, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sotheanithsok/CECS-574-Collection/A-2-OpenMP/main/2"}
{"code": "for (int i = 0; i < width; i++)\n{\n  for (int j = 0; j < height; j++)\n    array2D[(i * height) + j] = colorF(i, j);\n\n}\n\n", "pragma": "    #pragma omp parallel for collapse(2) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mustafamajid1/SpeedUpFractals/main/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (((i != j) || ((i % 2) == 0)) && 0)\n    {\n      D[(i * N) + j] = 0;\n    }\n    else\n    {\n      D[(i * N) + j] = (((float) i) * (j + 2)) / N;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/15"}
{"code": "for (i = 0; i < (((L / 1) + 2) / 2); i++)\n{\n  for (j = 0; j < ((L / 5) + 2); j++)\n  {\n    if (whites[i][j].isGhost == 1)\n    {\n      spin = whites[i][j].data;\n      spin_neigh_n = blacks[i][j].data;\n      spin_neigh_e = blacks[i][j + 1].data;\n      spin_neigh_w = blacks[i][j - 1].data;\n      spin_neigh_s = blacks[i + ((2 * (j % 2)) - 1)][j].data;\n      E += (((spin == spin_neigh_n) + (spin == spin_neigh_e)) + (spin == spin_neigh_w)) + (spin == spin_neigh_s);\n      Mt[spin] += 1;\n      spin = blacks[i][j].data;\n      Mt[spin] += 1;\n    }\n    else\n    {\n      continue;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for reduction(+:E) schedule(static, CHUNKSIZE)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/35"}
{"code": "for (int i = 0; i < numSamples; ++i)\n{\n  input[i] = (double *) malloc((sizeof(double)) * (numInputs + 1));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  rowel = row_ptr[i + 1] - row_ptr[i];\n  for (j = 0; j < rowel; j++)\n  {\n    val[curcol] = val[curcol] / out_link[i];\n    curcol++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/leankyr/Parallel_Pagerank/Final/Implementation_2/main2/6"}
{"code": "for (i = 0; i < num_steps; ++i)\n{\n  x = (i + 0.5) * step;\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp for schedule(static) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nuitrcs/OpenMP-MPI-workshop/openmp_examples/pi_red/0"}
{"code": "for (int i = 0; i < b_vec3.size(); i++)\n{\n  (((cout << b_vec3[i].first) << \"  \") << b_vec3[i].second) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amy090912/Word-Count-with-MapReduce-and-openMP/lab4b3/2"}
{"code": "for (int m = 0; m < voxels; m++)\n{\n  float e = (2.f * ((float) M_PI)) * (((k[m].x * xn) + (k[m].y * yn)) + (k[m].z * zn));\n  float c = cos(e);\n  float s = sin(e);\n  rfhdn += (rmu[m] * c) - (imu[m] * s);\n  ifhdn += (imu[m] * c) + (rmu[m] * s);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/fhd-sycl/main/0"}
{"code": "for (i = 0; i < NUM_NEIGHBOURS; i++)\n{\n  MPI_Request_free(&send_after_requests[i]);\n  MPI_Request_free(&send_before_requests[i]);\n  MPI_Request_free(&recv_after_requests[i]);\n  MPI_Request_free(&recv_before_requests[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetropoulakisPanagiotis/parallel-convolution/convolution/parallel_convolution/9"}
{"code": "for (k = 1; k <= (nz - 2); k += 1)\n{\n  frct[i][j][k][0] = frct[i][j][k][0] + ((dz1 * tz1) * ((rsd[i][j][k + 1][0] - (2.0 * rsd[i][j][k][0])) + rsd[i][j][k - 1][0]));\n  frct[i][j][k][1] = (frct[i][j][k][1] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][1] - flux[i][j][k][1]))) + ((dz2 * tz1) * ((rsd[i][j][k + 1][1] - (2.0 * rsd[i][j][k][1])) + rsd[i][j][k - 1][1]));\n  frct[i][j][k][2] = (frct[i][j][k][2] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][2] - flux[i][j][k][2]))) + ((dz3 * tz1) * ((rsd[i][j][k + 1][2] - (2.0 * rsd[i][j][k][2])) + rsd[i][j][k - 1][2]));\n  frct[i][j][k][3] = (frct[i][j][k][3] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][3] - flux[i][j][k][3]))) + ((dz4 * tz1) * ((rsd[i][j][k + 1][3] - (2.0 * rsd[i][j][k][3])) + rsd[i][j][k - 1][3]));\n  frct[i][j][k][4] = (frct[i][j][k][4] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i][j][k + 1][4] - flux[i][j][k][4]))) + ((dz5 * tz1) * ((rsd[i][j][k + 1][4] - (2.0 * rsd[i][j][k][4])) + rsd[i][j][k - 1][4]));\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (tz1,tz3,dz1,dz2,dz3,dz4,dz5)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/49"}
{"code": "for (unsigned i = 0; i < Set.getNumSlots(); ++i)\n{\n  if (Set.getSlotIndex(i) == FunctionIndex)\n  {\n    for (iterator I = Set.begin(i), E = Set.end(i); I != E; ++I)\n    {\n      if (I->isStringAttribute() && I->getKindAsString().startswith(\"INTEL:\"))\n        Fn->addFnAttr(I->getKindAsString());\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/lib/CodeGen/CGStmtOpenMP/2"}
{"code": "for (i = 0; i < nbRawMatrix; ++i)\n{\n  error = 1.0;\n  intiValueLayer(tabLayer[0], i);\n  fillOutc(outc, i);\n  rnnsetstart(tabLayer);\n  rnnset(tabLayer, outc);\n  ajustError(tabLayer[NBLAYER - 1]);\n  error = geterror(tabLayer[NBLAYER - 1], outc);\n  wichError(tabLayer[NBLAYER - 1], outc);\n  displayResult(tabLayer[NBLAYER - 1]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bastiendearaujo/MPI_OpenMp_DeepNeural/sources/rnn/27"}
{"code": "for (int u = 0; u < threads; u++)\n{\n  threadtmprlt[u] = (struct rlt *) malloc(sizeof(struct rlt));\n  threadtmprlt[u]->Nstb = 0;\n  threadtmprlt[u]->numover = (int *) calloc(topoinfo->numG, sizeof(int));\n  threadtmprlt[u]->numdown = (int *) calloc(topoinfo->numG, sizeof(int));\n  threadtmprlt[u]->cnt_store = (int *) calloc(simu_opts->num_stability, sizeof(int));\n  threadtmprlt[u]->y_store = (double *) calloc(simu_opts->num_ode * topoinfo->numG, sizeof(double));\n  threadtmprlt[u]->soln = (double *) calloc(simu_opts->num_stability * topoinfo->numG, sizeof(double));\n  threadtmprlt[u]->paras = (double *) calloc((3 * topoinfo->numR) + (2 * topoinfo->numG), sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/49"}
{"code": "for (int k = 0; k < M; k++)\n{\n  tmp_edge_list[k].x += pow_2(ib - 1) * ii_bit[k];\n  tmp_edge_list[k].y += pow_2(ib - 1) * jj_bit[k];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam9500370/OpenMP-Practice/bfs/pbfs/7"}
{"code": "for (j = 0; j <= (IMAX - 1); j++)\n{\n  for (k = 0; k <= (IMAX - 1); k++)\n  {\n    u[0][i][j][k] = 1.0;\n    u[1][i][j][k] = 0.0;\n    u[2][i][j][k] = 0.0;\n    u[3][i][j][k] = 0.0;\n    u[4][i][j][k] = 1.0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/14"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (a[i] != ah[i])\n  {\n    err = true;\n    printf(\"Error at %d, host = %lf, device = %lf\\n\", i, ah[i], a[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-target-nowait-dep-implicit/test/3"}
{"code": "for (int tid = 0; tid < npoints; tid++)\n{\n  for (int i = 0; i < nfeatures; i++)\n    feature_swap[(i * npoints) + tid] = feature[(tid * nfeatures) + i];\n\n}\n\n", "pragma": "omp target teams distribute parallel for thread_limit(BLOCK_SIZE) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zjin-lcf/HeCBench/kmeans-omp/cluster/0"}
{"code": "for (int i = 0; i < ITERATIONS; i++)\n{\n  for (int channel = 0; channel < c; channel++)\n  {\n    for (int y = boundBoxMinY; y <= boundBoxMaxY; y++)\n    {\n      for (int x = boundBoxMinX; x <= boundBoxMaxX; x++)\n      {\n        int id = (x + (y * w)) + ((channel * w) * h);\n        int idx_nextX = ((x + 1) + (w * y)) + ((w * h) * channel);\n        int idx_prevX = ((x - 1) + (w * y)) + ((w * h) * channel);\n        int idx_nextY = (x + (w * (y + 1))) + ((w * h) * channel);\n        int idx_prevY = (x + (w * (y - 1))) + ((w * h) * channel);\n        if (boundary_array[id] == INSIDE_MASK)\n        {\n          double neighbor_target = ((targetimg[idx_nextY] + targetimg[idx_nextX]) + targetimg[idx_prevX]) + targetimg[idx_prevY];\n          double neighbor_output = ((outimg[idx_nextY] + outimg[idx_nextX]) + outimg[idx_prevX]) + outimg[idx_prevY];\n          outimg[id] = 0.25 * (((4 * targetimg[id]) - neighbor_target) + neighbor_output);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/11"}
{"code": "for (uint i = 0; i < nBonds; ++i)\n{\n  bonded[i] = onFocus[i].a1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedron/0"}
{"code": "for (i = 0; i < 64; i++)\n{\n  for (j = 0; j < 64; j++)\n    if (i == j)\n  {\n    fprintf(fp, \"%d \", 1);\n  }\n  else\n  {\n    fprintf(fp, \"%d \", 0);\n  }\n\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/1"}
{"code": "for (int x = 0; x < thread_dimension.x; x++)\n  for (int y = 0; y < thread_dimension.y; y++)\n  for (int z = 0; z < thread_dimension.z; z++)\n  thread_lattice_map.emplace(ivec3(x, y, z), thread_counter++);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/szayyan/Multithreading-Library-Comparison/Boids/BoidManager/2"}
{"code": "for (int x = 0; x < size; x++)\n{\n  for (int y = 0; y < size; y++)\n  {\n    printf(\"%d \", Matrix[y][x]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ERovirosa/openMPPractice/matrixMult/2"}
{"code": "for (int j = pow(2, i) - 1; j < finishposition; j++)\n{\n  if (j == 0)\n    b->tab[0] = a->tab[(a->size / 2) - 1];\n  else\n    if ((j % 2) == 1)\n    b->tab[j] = b->tab[(j - 1) / 2];\n  else\n  {\n    if (a->tab[j - 1] > b->tab[(j - 2) / 2])\n      b->tab[j] = a->tab[j - 1];\n    else\n      b->tab[j] = b->tab[(j - 2) / 2];\n\n  }\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmp_calculate_substr/Dong_ziqi/3"}
{"code": "for (k2 = 0; k2 < N2; k2++)\n{\n  free(rows[k2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ulises-jeremias/fft-parallel/fft/src/openmp/fft/8"}
{"code": "for (j = 0; j < 100; j++)\n{\n  a[i][j] = ((double) i) * j;\n  b[i][j] = ((double) i) * j;\n  c[i][j] = ((double) i) * j;\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB060-matrixmultiply-orig-no/1"}
{"code": "for (int i = 0; i < rows; i++)\n{\n  for (int j = 0; j < columns; j++)\n  {\n    printf(\"%d\", matrix_a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FedeVerges/SistemasDistribuidos_MemoriaCompartida_OpenMP/OpenMP/Ejercicio6/Ejercicio6/4"}
{"code": "for (int i = 1; i <= len; ++i)\n{\n  histograms[i - 1] = getHistogram(i);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xaviml/openmp-project/P1_FolchMoreno/src/controller/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  double t = sqrt((inpB[2 * i] * inpB[2 * i]) + (inpB[(2 * i) + 1] * inpB[(2 * i) + 1]));\n  if (t != 0)\n  {\n    maxB = (minB = log(t));\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/15. filter (mkl)/filter/7"}
{"code": "for (i = 0; i < s; ++i)\n{\n  for (j = 0; j < s; j++)\n  {\n    (fout << mat[i][j]) << \",\";\n    if (j == (s - 1))\n      fout << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task4(a+b)/1"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; ++j)\n  for (k = 0; k < N; ++k)\n{\n  bar();\n}\n\n\n\n", "pragma": "omp parallel for ordered(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/sink-fold-1/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  r[i] = i * 3.14159;\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/BICG/bicg/2"}
{"code": "for (i = 0; i < sample_count; i++)\n{\n  printf(\"%d \", samples[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JimmyWorks/Parallel_Sorting_with_Regular_Sampling_MPI_OpenMP/src/psrs/4"}
{"code": "for (int l = 0; l < n; l++)\n{\n  if (odd[l] != 0)\n    printf(\"%d\\n\", odd[l]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jishnusaurav/Parallel-and-Distributed-Computing-programs/Seperating_even_odds_openMP/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  const double Xr1 = states[(n * STATE_Xr1) + i];\n  const double Xr2 = states[(n * STATE_Xr2) + i];\n  const double Xs = states[(n * STATE_Xs) + i];\n  const double m = states[(n * STATE_m) + i];\n  const double h = states[(n * STATE_h) + i];\n  const double j = states[(n * STATE_j) + i];\n  const double d = states[(n * STATE_d) + i];\n  const double f = states[(n * STATE_f) + i];\n  const double f2 = states[(n * STATE_f2) + i];\n  const double fCass = states[(n * STATE_fCass) + i];\n  const double s = states[(n * STATE_s) + i];\n  const double r = states[(n * STATE_r) + i];\n  const double Ca_i = states[(n * STATE_Ca_i) + i];\n  const double R_prime = states[(n * STATE_R_prime) + i];\n  const double Ca_SR = states[(n * STATE_Ca_SR) + i];\n  const double Ca_ss = states[(n * STATE_Ca_ss) + i];\n  const double Na_i = states[(n * STATE_Na_i) + i];\n  const double V = states[(n * STATE_V) + i];\n  const double K_i = states[(n * STATE_K_i) + i];\n  const double P_kna = parameters[(n * PARAM_P_kna) + i];\n  const double g_K1 = parameters[(n * PARAM_g_K1) + i];\n  const double g_Kr = parameters[(n * PARAM_g_Kr) + i];\n  const double g_Ks = parameters[(n * PARAM_g_Ks) + i];\n  const double g_Na = parameters[(n * PARAM_g_Na) + i];\n  const double g_bna = parameters[(n * PARAM_g_bna) + i];\n  const double g_CaL = parameters[(n * PARAM_g_CaL) + i];\n  const double g_bca = parameters[(n * PARAM_g_bca) + i];\n  const double g_to = parameters[(n * PARAM_g_to) + i];\n  const double K_mNa = parameters[(n * PARAM_K_mNa) + i];\n  const double K_mk = parameters[(n * PARAM_K_mk) + i];\n  const double P_NaK = parameters[(n * PARAM_P_NaK) + i];\n  const double K_NaCa = parameters[(n * PARAM_K_NaCa) + i];\n  const double K_sat = parameters[(n * PARAM_K_sat) + i];\n  const double Km_Ca = parameters[(n * PARAM_Km_Ca) + i];\n  const double Km_Nai = parameters[(n * PARAM_Km_Nai) + i];\n  const double alpha = parameters[(n * PARAM_alpha) + i];\n  const double gamma = parameters[(n * PARAM_gamma) + i];\n  const double K_pCa = parameters[(n * PARAM_K_pCa) + i];\n  const double g_pCa = parameters[(n * PARAM_g_pCa) + i];\n  const double g_pK = parameters[(n * PARAM_g_pK) + i];\n  const double Buf_c = parameters[(n * PARAM_Buf_c) + i];\n  const double Buf_sr = parameters[(n * PARAM_Buf_sr) + i];\n  const double Buf_ss = parameters[(n * PARAM_Buf_ss) + i];\n  const double Ca_o = parameters[(n * PARAM_Ca_o) + i];\n  const double EC = parameters[(n * PARAM_EC) + i];\n  const double K_buf_c = parameters[(n * PARAM_K_buf_c) + i];\n  const double K_buf_sr = parameters[(n * PARAM_K_buf_sr) + i];\n  const double K_buf_ss = parameters[(n * PARAM_K_buf_ss) + i];\n  const double K_up = parameters[(n * PARAM_K_up) + i];\n  const double V_leak = parameters[(n * PARAM_V_leak) + i];\n  const double V_rel = parameters[(n * PARAM_V_rel) + i];\n  const double V_sr = parameters[(n * PARAM_V_sr) + i];\n  const double V_ss = parameters[(n * PARAM_V_ss) + i];\n  const double V_xfer = parameters[(n * PARAM_V_xfer) + i];\n  const double Vmax_up = parameters[(n * PARAM_Vmax_up) + i];\n  const double k1_prime = parameters[(n * PARAM_k1_prime) + i];\n  const double k2_prime = parameters[(n * PARAM_k2_prime) + i];\n  const double k3 = parameters[(n * PARAM_k3) + i];\n  const double k4 = parameters[(n * PARAM_k4) + i];\n  const double max_sr = parameters[(n * PARAM_max_sr) + i];\n  const double min_sr = parameters[(n * PARAM_min_sr) + i];\n  const double Na_o = parameters[(n * PARAM_Na_o) + i];\n  const double Cm = parameters[(n * PARAM_Cm) + i];\n  const double F = parameters[(n * PARAM_F) + i];\n  const double R = parameters[(n * PARAM_R) + i];\n  const double T = parameters[(n * PARAM_T) + i];\n  const double V_c = parameters[(n * PARAM_V_c) + i];\n  const double stim_amplitude = parameters[(n * PARAM_stim_amplitude) + i];\n  const double stim_duration = parameters[(n * PARAM_stim_duration) + i];\n  const double stim_period = parameters[(n * PARAM_stim_period) + i];\n  const double stim_start = parameters[(n * PARAM_stim_start) + i];\n  const double K_o = parameters[(n * PARAM_K_o) + i];\n  const double E_Na = ((R * T) * log(Na_o / Na_i)) / F;\n  const double E_K = ((R * T) * log(K_o / K_i)) / F;\n  const double E_Ks = ((R * T) * log((K_o + (Na_o * P_kna)) / ((P_kna * Na_i) + K_i))) / F;\n  const double E_Ca = (((0.5 * R) * T) * log(Ca_o / Ca_i)) / F;\n  const double alpha_K1 = 0.1 / (1. + (6.14421235332821e-6 * exp((0.06 * V) - (0.06 * E_K))));\n  const double beta_K1 = ((0.367879441171442 * exp((0.1 * V) - (0.1 * E_K))) + (3.06060402008027 * exp((0.0002 * V) - (0.0002 * E_K)))) / (1. + exp((0.5 * E_K) - (0.5 * V)));\n  const double xK1_inf = alpha_K1 / (alpha_K1 + beta_K1);\n  const double i_K1 = (((0.430331482911935 * g_K1) * sqrt(K_o)) * ((-E_K) + V)) * xK1_inf;\n  const double i_Kr = ((((0.430331482911935 * g_Kr) * sqrt(K_o)) * ((-E_K) + V)) * Xr1) * Xr2;\n  const double xr1_inf = 1.0 / (1. + exp(((-26.) / 7.) - (V / 7.)));\n  const double alpha_xr1 = 450. / (1. + exp(((-9.) / 2.) - (V / 10.)));\n  const double beta_xr1 = 6. / (1. + (13.5813245225782 * exp(0.0869565217391304 * V)));\n  const double tau_xr1 = alpha_xr1 * beta_xr1;\n  const double dXr1_dt = ((-Xr1) + xr1_inf) / tau_xr1;\n  const double dXr1_dt_linearized = (-1.) / tau_xr1;\n  states[(n * STATE_Xr1) + i] = ((fabs(dXr1_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dXr1_dt_linearized)) * dXr1_dt) / dXr1_dt_linearized) : (dt * dXr1_dt)) + Xr1;\n  const double xr2_inf = 1.0 / (1. + exp((11. / 3.) + (V / 24.)));\n  const double alpha_xr2 = 3. / (1. + exp((-3.) - (V / 20.)));\n  const double beta_xr2 = 1.12 / (1. + exp((-3.) + (V / 20.)));\n  const double tau_xr2 = alpha_xr2 * beta_xr2;\n  const double dXr2_dt = ((-Xr2) + xr2_inf) / tau_xr2;\n  const double dXr2_dt_linearized = (-1.) / tau_xr2;\n  states[(n * STATE_Xr2) + i] = ((fabs(dXr2_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dXr2_dt_linearized)) * dXr2_dt) / dXr2_dt_linearized) : (dt * dXr2_dt)) + Xr2;\n  const double i_Ks = (g_Ks * (Xs * Xs)) * ((-E_Ks) + V);\n  const double xs_inf = 1.0 / (1. + exp(((-5.) / 14.) - (V / 14.)));\n  const double alpha_xs = 1400. / sqrt(1. + exp((5. / 6.) - (V / 6.)));\n  const double beta_xs = 1.0 / (1. + exp(((-7.) / 3.) + (V / 15.)));\n  const double tau_xs = 80. + (alpha_xs * beta_xs);\n  const double dXs_dt = ((-Xs) + xs_inf) / tau_xs;\n  const double dXs_dt_linearized = (-1.) / tau_xs;\n  states[(n * STATE_Xs) + i] = ((fabs(dXs_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dXs_dt_linearized)) * dXs_dt) / dXs_dt_linearized) : (dt * dXs_dt)) + Xs;\n  const double i_Na = (((g_Na * ((m * m) * m)) * ((-E_Na) + V)) * h) * j;\n  const double m_inf = 1.0 / ((1. + (0.00184221158116513 * exp((-0.110741971207087) * V))) * (1. + (0.00184221158116513 * exp((-0.110741971207087) * V))));\n  const double alpha_m = 1.0 / (1. + exp((-12.) - (V / 5.)));\n  const double beta_m = (0.1 / (1. + exp(7. + (V / 5.)))) + (0.1 / (1. + exp(((-1.) / 4.) + (V / 200.))));\n  const double tau_m = alpha_m * beta_m;\n  const double dm_dt = ((-m) + m_inf) / tau_m;\n  const double dm_dt_linearized = (-1.) / tau_m;\n  states[(n * STATE_m) + i] = ((fabs(dm_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dm_dt_linearized)) * dm_dt) / dm_dt_linearized) : (dt * dm_dt)) + m;\n  const double h_inf = 1.0 / ((1. + (15212.5932856544 * exp(0.134589502018843 * V))) * (1. + (15212.5932856544 * exp(0.134589502018843 * V))));\n  const double alpha_h = (V < (-40.)) ? (4.43126792958051e-7 * exp((-0.147058823529412) * V)) : (0.);\n  const double beta_h = (V < (-40.)) ? ((310000. * exp(0.3485 * V)) + (2.7 * exp(0.079 * V))) : (0.77 / (0.13 + (0.0497581410839387 * exp((-0.0900900900900901) * V))));\n  const double tau_h = 1.0 / (alpha_h + beta_h);\n  const double dh_dt = ((-h) + h_inf) / tau_h;\n  const double dh_dt_linearized = (-1.) / tau_h;\n  states[(n * STATE_h) + i] = ((fabs(dh_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dh_dt_linearized)) * dh_dt) / dh_dt_linearized) : (dt * dh_dt)) + h;\n  const double j_inf = 1.0 / ((1. + (15212.5932856544 * exp(0.134589502018843 * V))) * (1. + (15212.5932856544 * exp(0.134589502018843 * V))));\n  const double alpha_j = (V < (-40.)) ? (((37.78 + V) * (((-25428.) * exp(0.2444 * V)) - (6.948e-6 * exp((-0.04391) * V)))) / (1. + (50262745825.954 * exp(0.311 * V)))) : (0.);\n  const double beta_j = (V < (-40.)) ? ((0.02424 * exp((-0.01052) * V)) / (1. + (0.00396086833990426 * exp((-0.1378) * V)))) : ((0.6 * exp(0.057 * V)) / (1. + (0.0407622039783662 * exp((-0.1) * V))));\n  const double tau_j = 1.0 / (alpha_j + beta_j);\n  const double dj_dt = ((-j) + j_inf) / tau_j;\n  const double dj_dt_linearized = (-1.) / tau_j;\n  states[(n * STATE_j) + i] = ((fabs(dj_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dj_dt_linearized)) * dj_dt) / dj_dt_linearized) : (dt * dj_dt)) + j;\n  const double i_b_Na = g_bna * ((-E_Na) + V);\n  const double V_eff = (fabs((-15.) + V) < 0.01) ? (0.01) : ((-15.) + V);\n  const double i_CaL = ((((((((4. * g_CaL) * (F * F)) * ((-Ca_o) + ((0.25 * Ca_ss) * exp(((2. * F) * V_eff) / (R * T))))) * V_eff) * d) * f) * f2) * fCass) / ((R * T) * ((-1.) + exp(((2. * F) * V_eff) / (R * T))));\n  const double d_inf = 1.0 / (1. + (0.344153786865412 * exp((-0.133333333333333) * V)));\n  const double alpha_d = 0.25 + (1.4 / (1. + exp(((-35.) / 13.) - (V / 13.))));\n  const double beta_d = 1.4 / (1. + exp(1. + (V / 5.)));\n  const double gamma_d = 1.0 / (1. + exp((5. / 2.) - (V / 20.)));\n  const double tau_d = (alpha_d * beta_d) + gamma_d;\n  const double dd_dt = ((-d) + d_inf) / tau_d;\n  const double dd_dt_linearized = (-1.) / tau_d;\n  states[(n * STATE_d) + i] = ((fabs(dd_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dd_dt_linearized)) * dd_dt) / dd_dt_linearized) : (dt * dd_dt)) + d;\n  const double f_inf = 1.0 / (1. + exp((20. / 7.) + (V / 7.)));\n  const double tau_f = ((20. + (180. / (1. + exp(3. + (V / 10.))))) + (200. / (1. + exp((13. / 10.) - (V / 10.))))) + (1102.5 * exp((-((27. + V) * (27. + V))) / 225.));\n  const double df_dt = ((-f) + f_inf) / tau_f;\n  const double df_dt_linearized = (-1.) / tau_f;\n  states[(n * STATE_f) + i] = ((fabs(df_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * df_dt_linearized)) * df_dt) / df_dt_linearized) : (dt * df_dt)) + f;\n  const double f2_inf = 0.33 + (0.67 / (1. + exp(5. + (V / 7.))));\n  const double tau_f2 = ((31. / (1. + exp((5. / 2.) - (V / 10.)))) + (80. / (1. + exp(3. + (V / 10.))))) + (562. * exp((-((27. + V) * (27. + V))) / 240.));\n  const double df2_dt = ((-f2) + f2_inf) / tau_f2;\n  const double df2_dt_linearized = (-1.) / tau_f2;\n  states[(n * STATE_f2) + i] = ((fabs(df2_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * df2_dt_linearized)) * df2_dt) / df2_dt_linearized) : (dt * df2_dt)) + f2;\n  const double fCass_inf = 0.4 + (0.6 / (1. + (400.0 * (Ca_ss * Ca_ss))));\n  const double tau_fCass = 2. + (80. / (1. + (400.0 * (Ca_ss * Ca_ss))));\n  const double dfCass_dt = ((-fCass) + fCass_inf) / tau_fCass;\n  const double dfCass_dt_linearized = (-1.) / tau_fCass;\n  states[(n * STATE_fCass) + i] = ((fabs(dfCass_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dfCass_dt_linearized)) * dfCass_dt) / dfCass_dt_linearized) : (dt * dfCass_dt)) + fCass;\n  const double i_b_Ca = g_bca * ((-E_Ca) + V);\n  const double i_to = ((g_to * ((-E_K) + V)) * r) * s;\n  const double s_inf = 1.0 / (1. + exp(4. + (V / 5.)));\n  const double tau_s = (3. + (5. / (1. + exp((-4.) + (V / 5.))))) + (85. * exp((-((45. + V) * (45. + V))) / 320.));\n  const double ds_dt = ((-s) + s_inf) / tau_s;\n  const double ds_dt_linearized = (-1.) / tau_s;\n  states[(n * STATE_s) + i] = ((fabs(ds_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * ds_dt_linearized)) * ds_dt) / ds_dt_linearized) : (dt * ds_dt)) + s;\n  const double r_inf = 1.0 / (1. + exp((10. / 3.) - (V / 6.)));\n  const double tau_r = 0.8 + (9.5 * exp((-((40. + V) * (40. + V))) / 1800.));\n  const double dr_dt = ((-r) + r_inf) / tau_r;\n  const double dr_dt_linearized = (-1.) / tau_r;\n  states[(n * STATE_r) + i] = ((fabs(dr_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dr_dt_linearized)) * dr_dt) / dr_dt_linearized) : (dt * dr_dt)) + r;\n  const double i_NaK = ((K_o * P_NaK) * Na_i) / (((K_mNa + Na_i) * (K_mk + K_o)) * ((1. + (0.0353 * exp(((-F) * V) / (R * T)))) + (0.1245 * exp((((-0.1) * F) * V) / (R * T)))));\n  const double i_NaCa = (K_NaCa * (((Ca_o * ((Na_i * Na_i) * Na_i)) * exp(((F * gamma) * V) / (R * T))) - (((alpha * ((Na_o * Na_o) * Na_o)) * Ca_i) * exp(((F * ((-1.) + gamma)) * V) / (R * T))))) / (((1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))) * (Ca_o + Km_Ca)) * (((Km_Nai * Km_Nai) * Km_Nai) + ((Na_o * Na_o) * Na_o)));\n  const double i_p_Ca = (g_pCa * Ca_i) / (K_pCa + Ca_i);\n  const double i_p_K = (g_pK * ((-E_K) + V)) / (1. + (65.4052157419383 * exp((-0.167224080267559) * V)));\n  const double i_up = Vmax_up / (1. + ((K_up * K_up) / (Ca_i * Ca_i)));\n  const double i_leak = V_leak * ((-Ca_i) + Ca_SR);\n  const double i_xfer = V_xfer * ((-Ca_i) + Ca_ss);\n  const double kcasr = max_sr - ((max_sr - min_sr) / (1. + ((EC * EC) / (Ca_SR * Ca_SR))));\n  const double Ca_i_bufc = 1.0 / (1. + ((Buf_c * K_buf_c) / ((K_buf_c + Ca_i) * (K_buf_c + Ca_i))));\n  const double Ca_sr_bufsr = 1.0 / (1. + ((Buf_sr * K_buf_sr) / ((K_buf_sr + Ca_SR) * (K_buf_sr + Ca_SR))));\n  const double Ca_ss_bufss = 1.0 / (1. + ((Buf_ss * K_buf_ss) / ((K_buf_ss + Ca_ss) * (K_buf_ss + Ca_ss))));\n  const double dCa_i_dt = ((((V_sr * ((-i_up) + i_leak)) / V_c) - ((Cm * ((((-2.) * i_NaCa) + i_b_Ca) + i_p_Ca)) / ((2. * F) * V_c))) + i_xfer) * Ca_i_bufc;\n  const double dCa_i_bufc_dCa_i = ((2. * Buf_c) * K_buf_c) / (((1. + ((Buf_c * K_buf_c) / ((K_buf_c + Ca_i) * (K_buf_c + Ca_i)))) * (1. + ((Buf_c * K_buf_c) / ((K_buf_c + Ca_i) * (K_buf_c + Ca_i))))) * (((K_buf_c + Ca_i) * (K_buf_c + Ca_i)) * (K_buf_c + Ca_i)));\n  const double di_NaCa_dCa_i = ((((-K_NaCa) * alpha) * ((Na_o * Na_o) * Na_o)) * exp(((F * ((-1.) + gamma)) * V) / (R * T))) / (((1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))) * (Ca_o + Km_Ca)) * (((Km_Nai * Km_Nai) * Km_Nai) + ((Na_o * Na_o) * Na_o)));\n  const double di_up_dCa_i = ((2. * Vmax_up) * (K_up * K_up)) / (((1. + ((K_up * K_up) / (Ca_i * Ca_i))) * (1. + ((K_up * K_up) / (Ca_i * Ca_i)))) * ((Ca_i * Ca_i) * Ca_i));\n  const double di_p_Ca_dCa_i = (g_pCa / (K_pCa + Ca_i)) - ((g_pCa * Ca_i) / ((K_pCa + Ca_i) * (K_pCa + Ca_i)));\n  const double dE_Ca_dCa_i = (((-0.5) * R) * T) / (F * Ca_i);\n  const double dCa_i_dt_linearized = ((((-V_xfer) + ((V_sr * ((-V_leak) - di_up_dCa_i)) / V_c)) - ((Cm * ((((-2.) * di_NaCa_dCa_i) - (g_bca * dE_Ca_dCa_i)) + di_p_Ca_dCa_i)) / ((2. * F) * V_c))) * Ca_i_bufc) + (((((V_sr * ((-i_up) + i_leak)) / V_c) - ((Cm * ((((-2.) * i_NaCa) + i_b_Ca) + i_p_Ca)) / ((2. * F) * V_c))) + i_xfer) * dCa_i_bufc_dCa_i);\n  states[(n * STATE_Ca_i) + i] = Ca_i + ((fabs(dCa_i_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dCa_i_dt_linearized)) * dCa_i_dt) / dCa_i_dt_linearized) : (dt * dCa_i_dt));\n  const double k1 = k1_prime / kcasr;\n  const double k2 = k2_prime * kcasr;\n  const double O = (((Ca_ss * Ca_ss) * R_prime) * k1) / (k3 + ((Ca_ss * Ca_ss) * k1));\n  const double dR_prime_dt = (k4 * (1. - R_prime)) - ((Ca_ss * R_prime) * k2);\n  const double dR_prime_dt_linearized = (-k4) - (Ca_ss * k2);\n  states[(n * STATE_R_prime) + i] = ((fabs(dR_prime_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dR_prime_dt_linearized)) * dR_prime_dt) / dR_prime_dt_linearized) : (dt * dR_prime_dt)) + R_prime;\n  const double i_rel = (V_rel * ((-Ca_ss) + Ca_SR)) * O;\n  const double dCa_SR_dt = (((-i_leak) - i_rel) + i_up) * Ca_sr_bufsr;\n  const double dkcasr_dCa_SR = (((-2.) * (EC * EC)) * (max_sr - min_sr)) / (((1. + ((EC * EC) / (Ca_SR * Ca_SR))) * (1. + ((EC * EC) / (Ca_SR * Ca_SR)))) * ((Ca_SR * Ca_SR) * Ca_SR));\n  const double dCa_sr_bufsr_dCa_SR = ((2. * Buf_sr) * K_buf_sr) / (((1. + ((Buf_sr * K_buf_sr) / ((K_buf_sr + Ca_SR) * (K_buf_sr + Ca_SR)))) * (1. + ((Buf_sr * K_buf_sr) / ((K_buf_sr + Ca_SR) * (K_buf_sr + Ca_SR))))) * (((K_buf_sr + Ca_SR) * (K_buf_sr + Ca_SR)) * (K_buf_sr + Ca_SR)));\n  const double di_rel_dO = V_rel * ((-Ca_ss) + Ca_SR);\n  const double dk1_dkcasr = (-k1_prime) / (kcasr * kcasr);\n  const double dO_dk1 = (((Ca_ss * Ca_ss) * R_prime) / (k3 + ((Ca_ss * Ca_ss) * k1))) - (((pow(Ca_ss, 4.) * R_prime) * k1) / ((k3 + ((Ca_ss * Ca_ss) * k1)) * (k3 + ((Ca_ss * Ca_ss) * k1))));\n  const double di_rel_dCa_SR = (V_rel * O) + ((((V_rel * ((-Ca_ss) + Ca_SR)) * dO_dk1) * dk1_dkcasr) * dkcasr_dCa_SR);\n  const double dCa_SR_dt_linearized = ((((-V_leak) - di_rel_dCa_SR) - (((dO_dk1 * di_rel_dO) * dk1_dkcasr) * dkcasr_dCa_SR)) * Ca_sr_bufsr) + ((((-i_leak) - i_rel) + i_up) * dCa_sr_bufsr_dCa_SR);\n  states[(n * STATE_Ca_SR) + i] = Ca_SR + ((fabs(dCa_SR_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dCa_SR_dt_linearized)) * dCa_SR_dt) / dCa_SR_dt_linearized) : (dt * dCa_SR_dt));\n  const double dCa_ss_dt = ((((V_sr * i_rel) / V_ss) - ((V_c * i_xfer) / V_ss)) - ((Cm * i_CaL) / ((2. * F) * V_ss))) * Ca_ss_bufss;\n  const double dO_dCa_ss = (((((-2.) * ((Ca_ss * Ca_ss) * Ca_ss)) * (k1 * k1)) * R_prime) / ((k3 + ((Ca_ss * Ca_ss) * k1)) * (k3 + ((Ca_ss * Ca_ss) * k1)))) + ((((2. * Ca_ss) * R_prime) * k1) / (k3 + ((Ca_ss * Ca_ss) * k1)));\n  const double di_rel_dCa_ss = ((-V_rel) * O) + ((V_rel * ((-Ca_ss) + Ca_SR)) * dO_dCa_ss);\n  const double dCa_ss_bufss_dCa_ss = ((2. * Buf_ss) * K_buf_ss) / (((1. + ((Buf_ss * K_buf_ss) / ((K_buf_ss + Ca_ss) * (K_buf_ss + Ca_ss)))) * (1. + ((Buf_ss * K_buf_ss) / ((K_buf_ss + Ca_ss) * (K_buf_ss + Ca_ss))))) * (((K_buf_ss + Ca_ss) * (K_buf_ss + Ca_ss)) * (K_buf_ss + Ca_ss)));\n  const double di_CaL_dCa_ss = ((((((((1.0 * g_CaL) * (F * F)) * V_eff) * d) * exp(((2. * F) * V_eff) / (R * T))) * f) * f2) * fCass) / ((R * T) * ((-1.) + exp(((2. * F) * V_eff) / (R * T))));\n  const double dCa_ss_dt_linearized = (((((V_sr * ((dO_dCa_ss * di_rel_dO) + di_rel_dCa_ss)) / V_ss) - ((V_c * V_xfer) / V_ss)) - ((Cm * di_CaL_dCa_ss) / ((2. * F) * V_ss))) * Ca_ss_bufss) + (((((V_sr * i_rel) / V_ss) - ((V_c * i_xfer) / V_ss)) - ((Cm * i_CaL) / ((2. * F) * V_ss))) * dCa_ss_bufss_dCa_ss);\n  states[(n * STATE_Ca_ss) + i] = Ca_ss + ((fabs(dCa_ss_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dCa_ss_dt_linearized)) * dCa_ss_dt) / dCa_ss_dt_linearized) : (dt * dCa_ss_dt));\n  const double dNa_i_dt = (Cm * ((((-i_Na) - i_b_Na) - (3. * i_NaCa)) - (3. * i_NaK))) / (F * V_c);\n  const double dE_Na_dNa_i = ((-R) * T) / (F * Na_i);\n  const double di_NaCa_dNa_i = ((((3. * Ca_o) * K_NaCa) * (Na_i * Na_i)) * exp(((F * gamma) * V) / (R * T))) / (((1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))) * (Ca_o + Km_Ca)) * (((Km_Nai * Km_Nai) * Km_Nai) + ((Na_o * Na_o) * Na_o)));\n  const double di_Na_dE_Na = (((-g_Na) * ((m * m) * m)) * h) * j;\n  const double di_NaK_dNa_i = ((K_o * P_NaK) / (((K_mNa + Na_i) * (K_mk + K_o)) * ((1. + (0.0353 * exp(((-F) * V) / (R * T)))) + (0.1245 * exp((((-0.1) * F) * V) / (R * T)))))) - (((K_o * P_NaK) * Na_i) / ((((K_mNa + Na_i) * (K_mNa + Na_i)) * (K_mk + K_o)) * ((1. + (0.0353 * exp(((-F) * V) / (R * T)))) + (0.1245 * exp((((-0.1) * F) * V) / (R * T))))));\n  const double dNa_i_dt_linearized = (Cm * (((((-3.) * di_NaCa_dNa_i) - (3. * di_NaK_dNa_i)) + (g_bna * dE_Na_dNa_i)) - (dE_Na_dNa_i * di_Na_dE_Na))) / (F * V_c);\n  states[(n * STATE_Na_i) + i] = Na_i + ((fabs(dNa_i_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dNa_i_dt_linearized)) * dNa_i_dt) / dNa_i_dt_linearized) : (dt * dNa_i_dt));\n  const double i_Stim = (((t - (stim_period * floor(t / stim_period))) <= (stim_duration + stim_start)) && ((t - (stim_period * floor(t / stim_period))) >= stim_start)) ? (-stim_amplitude) : (0.);\n  const double dV_dt = ((((((((((((-i_CaL) - i_K1) - i_Kr) - i_Ks) - i_Na) - i_NaCa) - i_NaK) - i_Stim) - i_b_Ca) - i_b_Na) - i_p_Ca) - i_p_K) - i_to;\n  const double dalpha_K1_dV = ((-3.68652741199693e-8) * exp((0.06 * V) - (0.06 * E_K))) / ((1. + (6.14421235332821e-6 * exp((0.06 * V) - (0.06 * E_K)))) * (1. + (6.14421235332821e-6 * exp((0.06 * V) - (0.06 * E_K)))));\n  const double di_CaL_dV_eff = (((((((((4. * g_CaL) * (F * F)) * ((-Ca_o) + ((0.25 * Ca_ss) * exp(((2. * F) * V_eff) / (R * T))))) * d) * f) * f2) * fCass) / ((R * T) * ((-1.) + exp(((2. * F) * V_eff) / (R * T))))) - ((((((((((8. * g_CaL) * ((F * F) * F)) * ((-Ca_o) + ((0.25 * Ca_ss) * exp(((2. * F) * V_eff) / (R * T))))) * V_eff) * d) * exp(((2. * F) * V_eff) / (R * T))) * f) * f2) * fCass) / (((R * R) * (T * T)) * (((-1.) + exp(((2. * F) * V_eff) / (R * T))) * ((-1.) + exp(((2. * F) * V_eff) / (R * T))))))) + ((((((((((2.0 * g_CaL) * ((F * F) * F)) * Ca_ss) * V_eff) * d) * exp(((2. * F) * V_eff) / (R * T))) * f) * f2) * fCass) / (((R * R) * (T * T)) * ((-1.) + exp(((2. * F) * V_eff) / (R * T)))));\n  const double di_Ks_dV = g_Ks * (Xs * Xs);\n  const double di_p_K_dV = (g_pK / (1. + (65.4052157419383 * exp((-0.167224080267559) * V)))) + ((((10.9373270471469 * g_pK) * ((-E_K) + V)) * exp((-0.167224080267559) * V)) / ((1. + (65.4052157419383 * exp((-0.167224080267559) * V))) * (1. + (65.4052157419383 * exp((-0.167224080267559) * V)))));\n  const double di_to_dV = (g_to * r) * s;\n  const double dxK1_inf_dbeta_K1 = (-alpha_K1) / ((alpha_K1 + beta_K1) * (alpha_K1 + beta_K1));\n  const double dxK1_inf_dalpha_K1 = (1.0 / (alpha_K1 + beta_K1)) - (alpha_K1 / ((alpha_K1 + beta_K1) * (alpha_K1 + beta_K1)));\n  const double dbeta_K1_dV = (((0.000612120804016053 * exp((0.0002 * V) - (0.0002 * E_K))) + (0.0367879441171442 * exp((0.1 * V) - (0.1 * E_K)))) / (1. + exp((0.5 * E_K) - (0.5 * V)))) + (((0.5 * ((0.367879441171442 * exp((0.1 * V) - (0.1 * E_K))) + (3.06060402008027 * exp((0.0002 * V) - (0.0002 * E_K))))) * exp((0.5 * E_K) - (0.5 * V))) / ((1. + exp((0.5 * E_K) - (0.5 * V))) * (1. + exp((0.5 * E_K) - (0.5 * V)))));\n  const double di_K1_dV = (((0.430331482911935 * g_K1) * sqrt(K_o)) * xK1_inf) + ((((0.430331482911935 * g_K1) * sqrt(K_o)) * ((-E_K) + V)) * ((dalpha_K1_dV * dxK1_inf_dalpha_K1) + (dbeta_K1_dV * dxK1_inf_dbeta_K1)));\n  const double dV_eff_dV = (fabs((-15.) + V) < 0.01) ? (0.) : (1.);\n  const double di_Na_dV = ((g_Na * ((m * m) * m)) * h) * j;\n  const double di_Kr_dV = (((0.430331482911935 * g_Kr) * sqrt(K_o)) * Xr1) * Xr2;\n  const double di_NaK_dV = (((K_o * P_NaK) * ((((0.0353 * F) * exp(((-F) * V) / (R * T))) / (R * T)) + (((0.01245 * F) * exp((((-0.1) * F) * V) / (R * T))) / (R * T)))) * Na_i) / (((K_mNa + Na_i) * (K_mk + K_o)) * (((1. + (0.0353 * exp(((-F) * V) / (R * T)))) + (0.1245 * exp((((-0.1) * F) * V) / (R * T)))) * ((1. + (0.0353 * exp(((-F) * V) / (R * T)))) + (0.1245 * exp((((-0.1) * F) * V) / (R * T))))));\n  const double di_K1_dxK1_inf = ((0.430331482911935 * g_K1) * sqrt(K_o)) * ((-E_K) + V);\n  const double di_NaCa_dV = ((K_NaCa * ((((((Ca_o * F) * gamma) * ((Na_i * Na_i) * Na_i)) * exp(((F * gamma) * V) / (R * T))) / (R * T)) - ((((((F * alpha) * ((Na_o * Na_o) * Na_o)) * ((-1.) + gamma)) * Ca_i) * exp(((F * ((-1.) + gamma)) * V) / (R * T))) / (R * T)))) / (((1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))) * (Ca_o + Km_Ca)) * (((Km_Nai * Km_Nai) * Km_Nai) + ((Na_o * Na_o) * Na_o)))) - ((((((F * K_NaCa) * K_sat) * ((-1.) + gamma)) * (((Ca_o * ((Na_i * Na_i) * Na_i)) * exp(((F * gamma) * V) / (R * T))) - (((alpha * ((Na_o * Na_o) * Na_o)) * Ca_i) * exp(((F * ((-1.) + gamma)) * V) / (R * T))))) * exp(((F * ((-1.) + gamma)) * V) / (R * T))) / ((((R * T) * ((1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))) * (1. + (K_sat * exp(((F * ((-1.) + gamma)) * V) / (R * T)))))) * (Ca_o + Km_Ca)) * (((Km_Nai * Km_Nai) * Km_Nai) + ((Na_o * Na_o) * Na_o))));\n  const double dV_dt_linearized = (((((((((((-g_bca) - g_bna) - di_K1_dV) - di_Kr_dV) - di_Ks_dV) - di_NaCa_dV) - di_NaK_dV) - di_Na_dV) - di_p_K_dV) - di_to_dV) - (((dalpha_K1_dV * dxK1_inf_dalpha_K1) + (dbeta_K1_dV * dxK1_inf_dbeta_K1)) * di_K1_dxK1_inf)) - (dV_eff_dV * di_CaL_dV_eff);\n  states[(n * STATE_V) + i] = ((fabs(dV_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dV_dt_linearized)) * dV_dt) / dV_dt_linearized) : (dt * dV_dt)) + V;\n  const double dK_i_dt = (Cm * (((((((-i_K1) - i_Kr) - i_Ks) - i_Stim) - i_p_K) - i_to) + (2. * i_NaK))) / (F * V_c);\n  const double dE_Ks_dK_i = ((-R) * T) / (F * ((P_kna * Na_i) + K_i));\n  const double dbeta_K1_dE_K = ((((-0.000612120804016053) * exp((0.0002 * V) - (0.0002 * E_K))) - (0.0367879441171442 * exp((0.1 * V) - (0.1 * E_K)))) / (1. + exp((0.5 * E_K) - (0.5 * V)))) - (((0.5 * ((0.367879441171442 * exp((0.1 * V) - (0.1 * E_K))) + (3.06060402008027 * exp((0.0002 * V) - (0.0002 * E_K))))) * exp((0.5 * E_K) - (0.5 * V))) / ((1. + exp((0.5 * E_K) - (0.5 * V))) * (1. + exp((0.5 * E_K) - (0.5 * V)))));\n  const double di_Kr_dE_K = ((((-0.430331482911935) * g_Kr) * sqrt(K_o)) * Xr1) * Xr2;\n  const double dE_K_dK_i = ((-R) * T) / (F * K_i);\n  const double di_Ks_dE_Ks = (-g_Ks) * (Xs * Xs);\n  const double di_to_dE_K = ((-g_to) * r) * s;\n  const double dalpha_K1_dE_K = (3.68652741199693e-8 * exp((0.06 * V) - (0.06 * E_K))) / ((1. + (6.14421235332821e-6 * exp((0.06 * V) - (0.06 * E_K)))) * (1. + (6.14421235332821e-6 * exp((0.06 * V) - (0.06 * E_K)))));\n  const double di_K1_dE_K = ((((-0.430331482911935) * g_K1) * sqrt(K_o)) * xK1_inf) + ((((0.430331482911935 * g_K1) * sqrt(K_o)) * ((-E_K) + V)) * ((dalpha_K1_dE_K * dxK1_inf_dalpha_K1) + (dbeta_K1_dE_K * dxK1_inf_dbeta_K1)));\n  const double di_p_K_dE_K = (-g_pK) / (1. + (65.4052157419383 * exp((-0.167224080267559) * V)));\n  const double dK_i_dt_linearized = (Cm * (((((((-(((dE_K_dK_i * dalpha_K1_dE_K) * dxK1_inf_dalpha_K1) + ((dE_K_dK_i * dbeta_K1_dE_K) * dxK1_inf_dbeta_K1))) * di_K1_dxK1_inf) - (dE_K_dK_i * di_K1_dE_K)) - (dE_K_dK_i * di_Kr_dE_K)) - (dE_K_dK_i * di_p_K_dE_K)) - (dE_K_dK_i * di_to_dE_K)) - (dE_Ks_dK_i * di_Ks_dE_Ks))) / (F * V_c);\n  states[(n * STATE_K_i) + i] = K_i + ((fabs(dK_i_dt_linearized) > 1.0e-8) ? ((((-1.0) + exp(dt * dK_i_dt_linearized)) * dK_i_dt) / dK_i_dt_linearized) : (dt * dK_i_dt));\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/rushlarsen-omp/kernels/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  ants[i].pathLength = 0;\n  memset(&ants[i].city_flags[0], 1, 10000 * (sizeof(int)));\n  register int tmp = ((int) rand()) % 10000;\n  ants[i].initialCity = tmp;\n  ants[i].currentCity = tmp;\n  ants[i].route[0] = tmp;\n  ants[i].city_flags[tmp] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/makariosb/Parallel-Machine-Learning-Algorithms/Project3/Ant-Colony/4"}
{"code": "for (uint32_t row = 1; row < (pInImage->height - 1); row++)\n{\n  for (uint32_t col = 1; col < (pInImage->width - 1); col++)\n  {\n    int16_t gradX;\n    int16_t gradY;\n    convolution_3_by_3(pInImage, kernelX, row, col, &gradX);\n    convolution_3_by_3(pInImage, kernelY, row, col, &gradY);\n    int16_t norm = norm2(gradX, gradY);\n    pOutMatrix->data[(row * pOutMatrix->width) + col] = norm;\n    if (norm > locMax)\n    {\n      locMax = norm;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ricordel/parallel-sobel/sobel/implem_omp/0"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxy[(3 * j) + (3 * kj)] = at2 * zt1;\n    fxy[(1 + (3 * j)) + (3 * kj)] = at3 * zt1;\n    fxy[(2 + (3 * j)) + (3 * kj)] = zero;\n    fxy[(3 * j) + (3 * k1)] = at2 * zt2;\n    fxy[(1 + (3 * j)) + (3 * k1)] = (-at3) * zt2;\n    fxy[(2 + (3 * j)) + (3 * k1)] = zero;\n    wp += at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n  }\n\n  at1 = crealf(ffc[kk]) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = cimagf(q[kj]) - (crealf(q[kj]) * _Complex_I);\n  fxy[3 * kj] = zero;\n  fxy[1 + (3 * kj)] = at3 * zt1;\n  fxy[2 + (3 * kj)] = zero;\n  fxy[3 * k1] = zero;\n  fxy[1 + (3 * k1)] = zero;\n  fxy[2 + (3 * k1)] = zero;\n  wp += at1 * (q[kj] * conjf(q[kj]));\n  sum1 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum1)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/8"}
{"code": "for (int i = 0; i < out->height; i++)\n{\n  for (unsigned j = 0; j < out->width; j++)\n  {\n    out->pixelData[(i * out->width) + j] = (((image->pixelData[ID(i * 2, j * 2)] + image->pixelData[ID((i * 2) + 1, j * 2)]) + image->pixelData[ID(i * 2, (j * 2) + 1)]) + image->pixelData[ID((i * 2) + 1, (j * 2) + 1)]) / 4;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apardyl/raytracer/CUDA-RayTracer/backends/post_processing/SuperSampler/0"}
{"code": "for (i3 = 1; i3 < (n3 - 1); i3++)\n{\n  for (i2 = 1; i2 < (n2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < n1; i1++)\n    {\n      u1[i1] = ((u[i3][i2 - 1][i1] + u[i3][i2 + 1][i1]) + u[i3 - 1][i2][i1]) + u[i3 + 1][i2][i1];\n      u2[i1] = ((u[i3 - 1][i2 - 1][i1] + u[i3 - 1][i2 + 1][i1]) + u[i3 + 1][i2 - 1][i1]) + u[i3 + 1][i2 + 1][i1];\n    }\n\n    for (i1 = 1; i1 < (n1 - 1); i1++)\n    {\n      r[i3][i2][i1] = ((v[i3][i2][i1] - (a[0] * u[i3][i2][i1])) - (a[2] * ((u2[i1] + u1[i1 - 1]) + u1[i1 + 1]))) - (a[3] * (u2[i1 - 1] + u2[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/11"}
{"code": "for (int i = 1; i <= ITERATIONS; i++)\n{\n  x = multiplication(_matrix, x, _column_size, NUMBER_THREADS);\n  char outfile_name[256];\n  sprintf(outfile_name, \"CSCOpenMPVec%d.txt\", i);\n  FILE *fp;\n  fp = fopen(outfile_name, \"w\");\n  for (int k = 0; k < _column_size; k++)\n    fprintf(fp, \"%lf\\n\", x[k]);\n\n  fclose(fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/6"}
{"code": "for (i = 0; i < ((2 * n) - 1); ++i)\n{\n  if (R[i])\n  {\n    free(R[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alexgrigoras/parallel_algorithms/Lab 7/Lab7_p1_openmp/Hello_parallel/main/8"}
{"code": "for (j = 0; j <= i; j++)\n{\n  k = i - j;\n  x = i % 3;\n  if ((k == 0) && (j == 0))\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = 0;\n\n  }\n  else\n    if (k == 0)\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = a[(i - 1) % 3][j - 1];\n\n  }\n  else\n    if (j == 0)\n  {\n    if (X[k] == Y[j])\n      a[x][j] = 1;\n    else\n      a[x][j] = a[(i - 1) % 3][j];\n\n  }\n  else\n  {\n    if (X[k] == Y[j])\n      a[x][j] = a[(i - 2) % 3][j - 1] + 1;\n    else\n      a[x][j] = (a[(i - 1) % 3][j] >= a[(i - 1) % 3][j - 1]) ? (a[(i - 1) % 3][j]) : (a[(i - 1) % 3][j - 1]);\n\n  }\n\n\n\n}\n\n", "pragma": "omp parallel for private(j,k,x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_cache_improved/0"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    (cout << U[i][j]) << \"  \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lixueclaire/Parallel-SVD/OMP_SVD/7"}
{"code": "for (int i = 0; i < N; i++)\n{\n  globalBoard[i] = (int *) malloc(N * (sizeof(int)));\n  for (int j = 0; j < N; j++)\n  {\n    int temp = rand() % 3;\n    switch (temp)\n    {\n      case 0:\n        globalBoard[i][j] = 0;\n        break;\n\n      case 1:\n        globalBoard[i][j] = 1;\n        break;\n\n      case 2:\n        globalBoard[i][j] = 2;\n        break;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/qazwse/RedBlueOpenMP/orbs/3"}
{"code": "for (int i = 0; i < t; ++i)\n{\n  sigmaTime += parallelMatrixProduct(a, b, c, n, k, m);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/4/matrixMultiplication/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Fib[%lld] = %lld\\n\", i, fib(i));\n}\n\n", "pragma": "omp parallel for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/add19/Parallel-Programming/parallel_fib/0"}
{"code": "for (int i = 0; i < MAX_DEPTH; i++)\n{\n  int local_size = all_nodes[i];\n  int global_size;\n  MPI_Allreduce(&local_size, &global_size, 1, MPI_INT, MPI_SUM, comm);\n  if (!myrank)\n    (cout << global_size) << ' ';\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arashb/tbslas/src/applications/src/kernel_tst/3"}
{"code": "for (int i = 0; i < ncol; ++i)\n{\n  if (cast_vec->vec_[i] != ((static_cast < ValueType) > 0))\n  {\n    ++nnz_idx;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/124"}
{"code": "for (i = 0; i < n_threads; i++)\n{\n  buckets[i] = all_buckets + (i * n_buckets);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Wicz3k/MPR_OpenMP/zad_2/main_alg_3/2"}
{"code": "for (iterator LIter = L.begin(); LIter != L.end(); LIter++)\n{\n  elements.push_back(LIter);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BaoVo96/Apriori/apriori_v2_omp_final/4"}
{"code": "for (j = 1; j <= (naa + 1); j++)\n{\n  q[j] = 0.0;\n  z[j] = 0.0;\n  r[j] = x[j];\n  p[j] = x[j];\n  w[j] = 0.0;\n}\n\n", "pragma": "omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/grypp/NPB2.3-OpenMP-ACC/CG/cg_macc/5"}
{"code": "for (k = 0; k < n_clus; k++)\n{\n  for (ch = 0; ch < n_ch; ch++)\n  {\n    centers[(k * n_ch) + ch] = 0;\n  }\n\n  counts[k] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gabrielemirando/image-segmentation/src/segmentation_omp/6"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  color id = {.red = randomNumber(0.f, 0.15f) + 0.1f, .green = randomNumber(0.f, 0.14f) + 0.0f, .blue = randomNumber(0.f, 0.16f) + 0.0f};\n  floatvector initialPosition = {.x = (1024 / 2) - randomNumber(50, 320), .y = (1024 / 2) - randomNumber(50, 320)};\n  initialPosition.x = (((i / 2) % 2) == 0) ? (initialPosition.x) : (1024 - initialPosition.x);\n  initialPosition.y = (i < (64 / 2)) ? (initialPosition.y) : (1024 - initialPosition.y);\n  floatvector positionToBlackHole = {.x = initialPosition.x - (1024 / 2), .y = initialPosition.y - (1024 / 2)};\n  float distance = (0.06 + randomNumber(-0.01f, 0.01f)) / sqrt((positionToBlackHole.x * positionToBlackHole.x) + (positionToBlackHole.y * positionToBlackHole.y));\n  floatvector initialVelocity = {.x = distance * (-positionToBlackHole.y), .y = distance * positionToBlackHole.x};\n  if ((i % 2) == 0)\n  {\n    initialVelocity.x = -initialVelocity.x;\n    initialVelocity.y = -initialVelocity.y;\n  }\n\n  satelite tmpSatelite = {.identifier = id, .position = initialPosition, .velocity = initialVelocity};\n  satelites[i] = tmpSatelite;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/10"}
{"code": "for (i = 0; i < idx_nonmatching_len; i++)\n{\n  extrinsic_data(ptr_idx_nonmatching->get(i)) = (Viterbi_scaling_factor[1] * ((2.0 * extrinsic_data(ptr_idx_nonmatching->get(i))) - 1.0)) * LLR;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/12"}
{"code": "for (int i = 0; i < 500; i++)\n{\n  y[i] = 0.0;\n  for (int j = 0; j < 500; j++)\n  {\n    y[i] = a[i][j] * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(THREAD_COUNT) default(none) shared(a, x, y)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/karan9360/openmp_matrix/Assignment3 /2d/2d/0"}
{"code": "for (int i = (N / 3) * 2; i < N; i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/6"}
{"code": "for (j = 0; j < LX1; j++)\n{\n  for (i = 0; i < LX1; i++)\n  {\n    dxtm1_2[j][i] = dxtm1[j][i] * dxtm1[j][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/precond/6"}
{"code": "for (; (p < Size) && (InitData32[p - 1] <= InitData32[p]); p++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DualSPHysics/DualSPHysics/src/source/JRadixSort/16"}
{"code": "for (int np = 0; np < nProj; np++)\n{\n  pad_projections(d_pProj, nDetXMap, nDetYMap, nDetXMap, np);\n  d_pProj_tmp = (d_pProj + ((nDetXMap * nDetYMap) * np)) + 1;\n  memset(d_pProj_tmp, 0, nPixY * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/ddbp-omp/main/9"}
{"code": "for (unsigned i = 0; i < n; ++i)\n{\n  total += a[i];\n}\n\n", "pragma": "omp parallel for reduction (+:total)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jgmatu/PPAP/1/main/1"}
{"code": "for (iterator p = _collisionsOfNextTraversal[particleB.getGlobalParticleID()].begin(); p != _collisionsOfNextTraversal[particleB.getGlobalParticleID()].end(); p++)\n{\n  if (p->_copyOfPartnerParticle.getGlobalParticleID() == particleA.getGlobalParticleID())\n  {\n    dataSetB = &(*p);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KonstantinosKr/delta/delta/core/Engine/1"}
{"code": "for (row = 0; row < rows; row++)\n{\n  long length = row_lengths[row];\n  split_seq(b[row], 0, length, vector[row]);\n}\n\n", "pragma": "omp parallel for num_threads(DATA_THREADS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kianenigma/pmms-heat-dissipation/assignment_2/vecsort/vecsort/0"}
{"code": "for (i = 0; i < (NODESX + 2); i++)\n  for (j = 0; j < (NODESY + 2); j++)\n  TOPO[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/126"}
{"code": "for (i = 0; i < 100; i++)\n  for (k = 0; k < 100; k++)\n  for (j = 0; j < 100; j++)\n  printf(\"%lf %lf %lf\\n\", c[i][j], a[i][k], b[k][j]);\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB060-matrixmultiply-orig-no/6"}
{"code": "for (int ii = 0; ii < fSize; ++ii)\n{\n  zeroReal3(s->atoms->f[ii]);\n  s->atoms->U[ii] = 0.;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/CoMD/src-omp-task-deps/ljForce/0"}
{"code": "for (size_t i = 0; i < max; i++)\n{\n  for (size_t j = 2; j < i; j++)\n  {\n    if ((i % j) == 0)\n      goto not_a_prime;\n\n  }\n\n  primes.push_back(i);\n  not_a_prime:\n  ;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stride-Apollo/proto-TBB/proto1/0"}
{"code": "for (int i = 0; i < 1024; ++i)\n  counts_team += 1;\n\n", "pragma": "omp for reduction(+: counts_team)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/application_kernels/reduction_separated_directives/0"}
{"code": "for (int i = 0; i < xelem; i++)\n{\n  for (int j = 0; j < yelem; j++)\n  {\n    sclr.u[i][j][0] = (-pow(sin(PI * x[i][j]), 2.0)) * sin((2.0 * PI) * y[i][j]);\n    sclr.v[i][j][0] = pow(sin(PI * y[i][j]), 2.0) * sin((2.0 * PI) * x[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jichenglee/INS_LevelSet/NE577/main/3"}
{"code": "for (int j = 0; j < N; j = j + 1)\n{\n  sum3 += a[j];\n  sum4 += a[j];\n}\n\n", "pragma": "omp target teams distribute parallel for map(tofrom:sum3,sum4) reduction(+:sum3,sum4)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/xteam-red-1/xteam_red_1/2"}
{"code": "for (j = 0; j < 10000; j++)\n{\n  for (i = 0; i < 10000; i++)\n  {\n    A[i + (10000 * j)] = sin(0.01 * (i + (10000 * j)));\n  }\n\n  b[j] = cos(0.01 * j);\n  x[j] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DhavalNiphade/Parallel-Matrix-Vector-Products/matrix/1"}
{"code": "for (int i = 0; i < probs.size(); ++i)\n{\n  probs[i] /= cur_w;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ctiely/gbdt/tree/ClassificationTree/6"}
{"code": "for (k = -1; k < 2; k++)\n  for (l = -1; l < 2; l++)\n  if (A[(((i + k) * n) + j) + l] > max)\n  max = A[(((i + k) * n) + j) + l];\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rescurib/Notas_Computo_Paralelo/MemoriaCompartida/Sec_03/Ejemplo_3_3_OpenMP/1"}
{"code": "for (size_t j = i + 1; j < M; j++)\n{\n  swap(val[(i * M) + j], val[(j * M) + i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ricosjp/monolish/src/utils/transpose/transpose_dense/0"}
{"code": "for (i = 0; i < 302; i++)\n{\n  if ((i < 256) || (i > 768))\n    solution[cur_gen][i][0] = solution[cur_gen][i][1];\n  else\n    solution[cur_gen][i][0] = 20.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/moreandres/hotspot/tests/examples/heat2d/heat2d/3"}
{"code": "for (i = 0; i < 500; i++)\n{\n  for (j = 0; j < 500; j++)\n    for (k = 0; k < 500; k++)\n    c[i][j] += a[i][k] * b[k][j];\n\n\n}\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixMul/matrixMul_openMP/3"}
{"code": "for (int i = 0; i < l; i++)\n{\n  printf(\"%d \", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MariyaFilippova/Parprog-MIPT/tasks/massiv/task_dop/3"}
{"code": "for (i = 0; i < 8192; i++)\n  for (j = 0; j < 8192; j++)\n  x1[i] += a[(i * 8192) + j] * y1[j];\n\n\n", "pragma": "omp parallel for collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task10/mvt_parallel/4"}
{"code": "for (int i = 0; i < m; i++)\n{\n  Y_serial[i] = 0.0;\n  for (int j = 0; j < n; j++)\n  {\n    Y_serial[i] += A[i][j] * X[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture7/MatrixVectorMultiplication/MatrixVectorMultiplication/0"}
{"code": "for (int i = 0; i < a; i++)\n{\n  for (int j = 0; j < c; j++)\n  {\n    suma = 0;\n    for (int k = 0; k < b; k++)\n    {\n      suma = suma + (vector[i][k] * matriz[k][j]);\n    }\n\n    resultado[i][j] = suma;\n  }\n\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ejovanihh191197/MatrizXmatrizOpenMP/matrizxmatriz/1"}
{"code": "for (int i = 1; i < size; i++)\n{\n  if (visited[i] == 0)\n  {\n    int temp = curr_bound;\n    curr_weight += adj[curr_path[level - 1]][i];\n    curr_bound -= ((*((*second_mins) + curr_path[level - 1])) + (*((*first_mins) + i))) / 2;\n    if ((curr_bound + curr_weight) < final_res)\n    {\n      curr_path[level] = i;\n      visited[i] = 1;\n      recursion(size, adj, curr_bound, curr_weight, level + 1, curr_path, visited, first_mins, second_mins);\n    }\n\n    curr_bound = temp;\n    curr_weight -= adj[curr_path[level - 1]][i];\n    visited[i] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimitris23bp/Parallel-Traveling-Salesman/openmp_for/1"}
{"code": "for (i = 0; i < 1000; i++)\n  for (j = 0; j < 1000; j++)\n  Q[i][j] = (0.001 * i) * j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.4/1"}
{"code": "for (int frame = mid_frame; frame < to_frame; frame++)\n{\n  delta = (Delta * 0.99) * pow(0.99, frame);\n  const double xMin = xMid - delta;\n  const double yMin = yMid - delta;\n  const double dw = (2.0 * delta) / width;\n  for (int row = 0; row < width; row++)\n  {\n    const double cy = (-yMin) - (row * dw);\n    for (int col = 0; col < width; col++)\n    {\n      const double cx = (-xMin) - (col * dw);\n      double x = cx;\n      double y = cy;\n      int depth = 256;\n      double x2;\n      double y2;\n      do\n      {\n        x2 = x * x;\n        y2 = y * y;\n        y = ((2 * x) * y) + cy;\n        x = (x2 - y2) + cx;\n        depth--;\n      }\n      while ((depth > 0) && ((x2 + y2) < 5.0));\n      pic[(((frame * width) * width) + (row * width)) + col] = (unsigned char) depth;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/diegoloya/Hybrid_OMP_CUDA_MPI/fractal_hyb2/0"}
{"code": "for (j = 0; j < n; j++)\n{\n  kRow[j] = matrix[(localK * n) + j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firaja/Parallel-FloydWarshall/hybrid/4"}
{"code": "for (int64_t i = 0; i < n; ++i)\n  order[start[level[i]]++] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ddemidov/ilu_solve/ilu_solve/14"}
{"code": "for (i = 0; i < 2; ++i)\n{\n  ;\n}\n\n", "pragma": "#pragma omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_private_codegen/0"}
{"code": "for (int i = 0; i < falseSeedLocations.size(); i++)\n  lattice.at(falseSeedLocations.at(i)) = 3;\n\n", "pragma": "\t\t\t#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tunnellm/OpenMP-Crystal-Growth/main/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; i++)\n  {\n    A[i][j] = rand() % 50;\n    B[i][j] = rand() % 50;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/TP/TP5/ex3/2"}
{"code": "for (int i = 0; i < IT_END; i++)\n{\n  arr[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rutgers-apl/omp-racer/tests/microbenchmarks/contention_test/test_1/0"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  ma = max(ma, fabs(A[i][i]));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/11"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  (cout << i) << '\\n';\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abdelrahim-hentabli/image_convolution/src/main/0"}
{"code": "for (int i = 0; i < 10000; i++)\n{\n  t6 = omp_get_wtime();\n  TD1[i] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n  printf(\"Thread number %d fill this portion [%d] of table \\n\", omp_get_thread_num(), i);\n  t7 = omp_get_wtime() - t6;\n  printf(\"La charge du thread [%d] = %f \\n\", omp_get_thread_num(), t7 / nb_threads);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice5.1/1"}
{"code": "for (j = 0; j < (num_bodies - 1); j++)\n{\n  for (k = j + 1; k < num_bodies; k++)\n  {\n    r.x = pos[k].x - pos[j].x;\n    r.y = pos[k].y - pos[j].y;\n    r.z = pos[k].z - pos[j].z;\n    dist = sqrt(((r.x * r.x) + (r.y * r.y)) + (r.z * r.z));\n    if (dist <= (2 * body_radius))\n    {\n      temp = vel[j];\n      vel[j] = vel[k];\n      vel[k] = temp;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejasPote/N-Body-OpenMP/many_body_sim_program/2"}
{"code": "for (i = 0; i < matSize; i++)\n{\n  for (j = 0; j < matSize; j++)\n  {\n    fprintf(stderr, \"%15.5f \", oldA[(i * matSize) + j]);\n  }\n\n  cerr << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/example/Stencil/Blocks/TPParallelism/utils/1"}
{"code": "for (int nbcpu = 1; nbcpu <= maxthreads; nbcpu++)\n{\n  omp_set_num_threads(nbcpu);\n  ((cout << \"number of threads : \") << nbcpu) << endl;\n  int res_static;\n  double t0 = omp_get_wtime();\n  res_static = cmbpremier_s(parameter);\n  double t1 = omp_get_wtime();\n  double time_static = t1 - t0;\n  int res_dynamic;\n  double t2 = omp_get_wtime();\n  res_dynamic = cmbpremier_d(parameter);\n  double t3 = omp_get_wtime();\n  double time_dynamic = t3 - t2;\n  ((cout << \"time spent static :\") << time_static) << endl;\n  ((cout << \"result schedule static :\") << res_static) << endl;\n  ((cout << \"time spent dynamic :\") << time_dynamic) << endl;\n  ((cout << \"result schedule dynamic :\") << res_dynamic) << endl;\n  fprintf(fo1, \"%d %f %f\\n\", nbcpu, time_static, time_dynamic);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Enzoupi/TP_OpenMP/LE_BOUEDEC/premier/premier_v2/0"}
{"code": "for (i = 0; i < P; i++)\n{\n  for (j = i * blockSize; j < ((i + 1) * blockSize); j++)\n    if (a[j] > max[i])\n    max[i] = a[j];\n\n\n  compress(b + (i * blockSize), a + (i * blockSize), count + i, dictSize + i, blockSize, max[i]);\n  disp[i] = blockSize * i;\n  dataSend[i * 3] = dictSize[i];\n  dataSend[(i * 3) + 1] = count[i];\n  dataSend[(i * 3) + 2] = max[i];\n}\n\n", "pragma": "omp parallel for private(j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Hubble83/hybrid-distance-transform/src/dt/5"}
{"code": "for (i = 1; i <= 46; i += 1)\n{\n  R46 = 0.50 * R46;\n  T46 = 2.0 * T46;\n}\n\n", "pragma": "omp parallel for private (i) reduction (*:R46,T46)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/IS/is/1"}
{"code": "for (i = 3; i <= (grid_points[0] - 4); i++)\n{\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((((ue[m][i - 2] - (4.0 * ue[m][i - 1])) + (6.0 * ue[m][i])) - (4.0 * ue[m][i + 1])) + ue[m][i + 2]));\n}\n\n", "pragma": "omp parallel for firstprivate(i ,dssp ,m ,j ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/20"}
{"code": "for (int i = 0; i < colNumX; i++)\n{\n  XmatVecTemp = Xmat.col(i);\n  Sigma_iX1.col(i) = getPCG1ofSigmaAndVector(wVec, tauVec, XmatVecTemp, maxiterPCG, tolPCG);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/14"}
{"code": "for (int i = 1000000; i > 0; i--)\n{\n  if (steps(i) > value)\n  {\n    value = steps(i);\n    tmp = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zinedburak/Project_Euler_Questions_with_OpenMp/ex14projecteuler/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmpbkk0y1_d.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pepperpots/llvm-project-openmp/runtime/test/affinity/format/affinity_values/5"}
{"code": "for (int kk = kk_min; kk < kk_max; kk++)\n{\n  for (int jj = jj_min; jj < jj_max; jj++)\n  {\n    for (int ii = ii_min; ii < ii_max; ii++)\n    {\n      ngh = evaluate_array3d_bndy(array3d, N, ii - 1, jj, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii + 1, jj, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj - 1, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj + 1, kk, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj, kk - 1, recvarray);\n      ngh += evaluate_array3d_bndy(array3d, N, ii, jj, kk + 1, recvarray);\n      value = (((h * h) * evaluate_array3d(fluxfct, N, ii, jj, kk)) + ngh) / 6.;\n      fill_array3d(buffer, N, ii, jj, kk, ((1. - omega) * evaluate_array3d(array3d, N, ii, jj, kk)) + (omega * value));\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for private( value, ngh ) nowait ", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/smoother7p/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  if (bits[i] == 1)\n  {\n    result = 1;\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/y-gupta/col757-ass1/q1/0"}
{"code": "for (i = 1; i < (counter + 1); i++)\n{\n  MPI_Send(&zeroVector[i - 1], 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n  MPI_Send(&zeroVector[i], 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n  MPI_Send(&amount, 1, MPI_INT, i, 0, MPI_COMM_WORLD);\n  MPI_Send(observation + amount, zeroVector[i] - amount, MPI_FLOAT, i, 0, MPI_COMM_WORLD);\n  amount = zeroVector[i] + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MatanShulman/ParallelComputingC/Final Project/InitialMPIproject/InitialMPIproject/Initial/icpi/8"}
{"code": "for (m = 0; m < 5; m++)\n{\n  j = grid_points[1] - 3;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * (((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (6.0 * ue[m][j])) - (4.0 * ue[m][j + 1])));\n  j = grid_points[1] - 2;\n  forcing[m][i][j][k] = forcing[m][i][j][k] - (dssp * ((ue[m][j - 2] - (4.0 * ue[m][j - 1])) + (5.0 * ue[m][j])));\n}\n\n", "pragma": "omp parallel for firstprivate(dssp ,j ,m ,i ,k )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/28"}
{"code": "for (i = 0; i < 500; i++)\n{\n  fwrite(&autoc_h[i], 1, sizeof(float), file_out);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MiguelazoDS/so2-openmp/C\u00f3digos/paralelo/5"}
{"code": "for (n = nyi - 1; n < nyt; n++)\n{\n  ioff = nxhd * n;\n  for (l = 0; l < nz; l++)\n  {\n    ll = nxhyd * l;\n    l1 = (mixup[l] - 1) / nrzb;\n    if (l < l1)\n    {\n      l1 = nxhyd * l1;\n      i0 = ioff + ll;\n      i1 = ioff + l1;\n      for (i = 0; i < nxhs; i += 8)\n      {\n        v_t1 = _mm512_load_ps((float *) (&f[i + i1]));\n        v_t2 = _mm512_load_ps((float *) (&f[i + i0]));\n        _mm512_store_ps((float *) (&f[i + i1]), v_t2);\n        _mm512_store_ps((float *) (&f[i + i0]), v_t1);\n      }\n\n      for (i = nxhs; i < nxh; i++)\n      {\n        t1 = f[i + i1];\n        f[i + i1] = f[i + i0];\n        f[i + i0] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indz; l++)\n  {\n    ns2 = ns + ns;\n    km = nzh / ns;\n    kmr = km * nrz;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = nxhyd * (j + k1);\n        j2 = nxhyd * (j + k2);\n        t1 = conjf(sct[kmr * j]);\n        v_t1 = _mm512_set4_ps(cimagf(t1), crealf(t1), cimagf(t1), crealf(t1));\n        i0 = ioff + j1;\n        i1 = ioff + j2;\n        for (i = 0; i < nxhs; i += 8)\n        {\n          v_t2 = _mm512_load_ps((float *) (&f[i + i1]));\n          v_t3 = (int) _mm512_shuffle_epi32((int) v_t1, 160);\n          v_t3 = _mm512_mul_ps(v_t2, v_t3);\n          v_t2 = (int) _mm512_shuffle_epi32((int) v_t2, 177);\n          v_t4 = (int) _mm512_shuffle_epi32((int) v_t1, 245);\n          v_t4 = _mm512_mul_ps(v_t2, v_t4);\n          v_t4 = _mm512_mask_sub_ps(v_t4, _mm512_int2mask(21845), v_zero, v_t4);\n          v_t2 = _mm512_add_ps(v_t3, v_t4);\n          v_t3 = _mm512_load_ps((float *) (&f[i + i0]));\n          v_t4 = _mm512_sub_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[i + i1]), v_t4);\n          v_t4 = _mm512_add_ps(v_t3, v_t2);\n          _mm512_store_ps((float *) (&f[i + i0]), v_t4);\n        }\n\n        for (i = nxhs; i < nxh; i++)\n        {\n          t2 = t1 * f[i + i1];\n          f[i + i1] = f[i + i0] - t2;\n          f[i + i0] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,j1,j2,ll,l1,i0,i1,ioff,t1,t2, v_t1,v_t2,v_t3,v_t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic3/kncmbpush3/30"}
{"code": "for (size_t i = 0; i < centers.size(); i++)\n{\n  aabb.extend(centers[i] + Constant(radii[i]));\n  aabb.extend(centers[i] - Constant(radii[i]));\n  rMin = min(rMin, radii[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Azeko2xo/woodem/pkg/dem/Clump/1"}
{"code": "for (int i = 0; i < r1; ++i)\n{\n  for (int j = 0; j < c2; ++j)\n  {\n    int temp = 0;\n    for (int k = 0; k < c1; ++k)\n    {\n      temp += a[k + (i * c1)] * b[j + (k * c2)];\n    }\n\n    c[j + (i * c3)] = temp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_matrix_multiplication/c1/matmul/0"}
{"code": "for (int i = 0; i < _vpnts.size(); i++)\n{\n  for (int j = 0; j < _vpnts[i].size(); j++)\n  {\n    Point *pnt_ij = _vpnts[i][j];\n    double x_ij = pnt_ij->x;\n    double y_ij = pnt_ij->y;\n    int size = _vpnts[i].size();\n    for (int n = j + 1; n < size; n++)\n    {\n      if ((_vpnts[i][n]->y - y_ij) > r)\n        break;\n\n      double d = pnt_ij->calcDist(_vpnts[i][n]);\n      if (d < r)\n      {\n        double wij = edge->ripleyCorrection(pnt_ij, d);\n        double wji = edge->ripleyCorrection(_vpnts[i][n], d);\n        double wtot = wij + wji;\n        sum += wtot;\n      }\n\n    }\n\n    for (int m = i + 1; m < _vpnts.size(); m++)\n    {\n      if (((_vpnts[m][0]->x - F) - x_ij) > r)\n        break;\n\n      int size = _vpnts[m].size();\n      double y_min = _vpnts[m][0]->y;\n      double y_max = _vpnts[m][size - 1]->y;\n      int start = min(j, size - 1);\n      for (int n = start; n < size; n++)\n      {\n        if ((_vpnts[m][n]->y - y_ij) > r)\n          break;\n\n        double d = pnt_ij->calcDist(_vpnts[m][n]);\n        if (d < r)\n        {\n          double wij = edge->ripleyCorrection(pnt_ij, d);\n          double wji = edge->ripleyCorrection(_vpnts[m][n], d);\n          double wtot = wij + wji;\n          sum += wtot;\n        }\n\n      }\n\n      for (int n = start - 1; n >= 0; n--)\n      {\n        if ((y_ij - _vpnts[m][n]->y) > r)\n          break;\n\n        double d = pnt_ij->calcDist(_vpnts[m][n]);\n        if (d < r)\n        {\n          double wij = edge->ripleyCorrection(pnt_ij, d);\n          double wji = edge->ripleyCorrection(_vpnts[m][n], d);\n          double wtot = wij + wji;\n          sum += wtot;\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Guiming/ParallelRipleysKfunction/spp_mpi/SpatialPointPattern/3"}
{"code": "for (i = 0; i < N; i += N / 8)\n{\n  for (j = 0; j < N; j += N / 8)\n  {\n    printf(\"%.2f \", h[0][i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/parallelx/5"}
{"code": "for (i = 0; i < image->n_images; i++)\n{\n  width = image->width[i];\n  height = image->height[i];\n  pixel *pi = p[i];\n  int rank = 0;\n  rank = omp_get_thread_num();\n  apply_gray_filter(width, height, pi);\n  apply_blur_filter(width, height, pi, 5, 20);\n  apply_sobel_filter(width, height, pi);\n}\n\n", "pragma": "omp for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fabrizio-indirli/sobel-parallel/src/mpi_mode_0/0"}
{"code": "for (i = 0; i < l; i++)\n  alpha[i] *= y[i] / r;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/30"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  host_b = host_b | a[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitor/2"}
{"code": "for (i = 0; i <= 7; i += 1)\n{\n  fscanf(fp, \"%d\", &debug_vec[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/MG/mg/12"}
{"code": "for (unsigned long row = 0; row < rowLimit; ++row)\n  for (unsigned long column = 0; column < columnLimit; ++column)\n  subMatrix(row, column) = (*this)(rowStart + row, columnStart + column);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ShariqueMohd/Parallel-Image-Compression-using-PCA/DenseMatrix/2"}
{"code": "for (i = 0; i < numRows; i++)\n{\n  for (j = 0; j < numCols; j++)\n    array[i][j] = ((int) rand()) % 100;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShoeShi/Parallel-Programming-Samples/1OpenMPColumnWiseMat/main/3"}
{"code": "for (int i = 0; i < (tamanho + 2); i++)\n{\n  tabuleiro[i] = (char *) calloc(tamanho + 2, sizeof(char));\n  novoTabuleiro[i] = (char *) calloc(tamanho + 2, sizeof(char));\n  antigoTabuleiro[i] = (char *) calloc(tamanho + 2, sizeof(char));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucastavaresuerj/openMP/novo_jogo_da_vida/jogo/4"}
{"code": "for (int row_count = 0; row_count < lineHeight(); row_count++)\n{\n  for (int pixel_count = 0; pixel_count < strip.width(); pixel_count++)\n  {\n    const uint16_t *line_buf = nullptr;\n    switch (CFA[row_count][pixel_count % 6])\n    {\n      case RED:\n        line_buf = lineBufR[row_count >> 1];\n        break;\n\n      case GREEN:\n        line_buf = lineBufG[row_count];\n        break;\n\n      case BLUE:\n        line_buf = lineBufB[row_count >> 1];\n        break;\n\n      default:\n        __builtin_unreachable();\n\n    }\n\n    out(strip.offsetY(cur_line) + row_count, strip.offsetX() + pixel_count) = line_buf[idx(pixel_count)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/FujiDecompressor/5"}
{"code": "for (int i = 0; i < rows; ++i)\n{\n  prewittX[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/llama95/Parallel_Programming/Patterns/stencil/openmp/7"}
{"code": "for (int i = 0; i < 9; i++)\n{\n  for (int j = 0; j < 9; j++)\n  {\n    printf(\"\\t%d\", table[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/toful/ParallelSudokuSolver/src/OpenMP/P1.2_CPM_ElAzizi_Dauden/2"}
{"code": "for (unsigned int i = 0; i < path_array.size(); ++i)\n{\n  print_path_and_values(path_array.at(i), mapa);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/18"}
{"code": "for (int i = 0; i < tamanho; i++)\n{\n  aux += \"\uffec\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RolfAF/dna/dna/10"}
{"code": "for (i = 0; i < x; i++)\n{\n  p += a * i;\n  p = p / i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/dlb/doc/examples/mpi+omp/mpi_omp_pils/1"}
{"code": "for (i = 0; i < rows; i++)\n  for (j = 0; j < cols; j++)\n  if (a[i][j] != b[i][j])\n  abort();\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.51.3/3"}
{"code": "for (i = k + 1; i < n; i++)\n{\n  temp = pivot * a[i][k];\n  for (j = k; j < n; j++)\n  {\n    a[i][j] = a[i][j] + (temp * a[k][j]);\n    lwr[i][j] = (-1.0) * temp;\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for shared(k, pivot, a, n, lwr) private(i, j, temp) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clamslam12/LUdecomposition/ludecomp/1"}
{"code": "for (int i = 0; i < 3; i++)\n{\n  for (int j = 0; j < 3; j++)\n  {\n    matriz_A[i][j] = (i + j) + 1;\n    matriz_B[j][i] = j + 2;\n    matriz_result[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Pamgerber/Threads_Paralelismo/matriz_openmp/4"}
{"code": "for (irow = 0; irow < scatter_sz; irow++)\n{\n  printf(\"Thread id: %d with processor rank: %d\\n\", omp_get_thread_num(), rank_id);\n  MyFinalVector[irow] = 0;\n  index = irow * num_cols;\n  for (icol = 0; icol < num_cols; icol++)\n    MyFinalVector[irow] += Mybuffer[index++] * Vector[icol];\n\n}\n\n", "pragma": "omp parallel for private(index,icol,iam)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/hybrid_matrix_multiply/0"}
{"code": "for (int j = 0; j < THREADS; ++j)\n{\n  float currentScore = candidateScore(&decrypted[ENCRYPTEDLEN * j], scores);\n  scoreHistory[j] = currentScore;\n  if (currentScore < bestScore)\n  {\n    bestScore = currentScore;\n    bestCandidate = j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/columnarSolver-omp/main/4"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    fac1 = 1. / lhs[n + 2][i][j][k];\n    lhs[n + 3][i][j][k] = fac1 * lhs[n + 3][i][j][k];\n    lhs[n + 4][i][j][k] = fac1 * lhs[n + 4][i][j][k];\n    rhs[m][i][j][k] = fac1 * rhs[m][i][j][k];\n    lhs[n + 2][i][j][k1] = lhs[n + 2][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 3][i][j][k]);\n    lhs[n + 3][i][j][k1] = lhs[n + 3][i][j][k1] - (lhs[n + 1][i][j][k1] * lhs[n + 4][i][j][k]);\n    rhs[m][i][j][k1] = rhs[m][i][j][k1] - (lhs[n + 1][i][j][k1] * rhs[m][i][j][k]);\n    fac2 = 1. / lhs[n + 2][i][j][k1];\n    rhs[m][i][j][k1] = fac2 * rhs[m][i][j][k1];\n  }\n\n}\n\n", "pragma": "omp parallel for private (fac1,fac2,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/213"}
{"code": "for (size_t ii = 0; ii < ((plength * pwidth) * pheight); ++ii)\n  temp_cpk_model[ii] = cpk_model[ii];\n\n", "pragma": "#pragma omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebastiandaberdaku/VoxMeshSurfOpenMP/src/MolecularSurface/MolecularSurface/1"}
{"code": "for (int mycol = 0; mycol < SIZE; mycol++)\n{\n  if (mycol != uniquecol)\n    possiblevalues[row][mycol][num] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aerron/sudoku_openmp_c_2017/sudoku/8"}
{"code": "for (i_imopVarPre84 = ist; i_imopVarPre84 <= iend; i_imopVarPre84++)\n{\n  for (j_imopVarPre85 = jst; j_imopVarPre85 <= jend; j_imopVarPre85++)\n  {\n    for (k_imopVarPre86 = 0; k_imopVarPre86 <= (nz - 1); k_imopVarPre86++)\n    {\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3];\n      u41 = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      q = (0.50 * (((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1]) + (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2])) + (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3]))) / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] * u41;\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] * u41;\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] * u41) + (0.40e+00 * (u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] - q));\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = ((1.40e+00 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4]) - (0.40e+00 * q)) * u41;\n    }\n\n    for (k_imopVarPre86 = 1; k_imopVarPre86 <= (nz - 2); k_imopVarPre86++)\n    {\n      for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n      {\n        rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (tz2 * (flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][m_imopVarPre87] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][m_imopVarPre87]));\n      }\n\n    }\n\n    for (k_imopVarPre86 = 1; k_imopVarPre86 <= (nz - 1); k_imopVarPre86++)\n    {\n      tmp_imopVarPre88 = 1.0 / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0];\n      u21k = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1];\n      u31k = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2];\n      u41k = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3];\n      u51k = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4];\n      tmp_imopVarPre88 = 1.0 / u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][0];\n      u21km1 = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][1];\n      u31km1 = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][2];\n      u41km1 = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][3];\n      u51km1 = tmp_imopVarPre88 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][4];\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = tz3 * (u21k - u21km1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = tz3 * (u31k - u31km1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = ((4.0 / 3.0) * tz3) * (u41k - u41km1);\n      flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = ((((0.50 * (1.0 - (1.40e+00 * 1.40e+00))) * tz3) * ((((u21k * u21k) + (u31k * u31k)) + (u41k * u41k)) - (((u21km1 * u21km1) + (u31km1 * u31km1)) + (u41km1 * u41km1)))) + (((1.0 / 6.0) * tz3) * ((u41k * u41k) - (u41km1 * u41km1)))) + (((1.40e+00 * 1.40e+00) * tz3) * (u51k - u51km1));\n    }\n\n    for (k_imopVarPre86 = 1; k_imopVarPre86 <= (nz - 2); k_imopVarPre86++)\n    {\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0] + ((dz1 * tz1) * ((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][0] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][0])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][0]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][1] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1]))) + ((dz2 * tz1) * ((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][1] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][1])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][1]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][2] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2]))) + ((dz3 * tz1) * ((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][2] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][2])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][2]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][3] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3]))) + ((dz4 * tz1) * ((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][3] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][3])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][3]));\n      rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] = (rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4] + (((tz3 * 1.00e-01) * 1.00e+00) * (flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][4] - flux[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4]))) + ((dz5 * tz1) * ((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][4] - (2.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][4])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][4]));\n    }\n\n    for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n    {\n      rsd[i_imopVarPre84][j_imopVarPre85][1][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][1][m_imopVarPre87] - (dssp * ((((+5.0) * u[i_imopVarPre84][j_imopVarPre85][1][m_imopVarPre87]) - (4.0 * u[i_imopVarPre84][j_imopVarPre85][2][m_imopVarPre87])) + u[i_imopVarPre84][j_imopVarPre85][3][m_imopVarPre87]));\n      rsd[i_imopVarPre84][j_imopVarPre85][2][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][2][m_imopVarPre87] - (dssp * (((((-4.0) * u[i_imopVarPre84][j_imopVarPre85][1][m_imopVarPre87]) + (6.0 * u[i_imopVarPre84][j_imopVarPre85][2][m_imopVarPre87])) - (4.0 * u[i_imopVarPre84][j_imopVarPre85][3][m_imopVarPre87])) + u[i_imopVarPre84][j_imopVarPre85][4][m_imopVarPre87]));\n    }\n\n    for (k_imopVarPre86 = 3; k_imopVarPre86 <= (nz - 4); k_imopVarPre86++)\n    {\n      for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n      {\n        rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87] - (dssp * ((((u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 2][m_imopVarPre87] - (4.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 - 1][m_imopVarPre87])) + (6.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86][m_imopVarPre87])) - (4.0 * u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 1][m_imopVarPre87])) + u[i_imopVarPre84][j_imopVarPre85][k_imopVarPre86 + 2][m_imopVarPre87]));\n      }\n\n    }\n\n    for (m_imopVarPre87 = 0; m_imopVarPre87 < 5; m_imopVarPre87++)\n    {\n      rsd[i_imopVarPre84][j_imopVarPre85][nz - 3][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][nz - 3][m_imopVarPre87] - (dssp * (((u[i_imopVarPre84][j_imopVarPre85][nz - 5][m_imopVarPre87] - (4.0 * u[i_imopVarPre84][j_imopVarPre85][nz - 4][m_imopVarPre87])) + (6.0 * u[i_imopVarPre84][j_imopVarPre85][nz - 3][m_imopVarPre87])) - (4.0 * u[i_imopVarPre84][j_imopVarPre85][nz - 2][m_imopVarPre87])));\n      rsd[i_imopVarPre84][j_imopVarPre85][nz - 2][m_imopVarPre87] = rsd[i_imopVarPre84][j_imopVarPre85][nz - 2][m_imopVarPre87] - (dssp * ((u[i_imopVarPre84][j_imopVarPre85][nz - 4][m_imopVarPre87] - (4.0 * u[i_imopVarPre84][j_imopVarPre85][nz - 3][m_imopVarPre87])) + (5.0 * u[i_imopVarPre84][j_imopVarPre85][nz - 2][m_imopVarPre87])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/LU/lu/11"}
{"code": "for (__i = 0; __i < omp_get_max_threads(); __i++)\n{\n  fprintf(stderr, \"Thread %d: %d\\n\", __i, ____num_tasks[__i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/10"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    for (int m = 0; m < j; m++)\n    {\n      inv_a[j][i] = inv_a[j][i] - (inv_a[m][i] * a[j][m]);\n    }\n\n  }\n\n  for (int j = N - 1; j >= 0; j--)\n  {\n    for (int m = j + 1; m < N; m++)\n    {\n      inv_a[j][i] = inv_a[j][i] - (inv_a[m][i] * a[j][m]);\n    }\n\n    inv_a[j][i] = inv_a[j][i] / a[j][j];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(10) shared(inv_a, a)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_decomposition/Q1/3"}
{"code": "for (int i = 0; i < m->order; i++)\n{\n  for (int j = 0; j < m->order; j++)\n  {\n    if (i <= j)\n    {\n      m->SquareMatrix[i][j] = FindElement_U(m, i, j);\n    }\n    else\n      if (i > j)\n    {\n      m->SquareMatrix[i][j] = FindElement_L(m, i, j);\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Zhihh/Parallel-Optimization-of-Matrix-Inversion/Parallel_1.0/6"}
{"code": "for (i = incrmnt; i < NARRAY; i++)\n{\n  j = i;\n  temp = v2[i];\n  while ((j >= incrmnt) && (v2[j - incrmnt] > temp))\n  {\n    v2[j] = v2[j - incrmnt];\n    j = j - incrmnt;\n  }\n\n  v2[j] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelmcs/metodos-de-ordenamiento-OPENMP/trabajofinaltodoenunoparalelo/main/6"}
{"code": "for (i = 1; i <= (n * n); i++)\n{\n  if (isPrime(i))\n  {\n    if (d < n)\n    {\n      c[d] = i;\n      d++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 3/code4/2"}
{"code": "for (int i = 0; i < NUM_THREADS; ++i)\n{\n  mthread_join(pid[i], &res);\n  tsum[i] = (int) res;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/OpenMP&Mthread-dotproduct/5"}
{"code": "for (i = 0; i < N; i++)\n{\n  resultado[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica3/ejercicio7/3"}
{"code": "for (int k = 0; k < COLUMNS; k++)\n{\n  for (int j = 0; j < COLUMNS; j++)\n  {\n    for (int i = 0; i < ROWS; i++)\n    {\n      matrix_r[i][j] += matrix_a[i][k] * matrix_b[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritaly/OWS/Projekt2_MPI/matrix_gr4/4"}
{"code": "for (int i = 0; i < argc; ++i)\n{\n  foo();\n  break;\n  continue;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/parallel_for_messages/1"}
{"code": "for (i = 0; i < resultsCount; i++)\n{\n  printf(\"%s --> Distance=%f\\n\", records[i].recString, records[i].distance);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SOLLVE/benchmarks/rodinia_3.1/openmp/nn/nn_omp/2"}
{"code": "for (int i = 0; i < s; i++)\n{\n  int a = matB[0][c];\n  for (int j = 1; j < 2; j++)\n  {\n    matB[j - 1][c] = matB[j][c];\n  }\n\n  matB[2 - 1][c] = a;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Abhiramkns/openmpi-Implementions/matmul/cmm/5"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n  vector[i][ny - 2][nz - 2] += vector[i][ny - 1][nz - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/30"}
{"code": "for (; j < rightLen; j++)\n{\n  result[i + j] = right[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zilmarij/Hybrid_MPI-OpenMP_based_Sorting/sort/13"}
{"code": "for (size_t i = startIndex; i < endIndex; i++)\n  fprintf(outfile, \"%.16g\\n\", m_pParticleData->m_vVelocityU[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/52"}
{"code": "for (i = 0; i < ARR_SIZE; i++)\n  Sorted[rank[i]] = A[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/m-fig/CISC-4335-OpenMP-Rank-Sort/rank_sort/3"}
{"code": "for (y = 0; y != height; y++)\n{\n  for (x = 0; x != width; x++)\n  {\n    *((image_t + (3 * index)) + 2) = (unsigned char) ptr_r[index];\n    *((image_t + (3 * index)) + 1) = (unsigned char) ptr_g[index];\n    *((image_t + (3 * index)) + 0) = (unsigned char) ptr_b[index];\n    index++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/minyaho/Histogram-Equalization-by-OpenMP-and-OpenCL/code_files/code_file/10"}
{"code": "for (long int i = 0; i < num; i++)\n{\n  double x = (-1) + ((((double) 2.0) * rand_r(&seed)) / RAND_MAX);\n  double y = (-1) + ((((double) 2.0) * rand_r(&seed)) / RAND_MAX);\n  if (sqrt((x * x) + (y * y)) <= 1)\n    circle++;\n\n}\n\n", "pragma": "    #pragma omp for reduction(+:circle)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chahak13/HPC/Lab3/Code and data/piCalc/piParallel2/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  tmpdbl = l[k][i];\n  l[k][i] = l[kdash][i];\n  l[kdash][i] = tmpdbl;\n}\n\n", "pragma": "#pragma omp parallel for private(tmpdbl) if(k>500)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  B[i] = 0.1 * i;\n  C[i] = (0.01 * i) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.54.2/1"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  dky = dny * ((float) k);\n  kk = nxhd * k;\n  kj = nxvh * k;\n  k1 = (nxvh * ny) - kj;\n  wp = 0.0;\n  for (j = 1; j < nxh; j++)\n  {\n    at1 = crealf(ffc[j + kk]) * cimagf(ffc[j + kk]);\n    at2 = (at1 * dnx) * ((float) j);\n    at3 = dky * at1;\n    zt1 = cimagf(q[j + kj]) - (crealf(q[j + kj]) * _Complex_I);\n    zt2 = cimagf(q[j + k1]) - (crealf(q[j + k1]) * _Complex_I);\n    fxyz[3 * (j + kj)] = at2 * zt1;\n    fxyz[1 + (3 * (j + kj))] = at3 * zt1;\n    fxyz[2 + (3 * (j + kj))] = zero;\n    fxyz[3 * (j + k1)] = at2 * zt2;\n    fxyz[1 + (3 * (j + k1))] = (-at3) * zt2;\n    fxyz[2 + (3 * (j + k1))] = zero;\n    fxyz[3 * ((j + kj) + l1)] = zero;\n    fxyz[1 + (3 * ((j + kj) + l1))] = zero;\n    fxyz[2 + (3 * ((j + kj) + l1))] = zero;\n    fxyz[3 * ((j + k1) + l1)] = zero;\n    fxyz[1 + (3 * ((j + k1) + l1))] = zero;\n    fxyz[2 + (3 * ((j + k1) + l1))] = zero;\n    wp += at1 * ((q[j + kj] * conjf(q[j + kj])) + (q[j + k1] * conjf(q[j + k1])));\n  }\n\n  at1 = crealf(ffc[kk]) * cimagf(ffc[kk]);\n  at3 = (at1 * dny) * ((float) k);\n  zt1 = cimagf(q[kj]) - (crealf(q[kj]) * _Complex_I);\n  fxyz[3 * kj] = zero;\n  fxyz[1 + (3 * kj)] = at3 * zt1;\n  fxyz[2 + (3 * kj)] = zero;\n  fxyz[3 * k1] = zero;\n  fxyz[1 + (3 * k1)] = zero;\n  fxyz[2 + (3 * k1)] = zero;\n  fxyz[3 * (kj + l1)] = zero;\n  fxyz[1 + (3 * (kj + l1))] = zero;\n  fxyz[2 + (3 * (kj + l1))] = zero;\n  fxyz[3 * (k1 + l1)] = zero;\n  fxyz[1 + (3 * (k1 + l1))] = zero;\n  fxyz[2 + (3 * (k1 + l1))] = zero;\n  wp += at1 * (q[kj] * conjf(q[kj]));\n  sum2 += wp;\n}\n\n", "pragma": "omp parallel for private(j,k,k1,kk,kj,dky,at1,at2,at3,zt1,zt2,wp) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/15"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  unsigned char master[32];\n  pbkdf2_sha1((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt[0], cur_salt->saltlen[0], cur_salt->iterations[0], master, 16, 0);\n  if (akcdecrypt(master, cur_salt->ct[0]) == 0)\n    cracked[index] = 1;\n  else\n    cracked[index] = 0;\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/agilekeychain_fmt_plug/0"}
{"code": "for (i = 0; i < len; i++)\n{\n  printf(\"%d\\n\", a[i]);\n}\n\n", "pragma": "omp parallel for simd ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_simd/dataracebench/DRB002-antidep1-var-yes/0"}
{"code": "for (int kk = 0; kk < (N + 2); kk++)\n{\n  for (int jj = 0; jj < (N + 2); jj++)\n  {\n    fill_array3d(vector_out, N, 0, jj, kk, boundarycondition3d(N, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/matvecAv/4"}
{"code": "for (i = 0; i < (orderOfMatrix * orderOfMatrix); i++)\n{\n  if (j == orderOfMatrix)\n  {\n    j = 0;\n    k++;\n  }\n\n  vetEnvioMatrix[i] = matrix[k][j];\n  j++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dupradosantini/MPI-Jacobi/jacobi-mpi/4"}
{"code": "for (j = 0; j < n; j++)\n{\n  if (kc1[j] == kc[j])\n  {\n    l++;\n  }\n\n}\n\n", "pragma": "        #pragma parallel omp for shared(j,l,kc,kc1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/satwik-m/Convex-Hull/openmp/kMeans/2"}
{"code": "for (int i = 1; i < size; i++)\n{\n  MPI_Send(&k_pxy_pgap, 3, MPI_INT, i, 1, comm);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/parallel1/2"}
{"code": "for (l = 0; l < im->nb_rows; l++)\n{\n  for (c = 0; c < im->nb_columns; c++)\n  {\n    a = x_min + (c * dx);\n    b = y_max - (l * dy);\n    x = 0;\n    y = 0;\n    i = 0;\n    while (i < nb_iter)\n    {\n      tmp = x;\n      x = ((x * x) - (y * y)) + a;\n      y = ((2 * tmp) * y) + b;\n      if (((x * x) + (y * y)) > 4)\n        break;\n      else\n        i++;\n\n    }\n\n    im->pixels[(im->nb_columns * l) + c] = (((double) i) / nb_iter) * 255;\n  }\n\n}\n\n", "pragma": "omp parallel for private(l,c,a,b,x,y,i,tmp) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taniya-kapoor/Parallel-Mandelbrot/Hybrid MPI+OMP/mpi_omp/0"}
{"code": "for (int i = 0; i < Reps; i++)\n{\n  D.zeros();\n  assignew = Assign(data, D, P, n, cov_num, strt_num, level_num, omeganew, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  diff(i) = ((-sum(data.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/25"}
{"code": "for (i = 0; i < 800; i++)\n{\n  for (j = 0; j < 800; j++)\n  {\n    A[i][j] = rand() % 10;\n    B[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pierorex/parallelism-homework/practica6/e9-par/1"}
{"code": "for (int i = 0; i < 3; i++)\n  A_inv[i] = (double *) calloc(3, sizeof(double));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/iS3D/src/cpp/emissionfunction_smooth_kernels/7"}
{"code": "for (int i = start_index; i <= end_index; i++)\n{\n  if ((A % i) == 0)\n  {\n    isDiv[i] = true;\n    count++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab6_OpenMP/Lab6_OpenMP/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  for (j = 0; j < size; j++)\n  {\n    graphNodeDelete(graph[i][j]);\n  }\n\n  free(graph[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/delivery/g13omp/life3d-omp/6"}
{"code": "for (size_t i = 0; i < m_reachUpStream[iReach].size(); ++i)\n{\n  int upReachId = m_reachUpStream[iReach][i];\n  if (upReachId >= 0)\n  {\n    int upCellsNum = m_reachs[upReachId].size();\n    int upCellId = m_reachs[upReachId][upCellsNum - 1];\n    qUp += m_qCh[upReachId][upCellsNum - 1];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology/IKW_CH/IKW_CH/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  {\n    A[i] = A[i] + 1;\n    printf(\"A[%d] is computed by thread : %d\\n\", i, thread_id);\n  }\n}\n\n", "pragma": "#pragma omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/grandma-tutorial/OpenMP-tutorial/Synchronization/example_synchronization_3/0"}
{"code": "for (i = 0; i < grid_points[0]; i++)\n{\n  for (j = 0; j < grid_points[1]; j++)\n  {\n    for (k = 0; k < grid_points[2]; k++)\n    {\n      rho_inv = 1.0 / u[i][j][k][0];\n      rho_i[i][j][k] = rho_inv;\n      us[i][j][k] = u[i][j][k][1] * rho_inv;\n      vs[i][j][k] = u[i][j][k][2] * rho_inv;\n      ws[i][j][k] = u[i][j][k][3] * rho_inv;\n      square[i][j][k] = (0.5 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) * rho_inv;\n      qs[i][j][k] = square[i][j][k] * rho_inv;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(rho_inv)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/BT/bt/26"}
{"code": "for (int i = 0; i < _vdwcalculations.size(); ++i)\n{\n  if (_cutoff)\n    if (!_vdwpairs.BitIsSet(i))\n    continue;\n\n\n  if (gradients)\n  {\n    AddGradient(_vdwcalculations[i].force_a, _vdwcalculations[i].idx_a);\n    AddGradient(_vdwcalculations[i].force_b, _vdwcalculations[i].idx_b);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/5"}
{"code": "for (ti = 0; ti < varNumF1; ti++)\n{\n  f1_layer[o][ti].U = f1_layer[o][ti].V / oldTnorm;\n  tsum = 0;\n  ttemp = f1_layer[o][ti].P;\n  for (tj = *spot; tj < numpatterns; tj++)\n  {\n    if ((tj == winner[o][0]) && (Y[o][tj].y > 0))\n      tsum += tds[ti][tj] * varNumD;\n\n  }\n\n  f1_layer[o][ti].P = f1_layer[o][ti].U + tsum;\n  tnorm += f1_layer[o][ti].P * f1_layer[o][ti].P;\n  if (fabs(ttemp - f1_layer[o][ti].P) < 0.000001)\n    tresult = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/21"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n    MEAN[i] += A[(i * n) + j];\n\n  MEAN[i] /= n;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/phramos07/taskminer/ArrayInference/tests/testP_AI/1"}
{"code": "for (j = 0; j < 100; j++)\n  a[i][j] = a[i][j] + 1;\n\n", "pragma": "omp parallel for private(j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB046-doall2-orig-no/3"}
{"code": "for (n = 1; n < N; n++)\n{\n  A_min = INFINITY;\n  A_max = 0;\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    buffer = log_add(A0[rsctrellis.prevStates[k] + ((n - 1) * rsctrellis.numStates)], A1[rsctrellis.prevStates[k + rsctrellis.numStates] + ((n - 1) * rsctrellis.numStates)]);\n    A0[k + (rsctrellis.numStates * n)] = (Lc2I[n] * rsctrellis.PARout[k]) + buffer;\n    A1[k + (rsctrellis.numStates * n)] = ((Lc1I[n] + apriori_data[n]) + (Lc2I[n] * rsctrellis.PARout[k + rsctrellis.numStates])) + buffer;\n    A_min = min(A_min, A0[k + (rsctrellis.numStates * n)]);\n    A_max = max(A_max, A0[k + (rsctrellis.numStates * n)]);\n  }\n\n  A_mid[n] = (A_min + A_max) / 2;\n  if (isinf(A_mid[n]))\n  {\n    continue;\n  }\n\n  for (k = 0; k < rsctrellis.numStates; k++)\n  {\n    A0[k + (rsctrellis.numStates * n)] -= A_mid[n];\n    A1[k + (rsctrellis.numStates * n)] -= A_mid[n];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WeileiZeng/itpp-full-Docker-Image/version1/src/itpp-4.3.1/itpp/comm/siso_rsc/2"}
{"code": "for (i = 1; i < iteration_cnt; i++)\n{\n  memcpy(&ctx1, &tmp_ctx1, (sizeof(SHA_CTX)) - (64 + (sizeof(unsigned int))));\n  SHA1_Update(&ctx1, (unsigned char *) tmp_hash, SHA_DIGEST_LENGTH);\n  SHA1_Final((unsigned char *) tmp_hash, &ctx1);\n  memcpy(&ctx2, &tmp_ctx2, (sizeof(SHA_CTX)) - (64 + (sizeof(unsigned int))));\n  SHA1_Update(&ctx2, (unsigned char *) tmp_hash, SHA_DIGEST_LENGTH);\n  SHA1_Final((unsigned char *) tmp_hash, &ctx2);\n  for (j = 0; j < 4; j++)\n    _key[j] ^= tmp_hash[j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/mscash2_fmt_plug/7"}
{"code": "for (i = 0; i < 4; ++i)\n{\n  C[i] = big_calc2(i, A);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deborasetton/cpar-openmp-mpi-examples/openmp/v11_eg01_implicit_barriers/0"}
{"code": "for (i = 1; i < num_of_clusters; i++)\n{\n  newc1[i] = newc1[i - 1] + dimension;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/Hybrid version/kmeans/17"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    A[(i * SIZE) + j] = (((DATA_TYPE) i) * j) / SIZE;\n  }\n\n  for (j = 0; j < SIZE; j++)\n  {\n    D[(i * SIZE) + j] = ((((DATA_TYPE) i) * j) + 2) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/SYRK/syrk/2"}
{"code": "for (int i = 0; i < n_octave; i++)\n  for (int j = 0; j < (n_level - 1); j++)\n{\n  subtract(pyramids[i][j], pyramids[i][j + 1], DoG[i][j]);\n}\n\n\n", "pragma": "\t#pragma omp for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zon5566/SIFT-on-OpenMP/sift/2"}
{"code": "for (i = 0; i < NFEATURES; i++)\n  ans += (pt1[i] - pt2[i]) * (pt1[i] - pt2[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/Heterogeniuses/opencl/kmeans/rmse/1"}
{"code": "for (i = 0; i < 2; i++)\n{\n  for (j = 0; j < 5; j++)\n  {\n    printf(\"thread=%d\\n\", omp_get_thread_num());\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yadneshk/Parallel-Programming-OpenMP-/collapse/0"}
{"code": "for (int i = 0; i < sizeOfItems; ++i)\n{\n  countOfItemRatings[i] = 0;\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leo-xh/Recommendation-System-Based-on-MPI-OpenMP/src/parallel-rating-based/0"}
{"code": "for (int i = 0; i < ((int) nsubranks_1d); ++i)\n{\n  compressed_counts[i].reset_to_new(((g.out_queue_last[i].bm.get_nwords() + len) - 1) / len);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/mpi/bfs_custom/25"}
{"code": "for (j = start; j < end; j++)\n{\n  {\n    vx[j] = vx[j] + dax[j];\n    vy[j] = vy[j] + day[j];\n    x[j] = x[j] + dvx[j];\n    y[j] = y[j] + dvy[j];\n  }\n}\n\n", "pragma": "omp for schedule(dynamic) num_threads(t)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/Assignment3/assignment3_5/0"}
{"code": "for (i = 1; i < (height - 1); i++)\n{\n  for (j = 1; j < (width - 1); j++)\n  {\n    applyBilateralFilter(source, filteredImage, i, j, diameter, sigmaI, sigmaS);\n  }\n\n}\n\n", "pragma": "    #pragma omp for private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mohsenMahmoodzadeh/Parallel-Gaussian-and-Bilateral-Filter-with-OpenMP-CUDA/code/omp/bilateral_omp/1"}
{"code": "for (int i = 0; i < m; i++)\n  mark[i] = 0;\n\n", "pragma": "            #pragma omp parallel for schedule(static, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/bMatching/bSuitorD/1"}
{"code": "for (int j = 0; j < m.y; j++)\n{\n  for (int i = 0; i < m.x; i++)\n  {\n    (out << m.m[i][j]) << \"\\t\";\n  }\n\n  out << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GromHoll/Kat-8sem-PP-sum/sum/1"}
{"code": "for (int mat = 0; mat < Nmats; mat++)\n{\n  for (int j = 0; j < sizey; j++)\n  {\n    for (int i = 0; i < sizex; i++)\n    {\n      double nm = n[mat];\n      if (Vf[((ncells * mat) + i) + (sizex * j)] > 0.0)\n      {\n        p[((ncells * mat) + i) + (sizex * j)] = ((nm * rho[((ncells * mat) + i) + (sizex * j)]) * t[((ncells * mat) + i) + (sizex * j)]) / Vf[((ncells * mat) + i) + (sizex * j)];\n      }\n      else\n      {\n        p[((ncells * mat) + i) + (sizex * j)] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/multimaterial-omp/full_matrix/7"}
{"code": "for (j = 0; j < max_threads; j++)\n{\n  if (active_threads[j])\n    threadsnum++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hfinkel/openmp-bgq-old/runtime/test/worksharing/for/omp_for_schedule_auto/2"}
{"code": "for (i = 1; i <= ndata; i++)\n{\n  (*funcs)(x[i], afunc, ma);\n  for (j = 1; j <= ma; j++)\n    u[i][j] = afunc[j] / sig[i];\n\n  b[i] = y[i] / sig[i];\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THREADS) if(ndata > 100) shared(funcs, x, afunc, ma, u, sig, b, y) private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reedv/Tircis/tircis_process_cmd_v4/svdfit_d/0"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bx = calc_bin(x[i], nbx, xmin, xmax, edgesx);\n  by = calc_bin(y[i], nby, ymin, ymax, edgesy);\n  bin = by + (nby * bx);\n  values_ot[bin]++;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/38"}
{"code": "for (int s = 0; s < nk; ++s)\n{\n  (bitset < 15) > (s.to_string() << endl);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_gen_15/8"}
{"code": "for (int r = lr + 1, c = lc + 1; ((r < 6) && (c < 7)) && (this->board[r][c] == player); ++r, ++c)\n{\n  down++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_root/6"}
{"code": "for (j = 1; j <= ndelta; j++)\n{\n  for (k = 0; k <= nly; k++)\n  {\n    new_dw = ((learning_rate * delta[j]) * ly[k]) + (momentum * oldw[k][j]);\n    w[k][j] += new_dw;\n    oldw[k][j] = new_dw;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PAC-P2P/BPNN-Face-Recognition-For-Parallel/src/backprop/1"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  a[i] = rand() % max_range;\n  sum += a[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aiivar/cpp-openmp-parallel-programming/main/7"}
{"code": "for (int i = 0; i < N; i++)\n{\n  (cout << result[i]) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_multiplication/Q4/3"}
{"code": "for (i = 1; i <= 1000; i += 1)\n{\n  sum0 = sum0 + i;\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:sum0)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB092-threadprivatemissing2-orig-yes/0"}
{"code": "for (j = 0; j < y; j++)\n{\n  if (dom[i][j][k] == 0)\n  {\n    tmpdy = zdy[j];\n    tmp = min_dt(zdx[i], tmpdy);\n    svel = sqrt((Gamma1 * pre[i][j][k]) / rho[i][j][k]) / tmp;\n    xvel = fabs(vx[i][j][k]) / zdx[i];\n    yvel = fabs(vy[i][j][k]) / tmpdy;\n    max_tmp2 = max_dt(svel, xvel);\n    max_tmp3 = max_dt(max_tmp2, yvel);\n    rdt1 = max_dt(max_tmp3, rdt1);\n    if (viscosity_on_off == 1)\n    {\n      temperature = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n      kin_viscosity = kinematic_viscosity(temperature, rho[i][j][k]);\n      s_visc = kin_viscosity / (tmp * tmp);\n      rdt1 = max_dt(s_visc, rdt1);\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/dt_calc/0"}
{"code": "for (j = 0; j < 40000000; j++)\n  a[j] = 2.0E0 * a[j];\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/1"}
{"code": "for (int k = 1; k <= (nk + 1); ++k)\n{\n  for (int j = 1; j <= (nj + 1); ++j)\n  {\n    for (int i = 1; i <= (ni + 1); ++i)\n    {\n      Pdqdx_4d[LOC4D(i, j, k, m)] = (-Pworksx[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n      Pdqdy_4d[LOC4D(i, j, k, m)] = (-Pworksy[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n      Pdqdz_4d[LOC4D(i, j, k, m)] = (-Pworksz[LOC3D(i, j, k)]) * Pq_4d[LOC4D(i - il1, j - jl1, k - kl1, m)];\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(dynamic)nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/glb400/Parallel-Programming/FYArray/src/main/5"}
{"code": "for (i = 0; i < size; i++)\n  for (j = 0; j < size; j++)\n  if ((data[(i * size) + k] + data[(k * size) + j]) < data[(i * size) + j])\n  data[(i * size) + j] = data[(i * size) + k] + data[(k * size) + j];\n\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daverynties/Floyd-Warshall-Algorithm-using-OpenMP/floyd_known/0"}
{"code": "for (int k = N - 1; k > 0; k--)\n{\n  for (int i = (N - k) + 1; i < (N - 1); i++)\n  {\n    int j = (((2 * N) - k) - i) + 1;\n    double u0 = u(i, j);\n    u(i, j) = 0.25 * ((((u(i - 1, j) + u(i + 1, j)) + u(i, j - 1)) + u(i, j + 1)) - ((h * h) * f(i - 1, j - 1)));\n    double d = abs(u(i, j) - u0);\n    if (d > mx[i])\n      mx[i] = d;\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(u,N,max) num_threads(1) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/untitledfelis/openMP/main/6"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesMinus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/16"}
{"code": "for (y_act = begin; y_act < end; y_act++)\n{\n  for (x_act = 0; x_act < W; x_act++)\n  {\n    fwrite(pixels[(y_act * W) + x_act], 1, sizeof(pixel_t), fp);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rochii/parallel-mandelbrot/hybrid/scripts/mandelbrot_hybrid/2"}
{"code": "for (i = 1; i <= S; i++)\n{\n  mas[i] = true;\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/df7734/OpenMPI/OpenMPI/OpenMPI/main/0"}
{"code": "for (int i = 0; i < (20 / hist_interval); i++)\n{\n  printf(\"%lu\\n\", hist_array[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulwankhede/OpenMP/parallel/3"}
{"code": "for (int i = 1; i < (nx - 1); i++)\n  vector[i][1][nz - 2] += vector[i][0][nz - 1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/communication/Com3DNonblk/32"}
{"code": "for (long long i = 0; i < n; i++)\n{\n  b[i][j] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Srutiverma123/openmp-codes/matrix product & sum/2"}
{"code": "for (j = 0; j < 150; j++)\n{\n  v_scores[j] = 0.0;\n  for (i = 0; i < 150; i++)\n  {\n    v_scores[j] += matrix[i][j] / rowsums[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joewledger/Parallel_K_Medoids/Final_Report/k_medoids/48"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  tmp[(((i * 2) * n) + n) + j] = i == j;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/Sci Lab Code in C/3.Inverse_openMP/5"}
{"code": "for (i = 0; i < cs.addlen; i++)\n  cs.add[i] = (atoi16[ARCH_INDEX(p[2 * i])] << 4) | atoi16[ARCH_INDEX(p[(2 * i) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/padlock_fmt_plug/1"}
{"code": "for (int sample = 0; sample < data.size(); ++sample)\n{\n  if (data[sample].first[split_feature] < split_point)\n    data_left.push_back(data[sample]);\n  else\n    data_right.push_back(data[sample]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/2"}
{"code": "for (int row = 0; row < 16; row++)\n  for (int col = 0; col < 16; col++)\n{\n  for (int e = 0; e < 16; ++e)\n    Cs[row][col] += As[row][e] * Bs[e][col];\n\n}\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/gridify-3/1"}
{"code": "for (long c = 0; c < ncside; c++)\n{\n  for (long l = 0; l < ncside; l++)\n  {\n    dummy[c][l] = grid[c][l];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nekrotzar/simpar/simpar-omp/0"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (int i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = 1;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp target teams distribute parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_test_out/1"}
{"code": "for (int x = 0; x < WIDTH; ++x)\n{\n  int sumR = 0;\n  int sumG = 0;\n  int sumB = 0;\n  for (int i = 0; i < SSAA; ++i)\n  {\n    for (int j = x * SSAA; j < ((x * SSAA) + SSAA); ++j)\n    {\n      sumR += SSAA_buffer[j][i][0];\n      sumG += SSAA_buffer[j][i][1];\n      sumB += SSAA_buffer[j][i][2];\n    }\n\n  }\n\n  plot_pixel(x, 0, (sumR / SSAA) / SSAA, (sumG / SSAA) / SSAA, (sumB / SSAA) / SSAA);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CyxFTS/SimpleRayTracer/hw3/0"}
{"code": "for (int i = 0; i < 500; i++)\n  for (int j = 0; j < 500; j++)\n  node3weights[i][j] = 0.25;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HridayK97/parallel-backpropagation/openmp/16"}
{"code": "for (int i = 0; i < POPULATION_SIZE; i++)\n{\n  population.push_back(get_random(start, end, rand));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RenaLL-N/OpenMP/OpenMP/OpenMP/2"}
{"code": "for (int rep = 0; rep < total_reps; rep++)\n{\n  MPI_Isend(&src_buf[0], 3, MPI_CHAR, rUleft, DIR_ULEFT, cartesian, &sendRequests[DIR_ULEFT]);\n  MPI_Isend(src_buf, blockwidth, MPI_CHAR, rUp, DIR_UP, cartesian, &sendRequests[DIR_UP]);\n  MPI_Isend(&src_buf[blockwidth - 3], 3, MPI_CHAR, rUright, DIR_URIGHT, cartesian, &sendRequests[DIR_URIGHT]);\n  MPI_Isend(src_buf, 1, type_column_rgb, rLeft, DIR_LEFT, cartesian, &sendRequests[DIR_LEFT]);\n  MPI_Isend(&src_buf[blockwidth - 3], 1, type_column_rgb, rRight, DIR_RIGHT, cartesian, &sendRequests[DIR_RIGHT]);\n  MPI_Isend(&src_buf[(blockheight - 1) * blockwidth], 3, MPI_CHAR, rDleft, DIR_DLEFT, cartesian, &sendRequests[DIR_DLEFT]);\n  MPI_Isend(&src_buf[(blockheight - 1) * blockwidth], blockwidth, MPI_CHAR, rDown, DIR_DOWN, cartesian, &sendRequests[DIR_DOWN]);\n  MPI_Isend(&src_buf[(blockheight * blockwidth) - 3], 3, MPI_CHAR, rDright, DIR_DRIGHT, cartesian, &sendRequests[DIR_DRIGHT]);\n  sendRequests[DIR_CENTER] = MPI_REQUEST_NULL;\n  MPI_Irecv(&ulCorner, 3, MPI_CHAR, rUleft, DIR_DRIGHT, cartesian, &recvRequests[DIR_ULEFT]);\n  MPI_Irecv(upRow, blockwidth, MPI_CHAR, rUp, DIR_DOWN, cartesian, &recvRequests[DIR_UP]);\n  MPI_Irecv(&urCorner, 3, MPI_CHAR, rUright, DIR_DLEFT, cartesian, &recvRequests[DIR_URIGHT]);\n  MPI_Irecv(leftCol, blockheight * 3, MPI_CHAR, rLeft, DIR_RIGHT, cartesian, &recvRequests[DIR_LEFT]);\n  MPI_Irecv(rightCol, blockheight * 3, MPI_CHAR, rRight, DIR_LEFT, cartesian, &recvRequests[DIR_RIGHT]);\n  MPI_Irecv(&dlCorner, 3, MPI_CHAR, rDleft, DIR_URIGHT, cartesian, &recvRequests[DIR_DLEFT]);\n  MPI_Irecv(downRow, blockwidth, MPI_CHAR, rDown, DIR_UP, cartesian, &recvRequests[DIR_DOWN]);\n  MPI_Irecv(&drCorner, 3, MPI_CHAR, rDright, DIR_ULEFT, cartesian, &recvRequests[DIR_DRIGHT]);\n  recvRequests[DIR_CENTER] = MPI_REQUEST_NULL;\n  for (int i = 1; i < (blockheight - 1); i++)\n    for (int l = 3; l < (blockwidth - 3); l++)\n  {\n    unsigned int offset = (i * blockwidth) + l;\n    unsigned int val = ((src_buf[(offset - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[offset - blockwidth] * filter[DIR_DOWN])) + (src_buf[(offset - blockwidth) + 3] * filter[DIR_DLEFT]);\n    ;\n    val += ((src_buf[offset] * filter[DIR_CENTER]) + (src_buf[offset - 3] * filter[DIR_RIGHT])) + (src_buf[offset + 3] * filter[DIR_LEFT]);\n    ;\n    val += ((src_buf[(offset + blockwidth) - 3] * filter[DIR_URIGHT]) + (src_buf[offset + blockwidth] * filter[DIR_UP])) + (src_buf[(offset + blockwidth) + 3] * filter[DIR_ULEFT]);\n    ;\n    val /= filt_total;\n    dest_buf[offset] = ((char) val) & 0xFF;\n  }\n\n\n  MPI_Waitall(8, recvRequests, MPI_STATUSES_IGNORE);\n  for (int i = 3; i < (blockwidth - 3); i++)\n  {\n    unsigned int val = ((src_buf[i] * filter[DIR_CENTER]) + (src_buf[i - 3] * filter[DIR_RIGHT])) + (src_buf[i + 3] * filter[DIR_LEFT]);\n    ;\n    val += ((src_buf[(i + blockwidth) - 3] * filter[DIR_URIGHT]) + (src_buf[i + blockwidth] * filter[DIR_UP])) + (src_buf[(i + blockwidth) + 3] * filter[DIR_ULEFT]);\n    ;\n    val += upRow[i - 3] * filter[DIR_DRIGHT];\n    val += upRow[i] * filter[DIR_DOWN];\n    val += upRow[i + 3] * filter[DIR_DLEFT];\n    val /= filt_total;\n    dest_buf[i] = ((char) val) & 0xFF;\n  }\n\n  unsigned int last_line = (blockheight - 1) * blockwidth;\n  for (int i = 3; i < (blockwidth - 3); i++)\n  {\n    unsigned int val = ((src_buf[((last_line + i) - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[(last_line + i) - blockwidth] * filter[DIR_DOWN])) + (src_buf[((last_line + i) - blockwidth) + 3] * filter[DIR_DLEFT]);\n    ;\n    val += ((src_buf[last_line + i] * filter[DIR_CENTER]) + (src_buf[(last_line + i) - 3] * filter[DIR_RIGHT])) + (src_buf[(last_line + i) + 3] * filter[DIR_LEFT]);\n    ;\n    val += downRow[i - 3] * filter[DIR_URIGHT];\n    val += downRow[i] * filter[DIR_UP];\n    val += downRow[i + 3] * filter[DIR_ULEFT];\n    val /= filt_total;\n    dest_buf[last_line + i] = ((char) val) & 0xFF;\n  }\n\n  unsigned int base = 0;\n  unsigned int val = 0;\n  for (unsigned char stream = 0; stream < 3; stream++)\n  {\n    for (unsigned int i = 1; i < (blockheight - 1); i++)\n    {\n      base = (i * blockwidth) + stream;\n      val = ((src_buf[base] * filter[DIR_CENTER]) + (src_buf[base - blockwidth] * filter[DIR_DOWN])) + (src_buf[base + blockwidth] * filter[DIR_UP]);\n      ;\n      val += ((src_buf[(base - blockwidth) + 3] * filter[DIR_DLEFT]) + (src_buf[base + 3] * filter[DIR_LEFT])) + (src_buf[(base + blockwidth) + 3] * filter[DIR_ULEFT]);\n      ;\n      val += leftCol[((i - 1) * 3) + stream] * filter[DIR_DRIGHT];\n      val += leftCol[(i * 3) + stream] * filter[DIR_RIGHT];\n      val += leftCol[((i + 1) * 3) + stream] * filter[DIR_URIGHT];\n      val /= filt_total;\n      dest_buf[base] = ((char) val) & 0xFF;\n    }\n\n    for (unsigned int i = 1; i < (blockheight - 1); i++)\n    {\n      base = (((i + 1) * blockwidth) - 3) + stream;\n      val = ((src_buf[base] * filter[DIR_CENTER]) + (src_buf[base - blockwidth] * filter[DIR_DOWN])) + (src_buf[base + blockwidth] * filter[DIR_UP]);\n      ;\n      val += ((src_buf[(base - blockwidth) - 3] * filter[DIR_DRIGHT]) + (src_buf[base - 1] * filter[DIR_RIGHT])) + (src_buf[(base + blockwidth) - 3] * filter[DIR_URIGHT]);\n      ;\n      val += rightCol[((i - 1) * 3) + stream] * filter[DIR_DLEFT];\n      val += rightCol[(i * 3) + stream] * filter[DIR_LEFT];\n      val += rightCol[((i + 1) * 3) + stream] * filter[DIR_ULEFT];\n      val /= filt_total;\n      dest_buf[base] = ((char) val) & 0xFF;\n    }\n\n    val = src_buf[stream] * filter[DIR_CENTER];\n    val += src_buf[stream + 3] * filter[DIR_LEFT];\n    val += src_buf[stream + blockwidth] * filter[DIR_UP];\n    val += src_buf[(stream + blockwidth) + 3] * filter[DIR_ULEFT];\n    val += upRow[stream] * filter[DIR_DOWN];\n    val += upRow[stream + 3] * filter[DIR_DLEFT];\n    val += leftCol[stream] * filter[DIR_RIGHT];\n    val += leftCol[stream + 3] * filter[DIR_URIGHT];\n    val += ulCorner[stream] * filter[DIR_DRIGHT];\n    val /= filt_total;\n    dest_buf[stream] = ((char) val) & 0xFF;\n    base = (blockwidth + stream) - 3;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base - 3] * filter[DIR_RIGHT];\n    val += src_buf[base + blockwidth] * filter[DIR_UP];\n    val += src_buf[(base + blockwidth) - 3] * filter[DIR_URIGHT];\n    val += upRow[base] * filter[DIR_DOWN];\n    val += upRow[base - 3] * filter[DIR_DRIGHT];\n    val += rightCol[stream] * filter[DIR_LEFT];\n    val += rightCol[stream + 3] * filter[DIR_ULEFT];\n    val += urCorner[stream] * filter[DIR_DLEFT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n    base = ((blockheight - 1) * blockwidth) + stream;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base + 3] * filter[DIR_LEFT];\n    val += src_buf[base - blockwidth] * filter[DIR_DOWN];\n    val += src_buf[(base - blockwidth) + 3] * filter[DIR_DLEFT];\n    val += downRow[stream] * filter[DIR_UP];\n    val += downRow[stream + 3] * filter[DIR_ULEFT];\n    val += leftCol[(blockheight + stream) - 3] * filter[DIR_RIGHT];\n    val += leftCol[(blockheight + stream) - 6] * filter[DIR_DRIGHT];\n    val += dlCorner[stream] * filter[DIR_URIGHT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n    base = ((blockheight * blockwidth) + stream) - 3;\n    val = src_buf[base] * filter[DIR_CENTER];\n    val += src_buf[base - 3] * filter[DIR_RIGHT];\n    val += src_buf[base - blockwidth] * filter[DIR_DOWN];\n    val += src_buf[(base - blockwidth) - 3] * filter[DIR_DRIGHT];\n    val += downRow[(blockwidth + stream) - 3] * filter[DIR_UP];\n    val += downRow[(blockwidth + stream) - 6] * filter[DIR_URIGHT];\n    val += rightCol[(blockheight + stream) - 3] * filter[DIR_LEFT];\n    val += rightCol[(blockheight + stream) - 6] * filter[DIR_DLEFT];\n    val += drCorner[stream] * filter[DIR_ULEFT];\n    val /= filt_total;\n    dest_buf[base] = ((char) val) & 0xFF;\n  }\n\n  MPI_Waitall(8, sendRequests, MPI_STATUSES_IGNORE);\n  unsigned char *tmp = dest_buf;\n  dest_buf = src_buf;\n  src_buf = tmp;\n  if ((rep & 31) == 31)\n  {\n    unsigned char any_diff;\n    unsigned char diff = 0;\n    for (int i = 0; i < (blockwidth * blockheight); i++)\n      if (src_buf[i] != dest_buf[i])\n    {\n      diff = 1;\n      break;\n    }\n\n\n    MPI_Reduce(&diff, &any_diff, 1, MPI_CHAR, MPI_MAX, 0, cartesian);\n    MPI_Bcast(&any_diff, 1, MPI_CHAR, 0, cartesian);\n    if (any_diff == 0)\n      break;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nikofil/convolution/mpi/convolution/3"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  if (b[i] > max)\n    max = b[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VasilyLapinsky/OpenMP_projects/Home_work_OS/Home_work_OS/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    printf(\"%.3f \", Q[(j * n) + i]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/geziogas/ParallelProgramming-Project/qr_par2/6"}
{"code": "for (int j = 0; j < graph.size(); ++j)\n{\n  for (int k = 0; k < graph.size(); ++k)\n  {\n    out[j][k] = min(out[j][k], out[j][i] + out[i][k]);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/6yryndy4una174/OpenMPtask3/OpenMPtask3/main/3"}
{"code": "for (int i = 0; i < 6; i++)\n{\n  if (jouer_coup(cs, &newPos, pos, joueur, i))\n  {\n    const int val = valeur_minimaxAB(cs, &newPos, !joueur, alpha, beta, pmax - 1, gagne);\n    if (val > alpha)\n    {\n      alpha = val;\n    }\n\n    if (alpha >= beta)\n    {\n      return alpha;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/jouer_coup_parrallel_padding/16"}
{"code": "for (int i = orig_nrows; i < m.cols(); i++)\n{\n  m.row(i).setZero();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BenjaminWang236/coen-319-paralllel-power-method-linear-solver/pageRank_power_iter_openMP/5"}
{"code": "for (t = 0; t < graph->num_vertices; t++)\n{\n  if (getBit(bitmapNC, t))\n  {\n    if (!isEnArrayQueued(Neighbors, stats->dest[t]))\n    {\n      edgeWeightUV++;\n      enArrayQueueWithBitmapAtomic(Neighbors, stats->dest[t]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/5"}
{"code": "for (i = 0; i < numOptions; i++)\n{\n  rv = fprintf(file, \"%.18f\\n\", prices[i]);\n  if (rv < 0)\n  {\n    printf(\"ERROR: Unable to write to file `%s'.\\n\", outputFile);\n    fclose(file);\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/BlackScholes/blackscholes_for/3"}
{"code": "for (i = 0; i < ntrow; i++)\n{\n  if (i == k)\n  {\n  }\n  else\n  {\n    updateSubmatrix(i * nbrow, k * nbrow, i * nbrow, k * nbrow, k * nbrow, k * nbrow, A, b);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BineshTharikoppula/Parallel-Tiled-Floyd-Warshall/FinalAPSP/2"}
{"code": "for (i = 0; i < r->nnz; ++i)\n  colInd[i] = r->colInd[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/2"}
{"code": "for (i = 0; i < 3; i++)\n{\n  printf(\"%d\\n\", i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/denporras/CE-4302-TallerOpeMP/Ejemplo_Pi/prueba/0"}
{"code": "for (int i = 0; i < NUM_POINTS_0; i++)\n{\n  eta[i] = eta_phi[i];\n  phi[i] = eta_phi[NUM_POINTS_0 + i];\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tyggesnusk/MasterThesisCode-SurfaceWaves/SurfaceWaves/SurfaceWaves/6"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  double mean = 0.0;\n  double var = 0.0;\n  for (int j = 0; j < m; j++)\n  {\n    mean += x[j][i];\n    var += x[j][i] * x[j][i];\n  }\n\n  mean = mean / m;\n  for (int j = 0; j < m; j++)\n  {\n    var += ((x[j][i] * x[j][i]) + (mean * mean)) - ((2 * mean) * x[j][i]);\n  }\n\n  var = var / m;\n  double std = sqrt(var);\n  for (int j = 0; j < m; j++)\n  {\n    scale_x[j][i] = (x[j][i] - mean) / var;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ravihooda155/Logistic_Regression-Parallel/logistic/0"}
{"code": "for (pos = &ciphertext[(sizeof(\"$NETNTLM$\")) - 1]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETNTLM_bs_fmt_plug/0"}
{"code": "for (i = 0; i < 10000000; i++)\n{\n  bucketId = (((double) array[i]) / 1000000000) * 100;\n  omp_set_lock(&locks[bucketId]);\n  buckets[bucketId].elems[buckets[bucketId].len] = array[i];\n  buckets[bucketId].len++;\n  omp_unset_lock(&locks[bucketId]);\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg2/3"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  b[i][j] = b[i][j] + 1;\n\n\n", "pragma": "omp parallel for default(shared) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB113-default-orig-no/0"}
{"code": "for (i = rb; i < re; i++)\n  p_zw[i] = p_zw[i] + (beta * p_d[iter - j][i]);\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/32"}
{"code": "for (int i = 0; i < h; i++)\n{\n  for (int j = 0; j < w; j++)\n  {\n    pixels[i][j] = f(pixels[i][j]);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for schedule(kind, chunk_size) shared(pixels)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MONICgh/OpenMP/lab04/4"}
{"code": "for (i = row * row_block_size; (i < ((row + 1) * row_block_size)) && (i < dataSet.n); i++)\n{\n  for (j = col * col_block_size; (j < ((col + 1) * col_block_size)) && (j < dataSet.m); j++)\n  {\n    dataSet.C[(i * dataSet.m) + j] = dataSet.A[(i * dataSet.m) + j] + dataSet.B[(i * dataSet.m) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/Lab2/matadd/2"}
{"code": "for (i = 0; i <= (len - 1); i += 1)\n{\n  for (j = 0; j <= (len - 1); j += 1)\n  {\n    c[i][j] = a[i][j] * b[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j) firstprivate (len)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB098-simd2-orig-no/2"}
{"code": "for (k = ki1; k <= ki2; k += 1)\n{\n  phi1[i][k] = 0.40e+00 * (u[i][jbeg][k][4] - ((0.50 * (((u[i][jbeg][k][1] * u[i][jbeg][k][1]) + (u[i][jbeg][k][2] * u[i][jbeg][k][2])) + (u[i][jbeg][k][3] * u[i][jbeg][k][3]))) / u[i][jbeg][k][0]));\n}\n\n", "pragma": "omp parallel for private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/72"}
{"code": "for (i = 0; i < NRA; i++)\n{\n  for (j = 0; j < NCB; j++)\n    fprintf(fptr, \"%6.2f   \", c[i][j]);\n\n  fprintf(fptr, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akhilap1/OPENMPCourse/2019SepOPENMP/OMPMatrixMult/Ex5MM_Multiply/2"}
{"code": "for (size_t i = 0; i < Nqd; i++)\n{\n  for (size_t j = 0; j < Nelt; j++)\n  {\n    Diff1(i, j) = P1t(i, j) - P1tau(i, g.next(j));\n    Diff2(i, j) = P2t(i, j) - P2tau(i, g.next(j));\n    r = pow(Diff1(i, j), 2) + pow(Diff2(i, j), 2);\n    Knext(i, j) = kernel(pow(r, 0.5));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mhassell/BEM/BEM/Operators/17"}
{"code": "for (i = 1; i < 3780; i++)\n{\n  *(r_edge + i) = (*((r_edge + i) - 1)) + (((*((r_edge + i) - 1)) * (M_PI / 560)) / (1 + ((*((r_edge + i) - 1)) / r_ref)));\n  *((dr + i) - 1) = (*(r_edge + i)) - (*((r_edge + i) - 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lazzati-astro/MCRaT/OLDER_MCRaT_VERSIONS/HYBRID_PARALLEL/mclib_3d/1"}
{"code": "for (j = start; j < (end - 1); j++)\n{\n  for (i = j + 1; i < end; i++)\n  {\n    coef = A[i][j] / A[j][j];\n    for (k = 0; k < N; k++)\n    {\n      A[i][k] -= coef * A[j][k];\n    }\n\n    b[i] -= coef * b[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/igor-sumin/GraduateWork/graduatework/algo/impl/parallel/ParallelSweepMethod/0"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  printf(\"Iter %d was assigned thread %d\\n\", i, A[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nathanwbrei/openmp_tutorial/src/exfor/1"}
{"code": "for (ncols = 0, rowptr[0] = 0, k = 0, i = 0; i < nrows; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Premature end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    mat->rsizes[i] = strtof(head, &tail);\n    if (tail == head)\n      gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n    if (mat->rsizes[i] < 0)\n      errexit(\"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      mat->rwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n      if (tail == head)\n        errexit(\"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n      if (mat->rwgts[(i * ncon) + l] < 0)\n        errexit(\"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((rowind[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    ncols = gk_max(rowind[k], ncols);\n    if (readvals == 1)\n    {\n      fval = strtof(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"Value could not be found for column! Row:%zd, NNZ:%zd\\n\", i, k);\n\n      head = tail;\n      rowval[k] = fval;\n    }\n\n    k++;\n  }\n\n  rowptr[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/csr/37"}
{"code": "for (int i = 0; i < ny; i++)\n{\n  b[0][i + 1] = rget((iface.pointerB + iface.startIndex) + (iface.stride * i)).wait();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/oldenj/shallow-water-equations/src/blocks/SWE_DimensionalSplittingUpcxx/1"}
{"code": "for (int i = 4; i < 12; i++)\n  argv[0][i] = argv[0][i] - argv[0][i - 4];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/simd_safelen_messages/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  for (i = 0; i <= (grid_points[0] - 1); i += 1)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j += 1)\n    {\n      for (k = 0; k <= (grid_points[2] - 1); k += 1)\n      {\n        rhs[m][i][j][k] = forcing[m][i][j][k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/90"}
{"code": "for (int c = lc - 1; (c >= 0) && (this->board[lr][c] == player); --c)\n{\n  left++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kritika-gupta/parallel-monte-carlo-tree-search/connect4_root/1"}
{"code": "for (i = 0; i < NoofRows; i = i + 1)\n  for (j = 0; j < NoofCols; j = j + 1)\n  Checkoutput[j][i] = Matrix[i][j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/liangtj/Multi-core-Parallel/matrixTrans/matrixTrans_openMP/3"}
{"code": "for (index = 0; index < count; index += SHA1_N)\n{\n  SHA_CTX ctx;\n  if (new_keys)\n  {\n    SHA1_Init(&ipad_ctx[index]);\n    SHA1_Update(&ipad_ctx[index], ipad[index], 64);\n    SHA1_Init(&opad_ctx[index]);\n    SHA1_Update(&opad_ctx[index], opad[index], 64);\n  }\n\n  memcpy(&ctx, &ipad_ctx[index], sizeof(ctx));\n  SHA1_Update(&ctx, cur_salt, strlen((char *) cur_salt));\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n  memcpy(&ctx, &opad_ctx[index], sizeof(ctx));\n  SHA1_Update(&ctx, crypt_key[index], 20);\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/hmacSHA1_fmt_plug/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (long j = 0; j < n; j++)\n  {\n    ResM[i][j] = M1[i][j] + M2[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aboogi/Matrix-OpenMP/strassen_mul_2d_omp/1"}
{"code": "for (ii = 0; ii < params.ny; ii++)\n{\n  offset = ii * params.nx;\n  speeds = cells[offset].speeds;\n  if ((((!obstacles[offset]) && ((speeds[3] - w1) > 0.0)) && ((speeds[6] - w2) > 0.0)) && ((speeds[7] - w2) > 0.0))\n  {\n    speeds[1] += w1;\n    speeds[5] += w2;\n    speeds[8] += w2;\n    speeds[3] -= w1;\n    speeds[6] -= w2;\n    speeds[7] -= w2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(ii, offset, speeds) shared(cells)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/doraemoncito/boltzmann/boltzmann-openmp/d2q9-bgk/0"}
{"code": "for (int i = 0; i < (N + 1); i++)\n{\n  processwork(ptr_list[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mahikgot/openmp_practice/exercise 6/linked/2"}
{"code": "for (int i = 0; i < len; i++)\n  a[i] = 0.;\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/GraphAIBench/src/utilities/math_functions/5"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  int thread = omp_get_thread_num();\n  if (initialized == 0)\n  {\n    local_max[thread] = array[i];\n    local_min[thread] = array[i];\n    initialized = 1;\n  }\n  else\n  {\n    if (array[i] > local_max[thread])\n    {\n      local_max[thread] = array[i];\n    }\n\n    if (array[i] < local_min[thread])\n    {\n      local_min[thread] = array[i];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for private(initialized)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JiyanBlack/MPI-HPC-Project2/examQuestion/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"%d\\t\", a[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Vishwanath2001/OpenMp/ompquicksort/1"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  m_cellFlowCols = Max(CVT_INT(m_iuhCell[i][1]) + 1, m_cellFlowCols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/hydrology_longterm/IUH_OL/IUH_OL/0"}
{"code": "for (i = 0; i < mpi_chunksize; i++)\n{\n  x = scram[i];\n  for (y = 0; y < nptsside; y++)\n  {\n    xv = (x - side2) / side4;\n    yv = (y - side2) / side4;\n    z = xv + (yv * I);\n    if (inset(z))\n    {\n      count++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1C/Input/mpi_not_rc/1"}
{"code": "for (int i = 1; i < (this->image.rows - 1); i++)\n{\n  for (int j = 1; j < (this->image.cols - 1); j++)\n  {\n    float indicator;\n    float g11;\n    float g22;\n    float g12;\n    float Ix[3];\n    float Iy[3];\n    float Ixx[3];\n    float Iyy[3];\n    float Ixy[3];\n    float value;\n    float alphag;\n    float num;\n    float denom;\n    Ix[0] = dfX_0(0, i, j);\n    Ix[1] = dfX_0(1, i, j);\n    Ix[2] = dfX_0(2, i, j);\n    Iy[0] = dfY_0(0, i, j);\n    Iy[1] = dfY_0(1, i, j);\n    Iy[2] = dfY_0(2, i, j);\n    Ixx[0] = dfX2(0, i, j);\n    Ixx[1] = dfX2(1, i, j);\n    Ixx[2] = dfX2(2, i, j);\n    Iyy[0] = dfY2(0, i, j);\n    Iyy[1] = dfY2(1, i, j);\n    Iyy[2] = dfY2(2, i, j);\n    Ixy[0] = dfXY(0, i, j);\n    Ixy[1] = dfXY(1, i, j);\n    Ixy[2] = dfXY(2, i, j);\n    g11 = ((1.0 + (Ix[0] * Ix[0])) + (Ix[1] * Ix[1])) + (Ix[2] * Ix[2]);\n    g12 = ((Ix[0] * Iy[0]) + (Ix[1] * Iy[1])) + (Ix[2] * Iy[2]);\n    g22 = ((1.0 + (Iy[0] * Iy[0])) + (Iy[1] * Iy[1])) + (Iy[2] * Iy[2]);\n    indicator = sqrt(((g11 - g22) * (g11 - g22)) + ((4.0 * g12) * g12));\n    value = sqrt(indicator) / tau;\n    value *= -value;\n    alphag = alpha * exp(value);\n    for (int c = 0; c < 3; c++)\n    {\n      num = (((Ixx[c] * Iy[c]) * Iy[c]) - (((2.0 * Ixy[c]) * Ix[c]) * Iy[c])) + ((Iyy[c] * Ix[c]) * Ix[c]);\n      denom = (1e-8 + (Ix[c] * Ix[c])) + (Iy[c] * Iy[c]);\n      value = image(i, j)[c] + ((alphag * num) / denom);\n      if (value > 1)\n        value = 1;\n      else\n        if (value < 0)\n        value = 0;\n\n\n      temp(i, j)[c] = value;\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OluwaseunOjeleye/OpenMP-based-Image-Processing-/image_processing/IP/17"}
{"code": "for (int col = 0; col < ms; col++)\n  row_mult_col(arr1, arr2, m, row, col, res);\n\n", "pragma": "omp parallel for shared(res)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t2/1"}
{"code": "for (size_t i = 0; i < 16; i++)\n{\n  printf(\"Thread %i executing iteration %i (workload %u).\\n\", omp_get_thread_num(), i, workload[i]);\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/examples/binlpt-02/0"}
{"code": "for (int n = start; n < end; n++)\n{\n  int flags[9] = {0};\n  for (int k = 0; k < 9; k++)\n  {\n    int val = S[getNthSectionKthIndex(n, k)];\n    if ((val >= 1) && (val <= 9))\n    {\n      flags[val - 1] += 1;\n    }\n\n  }\n\n  if (exactlyOneEach(flags) == 0)\n  {\n    flag = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jeremyyew/sudoku-checker/srcs/sudoku_openmp/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      ru1 = rho_i[i][j][k];\n      uu = us[i][j][k];\n      vv = vs[i][j][k];\n      ww = ws[i][j][k];\n      ac = speed[i][j][k];\n      ac2inv = ainv[i][j][k] * ainv[i][j][k];\n      r1 = rhs[0][i][j][k];\n      r2 = rhs[1][i][j][k];\n      r3 = rhs[2][i][j][k];\n      r4 = rhs[3][i][j][k];\n      r5 = rhs[4][i][j][k];\n      t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n      t2 = (bt * ru1) * ((uu * r1) - r2);\n      t3 = ((bt * ru1) * ac) * t1;\n      rhs[0][i][j][k] = r1 - t1;\n      rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n      rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n      rhs[3][i][j][k] = (-t2) + t3;\n      rhs[4][i][j][k] = t2 + t3;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/44"}
{"code": "for (int i = 0; i < SIZE_X; i++)\n  m_Locks[i] = false;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  z.arr[i] = arr[i] + k.arr[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/martishaaddams/OpenMPVectorHoriVert/complexvector0/0"}
{"code": "for (int i = ProcessId * (size / 4); i < size; i++)\n{\n  result[i] = 0;\n  for (int j = i * size; j < ((i + 1) * size); j++)\n  {\n    result[i] += mat[j] * vector[j - (i * size)];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ziqidong/openmp-openmpi_test/openmpi_calculate_matrix/src/Dong_ziqi/1"}
{"code": "for (index = 0; index < count; index++)\n  if (!memcmp(binary, crypt_out[index], 4))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/AzureAD_fmt_plug/1"}
{"code": "for (j = 1; j < N; j = j + 3)\n  a[j] = b[j];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke-fails/no-loop-8/no_loop_8/1"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 3; k <= (grid_points[2] - 4); k++)\n  {\n    lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n    lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,comz1 ,comz4 ,comz6 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/75"}
{"code": "for (int c = last_chunk_idx + 1; c < node->dim_hidden; ++c)\n{\n  node->hidden[c] += (message[c] / norm) + (bias_1[c] / node->degree);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/erdenbatuhan/ParallelGraphConvNN/src/gcn_hybrid-simd/4"}
{"code": "for (int g = 0; g < I.n_egroups; g++)\n{\n  FSR_flux[g] += tally[g];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ANL-CESAR/SimpleMOC/src/solver/13"}
{"code": "for (int k = 0; k < K; k++)\n{\n  res += L[i][k] * U[k][j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NJU-TJL/OpenMP-MPI_Labs/Lab02/OpenMP/LU_OpenMP/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Aman-1701/Tiled_Matrix_Multiplication_OpenMP/TiledMatrixMultiplication/2"}
{"code": "for (int i = 0; i < src.rows; i++)\n{\n  for (int j = 0; j < src.cols; j++)\n  {\n    if ((((i < ksize) || (i >= (src.rows - ksize))) || (j < ksize)) || (j >= (src.cols - ksize)))\n    {\n      dst(i, j)[0] = src(i, j)[0];\n      dst(i, j)[1] = src(i, j)[1];\n      dst(i, j)[2] = src(i, j)[2];\n    }\n    else\n    {\n      for (int n = 0; n < k; n++)\n      {\n        for (int m = 0; m < k; m++)\n        {\n          dst(i, j)[0] += (int) (src((i + n) - ksize, (j + m) - ksize)[0] * kernel[n][m]);\n          dst(i, j)[1] += (int) (src((i + n) - ksize, (j + m) - ksize)[1] * kernel[n][m]);\n          dst(i, j)[2] += (int) (src((i + n) - ksize, (j + m) - ksize)[2] * kernel[n][m]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/separable/0"}
{"code": "for (i = 20; i < hashSize; i++)\n{\n  hashBuf[0][i] = 0x36;\n  hashBuf[0][32 + i] = 0x36;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/office_fmt_plug/6"}
{"code": "for (; i < individualsNo; i++)\n  individuals[i] = solution(townsNo, towns);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Tomev/Ozuko_OpenMP_4/z4/12"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k += 1)\n    {\n      vijk = vs[i][j][k];\n      vp1 = vs[i][j + 1][k];\n      vm1 = vs[i][j - 1][k];\n      rhs[0][i][j][k] = (rhs[0][i][j][k] + (dy1ty1 * ((u[0][i][j + 1][k] - (2.0 * u[0][i][j][k])) + u[0][i][j - 1][k]))) - (ty2 * (u[2][i][j + 1][k] - u[2][i][j - 1][k]));\n      rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dy2ty1 * ((u[1][i][j + 1][k] - (2.0 * u[1][i][j][k])) + u[1][i][j - 1][k]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[1][i][j + 1][k] * vp1) - (u[1][i][j - 1][k] * vm1)));\n      rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dy3ty1 * ((u[2][i][j + 1][k] - (2.0 * u[2][i][j][k])) + u[2][i][j - 1][k]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[2][i][j + 1][k] * vp1) - (u[2][i][j - 1][k] * vm1)) + ((((u[4][i][j + 1][k] - square[i][j + 1][k]) - u[4][i][j - 1][k]) + square[i][j - 1][k]) * c2)));\n      rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dy4ty1 * ((u[3][i][j + 1][k] - (2.0 * u[3][i][j][k])) + u[3][i][j - 1][k]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[3][i][j + 1][k] * vp1) - (u[3][i][j - 1][k] * vm1)));\n      rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dy5ty1 * ((u[4][i][j + 1][k] - (2.0 * u[4][i][j][k])) + u[4][i][j - 1][k]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[4][i][j + 1][k] * rho_i[i][j + 1][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i][j - 1][k] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[4][i][j + 1][k]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[4][i][j - 1][k]) - (c2 * square[i][j - 1][k])) * vm1)));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (vijk,vp1,vm1,i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/113"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    (out << a[i][j]) << \" \";\n  }\n\n  out << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TwinIsland-CCC/OMP-work/omp_arm/25"}
{"code": "for (int i = 0; i < 4; ++i)\n{\n  float *rez0 = result[i];\n  rez0[0] = arr_x0[i];\n  for (size_t j = 1; j < arr_size; ++j)\n    rez0[j] = (a * rez0[j - 1]) + b;\n\n}\n\n", "pragma": "omp parralel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArtTikidji/Study_openMP_AVX/main/0"}
{"code": "for (idx_t i = 0; i < nslices; ++i)\n{\n  p_tt_quicksort(tt, cmplt, histogram_array[i], histogram_array[i + 1]);\n  for (idx_t j = histogram_array[i]; j < histogram_array[i + 1]; ++j)\n  {\n    tt->ind[m][j] = i;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/sort/2"}
{"code": "for (int i = 0; i < ((int) nIndex.size()); i++)\n{\n  double distSq = 0.0;\n  if (currentAxes.InRcut(distSq, trialPos, t, currentCoords, nIndex[i], box))\n  {\n    double lambdaVDW = GetLambdaVDW(molIndex, particleMol[nIndex[i]], box);\n    if (distSq < forcefield.rCutLowSq)\n    {\n      overlap[t] |= true;\n    }\n\n    tempLJ += forcefield.particles->CalcEn(distSq, kindI, particleKind[nIndex[i]], lambdaVDW);\n    if (electrostatic)\n    {\n      double lambdaCoulomb = GetLambdaCoulomb(molIndex, particleMol[nIndex[i]], box);\n      double qi_qj_fact = (particleCharge[nIndex[i]] * kindICharge) * qqFact;\n      if (qi_qj_fact != 0.0)\n      {\n        tempReal += forcefield.particles->CalcCoulomb(distSq, kindI, particleKind[nIndex[i]], qi_qj_fact, lambdaCoulomb, box);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(kindI, kindICharge, nIndex, \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/3"}
{"code": "for (int j = 0; j < vector.size; j++)\n{\n  vector.arr[j] = 3 + (j / 6);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OlegShatin/openmp-homework/8/main/1"}
{"code": "for (int ThisCaptureLevel = getOpenMPCaptureLevels(OMPD_target_parallel_for); ThisCaptureLevel > 1; --ThisCaptureLevel)\n{\n  CS = (cast < CapturedStmt) > CS->getCapturedStmt();\n  CS->getCapturedDecl()->setNothrow();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/lib/Sema/SemaOpenMP/4"}
{"code": "for (size_t i = 0; i < size; i++)\n  fwrite(bmp + i, sizeof(unsigned char), PIXEL_REAL_SIZE, bmpFile);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlukyanets/parallel-computing-project/smooth_filter_openmp/2"}
{"code": "for (i = 0; i < numprocs; ++i)\n{\n  if ((allResultsBuffer[i * PAIR] < fileInfo->QC) || (allResultsBuffer[(i * PAIR) + 1] > (fileInfo->alphaMAX - fileInfo->alpha0)))\n  {\n    *minAlphaRank = i;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yotamMoshe7/C-Classification-Problem-Precepton/MPI_OMP_CUDA/PerceptronClassification/1"}
{"code": "for (j = 0; j < N; j++)\n{\n  colSum = 0;\n  for (i = 0; i < N; i++)\n  {\n    if (i != j)\n    {\n      per = (int) (100 * propArray[i]);\n      M[i][j] = propabilityFunction(per);\n      colSum += M[i][j];\n    }\n    else\n    {\n      M[i][j] = 0;\n    }\n\n  }\n\n  if (0 == colSum)\n  {\n    for (i = 0; i < N; i++)\n    {\n      if (i != j)\n      {\n        M[i][j] = propabilityFunction(50);\n        colSum += M[i][j];\n      }\n\n    }\n\n  }\n\n  if (0 == colSum)\n  {\n    per = rand() % N;\n    if (per == j)\n    {\n      if (j != (N - 1))\n      {\n        per++;\n      }\n      else\n      {\n        per--;\n      }\n\n    }\n\n    M[per][j] = 1;\n    colSum = 1;\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    M[i][j] /= colSum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/24"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  if (c[i] != 100)\n  {\n    printf(\"Data Race\\n\");\n    return 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB149-missingdata1-orig-gpu-no/2"}
{"code": "for (int i = 1; i < (siz - 1); i++)\n{\n  grid_n[siz - 1][i] = grid[siz - 1][i] + (((kappa * dt) * ((((grid[siz - 2][i] + grid[0][i]) + grid[siz - 1][i - 1]) + grid[siz - 1][i + 1]) - (4 * grid[siz - 1][i]))) / sq(dx));\n}\n\n", "pragma": "    #pragma omp parallel for num_threads(nthreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tejalb/Heat-Diffusion-using-MPI-/heat_omp/4"}
{"code": "for (int i = 0; i < n; i++)\n{\n  data[i] = (2.0f * (rand() / ((float) RAND_MAX))) - 1.0f;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jackspyder/CPS_Coursework2/Threaded_CPU_Nbody/Threaded/0"}
{"code": "for (int i = 0; i < aHeight; i++)\n  for (int j = 0; j < aWidth; j++)\n  scanf(\"%d\", &A[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/ImageMatch/main/1"}
{"code": "for (j = 0; j < 500; j++)\n{\n  mean = (mean + w[500 - 1][j]) + w[0][j];\n}\n\n", "pragma": "omp for reduction ( + : mean )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/5"}
{"code": "for (j = 0; j < dataSet->m; j++)\n{\n  dataSet->A[(i * dataSet->m) + j] = rand() % 100;\n  dataSet->B[(i * dataSet->m) + j] = rand() % 100;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MehranTaghian/CUDA-OpenMP-samples/OpenMP /matrix_add/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  x[i] = random_value(&my_seed);\n  printf(\"  %6d  %12d  %6d  %14.6g\\n\", my_id, my_seed, i, x[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vlkale/lw-sched/share/ukernels/randomnumbers/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  pr[i] = ((float) histogram[i]) / ((float) n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sirmisscriesalot/openmp_term_projects/src/histogram_equalization/2"}
{"code": "for (k = len - mod; k < len; k++)\n{\n  MPI_Send(&op[k], 1, mpi_op_type, count, 0, (MPI_Comm) 0x44000000);\n  count++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DomenicoNatella/implied_volatility/implied_vol_newton_ver2/3"}
{"code": "for (int i = 0; i < n_isotopes; i++)\n  for (int j = 0; j < n_gridpoints; j++)\n{\n  nuclide_grids[i][j].energy = ((double) rand()) / ((double) 32767);\n  nuclide_grids[i][j].total_xs = ((double) rand()) / ((double) 32767);\n  nuclide_grids[i][j].elastic_xs = ((double) rand()) / ((double) 32767);\n  nuclide_grids[i][j].absorbtion_xs = ((double) rand()) / ((double) 32767);\n  nuclide_grids[i][j].fission_xs = ((double) rand()) / ((double) 32767);\n  nuclide_grids[i][j].nu_fission_xs = ((double) rand()) / ((double) 32767);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/XSBench/GridInit/1"}
{"code": "for (i = 0; i < 100000; i++)\n{\n  total_sum += (*(array + i)) * (*(array + i));\n}\n\n", "pragma": "omp parallel for reduction (+:total_sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AndrewMcClelland/MultithreadingOperations/1a_DotProduct_OpenMP/0"}
{"code": "for (size_t i = 0; i < ((maRows * maColumns) - 1); i++)\n{\n  file1 >> valueFromFile1;\n  file2 >> valueFromFile2;\n  if (!((valueFromFile1 == valueFromFile2) && (abs(valueFromFile1 - valueFromFile2) <= 0.0001)))\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DmitriyFromBSUIR/Term_8_CAaD_LabWork3/main/7"}
{"code": "for (int j = 0; j < row_size; j++)\n{\n  int pos_B = (j * rank) * rank;\n  int pos_C = j * rank;\n  int k;\n  int l;\n  for (k = 0; k < rank; k++)\n  {\n    for (l = 0; l < rank; l++)\n    {\n      B[pos_B] = 0;\n      if (k == l)\n        B[pos_B] = lambda;\n\n      pos_B++;\n    }\n\n    C[pos_C++] = 0;\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(static) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/19"}
{"code": "for (layer8_index = 0; layer8_index < Layer_CH_Num; layer8_index++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      temp_data9[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = 0;\n    }\n\n  }\n\n  for (i = half_filter_size; i < (HIgh_h - half_filter_size); i++)\n  {\n    for (j = half_filter_size; j < (HIgh_w - half_filter_size); j++)\n    {\n      for (k = (-1) * half_filter_size; k < (half_filter_size + 1); k++)\n      {\n        for (l = (-1) * half_filter_size; l < (half_filter_size + 1); l++)\n        {\n          temp_data9[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = temp_data9[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + (conv8_data[(((layer8_index * HIgh_h) * HIgh_w) + ((i + k) * HIgh_w)) + (j + l)] * weight_conv9[(((((layer9_index * Layer_Filter_Size) * Layer_Filter_Size) * Layer_CH_Num) + ((layer8_index * Layer_Filter_Size) * Layer_Filter_Size)) + ((l + half_filter_size) * Layer_Filter_Size)) + (k + half_filter_size)]);\n        }\n\n      }\n\n    }\n\n  }\n\n  for (i = 0; i < HIgh_h; i++)\n  {\n    for (j = 0; j < HIgh_w; j++)\n    {\n      conv9_data[(((layer9_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] = conv9_data[(((layer9_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j] + temp_data9[(((layer8_index * HIgh_h) * HIgh_w) + (i * HIgh_w)) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private(j, i, k, l)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/40"}
{"code": "for (i = 0; i < filas; i++)\n{\n  matrix_v[i] = malloc(500 * (sizeof(float)));\n  matrix_h[i] = malloc(500 * (sizeof(float)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MiguelazoDS/so2-openmp/C\u00f3digos/paralelo/3"}
{"code": "for (i = 0; i < (ref_nb * dim); i++)\n  ref[i] = ((float) rand()) / ((float) RAND_MAX);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/3"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  pongSendBuf[i] = pingRecvBuf[i];\n}\n\n", "pragma": "omp parallel for private(i) shared(pongSendBuf,pingRecvBuf,dataSize,sizeofBuffer) schedule(static,dataSize)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/pt_to_pt_multiPingpong/1"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    count_bad_vals(&((double *) arg0.data)[5 * n], &arg1_l[64 * omp_get_thread_num()]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[15].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/count_bad_vals_kernel/1"}
{"code": "for (i = 1; i <= file_num; i++)\n{\n  if (file_num == 1)\n    sprintf(file_name, \"%s%s%04d%s%04d\", INPUT_FOLDER, \"/pos\", SNAPSHOT, \".\", CUR_STEP);\n  else\n    sprintf(file_name, \"%s%s%04d%s%04d%s%02d\", INPUT_FOLDER, \"/pos\", SNAPSHOT, \".\", CUR_STEP, \".\", i);\n\n  fp = fopen(file_name, \"rb\");\n  printf(\"Open %s\\n\", file_name);\n  fseek(fp, 0, 2);\n  file_len = ftell(fp);\n  readby = 0L;\n  if (i == 1)\n  {\n    header_size = ((2 * (sizeof(long int))) + (6 * (sizeof(float)))) + (2 * (sizeof(int)));\n    fseek(fp, header_size, 0);\n    file_len -= header_size;\n  }\n  else\n    rewind(fp);\n\n  while (readby < file_len)\n  {\n    fread(&block_size_1, sizeof(block_size_1), 1, fp);\n    fread(&reader_pos[readby_total], sizeof(char), abs(block_size_1), fp);\n    fread(&block_size_2, sizeof(block_size_2), 1, fp);\n    if (abs(block_size_2) != abs(block_size_1))\n    {\n      printf(\"Inconsistency found in %s\\n\", file_name);\n      warn_and_end(\"End\");\n    }\n\n    readby += abs(block_size_1) + (2 * (sizeof(block_size_1)));\n    readby_total += abs(block_size_1);\n  }\n\n  fclose(fp);\n  printf(\"Finish reading.\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/RSD-window/load_jing/2"}
{"code": "for (i = 0; i < (MAX_KEY - 1); i++)\n  prv_buff1[i + 1] += prv_buff1[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/9"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    test[i][j] = 0.0f;\n    for (k = 0; k < N; k++)\n    {\n      test[i][j] += lower[i][k] * upper[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_30_parallel_cholesky_inner/6"}
{"code": "for (long i = 0; i < VECTOR_SIZE; i += 1)\n{\n  if (fArray[i] > max1)\n  {\n    max1 = fArray[i];\n    max1idx = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soltanloo/Fall2020-PP-CAs/CA4/1/main/0"}
{"code": "for (int i = 0; i < hsize; i++)\n{\n  spmatrix->jja[i] = (int *) malloc(msize * (sizeof(int)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/CoSP2-master-openmp/sparseMatrix/3"}
{"code": "for (i = 0; i < num_alive; i++)\n{\n  it = vector[i];\n  unsigned char live_neighbours = it->ptr->neighbours;\n  it->ptr->neighbours = 0;\n  if (it->ptr->state == ALIVE)\n  {\n    if ((live_neighbours < 2) || (live_neighbours > 4))\n    {\n      it->ptr->state = DEAD;\n      graphNodeRemove(&graph[it->x][it->y], it->z, &graph_lock[it->x][it->y]);\n      hashtableRemove(hashtable, it->x, it->y, it->z);\n    }\n\n  }\n\n  for (j = 0; j < 6; j++)\n  {\n    it = neighbour_vector[i][j];\n    if (it != 0)\n    {\n      unsigned char live_neighbours = it->ptr->neighbours;\n      it->ptr->neighbours = 0;\n      if (it->ptr->state == DEAD)\n      {\n        if ((live_neighbours == 2) || (live_neighbours == 3))\n        {\n          it->ptr->state = ALIVE;\n          hashtableWrite(hashtable, it->x, it->y, it->z, it->ptr);\n        }\n        else\n        {\n          graphNodeRemove(&graph[it->x][it->y], it->z, &graph_lock[it->x][it->y]);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(it, i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jsbruglie/cpd/omp/par_grid_hash/par_grid_hash/2"}
{"code": "for (i = 0; i < num_of_clusters; i++)\n{\n  free(c[i]);\n  free(c1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/minavouronikou/kmeans_hybrid/OpenMP version/kmeans/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (dest[i] != source[loc[i]])\n  {\n    res = false;\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather/1"}
{"code": "for (y = 0; y < canvas->h; y++)\n  free(row_pointers[y]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lagodiuk/raytracing-render/render/src/canvas/6"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    fprintf(ff, \"%f \", a[i][j]);\n  }\n\n  fprintf(ff, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/parallel_loops/src/par_3/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (i == j)\n    {\n      out[(i * n) + j] = 0;\n    }\n    else\n      if (flip(rand_engine) < p)\n    {\n      out[(i * n) + j] = choose_weight(rand_engine);\n    }\n    else\n    {\n      out[(i * n) + j] = max() / 2;\n    }\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/moorejs/APSP-in-parallel/src/floyd_warshall/0"}
{"code": "for (i = 0; i < N; i++)\n  s2.q[i]++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-ykt/openmp/libomptarget/omptests/t-partial-struct/test/9"}
{"code": "for (int i = 0; i < length; i++)\n{\n  a[i] = i;\n  b[i] = i * ((double) 2);\n  c[i] = a[i] + b[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/carlosepb/BLAS_LAPACK__MPI_OpenMP_CUDA/MNC/Entrega8/Practica1/Main/0"}
{"code": "for (int i = 0; i < src.rows; i++)\n{\n  for (int j = 0; j < src.cols; j++)\n  {\n    if ((((i < fsize) || (i >= (src.rows - fsize))) || (j < fsize)) || (j >= (src.cols - fsize)))\n    {\n      dst(i, j)[0] = 0;\n      dst(i, j)[1] = 0;\n      dst(i, j)[2] = 0;\n    }\n    else\n    {\n      int r = 0;\n      int g = 0;\n      int b = 0;\n      for (int n = 0; n < 3; n++)\n      {\n        for (int m = 0; m < 3; m++)\n        {\n          r += src((i + n) - fsize, (j + m) - fsize)[0] * kernel[n][m];\n          g += src((i + n) - fsize, (j + m) - fsize)[1] * kernel[n][m];\n          b += src((i + n) - fsize, (j + m) - fsize)[2] * kernel[n][m];\n        }\n\n      }\n\n      dst(i, j)[0] = (int) ((((double) r) + 2040.0) / 16.0);\n      dst(i, j)[1] = (int) ((((double) g) + 2040.0) / 16.0);\n      dst(i, j)[2] = (int) ((((double) b) + 2040.0) / 16.0);\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/naoki7090624/ImageProcessing-OpenMP/Conv/3"}
{"code": "for (j = 2; j <= treeLevel; j++)\n{\n  compute_m2l_operator(interpolation_order, dof, symmetry, Kmat, Umat, Vmat, boxLenLevel, alpha, Kweights, epsilon, use_chebyshev, first_time_call);\n  boxLenLevel /= 2;\n  first_time_call = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruoxi-wang/PBBFMM3D/src/H2_3D_Tree/0"}
{"code": "for (i = 0; i < rows; ++i)\n{\n  H[i][0] = 0.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/8"}
{"code": "for (int i = 0; i < omp_get_num_threads(); i++)\n{\n  double rank = omp_get_thread_num() + 0.5;\n  res2 = rank;\n}\n\n", "pragma": "omp for reduction(+:res2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JSquar/cato/src/kernel_examples/multi_reduction/1"}
{"code": "for (j = 1; j < nxh; j++)\n{\n  at2 = (-ci2) * crealf(ffe[j]);\n  at1 = at2 * at2;\n  exyz[3 * j] = at2 * dcu[3 * j];\n  exyz[1 + (3 * j)] = at2 * dcu[1 + (3 * j)];\n  exyz[2 + (3 * j)] = at2 * dcu[2 + (3 * j)];\n  exyz[3 * (j + k1)] = zero;\n  exyz[1 + (3 * (j + k1))] = zero;\n  exyz[2 + (3 * (j + k1))] = zero;\n  exyz[3 * (j + l1)] = zero;\n  exyz[1 + (3 * (j + l1))] = zero;\n  exyz[2 + (3 * (j + l1))] = zero;\n  exyz[3 * ((j + k1) + l1)] = zero;\n  exyz[1 + (3 * ((j + k1) + l1))] = zero;\n  exyz[2 + (3 * ((j + k1) + l1))] = zero;\n  wp += at1 * (((dcu[3 * j] * conjf(dcu[3 * j])) + (dcu[1 + (3 * j)] * conjf(dcu[1 + (3 * j)]))) + (dcu[2 + (3 * j)] * conjf(dcu[2 + (3 * j)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic3/mdpush3/28"}
{"code": "for (i = 0; i <= (10000 + 1); i++)\n{\n  Temperature_last[i][0] = 0.0;\n  Temperature_last[i][10000 + 1] = (100.0 / 10000) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bakitybacon/parallelprogramming/Exercises/OpenMP/laplace_10k/3"}
{"code": "for (long i = 0; i < arraySize; ++i)\n  sum += A[i] * B[i];\n\n", "pragma": "#pragma omp parallel for default(shared)                                \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/test_dotprod_parfor/1"}
{"code": "for (int i = 0; i < K; i++)\n{\n  *((cent + (iter * K)) + (3 * i)) = clusters[i].cx;\n  *(((cent + (iter * K)) + (3 * i)) + 1) = clusters[i].cy;\n  *(((cent + (iter * K)) + (3 * i)) + 2) = clusters[i].cz;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/animeshsinghjay/parallel-kmeans/lab1_omp/4"}
{"code": "for (int id = 0; id < 2; id++)\n{\n  GASPICHECK(gaspi_segment_create(id, (gaspi_size_t) nsend, GASPI_GROUP_ALL, GASPI_BLOCK, GASPI_ALLOC_DEFAULT));\n  GASPICHECK(gaspi_segment_create(id + 2, (gaspi_size_t) nrecv, GASPI_GROUP_ALL, GASPI_BLOCK, GASPI_ALLOC_DEFAULT));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/GASPI_OpenMP_threads/linsolv/src/exchange_matrix/3"}
{"code": "for (int i = 0; i < len; i++)\n  sortDistances[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/7"}
{"code": "for (index = 0; index < count; index += 1)\n{\n  SHA512_CTX ctx;\n  unsigned char tmp[(512 / 8) + 47];\n  int len = EncKeyLen[index];\n  unsigned Lcount = loopCnt - 1;\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, cursalt, 8);\n  SHA512_Update(&ctx, EncKey[index], len);\n  memcpy(&tmp[512 / 8], (char *) EncKey[index], len);\n  SHA512_Final(tmp, &ctx);\n  len += 512 / 8;\n  do\n  {\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, tmp, len);\n    SHA512_Final(tmp, &ctx);\n  }\n  while (--Lcount);\n  SHA512_Init(&ctx);\n  SHA512_Update(&ctx, tmp, len);\n  SHA512_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/drupal7_fmt_plug/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  for (int j = 0; j < SIZE; j++)\n  {\n    D1[(i * SIZE) + j] = Dinit[(i * SIZE) + j] * 4546;\n  }\n\n}\n\n", "pragma": "omp distribute parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/SYRK/syrk/0"}
{"code": "for (i = 0; i < (channels * overlapLength); i += 4)\n{\n  corr += ((mixingPos[i] * compare[i]) + (mixingPos[i + 1] * compare[i + 1])) >> overlapDividerBits;\n  corr += ((mixingPos[i + 2] * compare[i + 2]) + (mixingPos[i + 3] * compare[i + 3])) >> overlapDividerBits;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/svn2github/OpenMPT/tags/1.25.01.00/include/soundtouch/source/SoundTouch/TDStretch/3"}
{"code": "for (j = 0; j < N; j++)\n{\n  if ((points_arr[j].cluster_x == x) && (points_arr[j].cluster_y == y))\n  {\n    sum_x += points_arr[j].x;\n    sum_y += points_arr[j].y;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for private (j), reduction (+: sum_x), reduction (+: sum_y)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Stefani237/K-MEANS/Initial/func/6"}
{"code": "for (size_t i = 0; i < (numberOfSpots - 1); i++)\n{\n  array[i] = euclideanDistances[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mikalaki/Vantage_point_tree_C_and_parallelism/vptree/src/vptree_openmp/3"}
{"code": "for (j = 1; j <= 1024; j++)\n{\n  q = (j % 256) + 1;\n  if ((q >= xstart[0]) && (q <= xend[0]))\n  {\n    r = ((3 * j) % 256) + 1;\n    if ((r >= ystart[0]) && (r <= yend[0]))\n    {\n      s = ((5 * j) % 128) + 1;\n      if ((s >= zstart[0]) && (s <= zend[0]))\n      {\n        chk.real = chk.real + u1[s - zstart[0]][r - ystart[0]][q - xstart[0]].real, chk.imag = chk.imag + u1[s - zstart[0]][r - ystart[0]][q - xstart[0]].imag;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/24"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  x1 = _mm_load_ps((float *) (&vX1[i]));\n  x2 = _mm_load_ps((float *) (&vX2[i]));\n  y = _mm_add_ps(x1, x2);\n  _mm_store_ps((float *) (&vY[i]), y);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zhoupeikun/Parallel-Programming/TP2/12/0"}
{"code": "for (i = 0; i < nra; i++)\n{\n  for (j = 0; j < nca; j++)\n  {\n    a[i][j] = (double) (i + j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonyz0x0/parallel-computing/omp_saxp/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < m; j++)\n  {\n    printf(\"%s%d[%d][%d]:%f  \", name, dev, i, j, A[(i * m) + j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/jacobi/jacobi_ompacc_mdev/1"}
{"code": "for (i = 0; i < n; ++i)\n{\n  a[i] = _a + (i * n);\n  if (_evec)\n    evec[i] = _evec + (i * n);\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/2"}
{"code": "for (int j = 1; j < ny; j += 2)\n{\n  for (int i = 2; i < nx; i += 2)\n  {\n    temp = inv * ((rhs[i + ((nx + 1) * j)] + (hy_2 * (get(i + 1, j) + get(i - 1, j)))) + (hx_2 * (get(i, j + 1) + get(i, j - 1))));\n    set(i, j, temp);\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for private (temp) schedule (static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/akjain90/OpenMP-parallized-RBGS-solver/matrix/5"}
{"code": "for (int i = 0; i < nweights; i++)\n{\n  weight_updates[i] *= p3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/connect-omp-cpu/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < m; j++)\n    (fout << array[i][j]) << \" \";\n\n  fout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp-tasks/scalar_sections/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  temp[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rishabh4402/parallelImplementationCgD/cgd/2"}
{"code": "for (i = 0; i < np1; i++)\n{\n  for (j = 0; j < np2; j++)\n    for (k = 0; k < np3; k++)\n  {\n    if ((((i + j) + k) % 2) == 1)\n      f[i][j][k].Re *= -1.0;\n\n  }\n\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dlcheng/LTic/local_shape_transfer/3"}
{"code": "for (int i = 0; i < (*rowsNumber); i++)\n{\n  for (int j = 0; j < (*columnsNumber); j++)\n  {\n    (*fullMatrixFromFile)[((*rowsNumber) * i) + j] = (*twoDMatrix)[i][j] - 48;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AbdullahAlSolaiman/ParallelComputingProject1/AbdullahAlSolaiman_AlternativeAssesment/2"}
{"code": "for (int i = 0; i < MAPPER_THREADS; i++)\n  omp_init_lock(&reader_mapper_locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ramachav/Map-Reduce-Multi-Threaded/Map_Reduce_Code/map_reduce/12"}
{"code": "for (j = 0; j < ncols; ++j)\n{\n  for (i = 0; i < nrows; ++i)\n  {\n    if (input[i][j] != 0)\n    {\n      if (input[i][P[ijk]] != 0)\n      {\n        intersection[j]++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(j, i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/reorder/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      lhs[0 + 5][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 5][i][j][k] = lhs[1][i][j][k] - (dttz2 * speed[i][j][k - 1]);\n      lhs[2 + 5][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 5][i][j][k] = lhs[3][i][j][k] + (dttz2 * speed[i][j][k + 1]);\n      lhs[4 + 5][i][j][k] = lhs[4][i][j][k];\n      lhs[0 + 10][i][j][k] = lhs[0][i][j][k];\n      lhs[1 + 10][i][j][k] = lhs[1][i][j][k] + (dttz2 * speed[i][j][k - 1]);\n      lhs[2 + 10][i][j][k] = lhs[2][i][j][k];\n      lhs[3 + 10][i][j][k] = lhs[3][i][j][k] - (dttz2 * speed[i][j][k + 1]);\n      lhs[4 + 10][i][j][k] = lhs[4][i][j][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/79"}
{"code": "for (i = 1; i < vals[0]; i++)\n{\n  total_len += gene_lens[i];\n  gene_prefixes[i] = (gene_prefixes[i - 1] + gene_lens[i - 1]) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcom48/Parallel-Sequence-Alignment/mmarasco-seqalkway/12"}
{"code": "for (int32_t i = 0; i < ((width / 2) * (height / 2)); i++)\n  *(D + i) = -10;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/17"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  stats->vertices[v] = v;\n  stats->degrees[v] = graph->vertices->out_degree[v];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/incrementalAggregation/0"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  for (m = 0; m < 5; m++)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,m ,dssp ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/85"}
{"code": "for (j = 1; j <= n; j++)\n{\n  for (i = 1; i <= m; i++)\n  {\n    fprintf(output_unit, \" %d\", grid[i + (j * (m + 2))]);\n  }\n\n  fprintf(output_unit, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/plloaao/lifegame_and_openmp/lifegame_omp/5"}
{"code": "for (i = 0; i < npts; i++)\n{\n  coldreal[i] = fftarr[i * 2];\n  coldimag[i] = fftarr[(i * 2) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/reedv/Tircis/tircis_process_cmd_v4/geneprocess/8"}
{"code": "for (i = 0; i <= N; i++)\n{\n  x = (i - 0.5f) * h;\n  for (j = 0; j <= N; j++)\n  {\n    y = (j - 0.5f) * h;\n    d00 = dens[i + ((N + 2) * j)];\n    d01 = dens[i + ((N + 2) * (j + 1))];\n    d10 = dens[(i + 1) + ((N + 2) * j)];\n    d11 = dens[(i + 1) + ((N + 2) * (j + 1))];\n    glColor3f(d00, d00, d00);\n    glVertex2f(x, y);\n    glColor3f(d10, d10, d10);\n    glVertex2f(x + h, y);\n    glColor3f(d11, d11, d11);\n    glVertex2f(x + h, y + h);\n    glColor3f(d01, d01, d01);\n    glVertex2f(x, y + h);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo2a/demo/3"}
{"code": "for (long long x = average + 1; x <= d; x++)\n{\n  sum = sum + x;\n  counter++;\n}\n\n", "pragma": "#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GennadySX/vvrs/lab_1/main/3"}
{"code": "for (int j = x_min - depth; j <= ((x_max + 1) + depth); j++)\n{\n  #pragma ivdep\n  for (int k = 1; k <= depth; k++)\n  {\n    mass_flux_x[FTNREF2D(j, y_max + k, x_max + 5, x_min - 2, y_min - 2)] = mass_flux_x[FTNREF2D(j, y_max - k, x_max + 5, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/49"}
{"code": "for (i = 0; i < N; i += N / 8)\n{\n  for (j = 0; j < N; j += N / 8)\n  {\n    printf(\"%.2f \", h[current][i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanhineam/2d-heat/openmp/5"}
{"code": "for (int ix = 2; ix < (nx + 2); ix++)\n{\n  for (int iy = 2; iy < (ny + 2); iy++)\n  {\n    for (int iz = 2; iz < (nz + 2); iz++)\n    {\n      int s = columnMajorLinearIndex(ix, iy, iz, nx + 4, ny + 4, nz + 4);\n      if (e[s] > freezeoutEnergyDensity)\n        accumulator += 1;\n\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp parallel for collapse(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/derekeverett/cpu-vh/freezeout/FreezeOut/2"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  s[i].position.x = tmpPosition[i].x;\n  s[i].position.y = tmpPosition[i].y;\n  s[i].velocity.x = tmpVelocity[i].x;\n  s[i].velocity.y = tmpVelocity[i].y;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/quangphan2405/parallel_computing/openMP/parallel/7"}
{"code": "for (i = current_index; i < master_end; i++)\n{\n  double y0 = ((i / width) * vert_int) + lower;\n  double x0 = ((i % width) * hori_int) + left;\n  int repeats = 0;\n  double x = 0;\n  double y = 0;\n  double length_squared = 0;\n  while ((repeats < 100000) && (length_squared < 4))\n  {\n    double temp = ((x * x) - (y * y)) + x0;\n    y = ((2 * x) * y) + y0;\n    x = temp;\n    length_squared = (x * x) + (y * y);\n    ++repeats;\n  }\n\n  image_loc[i] = repeats;\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aalty/MPI-OpenMP-Mandlebrot-Set/ms_hybrid/1"}
{"code": "for (i = 1; i <= m; i++)\n{\n  tid = omp_get_thread_num();\n  nthreads = omp_get_num_threads();\n  printf(\"second for loop: %d, id = %d\\n\", nthreads, tid);\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wipping/openMP_demo/chapter6/nf/1"}
{"code": "for (tj = *spot; tj < varNumF2; tj++)\n{\n  Y[o][tj].y = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vazexqi/OpenMPMicroBenchmarks/ParallelFor_vs_ParallelTask/ART2/scanner_for/26"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total_error += squared_errors[i];\n}\n\n", "pragma": "\t\t#pragma omp parallel for reduction(+ : total_error)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenxuhao/gardenia/src/sgd/omp_target/3"}
{"code": "for (i = 1; i < 1000000; i++)\n{\n  printf(\"%f\\n\", pow(i, 4));\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/matiasmartineza/learning_omp/final_test/sum/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"%4d\", A[i]);\n  if (i == (N - 1))\n  {\n    printf(\"\\n\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimgrav/OpenMP/OMParrayMulti/1"}
{"code": "for (int kk = 0; kk < (N + 2); kk += 2)\n{\n  for (int jj = 0; jj < (N + 2); jj += 2)\n  {\n    fill_array3d(new_X, N / 2, (N / 2) + 1, jj / 2, kk / 2, boundarycondition3d(N / 2, 0, 0, 0));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcrestel/parallelmultigrid/ParallelCode/src/restriction3d/9"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n{\n  idx = (i * n) + j;\n  uo[idx] = u0[idx];\n  uc[idx] = u1[idx];\n}\n\n\n", "pragma": "omp parallel for num_threads(nthreads) private(idx, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/deepakguptancsu/Lake-simulation-parallel-processing/omp_acc/lake/0"}
{"code": "for (int ii = HALO_PAD; ii < (_chunk.z - HALO_PAD); ++ii)\n{\n  for (int jj = 0; jj < depth; ++jj)\n  {\n    for (int kk = HALO_PAD; kk < (_chunk.x - HALO_PAD); ++kk)\n    {\n      int base = ((ii * _chunk.x) * _chunk.y) + kk;\n      buffer[base + (((_chunk.y - HALO_PAD) + jj) * _chunk.x)] = buffer[base + ((((_chunk.y - HALO_PAD) - 1) - jj) * _chunk.x)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf3D_OpenMP4/ext_update_halo/2"}
{"code": "for (int i = 0; i < (ARRAY_SIZE - 1); i++)\n{\n  array[i] = int_rand(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/TheNosiriN/University-OpenMP-assignment/full_assignment/5"}
{"code": "for (m = 0; m <= 2; m += 1)\n{\n  rhs[m][i][j2][k] = rhs[m][i][j2][k] - (lhs[n + 0][i][j2][k] * rhs[m][i][j][k]);\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/186"}
{"code": "for (i = 0; i < (num_particles / 512); ++i)\n{\n  for (j = 0; j < (num_particles / 512); j++)\n  {\n    calculate_force_bs(&particles[i], &particles[j], &forces[i], i * 512, j * 512);\n  }\n\n  update_particle_bs(&particles[i], &forces[i]);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_39_nbody/0"}
{"code": "for (int k = 0; k < ((Size * Size) - Size); k += Size + 1)\n{\n  for (int i = k + Size; i < (Size * Size); i += Size)\n  {\n    tmp = (-pMatrix[i]) / pMatrix[k];\n    for (int j = i; j < (i + Size); j++)\n    {\n      for (int h = k; h < (k + Size); h++)\n      {\n        if (j == (h + (Size * count)))\n        {\n          pMatrix[j] += pMatrix[h] * tmp;\n        }\n\n      }\n\n    }\n\n    count++;\n  }\n\n  count = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savinaDaria/Cramer_rule_OpenMP/lab2OpenMP/lab2OpenMP/3"}
{"code": "for (i_imopVarPre76 = 1; i_imopVarPre76 <= n; i_imopVarPre76++)\n{\n  x_imopVarPre75[i_imopVarPre76] = 0.0;\n  mark[i_imopVarPre76] = 0;\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/CG/cg/3"}
{"code": "for (i = 0; i < (simu_opts->num_stability + 1); i++)\n{\n  if (f_s[i] != 0)\n  {\n    fclose(f_s[i]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/64"}
{"code": "for (i = 0; i <= n; i++)\n{\n  win[i] = 0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Leonardo-Cortez/OpenMP/OrdenamientoCRCW/0"}
{"code": "for (int i = 0; i < ns; i++)\n{\n  (((cout << \"rho species \") << i) << \" = \") << rhoINIT[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/77"}
{"code": "for (unsigned int i = begin; i < end; i++)\n{\n  geno.Get_OneSNP_StdGeno(i, &vec);\n  float val1 = dot(vec, m_bVec);\n  m_bout += val1 * vec;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/8"}
{"code": "for (i = 1; i < n; i++)\n{\n  B[i] = B[0] + (i * n);\n  if (!B[i])\n  {\n    printf(\"memory failed \\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafalcode/openmping/mmmunr_omp/2"}
{"code": "for (i = 0; i < p; i++)\n{\n  pi += arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nishi1612/High-Performance-Computing/Lab2/201601408-201601059-trapezoidal-private/parallel_measurement/2"}
{"code": "for (i = 0; i < (1 << 11); i++)\n{\n  prv_buff1[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/6"}
{"code": "for (i = 0; i < n; i++)\n  printf(\"%d \", iters[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/miguelrochajr/ParallelProgramming/BookExercises/Chapter5/Question9/q9/2"}
{"code": "for (int i = 0; i < height; i++)\n{\n  int j;\n  for (j = 0; j < width; j++)\n  {\n    int simd_val = buf_simd[(i * width) + j];\n    int sc_val = buf_sc[(i * width) + j];\n    if (simd_val != sc_val)\n    {\n      fprintf(stderr, \"[%d,%d] -> %d != %d\\n\", i, j, sc_val, simd_val);\n      return 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/simd/mic/success_simd_40_mandel/4"}
{"code": "for (int x = 1; x <= iters; x++)\n  i.meanFilterTest(x);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bavudaia/Picturesque/imageproc/18"}
{"code": "for (int i = 0; i < blocksize; i++)\n{\n  for (int j = 0; j < blocksize; j++)\n  {\n    inv[i][j] = 0;\n  }\n\n  inv[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/radinshayanfar/MCP/HW4/Q3/8"}
{"code": "for (currentRow = 1; currentRow < (sizeUniverseX - 1); currentRow++)\n{\n  for (currentColumn = 1; currentColumn < (sizeUniverseY - 1); currentColumn++)\n  {\n    master[currentRow][currentColumn] = slave[currentRow][currentColumn];\n  }\n\n}\n\n", "pragma": "omp parallel for private(currentRow, currentColumn)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YiannisN/GameOfLife_C_Threads_OpenMP/OpenMP/src/angel/1"}
{"code": "for (i = 1; i <= nmax; i++)\n{\n  n += i;\n}\n\n", "pragma": "  #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stevenvdb/travisci_openmp/main/0"}
{"code": "for (int j = 0; j < 1000000; j++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/projjal1/Parallel-Programming/openmp/diff-cs-openmp/2"}
{"code": "for (index = 0; index < count; index++)\n{\n  compute_hash(cur_salt, saved_key[index], (unsigned char *) crypt_out[index]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/ike_fmt_plug/0"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 3; k <= (grid_points[2] - 4); k++)\n    {\n      lhs[0][i][j][k] = lhs[0][i][j][k] + comz1;\n      lhs[1][i][j][k] = lhs[1][i][j][k] - comz4;\n      lhs[2][i][j][k] = lhs[2][i][j][k] + comz6;\n      lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n      lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/SP/sp/18"}
{"code": "for (k = lb2; k <= ub2; ++k)\n{\n  for (j = lb1; j <= ub1; ++j)\n  {\n    for (i = lb0; i <= ub0; ++i)\n    {\n      destinationDataPointer[(arraySize_X_dest * ((arraySize_Y_dest * k) + j)) + i] = (((((sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * ((k - lb2src) + (-1))) + (j - lb1src))) + (i - lb0src)] + sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * ((k - lb2src) + 1)) + (j - lb1src))) + (i - lb0src)]) + sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * (k - lb2src)) + ((j - lb1src) + (-1)))) + (i - lb0src)]) + sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * (k - lb2src)) + ((j - lb1src) + 1))) + (i - lb0src)]) + sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * (k - lb2src)) + (j - lb1src))) + ((i - lb0src) + (-1))]) + sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * (k - lb2src)) + (j - lb1src))) + ((i - lb0src) + 1)]) + (sourceDataPointer[(arraySize_X_src * ((arraySize_Y_src * (k - lb2src)) + (j - lb1src))) + (i - lb0src)] * (-6.00000));\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/ShiftCalculus4/refCode/test_mpi_v1/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  if (flag[i] == 1)\n  {\n    comp1[psum[i] - 1] = data[i];\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/StarlAllen/HPC/openmp/radixSort/sort_radix/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = (int) (rand() % 10);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram2/0"}
{"code": "for (int left = 0; left < (n - len); left++)\n{\n  int right = left + len;\n  long long localMin = 1LL << 60;\n  long long product = sizes[left] * sizes[right + 1];\n  for (int cut = left; cut < right; cut++)\n    localMin = (localMin < ((dp[(left * n) + cut] + dp[(right * n) + (cut + 1)]) + (product * sizes[cut + 1]))) ? (localMin) : ((dp[(left * n) + cut] + dp[(right * n) + (cut + 1)]) + (product * sizes[cut + 1]));\n\n  dp[(left * n) + right] = (dp[(right * n) + left] = localMin);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DylanHIJ/ParallelProgramming-NTU/workshop/OpenMP/MatrixChainMultiplication/main/0"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA1)\n{\n  unsigned char master[SSE_GROUP_SZ_SHA1][1024];\n  int i;\n  int len[SSE_GROUP_SZ_SHA1];\n  unsigned char *pin[SSE_GROUP_SZ_SHA1];\n  unsigned char *pout[SSE_GROUP_SZ_SHA1];\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    len[i] = strlen(saved_key[i + index]);\n    pin[i] = (unsigned char *) saved_key[i + index];\n    pout[i] = master[i];\n  }\n\n  pbkdf2_sha1_sse((const unsigned char **) pin, len, (unsigned char *) cur_salt->salt, 8, 1000, pout, 1024, 0);\n  for (i = 0; i < SSE_GROUP_SZ_SHA1; ++i)\n  {\n    SHA512_CTX ctx;\n    SHA512_Init(&ctx);\n    SHA512_Update(&ctx, master[i], 1024);\n    SHA512_Final((unsigned char *) crypt_out[index + i], &ctx);\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/solarwinds_fmt_plug/3"}
{"code": "for (i = 0; i < sc_threads; i++)\n  free_region_t(&memory[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/4"}
{"code": "for (i = 0; i < best_tour->cities.size(); i++)\n{\n  (cout << best_tour->cities[i]) << \" \";\n  result_path[i] = best_tour->cities[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmaruEscalante/cpd-tsp-project/src/Algoritmo/tsp/1"}
{"code": "for (i = 0; i < (*lin); i++)\n{\n  for (j = 0; j < (*col); j++)\n  {\n    fscanf(arquivo, \"%d\", &matriz[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rodrigoborgesdeoliveira/Matrix-Multiplication-and-Sum-with-OpenMP-and-PThreads/Matrizes OpenMP/matriz2d/4"}
{"code": "for (uint64_t i = 0; i < length; i++)\n  data[i] = density(engine);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JGU-HPC/parallelprogrammingbook/chapter3/AVX/matrix_matrix_mult/0"}
{"code": "for (int k = 0; k < (n - 1); ++k)\n{\n  for (int i = k + 1; i < n; ++i)\n  {\n    double t = A[i][k] / A[k][k];\n    b[i] -= t * b[k];\n    for (int j = k + 1; j < n; ++j)\n    {\n      A[i][j] -= t * A[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daria-kulikova/parallel-processing/solving-polynomial-equations/equations/1"}
{"code": "for (int i = 0; i < numcells; i++)\n{\n  x_n[i] = x_n1[i];\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/Godunov_1d_omp/Godunov_1d_omp/source/iteration/18"}
{"code": "for (i = n / 2; i < n; i++)\n{\n  for (j = n / 2; j < n; j++)\n    masC[i][j] = masA[i][j] + masB[i][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/drewdru/parallel_labs_OpenMP/parallel_lab1/parallel_lab1/Vector \u041a\u041e\u041f\u0418\u042f 1/10"}
{"code": "for (i = 0; i < (1 << 25); i++)\n  key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/24"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  for (int j = 0; j < 8; j++)\n  {\n    matrix[i][j] = rand() % 2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Examples/openmp/1"}
{"code": "for (int j = st; j < end; j++)\n  arr[j - st] = s->b_U[idx(i, j, k)];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/171"}
{"code": "for (int i = 0; i < (frameWidth * frameHeight); i++)\n  fprintf(f, \"%d %d %d \", toInt(c[i].getX()), toInt(c[i].getY()), toInt(c[i].getZ()));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/soumik12345/Radium/src/lib/Renderer/0"}
{"code": "for (int p1 = 0; p1 < divider; p1++)\n  for (int y1 = 0; y1 < divider; y1++)\n{\n  if (y1 == dy)\n    break;\n\n  for (int x1 = 0; x1 < divider; x1++)\n  {\n    if (x1 == dx)\n      break;\n\n    sum += *(((matrixdata + ((x * divider) + x1)) + (((y * divider) + y1) * DtCol)) + ((((p * divider) + p1) * DtCol) * DtRow));\n  }\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/26"}
{"code": "for (i = 0; i < N; i++)\n{\n  v[i] = v[i] * v[i];\n}\n\n", "pragma": "#pragma omp distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/csc-training/summerschool/gpu-openmp/demos/vector/1"}
{"code": "for (int x_pixel = 0; x_pixel < nb_pixel_x; x_pixel++)\n  for (int y_pixel = 0; y_pixel < nb_pixel_y; y_pixel++)\n{\n  double x_init = (-2) + (x_pixel * 0.001);\n  double y_init = (-2) + (y_pixel * 0.001);\n  double x = x_init;\n  double y = y_init;\n  int iter = 0;\n  for (iter = 0; iter < 1000; iter++)\n  {\n    double previous_y = y;\n    double previous_x = x;\n    if (((x * x) + (y * y)) > 4)\n      break;\n\n    x = ((previous_x * previous_x) - (previous_y * previous_y)) + x_init;\n    y = ((2 * previous_x) * previous_y) + y_init;\n  }\n\n  iter_tab[(x_pixel * nb_pixel_y) + y_pixel] = iter;\n}\n\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/logarithm27/Mandelbrot_Fractal_Set_Parallelism/mandelbrot_open_mp/0"}
{"code": "for (int i = 0; i < size; i++)\n{\n  (*v)[i] = rand() % 10000;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luanteylo/minicurso-OpenMP/source_code/openmp/6_for-par1/1"}
{"code": "for (int i = 0; i < listnum; i++)\n{\n  list1[i] = (int) log(i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zithiat/OpenMP/Parallel/LogarithmArray/0"}
{"code": "for (i = 0; i < 16; i++)\n  for (j = 0; j < 16; j++)\n{\n  s++;\n  u = i + j;\n}\n\n\n", "pragma": "omp for simd schedule(static, 32) reduction(+:s) lastprivate(u) collapse(2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/simd-11/0"}
{"code": "for (int img = 0; img < number_of_images; ++img)\n{\n  unsigned char temp = 0;\n  file.read((char *) (&temp), sizeof(temp));\n  int number = (double) temp;\n  for (int i = 0; i < n3; ++i)\n  {\n    mnist_label_data[img][i] = 0.0;\n  }\n\n  mnist_label_data[img][number] = 1.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jordanott/Neural-Network-Parallelization/training_private_nn/1"}
{"code": "for (int i = 0; i < min(num_tiles, (int) data.size()); ++i)\n{\n  k_tiles.push_back((data.size() * i) / num_tiles);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EmaPajic/Parallel-Random-Forest/random_forest_openmp/4"}
{"code": "for (i = 0; i < c_nx; i++)\n{\n  for (j = 0; j < c_ny; j++)\n  {\n    for (k = 0; k < c_nz; k++)\n    {\n      idi = 2 * i;\n      idj = 2 * j;\n      idk = 2 * k;\n      if ((((((i != 0) && (i != (c_nx - 1))) && (j != 0)) && (j != (c_ny - 1))) && (k != 0)) && (k != (c_ny - 1)))\n      {\n        c->f3d[i][j][k] = (((0.125 * f->f3d[idi][idj][idk]) + (0.0625 * (((((f->f3d[idi + 1][idj][idk] + f->f3d[idi - 1][idj][idk]) + f->f3d[idi][idj + 1][idk]) + f->f3d[idi][idj - 1][idk]) + f->f3d[idi][idj][idk + 1]) + f->f3d[idi][idj][idk - 1]))) + (0.03125 * (((((((((((f->f3d[idi + 1][idj][idk + 1] + f->f3d[idi - 1][idj][idk + 1]) + f->f3d[idi][idj + 1][idk + 1]) + f->f3d[idi][idj - 1][idk + 1]) + f->f3d[idi + 1][idj][idk - 1]) + f->f3d[idi - 1][idj][idk - 1]) + f->f3d[idi][idj + 1][idk - 1]) + f->f3d[idi][idj - 1][idk - 1]) + f->f3d[idi + 1][idj + 1][idk]) + f->f3d[idi - 1][idj + 1][idk]) + f->f3d[idi + 1][idj - 1][idk]) + f->f3d[idi - 1][idj - 1][idk]))) + (0.015625 * (((((((f->f3d[idi + 1][idj + 1][idk + 1] + f->f3d[idi + 1][idj + 1][idk - 1]) + f->f3d[idi + 1][idj - 1][idk + 1]) + f->f3d[idi + 1][idj - 1][idk - 1]) + f->f3d[idi - 1][idj + 1][idk + 1]) + f->f3d[idi - 1][idj + 1][idk - 1]) + f->f3d[idi - 1][idj - 1][idk + 1]) + f->f3d[idi - 1][idj - 1][idk - 1]));\n      }\n      else\n      {\n        c->f3d[i][j][k] = f->f3d[idi][idj][idk];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/Mesh/7"}
{"code": "for (int y = 0; y < Y_SIZE; y++)\n  for (int x = 0; x < X_SIZE; x++)\n{\n  const float lx_rot = 30.0f;\n  const float ly_rot = 0.0f;\n  const float lx_expan = 0.5f;\n  const float ly_expan = 0.5f;\n  int lx_move = 0;\n  int ly_move = 0;\n  float affine[2][2];\n  float i_affine[2][2];\n  float beta[2];\n  float i_beta[2];\n  float det;\n  float x_new;\n  float y_new;\n  float x_frac;\n  float y_frac;\n  float gray_new;\n  int m;\n  int n;\n  unsigned short output_buffer;\n  affine[0][0] = lx_expan * cosf((lx_rot * PI) / 180.0f);\n  affine[0][1] = ly_expan * sinf((ly_rot * PI) / 180.0f);\n  affine[1][0] = lx_expan * sinf((lx_rot * PI) / 180.0f);\n  affine[1][1] = ly_expan * cosf((ly_rot * PI) / 180.0f);\n  beta[0] = lx_move;\n  beta[1] = ly_move;\n  det = (affine[0][0] * affine[1][1]) - (affine[0][1] * affine[1][0]);\n  if (det == 0.0f)\n  {\n    i_affine[0][0] = 1.0f;\n    i_affine[0][1] = 0.0f;\n    i_affine[1][0] = 0.0f;\n    i_affine[1][1] = 1.0f;\n    i_beta[0] = -beta[0];\n    i_beta[1] = -beta[1];\n  }\n  else\n  {\n    i_affine[0][0] = affine[1][1] / det;\n    i_affine[0][1] = (-affine[0][1]) / det;\n    i_affine[1][0] = (-affine[1][0]) / det;\n    i_affine[1][1] = affine[0][0] / det;\n    i_beta[0] = ((-i_affine[0][0]) * beta[0]) - (i_affine[0][1] * beta[1]);\n    i_beta[1] = ((-i_affine[1][0]) * beta[0]) - (i_affine[1][1] * beta[1]);\n  }\n\n  x_new = ((i_beta[0] + (i_affine[0][0] * (x - (X_SIZE / 2.0f)))) + (i_affine[0][1] * (y - (Y_SIZE / 2.0f)))) + (X_SIZE / 2.0f);\n  y_new = ((i_beta[1] + (i_affine[1][0] * (x - (X_SIZE / 2.0f)))) + (i_affine[1][1] * (y - (Y_SIZE / 2.0f)))) + (Y_SIZE / 2.0f);\n  m = (int) floorf(x_new);\n  n = (int) floorf(y_new);\n  x_frac = x_new - m;\n  y_frac = y_new - n;\n  if ((((m >= 0) && ((m + 1) < X_SIZE)) && (n >= 0)) && ((n + 1) < Y_SIZE))\n  {\n    gray_new = ((1.0f - y_frac) * (((1.0f - x_frac) * input_image[(n * X_SIZE) + m]) + (x_frac * input_image[((n * X_SIZE) + m) + 1]))) + (y_frac * (((1.0f - x_frac) * input_image[((n + 1) * X_SIZE) + m]) + (x_frac * input_image[(((n + 1) * X_SIZE) + m) + 1])));\n    output_buffer = (unsigned short) gray_new;\n  }\n  else\n    if (((((m + 1) == X_SIZE) && (n >= 0)) && (n < Y_SIZE)) || ((((n + 1) == Y_SIZE) && (m >= 0)) && (m < X_SIZE)))\n  {\n    output_buffer = input_image[(n * X_SIZE) + m];\n  }\n  else\n  {\n    output_buffer = WHITE;\n  }\n\n\n  output_image[(y * X_SIZE) + x] = output_buffer;\n}\n\n\n", "pragma": "      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/affine-omp/main/0"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j += 1)\n{\n  rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n}\n\n", "pragma": "omp parallel for private (j) firstprivate (dssp,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/140"}
{"code": "for (int i = 0; i < n; i++)\n{\n  ptr[i] = malloc((sizeof(int)) * m);\n  for (int j = 0; j < m; j++)\n  {\n    ptr[i][j] = rand() % 10;\n    if (print_arr)\n      printf(\"%d \", ptr[i][j]);\n\n  }\n\n  if (print_arr)\n    printf(\"\\n\");\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanyaio/openmp/t1/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (i == j)\n    {\n      graph[(i * N) + j] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EdwardAJ/OpenMP-Parallel-Computing/src/openmp/6"}
{"code": "for (i = 0; i <= (inLen - 1); i += 1)\n{\n  output[outLen++] = input[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB018-plusplus-orig-yes/1"}
{"code": "for (v = 0; v < graphHeavy->num_vertices; v++)\n{\n  if (getBit(bitmapSetCurr, v))\n  {\n    uint32_t degree = graphHeavy->vertices->out_degree[v];\n    uint32_t edge_idx = graphHeavy->vertices->edges_idx[v];\n    uint32_t j;\n    for (j = edge_idx; j < (edge_idx + degree); j++)\n    {\n      uint32_t src = EXTRACT_VALUE(graphHeavy->sorted_edges_array->edges_array_src[j]);\n      uint32_t dest = EXTRACT_VALUE(graphHeavy->sorted_edges_array->edges_array_dest[j]);\n      float weight = 1;\n      if (arguments->algo_numThreads == 1)\n        activeVertices += SSSPRelax(src, dest, weight, stats);\n      else\n        activeVertices += SSSPAtomicRelax(src, dest, weight, stats);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) shared(bitmapSetCurr, graphHeavy, stats) reduction(+ : activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/5"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    density1[FTNREF2D(1 - j, k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D(0 + j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/6"}
{"code": "for (k = 1; k <= (grid_points[2] - 2); k += 1)\n{\n  rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i][j1][k])) - (lhs[n + 4][i][j][k] * rhs[m][i][j2][k]);\n}\n\n", "pragma": "omp parallel for private (k) firstprivate (n,j1,j2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/202"}
{"code": "for (j = 1; j <= ((lastrow - firstrow) + 1); j += 1)\n{\n  d = 0.0;\n  for (k = rowstr[j]; k <= (rowstr[j + 1] - 1); k += 1)\n  {\n    d = d + (a[k] * z[colidx[k]]);\n  }\n\n  r[j] = d;\n}\n\n", "pragma": "omp parallel for private (d,j,k) firstprivate (firstrow,lastrow)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/CG/cg/12"}
{"code": "for (i = 0; i < 512; i++)\n{\n  for (j = 0; j < 512; j++)\n  {\n    printf(\"%d \", c[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rajatkhanna1999/OpenMpCodes/MatrixMultiplictaion/2"}
{"code": "for (j = 0; j < n; j += step)\n{\n  int target = (j + step) - 1;\n  int prev = (j + (step / 2)) - 1;\n  if (target < n)\n  {\n    lessThan[target] = lessThan[prev] + lessThan[target];\n    greaterThan[target] = greaterThan[prev] + greaterThan[target];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/npersson001/Parallel-Quick-Sort/quick_sort_parallel_final/1"}
{"code": "for (size_t j = i + 1; j < rows; j++)\n{\n  size_t baseY = j * cols;\n  float sumXY = 0.0;\n  for (size_t k = 0; k < cols; k++)\n  {\n    float a = vectors[baseX + k];\n    float b = vectors[baseY + k];\n    sumXY += a * b;\n  }\n\n  float sumY = preSum[j];\n  float s3 = preS23[j];\n  float s1 = (sumXY * fCols) - (sumX * sumY);\n  float s4 = sqrtf(s2 * s3);\n  float correlation = s1 / s4;\n  size_t index = getIndex(i, j, rows);\n  output[index] = correlation;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dvhh/massCorrelation/src/correlationOMP/2"}
{"code": "for (unsigned int j = 1; j <= n; j++)\n{\n  for (unsigned int i = 1; i <= n; i++)\n  {\n    u[i + ((n + 2) * j)] -= (0.5f * n) * (p[(i + 1) + ((n + 2) * j)] - p[(i - 1) + ((n + 2) * j)]);\n    v[i + ((n + 2) * j)] -= (0.5f * n) * (p[i + ((n + 2) * (j + 1))] - p[i + ((n + 2) * (j - 1))]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/emasa/parallel-computing-2012-famaf-unc/proyectos/lab2/paralelo1a/solver/6"}
{"code": "for (i = 0; i < nx; i++)\n{\n  x = ((double) i) / ((double) (nx - 1));\n  for (j = 0; j < ny; j++)\n  {\n    y = ((double) j) / ((double) (ny - 1));\n    uexact[(i * npadded) + j] = u_exact(x, y);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chponte/omp4simd/src/POISSON/poisson_openmp/8"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_hid, 0);\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/6"}
{"code": "for (int i = 1; i < (gpu_count + 1); i++)\n{\n  dealloc_cuda(&tasks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Rickyboy320/hpc_bench/vector/vector/5"}
{"code": "for (int i = 0; i < N; i++)\n{\n  a[i] = (double) i;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for is_device_ptr(a) device(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/managed_memory/managed_memory/1"}
{"code": "for (i = 1; i <= m; i++)\n{\n  for (j = 1; j <= n; j++)\n  {\n    psinew[i][j] = 0.25 * ((((psi[i - 1][j] + psi[i + 1][j]) + psi[i][j - 1]) + psi[i][j + 1]) - zet[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for default(none), private(i,j), shared(psi,psinew,zet,m,n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yvonnezou/Hybrid_MPI-OpenMP/Hybrid programme in single style/jacobi/1"}
{"code": "for (int j = 1; j < (W + 1); j++)\n{\n  for (int k = 0; k < 3; k++)\n  {\n    mySendArr[j][k] = pixels[j - 1][k];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rochii/parallel-mandelbrot/hybrid/scripts/mandelbrot_hybrid_dynamic/2"}
{"code": "for (int i = (13 * n) / 16; i < ((14 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/21"}
{"code": "for (i = 1; i < (900000 - 1); i++)\n{\n  x = B[i] / (B[i] + 1.0);\n  A[i] = ((x + B[i]) + 1.0) / 1000.0;\n  C[i] = ((A[i] + C[i - 1]) + C[i + 1]) / 3.0;\n  E[i] = (x * x) / ((x * x) + 1.7);\n}\n\n", "pragma": "omp parallel for shared(A) shared(B) shared(C) shared(E)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sherrerap/OpenMPII/mix/problem2_mix/5"}
{"code": "for (i = 0; i < newTam; i++)\n{\n  free(A11[i]);\n  free(A12[i]);\n  free(A21[i]);\n  free(A22[i]);\n  free(B11[i]);\n  free(B12[i]);\n  free(B21[i]);\n  free(B22[i]);\n  free(C11[i]);\n  free(C12[i]);\n  free(C21[i]);\n  free(C22[i]);\n  free(M1[i]);\n  free(M2[i]);\n  free(M3[i]);\n  free(M4[i]);\n  free(M5[i]);\n  free(M6[i]);\n  free(M7[i]);\n  free(aux1[i]);\n  free(aux2[i]);\n  free(aux3[i]);\n  free(aux4[i]);\n  free(aux5[i]);\n  free(aux6[i]);\n  free(aux7[i]);\n  free(aux8[i]);\n  free(aux9[i]);\n  free(aux10[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Eduardodsb/Prog_Paralela_e_Distribuida/Trabalhos/Trabalho 3/Trab3_Strassen_OMP/8"}
{"code": "for (h = 1; h <= cnt; h++)\n{\n  if (f_sbml == 0)\n  {\n    strcpy(fpname, topoinfo->modelname);\n    if (simu_opts->exts == 0)\n    {\n      if (simu_opts->numKD != 0)\n      {\n        strcat(fpname, \"_KD\");\n        for (i = 0; i < simu_opts->numKD; i++)\n        {\n          sprintf(KDIDname, \"%d\", simu_opts->KDID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, KDIDname);\n        }\n\n      }\n\n      if (simu_opts->numOE != 0)\n      {\n        strcat(fpname, \"_OE\");\n        for (i = 0; i < simu_opts->numOE; i++)\n        {\n          sprintf(OEIDname, \"%d\", simu_opts->OEID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, OEIDname);\n        }\n\n      }\n\n      if (simu_opts->numDE != 0)\n      {\n        strcat(fpname, \"_DE\");\n        for (i = 0; i < simu_opts->numDE; i++)\n        {\n          sprintf(DEIDname, \"%d\", simu_opts->DEID[i]);\n          strcat(fpname, \"_\");\n          strcat(fpname, DEIDname);\n        }\n\n      }\n\n    }\n\n    strcat(fpname, \"_sbml\");\n    sprintf(modelIDname, \"%d\", modelID);\n    strcat(fpname, \"_\");\n    strcat(fpname, modelIDname);\n    sprintf(nstbname, \"%d\", h);\n    strcat(fpname, \"_\");\n    strcat(fpname, nstbname);\n    strcat(fpname, \".xml\");\n    f_sbml = fopen(fpname, \"w\");\n  }\n\n  fprintf(f_sbml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n  fprintf(f_sbml, \"<sbml level=\\\"2\\\" version=\\\"3\\\" xmlns=\\\"http://www.sbml.org/sbml/level2/version3\\\">\\n\");\n  fprintf(f_sbml, \"\\t<model name=\\\"No_%d_model_%d\\\">\\n\", modelID, h);\n  fprintf(f_sbml, \"\\t\\t<listOfFunctionDefinitions>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t<functionDefinition id=\\\"hillfunction\\\">\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\txmlns:sbml=\\\"http://www.sbml.org/sbml/level3/version2/core\\\">\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t<lambda>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> x </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> x0 </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> lamda </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<bvar><ci> nx </ci></bvar>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<plus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<ci> lamda </ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<minus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lamda</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<plus/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<cn>1.0</cn>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<power/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x0</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>nx</ci>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t</apply>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t\\t</lambda>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t\\t</math>\\n\");\n  fprintf(f_sbml, \"\\t\\t\\t</functionDefinition>\\n\");\n  fprintf(f_sbml, \"\\t\\t</listOfFunctionDefinitions>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfSpecies>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<species id=\\\"x%d\\\"  initialAmount=\\\"%f\\\"    name=\\\"%s\\\"/>\\n\", i, tmprlt->soln[(topoinfo->numG * (h - 1)) + i], topoinfo->Gname[i]);\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfSpecies>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfParameters>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"g%d\\\"  value=\\\"%f\\\"/>\\n\", i, tmprlt->paras[i]);\n  }\n\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"k%d\\\"  value=\\\"%f\\\"/>\\n\", i, tmprlt->paras[i + topoinfo->numG]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"T%d\\\"  value=\\\"%f\\\"/>\\n\", (3 * i) + (2 * topoinfo->numG), tmprlt->paras[(3 * i) + (2 * topoinfo->numG)]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"n%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 1, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 1]);\n  }\n\n  for (i = 0; i < topoinfo->numR; i++)\n  {\n    if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 1)\n    {\n      fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"lambda%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 2, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 2]);\n    }\n    else\n      if (topoinfo->prsrandrange[2][((3 * i) + 2) + (2 * topoinfo->numG)] == 2)\n    {\n      fprintf(f_sbml, \"\\t\\t\\t<parameter id=\\\"lambda%d\\\"  value=\\\"%f\\\"/>\\n\", ((3 * i) + (2 * topoinfo->numG)) + 2, tmprlt->paras[((3 * i) + (2 * topoinfo->numG)) + 2]);\n    }\n\n\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfParameters>\\n\");\n  fprintf(f_sbml, \"\\t\\t<listOfReactions>\\n\");\n  for (i = 0; i < topoinfo->numG; i++)\n  {\n    fprintf(f_sbml, \"\\t\\t\\t<reaction id=\\\"eq_%d\\\">\\n\", i + 1);\n    fprintf(f_sbml, \"\\t\\t\\t\\t<listOfProducts>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t<speciesReference species=\\\"x%d\\\" />\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t</listOfProducts>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t<kineticLaw>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\">\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<minus/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>g%d</ci>\\n\", i);\n    for (j = 0; j < topoinfo->numR; j++)\n    {\n      if (topoinfo->TargetG[j] == i)\n      {\n        if (topoinfo->TypeR[j] == 1)\n        {\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<divide/>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>hillfunction</ci>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", topoinfo->SourceG[j]);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>T%d</ci>\\n\", (2 * topoinfo->numG) + (3 * j));\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>n%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 1);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n        }\n        else\n          if (topoinfo->TypeR[j] == 2)\n        {\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>hillfunction</ci>\\n\");\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", topoinfo->SourceG[j]);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>T%d</ci>\\n\", (2 * topoinfo->numG) + (3 * j));\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>lambda%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 2);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t\\t<ci>n%d</ci>\\n\", ((2 * topoinfo->numG) + (3 * j)) + 1);\n          fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n        }\n\n\n      }\n\n    }\n\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t<times/>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>k%d</ci>\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t\\t<ci>x%d</ci>\\n\", i);\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t\\t</apply>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t\\t</math>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t\\t</kineticLaw>\\n\");\n    fprintf(f_sbml, \"\\t\\t\\t</reaction>\\n\");\n  }\n\n  fprintf(f_sbml, \"\\t\\t</listOfReactions>\\n\");\n  fprintf(f_sbml, \"\\t</model>\\n\");\n  fprintf(f_sbml, \"</sbml>\\n\");\n  fclose(f_sbml);\n  f_sbml = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CatGlasses77/RACIPE_multithreaded/RACIPELIB/65"}
{"code": "for (n = nzi - 1; n < nzt; n++)\n{\n  nn = nxhyd * n;\n  for (i = 0; i < ny; i++)\n  {\n    joff = (nxhd3 * i) + nn;\n    for (j = 0; j < nxh; j++)\n    {\n      at1 = crealf(f[(2 + (3 * j)) + joff]);\n      f[(2 + (3 * j)) + joff] = crealf(f[(1 + (3 * j)) + joff]) + (cimagf(f[(2 + (3 * j)) + joff]) * _Complex_I);\n      at2 = cimagf(f[(1 + (3 * j)) + joff]);\n      f[(1 + (3 * j)) + joff] = cimagf(f[(3 * j) + joff]) + (at1 * _Complex_I);\n      f[(3 * j) + joff] = crealf(f[(3 * j) + joff]) + (at2 * _Complex_I);\n    }\n\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (i = 0; i < ny; i++)\n      {\n        joff = (nxhd3 * i) + nn;\n        t1 = f[(3 * j1) + joff];\n        t2 = f[(1 + (3 * j1)) + joff];\n        t3 = f[(2 + (3 * j1)) + joff];\n        f[(3 * j1) + joff] = f[(3 * j) + joff];\n        f[(1 + (3 * j1)) + joff] = f[(1 + (3 * j)) + joff];\n        f[(2 + (3 * j1)) + joff] = f[(2 + (3 * j)) + joff];\n        f[(3 * j) + joff] = t1;\n        f[(1 + (3 * j)) + joff] = t2;\n        f[(2 + (3 * j)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = sct[kmr * j];\n        for (i = 0; i < ny; i++)\n        {\n          joff = (nxhd3 * i) + nn;\n          t2 = t1 * f[(3 * j2) + joff];\n          t3 = t1 * f[(1 + (3 * j2)) + joff];\n          t4 = t1 * f[(2 + (3 * j2)) + joff];\n          f[(3 * j2) + joff] = f[(3 * j1) + joff] - t2;\n          f[(1 + (3 * j2)) + joff] = f[(1 + (3 * j1)) + joff] - t3;\n          f[(2 + (3 * j2)) + joff] = f[(2 + (3 * j1)) + joff] - t4;\n          f[(3 * j1) + joff] += t2;\n          f[(1 + (3 * j1)) + joff] += t3;\n          f[(2 + (3 * j1)) + joff] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  kmr = nxyz / nx;\n  ani = 0.5 / ((((float) nx) * ((float) ny)) * ((float) nz));\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) - (crealf(sct[kmr * j]) * _Complex_I);\n    for (k = 0; k < ny; k++)\n    {\n      joff = (nxhd3 * k) + nn;\n      for (jj = 0; jj < 3; jj++)\n      {\n        t2 = conjf(f[(jj + (3 * (nxh - j))) + joff]);\n        t1 = f[(jj + (3 * j)) + joff] + t2;\n        t2 = (f[(jj + (3 * j)) + joff] - t2) * t3;\n        f[(jj + (3 * j)) + joff] = ani * (t1 + t2);\n        f[(jj + (3 * (nxh - j))) + joff] = ani * conjf(t1 - t2);\n      }\n\n    }\n\n  }\n\n  ani = 2.0 * ani;\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nxhd3 * k) + nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      f[(jj + (3 * nxhh)) + joff] = ani * conjf(f[(jj + (3 * nxhh)) + joff]);\n      f[jj + joff] = ani * ((crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I));\n    }\n\n  }\n\n  for (k = 0; k < ny; k++)\n  {\n    joff = (nxhd3 * k) + nn;\n    k1 = (mixup[k] - 1) / nryb;\n    if (k < k1)\n    {\n      k1 = (nxhd3 * k1) + nn;\n      for (i = 0; i < nxh; i++)\n      {\n        t1 = f[(3 * i) + k1];\n        t2 = f[(1 + (3 * i)) + k1];\n        t3 = f[(2 + (3 * i)) + k1];\n        f[(3 * i) + k1] = f[(3 * i) + joff];\n        f[(1 + (3 * i)) + k1] = f[(1 + (3 * i)) + joff];\n        f[(2 + (3 * i)) + k1] = f[(2 + (3 * i)) + joff];\n        f[(3 * i) + joff] = t1;\n        f[(1 + (3 * i)) + joff] = t2;\n        f[(2 + (3 * i)) + joff] = t3;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indy; l++)\n  {\n    ns2 = ns + ns;\n    km = nyh / ns;\n    kmr = km * nry;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = (nxhd3 * (j + k1)) + nn;\n        j2 = (nxhd3 * (j + k2)) + nn;\n        t1 = sct[kmr * j];\n        for (i = 0; i < nxh; i++)\n        {\n          t2 = t1 * f[(3 * i) + j2];\n          t3 = t1 * f[(1 + (3 * i)) + j2];\n          t4 = t1 * f[(2 + (3 * i)) + j2];\n          f[(3 * i) + j2] = f[(3 * i) + j1] - t2;\n          f[(1 + (3 * i)) + j2] = f[(1 + (3 * i)) + j1] - t3;\n          f[(2 + (3 * i)) + j2] = f[(2 + (3 * i)) + j1] - t4;\n          f[(3 * i) + j1] += t2;\n          f[(1 + (3 * i)) + j1] += t3;\n          f[(2 + (3 * i)) + j1] += t4;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n  for (k = 1; k < nyh; k++)\n  {\n    joff = nxhd3 * k;\n    k1 = ((nxhd3 * ny) - joff) + nn;\n    joff += nn;\n    for (jj = 0; jj < 3; jj++)\n    {\n      t1 = f[jj + k1];\n      f[jj + k1] = 0.5 * (cimagf(f[jj + joff] + t1) + (crealf(f[jj + joff] - t1) * _Complex_I));\n      f[jj + joff] = 0.5 * (crealf(f[jj + joff] + t1) + (cimagf(f[jj + joff] - t1) * _Complex_I));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,n,ns,ns2,km,kmr,k1,k2,jj,j1,j2,nn,joff,at1,at2,ani,t1, t2,t3,t4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/29"}
{"code": "for (i = 0; i < 10; i++)\n{\n  if ((arr[i] % 2) == 0)\n    e++;\n  else\n    o++;\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) shared(e, o)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Arrays/array_evenodd_count/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  #pragma cetus private(j)\n  #pragma loop name main#0#0\n  #pragma cetus parallel\n  for (j = 0; j < m; j++)\n  {\n    b[i][j] = i + j;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/dataracebench/DRB037-truedepseconddimension-orig-yes/0"}
{"code": "for (int edge = 0; edge < edge_count; edge++)\n{\n  fscanf(infile, \"%d %d\", &from_node, &to_node);\n  if (from_node != to_node)\n  {\n    from_node_id[edge_count_new] = from_node;\n    to_node_id[edge_count_new] = to_node;\n    outbound_count[from_node]++;\n    inbound_count[to_node]++;\n    edge_count_new++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ejhusom/IN3200/page_rank_partial_exam/src/PE_functions/3"}
{"code": "for (int k = 0; k < n; k++)\n{\n  max = 0.0;\n  for (int i = k; i < n; i++)\n  {\n    if (fabs(a[i][k]) > max)\n    {\n      max = fabs(a[i][k]);\n      kdash = i;\n    }\n\n  }\n\n  if (max == 0.0)\n  {\n    (cerr << \"Singular matrix.\") << endl;\n  }\n\n  int temp = p[k];\n  p[k] = p[kdash];\n  p[kdash] = temp;\n  double *tmp = a[k];\n  a[k] = a[kdash];\n  a[kdash] = tmp;\n  double tmpdbl = 0.0;\n  for (int i = 0; i < k; i++)\n  {\n    tmpdbl = l[k][i];\n    l[k][i] = l[kdash][i];\n    l[kdash][i] = tmpdbl;\n  }\n\n  u[k][k] = a[k][k];\n  for (int i = k + 1; i < n; i++)\n  {\n    l[i][k] = (a[i][k] * 1.0) / u[k][k];\n    u[k][i] = a[k][i];\n  }\n\n  int j = 0;\n  double utemp[(n - k) - 1];\n  for (int i = 0; i < ((n - k) - 1); i++)\n  {\n    utemp[i] = u[k][(i + k) + 1];\n  }\n\n  double *tempdub;\n  double *tempdub2;\n  double val;\n  double val2;\n  int ei = 0;\n  for (int i = k + 1; i < (n - 1); i += 2)\n  {\n    ei = i;\n    val = l[i][k];\n    val2 = l[i + 1][k];\n    tempdub = a[i];\n    tempdub2 = a[i + 1];\n    for (j = k + 1; j < n; j++)\n    {\n      tempdub[j] -= val * utemp[(j - k) - 1];\n      tempdub2[j] -= val2 * utemp[(j - k) - 1];\n    }\n\n  }\n\n  if ((ei == (n - 3)) || ((k + 1) == (n - 1)))\n  {\n    ei = n - 1;\n    tempdub = a[ei];\n    val = l[ei][k];\n    for (j = k + 1; j < n; j++)\n    {\n      tempdub[j] -= val * utemp[(j - k) - 1];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vijay2411/Basic-Programming-with-OpenMp-and-Pthreads/assignment1_pthreads/2"}
{"code": "for (j = ((0x7fffffffffffffffLL * 2ULL) + 1) - 3; (0x7fffffffffffffffLL + 70ULL) <= j; j -= 0x7fffffffffffffffLL + 50ULL)\n{\n  if (j == (((0x7fffffffffffffffLL * 2ULL) + 1) - 3))\n    set(3, 0);\n  else\n    e = 1;\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-12/3"}
{"code": "for (unsigned i = 0; i < nvert; i++)\n  pagerank[i] *= sum;\n\n", "pragma": "        #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dmitrime/pagerank-omp/pagerank/5"}
{"code": "for (j = 0; j < npxyz; j++)\n{\n  part[3 + (idimp * j)] -= sum1;\n  part[4 + (idimp * j)] -= sum2;\n  part[5 + (idimp * j)] -= sum3;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic3/mbpush3/36"}
{"code": "for (int nbr = n - 1; nbr >= 1; nbr--)\n{\n  if (feasible(curr_tour, nbr))\n  {\n    add_city(curr_tour, nbr);\n    push_copy(my_stack, curr_tour);\n    remove_city(curr_tour, nbr);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AmaruEscalante/cpd-tsp-project/norecursivo/paralelo/par-tsp-bb/0"}
{"code": "for (i = 0; i < nr_class; i++)\n  model->label[i] = label[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yhchbjs/LibSVM/LibSVM/svm/58"}
{"code": "for (r = 0, pos = 0; r < rows; r++, pos += cols)\n{\n  edge[pos] = 255;\n  edge[(pos + cols) - 1] = 255;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wuhaostudy1992/CannyMulti-thread-Openmp/Openmp/canny_omp_v1/11"}
{"code": "for (size_t t = 0; t < n; t++)\n{\n  double angle = (((2 * M_PI) * t) * k) / n;\n  if (inverse)\n    angle = -angle;\n\n  sumreal += (inreal[t] * cos(angle)) + (inimag[t] * sin(angle));\n  sumimag += ((-inreal[t]) * sin(angle)) + (inimag[t] * cos(angle));\n}\n\n", "pragma": "#pragma omp parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gkonto/openmp/src/_dft/c3_1/dft/1"}
{"code": "for (i = 0; i < MAX_KEY; i++)\n  key_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rose-compiler/rose/projects/OpenK/test/is_single/6"}
{"code": "for (i = 0; i < nv; i++)\n  if ((mind[mv] + ohd[(mv * nv) + i]) < mind[i])\n{\n  if (i == checked_vertex)\n    printf(\" +v%d \", mv);\n\n  mind[i] = mind[mv] + ohd[(mv * nv) + i];\n}\n\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/1"}
{"code": "for (uint32_t px = 0; px < (pOutImage->width * pOutImage->height); px++)\n{\n  unNormalizedGradient.data[px] = norm2(pInMatrixX->data[px], pInMatrixY->data[px]);\n}\n\n", "pragma": "omp parallel for shared(unNormalizedGradient)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ricordel/parallel-sobel/sobel/implem_omp/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    m[(i * n) + j] = ((double) rand()) / 32767;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbarbetti/ppf-omp-project/playground/first-steps/omp-matmul/3"}
{"code": "for (istep = 0; istep < nstep; istep++)\n{\n  step_kernel_cpu(ni + 2, nj + 2, tfac, temp1_h, temp2_h);\n  temp_tmp = temp1_h;\n  temp1_h = temp2_h;\n  temp2_h = temp_tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hcarter108/cisc372_proj/heat_omp/4"}
{"code": "for (i = 0; i < Maze.Radius; i++)\n{\n  free(Maze.Points[i]);\n  free(Maze.Nodes[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/29"}
{"code": "for (i = 0; i < nb_patterns; i++)\n{\n  int l;\n  l = strlen(argv[i + 3]);\n  if (l <= 0)\n  {\n    fprintf(stderr, \"Error while parsing argument %d\\n\", i + 3);\n    return 1;\n  }\n\n  pattern[i] = (char *) malloc((l + 1) * (sizeof(char)));\n  if (pattern[i] == 0)\n  {\n    fprintf(stderr, \"Unable to allocate string of size %d\\n\", l);\n    return 1;\n  }\n\n  strncpy(pattern[i], argv[i + 3], l + 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexis51151/parallelDNA/apm/src/apmOMP/2"}
{"code": "for (int i = 0; i < getNOP(); i++)\n{\n  setU(i, 0.);\n  setV(i, vel);\n  setW(i, 0.);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/particles/Particles3D/2"}
{"code": "for (i = 0; i < x; i++)\n{\n  condition = 0;\n  i_local_min = 0;\n  i_local_max = 0;\n  while (condition == 0)\n  {\n    dom_counter = 0;\n    energy_left = 0.0;\n    energy_right = 0.0;\n    for (k = i_local_min; k < z; k++)\n    {\n      temperature_1D[k] = pre[i][j][k] / (gasconstant * rho[i][j][k]);\n      mass[k] = rho[i][j][k] * volume;\n      dom_1D[k] = dom[i][j][k];\n      if (dom_1D[k] == 1)\n      {\n        if (dom_counter == 0)\n          i_local_min = k;\n\n        dom_counter++;\n      }\n      else\n      {\n        if (dom_counter > 0)\n        {\n          i_local_max = k - 1;\n          break;\n        }\n\n      }\n\n      if (k == (z - 1))\n      {\n        i_local_max = k;\n        if (dom_counter == 0)\n          i_local_min = k;\n\n      }\n\n    }\n\n    if (k == z)\n    {\n      condition = 1;\n    }\n\n    if (i_local_min != 0)\n    {\n      heat_transfer_coefficient = alpha_heat_transfer(i, j, i_local_min - 1, 2);\n      energy_left = ((heat_transfer_coefficient * A) * (temperature_1D[i_local_min - 1] - temperature_1D[i_local_min])) * dt;\n    }\n\n    if (i_local_max != (z - 1))\n    {\n      heat_transfer_coefficient = alpha_heat_transfer(i, j, i_local_max + 1, 2);\n      energy_right = ((heat_transfer_coefficient * A) * (temperature_1D[i_local_max + 1] - temperature_1D[i_local_max])) * dt;\n    }\n\n    if ((energy_left <= 0) && (i_local_min != 0))\n    {\n      temperature_1D[i_local_min - 1] = temperature_1D[i_local_min - 1] + fabs(energy_left / (specific_heat_capacity_gas * mass[i_local_min - 1]));\n      temperature_1D[i_local_min] = temperature_1D[i_local_min] - fabs(energy_left / (specific_heat_capacity_obstacle * mass[i_local_min]));\n      pre[i][j][i_local_min - 1] = (gasconstant * rho[i][j][i_local_min - 1]) * temperature_1D[i_local_min - 1];\n      pre[i][j][i_local_min] = (gasconstant * rho[i][j][i_local_min]) * temperature_1D[i_local_min];\n    }\n\n    if ((energy_left > 0) && (i_local_min != 0))\n    {\n      temperature_1D[i_local_min - 1] = temperature_1D[i_local_min - 1] - fabs(energy_left / (specific_heat_capacity_gas * mass[i_local_min - 1]));\n      temperature_1D[i_local_min] = temperature_1D[i_local_min] + fabs(energy_left / (specific_heat_capacity_obstacle * mass[i_local_min]));\n      pre[i][j][i_local_min - 1] = (gasconstant * rho[i][j][i_local_min - 1]) * temperature_1D[i_local_min - 1];\n      pre[i][j][i_local_min] = (gasconstant * rho[i][j][i_local_min]) * temperature_1D[i_local_min];\n    }\n\n    if ((energy_right > 0) && (i_local_max != (z - 1)))\n    {\n      temperature_1D[i_local_max] = temperature_1D[i_local_max] + fabs(energy_right / (specific_heat_capacity_obstacle * mass[i_local_max]));\n      temperature_1D[i_local_max + 1] = temperature_1D[i_local_max + 1] - fabs(energy_right / (specific_heat_capacity_gas * mass[i_local_max + 1]));\n      pre[i][j][i_local_max] = (gasconstant * rho[i][j][i_local_max]) * temperature_1D[i_local_max];\n      pre[i][j][i_local_max + 1] = (gasconstant * rho[i][j][i_local_max + 1]) * temperature_1D[i_local_max + 1];\n    }\n\n    if ((energy_right <= 0) && (i_local_max != (z - 1)))\n    {\n      temperature_1D[i_local_max] = temperature_1D[i_local_max] - fabs(energy_right / (specific_heat_capacity_obstacle * mass[i_local_max]));\n      temperature_1D[i_local_max + 1] = temperature_1D[i_local_max + 1] + fabs(energy_right / (specific_heat_capacity_gas * mass[i_local_max + 1]));\n      pre[i][j][i_local_max] = (gasconstant * rho[i][j][i_local_max]) * temperature_1D[i_local_max];\n      pre[i][j][i_local_max + 1] = (gasconstant * rho[i][j][i_local_max + 1]) * temperature_1D[i_local_max + 1];\n    }\n\n    if (dom_counter > 2)\n    {\n      for (n = i_local_min + 1; n < i_local_max; n++)\n      {\n        temperature_1D_future[n] = ((alpha_solid_z * temperature_1D[n + 1]) + ((1 - (2 * alpha_solid_z)) * temperature_1D[n])) + (alpha_solid_z * temperature_1D[n - 1]);\n      }\n\n      for (k = i_local_min + 1; k < i_local_max; k++)\n      {\n        pre[i][j][k] = (gasconstant * rho[i][j][k]) * temperature_1D_future[k];\n      }\n\n      for (k = i_local_min; k < i_local_max; k++)\n      {\n        temperature_1D[k] = 0.0;\n        temperature_1D_future[k] = 0.0;\n        mass[k] = 0.0;\n        dom_1D[k] = 0;\n      }\n\n    }\n\n    i_local_min = i_local_max + 1;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/diffusion/2"}
{"code": "for (int t = 0; t < width; ++t)\n  WriteStrided(t, input[t]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/openmpf/openmpf-components/cpp/TesseractOCRTextDetection/model_updater_tesseract_src/weightmatrix/1"}
{"code": "for (int i = start; i <= pointbreak; i++)\n  if (cmp_ge((void *) (&data[i]), pivot))\n{\n  while ((pointbreak > i) && cmp_ge((void *) (&data[pointbreak]), pivot))\n    pointbreak--;\n\n  if (pointbreak > i)\n    do\n  {\n    int sz = sizeof(data_t);\n    char *a = (void *) (&data[i]);\n    char *b = (void *) (&data[pointbreak--]);\n    do\n    {\n      char _temp = *a;\n      *(a++) = *b;\n      *(b++) = _temp;\n    }\n    while (--sz);\n  }\n  while (0);\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/examples_tasks/08_quicksort.v0/1"}
{"code": "for (unsigned int idx = 0; idx < parameter.size(); idx++)\n  if ((((a == parameter[idx].a) && (b == parameter[idx].b)) && (c == parameter[idx].c)) || (((a == parameter[idx].c) && (b == parameter[idx].b)) && (c == parameter[idx].a)))\n{\n  par = &parameter[idx];\n  return par;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ovalerio/omp_confab/src/forcefields/forcefieldmmff94/34"}
{"code": "for (int i = 0; i < (Size * Size); i += Size + 1)\n{\n  determinant *= pMatrix[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/savinaDaria/Cramer_rule_OpenMP/lab2OpenMP/lab2OpenMP/4"}
{"code": "for (ti = 0; ti < thread_number; ti++)\n{\n  for (i = 0; i < column_size; i++)\n  {\n    result[i] += temp[ti][i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xiaolinj/Sparse-Matrix-Vector-Multiplication-SpMV-with-OpenMP/CSCOpenMP/4"}
{"code": "for (i = 0; i < 2; ++i)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1/2"}
{"code": "for (int i = 0; i < dimension; i++)\n{\n  array[i] = (int ***) malloc(dimension * (sizeof(int **)));\n  if (array[i] == NULL)\n  {\n    fprintf(stderr, \"Out of memory\");\n    exit(0);\n  }\n\n  for (int j = 0; j < dimension; j++)\n  {\n    array[i][j] = (int **) malloc(dimension * (sizeof(int *)));\n    if (array[i][j] == NULL)\n    {\n      fprintf(stderr, \"Out of memory\");\n      exit(0);\n    }\n\n    for (int k = 0; k < dimension; ++k)\n    {\n      array[i][j][k] = (int *) malloc(dimension * (sizeof(int)));\n      if (array[i][j] == NULL)\n      {\n        fprintf(stderr, \"Out of memory\");\n        exit(0);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MohamadCM/Parallel-Programming-Practice/OpenMP_3-Tensor multiplication/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  fprintf(fp, \"%d,%f\\n\", i, sums[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LifeAlgorithm/Parallel-Computing/openMP_run/2"}
{"code": "for (m = 0; m <= 4; m += 1)\n{\n  tmat[m][0] = d[i][j][m][0];\n  tmat[m][1] = d[i][j][m][1];\n  tmat[m][2] = d[i][j][m][2];\n  tmat[m][3] = d[i][j][m][3];\n  tmat[m][4] = d[i][j][m][4];\n}\n\n", "pragma": "omp parallel for private (m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/4"}
{"code": "for (j = 0; j <= (ny - 1); j += 1)\n{\n  for (k = 0; k <= (nz - 1); k += 1)\n  {\n    for (m = 0; m <= 4; m += 1)\n    {\n      rsd[i][j][k][m] = -frct[i][j][k][m];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (j,k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/LU/lu/84"}
{"code": "for (h = 0; h < 1024; ++h)\n  C[h] = malloc(1024 * (sizeof(float)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial/5"}
{"code": "for (int k = 0; k <= 2; k += 1)\n{\n  c[(3 * i) + k] = s[k];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_functionCall/0"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"Amount of threads: %i;\\nThread number: %i;\\n\", omp_get_num_threads(), omp_get_thread_num());\n  a[i] = (rand() % 10) + 1;\n  b[i] = (rand() % 10) + 1;\n  printf(\"a[%i] = %i\\n\", i, a[i]);\n  printf(\"b[%i] = %i\\n\", i, b[i]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static,12/3) num_threads(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/burningbridges9/OpenMpTasksMaster/7th/7th/0"}
{"code": "for (i = 0; i < 7; i++)\n{\n  printf(\"Run %d \\n\", i);\n  train7(G, i);\n  sleep(2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/train7/1"}
{"code": "for (; p1 != end; ++p1)\n  sum += ((*p1) > 0) ? (*p1) : (0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/14"}
{"code": "for (i = 0; i < nd; i++)\n{\n  for (j = 0; j < np; j++)\n  {\n    pos[i + (j * nd)] = box[i] * r8_uniform_01(seed);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/md_open_mp/5"}
{"code": "for (i = 0; i < nbodies; ++i)\n  for (j = i + 1; j < nbodies; ++j)\n{\n  d2 = 0.0;\n  for (k = 0; k < 3; ++k)\n  {\n    rij[k] = pos[i][k] - pos[j][k];\n    d2 += rij[k] * rij[k];\n  }\n\n  if (d2 <= cut2)\n  {\n    d = sqrt(d2);\n    d3 = d * d2;\n    for (k = 0; k < 3; ++k)\n    {\n      double f = (-rij[k]) / d3;\n      pforces[i][k] += f;\n      pforces[j][k] -= f;\n    }\n\n    ene += (-1.0) / d;\n  }\n\n}\n\n\n", "pragma": "omp for reduction(+:ene) schedule(guided)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/scarpma/mpi_openmp_CINECA_course/OpenMP/solutions/5/main_v2/0"}
{"code": "for (i = 1; i <= nodesCount; ++i)\n{\n  if (distance[i][k] != (-1))\n  {\n    for (j = 1; j <= nodesCount; ++j)\n    {\n      if ((distance[k][j] != (-1)) && ((distance[i][j] == (-1)) || ((distance[i][k] + distance[k][j]) < distance[i][j])))\n      {\n        distance[i][j] = distance[i][k] + distance[k][j];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i) shared(distance)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jackson211/Floyd-Warshall-OpenMP/fw1/0"}
{"code": "for (i = 0; i < (n * n); i++)\n{\n  A[i] = rand() / 32767;\n  B[i] = rand() / 32767;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/mm/cache_friedly_mm/3"}
{"code": "for (int i = 0; i < nl; ++i)\n  arr[i] = l[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lucaszm7/IPPD_OpenMP_RPC_RMI_MPI/IPPD_OpenMP/sort/2"}
{"code": "for (i = 0; i < (cX * cY); i++)\n{\n  size_t ii = i % cX;\n  size_t jj = i / cX;\n  if (ii < jj)\n    continue;\n\n  double *X = X0 + (ii * rX);\n  double *Y = Y0 + (jj * rY);\n  double cc = 0.0;\n  double nw = 0.0;\n  size_t k;\n  for (k = 0; k < rX; k++)\n  {\n    double z = X[k] * Y[k];\n    if (ISNAN(z))\n    {\n      flag_isNaN = 1;\n      continue;\n    }\n\n    cc += z * W[k];\n    nw += W[k];\n  }\n\n  size_t j = jj + (ii * cX);\n  CC[i] = cc;\n  CC[j] = cc;\n  if (NN != NULL)\n  {\n    NN[i] = nw;\n    NN[j] = nw;\n  }\n\n}\n\n", "pragma": "            #pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/covm_mex/3"}
{"code": "for (int j = 0; j < N; j++)\n{\n  thread_num = omp_get_thread_num();\n  if (!printed_val[thread_num])\n  {\n    ((cout << \"thread \") << thread_num) << endl;\n    printed_val[thread_num] = true;\n  }\n\n  sum += mat[i][j] * vect[j];\n}\n\n", "pragma": "        #pragma omp parallel for reduction(+:sum) private(thread_num)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lexispike/openMP_matrix_multiplication/Q4/2"}
{"code": "for (i = 0; i < local_C->n_bar; i++)\n{\n  for (j = 0; j < local_C->n_bar; j++)\n    printf(\"%20.15E \", *((local_C->entries + (local_C->n_bar * i)) + j));\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yangyang14641/Parallel-Matrix-Multiplication-FOX-Algorithm/Code Tests/Dell XPS8900/Testing on Intel Core i7 CPU/Source Codes/fox_floats_timer_caching_omp_fileIO_benchmark/20"}
{"code": "for (unsigned it = 1; it <= nb_iter; it++)\n{\n  for (int i = 0; i < DIM; i++)\n    for (int j = 0; j < DIM; j++)\n    compute_new_state(i, j);\n\n\n  swap_images();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/5"}
{"code": "for (int a_block_count = 0; a_block_count < (p * q); a_block_count++)\n{\n  int i_block = a_block_count / q;\n  int j_block = a_block_count % q;\n  for (int t_block = 0; t_block < r; t_block++)\n  {\n    for (int i = i_block * a_h; i < ((i_block + 1) * a_h); i++)\n      for (int j = j_block * a_w; j < ((j_block + 1) * a_w); j++)\n      for (int t = t_block * b_w; t < ((t_block + 1) * b_w); t++)\n      result[i][t] += arr1[i][j] * arr2[j][t];\n\n\n\n  }\n\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JasonPV/openmp_tasks/task4/0"}
{"code": "for (j = 0; j < HIgh_w; j++)\n{\n  for (i = 0; i < HIgh_h; i++)\n  {\n    output_R[(i * HIgh_w) + j] = floor(((((1.16438356164384000000 * summation_data[(i * HIgh_w) + j]) + (0.00000030112439741101 * bicubic_Cb[(i * HIgh_w) + j])) + (1.59602688733570000000 * bicubic_Cr[(i * HIgh_w) + j])) - 222.921617109194) + 0.5);\n    output_G[(i * HIgh_w) + j] = floor(((((1.16438356164384000000 * summation_data[(i * HIgh_w) + j]) - (0.39176253994145000000 * bicubic_Cb[(i * HIgh_w) + j])) - (0.81296829216220500000 * bicubic_Cr[(i * HIgh_w) + j])) + 135.575409522967) + 0.5);\n    output_B[(i * HIgh_w) + j] = floor(((((1.16438356164384000000 * summation_data[(i * HIgh_w) + j]) + (2.01723263955646000000 * bicubic_Cb[(i * HIgh_w) + j])) + (0.00000305426174524847 * bicubic_Cr[(i * HIgh_w) + j])) - 276.836305795032) + 0.5);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kym343/Super-resolution-SRCNN-VDSR-with-GUI/src/PIP_final_project/76"}
{"code": "for (int i = 0; i < size; i++)\n{\n  v1[i] = (rand() % 20) + 1;\n  v2[i] = (rand() % 20) + 1;\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/realsanya/parallel-programming/sem-2/ConsoleApplication1/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  marked[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/firehawk23/Parallel-Programming/Lab 10/prime/1"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    if ((((i * nx) + j) % 20) == 0)\n      fprintf(stderr, \"\\n\");\n\n    fprintf(stderr, \"%0.2lf \", ey[i][j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Fedor1533/FDTD-2D-solution-openMP-/fdtd-2d/7"}
{"code": "for (unsigned int i = 0; i < (query_nb * k); i++)\n  dist[i] = sqrtf(dist[i]);\n\n", "pragma": "    #pragma omp target teams distribute parallel for thread_limit(256)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/knn-omp/main/7"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sinValue[i] = sin((2 * i) * 3.141592) * cos((2 * i) * 3.141592);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ValafarLab01/openmp/main/0"}
{"code": "for (base = start; base < end; base++)\n{\n  uint32_t seed = ((uint32_t) base) << 5;\n  typedef struct \n  {\n    vtype a;\n    vtype b;\n    vtype c;\n    vtype d;\n    vtype e;\n    vtype f;\n    vtype g;\n    vtype h;\n  } atype;\n  atype xM;\n  atype x = {};\n  atype x710 = {};\n  volatile atype x1;\n  const vtype cone = _mm512_set1_epi32(1);\n  vtype vseed = _mm512_set1_epi32(seed);\n  version_t version;\n  xM.a = _mm512_add_epi32(vseed, _mm_set_epi32(0, 2, 4, 6));\n  xM.b = _mm512_add_epi32(xM.a, _mm512_set1_epi32(1));\n  xM.c = _mm512_add_epi32(xM.a, _mm512_set1_epi32(8));\n  xM.d = _mm512_add_epi32(xM.a, _mm512_set1_epi32(9));\n  xM.e = _mm512_add_epi32(xM.a, _mm512_set1_epi32(16));\n  xM.f = _mm512_add_epi32(xM.a, _mm512_set1_epi32(17));\n  xM.g = _mm512_add_epi32(xM.a, _mm512_set1_epi32(24));\n  xM.h = _mm512_add_epi32(xM.a, _mm512_set1_epi32(25));\n  if (flavor == PHP_LEGACY)\n  {\n    const vtype c69069 = _mm512_set1_epi32(69069);\n    const vtype c69069to396 = _mm512_set1_epi32(0x4396a0b1);\n    xM.a = _mm512_add_epi32(_mm512_add_epi32(xM.a, xM.a), cone);\n    x1.a = (xM.a = _mm512_mullo_epi32(c69069, xM.a));\n    xM.a = _mm512_mullo_epi32(c69069to396, xM.a);\n    xM.b = _mm512_add_epi32(_mm512_add_epi32(xM.b, xM.b), cone);\n    x1.b = (xM.b = _mm512_mullo_epi32(c69069, xM.b));\n    xM.b = _mm512_mullo_epi32(c69069to396, xM.b);\n    xM.c = _mm512_add_epi32(_mm512_add_epi32(xM.c, xM.c), cone);\n    x1.c = (xM.c = _mm512_mullo_epi32(c69069, xM.c));\n    xM.c = _mm512_mullo_epi32(c69069to396, xM.c);\n    xM.d = _mm512_add_epi32(_mm512_add_epi32(xM.d, xM.d), cone);\n    x1.d = (xM.d = _mm512_mullo_epi32(c69069, xM.d));\n    xM.d = _mm512_mullo_epi32(c69069to396, xM.d);\n    xM.e = _mm512_add_epi32(_mm512_add_epi32(xM.e, xM.e), cone);\n    x1.e = (xM.e = _mm512_mullo_epi32(c69069, xM.e));\n    xM.e = _mm512_mullo_epi32(c69069to396, xM.e);\n    xM.f = _mm512_add_epi32(_mm512_add_epi32(xM.f, xM.f), cone);\n    x1.f = (xM.f = _mm512_mullo_epi32(c69069, xM.f));\n    xM.f = _mm512_mullo_epi32(c69069to396, xM.f);\n    xM.g = _mm512_add_epi32(_mm512_add_epi32(xM.g, xM.g), cone);\n    x1.g = (xM.g = _mm512_mullo_epi32(c69069, xM.g));\n    xM.g = _mm512_mullo_epi32(c69069to396, xM.g);\n    xM.h = _mm512_add_epi32(_mm512_add_epi32(xM.h, xM.h), cone);\n    x1.h = (xM.h = _mm512_mullo_epi32(c69069, xM.h));\n    xM.h = _mm512_mullo_epi32(c69069to396, xM.h);\n  }\n  else\n  {\n    const vtype cmul = _mm512_set1_epi32(1812433253U);\n    vtype vi = _mm512_add_epi32(cone, cone);\n    unsigned int n = (397 - 1) / 22;\n    x1.a = (xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, seed_shr_30), cone));\n    x1.b = (xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, seed_shr_30), cone));\n    x1.c = (xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, seed_shr_30), cone));\n    x1.d = (xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, seed_shr_30), cone));\n    x1.e = (xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, seed_shr_30), cone));\n    x1.f = (xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, seed_shr_30), cone));\n    x1.g = (xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, seed_shr_30), cone));\n    x1.h = (xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, seed_shr_30), cone));\n    do\n    {\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n      xM.a = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.a, _mm512_srli_epi32(xM.a, 30)), vi);\n      xM.b = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.b, _mm512_srli_epi32(xM.b, 30)), vi);\n      xM.c = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.c, _mm512_srli_epi32(xM.c, 30)), vi);\n      xM.d = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.d, _mm512_srli_epi32(xM.d, 30)), vi);\n      xM.e = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.e, _mm512_srli_epi32(xM.e, 30)), vi);\n      xM.f = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.f, _mm512_srli_epi32(xM.f, 30)), vi);\n      xM.g = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.g, _mm512_srli_epi32(xM.g, 30)), vi);\n      xM.h = _mm512_fmadd_epi32(cmul, _mm512_xor_epi32(xM.h, _mm512_srli_epi32(xM.h, 30)), vi);\n      vi = _mm512_add_epi32(vi, cone);\n    }\n    while (--n);\n  }\n\n  version = flavor;\n  if (!(match->flags & 4))\n  {\n    const vtype c0x7fffffff = _mm512_set1_epi32(0x7fffffff);\n    const vtype c0x9908b0df = _mm512_set1_epi32(0x9908b0df);\n    x.a = _mm512_xor_epi32(xM.a, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.a, c0x7fffffff)), 1));\n    x.b = _mm512_xor_epi32(xM.b, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.b, c0x7fffffff)), 1));\n    x.c = _mm512_xor_epi32(xM.c, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.c, c0x7fffffff)), 1));\n    x.d = _mm512_xor_epi32(xM.d, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.d, c0x7fffffff)), 1));\n    x.e = _mm512_xor_epi32(xM.e, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.e, c0x7fffffff)), 1));\n    x.f = _mm512_xor_epi32(xM.f, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.f, c0x7fffffff)), 1));\n    x.g = _mm512_xor_epi32(xM.g, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.g, c0x7fffffff)), 1));\n    x.h = _mm512_xor_epi32(xM.h, _mm512_srli_epi32(_mm512_or_epi32(seed_and_0x80000000, _mm512_and_epi32(x1.h, c0x7fffffff)), 1));\n    x710.a = _mm512_xor_epi32(x.a, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.a, cone)));\n    x710.b = _mm512_xor_epi32(x.b, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.b, cone)));\n    x710.c = _mm512_xor_epi32(x.c, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.c, cone)));\n    x710.d = _mm512_xor_epi32(x.d, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.d, cone)));\n    x710.e = _mm512_xor_epi32(x.e, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.e, cone)));\n    x710.f = _mm512_xor_epi32(x.f, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.f, cone)));\n    x710.g = _mm512_xor_epi32(x.g, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.g, cone)));\n    x710.h = _mm512_xor_epi32(x.h, _mm512_mullo_epi32(c0x9908b0df, _mm512_and_epi32(x1.h, cone)));\n    if (version == PHP_521)\n    {\n      x.b = _mm512_xor_epi32(x.b, c0x9908b0df);\n      x.d = _mm512_xor_epi32(x.d, c0x9908b0df);\n      x.f = _mm512_xor_epi32(x.f, c0x9908b0df);\n      x.h = _mm512_xor_epi32(x.h, c0x9908b0df);\n    }\n    else\n      x = x710;\n\n  }\n\n  do\n  {\n    uint32_t maybe = 1;\n    if (!(match->flags & 4))\n    {\n      const vtype c0x9d2c5680 = _mm512_set1_epi32(0x9d2c5680);\n      const vtype c0xefc60000 = _mm512_set1_epi32(0xefc60000);\n      x.a = _mm512_xor_epi32(x.a, _mm512_srli_epi32(x.a, 11));\n      x.b = _mm512_xor_epi32(x.b, _mm512_srli_epi32(x.b, 11));\n      x.c = _mm512_xor_epi32(x.c, _mm512_srli_epi32(x.c, 11));\n      x.d = _mm512_xor_epi32(x.d, _mm512_srli_epi32(x.d, 11));\n      x.e = _mm512_xor_epi32(x.e, _mm512_srli_epi32(x.e, 11));\n      x.f = _mm512_xor_epi32(x.f, _mm512_srli_epi32(x.f, 11));\n      x.g = _mm512_xor_epi32(x.g, _mm512_srli_epi32(x.g, 11));\n      x.h = _mm512_xor_epi32(x.h, _mm512_srli_epi32(x.h, 11));\n      x.a = _mm512_xor_epi32(x.a, _mm512_and_epi32(_mm512_slli_epi32(x.a, 7), c0x9d2c5680));\n      x.a = _mm512_xor_epi32(x.a, _mm512_and_epi32(_mm512_slli_epi32(x.a, 15), c0xefc60000));\n      x.b = _mm512_xor_epi32(x.b, _mm512_and_epi32(_mm512_slli_epi32(x.b, 7), c0x9d2c5680));\n      x.b = _mm512_xor_epi32(x.b, _mm512_and_epi32(_mm512_slli_epi32(x.b, 15), c0xefc60000));\n      x.c = _mm512_xor_epi32(x.c, _mm512_and_epi32(_mm512_slli_epi32(x.c, 7), c0x9d2c5680));\n      x.c = _mm512_xor_epi32(x.c, _mm512_and_epi32(_mm512_slli_epi32(x.c, 15), c0xefc60000));\n      x.d = _mm512_xor_epi32(x.d, _mm512_and_epi32(_mm512_slli_epi32(x.d, 7), c0x9d2c5680));\n      x.d = _mm512_xor_epi32(x.d, _mm512_and_epi32(_mm512_slli_epi32(x.d, 15), c0xefc60000));\n      x.e = _mm512_xor_epi32(x.e, _mm512_and_epi32(_mm512_slli_epi32(x.e, 7), c0x9d2c5680));\n      x.e = _mm512_xor_epi32(x.e, _mm512_and_epi32(_mm512_slli_epi32(x.e, 15), c0xefc60000));\n      x.f = _mm512_xor_epi32(x.f, _mm512_and_epi32(_mm512_slli_epi32(x.f, 7), c0x9d2c5680));\n      x.f = _mm512_xor_epi32(x.f, _mm512_and_epi32(_mm512_slli_epi32(x.f, 15), c0xefc60000));\n      x.g = _mm512_xor_epi32(x.g, _mm512_and_epi32(_mm512_slli_epi32(x.g, 7), c0x9d2c5680));\n      x.g = _mm512_xor_epi32(x.g, _mm512_and_epi32(_mm512_slli_epi32(x.g, 15), c0xefc60000));\n      x.h = _mm512_xor_epi32(x.h, _mm512_and_epi32(_mm512_slli_epi32(x.h, 7), c0x9d2c5680));\n      x.h = _mm512_xor_epi32(x.h, _mm512_and_epi32(_mm512_slli_epi32(x.h, 15), c0xefc60000));\n      x.a = _mm512_xor_epi32(x.a, _mm512_srli_epi32(x.a, 18));\n      x.b = _mm512_xor_epi32(x.b, _mm512_srli_epi32(x.b, 18));\n      x.c = _mm512_xor_epi32(x.c, _mm512_srli_epi32(x.c, 18));\n      x.d = _mm512_xor_epi32(x.d, _mm512_srli_epi32(x.d, 18));\n      x.e = _mm512_xor_epi32(x.e, _mm512_srli_epi32(x.e, 18));\n      x.f = _mm512_xor_epi32(x.f, _mm512_srli_epi32(x.f, 18));\n      x.g = _mm512_xor_epi32(x.g, _mm512_srli_epi32(x.g, 18));\n      x.h = _mm512_xor_epi32(x.h, _mm512_srli_epi32(x.h, 18));\n      if (match->flags & 2)\n      {\n        x.a = _mm512_srli_epi32(x.a, 1);\n        x.b = _mm512_srli_epi32(x.b, 1);\n        x.c = _mm512_srli_epi32(x.c, 1);\n        x.d = _mm512_srli_epi32(x.d, 1);\n        x.e = _mm512_srli_epi32(x.e, 1);\n        x.f = _mm512_srli_epi32(x.f, 1);\n        x.g = _mm512_srli_epi32(x.g, 1);\n        x.h = _mm512_srli_epi32(x.h, 1);\n      }\n\n    }\n\n    if (maybe)\n    {\n      unsigned int i;\n      uint32_t iseed;\n      typedef union \n      {\n        atype v;\n        uint32_t s[8][(sizeof(vtype)) / 4];\n      } utype;\n      utype u;\n      volatile utype uM;\n      u.v = x;\n      uM.v = xM;\n      for (i = 0, iseed = seed; i < 8; i++, iseed += 8)\n      {\n        if (!diff(u.s[i][0], uM.s[i][0], iseed + 6, match, version))\n          print_guess(iseed + 6, &found, version);\n\n        if (!diff(u.s[i][1], uM.s[i][1], iseed + 4, match, version))\n          print_guess(iseed + 4, &found, version);\n\n        if (!diff(u.s[i][2], uM.s[i][2], iseed + 2, match, version))\n          print_guess(iseed + 2, &found, version);\n\n        if (!diff(u.s[i][3], uM.s[i][3], iseed, match, version))\n          print_guess(iseed, &found, version);\n\n        i++;\n        if (!diff(u.s[i][0], uM.s[i][0], iseed + 7, match, version))\n          print_guess(iseed + 7, &found, version);\n\n        if (!diff(u.s[i][1], uM.s[i][1], iseed + 5, match, version))\n          print_guess(iseed + 5, &found, version);\n\n        if (!diff(u.s[i][2], uM.s[i][2], iseed + 3, match, version))\n          print_guess(iseed + 3, &found, version);\n\n        if (!diff(u.s[i][3], uM.s[i][3], iseed + 1, match, version))\n          print_guess(iseed + 1, &found, version);\n\n      }\n\n      xM = uM.v;\n    }\n\n    if (version != PHP_521)\n      break;\n\n    version = PHP_710;\n    x = x710;\n  }\n  while (1);\n}\n\n", "pragma": "omp parallel for default(none) private(base) shared(match, flavor, start, end, found, seed_and_0x80000000, seed_shr_30)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/php_mt_seed/php_mt_seed/5"}
{"code": "for (i = 0; i < M; i = i + 1)\n{\n  for (j = 0; j < M; j++)\n  {\n    for (l = 0; l < M; l = l + 4)\n    {\n      Bcol[l] = B[(l * M) + j];\n      Bcol[l + 1] = B[((l + 1) * M) + j];\n      Bcol[l + 2] = B[((l + 2) * M) + j];\n      Bcol[l + 3] = B[((l + 3) * M) + j];\n    }\n\n    r = 0.0;\n    indice_ligne = i * M;\n    for (k = 0; k < M; k = k + 4)\n    {\n      av4 = _mm_load_ps((A + indice_ligne) + k);\n      bv4 = _mm_load_ps(Bcol + k);\n      dot = _mm_dp_ps(av4, bv4, 0xFF);\n      _mm_store_ps(R4, dot);\n      r = r + R4[0];\n    }\n\n    C[indice_ligne + j] = (alpha * r) + (beta * C[indice_ligne + j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ASGdev/mn-openmp/blas1/gemm/4"}
{"code": "for (int i = 0; i < 248; i++)\n{\n  for (int j = 0; j < 328; j++)\n  {\n    residual[i][j] = \"non\";\n    arra[i][j] = \"non\";\n    arrb[i][j] = \"non\";\n    arrc[i][j] = \"non\";\n    arrd[i][j] = \"non\";\n    arre[i][j] = \"non\";\n    arrf[i][j] = \"non\";\n    arrg[i][j] = \"non\";\n    arrh[i][j] = \"non\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/s1260051/OpenMPparallel/calibrationgraph/82"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    *((C + (i * n)) + j) = 0;\n    for (k = 0; k < n; k++)\n    {\n      *((C + (i * n)) + j) += (*((A + (i * n)) + k)) * (*((B + (k * n)) + j));\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nishi1612/High-Performance-Computing/Lab3/201601408-201601059-matrix_multiplication-outermost/parallel_measurement/0"}
{"code": "for (int i = 0; i < k; i++)\n{\n  for (int j = 0; j < k; j++)\n  {\n    tmp[j + (i * k)] = (*kernel)[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/marcogualtieri/kernel_image_processing/openmp_kernel_image_processing/1"}
{"code": "for (int i = 0; i < n; ++i)\n  a[i] /= n;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mlchkhn/parallel_algorithms/multiplication/6"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  xRef[i][0] = 0.0;\n  xRef[i][1] = 0.0;\n  xRef[i][2] = 0.0;\n  neigh[i][0] = 0;\n  for (j = i + 1; j < N2; j++)\n  {\n    if (j == (i + 2))\n      continue;\n\n    del[0] = x[i][0] - x[j][0];\n    del[1] = x[i][1] - x[j][1];\n    del[2] = x[i][2] - x[j][2];\n    rsq = ((del[0] * del[0]) + (del[1] * del[1])) + (del[2] * del[2]);\n    if (rsq < neighCutSq)\n    {\n      neigh[i][++neigh[i][0]] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(guided,100)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/neighbour/1"}
{"code": "for (int i = 0; i < ratings.size(); ++i)\n{\n  ui = ratings.at(i).at(0) - 1;\n  mi = ratings.at(i).at(1) - 1;\n  ri = ratings.at(i).at(2);\n  error = ri - (U.row(ui) * M.col(mi));\n  tempU = U.row(ui) + ((eta * error) * M.col(mi).transpose());\n  M.col(mi) = M.col(mi) + ((eta * error) * U.row(ui).transpose());\n  U.row(ui) = tempU;\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(threadNumber) schedule(static) private(ui, mi, ri, error, tempU)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muatik/openmp-examples/als-movie-recommender/main/2"}
{"code": "for (int i = 0; i < ((int) imageSizeRef[box]); i++)\n{\n  double arg = Dot(atom, kxRef[box][i], kyRef[box][i], kzRef[box][i], currentCoords);\n  double factor = ((prefactRef[box][i] * 2.0) * ((sumIref[box][i] * cos(arg)) - (sumRref[box][i] * sin(arg)))) * charge;\n  wT11 += factor * (kxRef[box][i] * diffC.x);\n  wT22 += factor * (kyRef[box][i] * diffC.y);\n  wT33 += factor * (kzRef[box][i] * diffC.z);\n}\n\n", "pragma": "      #pragma omp parallel for default(none) shared(atom, box, charge, diffC) reduction(+:wT11, wT22, wT33)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/Ewald/26"}
{"code": "for (int i = 0; i < (matrixSize - 1); i++)\n{\n  eig += to_string(result[i]);\n  eig += \",\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/Bisection/2"}
{"code": "for (m = 0; m < (n / 2); m++)\n{\n  w.Re = cos(((2 * PI) * m) / ((float) n));\n  w.Im = -sin(((2 * PI) * m) / ((float) n));\n  z.Re = (w.Re * vo[m].Re) - (w.Im * vo[m].Im);\n  z.Im = (w.Re * vo[m].Im) + (w.Im * vo[m].Re);\n  v[m].Re = ve[m].Re + z.Re;\n  v[m].Im = ve[m].Im + z.Im;\n  v[m + (n / 2)].Re = ve[m].Re - z.Re;\n  v[m + (n / 2)].Im = ve[m].Im - z.Im;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/omphardcloud/hardcloud/samples/fft/sw/src/main/1"}
{"code": "for (i = 0; i < 73; i++)\n{\n  if (l == (-1))\n  {\n    n = 1;\n    c++;\n  }\n  else\n    if (l == (i - 1))\n    n++;\n  else\n  {\n    if (l >= i)\n      abort();\n\n    if (n < 7)\n      abort();\n\n    n = 1;\n    c++;\n  }\n\n\n  l = i;\n}\n\n", "pragma": "omp for schedule (monotonic :guided , 7) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/monotonic-1/5"}
{"code": "for (int i = 0; i < n; ++i)\n  fscanf(file, \"%lf \", &z[i]);\n\n", "pragma": "omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/7"}
{"code": "for (int my_igp = 0; my_igp < ngpown; my_igp++)\n  for (int ig = 0; ig < ncouls; ig++)\n{\n  I_eps_array(my_igp, ig) = expr;\n  wtilde_array(my_igp, ig) = expr;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gpp-omp/main/1"}
{"code": "for (j = DIM, D3 = 1; j < ND; D3 = D3 * SZ2[j++])\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nicoTolly/stage_openmp/openmp/NaN/src/sumskipnan_mex/4"}
{"code": "for (int i = 0; i < loc_num; i++)\n{\n  u1 = U[i] + sqrt((GAMMA * P[i]) / R[i]);\n  u2 = U[i] - sqrt((GAMMA * P[i]) / R[i]);\n  u3 = U[i];\n  if (u1 > u_loc)\n    u_loc = u1;\n\n  if (u2 > u_loc)\n    u_loc = u2;\n\n  if (u3 > u_loc)\n    u_loc = u3;\n\n}\n\n", "pragma": "#pragma omp for schedule(static, omp_chunk) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dklyuchinskiy/CFD-Godunov-scheme-1D-with-MPI/CFD Godunov scheme 1D with MPI/source/main/3"}
{"code": "for (j = 0; j < size; j++)\n{\n  alive = count_alive(field, i, j, size);\n  cs = field[(size * i) + j];\n  if (cs)\n  {\n    if ((alive > 3) || (alive < 2))\n      t[(size * i) + j] = 0;\n    else\n      t[(size * i) + j] = 1;\n\n  }\n  else\n  {\n    if (alive == 3)\n      t[(size * i) + j] = 1;\n    else\n      t[(size * i) + j] = 0;\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/FelipeBrizola/game-of-life-openMp/gameoflife/game_mp/0"}
{"code": "for (int i = 1; i < (COLUMN - 1); i++)\n{\n  for (int j = 1; j < (ROW - 1); j++)\n  {\n    (f << currentGeneration[i][j]) << \" \";\n  }\n\n  f << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rzaaeeff/GameofLife-OpenMP/GoLParallel/7"}
{"code": "for (int h = 0; h < NumQs; h++)\n  for (int g = 0; g < threads; g++)\n  *(tmpSPQx + h) += *((SPQxThrdvsNumQ + h) + (g * NumQs));\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gcucho/mass-2d3d-openmp/Proyecto M2D3D DLL/Mass2d3d/main/37"}
{"code": "for (m = 0; m < 5; m++)\n{\n  j = 1;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((5.0 * ue[j][m]) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n  j = 2;\n  forcing[i][j][k][m] = forcing[i][j][k][m] - (dssp * (((((-4.0) * ue[j - 1][m]) + (6.0 * ue[j][m])) - (4.0 * ue[j + 1][m])) + ue[j + 2][m]));\n}\n\n", "pragma": "omp parallel for private(m) firstprivate(dssp ,k ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/24"}
{"code": "for (i = 1; i < (size - 1); i += 2)\n{\n  if (vec[i] > vec[i + 1])\n  {\n    tmp = vec[i];\n    vec[i] = vec[i + 1];\n    vec[i + 1] = vec[i];\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for num_threads(thread_count)\\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pengjintao/OpenMP/07_odd_even_sort/2"}
{"code": "for (int i = 0; i < nthreads; i++)\n  do_something(my_thread_id);\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Foundations-of-HPC/Foundations_of_HPC_2021/OpenMP/parallel_regions/05c_order_of_threads/0"}
{"code": "for (int jj = HALO_PAD; jj < (HALO_PAD + depth); ++jj)\n{\n  for (int kk = HALO_PAD; kk < (xMax - HALO_PAD); ++kk)\n  {\n    int bufIndex = (kk - HALO_PAD) + ((jj - HALO_PAD) * _chunk.innerX);\n    buffer[bufIndex] = field[(jj * xMax) + kk];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel/3"}
{"code": "for (size_t i = 0; i < Drawings.size(); i++)\n{\n  Drawings[i].Update();\n}\n\n", "pragma": "#pragma omp parallel for num_threads(Params.Simulator.NumThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/FourierDraw/Source/FourierDraw/3"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  if ((!in_mst[i]) && (min >= d[i]))\n  {\n    min = d[i];\n    min_idx = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mst/11"}
{"code": "for (int i = 0; i < nprocs; i++)\n{\n  if (i != me)\n    MPI_Isend(remoteArray[i].data(), send_sz[i], commType, i, CommunityDataTag, MPI_COMM_WORLD, &sreqs[i]);\n  else\n    sreqs[i] = MPI_REQUEST_NULL;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/vite/louvain/17"}
{"code": "for (unsigned int i = 0; i < n; i++)\n{\n  for (unsigned int l = 0; l < d_x; l++)\n  {\n    j[(i * d) + l] = x[(i * d_x) + l];\n  }\n\n  for (unsigned int l = 0; l < d_y; l++)\n  {\n    j[((i * d) + d_x) + l] = y[(i * d_y) + l];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/adam-zlatniczki/moar-zeta-cpp-openmp/src/local_zeta/1"}
{"code": "for (int i = 0; i < height; i++)\n{\n  for (int j = 0; j < width; j++)\n  {\n    int result_x_r = 0;\n    int result_x_g = 0;\n    int result_x_b = 0;\n    int result_y_r = 0;\n    int result_y_g = 0;\n    int result_y_b = 0;\n    for (int s = -1; s <= 1; s++)\n    {\n      if (((i + s) < 0) || ((i + s) >= height))\n      {\n        result_x_r += 0;\n        result_x_g += 0;\n        result_x_b += 0;\n        result_y_r += 0;\n        result_y_g += 0;\n        result_y_b += 0;\n      }\n      else\n      {\n        for (int t = -1; t <= 1; t++)\n        {\n          if (((j + t) < 0) || ((j + t) >= width))\n          {\n            result_x_r += 0;\n            result_x_g += 0;\n            result_x_b += 0;\n            result_y_r += 0;\n            result_y_g += 0;\n            result_y_b += 0;\n          }\n          else\n          {\n            result_x_r += m_x[s + 1][t + 1] * pixels[i + s][j + t].r;\n            result_x_g += m_x[s + 1][t + 1] * pixels[i + s][j + t].g;\n            result_x_b += m_x[s + 1][t + 1] * pixels[i + s][j + t].b;\n            result_y_r += m_y[s + 1][t + 1] * pixels[i + s][j + t].r;\n            result_y_g += m_y[s + 1][t + 1] * pixels[i + s][j + t].g;\n            result_y_b += m_y[s + 1][t + 1] * pixels[i + s][j + t].b;\n          }\n\n        }\n\n      }\n\n    }\n\n    pixels_aux[i][j].r = abs(weight * result_x_r) + abs(weight * result_y_r);\n    pixels_aux[i][j].g = abs(weight * result_x_g) + abs(weight * result_y_g);\n    pixels_aux[i][j].b = abs(weight * result_x_b) + abs(weight * result_y_b);\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dariomnz/Cpp-parallelism-image-filter/image-par/1"}
{"code": "for (int i = 0; i < inputData.numDataPoints; i++)\n{\n  int d = calcDirectBin(inputData.windDir[i]);\n  int s = calcSpeedsBin(inputData.windSpd[i]);\n  if (((d < NUM_OF_SECTORS) && (d >= 0)) && ((s < NUM_OF_SPEED) && (s >= 0)))\n  {\n    localOutData[d][s]++;\n    print++;\n  }\n  else\n    noPrint++;\n\n}\n\n", "pragma": "\t\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Sandyarathi/WindRosePOC/src_OpenMP/Parallel01_01/3"}
{"code": "for (int i = 0; i < ROW2; i++)\n{\n  mapG2[i].setCol(COL);\n  mapG2[i].clear();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ZhangYanrui123/Parrallel-Programming---Hw4---OpenMP/Grobner/8"}
{"code": "for (int i = 5; i >= 0; i--)\n{\n  printf(\"[%d] \", pos->_Cases[1][16 * i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif_padding/2"}
{"code": "for (index = 0; index < count; index += SSE_GROUP_SZ_SHA256)\n{\n  unsigned char PswCheckValue[SHA256_DIGEST_SIZE];\n  unsigned char PswCheck[SIZE_PSWCHECK];\n  int i;\n  pbkdf2_sha256((unsigned char *) saved_key[index], strlen(saved_key[index]), cur_salt->salt, SIZE_SALT50, cur_salt->iterations + 32, PswCheckValue, SHA256_DIGEST_SIZE, 0);\n  memset(PswCheck, 0, sizeof(PswCheck));\n  for (i = 0; i < SHA256_DIGEST_SIZE; i++)\n    PswCheck[i % SIZE_PSWCHECK] ^= PswCheckValue[i];\n\n  memcpy((void *) crypt_out[index], PswCheck, SIZE_PSWCHECK);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/rar5_fmt_plug/1"}
{"code": "for (int i = 0; i <= m; i++)\n{\n  l[i] = (int *) malloc((sizeof(int)) * (n + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/lcs/2"}
{"code": "for (int i = 0; i < N; i++)\n{\n  host[i] = A;\n}\n\n", "pragma": "      #pragma omp parallel for num_threads(N)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/MasterBarrier/MasterBarrier/0"}
{"code": "for (n = 0, NumSphUpdate = 0; n < N_gas; n++)\n{\n  if (P[n].Ti_endstep == All.Ti_Current)\n    NumSphUpdate++;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rmoleary/Gadget-2-openmp/hydra/2"}
{"code": "for (int t = 0; t < nthreads; t++)\n  initstate_r(random(), &rand_state_bufs[t], 32, &rand_states[t]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sas91305/Parallelized-vs-Sequential-Approximization-of-Pi/parallelapprox/1"}
{"code": "for (i = 0; i < nu; i++)\n{\n  aleft[i] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sacredbanana/CITS3402Project1OpenMP/FEM1D/2"}
{"code": "for (i = 1; i < nv; i++)\n{\n  notdone[i] = 1;\n  mind[i] = ohd[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/larry-han-au/OpenMp-and-MPI/Project1A/dijkstra_f/3"}
{"code": "for (int32_t v = 0; v < height; v += D_candidate_stepsize)\n  D_can_height++;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Clouds1997/elas_openmp_ros/libelas/src/elas/7"}
{"code": "for (i = 0; i < 20; ++i)\n{\n  if ((i % 3) == 0)\n    sleep(0);\n\n  nDynamicN[i] = omp_get_thread_num();\n}\n\n", "pragma": "omp for schedule(dynamic, DYNAMIC_CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nicolasenciso/Parallel-and-distributed-computing/openMP/omp_schedule/3"}
{"code": "for (int i = 1; i <= N; i++)\n{\n  sum += i;\n  printf(\"%d:calculation of the iteration number %d.\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "#pragma omp for reduction(+:sum) schedule(guided, 2)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Jake33rus/MPI-OpenMP-labs-and-CursProject/lab2Parallels/lab2Parallels/lab2Parallels/3"}
{"code": "for (i = i_peak2; i < 395; i++)\n{\n  if (((((((histogramT[i] + histogramT[i + 1]) + histogramT[i + 2]) + histogramT[i + 3]) + histogramT[i + 4]) / 5) < histogramT[i]) && (stop == 0))\n  {\n    bottom2b = histogramT[i];\n    i_bottom2b = i;\n  }\n  else\n    if (((((((histogramT[i] + histogramT[i + 1]) + histogramT[i + 2]) + histogramT[i + 3]) + histogramT[i + 4]) / 5) > histogramT[i]) && (stop == 0))\n  {\n    peak3 = histogramT[i];\n    i_peak3 = i;\n    stop = 1;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/YannChemin/distRS/prog/prog_ETa_METRIC/gdal_metric_eta/8"}
{"code": "for (long i = 0; i < MAX_MAGIC; i++)\n{\n  payload_set_magic(p, i);\n  payload_checksum(p, hash);\n  int cnt = count_zeroes(hash, sizeof(hash));\n  ret += cnt == target_count;\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Dunder-Muffin/parallelProgramming/problem5/run/0"}
{"code": "for (size_t i = 0; i < len; ++i)\n  if (seq[i] & bit_mask)\n{\n  seq[i] = value_traits.mask_char;\n  ++n;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/diamond-omp/masking/10"}
{"code": "for (int i = 0; i < nxn; i++)\n  for (int k = 0; k < nzn; k++)\n{\n  Bxn[i][0][k] = B0x * tanh((grid->getYC(i, 0, k) - (Ly / 2)) / delta);\n  Bxn[i][1][k] = Bxn[i][0][k];\n  Bxn[i][2][k] = Bxn[i][0][k];\n  Byn[i][0][k] = B0y;\n  Bzn[i][0][k] = B0z;\n  Bzn[i][1][k] = B0z;\n  Bzn[i][2][k] = B0z;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/31"}
{"code": "for (int a = 0; a < nkernels; a++)\n{\n  for (int b = 0; b < nchannels; b++)\n  {\n    for (int d = 0; d < kernel_order; d++)\n    {\n      for (int e = 0; e < kernel_order; e++)\n      {\n        kernelsAsFloats[a][d][e][b] = kernels[a][b][d][e];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for simd collapse(4)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saisankp/Concurrent-Systems/Lab-2-Parallel-Multichannel-Multikernel-Convolution/conv-harness/0"}
{"code": "for (j = 0; j < (1 << NUM_BUCKETS_LOG_2); j++)\n{\n  k1 = (j > 0) ? (bucket_ptrs[j - 1]) : (0);\n  for (i = k1; i < bucket_ptrs[j]; i++)\n  {\n    k = --key_buff_ptr_global[key_buff2[i]];\n    key_array[k] = key_buff2[i];\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,k1) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/IS/is/36"}
{"code": "for (indice_columnas = 0; indice_columnas < columnas_b; indice_columnas++)\n{\n  b[indice_filas][indice_columnas] = ((indice_filas + 1) * columnas_b) - (columnas_b - (indice_columnas + 1));\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vanecaradonna/openMP/Ejercicio6/ejercicio6/1"}
{"code": "for (i = numEdges - 1; i >= 0; --i)\n{\n  key = edges[i].src;\n  pos = vertex_cnt[key] - 1;\n  edges_sorted[pos] = edges[i];\n  vertex_cnt[key]--;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iMeanHow/OpenMP/Radix/src/sort/3"}
{"code": "for (r = 0; r < 1000; r++)\n{\n  loop1();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satlawa/edin_threaded_programming/loops_schedules/loop_schedules/0"}
{"code": "for (size_t i = 0; i < 100; i++)\n{\n  c[i] = a[i] + b[i];\n  printf(\"Thread %d: c[%2zu] = %g\\n\", tid, i, c[i]);\n}\n\n", "pragma": "omp for schedule(dynamic, CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/schedule/0"}
{"code": "for (x = 0; x < w; x++)\n  for (y = 0; y < h; y++)\n  univ[y][x] = (rand() < (32767 / 10)) ? (1) : (0);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LazyRacc00n/HPC-project/Project/OpenMP/experiment01/2"}
{"code": "for (int i = 0; i < row; i++)\n  matrix[i] = (double *) emalloc(col * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/allanamancio/matrixproduct/matrixproduct/2"}
{"code": "for (ci = nchunks - 1; ci >= 0; ci--)\n{\n  for (vi = chunkptr[ci]; vi < chunkptr[ci + 1]; vi++)\n  {\n    vj = iperm[vi];\n    buffer = nadjncy + nxadj[vi];\n    for (nedges = 0, ej = xadj[vj], ejend = xadj[vj + 1]; ej < ejend; ej++, nedges++)\n      buffer[nedges] = perm[adjncy[ej]];\n\n    buffer[nedges++] = vi;\n    if (nedges > 1)\n      gk_i32sorti(nedges, buffer);\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic, 1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KarypisLab/TriangleCounting/ptc/1"}
{"code": "for (i = 0; i < ((4 * TableSize) / 1024); i++)\n{\n  for (j = 0; j < 1024; j++)\n  {\n    ran[j] = (6364136223846793005ULL * ran[j]) + 1;\n    Table[ran[j] >> (64 - logTableSize)] ^= ran[j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/8"}
{"code": "for (i = 0; i < num_buckets; i++)\n{\n  threadCounts[thread_num][i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/danidomenico/OpenMP_TM/cowichan/cowichan_openmp/sort/3"}
{"code": "for (int j = 0; j < width; ++j)\n  for (int i = 0; i < height; ++i)\n  out[j].emplace_back(i, j);\n\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/muji-4ok/pixel-sort-qt5/sorter/5"}
{"code": "for (i = 0; i < Maze->Radius; i++)\n{\n  Maze->Nodes[i] = malloc(Maze->Sections[i] * (sizeof(node)));\n  for (j = 0; j < Maze->Sections[i]; j++)\n  {\n    Cartesify(&Maze->Nodes[i][j], i + 1, j, (1.0f / Maze->Sections[i]) * 360.0f);\n    Maze->Nodes[i][j].Self = k;\n    for (l = 0; l < 4; l++)\n      Maze->Nodes[i][j].Friends[l] = -1;\n\n    ++k;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephmcl/labyrinth-openmp/omp/13"}
{"code": "for (i = 0; i < 10; i++)\n{\n}\n\n", "pragma": "omp cancellation point for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/cancel-1/5"}
{"code": "for (i = 0; i < (s + 2); i++)\n  for (j = 0; j < (s + 2); j++)\n  filter->array[i][j] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kyriathar/MPI-OpenMP/filter_OMP/4"}
{"code": "for (j = 0; j < LX1; j++)\n{\n  for (i = 0; i < LX1; i++)\n  {\n    ixmc2[j][i] = ixtmc2[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/setup/16"}
{"code": "for (k = 0; k < nye; k++)\n{\n  for (j = 0; j < nxe; j++)\n  {\n    for (i = 0; i < ndim; i++)\n    {\n      a[(i + (ndim * j)) + (nnxe * k)] = b[(i + (ndim * j)) + (nnxe * k)] + c[(i + (ndim * j)) + (nnxe * k)];\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/7"}
{"code": "for (i = 1; i < (grid_points[0] - 1); i++)\n{\n  for (k = 1; k < (grid_points[2] - 1); k++)\n  {\n    matvec_sub(lhs[i][jsize][k][0], rhs[i][jsize - 1][k], rhs[i][jsize][k]);\n    matmul_sub(lhs[i][jsize][k][0], lhs[i][jsize - 1][k][2], lhs[i][jsize][k][1]);\n    binvrhs(lhs[i][jsize][k][1], rhs[i][jsize][k]);\n  }\n\n}\n\n", "pragma": "omp for private(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tutorial/bt_onefile/13"}
{"code": "for (j = 0; j < M; j++)\n{\n  a = adjacent_to(temp2, N - 1, j, 3, M);\n  if (a == 2)\n    NewBoard(N - 1, j) = Board(N - 1, j);\n\n  if (a == 3)\n    NewBoard(N - 1, j) = 1;\n\n  if (a < 2)\n    NewBoard(N - 1, j) = 0;\n\n  if (a > 3)\n    NewBoard(N - 1, j) = 0;\n\n}\n\n", "pragma": "omp parallel for private(j,a) shared(board,newboard) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/8"}
{"code": "for (i = 0; i <= (672 + 1); i++)\n{\n  Temperature_last[i][0] = 0.0;\n  Temperature_last[i][672 + 1] = (100.0 / 672) * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunowu/laplace/impl/OpenMP/laplace_omp/3"}
{"code": "for (;;)\n{\n}\n\n", "pragma": "    #pragma omp cancel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/cancel_messages/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  y = (((i - 1) * y_max) + ((m - i) * y_min)) / (m - 1);\n  for (j = 0; j < n; j++)\n  {\n    x = (((j - 1) * x_max) + ((n - j) * x_min)) / (n - 1);\n    count[i][j] = 0;\n    x1 = x;\n    y1 = y;\n    for (k = 1; k <= count_max; k++)\n    {\n      x2 = ((x1 * x1) - (y1 * y1)) + x;\n      y2 = ((2 * x1) * y1) + y;\n      if ((((x2 < (-2.0)) || (2.0 < x2)) || (y2 < (-2.0))) || (2.0 < y2))\n      {\n        count[i][j] = k;\n        break;\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n\n    if ((count[i][j] % 2) == 1)\n    {\n      r[i][j] = 255;\n      g[i][j] = 255;\n      b[i][j] = 255;\n    }\n    else\n    {\n      c = (int) (255.0 * (1 - (log(count[i][j]) / log(count_max))));\n      r[i][j] = c;\n      g[i][j] = c;\n      b[i][j] = c;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared ( b, count, count_max, g, r, x_max, x_min, y_max, y_min ) private ( i, j, k, x, x1, x2, y, y1, y2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ssvassiliev/Summer_School_OpenMP/code/mandelbrot_omp/0"}
{"code": "for (x = 0; x < 10; x++)\n{\n  a -= 10;\n}\n\n", "pragma": "omp parallel for private(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/src/imop/lib/testcases/cfgTests/parallelForConstruct/0"}
{"code": "for (int iter = 0; iter < KMEANS_MAX_ITER; ++iter)\n{\n  int done = 1;\n  for (size_t i = 0u; i < n_pixels; ++i)\n  {\n    struct pixel pixel = pixels[i];\n    size_t closest_centroid = find_closest_centroid(pixel, centroids, n_centroids);\n    if (closest_centroid != labels[i])\n    {\n      labels[i] = closest_centroid;\n      done = 0;\n    }\n\n    struct pixel *sum = &sums[closest_centroid];\n    sum->r += pixel.r;\n    sum->g += pixel.g;\n    sum->b += pixel.b;\n    counts[closest_centroid]++;\n  }\n\n  exec_time_kernel1 = ((double) (clock() - exec_begin)) / CLOCKS_PER_SEC;\n  exec_begin = clock();\n  for (size_t i = 0u; i < n_centroids; ++i)\n  {\n    if (counts[i])\n      continue;\n\n    done = 0;\n    size_t largest_cluster = 0u;\n    size_t largest_cluster_count = 0u;\n    for (size_t j = 0u; j < n_centroids; ++j)\n    {\n      if (j == i)\n        continue;\n\n      if (counts[j] > largest_cluster_count)\n      {\n        largest_cluster = j;\n        largest_cluster_count = counts[j];\n      }\n\n    }\n\n    struct pixel largest_cluster_centroid = centroids[largest_cluster];\n    size_t furthest_pixel = 0u;\n    double max_dist = 0.0;\n    for (size_t j = 0u; j < n_pixels; ++j)\n    {\n      if (labels[j] != largest_cluster)\n        continue;\n\n      double dist = pixel_dist(pixels[j], largest_cluster_centroid);\n      if (dist > max_dist)\n      {\n        furthest_pixel = j;\n        max_dist = dist;\n      }\n\n    }\n\n    struct pixel replacement_pixel = pixels[furthest_pixel];\n    centroids[i] = replacement_pixel;\n    labels[furthest_pixel] = i;\n    sums[i] = replacement_pixel;\n    struct pixel *sum = &sums[largest_cluster];\n    sum->r -= replacement_pixel.r;\n    sum->g -= replacement_pixel.g;\n    sum->b -= replacement_pixel.b;\n    counts[i] = 1u;\n    counts[largest_cluster]--;\n  }\n\n  for (int j = 0; j < n_centroids; ++j)\n  {\n    struct pixel *centroid = &centroids[j];\n    struct pixel *sum = &sums[j];\n    size_t count = counts[j];\n    centroid->r = sum->r / count;\n    centroid->g = sum->g / count;\n    centroid->b = sum->b / count;\n    sum->r = 0.0;\n    sum->g = 0.0;\n    sum->b = 0.0;\n    counts[j] = 0u;\n  }\n\n  if (done)\n    break;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Time0o/parallel-kmeans/c/src/kmeans/16"}
{"code": "for (i = 0; i < (LX1 - 1); i++)\n{\n  idmo[iel][face][1][1][LX1 - 1][i] = mor_s_v[1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/23"}
{"code": "for (int x = 0; x < 1024; ++x)\n{\n  b = b ^ a[x];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/5.0/loop/test_loop_reduction_bitxor/1"}
{"code": "for (i = 0; i < m; i++)\n{\n  a[i] = 0.0;\n  for (j = 0; j < n; j++)\n  {\n    a[i] += b[(i * n) + j] * c[j];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(m,n,a,b,c) private(i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dangets/openmp_examples/MatxVec/0"}
{"code": "for (j = 1024 / 2; j < (3 * (1024 / 4)); j++)\n  a[j] = b[j] + 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/openmp/libomptarget/omptests/t-target-enter-nowait/test/5"}
{"code": "for (i = 0; i < iter; i++)\n{\n  r = VecVecRed(b, SPMaVecPro(A, z, n), n);\n  x = GaussEli(M, r, n);\n  z = VecVecAdd(z, x, n);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/Gauss_Seidal/3"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  tmp = a[i] + i;\n  a[i] = tmp;\n}\n\n", "pragma": "omp parallel for private (tmp,i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/autoParallelization/tests/references/rose_scalar_true/0"}
{"code": "for (j = MAX(jstart, RADIUS); j <= MIN((n - RADIUS) - 1, jend); j++)\n{\n  for (i = MAX(istart, RADIUS); i <= MIN((n - RADIUS) - 1, iend); i++)\n  {\n    for (jj = -RADIUS; jj <= RADIUS; jj++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[0 + RADIUS][jj + RADIUS] * in[((i - istart) + RADIUS) + (((long) (((j + jj) - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n    for (ii = -RADIUS; ii < 0; ii++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[ii + RADIUS][0 + RADIUS] * in[(((i + ii) - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n    for (ii = 1; ii <= RADIUS; ii++)\n      out[(i - istart) + ((j - jstart) * width)] += weight[ii + RADIUS][0 + RADIUS] * in[(((i + ii) - istart) + RADIUS) + (((long) ((j - jstart) + RADIUS)) * ((long) (width + (2 * RADIUS))))];\n\n  }\n\n}\n\n", "pragma": "omp parallel for private (i, j, ii, jj)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ParRes/Kernels/MPIOPENMP/Stencil/stencil/1"}
{"code": "for (int i = 0; i < _nth; ++i)\n{\n  thread_args[i].t_id = i;\n  thread_args[i].start = start, thread_args[i].end = (start += _div + (i < _compensate));\n  pthread_create(&thread[i], 0, &pth_worker, &thread_args[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raushankit/Parallel-Computing/src/mat_mult/2"}
{"code": "for (unsigned int y = 0; y < height; y++)\n{\n  double realValue = upperLeftX;\n  for (unsigned int x = 0; x < width; x++)\n  {\n    escapeCounts[(y * width) + x] = isMandelbrotNumber(realValue, imaginaryValue, numberOfIterations);\n    realValue += incrementX;\n  }\n\n  imaginaryValue -= incrementY;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Balta-Stefan/Mandelbrot-viewer/src/MandelbrotCalculatorOLD/2"}
{"code": "for (int k = 0, i = train_len; i < N; k++, i++)\n  y_test[k] = y[index[i]];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lijinrun/ParallelProgramming/MPI+OpenMP/KNN/omp_knn/5"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f %f %f \", (float) polygonNormal[i * 3], (float) polygonNormal[(i * 3) + 1], (float) polygonNormal[(i * 3) + 2]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/106"}
{"code": "for (i = 0; i < N; i++)\n{\n  x[i] = 0.0;\n  b[i] = ((float) rand()) / ((32767 * 2.0) - 1.0);\n  flag[i] = 0;\n  a[i][i] = 2.0 + (((float) rand()) / ((32767 * 2.0) - 1.0));\n  for (j = 0; j < i; j++)\n    a[i][j] = ((float) rand()) / ((32767 * 2.0) - 1.0);\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimizisis/high-performance-computing/OpenMP/backsub/backsub_parallel/1"}
{"code": "for (p = 0; p < M; p++)\n{\n  temp2[(0 * M) + p] = Board(N - 2, p);\n}\n\n", "pragma": "omp parallel for private(p) shared(temp,board) num_threads(num_th)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/theoVag/Parallel-and-Distributed-Systems---Game-Of-Life-/src/play/1"}
{"code": "for (int j = 0; j < size; j++)\n{\n  outputSignal[2 * (offset + (j * step))] /= _size;\n  outputSignal[(2 * (offset + (j * step))) + 1] /= _size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/myctu1138/Samples/05_Fourie/11. filter (parallel)/fft/7"}
{"code": "for (i = 0; i < 16; i++)\n{\n  printf(\"Thread %d: Dynamic Ordered Hello World %d\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "omp parallel for schedule(dynamic) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tianyi93/hpxMP_mirror/examples/omp/tests/src/omp-for-dynamic/5"}
{"code": "for (int i = 0; i < nBuckets; i++)\n{\n  segmentsLeft += buckets[i].nSegments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pentalpha/sequencer/src/main/1"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/138"}
{"code": "for (i = L1; i <= L2; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    for (k = 1; k <= (nz - 2); k++)\n    {\n      flux[i][j][k][0] = u[i][j][k][1];\n      u21 = u[i][j][k][1] / u[i][j][k][0];\n      q = (0.50 * (((u[i][j][k][1] * u[i][j][k][1]) + (u[i][j][k][2] * u[i][j][k][2])) + (u[i][j][k][3] * u[i][j][k][3]))) / u[i][j][k][0];\n      flux[i][j][k][1] = (u[i][j][k][1] * u21) + (C2 * (u[i][j][k][4] - q));\n      flux[i][j][k][2] = u[i][j][k][2] * u21;\n      flux[i][j][k][3] = u[i][j][k][3] * u21;\n      flux[i][j][k][4] = ((C1 * u[i][j][k][4]) - (C2 * q)) * u21;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/15"}
{"code": "for (int i = 1; i < NUM_BINS; i += 2)\n{\n  _output[i - 1] = localBins[0][i - 1];\n  _output[i] = localBins[NUM_THREADS - 1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture13/Histogram/Histogram/12"}
{"code": "for (int i = 1; i < N; i++)\n  vec.col(i) += vec.col(i - 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MaverickTheDude/Parallel_computing/reverseCummulativeSum/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  if (max < abs(A[i][i]))\n    max = abs(A[i][i]);\n\n}\n\n", "pragma": "omp parallel for private(i) reduction(max: max)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/PetrosPapandonopoulos/OpenMP-Strictly-Diagonally-Dominant/main/1"}
{"code": "for (k = 0; k < ntimes; k++)\n{\n  MPI_Request req[16];\n  MPI_Status status[16];\n  MPI_Isend(&right_send[0], mysize, (MPI_Datatype) 0x4c000405, right, 0, comm, req);\n  MPI_Irecv(&right_rcv[0], mysize, (MPI_Datatype) 0x4c000405, right, 1, comm, req + 1);\n  MPI_Isend(&left_send[0], mysize, (MPI_Datatype) 0x4c000405, left, 1, comm, req + 2);\n  MPI_Irecv(&left_rcv[0], mysize, (MPI_Datatype) 0x4c000405, left, 0, comm, req + 3);\n  MPI_Isend(&matrix[1][1], mysize, (MPI_Datatype) 0x4c000405, up, 2, comm, req + 4);\n  MPI_Irecv(&matrix[0][1], mysize, (MPI_Datatype) 0x4c000405, up, 3, comm, req + 5);\n  MPI_Isend(&matrix[mysize][1], mysize, (MPI_Datatype) 0x4c000405, down, 3, comm, req + 6);\n  MPI_Irecv(&matrix[mysize + 1][1], mysize, (MPI_Datatype) 0x4c000405, down, 2, comm, req + 7);\n  MPI_Isend(&matrix[1][1], 1, (MPI_Datatype) 0x4c000405, up_left, 5, comm, req + 8);\n  MPI_Irecv(&matrix[0][0], 1, (MPI_Datatype) 0x4c000405, up_left, 6, comm, req + 9);\n  MPI_Isend(&matrix[mysize][mysize], 1, (MPI_Datatype) 0x4c000405, down_right, 6, comm, req + 10);\n  MPI_Irecv(&matrix[mysize + 1][mysize + 1], 1, (MPI_Datatype) 0x4c000405, down_right, 5, comm, req + 11);\n  MPI_Isend(&matrix[mysize][1], 1, (MPI_Datatype) 0x4c000405, down_left, 7, comm, req + 12);\n  MPI_Irecv(&matrix[mysize + 1][0], 1, (MPI_Datatype) 0x4c000405, down_left, 8, comm, req + 13);\n  MPI_Isend(&matrix[1][mysize], 1, (MPI_Datatype) 0x4c000405, up_right, 8, comm, req + 14);\n  MPI_Irecv(&matrix[0][mysize + 1], 1, (MPI_Datatype) 0x4c000405, up_right, 7, comm, req + 15);\n  for (i = 0; i < mysize; i++)\n  {\n    matrix[i + 1][mysize + 1] = right_rcv[i];\n    matrix[i + 1][0] = left_rcv[i];\n  }\n\n  int n_sum = 0;\n  int has_changed = 0;\n  {\n    int tid = omp_get_thread_num();\n    int total = omp_get_num_threads();\n    for (i = 2; i < mysize; i++)\n    {\n      for (j = 2; j < mysize; j++)\n      {\n        n_sum = neighbor_sum(matrix, i, j);\n        temp[i][j] = calculate_next_gen(n_sum, matrix[i][j]);\n        if (matrix[i][j] != temp[i][j])\n        {\n          has_changed = 1;\n        }\n\n      }\n\n    }\n\n  }\n  changed = 0;\n  MPI_Waitall(16, req, status);\n  for (i = 1; i < (mysize + 1); i++)\n  {\n    n_sum = neighbor_sum(matrix, i, mysize);\n    temp[i][mysize] = calculate_next_gen(n_sum, matrix[i][mysize]);\n    n_sum = neighbor_sum(matrix, i, 1);\n    temp[i][1] = calculate_next_gen(n_sum, matrix[i][1]);\n    n_sum = neighbor_sum(matrix, 1, i);\n    temp[1][i] = calculate_next_gen(n_sum, matrix[1][i]);\n    n_sum = neighbor_sum(matrix, mysize, i);\n    temp[mysize][i] = calculate_next_gen(n_sum, matrix[mysize][i]);\n  }\n\n  addr = matrix;\n  matrix = temp;\n  temp = addr;\n  MPI_Allreduce(&has_changed, &changed, 1, (MPI_Datatype) 0x4c000405, (MPI_Op) 0x58000007, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Koutoulakis/Parallel_Programming/MPI/6"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  omp_set_lock(&lck);\n  var++;\n  omp_unset_lock(&lck);\n}\n\n", "pragma": "omp teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB150-missinglock1-orig-gpu-yes/0"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  d = d + (p[j] * q[j]);\n}\n\n", "pragma": "omp for reduction(+:d)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/CG/cg/8"}
{"code": "for (i = 0; i < face->count; i++)\n{\n  k = 0;\n  for (j = 0; j < i; j++)\n  {\n    k += a[j] * remain_dim[j];\n  }\n\n  l = remain_dim[i];\n  for (j = 0; j < face->size[i]; j++)\n  {\n    if ((idx - k) < l)\n      break;\n    else\n      l += remain_dim[i];\n\n  }\n\n  a[i] = j;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vtsynergy/MetaMorph/metamorph-backends/openmp-backend/metamorph_openmp/12"}
{"code": "for (int i = 0; i < min(vals, cols); i++)\n{\n  sum += c[i];\n  printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], (100.0 * sum) / g.nodes);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/gc-omp/main/5"}
{"code": "for (size_t i = 0; i < loops.size(); i++)\n  result.push_back(getLoopIndexVariable(loops[i]));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/passlab/rexompiler/src/midend/programTransformation/ompLowering/omp_lowering/0"}
{"code": "for (i = 0; i < n; i++)\n  xk[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tungcyang/OpenMPJacobiAlgorithm/OpenMPJacobiAlgorithm/JacobiMethod/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  minDist = FLT_MAX;\n  for (j = 0; j < k; j++)\n  {\n    dist = pow(data[i].x - centroids[j].x, 2) + pow(data[i].y - centroids[j].y, 2);\n    if (dist < minDist)\n    {\n      minDist = dist;\n      labels[i] = j;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j, dist, minDist) num_threads(p)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yq314/k-means/k-means-openmp/kmeans/1"}
{"code": "for (i = 1; i < n; i++)\n  if (a[i - 1] > a[i])\n  return 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ysimonov/C-concurrent/OpenMP/lab3part4/1"}
{"code": "for (int i = mystart; i <= myend; i++)\n{\n  for (int j = 0; j < nx; j++)\n  {\n    i_c = i_start + ((i / (ny * 1.0)) * (i_end - i_start));\n    r_c = r_start + ((j / (nx * 1.0)) * (r_end - r_start));\n    i_z = i_c;\n    r_z = r_c;\n    iter = 0;\n    while (iter < maxiter)\n    {\n      iter = iter + 1;\n      double r_t = (r_z * r_z) - (i_z * i_z);\n      double i_t = (2.0 * r_z) * i_z;\n      i_z = i_t + i_c;\n      r_z = r_t + r_c;\n      if (((r_z * r_z) + (i_z * i_z)) > 4)\n      {\n        numoutside = numoutside + 1;\n        break;\n      }\n\n    }\n\n    mat[(i * nx) + j] = iter;\n  }\n\n}\n\n", "pragma": "omp for reduction(+:numoutside) nowait", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nvoronin1337/MPI-OpenMP-Parallel-Mandelbrot-Set/A9/0"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  for (k = 0; k < n; k++)\n{\n  this_diff = wref[i][j][k] - w[i][j][k];\n  if (this_diff < 0)\n  {\n    this_diff = (-1.0) * this_diff;\n  }\n\n  if (this_diff > 0.00000001)\n  {\n    numdiffs++;\n    if (this_diff > maxdiff)\n    {\n      maxdiff = this_diff;\n    }\n\n  }\n\n}\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vineeth-thumma/ParallelComputing/OpenMP/OpenMP/4"}
{"code": "for (int i = 1; i <= error_history.size(); ++i)\n{\n  (((out_file << i) << \",\") << error_history[i - 1]) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinayakvivek/Iterative-Closest-Point/src/icp/7"}
{"code": "for (i = 0; i < nx; i++)\n{\n  for (j = 0; j < ny; j++)\n  {\n    for (k = 0; k < nz; k++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        frct[i][j][k][m] = 0.0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/8"}
{"code": "for (size_t i = 0; i < size; ++i)\n{\n  hamiltonian[i] = ((1.0 - static_cast) < real_t) > (i / size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/hexciton-omp/utils/0"}
{"code": "for (i = 0; i < 10; i++)\n{\n  value = ((((uint32_t) atoi64[ARCH_INDEX(pos[0])]) | (((uint32_t) atoi64[ARCH_INDEX(pos[1])]) << 6)) | (((uint32_t) atoi64[ARCH_INDEX(pos[2])]) << 12)) | (((uint32_t) atoi64[ARCH_INDEX(pos[3])]) << 18);\n  pos += 4;\n  out[i] = value >> 16;\n  out[i + 11] = value >> 8;\n  out[i + 21] = value;\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dragonfly3_fmt_plug/2"}
{"code": "for (int i = 0; i < 500000000; i++)\n{\n  c[i] = a[i] * b[i];\n}\n\n", "pragma": "omp parallel for default(none) shared(a, b, c) schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hpc2n/OpenMP-Collaboration/Templates/Day_4/FirstTouch/SampleSolution/C/firstTouch_allparallel/1"}
{"code": "for (i = 0; i < M; ++i)\n{\n  for (k = 0; k < K; ++k)\n  {\n    register float A_PART = ALPHA * A[(i * lda) + k];\n    for (j = 0; j < N; ++j)\n    {\n      C[(i * ldc) + j] += A_PART * B[(k * ldb) + j];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/cjmcv/hpc/openmp/alg_matrix_multiply/1"}
{"code": "for (uint64_t i = 0; i < nsmall; i += 2)\n{\n  uint64_t h = smallsegs[i + 1];\n  uint64_t l = smallsegs[i + 0];\n  if (((h - l) + 1) <= insertionSize)\n    insertionSort(vec, l, h);\n  else\n    basicquicksort(vec, l, h);\n\n}\n\n", "pragma": "#pragma omp for schedule ( guided , 1 )", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/arnov-sinha/parallel-qsort/psort/4"}
{"code": "for (int i = 0; i < plength; ++i)\n{\n  for (int j = 0; j < pwidth; ++j)\n  {\n    for (int k = 0; k < pheight; ++k)\n    {\n      if (surface[(((i * pwidth) + j) * pheight) + k])\n        file_stream << 1.0f;\n      else\n        file_stream << 0.0f;\n\n      if (((c % 3) == 0) || (c == gridSize))\n      {\n        file_stream << \"\\n\";\n      }\n      else\n      {\n        file_stream << \" \";\n      }\n\n      ++c;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebastiandaberdaku/VoxMeshSurfOpenMP/src/MolecularSurface/MolecularSurface/4"}
{"code": "for (i = 0; i < SIZE; i++)\n  result = result + sqrt((v1[i] * v1[i]) + (v2[i] * v2[i]));\n\n", "pragma": "#pragma omp parallel for private(i) reduction(+:result)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/vector_dot_product/1"}
{"code": "for (int i = 0; i < thread_cnt; i++)\n{\n  changed_pri[i] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nyu-multicore/k-means/src/kmeans_par1/2"}
{"code": "for (int idx = 0; idx < nPreFixos; idx++)\n{\n  unsigned int flag = 0;\n  unsigned int bit_test = 0;\n  char vertice[20];\n  int N_l = N;\n  int i;\n  int depth;\n  unsigned long long qtd_solutions_thread = 0ULL;\n  int depthGlobal = depthPreFixos;\n  unsigned long long tree_size = 0ULL;\n  #pragma unroll 2\n  for (i = 0; i < N_l; ++i)\n  {\n    vertice[i] = _EMPTY_;\n  }\n\n  flag = root_prefixes[idx].control;\n  #pragma unroll 2\n  for (i = 0; i < depthGlobal; ++i)\n    vertice[i] = root_prefixes[idx].board[i];\n\n  depth = depthGlobal;\n  do\n  {\n    vertice[depth]++;\n    bit_test = 0;\n    bit_test |= 1 << vertice[depth];\n    if (vertice[depth] == N_l)\n    {\n      vertice[depth] = _EMPTY_;\n    }\n    else\n      if ((!(flag & bit_test)) && queens_stillLegal(vertice, depth))\n    {\n      ++tree_size;\n      flag |= 1ULL << vertice[depth];\n      depth++;\n      if (depth == N_l)\n      {\n        ++qtd_solutions_thread;\n      }\n      else\n        continue;\n\n    }\n    else\n      continue;\n\n\n    depth--;\n    flag &= ~(1ULL << vertice[depth]);\n  }\n  while (depth >= depthGlobal);\n  sols[idx] = qtd_solutions_thread;\n  vector_of_tree_size[idx] = tree_size;\n}\n\n", "pragma": "  #pragma omp target teams distribute parallel for thread_limit(_QUEENS_BLOCK_SIZE_)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/nqueen-omp/main/5"}
{"code": "for (int i = 0; i < countOut1; i++)\n{\n  int street = out1[i];\n  if (street_state[street].out == 1)\n  {\n    for (int j = 0; j < countStreet[street]; j++)\n    {\n      int c = factorSlot[street][j];\n      car_state[c].position--;\n    }\n\n    street_state[street].nb_cars--;\n    street_state[street].out = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Chalearm/OpenMPApp/TrafficSignaling/solution_check/0"}
{"code": "for (i = 0; i < remain_size; i++)\n{\n  if (strlen((seq2_all + ((num_procs * num_rows_each_proc) * BUF_SIZE_SEQ2)) + (BUF_SIZE_SEQ2 * i)) > 0)\n    printf(\"#%d: score: %d, n: %d, k: %d\\n\", i + (num_procs * num_rows_each_proc), local_remain_score[i], local_remain_offset[i], local_remain_mutant[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nmiz1987/MPI-OPENMP-CUDA/main/5"}
{"code": "for (size_t i = 0; i < Params.NumIterations; i++)\n{\n  ElapsedTime += Tick();\n  (((cout << \"Tick: \") << i) << \"\\r\") << flush;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/1"}
{"code": "for (unsigned int i = 0; i < size; i++)\n  printf(\"%i \", array[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NDaghboudj/Learn-OpenMP/01-Basics/omp_ex_19/2"}
{"code": "for (int i = 1; i <= n; i++)\n{\n  int **b = makemat(n, a, i);\n  if ((i % 2) == 0)\n    d -= a[0][i - 1] * determinant(n - 1, b);\n  else\n    if ((i % 2) == 1)\n    d += a[0][i - 1] * determinant(n - 1, b);\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Aiden-Frost/Linear-Algebra-openMP/4.Eigen_Vector_Values/eigen/3"}
{"code": "for (c2 = nm; c2 <= (((((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) < (nl + (-1))) ? (((nj + (-1)) < (nk + (-1))) ? (nj + (-1)) : (nk + (-1))) : (nl + (-1))); c2++)\n{\n  A[c1][c2] = (((double) c1) * c2) / ni;\n  B[c1][c2] = (((double) c1) * (c2 + 1)) / nj;\n  D[c1][c2] = (((double) c1) * (c2 + 2)) / nk;\n}\n\n", "pragma": "omp parallel for private(c2 )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB041-3mm-parallel-no/3"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  (((((((cout << (i + 1)) << \". \") << scores[i].s1) << \" \") << scores[i].s2) << \" \") << scores[i].score) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hknakst/Needleman-Wunsch-With-OpenMP/ParallelNeedlemanWunsch/0"}
{"code": "for (it = 1; it <= nit; it++)\n{\n  mg3P(u, v, r, a, c, n1, n2, n3, lt);\n  double ***_imopVarPre297;\n  double ***_imopVarPre298;\n  _imopVarPre297 = r[lt];\n  _imopVarPre298 = u[lt];\n  resid(_imopVarPre298, v, _imopVarPre297, n1, n2, n3, a, lt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/MG/hope/5"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  ((((cout << \"Thread \") << omp_get_thread_num()) << \" result = \") << result) << endl;\n  result += a[i] * b[i];\n}\n\n", "pragma": "    #pragma omp parallel for schedule(static, 2) reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/omp_data_scope_test2/1"}
{"code": "for (int j = i + 1; j < NUM_BODIES; ++j)\n{\n  _bodies[i].interact(_bodies[j]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ligh7bringer/Nbody-parallel/src/openmp/Simulation/1"}
{"code": "for (j = 0; j < (size - 1); j++)\n{\n  for (i = j + 1; i < size; i++)\n  {\n    factor = m[i][j] / m[j][j];\n    for (k = 0; k < size; k++)\n    {\n      u[i][k] = m[i][k] - (m[j][k] * factor);\n    }\n\n    l[i][j] = factor;\n  }\n\n  for (i = 0; i < size; i++)\n  {\n    for (k = 0; k < size; k++)\n    {\n      m[i][k] = u[i][k];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adilansari/luDecomposition/OpenMP/lu_openmp/0"}
{"code": "for (int RowId = 0; RowId < RowN; RowId++)\n{\n  out->PutStr(GetStr(m[RowId], 20, 18));\n  out->PutCh('\\n');\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/17"}
{"code": "for (i = 1; i <= n; i++)\n{\n  M1[i] = M1[i - 1] + test[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/TransposeSPMX/2"}
{"code": "for (int i = 0; i < nV; ++i)\n  for (int j = 0; j < nV; ++j)\n  graph[i][j] = (i == j) ? (0) : (INF);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Amagnum/Parallel-Floyd-Warshall-algorithm-omp/src/apsp/2"}
{"code": "for (j = 0; j < ny; j++)\n{\n  jglob = j;\n  for (k = 1; k < (nz - 1); k++)\n  {\n    zeta = ((double) k) / (nz - 1);\n    if ((jglob != 0) && (jglob != (ny0 - 1)))\n    {\n      eta = ((double) jglob) / (ny0 - 1);\n      for (i = 0; i < nx; i++)\n      {\n        iglob = i;\n        if ((iglob != 0) && (iglob != (nx0 - 1)))\n        {\n          xi = ((double) iglob) / (nx0 - 1);\n          exact(0, jglob, k, ue_1jk);\n          exact(nx0 - 1, jglob, k, ue_nx0jk);\n          exact(iglob, 0, k, ue_i1k);\n          exact(iglob, ny0 - 1, k, ue_iny0k);\n          exact(iglob, jglob, 0, ue_ij1);\n          exact(iglob, jglob, nz - 1, ue_ijnz);\n          for (m = 0; m < 5; m++)\n          {\n            pxi = ((1.0 - xi) * ue_1jk[m]) + (xi * ue_nx0jk[m]);\n            peta = ((1.0 - eta) * ue_i1k[m]) + (eta * ue_iny0k[m]);\n            pzeta = ((1.0 - zeta) * ue_ij1[m]) + (zeta * ue_ijnz[m]);\n            u[i][j][k][m] = (((((pxi + peta) + pzeta) - (pxi * peta)) - (peta * pzeta)) - (pzeta * pxi)) + ((pxi * peta) * pzeta);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(jglob, zeta, eta, iglob, xi, pxi, peta, pzeta)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/48"}
{"code": "for (int i; i < 30; i++)\n{\n  a[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/osvchnk/Parallel-programming/OpenMP/task10/0"}
{"code": "for (int i = 1; i < 16; i++)\n{\n  if (i <= 4)\n  {\n    printf(\"---------------------------RODANDO COM 2 THREADS---------------------------\\n\");\n    omp_set_num_threads(2);\n  }\n  else\n    if ((i > 4) && (i <= 8))\n  {\n    printf(\"---------------------------RODANDO COM 4 THREADS---------------------------\\n\");\n    omp_set_num_threads(4);\n  }\n  else\n    if ((i > 8) && (i <= 12))\n  {\n    printf(\"---------------------------RODANDO COM 6 THREADS---------------------------\\n\");\n    omp_set_num_threads(6);\n  }\n  else\n    if ((i > 12) && (i <= 16))\n  {\n    printf(\"---------------------------RODANDO COM 8 THREADS---------------------------\\n\");\n    omp_set_num_threads(8);\n  }\n\n\n\n\n  int *vetInvertidoV2;\n  vetInvertidoV2 = (int *) malloc(tam * (sizeof(int)));\n  preenche_vetor_em_sequencia(vetInvertidoV2, &tam);\n  vetInvertidoV2 = inverte_vetor(vetInvertidoV2, &tam);\n  printf(\"Vetor desordenado: \");\n  imprimirVetor(vetInvertidoV2, &tam);\n  start = omp_get_wtime();\n  bubblesortV2(vetInvertidoV2, &tam);\n  end = omp_get_wtime();\n  printf(\"Paralelo = %f\\n\", end - start);\n  printf(\"Vetor ordenado: \");\n  imprimirVetor(vetInvertidoV2, &tam);\n  free(vetInvertidoV2);\n  printf(\"-----------------------------------------------\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wennys-camilo/OpenMP/bubble_sortV2/8"}
{"code": "for (i = 0; i < 590; i++)\n{\n  for (j = 0; j < 590; j++)\n  {\n    C[i][j] = 0.;\n    for (k = 0; k < 590; k++)\n    {\n      C[i][j] += A[i][k] * B[k][j];\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/faxmishok/Matrix-PI-OpenMP-pw4-parallel/ex1/0"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  for (int j = 0; j < size; ++j)\n  {\n    a[i][j] = ((float) i) + j;\n    b[i][j] = ((float) i) - j;\n    c[i][j] = 0.0f;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ayush9719/Parallel-and-Distributed-Computing-Lab/Lab 02- Parallel and Serial Computation/Code/thread3_1335/0"}
{"code": "for (i = 0; i < nx; i++)\n{\n  heatgrid[0][0][i] = (heatgrid[1][0][i] = pow(cos(i * dx), 2));\n  heatgrid[0][nx - 1][i] = (heatgrid[1][nx - 1][i] = pow(sin(i * dx), 2));\n}\n\n", "pragma": "omp parallel for shared(heatgrid) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juliennelachance/apc524_hw4/heat_omp/2"}
{"code": "for (j = 0; j < ny; j++)\n{\n  jglob = j;\n  for (k = 1; k < (nz - 1); k++)\n  {\n    zeta = ((double) k) / (nz - 1);\n    if ((jglob != 0) && (jglob != (ny0 - 1)))\n    {\n      eta = ((double) jglob) / (ny0 - 1);\n      for (i = 0; i < nx; i++)\n      {\n        iglob = i;\n        if ((iglob != 0) && (iglob != (nx0 - 1)))\n        {\n          xi = ((double) iglob) / (nx0 - 1);\n          exact(0, jglob, k, ue_1jk);\n          exact(nx0 - 1, jglob, k, ue_nx0jk);\n          exact(iglob, 0, k, ue_i1k);\n          exact(iglob, ny0 - 1, k, ue_iny0k);\n          exact(iglob, jglob, 0, ue_ij1);\n          exact(iglob, jglob, nz - 1, ue_ijnz);\n          for (m = 0; m < 5; m++)\n          {\n            pxi = ((1.0 - xi) * ue_1jk[m]) + (xi * ue_nx0jk[m]);\n            peta = ((1.0 - eta) * ue_i1k[m]) + (eta * ue_iny0k[m]);\n            pzeta = ((1.0 - zeta) * ue_ij1[m]) + (zeta * ue_ijnz[m]);\n            u[i][j][k][m] = (((((pxi + peta) + pzeta) - (pxi * peta)) - (peta * pzeta)) - (pzeta * pxi)) + ((pxi * peta) * pzeta);\n          }\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/LU/lu/25"}
{"code": "for (int run = 0; run < numRuns; run++)\n{\n  totalTime += lstmNaive(hiddenSize, miniBatch, seqLength, numLayers, run);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_naive/8"}
{"code": "for (size_t l_co = 0; l_co < m_nCommElFa; l_co++)\n{\n  size_t l_el = m_sendEl[l_co];\n  unsigned short l_fa = m_sendFa[l_co];\n  o_veIdsAd[(l_el * l_nElFas) + l_fa] = m_sendVeIdsAd[l_co];\n  o_faIdsAd[(l_el * l_nElFas) + l_fa] = m_sendFaIdsAd[l_co];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/3343/edge/src/mesh/EdgeV/13"}
{"code": "for (int i = 0; i < maxNumOfNodes; ++i)\n{\n  nodes[i].seen = false;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/WuedK/Concurrent_Programming_SBU_2022/Assignments/2/DFS/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    a[i][j] = (i * j) * s;\n    b[i][j] = (i + j) + s;\n    s = -s;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_6_1_0_release/testsuite/libgomp.c/examples-4/simd-5/0"}
{"code": "for (int i = 0; i < numberOfPointsForHost; i++)\n{\n  int tid = omp_get_thread_num();\n  if ((tid == MASTER_THREAD) && activateCuda)\n  {\n    cudaCalcDistanceToCentroid(mPointsInDevice, aNumberOfPointsForCuda, mNumberOfPointsInDevice, mCentroidsInDevice, mNumberOfCentroidsInDevice, mHasUpdatedInDevice);\n    CudaGetHasChangedFlag(&pointChangedCentroidInCuda);\n    activateCuda = false;\n  }\n\n  pointChangedCentroidInOmp = omp_calc_distance_point_to_centroids(&aPoints[i], aCentroids, aNumberOfCentroids);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tamirsagi/Kmeans/Kmeans/2"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  x = drandom();\n  y = drandom();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "omp for reduction(+:Ncirc) private(x,y,test)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tgmattso/OpenMP_Exercises/challenge_problems/pi_monte_carlo/Solutions/pi_mc_par/0"}
{"code": "for (i = 0; i < px; i++)\n  for (j = 0; j < py; j++)\n  sum += im[(i * py) + j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mizadri/parallel/OpenMP/filtro-bloques/4"}
{"code": "for (i = c + 1; i <= a; i++)\n{\n  if (primes_[i] > sqrtx)\n    break;\n\n  int64_t xp = fast_div(x, primes_[i]);\n  if (is_pix(xp, i - 1))\n    break;\n\n  sum += (phi < (-SIGN)) > ((xp, i - 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kimwalisch/primecount/src/phi/0"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    (((((((((((sum_file << \"[\") << i) << \"]\") << \"[\") << j) << \"]: \") << a[i][j]) << \" + \") << b[i][j]) << \" = \") << c[i][j]) << \"\\n\";\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Mazuruk-O/OpenMP_example/OpenMp_2_lab/OpenMP_2_lab/OpenMP_2_lab/2"}
{"code": "for (int i = 0; i < max.capa; ++i)\n  look_ahead[i] = 1;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hobywan/trinity/src/matching/4"}
{"code": "for (k = 1; k <= ((grid_points[2] - 1) - 1); k += 1)\n{\n  for (m = 0; m <= 4; m += 1)\n  {\n    rhs[i][j][k][m] = rhs[i][j][k][m] - (dssp * ((((u[i - 2][j][k][m] - (4.0 * u[i - 1][j][k][m])) + (6.0 * u[i][j][k][m])) - (4.0 * u[i + 1][j][k][m])) + u[i + 2][j][k][m]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (k,m)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/BT/bt/86"}
{"code": "for (x = 0; x < size; x++)\n{\n  free(grid[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SgtSwagrid/supercomputing/02 - Conway+RDF/life/3"}
{"code": "for (i = 1; i <= NODESX; i++)\n  TOPO[i][(5 + 2) - 1] = TOPO[i][1];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/102"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < dims; j++)\n  ref_points[i][j] = ((1.1 * rand()) * 5000) / 32767;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/marcvanheerden/knn_parallel_project/knn_parallel/4"}
{"code": "for (int i = 0; i < input.sizeOfVector; i++)\n{\n  results[i] = (input.a[i] * input.x) + input.b[i];\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shepherdjerred-homework/openmp-timing/src/main/2"}
{"code": "for (int i = 0; i <= sN; i++)\n  for (int j = 0; j <= _M; j++)\n{\n  int bi = 1;\n  int bj = 1;\n  if (sN / mpi_size)\n    bi = i / (sN / mpi_size);\n\n  if (_M / mpi_size)\n    bj = j / (_M / mpi_size);\n\n  if (bi >= mpi_size)\n    bi = mpi_size - 1;\n\n  if (bj >= mpi_size)\n    bj = mpi_size - 1;\n\n  int st = bi - bj;\n  if (st < 0)\n    st += mpi_size;\n\n  st = (st + mpi_rank) % mpi_size;\n  s->rb = st * (K / mpi_size);\n  s->re = s->rb + (K / mpi_size);\n  if (st == 0)\n    s->rb = 0;\n\n  if (st == (mpi_size - 1))\n    s->re = K + 1;\n\n  if (s->rb != 0)\n    sbp[0][0] = x[idx(i, j, s->rb)];\n\n  if (s->re != (K + 1))\n    sbp[1][0] = x[idx(i, j, s->re - 1)];\n\n  sbp[0]++;\n  sbp[1]++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/137"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  if (array == 0)\n    return 0;\n\n  if (array[i] == value)\n    return 1;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JiyanBlack/MPI-HPC-Project2/Project2/8"}
{"code": "for (size_t i = 0; i < AllFlocksVec.size(); i++)\n{\n  AllFlocksVec[i]->ComputeBB();\n}\n\n", "pragma": "#pragma omp for schedule(dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GustavoSilvera/ParallelBoids/source/Simulator/10"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"Thread %d executes loop iteration %d\\n\", 0, i);\n  b[i] = 2 * a[i];\n}\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.12-two-for-loops/3"}
{"code": "for (int i = 0; i < ((sizeof(a)) / (sizeof(*a))); i++)\n{\n  x += a[(((sizeof(a)) / (sizeof(*a))) - 1) - i] * pow(2, i);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+: x) num_threads(4)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nullkod/OpenMP/hw13/main/0"}
{"code": "for (i = 0; i < a_r; i++)\n{\n  printf(\"\\ncan not multiply\");\n  goto again;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TejaswiParuchuri/ParalleProcessing/mulmp/1"}
{"code": "for (int i = 0; i <= N; i++)\n{\n  if (dead[i] == 1)\n    continue;\n\n  pr[i] = d / (N * 1.0);\n  for (int v = 0; v < rev[i].size(); v++)\n  {\n    int ver = rev[i][v];\n    pr[i] += ((prev[ver] * 1.0) / (outdeg[ver] * 1.0)) * (1.0 - d);\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for  ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sgk98/distributed_pagerank/src/new/12"}
{"code": "for (int i = 0; i < (n / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/8"}
{"code": "for (i = 1; i < (n / 2); i++)\n{\n  x = h * (((double) i) - 0.5);\n  area += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Danark/miniomp_github/test/pi2/1"}
{"code": "for (int i = 0; i < nz; i++)\n{\n  num.push_back(tmp[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/netweel/Parallel-programming-OpenMP_TBB_std-thread/OpenMP/umnrazr/1"}
{"code": "for (i = 1; i < argc; i++)\n{\n  if ((i + 1) != argc)\n  {\n    if (strcmp(argv[i], \"-r\") == 0)\n    {\n      TotalRows = atoi(argv[i + 1]);\n    }\n    else\n      if (strcmp(argv[i], \"-c\") == 0)\n    {\n      TotalColumns = atoi(argv[i + 1]);\n    }\n    else\n      if (strcmp(argv[i], \"-f\") == 0)\n    {\n      filename = argv[i + 1];\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/billDrett/GameOfLife-MPI-OpenMp-Cuda-/openMP/openmpMasterThreadCommunication/main/1"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\" %g \", v1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ivanortegaalba/prog-pararela-OpenMP/P3/7/pvm-secuencial/3"}
{"code": "for (i = 1; i < NARRAY; i += 2)\n{\n  if (v2[i - 1] > v2[i])\n  {\n    tmp = v2[i - 1];\n    v2[i - 1] = v2[i];\n    v2[i] = tmp;\n  }\n\n}\n\n", "pragma": "       #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/michaelmcs/metodos-de-ordenamiento-OPENMP/trabajofinaltodoenunoparalelo/main/2"}
{"code": "for (index = 0; index < kpc; index++)\n{\n  memcpy(((unsigned char *) prep_key[index]) + 510, (unsigned char *) salt, 8);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/SybaseASE_fmt_plug/3"}
{"code": "for (int i = 0; i < noOfElements; i++)\n{\n  arrWrite[i] = rand() % 100;\n  a3[i] = arrWrite[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AniMahajan20/Parallel-Computing/HyperQuickSort using OpenMP/hyperquicksort_openmp/0"}
{"code": "for (int i = 0; i < n; i++)\n  for (int j = 0; j < m; j++)\n  a[(i * m) + j] = ((float) id) + 0.00001;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Brenolleite/Parallel-Programming/mcm_parallel/1"}
{"code": "for (i = 0; i < 20; i++)\n{\n  for (j = 0; j < 20; j++)\n    a[i][j] = (i * 20) + j;\n\n}\n\n", "pragma": "omp parallel for private(i ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB053-inneronly1-orig-no/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  riDividedOnDiClause_quant[v] = quantize_16(riDividedOnDiClause[v], rDivD_params.scale, rDivD_params.zero);\n}\n\n", "pragma": "omp parallel for private(v) shared(riDividedOnDiClause_quant,riDividedOnDiClause,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/24"}
{"code": "for (int i = (N / 4) * 3; i < N; i++)\n{\n  int tempMult = ((A[i] % 2) == 0) ? (B[i] / C[i]) : (B[i] + C[i]);\n  if (tempMult)\n  {\n    multiply *= tempMult;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MietLabsStorage/MIET_OpenMP_labs/Lab3/Lab3/Lab3/10"}
{"code": "for (int a = 0; a < r; a++)\n{\n  for (int b = 0; b < c; b++)\n  {\n    image.read(&temp, 1);\n    mat[a][b] = temp;\n  }\n\n  image.read(&temp, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mayank42/OpenMP-MPI-Tasks/Task1/Part2/Asgn2/0"}
{"code": "for (i = 0; i < 1000; i++)\n  b[i] = 10;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SOLLVE/sollve_vv/tests/4.5/task/test_task_target/1"}
{"code": "for (int i = 0; i < N; i += step)\n{\n  v += 2;\n  v = v + step;\n}\n\n", "pragma": "omp parallel for reduction(+:v)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/benhg/dependency-taxonomy/flow_RAW/omp_1_parallel/0"}
{"code": "for (i = 0; i < N; i++)\n  for (k = 0; k < N; k++)\n  for (j = 0; j < N; j++)\n{\n  c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n}\n\n\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/matrix_mulitply/omp_mm/0"}
{"code": "for (int i = 0; i < (chromo_length - 1); i++)\n{\n  for (int j = i + 1; j < chromo_length; j++)\n  {\n    float distance = get_distance(cities[i], cities[j]);\n    dist_matrix[i][j] = (dist_matrix[j][i] = distance);\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(NUM_THRDS)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ygutgutia/TSP-Genetic-Algorithm-OpenMP/GA_TSP_Parallel/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  for (int j = 0; j < M; j++)\n  {\n    if (x[i][j] == INT_MIN)\n      cout << \"x \";\n    else\n      (cout << x[i][j]) << \" \";\n\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mujundi/assembler/Assembler/assemble/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    c[i][j] = 0.0;\n    for (k = 0; k < n; k++)\n    {\n      c[i][j] = c[i][j] + (a[i][k] * b[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lmontigny/openMP/matrixProduct/1"}
{"code": "for (i = 0; i < Np; i++)\n{\n  r_old[i] = r[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_leukocyte/OpenMP/track_ellipse/14"}
{"code": "for (i = 0; i < n; i++)\n{\n  y[i] = i * 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/looptest_1/1"}
{"code": "for (int j = x; j < (x + sampleSize); j++)\n{\n  songSection[j - x] = song[j];\n}\n\n", "pragma": "#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fatemehNe/openmp-lab/amplifier XE&schedule/Lab-1-1/7"}
{"code": "for (y = (imageSize / 4) * (-2); y < ((imageSize / 4) * 2); ++y)\n{\n  for (x = (imageSize / 4) * (-3); x < ((imageSize / 4) * 1); ++x)\n  {\n    xm = ((double) x) / (imageSize / 2);\n    ym = ((double) y) / (imageSize / 2);\n    znX = (znY = 0);\n    if (((xm * xm) + (ym * ym)) < 2)\n    {\n      for (z = 0; z < maxIter; ++z)\n      {\n        zn1X = ((znX * znX) - (znY * znY)) + xm;\n        zn1Y = ((2 * znX) * znY) + ym;\n        if (((zn1X * zn1X) + (zn1Y * zn1Y)) > 4)\n          break;\n\n        znX = zn1X;\n        znY = zn1Y;\n      }\n\n      if (z < maxIter)\n      {\n        imageMatrix[(imageSize / 2) + y][((imageSize / 2) + (imageSize / 4)) + x] = (z + 1) + (log(log((znX * znX) + (znY * znY))) / log(z));\n      }\n      else\n      {\n        imageMatrix[(imageSize / 2) + y][((imageSize / 2) + (imageSize / 4)) + x] = 201;\n      }\n\n    }\n    else\n    {\n      imageMatrix[(imageSize / 2) + y][((imageSize / 2) + (imageSize / 4)) + x] = 200;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) private(x,xm,ym,znX, znY, zn1, zn1X, zn1Y,z)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saumyabhadani95/Mandelbrot-set-parallel/OpenMPMandelbrot/0"}
{"code": "for (int p = 0; p < numPoints; p++)\n{\n  (((myfile << dataset[p].id) << \",\") << clusters[globalMembership[p]].id) << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmscarla/k-means-parallel/Node/20"}
{"code": "for (int i = 0; i < size; i++)\n{\n  sum += arr[i];\n}\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yehia67/OpenMP-Examples/lab5_main1_Reduction/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  a[i] = malloc(n * (sizeof(double *)));\n  l[i] = malloc(n * (sizeof(double *)));\n  u[i] = malloc(n * (sizeof(double *)));\n  pi[i] = i;\n  for (j = 0; j < n; j++)\n  {\n    drand48_r(&drand_buf, &a[i][j]);\n    a[i][j] = (a[i][j] + 0.5) / 2;\n    if (i == j)\n    {\n      l[i][j] = 1;\n      drand48_r(&drand_buf, &u[i][j]);\n    }\n    else\n    {\n      if (i > j)\n      {\n        drand48_r(&drand_buf, &l[i][j]);\n        u[i][j] = 0;\n      }\n      else\n      {\n        drand48_r(&drand_buf, &u[i][j]);\n        l[i][j] = 0;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/openmp/0"}
{"code": "for (int i = 0; i < 100000000; i++)\n{\n  A[i] = 1;\n  B[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josemonsalve2/openmp_tutorial/Labs/Lab4/Solutions/exercise3/1"}
{"code": "for (int j = 0; j < size_u[0]; j++)\n{\n  for (int k = 0; k < size_u[1]; k++)\n  {\n    u[0][j][k] = 1.0;\n    u[1][j][k] = 1.0;\n    u[2][j][k] = 1.0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/maelso/OpenMP5.0/time_marching/1"}
{"code": "for (int i = 0; i < m; i++)\n{\n  total += data[(i * n) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Fabbeiru/PCA/Source/3"}
{"code": "for (int i = 0; i < this->nnz_; ++i)\n{\n  this->mat_.val[i] *= alpha;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_coo/17"}
{"code": "for (long long l = 2; l <= N; l += BLOCK_SIZE)\n{\n  long long r = l + BLOCK_SIZE;\n  if (r > N)\n    r = N;\n\n  result += sieveProcessOddBlockSqrt(l, r);\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Dalgerok/parallel-sieve-of-eratosthenes-/soe_odd_only_blockwise_sqrt/0"}
{"code": "for (int i = 0; i < nov; i++)\n{\n  arr[i] = sparse3(xadj, adj, i);\n}\n\n", "pragma": "            #pragma omp for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CS-406-Parallel-Programming/Sparse-Matrix-Cycle-Count/openmp_nonrecursive/4"}
{"code": "for (i = 0; i <= (public.allPoints - 1); i += 1)\n{\n  private[i].in_partial_sum = (float *) malloc((((sizeof(float)) * 2) * public.tSize) + 1);\n  private[i].in_sqr_partial_sum = (float *) malloc((((sizeof(float)) * 2) * public.tSize) + 1);\n  private[i].par_max_val = (float *) malloc((sizeof(float)) * (((2 * public.tSize) + (2 * public.sSize)) + 1));\n  private[i].par_max_coo = (int *) malloc((sizeof(int)) * (((2 * public.tSize) + (2 * public.sSize)) + 1));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/main/3"}
{"code": "for (k = 0; k < nvtx_scale; ++k)\n  has_adj[k] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/0"}
{"code": "for (int i = 1; i <= n; i++)\n  isum += a[i];\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kka-na/parallel_image_processing/ex3/ex3/4"}
{"code": "for (int imf = 1; imf <= mode; ++imf)\n{\n  for (int i = 0; i < length; ++i)\n  {\n    Current[i] = Residual[i];\n  }\n\n  IterationCount = 0;\n  for (int iteration = 0; iteration < 250; ++iteration)\n  {\n    FindExtrema(Current, length, UpExtrema, UpLength, LowExtrema, LowLength);\n    if ((UpLength < 1) || (LowLength < 1))\n      break;\n\n    Spline(Current, UpEnvelope, length, UpExtrema, UpLength, 1);\n    Spline(Current, LowEnvelope, length, LowExtrema, LowLength, 1);\n    for (int i = 0; i < length; ++i)\n    {\n      MeanEnvelope[i] = (UpEnvelope[i] + LowEnvelope[i]) * 0.5;\n      Current[i] = Current[i] - MeanEnvelope[i];\n    }\n\n    IterationCount++;\n    if (STDEV(MeanEnvelope, length) < (STDEV(Current, length) * TargetSTDEV))\n      break;\n\n  }\n\n  for (int i = 0; i < length; ++i)\n  {\n    result[imf - 1][i] = Current[i];\n    Residual[i] -= Current[i];\n    residual[imf - 1][i] = Residual[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CardLin/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/HHSA_CPU_OpenMP/7"}
{"code": "for (j = 1; j <= ma; j++, wptr++)\n  if ((*wptr) < thresh)\n  *wptr = 0.0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/reedv/Tircis/tircis_process_cmd_v4/svdfit_d/3"}
{"code": "for (size_t i = 0; i < 5120; i++)\n{\n  if (ref[i] != c[i])\n  {\n    printf(\"Bad results :-(((\\n\");\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/fritschnils/tp-parallelisation/tp1/tp1_5_matvec/3"}
{"code": "for (int i = 0; i < list_size; ++i)\n{\n  input_list[i] = next_prime(input_list[i]);\n}\n\n", "pragma": "omp parallel for shared(list_size, input_list)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/labs/Lab6/Software/OpenMP/next_prime/0"}
{"code": "for (j = 1; j < (nrows + 1); j++)\n{\n  rowstr[j] = rowstr[j] + rowstr[j - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/CG/cg/19"}
{"code": "for (i = 0; i < 5; i++)\n{\n  pagRank = ((double) topFive[i]) / ((double) (nSize * K));\n  fprintf(outFile, \"%d,%d,%lf\\n\", topNodes[i], topFive[i], pagRank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ManuelBerrueta/cpts411_PageRankEstimator/pagerankestimator/5"}
{"code": "for (int i = 0; i < (n * n); ++i)\n{\n  a[i] = rand() % 10;\n  b[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tonibofarull/mini-openmp/miniomp/test/tfinal/6"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"x(%d) <--> y(%d)\\n\", x[i], y[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sdasgup3/parallel-programming/OpenMP/Samples/looptest_1/2"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  for (size_t j = 0; j < n; ++j)\n  {\n    sum += mtx[(i * n) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/parallel-runtimes/lomp/examples/matmul/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  expr = i % ((3 * (i / 30)) + 1);\n  if (expr == 0)\n  {\n    jmax[i] = N;\n  }\n  else\n  {\n    jmax[i] = 1;\n  }\n\n  c[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cstyl/omp-scheduling/src/loops/workload/1"}
{"code": "for (i = k1; i >= j1; --i)\n{\n  if ((i < j2) || (i > k2))\n    ++e;\n\n  ++c;\n}\n\n", "pragma": "omp for schedule (dynamic) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr29947-1/3"}
{"code": "for (int i = 0; i < M; i++)\n{\n  for (int j = 0; j < N; j++)\n  {\n    if (i == j)\n    {\n      (Sf << \" \") << S[i];\n    }\n    else\n    {\n      Sf << \" 0.0\";\n    }\n\n  }\n\n  Sf << \"\\n\";\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lixueclaire/Parallel-SVD/OMP_SVD/13"}
{"code": "for (i = 0; i <= 7; i++)\n{\n  debug_vec[i] = DEBUG_DEFAULT;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/1"}
{"code": "for (i3 = 1; i3 < e3; i3++)\n{\n  x1 = x0;\n  for (i2 = 1; i2 < e2; i2++)\n  {\n    xx = x1;\n    vranlc(d1, &xx, A, &z[i3][i2][1]);\n    randlc(&x1, a1);\n  }\n\n  randlc(&x0, a2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/MG/mg/15"}
{"code": "for (int i = 1; i <= num; ++i)\n{\n  sum += i * i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/scheduleFor/0"}
{"code": "for (graph->xadj[0] = 0, k = 0, i = 0; i < nvtxs; i++)\n{\n  do\n  {\n    if (gk_getline(&line, &lnlen, fpin) == (-1))\n      gk_errexit(SIGERR, \"Pregraphure end of input file: file while reading row %d\\n\", i);\n\n  }\n  while (line[0] == '%');\n  head = line;\n  tail = 0;\n  if (readsizes)\n  {\n    if (isfvsizes)\n    {\n      graph->fvsizes[i] = strtof(head, &tail);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->fvsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n    else\n    {\n      graph->ivsizes[i] = strtol(head, &tail, 0);\n      if (tail == head)\n        gk_errexit(SIGERR, \"The line for vertex %zd does not have size information\\n\", i + 1);\n\n      if (graph->ivsizes[i] < 0)\n        gk_errexit(SIGERR, \"The size for vertex %zd must be >= 0\\n\", i + 1);\n\n    }\n\n    head = tail;\n  }\n\n  if (readwgts)\n  {\n    for (l = 0; l < ncon; l++)\n    {\n      if (isfvwgts)\n      {\n        graph->fvwgts[(i * ncon) + l] = (float) strtod(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->fvwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n      else\n      {\n        graph->ivwgts[(i * ncon) + l] = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"The line for vertex %zd does not have enough weights for the %d constraints.\\n\", i + 1, ncon);\n\n        if (graph->ivwgts[(i * ncon) + l] < 0)\n          gk_errexit(SIGERR, \"The weight vertex %zd and constraint %zd must be >= 0\\n\", i + 1, l);\n\n      }\n\n      head = tail;\n    }\n\n  }\n\n  while (1)\n  {\n    ival = (int) strtol(head, &tail, 0);\n    if (tail == head)\n      break;\n\n    head = tail;\n    if ((graph->adjncy[k] = ival + numbering) < 0)\n      gk_errexit(SIGERR, \"Error: Invalid column number %d at row %zd.\\n\", ival, i);\n\n    if (readvals)\n    {\n      if (isfewgts)\n      {\n        fval = strtof(head, &tail);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->fadjwgt[k] = fval;\n      }\n      else\n      {\n        ival = strtol(head, &tail, 0);\n        if (tail == head)\n          gk_errexit(SIGERR, \"Value could not be found for edge! Vertex:%zd, NNZ:%zd\\n\", i, k);\n\n        graph->iadjwgt[k] = ival;\n      }\n\n      head = tail;\n    }\n\n    k++;\n  }\n\n  graph->xadj[i + 1] = k;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/metis-5.1.0/GKlib/graph/14"}
{"code": "for (i = 1; i < numprocs; i++)\n{\n  MPI_Recv(&quantmaior, 5, (MPI_Datatype) 0x4c000405, i, 4, (MPI_Comm) 0x44000000, &status);\n  int y;\n  for (y = 0; y < 5; y++)\n  {\n    int f = 0;\n    f = *(((int *) quantmaior) + y);\n    qntmaior[y] = f + qntmaior[y];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MarceloMilbradt/Analizador-genoma-paralelo/dna/6"}
{"code": "for (i = 0; i < 3; i++)\n{\n  xstart[i] = 1;\n  xend[i] = 256;\n  ystart[i] = 1;\n  yend[i] = 256;\n  zstart[i] = 1;\n  zend[i] = 128;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rose-compiler/rose/projects/OpenK/test/npb2.3-omp-c/FT/ft_single/27"}
{"code": "for (u = 0, v = num_vertices - topk; v < num_vertices; v++, u++)\n{\n  ref_rankedVertices[u] = ref_stats->realRanks[v];\n  ref_rankedVerticesfloat[u] = ref_stats->pageRanks[stats->realRanks[v]];\n  ref_rankedVerticesReal[u] = ((float) ref_stats->realRanks[v]) / ((float) 1.0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/15"}
{"code": "for (unsigned int i = 0; i < (rows - 2); i++)\n{\n  for (unsigned int j = 0; j < (cols - 2); j++)\n  {\n    data_avg[i + 1][j + 1] = ((((((((data[i][j] + data[i][j + 1]) + data[i][j + 2]) + data[i + 1][j]) + data[i + 1][j + 1]) + data[i + 1][j + 2]) + data[i + 2][j]) + data[i + 2][j + 1]) + data[i + 2][j + 2]) / 9.0;\n    if (data_avg[i + 1][j + 1] >= data_avg[max_row][max_col])\n    {\n      {\n        max_avg = data_avg[i + 1][j + 1];\n        max_row = i + 1;\n        max_col = j + 1;\n      }\n    }\n\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zendsley/cs312/matAverager/1"}
{"code": "for (int i = 0; i < 1000; i++)\n{\n  #pragma GCC ivdep\n  for (int j = 0; j < 1000; j++)\n    c[i][j] = a[i][j] + b[i][j];\n\n}\n\n", "pragma": "omp parallel for schedule(static,50)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Exercise4/addMAt/addMat_omp/0"}
{"code": "for (int j = 0; j < k; j++)\n{\n  sumk += ((k - j) + 6) * fabs((u[j] * u[j]) / (d[j] - lambda_j));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ibamba/Secular_Equation_Solvers_In_OpenMP/gragg/14"}
{"code": "for (i = 1; i < (nx - 1); i++)\n{\n  sigma1_np1_jac[i] = ((-(dx * dx)) / (dt * dt)) - (1.0 / (dx * dx));\n  sigma2_np1_jac[i] = ((dx * dx) / (dt * dt)) + (1.0 / (dx * dx));\n  sigma1_n_jac[i] = 1;\n  sigma2_n_jac[i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/routines/13"}
{"code": "for (int i = 0; i < nElements; ++i)\n{\n  arr[i] = rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/senior-sigan/ParallelMethods/parallel_2/parallel_2/1"}
{"code": "for (v = 0; v < num_vectors; v++)\n  multMatrixVector(rotation_matrix, &original_vectors[v * 3], &rotated_vectors[v * 3]);\n\n", "pragma": "omp parallel for num_threads(thread_count)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/devinspire-gitch/OpenmpParallel/serial_vector_rotate_modified/0"}
{"code": "for (int i = 0; i < L1_NEURONS; i++)\n{\n  delta_i = DELTA_L1[i];\n  WL1[i][0] += ALPHA * delta_i;\n  for (int j = 1; j < L1_DIM; j++)\n  {\n    WL1[i][j] += (ALPHA * delta_i) * vector_in[j - 1];\n  }\n\n}\n\n", "pragma": "omp parallel for private(delta_i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/n-roussos/Parallel-Programming-with-OpenMP/4. Neural networks/NN4/NN4.2/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  y[i] = 0;\n  for (int u = Ap[i]; u < Ap[i + 1]; u++)\n  {\n    int j = Aj[u];\n    double A_ij = Ax[u];\n    y[i] += A_ij * x[j];\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(guided)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArthurZucker/HighPerformanceComputing/Projet/OMP/cg/0"}
{"code": "for (k = 1; k <= (nz - 2); k++)\n{\n  flux[i][j][k][0] = rsd[i][j][k][2];\n  u31 = rsd[i][j][k][2] / rsd[i][j][k][0];\n  q = (0.50 * (((rsd[i][j][k][1] * rsd[i][j][k][1]) + (rsd[i][j][k][2] * rsd[i][j][k][2])) + (rsd[i][j][k][3] * rsd[i][j][k][3]))) / rsd[i][j][k][0];\n  flux[i][j][k][1] = rsd[i][j][k][1] * u31;\n  flux[i][j][k][2] = (rsd[i][j][k][2] * u31) + (C2 * (rsd[i][j][k][4] - q));\n  flux[i][j][k][3] = rsd[i][j][k][3] * u31;\n  flux[i][j][k][4] = ((C1 * rsd[i][j][k][4]) - (C2 * q)) * u31;\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,k ,ny ,u31 ,q ,nz ,L2 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/26"}
{"code": "for (x = 0; x < size; x++)\n{\n  for (y = 0; y < size; y++)\n  {\n    while (cube[x][y] != 0)\n    {\n      aux = cube[x][y];\n      cube[x][y] = cube[x][y]->next;\n      free(aux);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dbsousa01/Game-of-Life3D/life3d-omp/3"}
{"code": "for (long i = 0; i < (2 * NE); i++)\n{\n  long head = tmpEdgeList[i].head;\n  long tail = tmpEdgeList[i].tail;\n  double weight = tmpEdgeList[i].weight;\n  long Where = edgeListPtr[head] + __sync_fetch_and_add(&added[head], 1);\n  edgeList[Where].head = head;\n  edgeList[Where].tail = tail;\n  edgeList[Where].weight = weight;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Exa-Graph/grappolo/InputsOutput/loadEdgeList/12"}
{"code": "for (j = 0; j < numprocs; j++)\n  printOutput(oArr[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/basicFunctions/3"}
{"code": "for (t = 0; t < n; t++)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  index = t;\n  {\n    int i;\n    memcpy(BF_current.S, BF_init_state.S, sizeof(BF_current.S));\n    memcpy(BF_current.P, BF_init_key, sizeof(BF_current.P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_current.P[i] = L0;\n      BF_current.P[i + 1] = R0;\n    }\n\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n  }\n  count = 1 << salt->rounds;\n  do\n  {\n    index = t;\n    {\n      BF_current.P[0] ^= BF_exp_key[0];\n      BF_current.P[1] ^= BF_exp_key[1];\n      BF_current.P[2] ^= BF_exp_key[2];\n      BF_current.P[3] ^= BF_exp_key[3];\n      BF_current.P[4] ^= BF_exp_key[4];\n      BF_current.P[5] ^= BF_exp_key[5];\n      BF_current.P[6] ^= BF_exp_key[6];\n      BF_current.P[7] ^= BF_exp_key[7];\n      BF_current.P[8] ^= BF_exp_key[8];\n      BF_current.P[9] ^= BF_exp_key[9];\n      BF_current.P[10] ^= BF_exp_key[10];\n      BF_current.P[11] ^= BF_exp_key[11];\n      BF_current.P[12] ^= BF_exp_key[12];\n      BF_current.P[13] ^= BF_exp_key[13];\n      BF_current.P[14] ^= BF_exp_key[14];\n      BF_current.P[15] ^= BF_exp_key[15];\n      BF_current.P[16] ^= BF_exp_key[16];\n      BF_current.P[17] ^= BF_exp_key[17];\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    index = t;\n    {\n      BF_current.P[0] ^= u1;\n      BF_current.P[1] ^= u2;\n      BF_current.P[2] ^= u3;\n      BF_current.P[3] ^= u4;\n      BF_current.P[4] ^= u1;\n      BF_current.P[5] ^= u2;\n      BF_current.P[6] ^= u3;\n      BF_current.P[7] ^= u4;\n      BF_current.P[8] ^= u1;\n      BF_current.P[9] ^= u2;\n      BF_current.P[10] ^= u3;\n      BF_current.P[11] ^= u4;\n      BF_current.P[12] ^= u1;\n      BF_current.P[13] ^= u2;\n      BF_current.P[14] ^= u3;\n      BF_current.P[15] ^= u4;\n      BF_current.P[16] ^= u1;\n      BF_current.P[17] ^= u2;\n    }\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  index = t;\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current.P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/3"}
{"code": "for (i = 0; i < height; i++)\n{\n  for (j = 0; j < width; j++)\n  {\n    int row;\n    int col;\n    double redSum = 0;\n    double greenSum = 0;\n    double blueSum = 0;\n    double weightSum = 0;\n    for (row = i - radius; row <= (i + radius); row++)\n    {\n      for (col = j - radius; col <= (j + radius); col++)\n      {\n        int x = setBoundary(col, 0, width - 1);\n        int y = setBoundary(row, 0, height - 1);\n        int tempPos = (y * width) + x;\n        double square = ((col - j) * (col - j)) + ((row - i) * (row - i));\n        double sigma = radius * radius;\n        double weight = exp((-square) / (2 * sigma)) / ((3.14 * 2) * sigma);\n        redSum += red[tempPos] * weight;\n        greenSum += green[tempPos] * weight;\n        blueSum += blue[tempPos] * weight;\n        weightSum += weight;\n      }\n\n    }\n\n    red[(i * width) + j] = round(redSum / weightSum);\n    green[(i * width) + j] = round(greenSum / weightSum);\n    blue[(i * width) + j] = round(blueSum / weightSum);\n    redSum = 0;\n    greenSum = 0;\n    blueSum = 0;\n    weightSum = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(static,100) private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/manogna-mujje/Image-Processing/OpenMP/openmp/0"}
{"code": "for (i = 0; i < 100; i++)\n{\n  iterative_cluster_count_global[i] = (int *) calloc(K, sizeof(int));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Rohnie/Parallelization-of-K-means-Clustering-model-for-chest-X-Ray-images-using-CUDA-and-OpenMP./XRay_omp/8"}
{"code": "for (i = 0; i < 10; ++i)\n{\n  x >>= 1;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/cvalidationsuite/omp_atomic/10"}
{"code": "for (k = y_min; k <= (y_max + 1); k++)\n{\n  #pragma ivdep\n  for (j = x_min; j <= (x_max + 1); j++)\n  {\n    xvel1[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] = xvel0[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] - (stepbymass[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * ((xarea[FTNREF2D(j, k, x_max + 5, x_min - 2, y_min - 2)] * (pressure[FTNREF2D(j, k, x_max + 4, x_min - 2, y_min - 2)] - pressure[FTNREF2D(j - 1, k, x_max + 4, x_min - 2, y_min - 2)])) + (xarea[FTNREF2D(j, k - 1, x_max + 5, x_min - 2, y_min - 2)] * (pressure[FTNREF2D(j, k - 1, x_max + 4, x_min - 2, y_min - 2)] - pressure[FTNREF2D(j - 1, k - 1, x_max + 4, x_min - 2, y_min - 2)]))));\n  }\n\n}\n\n", "pragma": "omp for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/CloverLeaf_OpenMP4/accelerate_kernel_c/1"}
{"code": "for (int i = 0; i < TOTAL_ROW; i++)\n{\n  int x = row_data[i].size();\n  for (int j = 0; j < x; j++)\n  {\n    itr = row_data[i][j];\n    *p = i;\n    fwrite(p, 4, 1, write_output);\n    *p = itr.x;\n    fwrite(p, 4, 1, write_output);\n    fwrite(itr.y, 1, 8, write_output);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 4/sort2d/20"}
{"code": "for (int i = length - 2; i >= 0; i--)\n{\n  seq[i] = prevs[i][seq[i + 1]];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/21"}
{"code": "for (int i = 0; i < 5; i++)\n  omp_destroy_lock(&hist_locks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/olia92/OpenMP_Mattson/Histogram/histogram_omp/2"}
{"code": "for (int i = (14 * n) / 16; i < ((15 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/22"}
{"code": "for (MCUIdx = 0; MCUIdx < (numMCUs - 1); ++MCUIdx)\n{\n  assert((MCUIdx + 1) <= numMCUs);\n  array < MCUTy, 2 > MCUs;\n  for (size_t SubMCUIdx = 0; SubMCUIdx < MCUs.size(); ++SubMCUIdx)\n    MCUs[SubMCUIdx] = LoadMCU(MCUIdx + SubMCUIdx);\n\n  MCUs[0][0].process(hue);\n  MCUs[1][0].process(hue);\n  MCUs[0][1].interpolateCbCr(MCUs[0][0], MCUs[1][0]);\n  StoreMCU(MCUs[0], MCUIdx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/interpolators/Cr2sRawInterpolator/2"}
{"code": "for (unsigned f = 0; f < coupled_images_creation_locks.size(); ++f)\n  omp_destroy_lock(&coupled_images_creation_locks[f]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/CPBridge/RIFeatures/src/RIFeatExtractor/8"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    uijk = us[i][j][k];\n    up1 = us[i + 1][j][k];\n    um1 = us[i - 1][j][k];\n    rhs[0][i][j][k] = (rhs[0][i][j][k] + (dx1tx1 * ((u[0][i + 1][j][k] - (2.0 * u[0][i][j][k])) + u[0][i - 1][j][k]))) - (tx2 * (u[1][i + 1][j][k] - u[1][i - 1][j][k]));\n    rhs[1][i][j][k] = ((rhs[1][i][j][k] + (dx2tx1 * ((u[1][i + 1][j][k] - (2.0 * u[1][i][j][k])) + u[1][i - 1][j][k]))) + ((xxcon2 * con43) * ((up1 - (2.0 * uijk)) + um1))) - (tx2 * (((u[1][i + 1][j][k] * up1) - (u[1][i - 1][j][k] * um1)) + ((((u[4][i + 1][j][k] - square[i + 1][j][k]) - u[4][i - 1][j][k]) + square[i - 1][j][k]) * c2)));\n    rhs[2][i][j][k] = ((rhs[2][i][j][k] + (dx3tx1 * ((u[2][i + 1][j][k] - (2.0 * u[2][i][j][k])) + u[2][i - 1][j][k]))) + (xxcon2 * ((vs[i + 1][j][k] - (2.0 * vs[i][j][k])) + vs[i - 1][j][k]))) - (tx2 * ((u[2][i + 1][j][k] * up1) - (u[2][i - 1][j][k] * um1)));\n    rhs[3][i][j][k] = ((rhs[3][i][j][k] + (dx4tx1 * ((u[3][i + 1][j][k] - (2.0 * u[3][i][j][k])) + u[3][i - 1][j][k]))) + (xxcon2 * ((ws[i + 1][j][k] - (2.0 * ws[i][j][k])) + ws[i - 1][j][k]))) - (tx2 * ((u[3][i + 1][j][k] * up1) - (u[3][i - 1][j][k] * um1)));\n    rhs[4][i][j][k] = ((((rhs[4][i][j][k] + (dx5tx1 * ((u[4][i + 1][j][k] - (2.0 * u[4][i][j][k])) + u[4][i - 1][j][k]))) + (xxcon3 * ((qs[i + 1][j][k] - (2.0 * qs[i][j][k])) + qs[i - 1][j][k]))) + (xxcon4 * (((up1 * up1) - ((2.0 * uijk) * uijk)) + (um1 * um1)))) + (xxcon5 * (((u[4][i + 1][j][k] * rho_i[i + 1][j][k]) - ((2.0 * u[4][i][j][k]) * rho_i[i][j][k])) + (u[4][i - 1][j][k] * rho_i[i - 1][j][k])))) - (tx2 * ((((c1 * u[4][i + 1][j][k]) - (c2 * square[i + 1][j][k])) * up1) - (((c1 * u[4][i - 1][j][k]) - (c2 * square[i - 1][j][k])) * um1)));\n  }\n\n}\n\n", "pragma": "omp parallel for private(uijk, up1, um1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/49"}
{"code": "for (i = 0; i < num_line; i++)\n{\n  for (j = 0; j < 3000; j++)\n  {\n    printf(\" %d\", resultMatrix[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mandebi/Sobel-Edge-Detection-MPI-OpenMP/part2/sobel2/13"}
{"code": "for (i = start; i < (size + 1); i++)\n{\n  if (comparator(arr[insert], arr[i]) < 0)\n  {\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artalukd/ParallelEdgeReverse/reverse/3"}
{"code": "for (int i = 0; i < dim; i++)\n{\n  for (int j = 0; j < dim; j++)\n  {\n    vectorA[(i * dim) + j] = A[i][j];\n    vectorB[(j * dim) + i] = B[i][j];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshan14/matrix-multiplication-openMP/MatrixMultiplication/0"}
{"code": "for (; i < size_; i += BYN, p1 += BYN, p2 += BYN)\n  sum += vector_dot_product_pointer16_avx512(p1, p2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sdpython/cpyquickhelper/cpyquickhelper/numbers/cbenchmark_dot/7"}
{"code": "for (m = 0; m < 1000; ++m)\n  switch (p[m])\n{\n  case 1:\n    p[m] = 2;\n    break;\n\n  default:\n    p[m] = 3;\n    break;\n\n}\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/block-11/0"}
{"code": "for (unsigned int i = 0; i < no_of_nodes; i++)\n{\n  fscanf(fp, \"%d %d\", &start, &edgeno);\n  s[i] = start;\n  e[i] = edgeno;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ruixueqingyang/OAO-Translator/benchmarks/Rodina/openmp/bfs/bfs_test/0"}
{"code": "for (int i = 2; i < (GRAIN + 1); i += 2)\n  for (int j = 2; j < (GRAIN + 1); j += 2)\n{\n  if (!tab_unstable[(i * (GRAIN + 2)) + j])\n  {\n    if (((tab_unstable[((i - 1) * (GRAIN + 2)) + j] || tab_unstable[((i + 1) * (GRAIN + 2)) + j]) || tab_unstable[(i * (GRAIN + 2)) + (j - 1)]) || tab_unstable[(i * (GRAIN + 2)) + (j + 1)])\n      tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_stable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n\n  }\n  else\n  {\n    tab_unstable[(i * (GRAIN + 2)) + j] = do_tile_unstable(((j - 1) * TILE_SIZE) + ((j - 1) == 0), ((i - 1) * TILE_SIZE) + ((i - 1) == 0), TILE_SIZE - (((((j - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((j - 1) == 0)), TILE_SIZE - (((((i - 1) * TILE_SIZE) + TILE_SIZE) == DIM) + ((i - 1) == 0)), omp_get_thread_num());\n    changement += tab_unstable[(i * (GRAIN + 2)) + j];\n  }\n\n}\n\n\n", "pragma": "omp for collapse(2) reduction(+:changement)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/9"}
{"code": "for (long i = 0; i < n; i++)\n{\n  arr[i] = (int) rand();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/turfaa/bitonic-sort-openmp/src/bitonic_sort/2"}
{"code": "for (int f = half + i; f < length; f = f + half)\n{\n  j = f;\n  while ((j > i) && (arr[j - half] > arr[j]))\n  {\n    temp = arr[j];\n    arr[j] = arr[j - half];\n    arr[j - half] = temp;\n    j = j - half;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Matt-st/Parallel_shell_sort/ShellOpenMP/4"}
{"code": "for (i = 0; i < CELLS[id].n; i++)\n{\n  nn = starts(id, i, NWS, CELLS);\n  nnl += nn;\n  for (j = 0; j < nn; j++)\n  {\n    _taskFunc0_((void *) 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Kingtous/Bots_Task_Result/floorplan/src/floorplan_ompi_trim/0"}
{"code": "for (int ix = 0; ix < A_height; ++ix)\n{\n  for (int iy = 0; iy < B_height; ++iy)\n  {\n    for (int i = 0; i < A_width; ++i)\n    {\n      C[ix][iy] += A[ix][i] * B[iy][i];\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(THREADS) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/I-Iaroslav/MIPT_Programs/Parallel_2/Matrix_multiply/0"}
{"code": "for (int i = 0; i < MAX_N; ++i)\n{\n  local += A[i];\n  printf(\"Thread %d processed A[%d]\\n\", omp_get_thread_num(), i);\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/abelidze/cluster-parallel/task02.14.03.2019/task/2"}
{"code": "for (int n = 0; n < NUMTRIALS; n++)\n{\n  float xc = xcs[n];\n  float yc = ycs[n];\n  float r = rs[n];\n  float a = 1. + (tn * tn);\n  float b = (-2.) * (xc + (yc * tn));\n  float c = ((xc * xc) + (yc * yc)) - (r * r);\n  float d = (b * b) - ((4. * a) * c);\n  if (d >= 0.)\n  {\n    d = sqrt(d);\n    float t1 = ((-b) + d) / (2. * a);\n    float t2 = ((-b) - d) / (2. * a);\n    float tmin = (t1 < t2) ? (t1) : (t2);\n    if (tmin >= 0.)\n    {\n      float xcir = tmin;\n      float ycir = tmin * tn;\n      float nx = xcir - xc;\n      float ny = ycir - yc;\n      float nxy = sqrt((nx * nx) + (ny * ny));\n      nx /= nxy;\n      ny /= nxy;\n      float inx = xcir - 0.;\n      float iny = ycir - 0.;\n      float in = sqrt((inx * inx) + (iny * iny));\n      inx /= in;\n      iny /= in;\n      float dot = (inx * nx) + (iny * ny);\n      float outx = inx - ((2. * nx) * dot);\n      float outy = iny - ((2. * ny) * dot);\n      float tt = (0. - ycir) / outy;\n      if (tt >= 0.)\n      {\n        numHits++;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for default(none) shared(xcs, ycs, rs, tn) reduction(+:numHits)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sd-owens/Parallel/p1_monteCarlo/monteCarlo/0"}
{"code": "for (;;)\n{\n  for (l = en; l > low; l--)\n    if (((h[l][l - 1] >= 0.) ? (h[l][l - 1]) : (-h[l][l - 1])) <= (DBL_EPSILON * (((h[l - 1][l - 1] >= 0.) ? (h[l - 1][l - 1]) : (-h[l - 1][l - 1])) + ((h[l][l] >= 0.) ? (h[l][l]) : (-h[l][l])))))\n    break;\n\n\n  x = h[en][en];\n  if (l == en)\n  {\n    wr[en] = (h[en][en] = x + t);\n    wi[en] = 0.;\n    cnt[en] = iter;\n    en--;\n    break;\n  }\n\n  y = h[na][na];\n  w = h[en][na] * h[na][en];\n  if (l == na)\n  {\n    p = (y - x) * 0.5;\n    q = (p * p) + w;\n    z = sqrt((q >= 0.) ? (q) : (-q));\n    x = (h[en][en] = x + t);\n    h[na][na] = y + t;\n    cnt[en] = -iter;\n    cnt[na] = iter;\n    if (q >= 0.)\n    {\n      z = (p < 0.) ? (p - z) : (p + z);\n      wr[na] = x + z;\n      wr[en] = (s = x - (w / z));\n      wi[na] = (wi[en] = 0.);\n      x = h[en][na];\n      r = sqrt((x * x) + (z * z));\n      if (vec)\n      {\n        p = x / r;\n        q = z / r;\n        for (j = na; j < n; j++)\n        {\n          z = h[na][j];\n          h[na][j] = (q * z) + (p * h[en][j]);\n          h[en][j] = (q * h[en][j]) - (p * z);\n        }\n\n        for (i = 0; i <= en; i++)\n        {\n          z = h[i][na];\n          h[i][na] = (q * z) + (p * h[i][en]);\n          h[i][en] = (q * h[i][en]) - (p * z);\n        }\n\n        for (i = low; i <= high; i++)\n        {\n          z = eivec[i][na];\n          eivec[i][na] = (q * z) + (p * eivec[i][en]);\n          eivec[i][en] = (q * eivec[i][en]) - (p * z);\n        }\n\n      }\n\n    }\n    else\n    {\n      wr[na] = (wr[en] = x + p);\n      wi[na] = z;\n      wi[en] = -z;\n    }\n\n    en -= 2;\n    break;\n  }\n\n  if (iter >= 50)\n  {\n    cnt[en] = 50 + 1;\n    return en;\n  }\n\n  if ((iter != 0) && ((iter % 10) == 0))\n  {\n    t += x;\n    for (i = low; i <= en; i++)\n      h[i][i] -= x;\n\n    s = ((h[en][na] >= 0.) ? (h[en][na]) : (-h[en][na])) + ((h[na][en - 2] >= 0.) ? (h[na][en - 2]) : (-h[na][en - 2]));\n    x = (y = ((double) 0.75) * s);\n    w = ((-((double) 0.4375)) * s) * s;\n  }\n\n  iter++;\n  for (m = en - 2; m >= l; m--)\n  {\n    z = h[m][m];\n    r = x - z;\n    s = y - z;\n    p = (((r * s) - w) / h[m + 1][m]) + h[m][m + 1];\n    q = ((h[m + 1][m + 1] - z) - r) - s;\n    r = h[m + 2][m + 1];\n    s = (((p >= 0.) ? (p) : (-p)) + ((q >= 0.) ? (q) : (-q))) + ((r >= 0.) ? (r) : (-r));\n    p /= s;\n    q /= s;\n    r /= s;\n    if (m == l)\n      break;\n\n    if ((((h[m][m - 1] >= 0.) ? (h[m][m - 1]) : (-h[m][m - 1])) * (((q >= 0.) ? (q) : (-q)) + ((r >= 0.) ? (r) : (-r)))) <= ((DBL_EPSILON * ((p >= 0.) ? (p) : (-p))) * ((((h[m - 1][m - 1] >= 0.) ? (h[m - 1][m - 1]) : (-h[m - 1][m - 1])) + ((z >= 0.) ? (z) : (-z))) + ((h[m + 1][m + 1] >= 0.) ? (h[m + 1][m + 1]) : (-h[m + 1][m + 1])))))\n      break;\n\n  }\n\n  for (i = m + 2; i <= en; i++)\n    h[i][i - 2] = 0.;\n\n  for (i = m + 3; i <= en; i++)\n    h[i][i - 3] = 0.;\n\n  for (k = m; k <= na; k++)\n  {\n    if (k != m)\n    {\n      p = h[k][k - 1];\n      q = h[k + 1][k - 1];\n      r = (k != na) ? (h[k + 2][k - 1]) : (0.);\n      x = (((p >= 0.) ? (p) : (-p)) + ((q >= 0.) ? (q) : (-q))) + ((r >= 0.) ? (r) : (-r));\n      if (x == 0.)\n        continue;\n\n      p /= x;\n      q /= x;\n      r /= x;\n    }\n\n    s = sqrt(((p * p) + (q * q)) + (r * r));\n    if (p < 0.)\n      s = -s;\n\n    if (k != m)\n      h[k][k - 1] = (-s) * x;\n    else\n      if (l != m)\n      h[k][k - 1] = -h[k][k - 1];\n\n\n    p += s;\n    x = p / s;\n    y = q / s;\n    z = r / s;\n    q /= p;\n    r /= p;\n    for (j = k; j < n; j++)\n    {\n      p = h[k][j] + (q * h[k + 1][j]);\n      if (k != na)\n      {\n        p += r * h[k + 2][j];\n        h[k + 2][j] -= p * z;\n      }\n\n      h[k + 1][j] -= p * y;\n      h[k][j] -= p * x;\n    }\n\n    j = ((k + 3) < en) ? (k + 3) : (en);\n    for (i = 0; i <= j; i++)\n    {\n      p = (x * h[i][k]) + (y * h[i][k + 1]);\n      if (k != na)\n      {\n        p += z * h[i][k + 2];\n        h[i][k + 2] -= p * r;\n      }\n\n      h[i][k + 1] -= p * q;\n      h[i][k] -= p;\n    }\n\n    if (vec)\n    {\n      for (i = low; i <= high; i++)\n      {\n        p = (x * eivec[i][k]) + (y * eivec[i][k + 1]);\n        if (k != na)\n        {\n          p += z * eivec[i][k + 2];\n          eivec[i][k + 2] -= p * r;\n        }\n\n        eivec[i][k + 1] -= p * q;\n        eivec[i][k] -= p;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sreyansb/LinearAlgebraOpenMPcodes/eigen/22"}
{"code": "for (i = 0; i < n; i++)\n  for (j = 0; j < n; j++)\n  mat2[i][j] = mat1[j][i];\n\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rohit-gupta3/Parallel_and_DistributiveComputing-PDC-/Matrix_Operations/Transpose_Matrix_OpenMp/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  output[i] = local_array[i];\n}\n\n", "pragma": "omp parallel for firstprivate(n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/rendermodule/0"}
{"code": "for (i = 0; i < 7; i++)\n{\n  printf(\"Run %d \\n\", i);\n  updateMultipleArrayPerIteration(G, i);\n  sleep(2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jkrishnavs/OpenMPGraphAlgorithms/src/train2/1"}
{"code": "for (i = 0; i < rows; i++)\n  avg += mat[(i * columns) + j];\n\n", "pragma": "omp parallel for reduction(+:avg)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AdoniasAlcantara/project4-omp/src/parallel/10"}
{"code": "for (size_t i = 0; i < size_N; ++i)\n{\n  fprintf(output, \"%f\", result_n_p_AVX[i]);\n  if (abs(result_n_p[i] - result_n_p_AVX[i]) < 0.1)\n    fprintf(output, \" Ok \");\n  else\n    fprintf(output, \" Err \");\n\n  fprintf(output, \"%f \\n\", result_n_p[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ArtTikidji/Study_openMP_AVX/main/7"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  a[i] = 10. / (i + 1.);\n  b[i] = (i + 1.) / 10.;\n}\n\n", "pragma": "omp parallel for num_threads(size) shared(a,b)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/wwJinkla/Parallel-Computing/lectures/openmp/dot_omp/0"}
{"code": "for (int i = 0; i < (ifog.size() / 4); ++i)\n{\n  for (int j = 0; j < ifog[0].size(); ++j)\n  {\n    g_t[i][j] = ifog[i + (3 * (ifog.size() / 4))][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shubodh/Optimizing-LSTMs-on-GPU/LSTM_opti_1/5"}
{"code": "for (int i = 0; i < flux_out_len; ++i)\n{\n  flux_out[i] = 0.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/6"}
{"code": "for (v = 0; v < stats->num_vertices; v++)\n{\n  rankedVertices_inverse[stats->realRanks[v]] = v;\n  ref_rankedVertices_inverse[ref_stats->realRanks[v]] = v;\n  ref_rankedVertices_total[v] = ref_stats->realRanks[v];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/16"}
{"code": "for (int i = (6 * n) / 16; i < ((7 * n) / 16); i++)\n{\n  U[i][i] = 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/kode/14"}
{"code": "for (i = 0; i < state->nMoves; ++i)\n{\n  values[i] = MiniMax_Recursive(state, state->moves + i, -2147483648, 2147483647, depth);\n  GUI_ManageEvents(gui);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/luigifusco/CChess/minimax/0"}
{"code": "for (i_imopVar79 = 1; i_imopVar79 < (grid_points[0] - 1); i_imopVar79++)\n{\n  xi_imopVar75 = ((double) i_imopVar79) * dnxm1;\n  for (k_imopVar81 = 1; k_imopVar81 < (grid_points[2] - 1); k_imopVar81++)\n  {\n    zeta_imopVar77 = ((double) k_imopVar81) * dnzm1;\n    for (j_imopVar80 = 0; j_imopVar80 < grid_points[1]; j_imopVar80++)\n    {\n      eta_imopVar76 = ((double) j_imopVar80) * dnym1;\n      exact_solution(xi_imopVar75, eta_imopVar76, zeta_imopVar77, dtemp);\n      for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n      {\n        ue[j_imopVar80][m_imopVar78] = dtemp[m_imopVar78];\n      }\n\n      dtpp = 1.0 / dtemp[0];\n      for (m_imopVar78 = 1; m_imopVar78 <= 4; m_imopVar78++)\n      {\n        buf[j_imopVar80][m_imopVar78] = dtpp * dtemp[m_imopVar78];\n      }\n\n      cuf[j_imopVar80] = buf[j_imopVar80][2] * buf[j_imopVar80][2];\n      buf[j_imopVar80][0] = (cuf[j_imopVar80] + (buf[j_imopVar80][1] * buf[j_imopVar80][1])) + (buf[j_imopVar80][3] * buf[j_imopVar80][3]);\n      q[j_imopVar80] = 0.5 * (((buf[j_imopVar80][1] * ue[j_imopVar80][1]) + (buf[j_imopVar80][2] * ue[j_imopVar80][2])) + (buf[j_imopVar80][3] * ue[j_imopVar80][3]));\n    }\n\n    for (j_imopVar80 = 1; j_imopVar80 < (grid_points[1] - 1); j_imopVar80++)\n    {\n      jm1 = j_imopVar80 - 1;\n      jp1 = j_imopVar80 + 1;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][0] = (forcing[i_imopVar79][j_imopVar80][k_imopVar81][0] - (ty2 * (ue[jp1][2] - ue[jm1][2]))) + (dy1ty1 * ((ue[jp1][0] - (2.0 * ue[j_imopVar80][0])) + ue[jm1][0]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][1] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][1] - (ty2 * ((ue[jp1][1] * buf[jp1][2]) - (ue[jm1][1] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][1] - (2.0 * buf[j_imopVar80][1])) + buf[jm1][1]))) + (dy2ty1 * ((ue[jp1][1] - (2.0 * ue[j_imopVar80][1])) + ue[jm1][1]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][2] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][2] - (ty2 * (((ue[jp1][2] * buf[jp1][2]) + (c2 * (ue[jp1][4] - q[jp1]))) - ((ue[jm1][2] * buf[jm1][2]) + (c2 * (ue[jm1][4] - q[jm1])))))) + (yycon1 * ((buf[jp1][2] - (2.0 * buf[j_imopVar80][2])) + buf[jm1][2]))) + (dy3ty1 * ((ue[jp1][2] - (2.0 * ue[j_imopVar80][2])) + ue[jm1][2]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][3] = ((forcing[i_imopVar79][j_imopVar80][k_imopVar81][3] - (ty2 * ((ue[jp1][3] * buf[jp1][2]) - (ue[jm1][3] * buf[jm1][2])))) + (yycon2 * ((buf[jp1][3] - (2.0 * buf[j_imopVar80][3])) + buf[jm1][3]))) + (dy4ty1 * ((ue[jp1][3] - (2.0 * ue[j_imopVar80][3])) + ue[jm1][3]));\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][4] = ((((forcing[i_imopVar79][j_imopVar80][k_imopVar81][4] - (ty2 * ((buf[jp1][2] * ((c1 * ue[jp1][4]) - (c2 * q[jp1]))) - (buf[jm1][2] * ((c1 * ue[jm1][4]) - (c2 * q[jm1])))))) + ((0.5 * yycon3) * ((buf[jp1][0] - (2.0 * buf[j_imopVar80][0])) + buf[jm1][0]))) + (yycon4 * ((cuf[jp1] - (2.0 * cuf[j_imopVar80])) + cuf[jm1]))) + (yycon5 * ((buf[jp1][4] - (2.0 * buf[j_imopVar80][4])) + buf[jm1][4]))) + (dy5ty1 * ((ue[jp1][4] - (2.0 * ue[j_imopVar80][4])) + ue[jm1][4]));\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      j_imopVar80 = 1;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((5.0 * ue[j_imopVar80][m_imopVar78]) - (4.0 * ue[j_imopVar80 + 1][m_imopVar78])) + ue[j_imopVar80 + 2][m_imopVar78]));\n      j_imopVar80 = 2;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((((-4.0) * ue[j_imopVar80 - 1][m_imopVar78]) + (6.0 * ue[j_imopVar80][m_imopVar78])) - (4.0 * ue[j_imopVar80 + 1][m_imopVar78])) + ue[j_imopVar80 + 2][m_imopVar78]));\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      for (j_imopVar80 = 1 * 3; j_imopVar80 <= ((grid_points[1] - (3 * 1)) - 1); j_imopVar80++)\n      {\n        forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * ((((ue[j_imopVar80 - 2][m_imopVar78] - (4.0 * ue[j_imopVar80 - 1][m_imopVar78])) + (6.0 * ue[j_imopVar80][m_imopVar78])) - (4.0 * ue[j_imopVar80 + 1][m_imopVar78])) + ue[j_imopVar80 + 2][m_imopVar78]));\n      }\n\n    }\n\n    for (m_imopVar78 = 0; m_imopVar78 < 5; m_imopVar78++)\n    {\n      j_imopVar80 = grid_points[1] - 3;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * (((ue[j_imopVar80 - 2][m_imopVar78] - (4.0 * ue[j_imopVar80 - 1][m_imopVar78])) + (6.0 * ue[j_imopVar80][m_imopVar78])) - (4.0 * ue[j_imopVar80 + 1][m_imopVar78])));\n      j_imopVar80 = grid_points[1] - 2;\n      forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] = forcing[i_imopVar79][j_imopVar80][k_imopVar81][m_imopVar78] - (dssp * ((ue[j_imopVar80 - 2][m_imopVar78] - (4.0 * ue[j_imopVar80 - 1][m_imopVar78])) + (5.0 * ue[j_imopVar80][m_imopVar78])));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/4"}
{"code": "for (i = 0; i < buckets; i++)\n{\n  for (j = 0; j < P; j++)\n  {\n    t = buckets_count[(j * buckets) + i];\n    buckets_count[(j * buckets) + i] = base;\n    base += t;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/preprocess/reorder/14"}
{"code": "for (int i = 0; i < Added.size(); i++)\n  DiffOcc[Added[i] - 1] += 1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCWaveFunctions/EinsplineSetBuilderESHDF.fft/8"}
{"code": "for (i = 0; i < 12; i++)\n{\n  id = omp_get_thread_num();\n  a[i] = i;\n  printf(\"a[%d] is %d from thread: %d\\n\", i, a[i], id);\n}\n\n", "pragma": "omp parallel for private(i,id) shared(a)schedule(dynamic,2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darkxaze/HPC_coursecodes/testcodes_omp/scheduleparallelfor/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  v[i][j][k][m] = v[i][j][k][m] - (omega * (((((ldz[i][j][m][0] * v[i][j][k - 1][0]) + (ldz[i][j][m][1] * v[i][j][k - 1][1])) + (ldz[i][j][m][2] * v[i][j][k - 1][2])) + (ldz[i][j][m][3] * v[i][j][k - 1][3])) + (ldz[i][j][m][4] * v[i][j][k - 1][4])));\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,ist ,j ,m ,ldz ,k ,v ,omega ,jst ,jend ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/2"}
{"code": "for (int i = 0; i < (A_size / 2); ++i)\n{\n  copy(A[i], A[i] + next_size, A_11[i]);\n  copy(A[i] + next_size, A[i] + A_size, A_12[i]);\n  copy(A[i + next_size], A[i + next_size] + next_size, A_21[i]);\n  copy(A[i + next_size] + next_size, A[i + next_size] + A_size, A_22[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/I-Iaroslav/MIPT_Programs/Parallel_2/Strassen/1"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  velocity[i].x = (velocity[i].y = (velocity[i].z = 0));\n}\n\n", "pragma": "omp for private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/namanjain0501/openmp_trajectory/code/0"}
{"code": "for (i = lower; i > upper; i -= stride)\n{\n  printf(\"Iteration %2d is carried out by thread %2d\\n\", i, omp_get_thread_num());\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/tests/CompileTests/OpenMP_tests/ompfor-decremental/0"}
{"code": "for (size_t space_point = 0; space_point < mesh->space_points; ++space_point)\n{\n  fprintf(output, format, mesh_Get(mesh, time_point, space_point));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/0x414c/Openmp-example/sources/main/2"}
{"code": "for (int s = 0; s < nb_system; s++)\n{\n  for (int i = 0; i < systems[s].system_size; i++)\n    if ((!isEqual(systems[s].validation_matrix[i], systems[s].variable_value_prev_t[i])) && (!isnan(systems[s].variable_value_prev_t[i])))\n  {\n    system_is_valid = false;\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/piotrfratczak/TD-OpenMP/exo_1.2/multiple_system_solver/4"}
{"code": "for (int i = 0; i < 20000; i++)\n  array[i] = 2.3;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abdussametkaci/Parallel_Programming/Lecture15/hybrid_mean/1"}
{"code": "for (i = 0; i < (length - 1); i++)\n{\n  if (((array[i] > array[i + 1]) && (array[i + 1] != (-1))) || ((array[i] == (-1)) && (array[i + 1] != (-1))))\n  {\n    changed = 1;\n    temp = array[i];\n    array[i] = array[i + 1];\n    array[i + 1] = temp;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/B/ass2-openmp/11"}
{"code": "for (int j = 0; j < n; j++)\n{\n  for (int k = 0; k < n; k++)\n  {\n    for (int i = 0; i < n; i++)\n    {\n      mat_3[i][j] = mat_3[i][j] + (mat_1[i][k] * mat_2[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(numThreads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/umnov-yu-an/parallel-algorithms/Assignment2/4"}
{"code": "for (int i = 0; i < N; i++)\n  b[i] = b[i] / sum;\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture6/Single_construct/Single_construct/2"}
{"code": "for (int i = 0; i < h; ++i)\n{\n  memset(&data.canva[((data.width * data.bpp) * (i + y)) + (x * data.bpp)], 0, (sizeof(unsigned char)) * w);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/DataProviders/Images/2"}
{"code": "for (index = 0; index < count; index++)\n  if ((*((uint32_t *) binary)) == (*((uint32_t *) crypt_out[index])))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/SybaseASE_fmt_plug/4"}
{"code": "for (int i = 1; i < (SIZE_X - 1); i++)\n{\n  int iUp;\n  int iDown;\n  int jLeft;\n  int jRight;\n  int nIndex = 0;\n  for (int j = 0; j < SIZE_Y; j++)\n  {\n    if (NULL == MeshA[i][j])\n      continue;\n\n    MeshA[i][j]->Grow();\n    MeshA[i][j]->ChangeToZombie();\n    iUp = ((i - 1) + SIZE_X) % SIZE_X;\n    iDown = ((i + 1) + SIZE_X) % SIZE_X;\n    jLeft = ((j - 1) + SIZE_Y) % SIZE_Y;\n    jRight = ((j + 1) + SIZE_Y) % SIZE_Y;\n    double move = mtRand[nIndex].randExc();\n    if (((move < (1.0 * MOVE)) && (NULL == MeshA[iUp][j])) && (NULL == MeshB[iUp][j]))\n    {\n      MeshB[iUp][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (2.0 * MOVE)) && (NULL == MeshA[iDown][j])) && (NULL == MeshB[iDown][j]))\n    {\n      MeshB[iDown][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (3.0 * MOVE)) && (NULL == MeshA[i][jLeft])) && (NULL == MeshB[i][jLeft]))\n    {\n      MeshB[i][jLeft] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n      if (((move < (4.0 * MOVE)) && (NULL == MeshA[i][jRight])) && (NULL == MeshB[i][jRight]))\n    {\n      MeshB[i][jRight] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n    else\n    {\n      MeshB[i][j] = MeshA[i][j];\n      MeshA[i][j] = NULL;\n    }\n\n\n\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(MeshA, MeshB, mtRand)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/BigWEric/Zombie-Apocalypse-Simulation-MPI-OPENMP-/NorthTerritory/3"}
{"code": "for (int y = 0; y < ny; y++)\n{\n  for (int x = 0; x < nx; x++)\n  {\n    int this_offset = POINT_OFFSET(x, y, dimx, radius);\n    TYPE temp = (2.0f * curr[this_offset]) - next[this_offset];\n    TYPE div = c_coeff[0] * curr[this_offset];\n    for (int d = 1; d <= radius; d++)\n    {\n      int y_pos_offset = POINT_OFFSET(x, y + d, dimx, radius);\n      int y_neg_offset = POINT_OFFSET(x, y - d, dimx, radius);\n      int x_pos_offset = POINT_OFFSET(x + d, y, dimx, radius);\n      int x_neg_offset = POINT_OFFSET(x - d, y, dimx, radius);\n      div += c_coeff[d] * (((curr[y_pos_offset] + curr[y_neg_offset]) + curr[x_pos_offset]) + curr[x_neg_offset]);\n    }\n\n    next[this_offset] = temp + (div * vsq[this_offset]);\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ijpq/15418/utils/opencv/CodeSamples/lectures_code/iso/src/iso2d/0"}
{"code": "for (int col = 0; col <= col_len; col++)\n{\n  float update = s_lr * ((data[col] * Y) + (lambda * model_weights[col]));\n  omp_set_lock(&weightlock[col]);\n  model_weights[col] += update;\n  omp_unset_lock(&weightlock[col]);\n}\n\n", "pragma": "                #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/L1FE0FJ4Y/Parallel_Ensemble_Classifier/svm/2"}
{"code": "for (int i = 0; i < size; i++)\n{\n  cin >> tmp;\n  a.push_back(tmp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leonshting/mipt-openmp-mpi/openmp-mpi/06/main_omp/2"}
{"code": "for (int j = 0; j < initSize; j++)\n{\n  rndNumber = rand() / ((double) RAND_MAX);\n  if (rndNumber <= MUT_PROB)\n  {\n    rand1 = rand() % dim;\n    rand2 = rand() % dim;\n    while (rand2 == rand1)\n    {\n      rand2 = rand() % dim;\n    }\n\n    tmpChar = population[j][rand1];\n    population[j][rand1] = population[j][rand2];\n    population[j][rand2] = tmpChar;\n  }\n\n  populationFitness[j] = evaluateFitness(population[j], dim, dist);\n}\n\n", "pragma": "        #pragma omp parallel for num_threads(NUM_THREADS) \\", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kushagramadan/tsp-openmp/tsp/21"}
{"code": "for (butterflyNo = 0; butterflyNo < numOfButterflyes; butterflyNo++)\n{\n  butterflyOffset = butterflyNo * butterflyLen;\n  angle = (2.0 * M_PI) / ((float) butterflyLen);\n  for (n = 0; n < half; n++)\n  {\n    dataOffset = n + butterflyOffset;\n    halfOffset = dataOffset + half;\n    w.re = cos(angle * ((float) n));\n    w.im = sin(angle * ((float) n));\n    _complex_mul(data[halfOffset], w, temp);\n    _complex_add(data[dataOffset], temp, butterfly[0]);\n    _complex_sub(data[dataOffset], temp, butterfly[1]);\n    _complex_mov(butterfly[0], data[dataOffset]);\n    _complex_mov(butterfly[1], data[halfOffset]);\n  }\n\n}\n\n", "pragma": "omp for private(butterflyOffset, angle, n, dataOffset, halfOffset, w, temp, butterfly) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/immanuelsavio/Parallel-Processing-Using-OpenMP/radix2/1"}
{"code": "for (int i = floor(sqrt(numCores)); i <= numCores; i++)\n{\n  if ((numCores % i) == 0)\n  {\n    N = numCores / i;\n    M = i;\n    if (N > M)\n    {\n      N = i;\n      M = numCores / i;\n    }\n\n    return;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bsc-performance-tools/wxparaver/src/glviewercanvas/1"}
{"code": "for (i = 0; i < n; i++)\n{\n  TID = omp_get_thread_num();\n  if ((pglobal = (int *) malloc(length[i] * (sizeof(int)))) != 0)\n  {\n    for (j = (sum = 0); j < length[i]; j++)\n      pglobal[j] = j + 1;\n\n    sum = calculate_sum(length[i]);\n    printf(\"TID %d: value of sum for i = %d is %8d (check = %8d)\\n\", TID, i, sum, check[i]);\n    free(pglobal);\n  }\n  else\n  {\n    printf(\"TID %d: fatal error in malloc for length[%d] = %d\\n\", TID, i, length[i]);\n  }\n\n}\n\n", "pragma": "omp parallel for shared(n,length,check) private(TID,i,j,sum)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/district10/tryopenmp/src/chapter4/fig4.98-threadprivate/0"}
{"code": "for (k = 1; k <= nz2; k++)\n{\n  lhsinitj(ny2 + 1, nx2);\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (j = 0; j <= (grid_points[1] - 1); j++)\n    {\n      ru1 = c3c4 * rho_i[k][j][i];\n      cv[j] = vs[k][j][i];\n      rhoq[j] = max(max(dy3 + (con43 * ru1), dy5 + (c1c5 * ru1)), max(dymax + ru1, dy1));\n    }\n\n    for (j = 1; j <= (grid_points[1] - 2); j++)\n    {\n      lhs[j][i][0] = 0.0;\n      lhs[j][i][1] = ((-dtty2) * cv[j - 1]) - (dtty1 * rhoq[j - 1]);\n      lhs[j][i][2] = 1.0 + (c2dtty1 * rhoq[j]);\n      lhs[j][i][3] = (dtty2 * cv[j + 1]) - (dtty1 * rhoq[j + 1]);\n      lhs[j][i][4] = 0.0;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = 1;\n    lhs[j][i][2] = lhs[j][i][2] + comz5;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j][i][4] = lhs[j][i][4] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz6;\n    lhs[j + 1][i][3] = lhs[j + 1][i][3] - comz4;\n    lhs[j + 1][i][4] = lhs[j + 1][i][4] + comz1;\n  }\n\n  for (j = 3; j <= (grid_points[1] - 4); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhs[j][i][0] = lhs[j][i][0] + comz1;\n      lhs[j][i][1] = lhs[j][i][1] - comz4;\n      lhs[j][i][2] = lhs[j][i][2] + comz6;\n      lhs[j][i][3] = lhs[j][i][3] - comz4;\n      lhs[j][i][4] = lhs[j][i][4] + comz1;\n    }\n\n  }\n\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    j = grid_points[1] - 3;\n    lhs[j][i][0] = lhs[j][i][0] + comz1;\n    lhs[j][i][1] = lhs[j][i][1] - comz4;\n    lhs[j][i][2] = lhs[j][i][2] + comz6;\n    lhs[j][i][3] = lhs[j][i][3] - comz4;\n    lhs[j + 1][i][0] = lhs[j + 1][i][0] + comz1;\n    lhs[j + 1][i][1] = lhs[j + 1][i][1] - comz4;\n    lhs[j + 1][i][2] = lhs[j + 1][i][2] + comz5;\n  }\n\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      lhsp[j][i][0] = lhs[j][i][0];\n      lhsp[j][i][1] = lhs[j][i][1] - (dtty2 * speed[k][j - 1][i]);\n      lhsp[j][i][2] = lhs[j][i][2];\n      lhsp[j][i][3] = lhs[j][i][3] + (dtty2 * speed[k][j + 1][i]);\n      lhsp[j][i][4] = lhs[j][i][4];\n      lhsm[j][i][0] = lhs[j][i][0];\n      lhsm[j][i][1] = lhs[j][i][1] + (dtty2 * speed[k][j - 1][i]);\n      lhsm[j][i][2] = lhs[j][i][2];\n      lhsm[j][i][3] = lhs[j][i][3] - (dtty2 * speed[k][j + 1][i]);\n      lhsm[j][i][4] = lhs[j][i][4];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      fac1 = 1.0 / lhs[j][i][2];\n      lhs[j][i][3] = fac1 * lhs[j][i][3];\n      lhs[j][i][4] = fac1 * lhs[j][i][4];\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      }\n\n      lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n      lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n      }\n\n      lhs[j2][i][1] = lhs[j2][i][1] - (lhs[j2][i][0] * lhs[j][i][3]);\n      lhs[j2][i][2] = lhs[j2][i][2] - (lhs[j2][i][0] * lhs[j][i][4]);\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhs[j2][i][0] * rhs[k][j][i][m]);\n      }\n\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    fac1 = 1.0 / lhs[j][i][2];\n    lhs[j][i][3] = fac1 * lhs[j][i][3];\n    lhs[j][i][4] = fac1 * lhs[j][i][4];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    }\n\n    lhs[j1][i][2] = lhs[j1][i][2] - (lhs[j1][i][1] * lhs[j][i][3]);\n    lhs[j1][i][3] = lhs[j1][i][3] - (lhs[j1][i][1] * lhs[j][i][4]);\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhs[j1][i][1] * rhs[k][j][i][m]);\n    }\n\n    fac2 = 1.0 / lhs[j1][i][2];\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j1][i][m] = fac2 * rhs[k][j1][i][m];\n    }\n\n  }\n\n  for (j = 0; j <= (grid_points[1] - 3); j++)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      m = 3;\n      fac1 = 1.0 / lhsp[j][i][2];\n      lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n      lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n      lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n      lhsp[j2][i][1] = lhsp[j2][i][1] - (lhsp[j2][i][0] * lhsp[j][i][3]);\n      lhsp[j2][i][2] = lhsp[j2][i][2] - (lhsp[j2][i][0] * lhsp[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsp[j2][i][0] * rhs[k][j][i][m]);\n      m = 4;\n      fac1 = 1.0 / lhsm[j][i][2];\n      lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n      lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n      rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n      lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n      lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n      rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n      lhsm[j2][i][1] = lhsm[j2][i][1] - (lhsm[j2][i][0] * lhsm[j][i][3]);\n      lhsm[j2][i][2] = lhsm[j2][i][2] - (lhsm[j2][i][0] * lhsm[j][i][4]);\n      rhs[k][j2][i][m] = rhs[k][j2][i][m] - (lhsm[j2][i][0] * rhs[k][j][i][m]);\n    }\n\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    m = 3;\n    fac1 = 1.0 / lhsp[j][i][2];\n    lhsp[j][i][3] = fac1 * lhsp[j][i][3];\n    lhsp[j][i][4] = fac1 * lhsp[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsp[j1][i][2] = lhsp[j1][i][2] - (lhsp[j1][i][1] * lhsp[j][i][3]);\n    lhsp[j1][i][3] = lhsp[j1][i][3] - (lhsp[j1][i][1] * lhsp[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsp[j1][i][1] * rhs[k][j][i][m]);\n    m = 4;\n    fac1 = 1.0 / lhsm[j][i][2];\n    lhsm[j][i][3] = fac1 * lhsm[j][i][3];\n    lhsm[j][i][4] = fac1 * lhsm[j][i][4];\n    rhs[k][j][i][m] = fac1 * rhs[k][j][i][m];\n    lhsm[j1][i][2] = lhsm[j1][i][2] - (lhsm[j1][i][1] * lhsm[j][i][3]);\n    lhsm[j1][i][3] = lhsm[j1][i][3] - (lhsm[j1][i][1] * lhsm[j][i][4]);\n    rhs[k][j1][i][m] = rhs[k][j1][i][m] - (lhsm[j1][i][1] * rhs[k][j][i][m]);\n    rhs[k][j1][i][3] = rhs[k][j1][i][3] / lhsp[j1][i][2];\n    rhs[k][j1][i][4] = rhs[k][j1][i][4] / lhsm[j1][i][2];\n  }\n\n  j = grid_points[1] - 2;\n  j1 = grid_points[1] - 1;\n  for (i = 1; i <= (grid_points[0] - 2); i++)\n  {\n    for (m = 0; m < 3; m++)\n    {\n      rhs[k][j][i][m] = rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m]);\n    }\n\n    rhs[k][j][i][3] = rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3]);\n    rhs[k][j][i][4] = rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4]);\n  }\n\n  for (j = grid_points[1] - 3; j >= 0; j--)\n  {\n    j1 = j + 1;\n    j2 = j + 2;\n    for (i = 1; i <= (grid_points[0] - 2); i++)\n    {\n      for (m = 0; m < 3; m++)\n      {\n        rhs[k][j][i][m] = (rhs[k][j][i][m] - (lhs[j][i][3] * rhs[k][j1][i][m])) - (lhs[j][i][4] * rhs[k][j2][i][m]);\n      }\n\n      rhs[k][j][i][3] = (rhs[k][j][i][3] - (lhsp[j][i][3] * rhs[k][j1][i][3])) - (lhsp[j][i][4] * rhs[k][j2][i][3]);\n      rhs[k][j][i][4] = (rhs[k][j][i][4] - (lhsm[j][i][3] * rhs[k][j1][i][4])) - (lhsm[j][i][4] * rhs[k][j2][i][4]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for default(shared) private(i,j,k,j1,j2,m, ru1,fac1,fac2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/y_solve/0"}
{"code": "for (x = 0; x < w; ++x)\n{\n  for (y = 0; y < h; ++y)\n  {\n    const Color c = get_pixel(x, y, base);\n    const Color gray = grayscale(c);\n    set_pixel(x, y, gray, ret);\n  }\n\n}\n\n", "pragma": "omp for collapse(2) schedule(dynamic, IMG_CHUNK)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lagodiuk/raytracing-render/render/src/canvas/0"}
{"code": "for (dest = 1; dest <= numworkers; dest++)\n{\n  rows = (dest <= extra) ? (averow + 1) : (averow);\n  printf(\"Sending %d rows to task %d offset=%d\\n\", rows, dest, offset);\n  MPI_Send(&offset, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&rows, 1, (MPI_Datatype) 0x4c000405, dest, mtype, 1);\n  MPI_Send(&a[offset][0], rows * 10, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  MPI_Send(&b, 10 * 10, (MPI_Datatype) 0x4c00080b, dest, mtype, 1);\n  offset = offset + rows;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/matrix_multipy/1"}
{"code": "for (int row = 0; row < 16; row++)\n{\n  for (int col = 0; col < 16; col++)\n  {\n    for (int e = 0; e < 16; ++e)\n      Cs[row][col] += As[row][e] * Bs[e][col];\n\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/libgomp/testsuite/libgomp.hsa.c/tiling-2/2"}
{"code": "for (i = 1; i <= tradesPerThread; i++)\n{\n  buyerIndex = lowerBuyerBound + (rand() % (upperBuyerBound - lowerBuyerBound));\n  bidPrice = (rand() % Buyers[buyerIndex].value) + 1;\n  sellerIndex = lowerSellerBound + (rand() % (upperSellerBound - lowerSellerBound));\n  askPrice = Sellers[sellerIndex].value + (rand() % ((20 - Sellers[sellerIndex].value) + 1));\n  if (((Buyers[buyerIndex].quantityHeld == 0) && (Sellers[sellerIndex].quantityHeld == 1)) && (bidPrice >= askPrice))\n  {\n    transactionPrice = askPrice + (rand() % ((bidPrice - askPrice) + 1));\n    Buyers[buyerIndex].price = transactionPrice;\n    Sellers[sellerIndex].price = transactionPrice;\n    Buyers[buyerIndex].quantityHeld = 1;\n    Sellers[sellerIndex].quantityHeld = 0;\n  }\n\n  ;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nitnelav27/ZITraders-OpenMP/zi_ompOLD/1"}
{"code": "for (int i = 0; i < nbpions; i++)\n{\n  const int tj = j;\n  j = cs->_Jnext[j][c];\n  c = cs->_Cnext[tj][c];\n  newPos->_Cases[j][c]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/7"}
{"code": "for (col = 0; col < public.in2_pad_cols; col++)\n{\n  #pragma loop name kernel#11#0\n  for (row = 0; row < public.in2_pad_rows; row++)\n  {\n    if ((((row > (public.in2_pad_add_rows - 1)) && (row < (public.in2_pad_add_rows + public.in2_rows))) && (col > (public.in2_pad_add_cols - 1))) && (col < (public.in2_pad_add_cols + public.in2_cols)))\n    {\n      ori_row = row - public.in2_pad_add_rows;\n      ori_col = col - public.in2_pad_add_cols;\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = private.d_in2_sqr[(ori_col * public.in2_rows) + ori_row];\n    }\n    else\n    {\n      private.d_in2_pad[(col * public.in2_pad_rows) + row] = 0;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Cetus/rodinia_3.1/openmp/heartwall/kernel/12"}
{"code": "for (j = 1; j <= npoints; j++)\n{\n  if ((((first + j) - 1) == 1) || (((first + j) - 1) == 400000))\n    newval[j] = 0.0;\n  else\n    newval[j] = ((2.0 * values[j]) - oldval[j]) + (sqtau * ((values[j - 1] - (2.0 * values[j])) + values[j + 1]));\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lk-2020/CFiles/concurrent_wave_testThreads/0"}
{"code": "for (t = 0; t < n; t += 3)\n{\n  BF_word L0;\n  BF_word R0;\n  BF_word u1;\n  BF_word u2;\n  BF_word u3;\n  BF_word u4;\n  BF_word *ptr;\n  BF_word count;\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    int i;\n    memcpy(BF_current.S, BF_init_state.S, sizeof(BF_current.S));\n    memcpy(BF_current.P, BF_init_key[index], sizeof(BF_current.P));\n    L0 = (R0 = 0);\n    for (i = 0; i < (16 + 2); i += 2)\n    {\n      L0 ^= salt->salt[i & 2];\n      R0 ^= salt->salt[(i & 2) + 1];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_current.P[i] = L0;\n      BF_current.P[i + 1] = R0;\n    }\n\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 4;\n      L0 ^= salt->salt[(16 + 2) & 3];\n      R0 ^= salt->salt[(16 + 3) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 4) = L0;\n      *(ptr - 3) = R0;\n      L0 ^= salt->salt[(16 + 4) & 3];\n      R0 ^= salt->salt[(16 + 5) & 3];\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n  }\n\n  count = 1 << salt->rounds;\n  do\n  {\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current.P[0] ^= BF_exp_key[index][0];\n      BF_current.P[1] ^= BF_exp_key[index][1];\n      BF_current.P[2] ^= BF_exp_key[index][2];\n      BF_current.P[3] ^= BF_exp_key[index][3];\n      BF_current.P[4] ^= BF_exp_key[index][4];\n      BF_current.P[5] ^= BF_exp_key[index][5];\n      BF_current.P[6] ^= BF_exp_key[index][6];\n      BF_current.P[7] ^= BF_exp_key[index][7];\n      BF_current.P[8] ^= BF_exp_key[index][8];\n      BF_current.P[9] ^= BF_exp_key[index][9];\n      BF_current.P[10] ^= BF_exp_key[index][10];\n      BF_current.P[11] ^= BF_exp_key[index][11];\n      BF_current.P[12] ^= BF_exp_key[index][12];\n      BF_current.P[13] ^= BF_exp_key[index][13];\n      BF_current.P[14] ^= BF_exp_key[index][14];\n      BF_current.P[15] ^= BF_exp_key[index][15];\n      BF_current.P[16] ^= BF_exp_key[index][16];\n      BF_current.P[17] ^= BF_exp_key[index][17];\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n    u1 = salt->salt[0];\n    u2 = salt->salt[1];\n    u3 = salt->salt[2];\n    u4 = salt->salt[3];\n    for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n    {\n      BF_current.P[0] ^= u1;\n      BF_current.P[1] ^= u2;\n      BF_current.P[2] ^= u3;\n      BF_current.P[3] ^= u4;\n      BF_current.P[4] ^= u1;\n      BF_current.P[5] ^= u2;\n      BF_current.P[6] ^= u3;\n      BF_current.P[7] ^= u4;\n      BF_current.P[8] ^= u1;\n      BF_current.P[9] ^= u2;\n      BF_current.P[10] ^= u3;\n      BF_current.P[11] ^= u4;\n      BF_current.P[12] ^= u1;\n      BF_current.P[13] ^= u2;\n      BF_current.P[14] ^= u3;\n      BF_current.P[15] ^= u4;\n      BF_current.P[16] ^= u1;\n      BF_current.P[17] ^= u2;\n    }\n\n    L0 = (R0 = 0);\n    ptr = BF_current.P;\n    do\n    {\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *ptr = L0;\n      *(ptr + 1) = R0;\n      ptr += 2;\n    }\n    while (ptr < (&BF_current.P[16 + 2]));\n    ptr = BF_current.S[0];\n    do\n    {\n      ptr += 2;\n      L0 ^= BF_current.P[0];\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u1 = L0 & 0xFF;\n      u1 <<= 2;\n      u2 = L0 >> 6;\n      u2 &= 0x3FC;\n      u3 = L0 >> 14;\n      u3 &= 0x3FC;\n      u4 = L0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R0 ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R0 ^= u3;\n      ;\n      u1 = R0 & 0xFF;\n      u1 <<= 2;\n      u2 = R0 >> 6;\n      u2 &= 0x3FC;\n      u3 = R0 >> 14;\n      u3 &= 0x3FC;\n      u4 = R0 >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L0 ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L0 ^= u3;\n      ;\n      u4 = R0;\n      R0 = L0;\n      L0 = u4 ^ BF_current.P[16 + 1];\n      ;\n      *(ptr - 2) = L0;\n      *(ptr - 1) = R0;\n    }\n    while (ptr < (&BF_current.S[3][0xFF]));\n    ;\n  }\n  while (--count);\n  for (index = t, lindex = 0; lindex < 3; index++, lindex++)\n  {\n    BF_word L;\n    BF_word R;\n    BF_word u1;\n    BF_word u2;\n    BF_word u3;\n    BF_word u4;\n    BF_word count;\n    int i;\n    memcpy(&BF_out[index], &BF_magic_w, sizeof(BF_out[index]));\n    count = 64;\n    do\n      for (i = 0; i < 6; i += 2)\n    {\n      L = BF_out[index][i];\n      R = BF_out[index][i + 1];\n      L ^= BF_current.P[0];\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[0 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[1 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[2 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[3 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[4 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[5 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[6 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[7 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[8 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[9 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[10 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[11 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[12 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[13 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u1 = L & 0xFF;\n      u1 <<= 2;\n      u2 = L >> 6;\n      u2 &= 0x3FC;\n      u3 = L >> 14;\n      u3 &= 0x3FC;\n      u4 = L >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      R ^= BF_current.P[14 + 1];\n      u3 += u1;\n      R ^= u3;\n      ;\n      u1 = R & 0xFF;\n      u1 <<= 2;\n      u2 = R >> 6;\n      u2 &= 0x3FC;\n      u3 = R >> 14;\n      u3 &= 0x3FC;\n      u4 = R >> 22;\n      u4 &= 0x3FC;\n      u1 = *((BF_word *) (((unsigned char *) BF_current.S[3]) + u1));\n      u2 = *((BF_word *) (((unsigned char *) BF_current.S[2]) + u2));\n      u3 = *((BF_word *) (((unsigned char *) BF_current.S[1]) + u3));\n      u3 += *((BF_word *) (((unsigned char *) BF_current.S[0]) + u4));\n      u3 ^= u2;\n      L ^= BF_current.P[15 + 1];\n      u3 += u1;\n      L ^= u3;\n      ;\n      u4 = R;\n      R = L;\n      L = u4 ^ BF_current.P[16 + 1];\n      ;\n      BF_out[index][i] = L;\n      BF_out[index][i + 1] = R;\n    }\n\n    while (--count);\n    BF_out[index][5] &= ~((BF_word) 0xFF);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/23"}
{"code": "for (int i = 0; i < listacentroidi.size(); i++)\n{\n  float distanza = listacentroidi.at(i).distanceFrom(newlistacentroidi.at(i));\n  ((cout << \"distanza: \") << distanza) << endl;\n  if (listacentroidi.at(i).distanceFrom(newlistacentroidi.at(i)) > 0.001)\n  {\n    return false;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/francescobongini/Kmeans/Kmeans/Kmeans/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  result[i] = A[i][n] / A[i][i];\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) private(i)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rkj777/OpenMPGaussJordanElimination/Main/2"}
{"code": "for (i = 1; i <= n; i++)\n{\n  x = w * (((double) i) - 0.5);\n  sum = sum + (4.0 / (1.0 + (x * x)));\n}\n\n", "pragma": "omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MaverickTheDude/Parallel_computing/timings_pi_program/0"}
{"code": "for (int i = 0; i < chunk; i++)\n{\n  if ((first_array.at(i) != 0) && (second_array.at(i) != 0))\n  {\n    sum = (sum + first_array[i]) + second_array[i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vladislavhgtech/openMp/OpenMpAll/OpenMpAll/OpenMpAll/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  transitions[i] = (double *) malloc(1000 * (sizeof(double)));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lar9482/High-Performance-Computing-Projects/TSP/Ant Colony Attempt/Ant_Colony/4"}
{"code": "for (unsigned int j = 0; j < sz; j++)\n{\n  encodedBlockBuffer.get()[idx].cb.encoded[j].encoded = (*encodedBlock->cb->encoded.get())[j].encoded;\n  encodedBlockBuffer.get()[idx].cb.encoded[j].count = (*encodedBlock->cb->encoded.get())[j].count;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/spenceryu/15618-final-project/src/rle/4"}
{"code": "for (t = 0; t < omp_para; t++)\n  md5cryptsse((unsigned char *) (&saved_key[t * MD5_N]), cursalt, (char *) (&sout[((t * MD5_N) * 4) / (sizeof(MD5_word))]), CryptType);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/MD5_fmt/3"}
{"code": "for (i = 0; i < 5; i++)\n{\n  for (j = 0; j < (5 + 1); j++)\n  {\n    matrix[i][j] = drand48();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/newomp/1"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x[i] = 0.0;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/hahnjo/CGxx/openmp/CGOpenMP/7"}
{"code": "for (i = 1; i < 10; i++)\n  (cout << (i * i)) << endl;\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/guilhermegoncalvess/openmp/directives/For/0"}
{"code": "for (i2 = 1; i2 <= num_threads; i2++)\n{\n  {\n    if (ten[i1][1] > best1)\n    {\n      best1 = ten[i1][1];\n      jg[0][i][1] = myid;\n    }\n\n    if (ten[i0][0] < best0)\n    {\n      best0 = ten[i0][0];\n      jg[0][i][0] = myid;\n    }\n\n  }\n}\n\n", "pragma": "omp for ordered schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/MG/mg/5"}
{"code": "for (int i = 0; i < locks.size(); i++)\n{\n  omp_destroy_lock(&locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/E-BAO/Particles-Simulation/openmp/3"}
{"code": "for (int i = 0; i < NODE; i++)\n{\n  if ((selected[i] == 0) && (dist[i] < min_array[thread_id]))\n  {\n    min_array[thread_id] = dist[i];\n    waypoint_array[thread_id] = i;\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/actumn/dijkstra-openmp/dijkstra/7"}
{"code": "for (size_t i = 0; i < 100; i++)\n  a[i] = (b[i] = i);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/a-guillot/OpenMP/schedule/1"}
{"code": "for (iCntr = 0; iCntr < iLoopCntr; iCntr++)\n{\n  if (iCntr == 0)\n  {\n    iThreadCnt = omp_get_num_threads();\n  }\n\n  int result1 = _mm256_fmadd_ps(vec1, vec2, vec3);\n  int result2 = _mm256_fmadd_ps(vec4, vec5, vec6);\n  int result3 = _mm256_fmadd_ps(vec7, vec8, vec9);\n  int result4 = _mm256_fmadd_ps(result1, result2, result3);\n  asm(\"\");\n}\n\n", "pragma": "omp parallel for default(shared)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tkonduri/HPC_1/fCode/0"}
{"code": "for (i = 0; i < nonzeros; i++)\n{\n  for (j = 0; j < order; j++)\n  {\n    k = indices[pos++];\n    CountX[(j * max_dim) + k]++;\n    tempX[(j * max_dim) + k]++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sejoonoh/GTA-Tensor/src/GTA/8"}
{"code": "for (int k = kb; k < ke; k++)\n{\n  for (int i = ib; i < ie; i++)\n  {\n    Dyu[IDX(i, 3, k)] = ((((-3.0) * u[IDX(i, 3, k)]) + (4.0 * u[IDX(i, 4, k)])) - u[IDX(i, 5, k)]) * idy_by_2;\n    Dyu[IDX(i, 4, k)] = ((-u[IDX(i, 3, k)]) + u[IDX(i, 5, k)]) * idy_by_2;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RuwanKarunanayake/openmp_unrolling_4/bssn/src/derivs/6"}
{"code": "for (int i = 0; i < rowA; ++i)\n{\n  for (int j = 0; j < colA; ++j)\n  {\n    int sum = 0;\n    for (int k = 0; k < colB; ++k)\n    {\n      sum += (*((matA + (i * colA)) + k)) * (*((matD + (j * colB)) + k));\n    }\n\n    *((matC + (i * colB)) + j) = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/laochonlam/matrix-multiplication/impl/1"}
{"code": "for (i = 0; i < Nx; i++)\n{\n  free(un1[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dseitani/OpenMP_project/Seitanidou_parallel/9"}
{"code": "for (chunk = 0; chunk < CHUNKS_PER_PE; chunk++)\n{\n  const uint64_t keys_per_chunk = NUM_KEYS_PER_PE / CHUNKS_PER_PE;\n  const uint64_t start_index = chunk * keys_per_chunk;\n  const uint64_t max_index = start_index + keys_per_chunk;\n  pcg32_random_t rng = seed_my_chunk(chunk);\n  KEY_TYPE * restrict my_keys_1D = &my_keys[start_index];\n  for (uint64_t i = start_index; i < max_index; i++)\n  {\n    *my_keys_1D = pcg32_boundedrand_r(&rng, MAX_KEY_VAL);\n    my_keys_1D += 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private(chunk) schedule (dynamic,1)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/isx/isx_original/0"}
{"code": "for (i = 0; i < 512; i++)\n{\n  fprintf(fp, \"%lf\", Sums[i]);\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AbhishekRamamurthy/OpenMP-Cuda/AutoCo_OpenMP/2"}
{"code": "for (i = 0; i < N; i++)\n{\n  *(matrixn + i) = data + (N * i);\n  *(matrixn1 + i) = data1 + (N * i);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stvschmdt/Advection_Parallel/ompAF/1"}
{"code": "for (size_t i = 0; i < N; ++i)\n{\n  y[i] = x[i] + y[i];\n}\n\n", "pragma": "   #pragma omp target teams distribute parallel for if(target:use_device)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/smoke/clang-273738/clang-273738/1"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  for (k = 0; k < 50; k++)\n  colidx[i][j][k] = 0;\n\n\n\n", "pragma": "omp parallel for private(i,j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/developmentTests/pointer2Array3/0"}
{"code": "for (j = 0; j < npp; j++)\n{\n  n = part[idimp * j];\n  m = part[1 + (idimp * j)];\n  n = n / mx;\n  m = (m - mnoff) / my;\n  m = n + (mx1 * m);\n  ip = kpic[m];\n  if (ip < nppmx)\n  {\n    for (i = 0; i < idimp; i++)\n    {\n      ppart[i + (idimp * (ip + (nppmx * m)))] = part[i + (idimp * j)];\n    }\n\n  }\n  else\n  {\n    ierr = (ierr > ((ip - nppmx) + 1)) ? (ierr) : ((ip - nppmx) + 1);\n  }\n\n  kpic[m] = ip + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpbpic2/mpbpush2/31"}
{"code": "for (int i = 5; i >= 0; i--)\n{\n  printf(\"[%d] \", pos->_Cases[0][i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif/1"}
{"code": "for (x = proc_x_indices.first; x < proc_x_indices.second; ++x)\n{\n  if ((x == 0) || (x == (GLOBAL_GRID_H - 1)))\n  {\n    for (y = 0; y < GLOBAL_GRID_W; ++y)\n      grid_values[get_index_row(x, y)] = u_value(iteration + 1, x, y);\n\n    continue;\n  }\n\n  for (y = 0; y < GLOBAL_GRID_W; ++y)\n  {\n    double L = ((buf_grid_values[get_index_row(x - 1, y)] - (2 * buf_grid_values[get_index_row(x, y)])) + buf_grid_values[get_index_row(x + 1, y)]) / (D_X * D_X);\n    F_y[y] = (-buf_grid_values[get_index_row(x, y)]) - ((0.5 * D_T) * (f_value(iteration, x, y) + L));\n  }\n\n  P_y[0] = (-c_matrix_y[0]) / b_matrix_y[0];\n  Q_y[0] = F_y[0] / b_matrix_y[0];\n  for (y = 1; y < GLOBAL_GRID_W; ++y)\n  {\n    P_y[y] = c_matrix_y[y] / (((-a_matrix_y[y]) * P_y[y - 1]) - b_matrix_y[y]);\n    Q_y[y] = ((-F_y[y]) + (a_matrix_y[y] * Q_y[y - 1])) / (((-a_matrix_y[y]) * P_y[y - 1]) - b_matrix_y[y]);\n  }\n\n  for (y = GLOBAL_GRID_W - 1; y >= 0; --y)\n  {\n    if ((y == 0) || (y == (GLOBAL_GRID_W - 1)))\n    {\n      grid_values[get_index_row(x, y)] = u_value(iteration + 1, x, y);\n      continue;\n    }\n\n    grid_values[get_index_row(x, y)] = (P_y[y] * grid_values[get_index_row(x, y + 1)]) + Q_y[y];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ArkadiyD/ParallelDiffEquation/src/solver/24"}
{"code": "for (j = jst; j <= L2; j++)\n{\n  tmp = 1.0 / rsd[i][j][k][0];\n  u21j = tmp * rsd[i][j][k][1];\n  u31j = tmp * rsd[i][j][k][2];\n  u41j = tmp * rsd[i][j][k][3];\n  u51j = tmp * rsd[i][j][k][4];\n  tmp = 1.0 / rsd[i][j - 1][k][0];\n  u21jm1 = tmp * rsd[i][j - 1][k][1];\n  u31jm1 = tmp * rsd[i][j - 1][k][2];\n  u41jm1 = tmp * rsd[i][j - 1][k][3];\n  u51jm1 = tmp * rsd[i][j - 1][k][4];\n  flux[i][j][k][1] = ty3 * (u21j - u21jm1);\n  flux[i][j][k][2] = ((4.0 / 3.0) * ty3) * (u31j - u31jm1);\n  flux[i][j][k][3] = ty3 * (u41j - u41jm1);\n  flux[i][j][k][4] = ((((0.50 * (1.0 - (C1 * C5))) * ty3) * ((((u21j * u21j) + (u31j * u31j)) + (u41j * u41j)) - (((u21jm1 * u21jm1) + (u31jm1 * u31jm1)) + (u41jm1 * u41jm1)))) + (((1.0 / 6.0) * ty3) * ((u31j * u31j) - (u31jm1 * u31jm1)))) + (((C1 * C5) * ty3) * (u51j - u51jm1));\n}\n\n", "pragma": "omp parallel for firstprivate(iend ,m ,j ,ist ,k ,u21j ,u31j ,u41j ,u51j ,tmp ,u21jm1 ,u31jm1 ,u41jm1 ,u51jm1 ,ty2 ,jst ,jend ,ty3 ,L2 ,ty1 ,dy1 ,dy2 ,dy3 ,dy4 ,dy5 ,dssp ,jend1 ,ny ,nz ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/31"}
{"code": "for (index = 0; index < num_rows; index++)\n  printf(\" output[%d] = %f \\n\", index, FinalVector[index]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/poodarchu/parallel-computing/OpenMP+MPI/hybrid_matrix_multiply/5"}
{"code": "for (e = 0; e < graph->num_edges; e++)\n{\n  weight = 1;\n  uint32_t index = 0;\n  if (weight > delta)\n  {\n    index = __sync_fetch_and_add(&edgesPlus_idx, 1);\n    edgesPlus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlus->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n    edgesPlusInverse->edges_array_dest[index] = graph->sorted_edges_array->edges_array_src[e];\n    edgesPlusInverse->edges_array_src[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesPlusInverse->edges_array_weight[index] = graph->sorted_edges_array->edges_array_weight[e];\n  }\n  else\n    if (weight <= delta)\n  {\n    index = __sync_fetch_and_add(&edgesMinus_idx, 1);\n    edgesMinus->edges_array_dest[index] = graph->sorted_edges_array->edges_array_dest[e];\n    edgesMinus->edges_array_src[index] = graph->sorted_edges_array->edges_array_src[e];\n  }\n\n\n}\n\n", "pragma": "omp parallel for private(e,weight) shared(edgesMinus_idx,edgesPlus_idx,edgesPlus,edgesMinus,graph)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/SSSP/17"}
{"code": "for (i = 0; i < 10; i++)\n{\n  t_id = omp_get_thread_num();\n  printf(\"i : %d, by the way i'm thread %d\\n\", i, t_id);\n}\n\n", "pragma": "omp parallel for private(t_id)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nnadnad/openmp/src/hello_openmp/0"}
{"code": "for (i = 0; i < sizeofBuffer; i++)\n{\n  if (finalBuf[i] != testBuf[i])\n  {\n    testFlag = FALSE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jbreitbart/OpenMP-GASPI-MicroBenchmark-Suite/collective_scatterGather/3"}
{"code": "for (int i = 0; i < 900; i++)\n{\n  X[i] = ((((double) rand()) / 32767) * 100.0) - 0.0;\n}\n\n", "pragma": "omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/RidaLr/Parallel-programming-OpenMp/Exercice7/0"}
{"code": "for (idx_t m = 0; m < nmodes; ++m)\n{\n  const val_t * const restrict atavals = aTa[m]->vals;\n  for (idx_t i = 0; i < rank; ++i)\n  {\n    for (idx_t j = i; j < rank; ++j)\n    {\n      av[j + (i * rank)] *= atavals[j + (i * rank)];\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/cpd/6"}
{"code": "for (size_t i = 0; i < num_elements; ++i)\n{\n  a += out[i];\n  out[i] = b;\n  b = a;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sebkelle1/parallel-scan/main/0"}
{"code": "for (j = i + 1; j < 2000; j++)\n{\n  if (fabsl(MA[j][i]) > MAX)\n  {\n    MAX = fabsl(MA[j][i]);\n    mas[MyP] = j;\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/berezhko/openmp/metodGaussaOMP-20/0"}
{"code": "for (j = 0; j < numOfProc; j++)\n  printOutPut(oArr[j]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DorelShoshany/Perceptron-Algorithm/hw4/work/3"}
{"code": "for (pos = 0; pos < (QRNG_DIMENSIONS * N); pos++)\n{\n  unsigned int d = (pos + 1) * distance;\n  ref = MoroInvCNDcpu(d);\n  delta = ((double) output[pos]) - ref;\n  sumDelta += fabs(delta);\n  sumRef += fabs(ref);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/qrg-omp/main/5"}
{"code": "for (i = 1; i < num_threads; ++i)\n{\n  max_prefix_sums[i] += max_prefix_sums[i - 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/zwhe99/String-Group-By-Parallel-Algorithm/omp_group_by/21"}
{"code": "for (i = 0; i < N; i++)\n  for (j = 0; j < N; j++)\n  a[i][j] = (i + j) * ((double) rand());\n\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/davidbejarcaceres/OpenMP-Matrix-Multiplication/mmOMP/0"}
{"code": "for (i = 0; i < square; ++i)\n{\n  size_t p = PIC_START + (3 * i);\n  buffer[p] = to_char((buffer[p] - min_diap) * c);\n  buffer[p + 1] = to_char((buffer[p + 1] - min_diap) * c);\n  buffer[p + 2] = to_char((buffer[p + 2] - min_diap) * c);\n}\n\n", "pragma": "#pragma omp parallel for firstprivate(width, c, min_diap, height, PIC_START, square) shared(buffer) private(i) default(none) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mralex1810/openmp/main/15"}
{"code": "for (i = 0; i < row; i++)\n{\n  for (j = 0; j < column; j++)\n  {\n    ch = *((matrix + (i * column)) + j);\n    printf(\"%c \", ch);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AhmedSam3r/parallel-processing-assignments/#3/A3-20160014-20160027/2"}
{"code": "for (i = 0; i < wl_size; i++)\n{\n  for (j = 0; j < num_hf; j++)\n  {\n    hash = hf[j](get_word(wl, i));\n    hash %= bv_size;\n    bv[hash] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(wl_size, num_hf, wl, bv_size) private(i,j, hash) schedule(guided)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rcouchh/OpenMP-Parallel-Programming/src/spell_t4_fastest/0"}
{"code": "for (int i = (np / unroll) * unroll; i < np; ++i)\n  inner_func(input, sup, sgn, i, i + 1);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/7"}
{"code": "for (int k = y_min - depth; k <= ((y_max + y_inc) + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    int index = (buffer_offset + j) + (((k + depth) - 1) * depth);\n    right_snd_buffer[FTNREF1D(index, 1)] = field[FTNREF2D((x_max + 1) - j, k, (x_max + 4) + x_inc, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_pack/2"}
{"code": "for (j_imopVar118 = 1; j_imopVar118 < (grid_points[1] - 1); j_imopVar118++)\n{\n  for (k_imopVar119 = 1; k_imopVar119 < (grid_points[2] - 1); k_imopVar119++)\n  {\n    for (m = 0; m < 5; m++)\n    {\n      for (n = 0; n < 5; n++)\n      {\n        rhs[i_imopVar117][j_imopVar118][k_imopVar119][m] = rhs[i_imopVar117][j_imopVar118][k_imopVar119][m] - (lhs[i_imopVar117][j_imopVar118][k_imopVar119][2][m][n] * rhs[i_imopVar117 + 1][j_imopVar118][k_imopVar119][n]);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/bt-long/76"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    a[i][j] = rand() % 10;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/durgeshnaik06/parallel-openmp-programs/LU_decomposition_parallel/0"}
{"code": "for (i = 2; i <= till; i++)\n{\n  arr[i * myPrime] = 1;\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rahulgurnani/parallel-seive/eseive/0"}
{"code": "for (i = 0; i < num_l; i++)\n{\n  if (dim == 1)\n  {\n    double *temp;\n    double *temp_data;\n    temp = fields[i][field1]->f1d;\n    fields[i][field1]->f1d = fields[i][field2]->f1d;\n    fields[i][field2]->f1d = temp;\n    temp_data = fields[i][field1]->data;\n    fields[i][field1]->data = fields[i][field2]->data;\n    fields[i][field2]->data = temp_data;\n  }\n  else\n    if (dim == 2)\n  {\n    double **temp1;\n    double *temp2;\n    double *temp_data;\n    int nx = fields[i][field1]->size[0];\n    for (j = 0; j < nx; j++)\n    {\n      temp2 = fields[i][field1]->f2d[j];\n      fields[i][field1]->f2d[j] = fields[i][field2]->f2d[j];\n      fields[i][field2]->f2d[j] = temp2;\n    }\n\n    temp1 = fields[i][field1]->f2d;\n    fields[i][field1]->f2d = fields[i][field2]->f2d;\n    fields[i][field2]->f2d = temp1;\n    temp_data = fields[i][field1]->data;\n    fields[i][field1]->data = fields[i][field2]->data;\n    fields[i][field2]->data = temp_data;\n  }\n  else\n    if (dim == 3)\n  {\n    double ***temp1;\n    double **temp2;\n    double *temp3;\n    double *temp_data;\n    int nx = fields[i][field1]->size[0];\n    int ny = fields[i][field1]->size[1];\n    for (j = 0; j < nx; j++)\n    {\n      for (k = 0; k < ny; k++)\n      {\n        temp3 = fields[i][field1]->f3d[j][k];\n        fields[i][field1]->f3d[j][k] = fields[i][field2]->f3d[j][k];\n        fields[i][field2]->f3d[j][k] = temp3;\n      }\n\n      temp2 = fields[i][field1]->f3d[j];\n      fields[i][field1]->f3d[j] = fields[i][field2]->f3d[j];\n      fields[i][field2]->f3d[j] = temp2;\n    }\n\n    temp1 = fields[i][field1]->f3d;\n    fields[i][field1]->f3d = fields[i][field2]->f3d;\n    fields[i][field2]->f3d = temp1;\n    temp_data = fields[i][field1]->data;\n    fields[i][field1]->data = fields[i][field2]->data;\n    fields[i][field2]->data = temp_data;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gdreid/MG_OMP/Hierarchy/6"}
{"code": "for (i = 0; i < numDims; i++)\n{\n  dist += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/amitlevy21/kMeans_200055986/kMeans_200055986/quality/0"}
{"code": "for (i = 1; i <= nodesCount; i += block_size)\n{\n  if (i == k)\n  {\n    continue;\n  }\n\n  for (j = 1; j <= nodesCount; j += block_size)\n  {\n    if (j == k)\n    {\n      continue;\n    }\n\n    if ((((i + block_size) - 1) > nodesCount) && (((j + block_size) - 1) <= nodesCount))\n    {\n      fw(i, nodesCount, j, (j + block_size) - 1, k, end);\n    }\n    else\n      if ((((i + block_size) - 1) > nodesCount) && (((j + block_size) - 1) > nodesCount))\n    {\n      fw(i, nodesCount, j, nodesCount, k, end);\n    }\n    else\n      if ((((i + block_size) - 1) <= nodesCount) && (((j + block_size) - 1) > nodesCount))\n    {\n      fw(i, (i + block_size) - 1, j, nodesCount, k, end);\n    }\n    else\n    {\n      fw(i, (i + block_size) - 1, j, (j + block_size) - 1, k, end);\n    }\n\n\n\n  }\n\n}\n\n", "pragma": "omp parallel for shared(k, end) private(i, j) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hongfeiyang/Parallel-Flyord-Warshall-OpenMP-/proj1/3"}
{"code": "for (; nthreads <= nthreadsMax; nthreads *= 2)\n{\n  omp_set_num_threads(nthreads);\n  initMatrix(A);\n  initMatrix(B);\n  clearMatrix(C);\n  for (int i = 0; i < 5; i++)\n  {\n    double start = omp_get_wtime();\n    cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, A, N, B, N, 1.0, C, N);\n    double end = omp_get_wtime();\n    double elapsed = end - start;\n    printf(\"%d\\t%d\\t%f\\t%f\\n\", N, nthreads, elapsed, Mflop / (elapsed * 1E9));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nunosilva800/pGEMM_performanceEval/ompMM_BLAS/3"}
{"code": "for (int y = 2; y < (prows - 2); y++)\n{\n  fY = (deltaX + xStart) + ((y - 2) * deltaY);\n  updateVal = (((((u_old[(y * pcolumns) + (pcolumns - 3)] + u_old[(y * pcolumns) + (pcolumns - 1)]) * cx) + ((u_old[((y - 1) * pcolumns) + (pcolumns - 2)] + u_old[((y + 1) * pcolumns) + (pcolumns - 2)]) * cy)) + (u_old[(y * pcolumns) + (pcolumns - 2)] * cc)) - ((((fX * fX) - 1.0) * ((alpha * (1.0 - (fY * fY))) + 2.0)) - (2.0 * (1.0 - (fY * fY))))) / cc;\n  u[(y * pcolumns) + (pcolumns - 2)] = u_old[(y * pcolumns) + (pcolumns - 2)] - (relax * updateVal);\n  loop_error += updateVal * updateVal;\n}\n\n", "pragma": "omp for reduction(+:loop_error) private(fY, updateVal, y) schedule(static)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dora-jpg/parallel-jacobi-SOR/HybridMPI/openmpi/2"}
{"code": "for (ix = 1; ix < (XblockSize - 1); ix++)\n  for (iy = 1; iy < (YblockSize - 1); iy++)\n{\n  u[1 - currentArray][ix][iy] = (u[currentArray][ix][iy] + (parms.cx * ((u[currentArray][ix + 1][iy] + u[currentArray][ix - 1][iy]) - (2.0 * u[currentArray][ix][iy])))) + (parms.cy * ((u[currentArray][ix][iy + 1] + u[currentArray][ix][iy - 1]) - (2.0 * u[currentArray][ix][iy])));\n  if (u[1 - currentArray][ix][iy] == u[currentArray][ix][iy])\n    changed++;\n\n}\n\n\n", "pragma": "omp for schedule(static, 4) collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Qwerkykk/heat-transfer-simulation/MPI_OPENMP/heat2D/0"}
{"code": "for (i = 0; i < 3; i++)\n{\n  mor_v[i] = *count;\n  *count = (*count) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/7"}
{"code": "for (i = 0; i < 10000; i++)\n{\n  float tmp1 = 0.0;\n  for (k = 0; k < 1024; k++)\n    tmp1 += Pfun(i, k);\n\n  tmp += tmp1;\n}\n\n", "pragma": "omp parallel for reduction(+:tmp)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rogerioag/openmp.info/src/check-libgomp/python/gcc_5_1_0_release/testsuite/libgomp.c/examples-4/e.53.5/0"}
{"code": "for (unsigned int g = 0; g < ng; ++g)\n{\n  for (unsigned int k = 0; k < nz; k++)\n  {\n    for (unsigned int j = 0; j < ny; j++)\n    {\n      for (unsigned int i = 0; i < nx; i++)\n      {\n        for (unsigned int l = 0; l < nmom; l++)\n        {\n          scat_cs(l, i, j, k, g) = gg_cs(mat(i, j, k) - 1, l, g, g);\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/SNAP-OpenMP/src/ext_kernels/2"}
{"code": "for (j = 0; j < 500; j++)\n{\n  w[0][j] = 0.0;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/HaoLIU94/Parallel-computing/OpenMP/heated_plate_openmp/3"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  for (int aj = this->mat_.row_offset[ai]; aj < this->mat_.row_offset[ai + 1]; ++aj)\n  {\n    if (ai == this->mat_.col[aj])\n    {\n      ++size;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/35"}
{"code": "for (int i = 0, j = 0; i < this->nrow_; ++i)\n{\n  if (cast_agg->vec_[i] >= 0)\n  {\n    col[j] = cast_agg->vec_[i];\n    val[j] = 1.0;\n    ++j;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/94"}
{"code": "for (int i = 1; i <= n; i += 2)\n{\n  czyPierwsza[i - 1] = false;\n  czyPierwsza[i] = true;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Vieja/PrimeNumbers-OpenMP/LiczbyPierwsze/LiczbyPierwsze/5"}
{"code": "for (i = 0; i < 1024; i++)\n  (void) 0;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/llvm-mirror/openmp/runtime/test/tasking/bug_36720/0"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 100; j++)\n  printf(\"%d\\n\", a[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/dataracebench/DRB073-doall2-orig-yes/2"}
{"code": "for (k = ki1; k < ki2; k++)\n{\n  for (i = ibeg; i < ifin; i++)\n  {\n    phi2[k][i] = C2 * (u[k][jfin - 1][i][4] - ((0.50 * (((u[k][jfin - 1][i][1] * u[k][jfin - 1][i][1]) + (u[k][jfin - 1][i][2] * u[k][jfin - 1][i][2])) + (u[k][jfin - 1][i][3] * u[k][jfin - 1][i][3]))) / u[k][jfin - 1][i][0]));\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/NPB-OMP/LU/lu/23"}
{"code": "for (int i = 0; i < n; ++i)\n{\n  result += x[i] * y[i];\n}\n\n", "pragma": "  #pragma omp parallel for reduction(+:result)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gadube/simple_openmp_examples/cg-solve/cgsolve_omp/2"}
{"code": "for (int i = 0; i < n; ++i)\n  L[i] = (double *) malloc(n * (sizeof(double)));\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Diwakar98/COL380-A2-Crout-Decomposition-Using-OpenMP-And-MPI/main/20"}
{"code": "for (middle = 0; middle < 1200; middle++)\n{\n  int *dm = distance_matrix[middle];\n  for (src = 0; src < 1200; src++)\n  {\n    int *ds = distance_matrix[src];\n    for (dst = 0; dst < 1200; dst++)\n    {\n      ds[dst] = min(ds[dst], ds[middle] + dm[dst]);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kckishan/Floyd-Warshall-algorithm-OpenMP/apsp_1200_nodes/4"}
{"code": "for (int i = 1; i <= n3; ++i)\n{\n  theta3[i] = (out3[i] * (1 - out3[i])) * (expected[i] - out3[i]);\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VithikShah/Multilayer-Perceptron-OpenMP/parallel_training/9"}
{"code": "for (i = 0; i < 1700; i++)\n{\n  for (j = 0; j < 1700; j++)\n  {\n    if (M[i][j] == (100 * 100))\n      fprintf(fp, \"%4s \", \"inf\");\n    else\n      fprintf(fp, \"% 4d \", M[i][j]);\n\n  }\n\n  fprintf(fp, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dmitrybbch/parallelized-floyd-warshall/floydwarshall/4"}
{"code": "for (int i = start; i < end; i++)\n{\n  max = (data[i].data[dim] > max) ? (data[i].data[dim]) : (max);\n  min = (data[i].data[dim] < min) ? (data[i].data[dim]) : (min);\n}\n\n", "pragma": "omp for reduction(max:max) reduction(min:min)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erikalena/hpc_assignment2/src/sorting_data/0"}
{"code": "for (int i = 1; i < (grid.shape[0] - 1); ++i)\n{\n  for (int j = 1; j < (grid.shape[1] - 1); ++j)\n  {\n    for (int k = 1; k < (grid.shape[2] - 1); ++k)\n    {\n      sum += sqr(grid(i, j, k) - groundTruth(i, j, k));\n    }\n\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lyukov/parallel_wave_equation/src/CpuSolver/6"}
{"code": "for (unsigned int i = 0; i < path.size(); ++i)\n{\n  int check = 0;\n  for (unsigned int j = 0; j < path.size(); ++j)\n  {\n    if (path.at(i) == path.at(j))\n    {\n      ++check;\n      if (check > 1)\n        return true;\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mnmnc/OpenMP_TSP_Evolution/tspevo/15"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  npp = kpic[k];\n  npoff = nppmx * k;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sfxy[(3 * i) + (mxv3 * j)] = fxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sfxy[(1 + (3 * i)) + (mxv3 * j)] = fxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sfxy[(2 + (3 * i)) + (mxv3 * j)] = fxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      sbxy[(3 * i) + (mxv3 * j)] = bxy[3 * ((i + noff) + (nxv * (j + moff)))];\n      sbxy[(1 + (3 * i)) + (mxv3 * j)] = bxy[1 + (3 * ((i + noff) + (nxv * (j + moff))))];\n      sbxy[(2 + (3 * i)) + (mxv3 * j)] = bxy[2 + (3 * ((i + noff) + (nxv * (j + moff))))];\n    }\n\n  }\n\n  sum1 = 0.0;\n  for (j = 0; j < npp; j++)\n  {\n    x = ppart[idimp * (j + npoff)];\n    y = ppart[1 + (idimp * (j + npoff))];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = (3 * (nn - noff)) + (mxv3 * (mm - moff));\n    amx = 1.0 - dxp;\n    amy = 1.0 - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += mxv3;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 3;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += mxv3;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 3;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[2 + (idimp * (j + npoff))] + dx;\n    acy = ppart[3 + (idimp * (j + npoff))] + dy;\n    acz = ppart[4 + (idimp * (j + npoff))] + dz;\n    p2 = ((acx * acx) + (acy * acy)) + (acz * acz);\n    gami = 1.0 / sqrtf(1.0 + (p2 * ci2));\n    qtmg = qtmh * gami;\n    sum1 += (gami * p2) / (1.0 + gami);\n    omxt = qtmg * ox;\n    omyt = qtmg * oy;\n    omzt = qtmg * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0 / (1.0 + omt);\n    omt = 0.5 * (1.0 - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    dx += (((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm;\n    dy += (((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm;\n    dz += (((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm;\n    ppart[2 + (idimp * (j + npoff))] = dx;\n    ppart[3 + (idimp * (j + npoff))] = dy;\n    ppart[4 + (idimp * (j + npoff))] = dz;\n    p2 = ((dx * dx) + (dy * dy)) + (dz * dz);\n    dtg = dtc / sqrtf(1.0 + (p2 * ci2));\n    dx = x + (dx * dtg);\n    dy = y + (dy * dtg);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = ppart[idimp * (j + npoff)];\n        ppart[2 + (idimp * (j + npoff))] = -ppart[2 + (idimp * (j + npoff))];\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = ppart[1 + (idimp * (j + npoff))];\n        ppart[3 + (idimp * (j + npoff))] = -ppart[3 + (idimp * (j + npoff))];\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = ppart[idimp * (j + npoff)];\n        ppart[2 + (idimp * (j + npoff))] = -ppart[2 + (idimp * (j + npoff))];\n      }\n\n    }\n\n\n    ppart[idimp * (j + npoff)] = dx;\n    ppart[1 + (idimp * (j + npoff))] = dy;\n  }\n\n  sum2 += sum1;\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nn,mm,nm,x,y,dxp,dyp,amx,amy,dx,dy, dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1,rot2,rot3,rot4, rot5,rot6,rot7,rot8,rot9,p2,gami,qtmg,dtg,sum1,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mbpic2/mbpush2/3"}
{"code": "for (i = 0; i < n; i++)\n{\n  suma = suma + a[i];\n  printf(\"thread %d suma a[%d]/ \", 0, i);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MAInformatico/Arquitectura-de-Computadores/practica2/private-clause/1"}
{"code": "for (int i = 0; i < nthreads; i++)\n  stddev += pow(respvar[i] - mean, 2);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp-benchmarks/src/benchmark/benchmark/3"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n{\n  a[i] = (rand() % 100) - 50;\n  b[i] = (rand() % 100) - 50;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GoodBoy962/ParallelProgramming/OpenMP/hw/open_mp/task6/0"}
{"code": "for (i = 0; i < 10; i++)\n  counts[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Faizan-Mushtaq/PADP-Lab-Programs/Prog6_WordSearch_openmp/1"}
{"code": "for (i = 1; i < (pcinfo.x_cells_num - 1); i++)\n{\n  int index_i = pcinfo.x_cell_pos + i;\n  int index_j = pcinfo.y_cell_pos + j;\n  df[(j * pcinfo.x_cells_num) + i] = ((((f[(j * pcinfo.x_cells_num) + i] - f[((j * pcinfo.x_cells_num) + i) - 1]) / hx_(index_i - 1)) - ((f[((j * pcinfo.x_cells_num) + i) + 1] - f[(j * pcinfo.x_cells_num) + i]) / hx_(index_i))) / hhx_(index_i)) + ((((f[(j * pcinfo.x_cells_num) + i] - f[((j - 1) * pcinfo.x_cells_num) + i]) / hy_(index_j - 1)) - ((recv_message_bu[i] - f[(j * pcinfo.x_cells_num) + i]) / hy_(index_j))) / hhy_(index_j));\n}\n\n", "pragma": "                #pragma omp for schedule (static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Goorman/SC_Openmp/DPS/9"}
{"code": "for (i = 0; i < 100; i++)\n  for (j = 0; j < 700; j++)\n  c[i][j] = 0;\n\n\n", "pragma": "omp for schedule (static, chunk)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sajidamro/eclipse-workspace/omp_mm/MatrixMultiplication/2"}
{"code": "for (c = 0; c < 3; c++)\n{\n  for (d = 0; d < 3; d++)\n  {\n    for (k = 0; k < 3; k++)\n    {\n      sum = sum + (first[c][k] * second[k][d]);\n    }\n\n    multiply[c][d] = sum;\n    sum = 0;\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) shared(first,second,multiply)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/riaarun25/OpenMP_Programs/matrixmul/0"}
{"code": "for (i = 0; i < ch_im_out; i++)\n{\n  for (j = 0; j < dim_im_out; j++)\n  {\n    for (k = 0; k < dim_im_out; k++)\n    {\n      conv_out = (bias[i] << bias_shift) + NN_ROUND(out_shift);\n      for (m = 0; m < dim_kernel; m++)\n      {\n        for (n = 0; n < dim_kernel; n++)\n        {\n          in_row = ((stride * j) + m) - padding;\n          in_col = ((stride * k) + n) - padding;\n          if ((((in_row >= 0) && (in_col >= 0)) && (in_row < dim_im_in)) && (in_col < dim_im_in))\n          {\n            for (l = 0; l < ch_im_in; l++)\n            {\n              conv_out += Im_in[(((in_row * dim_im_in) + in_col) * ch_im_in) + l] * wt[((((i * ch_im_in) * dim_kernel) * dim_kernel) + (((m * dim_kernel) + n) * ch_im_in)) + l];\n            }\n\n          }\n\n        }\n\n      }\n\n      Im_out[i + (((j * dim_im_out) + k) * ch_im_out)] = (q7_t) __SSAT(conv_out >> out_shift, 8);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aignacio/openmp_eval_arm/cifar_original/CMSIS_5/CMSIS/NN/Source/ConvolutionFunctions/arm_convolve_HWC_q7_RGB/0"}
{"code": "for (int i = 0; i < nthreads; i++)\n{\n  int f = i * (n / nthreads);\n  int l = ((i + 1) * (n / nthreads)) - 1;\n  compute_group_bisect(diagonal, offdiagonal, left_boundary, right_boundary, f, l, n, relative_tolerance, eigenvalues);\n}\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/NikiforovAll/JacobiEigenvalueAlgorithm/JacobiEigenvalueAlgorithm/Bisection/4"}
{"code": "for (l = 1; l <= m; l += 2)\n{\n  fftz2(is, l, m, n, fftblock, fftblockpad, u, x, y);\n  if (l == m)\n    break;\n\n  fftz2(is, l + 1, m, n, fftblock, fftblockpad, u, y, x);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/FT/ft/14"}
{"code": "for (int i = 0; i < m_nCells; i++)\n{\n  for (int k = 0; k < CVT_INT(m_nSoilLyrs[i]); k++)\n  {\n    m_soilMass[i][k] = ((10000.f * m_soilThk[i][k]) * m_soilBD[i][k]) * (1.f - (m_soilRock[i][k] * 0.01f));\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lreis2415/SEIMS/seims/src/seims_main/modules/nutrient/NUTR_TF/Nutrient_Transformation/1"}
{"code": "for (i = 1; i < (N + 1); i++)\n{\n  for (j = 1; j < (N + 1); j++)\n  {\n    for (k = 1; k < (N + 1); k++)\n    {\n      if (roomCopy[(((i * (2 + N)) * (2 + N)) + (j * (2 + N))) + k] < conMin)\n      {\n        conMin = roomCopy[(((i * (2 + N)) * (2 + N)) + (j * (2 + N))) + k];\n      }\n\n      if (roomCopy[(((i * (2 + N)) * (2 + N)) + (j * (2 + N))) + k] > conMax)\n      {\n        conMax = roomCopy[(((i * (2 + N)) * (2 + N)) + (j * (2 + N))) + k];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/coolbrees9/CSC435-GroupProject/c/diffusion/2"}
{"code": "for (int q = 0; q < 500; q++)\n{\n  pos[q][0] = ((rand() / ((double) 32767)) * 2) - 1;\n  pos[q][1] = ((rand() / ((double) 32767)) * 2) - 1;\n  vel[q][0] = ((rand() / ((double) 32767)) * 2) - 1;\n  vel[q][1] = ((rand() / ((double) 32767)) * 2) - 1;\n  masses[q] = fabs(((rand() / ((double) 32767)) * 2) - 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/timmitommi/DD2356-assignment-2/exercise-2/parallel/4"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  fprintf(fp, \"%f \", (float) pndSmall[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/103"}
{"code": "for (int i = 0; i < (10000 + 1); i++)\n  Path[i] = -1;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/georgevangelou/parallel_programming_with_OpenMP/3. Travelling salesman problem/tsp_rnd04/1"}
{"code": "for (int i = 0; i < Reps; i++)\n{\n  D.zeros();\n  assignew = Assign(data, D, P, n, cov_num, strt_num, level_num, omega, p);\n  n1 = -sum(assignew - 2);\n  n0 = n - n1;\n  diff(i) = ((-sum(data.row(cov_num + 1) % (assignew - 2))) / n1) - (sum(data.row(cov_num + 1) % (assignew - 1)) / n0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yexiaoqingruc/carat/caratOMP/src/All/17"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n  {\n    a[i][j] = (10 * i) + j;\n  }\n\n}\n\n", "pragma": "omp for schedule(static) collapse(1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/MolVlad/Parallel-Computing-OpenMP-MIPT/parallel_loops/src/par_3/0"}
{"code": "for (i = 0; i < sc_threads; i++)\n{\n  free_region_t(&memory[i]);\n  MEM_FREE(pseudo_rands[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/argon2_fmt_plug/2"}
{"code": "for (i = 0; i < (2 * N); i++)\n{\n  matrix[i][0] = 0;\n  matrix[i][1] = 0;\n  matrix[i][2] = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/littleblackfish/coilmd/src/helper/5"}
{"code": "for (i = 0; i < testIter; ++i)\n  hypre_CSRMatrixMatvec(1, A, x, 0, y);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/amgmk-omp/main/0"}
{"code": "for (j2 = 0; j2 < 4; j2++)\n  for (i = ji; i < ki; i++)\n  for (k2 = 0; k2 < 5; k2 += 2)\n  l++;\n\n\n\n", "pragma": "omp for reduction(+: l) collapse(3)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/testsuite/libgomp.c/loop-13/2"}
{"code": "for (i = 1; i < n; i++)\n{\n  for (j = 0; j < c; j++)\n  {\n    if ((j < weight[i]) || (total[!current][j] >= (total[!current][j - weight[i]] + profit[i])))\n    {\n      total[current][j] = total[!current][j];\n    }\n    else\n    {\n      total[current][j] = total[!current][j - weight[i]] + profit[i];\n    }\n\n  }\n\n  current = !current;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rish8795/Design-and-Implementation-of-Knapsack-0-1-problem-in-MPI-OpenMP-and-Hadoop/Knapsack_OpenMP/OpenMPKnapsack/4"}
{"code": "for (line = 0; line < nnz; ++line)\n{\n  fscanf(fin, \"%u%u%lf\", &j, &i, &val);\n  matrix->data[midx(matrix, i - 1, j - 1)] = val;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vuvko/nmf_mpi/common/matrix/7"}
{"code": "for (unsigned int i = 0; i < size; ++i)\n{\n  Vertex = rGeometry[i].Coordinates();\n  Vertices.push_back(Vertex);\n  Center += Vertex;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KratosMultiphysics/Kratos/applications/DelaunayMeshingApplication/custom_utilities/mesher_utilities/3"}
{"code": "for (int i = 0; i < (strlen(seq2) + 1); i++)\n{\n  mutant = seq2;\n  if (i != 0)\n  {\n    mutant = createMutant(mutant, i);\n  }\n\n  compare_Seqs_With_Offset(seqs_d, seq1, mutant, delta, i);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yonatanblum/Parallel-implementation-of-Sequence-Allignment-MPI-openMP/MPI_OpenMP_functions/0"}
{"code": "for (i = 0; i < nlm; i++)\n  free(landmarks[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bananamanda/open-slam-c/ekf-slam/simulator/2"}
{"code": "for (m = 0; m < nkernels; m++)\n{\n  for (w = 0; w < width; w++)\n  {\n    for (h = 0; h < height; h++)\n    {\n      double sum = 0.0;\n      for (c = 0; c < nchannels; c++)\n      {\n        for (x = 0; x < kernel_order; x++)\n        {\n          for (y = 0; y < kernel_order; y++)\n          {\n            sum += ((double) image[w + x][h + y][c]) * ((double) kernels[m][c][x][y]);\n          }\n\n        }\n\n        output[m][w][h] = (float) sum;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/slow-J/CS3014-Concurrent/Concurrent Systems/conv-harness/4"}
{"code": "for (i = 0; i < length; i++)\n{\n  j = (lrand48() % (length - i)) + i;\n  temp = intarray[i];\n  intarray[i] = intarray[j];\n  intarray[j] = temp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/XFAIL/rodinia_steamcluster/streamcluster_omp/1"}
{"code": "for (i = 0; i < 10; i++)\n  ++i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/clang-omp/clang/test/OpenMP/distribute_loop_messages/6"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  if ((visit[i] == false) && (dist[i] < min))\n  {\n    min = dist[i];\n    minNode = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nickpei/EECS224-High-Performance-Computing/Dijkstra_omp_v4/0"}
{"code": "for (int i = 0; i < n_thr; i++)\n  step += pool[i].size();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AGorchakov/BNB_test_prelimited/bnb_test_prelim/3"}
{"code": "for (j = 0; j < ((lastcol - firstcol) + 1); j++)\n{\n  d = x[j] - r[j];\n  sum = sum + (d * d);\n}\n\n", "pragma": "omp parallel for private(d) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tclin914/ConjugateGradient_openmp/CG_openmp/cg/5"}
{"code": "for (int i = 0; i < nbp; i++)\n{\n  const int tj = j;\n  j = cs->_Jnext[j][c];\n  c = cs->_Cnext[tj][c];\n  newPos->_Cases[j][16 * c]++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ingambe/Travail-Encadre-de-Recherche-Master-1/sources/minimax_graph_parallel_naif_padding/8"}
{"code": "for (i = 1; i < (block_height - 1); i++)\n{\n  for (j = 1; j < (block_width - 1); j++)\n  {\n    pk(i, j) -= tau * gk(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/KamalovRuslan/Parallel-Computations/Poisson/25"}
{"code": "for (i = 0; i < (sizeof(struct sapH_salt)); i++)\n  hash = ((hash << 5) + hash) ^ cp[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/sapH_fmt_plug/5"}
{"code": "for (int i = 0; i < graph->size; i++)\n{\n  counter = 0;\n  for (j = 0; j < graph->size; j++)\n  {\n    if (i == j)\n      continue;\n\n    if (arr[(size * i) + j])\n    {\n      graph->nodes[i]->degree++;\n      graph->nodes[i]->neighbours[counter] = graph->nodes[j];\n      counter++;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(numthreads) private(j,counter) if(graph->size > 2000)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/ReverseCuthillMcKee/src/secondaryFunctions/3"}
{"code": "for (int i = 5; i < 10; i++)\n  for (int j = 5; j < 10; j++)\n{\n  ocean[i][j].makeAnimal(1, i, j);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/JJ0421/Planet-Wa-Tor/Finale/11"}
{"code": "for (i = 0; i < n_rng; i++)\n{\n  fscanf_result = fscanf(fp, \"%u %u %u\", &fora, &tmp1, &tmp2);\n  if (fscanf_result < 3)\n  {\n    printf(\"Problem reading safeprime %d out of %d from file %s\\n\", i + 2, n_rng + 1, safeprimes_file);\n    return 1;\n  }\n\n  a[i] = fora;\n  x[i] = 0;\n  while (((x[i] == 0) | (((unsigned int) (x[i] >> 32)) >= (fora - 1))) | (((unsigned int) x[i]) >= 0xfffffffful))\n  {\n    xinit = ((xinit & 0xffffffffull) * begin) + (xinit >> 32);\n    x[i] = (unsigned int) floor((((double) ((unsigned int) xinit)) / ((double) 0x100000000)) * fora);\n    x[i] = x[i] << 32;\n    xinit = ((xinit & 0xffffffffull) * begin) + (xinit >> 32);\n    x[i] += (unsigned int) xinit;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/2"}
{"code": "for (int i = 0; i < x; i++)\n{\n  arr_2d[i] = &arr_1d[i * y];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/koksing456/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/OpenMP/OpenMP/parallel/7"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  degree = vertices->out_degree[v];\n  edge_idx = vertices->edges_idx[v];\n  for (j = edge_idx; j < (edge_idx + degree); j++)\n  {\n    u = EXTRACT_VALUE(sorted_edges_array[j]);\n    pageRanksNext[v] += riDividedOnDiClause[u];\n  }\n\n}\n\n", "pragma": "omp parallel for private(v,j,u,degree,edge_idx) schedule(dynamic, 1024) num_threads(arguments->ker_numThreads)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/algorithms/openmp/pageRank/1"}
{"code": "for (i = 0; i <= len1; i++)\n{\n  mat[i][0].score = i;\n  mat[i][0].prev = 0;\n  mat[i][0].arg1 = 0;\n  mat[i][0].arg2 = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/2"}
{"code": "for (i = 0; i < subprob_size; i++)\n{\n  a[i] = &rows[i * subprob_size];\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mcanalesmayo/jacobi-mpi/jacobi_par/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  ky = k / mx1;\n  kk = ky * mx1;\n  kl = ky - 1;\n  if (kl < 0)\n    kl += my1;\n\n  kl = kl * mx1;\n  kr = ky + 1;\n  if (kr >= my1)\n    kr -= my1;\n\n  kr = kr * mx1;\n  kx = k - (ky * mx1);\n  kxl = kx - 1;\n  if (kxl < 0)\n    kxl += mx1;\n\n  kxr = kx + 1;\n  if (kxr >= mx1)\n    kxr -= mx1;\n\n  ks[0] = kxr + kk;\n  ks[1] = kxl + kk;\n  ks[2] = kx + kr;\n  ks[3] = kxr + kr;\n  ks[4] = kxl + kr;\n  ks[5] = kx + kl;\n  ks[6] = kxr + kl;\n  ks[7] = kxl + kl;\n  nh = ihole[(2 * (ntmax + 1)) * k];\n  ncoff = 0;\n  ih = 0;\n  ist = 0;\n  j1 = 0;\n  for (ii = 0; ii < 8; ii++)\n  {\n    nboff = (idimp * npbmx) * ks[ii];\n    if (ii > 0)\n      ncoff = ncl[(ii - 1) + (8 * ks[ii])];\n\n    ip = ncl[ii + (8 * ks[ii])] - ncoff;\n    for (j = 0; j < ip; j++)\n    {\n      ih += 1;\n      if (ih <= nh)\n      {\n        j1 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        j1 = npp;\n        npp += 1;\n      }\n\n      if (j1 < nppmx)\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j1 + (nppmx * i)) + npoff] = ppbuff[((j + ncoff) + (npbmx * i)) + nboff];\n        }\n\n      }\n      else\n      {\n        ist = 1;\n      }\n\n    }\n\n  }\n\n  if (ist > 0)\n    *irc = j1 + 1;\n\n  if (ih < nh)\n  {\n    ip = nh - ih;\n    ii = nh;\n    nn = ihole[2 * (ii + ((ntmax + 1) * k))] - 1;\n    ih += 1;\n    j2 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n    for (j = 0; j < ip; j++)\n    {\n      j1 = (npp - j) - 1;\n      if (j1 == nn)\n      {\n        ii -= 1;\n        nn = ihole[2 * (ii + ((ntmax + 1) * k))] - 1;\n      }\n      else\n      {\n        for (i = 0; i < idimp; i++)\n        {\n          ppart[(j2 + (nppmx * i)) + npoff] = ppart[(j1 + (nppmx * i)) + npoff];\n        }\n\n        ih += 1;\n        j2 = ihole[2 * (ih + ((ntmax + 1) * k))] - 1;\n      }\n\n    }\n\n    npp -= ip;\n  }\n\n  kpic[k] = npp;\n}\n\n", "pragma": "omp parallel for private(i,j,k,ii,kk,npp,npoff,nboff,kx,ky,kl,kr,kxl,kxr,ih,nh,nn, ncoff,ist,j1,j2,ip,ks)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/vmbpush2/12"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((cur_solution->forest[a][i] && cur_solution->even[i]) && (even != i))\n  {\n    *next1 = ilist(i, next2);\n    if ((head = find_head_exposed(i, next1, avoid)) != NULL)\n    {\n      return head;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xelaadryth/Edmonds-Parallel/OMP/src/eba/0"}
{"code": "for (i = 1; i < (((L / NODESX) + 2) - 1); i++)\n{\n  j = ((L / NODESY) + 2) - 1;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = gre[i];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = gre[i];\n\n  j = 0;\n  ii = ((((i + j) % 2) * ((L / NODESX) + 2)) + i) / 2;\n  if (ii < (((L / NODESX) + 2) / 2))\n    whites[ii][j].data = gro[i];\n  else\n    blacks[ii - (((L / NODESX) + 2) / 2)][j].data = gro[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/145"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  printf(\"%i: Th %i sleeping\\n\", i, omp_get_thread_num());\n  sleep(i);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/epoell/openMP_examples_and_Matrix-Matrix-Multiplication/min_examples/5"}
{"code": "for (i = 1; i < dim; i++)\n  q += fabs(mat[i][0] / mat[i][i]);\n\n", "pragma": "omp for reduction(+:q)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/hpc-data/works/openmp_jacobi_column/jacobi_omp_col/0"}
{"code": "for (ssize_t i = 0; i < nx; ++i)\n{\n  bin = calc_bin(x[i], ax.nbins, ax.amin, ax.amax, norm);\n  values_ot[bin]++;\n}\n\n", "pragma": "#pragma omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/douglasdavis/pygram11/src/_backend/8"}
{"code": "for (i = 0; i < NUMBER; ++i)\n{\n  sum += i;\n  printf(\"Iteraction %d executed by thread %d, temporal sum value is %d\\n\", i, omp_get_thread_num(), sum);\n}\n\n", "pragma": "#pragma omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mmalinova/Parallel_programing_CSharp/LU6_reduction/Ex1/Ex1/0"}
{"code": "for (i = 0; i < count; i++)\n{\n  setup_des_key(saved_key[i], &ks);\n  DES_ecb_encrypt((DES_cblock *) challenge, (DES_cblock *) output[i], &ks, 1);\n}\n\n", "pragma": "omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/NETLM_fmt_plug/0"}
{"code": "for (size_t j = 0; j < a->nr_vertices; ++j)\n  da[i + ai_off][j + aj_off] = MIN(da[i + ai_off][j + aj_off], db[i + bi_off][k + bj_off] + dc[k + ci_off][j + cj_off]);\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dimosr/Parallel_Programming/Project3/graph/1"}
{"code": "for (int i = 0; i < 64; ++i)\n{\n  color id = {.red = randomNumber(0.f, 0.15f) + 0.1f, .green = randomNumber(0.f, 0.14f) + 0.0f, .blue = randomNumber(0.f, 0.16f) + 0.0f};\n  floatvector initialPosition = {.x = (1024 / 2) - randomNumber(50, 320), .y = (1024 / 2) - randomNumber(50, 320)};\n  initialPosition.x = (((i / 2) % 2) == 0) ? (initialPosition.x) : (1024 - initialPosition.x);\n  initialPosition.y = (i < (64 / 2)) ? (initialPosition.y) : (1024 - initialPosition.y);\n  floatvector positionToBlackHole = {.x = initialPosition.x - (1024 / 2), .y = initialPosition.y - (1024 / 2)};\n  float distance = (0.06 + randomNumber(-0.01f, 0.01f)) / sqrt((positionToBlackHole.x * positionToBlackHole.x) + (positionToBlackHole.y * positionToBlackHole.y));\n  floatvector initialVelocity = {.x = distance * (-positionToBlackHole.y), .y = distance * positionToBlackHole.x};\n  if ((i % 2) == 0)\n  {\n    initialVelocity.x = -initialVelocity.x;\n    initialVelocity.y = -initialVelocity.y;\n  }\n\n  satellite tmpSatelite = {.identifier = id, .position = initialPosition, .velocity = initialVelocity};\n  satellites[i] = tmpSatelite;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/TheDK0309/Parallel_computing/Part1/parallel/5"}
{"code": "for (i = 0; i < rows; i++)\n{\n  for (j = 0; j < cols; j++)\n  {\n    (cout << a[(i * cols) + j]) << \" \";\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/miguelrochajr/ParallelProgramming/Final_Project/Tests/parallel/my_feed/0"}
{"code": "for (i = 0; i < (100000000 - 2); i++)\n{\n  if (final_array[i] > final_array[i + 1])\n  {\n    sorted = 'N';\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ErnestL1n/OpenMP-Practice-In-C/training6/b0521229-train6/7"}
{"code": "for (int i = 0; i < n; i++)\n{\n  mypi = mypi + f(i * h);\n}\n\n", "pragma": "omp parallel for reduction (+:mypi) num_threads ( 6 )", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/filipecosta90/Parallel-Computing-Paradigms/aula3/exec1/0"}
{"code": "for (int i = 1; i <= COUNT_OF_DOTS; i++)\n{\n  double x = xDistribution(gen);\n  double y = yDistribution(gen);\n  if (y <= f(x))\n    countOfInnerPoints++;\n\n}\n\n", "pragma": "\t#pragma omp parallel for reduction(+: countOfInnerPoints)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pamugk/hpc/openmp2/main/0"}
{"code": "for (uint8_t i = 1; i < nLevels; i++)\n  downsampleConvolve(outPyr[i + 1], outPyr[i], &width, &height, filter);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/stranck/RealTimeLLF/src/OpenMP/openmp/2"}
{"code": "for (i = 0; i < cs.encrypted_keyblob_size; i++)\n  cs.encrypted_keyblob[i] = (atoi16[ARCH_INDEX(p[i * 2])] * 16) + atoi16[ARCH_INDEX(p[(i * 2) + 1])];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/dmg_fmt_plug/0"}
{"code": "for (size_t i = 0; i < num_threads; ++i)\n{\n  file_id_maps.emplace_back();\n  dictionaries.emplace_back();\n  word_count_maps.emplace_back();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/colby-j-wise/cpptext/src/processor/1"}
{"code": "for (k = 0; k < n; k++)\n{\n  if (k != q)\n  {\n    x_diff = p[q].pos[X] - p[k].pos[X];\n    y_diff = p[q].pos[Y] - p[k].pos[Y];\n    z_diff = p[q].pos[Z] - p[k].pos[Z];\n    dist = sqrt(((x_diff * x_diff) + (y_diff * y_diff)) + (z_diff * z_diff));\n    dist_cubed = (dist * dist) * dist;\n    forces[q][X] -= (((G * p[q].mass) * p[k].mass) / dist_cubed) * x_diff;\n    forces[q][Y] -= (((G * p[q].mass) * p[k].mass) / dist_cubed) * y_diff;\n    forces[q][Z] -= (((G * p[q].mass) * p[k].mass) / dist_cubed) * z_diff;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bergolho1337/OpenMP/Two-n-Body/Parallel-Basic/src/twoBody/4"}
{"code": "for (i = 0; i < count; i++)\n  if (!memcmp(binary, crypt_key[i], 16))\n  return 1;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/nt2_fmt_plug/4"}
{"code": "for (int i = 0; i < SIZE; i++)\n{\n  arr[i] = gen(generator);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Gerrytty/parallel-programming-course/openMP/task10/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  sum += a[i];\n  a[i] = sum;\n}\n\n", "pragma": "#pragma omp for schedule(static, 1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AshkanGoharfar/Openmp_prefix_sum_Hillis_Steele_algorithm/inclusive_exclusive/inclusive_exclusive/0"}
{"code": "for (totalMem *= 0.5, logTableSize = 0, TableSize = 1; totalMem >= 1.0; totalMem *= 0.5, logTableSize++, TableSize <<= 1)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bryantclc/MyRandomAccess/omp/single_node_lcg/4"}
{"code": "for (long i = 0; i < nr_points; i++)\n{\n  closest_centroid = 0;\n  d_min = distance(&dataset[i * nr_dimensions], &centroids[0], nr_dimensions);\n  for (int j = 1; j < nr_centroids; j++)\n  {\n    d_temp = distance(&dataset[i * nr_dimensions], &centroids[j * nr_dimensions], nr_dimensions);\n    if (d_temp < d_min)\n    {\n      closest_centroid = j;\n      d_min = d_temp;\n    }\n\n  }\n\n  printf(\"%d has \", closest_centroid);\n  print_point(&dataset[i * nr_dimensions], nr_dimensions);\n  points_accumulator[closest_centroid]++;\n  for (int j = 0; j < nr_dimensions; j++)\n  {\n    coordinates_accumulator[(closest_centroid * nr_dimensions) + j] += dataset[(i * nr_dimensions) + j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/claudioMontanari/Middleware_project/kmeans_openmp_mpi/benchmark_mpi/14"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    A[i][j] = (rand() % 10) + 1;\n    B[i][j] = (rand() % 10) + 1;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prplcld/arrays_and_openmp/OpenMP/OpenMP/OpenMP/0"}
{"code": "for (i = 0; i < (1 << 19); i++)\n  prv_buff1[i] = 0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/IS/is/36"}
{"code": "for (idx = 0; idx < 5; idx++)\n  if (arr[(3 * 5) + idx] != (idx < 1))\n  abort();\nelse\n  arr[(3 * 5) + idx] = 0;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-12/9"}
{"code": "for (int i = 0; i < localDataset.size(); i++)\n  for (int j = 0; j < total_values; j++)\n  localSum[memberships[i]].values[j] += localDataset[i].values[j];\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Akshay-jain22/K-Means-Clustering/Parallel/Node/14"}
{"code": "for (int jj = HALO_PAD; jj < (yMax - HALO_PAD); ++jj)\n{\n  for (int kk = xMax - HALO_PAD; kk < ((xMax - HALO_PAD) + depth); ++kk)\n  {\n    int bufIndex = (kk - (xMax - HALO_PAD)) + ((jj - HALO_PAD) * depth);\n    field[(jj * xMax) + kk] = buffer[bufIndex];\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UK-MAC/TeaLeaf_OpenMP4/ext_pack_kernel/5"}
{"code": "for (int i = 0; i < N; ++i)\n{\n  result += vector[i] * vector[i];\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:result)  ", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/paulpaulych/parallel_labs/Lab2/var1/2"}
{"code": "for (i = 1; i < 1; i++)\n  for (j = 0; j < 1; j++)\n  ys[(i * 1) + j] = ys[((i - 1) * 1) + j] + ycell;\n\n\n", "pragma": "omp parallel for num_threads(NUMTHREADS) collapse(2) schedule (static,1) default(none) private(i,j) shared(ys, ycell)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/patschris/Heat2D/grad1612_hybrid_heat/1"}
{"code": "for (int k = 0; k < num_clusters; ++k)\n{\n  sum_of_x_per_cluster[k] = 0.0;\n  sum_of_y_per_cluster[k] = 0.0;\n  num_points_in_cluster[k] = 0;\n}\n\n", "pragma": "omp parallel for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg42819/kmeans-openmp/kmeans_omp1_impl/1"}
{"code": "for (i = 0; i < numInputs; i++)\n{\n  if (strcmp(&arrayPtr[i * 15], searchStr) == 0)\n  {\n    posFoundD = i;\n    processFoundD = tid;\n  }\n\n}\n\n", "pragma": "omp for schedule( dynamic, sliceSize)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/carlislk/OpenMP-ArraySearch/Program/1"}
{"code": "for (i = 0; i < p->ntloop; i++)\n  if (sequences_match(s, p->tloop[i].seq, d + 2))\n  return &p->tloop[i].val;\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/frna-omp/frna/1"}
{"code": "for (k = 0; k < omp_get_num_threads(); ++k)\n{\n  {\n    debug_printf(\"Thread %d: captured affinity = %s\\n\", omp_get_thread_num(), buf);\n    for (j = 0; j < num_procs; ++j)\n    {\n      debug_printf(\"Thread %d: ids[%d] = %d ids2[%d] = %d\\n\", omp_get_thread_num(), j, ids[j], j, ids2[j]);\n      if (!(ids[j] == ids2[j]))\n      {\n        fprintf(stderr, \"error: %s: %d: ids[j] == ids2[j]\\n\", \"/tmp/tmp580zhmhg.c\", 121);\n        exit(1);\n      }\n\n      ;\n    }\n\n  }\n}\n\n", "pragma": "omp for schedule(static) ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mbrukman/llvm-openmp/runtime/test/affinity/format/affinity_values/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  b[i] = (z[i] = 0);\n  a[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/JacksianYun/openmp_tutorial/011_nowait_data_race_condition/2"}
{"code": "for (unsigned int i = 0; i < numNodes; ++i)\n{\n  for (unsigned int j = 0; j < i; ++j)\n  {\n    pathMatrix[(i * numNodes) + j] = i;\n    pathMatrix[(j * numNodes) + i] = j;\n  }\n\n  pathMatrix[(i * numNodes) + i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/floydwarshall-omp/main/3"}
{"code": "for (int n_op = 0; n_op < count; n_op++)\n{\n  const double *value = &data0[5 * n_op];\n  int *count = &arg1_l;\n  for (int v = 0; v < NVAR; v++)\n  {\n    if (value[v] > 0.0)\n    {\n      (*count)++;\n    }\n\n  }\n\n}\n\n", "pragma": "  #pragma omp distribute parallel for schedule(static,1) reduction(+:arg1_l)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp4/count_non_zeros_omp4kernel_func/0"}
{"code": "for (int i = 0; i < SIZE; i++)\n  ar[i] = i % MAX_VAL;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PositronPiercer/OpenMP-codes/histogram_update/0"}
{"code": "for (uint32_t i = 0; i < this->rows; i++)\n{\n  for (uint32_t j = 0; j < this->cols; j++)\n  {\n    this->operator()(i, j) -= rhs(i, j);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tmaklin/rcgpar/src/Matrix_omp/6"}
{"code": "for (i = 0; i < used_matrix_size; i++)\n{\n  mat_mul[i] = (double *) calloc(used_matrix_size * used_matrix_size, sizeof(double));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/abodh/Parallel_matrix_mutiplication/mat_mat_parallel/1"}
{"code": "for (int i = 0; i < v.size(); i++)\n{\n  for (int j = 0; j < buckets; j++)\n  {\n    if ((v[i] >= (j * bucket_interval)) && (v[i] <= ((j + 1) * bucket_interval)))\n    {\n      bs[omp_get_thread_num()][j].push_back(v[i]);\n      break;\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for shared(bs, v, bucket_interval) schedule(static, v.size()/threads)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Ahmore/bucket-sort-openMP/src/sort3/0"}
{"code": "for (k = 0; k < mxy1; k++)\n{\n  noff = k / mx1;\n  moff = my * noff;\n  noff = mx * (k - (mx1 * noff));\n  v_noff = _mm_set1_epi32(noff);\n  v_moff = _mm_set1_epi32(moff);\n  npp = kpic[k];\n  npoff = (idimp * nppmx) * k;\n  nn = ((mx < (nx - noff)) ? (mx) : (nx - noff)) + 1;\n  mm = ((my < (ny - moff)) ? (my) : (ny - moff)) + 1;\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&fxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sfxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  for (j = 0; j < mm; j++)\n  {\n    for (i = 0; i < nn; i++)\n    {\n      v_at = _mm_loadu_ps(&bxy[4 * ((i + noff) + (nxv * (j + moff)))]);\n      _mm_storeu_ps(&sbxy[4 * (i + (mxv * j))], v_at);\n    }\n\n  }\n\n  nps = 4 * (npp / 4);\n  sum1 = 0.0;\n  v_sum1 = _mm_set1_pd(0.0);\n  for (j = 0; j < nps; j += 4)\n  {\n    v_x = _mm_load_ps(&ppart[j + npoff]);\n    v_y = _mm_load_ps(&ppart[(j + nppmx) + npoff]);\n    v_nn = _mm_cvttps_epi32(v_x);\n    v_mm = _mm_cvttps_epi32(v_y);\n    v_dxp = _mm_sub_ps(v_x, _mm_cvtepi32_ps(v_nn));\n    v_dyp = _mm_sub_ps(v_y, _mm_cvtepi32_ps(v_mm));\n    v_nn = _mm_sub_epi32(v_nn, v_noff);\n    v_mm = _mm_sub_epi32(v_mm, v_moff);\n    v_it = _mm_mul_epu32(v_mxv, _mm_srli_si128(v_mm, 4));\n    v_mm = _mm_mul_epu32(v_mm, v_mxv);\n    v_mm = _mm_add_epi32(v_mm, _mm_slli_si128(v_it, 4));\n    v_nn = _mm_slli_epi32(_mm_add_epi32(v_nn, v_mm), 2);\n    v_amx = _mm_sub_ps(v_one, v_dxp);\n    v_amy = _mm_sub_ps(v_one, v_dyp);\n    _mm_store_si128((int *) ll, v_nn);\n    nn = ll[0];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 0);\n    a = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    e = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 0);\n    nn += 4;\n    a = _mm_add_ps(a, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    e = _mm_add_ps(e, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 0);\n    a = _mm_mul_ps(a, v_at);\n    e = _mm_mul_ps(e, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 0);\n    a = _mm_add_ps(a, _mm_mul_ps(v_dx, v_at));\n    e = _mm_add_ps(e, _mm_mul_ps(v_dy, v_at));\n    nn = ll[1];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 85);\n    b = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    f = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 85);\n    nn += 4;\n    b = _mm_add_ps(b, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    f = _mm_add_ps(f, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 85);\n    b = _mm_mul_ps(b, v_at);\n    f = _mm_mul_ps(f, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 85);\n    b = _mm_add_ps(b, _mm_mul_ps(v_dx, v_at));\n    f = _mm_add_ps(f, _mm_mul_ps(v_dy, v_at));\n    nn = ll[2];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 170);\n    c = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    g = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 170);\n    nn += 4;\n    c = _mm_add_ps(c, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    g = _mm_add_ps(g, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 170);\n    c = _mm_mul_ps(c, v_at);\n    g = _mm_mul_ps(g, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 170);\n    c = _mm_add_ps(c, _mm_mul_ps(v_dx, v_at));\n    g = _mm_add_ps(g, _mm_mul_ps(v_dy, v_at));\n    nn = ll[3];\n    v_at = _mm_shuffle_ps(v_amx, v_amx, 255);\n    d = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn]));\n    h = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn]));\n    mm = nn + (4 * mxv);\n    v_dx = _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm]));\n    v_dy = _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm]));\n    v_at = _mm_shuffle_ps(v_dxp, v_dxp, 255);\n    nn += 4;\n    d = _mm_add_ps(d, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[nn])));\n    h = _mm_add_ps(h, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[nn])));\n    mm += 4;\n    v_dx = _mm_add_ps(v_dx, _mm_mul_ps(v_at, _mm_load_ps(&sfxy[mm])));\n    v_dy = _mm_add_ps(v_dy, _mm_mul_ps(v_at, _mm_load_ps(&sbxy[mm])));\n    v_at = _mm_shuffle_ps(v_amy, v_amy, 255);\n    d = _mm_mul_ps(d, v_at);\n    h = _mm_mul_ps(h, v_at);\n    v_at = _mm_shuffle_ps(v_dyp, v_dyp, 255);\n    d = _mm_add_ps(d, _mm_mul_ps(v_dx, v_at));\n    h = _mm_add_ps(h, _mm_mul_ps(v_dy, v_at));\n    _MM_TRANSPOSE4_PS(a, b, c, d);\n    _MM_TRANSPOSE4_PS(e, f, g, h);\n    v_dx = _mm_mul_ps(a, v_qtmh);\n    v_dy = _mm_mul_ps(b, v_qtmh);\n    v_dz = _mm_mul_ps(c, v_qtmh);\n    a = _mm_add_ps(v_dx, _mm_load_ps(&ppart[(j + (2 * nppmx)) + npoff]));\n    b = _mm_add_ps(v_dy, _mm_load_ps(&ppart[(j + (3 * nppmx)) + npoff]));\n    c = _mm_add_ps(v_dz, _mm_load_ps(&ppart[(j + (4 * nppmx)) + npoff]));\n    v_at = _mm_add_ps(_mm_mul_ps(a, a), _mm_mul_ps(b, b));\n    v_at = _mm_add_ps(v_at, _mm_mul_ps(c, c));\n    v_d = _mm_cvtps_pd(v_at);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    v_it = _mm_srli_si128((int) v_at, 8);\n    v_d = _mm_cvtps_pd((int) v_it);\n    v_sum1 = _mm_add_pd(v_sum1, v_d);\n    e = _mm_mul_ps(v_qtmh, e);\n    f = _mm_mul_ps(v_qtmh, f);\n    g = _mm_mul_ps(v_qtmh, g);\n    v_vx = _mm_mul_ps(e, e);\n    v_vy = _mm_mul_ps(f, f);\n    v_vz = _mm_mul_ps(g, g);\n    v_at = _mm_add_ps(_mm_add_ps(v_vx, v_vy), v_vz);\n    d = _mm_div_ps(v_two, _mm_add_ps(v_one, v_at));\n    h = _mm_mul_ps(v_half, _mm_sub_ps(v_one, v_at));\n    v_vx = _mm_mul_ps(_mm_add_ps(h, v_vx), a);\n    v_vy = _mm_mul_ps(_mm_add_ps(h, v_vy), b);\n    v_vz = _mm_mul_ps(_mm_add_ps(h, v_vz), c);\n    h = _mm_mul_ps(e, f);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_add_ps(h, g), b));\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_sub_ps(h, g), a));\n    h = _mm_mul_ps(e, g);\n    v_vx = _mm_add_ps(v_vx, _mm_mul_ps(_mm_sub_ps(h, f), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_add_ps(h, f), a));\n    h = _mm_mul_ps(f, g);\n    v_vy = _mm_add_ps(v_vy, _mm_mul_ps(_mm_add_ps(h, e), c));\n    v_vz = _mm_add_ps(v_vz, _mm_mul_ps(_mm_sub_ps(h, e), b));\n    v_vx = _mm_add_ps(v_dx, _mm_mul_ps(v_vx, d));\n    v_vy = _mm_add_ps(v_dy, _mm_mul_ps(v_vy, d));\n    v_vz = _mm_add_ps(v_dz, _mm_mul_ps(v_vz, d));\n    v_dx = _mm_add_ps(v_x, _mm_mul_ps(v_vx, v_dtc));\n    v_dy = _mm_add_ps(v_y, _mm_mul_ps(v_vy, v_dtc));\n    if (ipbc == 2)\n    {\n      v_at = _mm_cmplt_ps(v_dx, v_edgelx);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dx, v_edgerx));\n      v_x = _mm_and_ps(v_at, v_x);\n      v_dx = _mm_add_ps(_mm_andnot_ps(v_at, v_dx), v_x);\n      v_dxp = _mm_and_ps(v_at, v_vx);\n      v_vx = _mm_sub_ps(_mm_andnot_ps(v_at, v_vx), v_dxp);\n      v_at = _mm_cmplt_ps(v_dy, v_edgely);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dy, v_edgery));\n      v_y = _mm_and_ps(v_at, v_y);\n      v_dy = _mm_add_ps(_mm_andnot_ps(v_at, v_dy), v_y);\n      v_dyp = _mm_and_ps(v_at, v_vy);\n      v_vy = _mm_sub_ps(_mm_andnot_ps(v_at, v_vy), v_dyp);\n    }\n    else\n      if (ipbc == 3)\n    {\n      v_at = _mm_cmplt_ps(v_dx, v_edgelx);\n      v_at = _mm_or_ps(v_at, _mm_cmpge_ps(v_dx, v_edgerx));\n      v_x = _mm_and_ps(v_at, v_x);\n      v_dx = _mm_add_ps(_mm_andnot_ps(v_at, v_dx), v_x);\n      v_dxp = _mm_and_ps(v_at, v_vx);\n      v_vx = _mm_sub_ps(_mm_andnot_ps(v_at, v_vx), v_dxp);\n    }\n\n\n    _mm_store_ps(&ppart[j + npoff], v_dx);\n    _mm_store_ps(&ppart[(j + nppmx) + npoff], v_dy);\n    _mm_store_ps(&ppart[(j + (2 * nppmx)) + npoff], v_vx);\n    _mm_store_ps(&ppart[(j + (3 * nppmx)) + npoff], v_vy);\n    _mm_store_ps(&ppart[(j + (4 * nppmx)) + npoff], v_vz);\n  }\n\n  for (j = nps; j < npp; j++)\n  {\n    x = ppart[j + npoff];\n    y = ppart[(j + nppmx) + npoff];\n    nn = x;\n    mm = y;\n    dxp = x - ((float) nn);\n    dyp = y - ((float) mm);\n    nm = 4 * ((nn - noff) + (mxv * (mm - moff)));\n    amx = 1.0f - dxp;\n    amy = 1.0f - dyp;\n    nn = nm;\n    dx = amx * sfxy[nn];\n    dy = amx * sfxy[nn + 1];\n    dz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx = amy * ((dxp * sfxy[mm]) + dx);\n    dy = amy * ((dxp * sfxy[mm + 1]) + dy);\n    dz = amy * ((dxp * sfxy[mm + 2]) + dz);\n    nn += 4 * mxv;\n    acx = amx * sfxy[nn];\n    acy = amx * sfxy[nn + 1];\n    acz = amx * sfxy[nn + 2];\n    mm = nn + 4;\n    dx += dyp * ((dxp * sfxy[mm]) + acx);\n    dy += dyp * ((dxp * sfxy[mm + 1]) + acy);\n    dz += dyp * ((dxp * sfxy[mm + 2]) + acz);\n    nn = nm;\n    ox = amx * sbxy[nn];\n    oy = amx * sbxy[nn + 1];\n    oz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox = amy * ((dxp * sbxy[mm]) + ox);\n    oy = amy * ((dxp * sbxy[mm + 1]) + oy);\n    oz = amy * ((dxp * sbxy[mm + 2]) + oz);\n    nn += 4 * mxv;\n    acx = amx * sbxy[nn];\n    acy = amx * sbxy[nn + 1];\n    acz = amx * sbxy[nn + 2];\n    mm = nn + 4;\n    ox += dyp * ((dxp * sbxy[mm]) + acx);\n    oy += dyp * ((dxp * sbxy[mm + 1]) + acy);\n    oz += dyp * ((dxp * sbxy[mm + 2]) + acz);\n    dx *= qtmh;\n    dy *= qtmh;\n    dz *= qtmh;\n    acx = ppart[(j + (2 * nppmx)) + npoff] + dx;\n    acy = ppart[(j + (3 * nppmx)) + npoff] + dy;\n    acz = ppart[(j + (4 * nppmx)) + npoff] + dz;\n    sum1 += ((acx * acx) + (acy * acy)) + (acz * acz);\n    omxt = qtmh * ox;\n    omyt = qtmh * oy;\n    omzt = qtmh * oz;\n    omt = ((omxt * omxt) + (omyt * omyt)) + (omzt * omzt);\n    anorm = 2.0f / (1.0f + omt);\n    omt = 0.5f * (1.0f - omt);\n    rot4 = omxt * omyt;\n    rot7 = omxt * omzt;\n    rot8 = omyt * omzt;\n    rot1 = omt + (omxt * omxt);\n    rot5 = omt + (omyt * omyt);\n    rot9 = omt + (omzt * omzt);\n    rot2 = omzt + rot4;\n    rot4 -= omzt;\n    rot3 = (-omyt) + rot7;\n    rot7 += omyt;\n    rot6 = omxt + rot8;\n    rot8 -= omxt;\n    vx = ((((rot1 * acx) + (rot2 * acy)) + (rot3 * acz)) * anorm) + dx;\n    vy = ((((rot4 * acx) + (rot5 * acy)) + (rot6 * acz)) * anorm) + dy;\n    vz = ((((rot7 * acx) + (rot8 * acy)) + (rot9 * acz)) * anorm) + dz;\n    dx = x + (vx * dtc);\n    dy = y + (vy * dtc);\n    if (ipbc == 2)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n      if ((dy < edgely) || (dy >= edgery))\n      {\n        dy = y;\n        vy = -vy;\n      }\n\n    }\n    else\n      if (ipbc == 3)\n    {\n      if ((dx < edgelx) || (dx >= edgerx))\n      {\n        dx = x;\n        vx = -vx;\n      }\n\n    }\n\n\n    ppart[j + npoff] = dx;\n    ppart[(j + nppmx) + npoff] = dy;\n    ppart[(j + (2 * nppmx)) + npoff] = vx;\n    ppart[(j + (3 * nppmx)) + npoff] = vy;\n    ppart[(j + (4 * nppmx)) + npoff] = vz;\n  }\n\n  _mm_store_pd(&dd[0], v_sum1);\n  for (j = 1; j < 2; j++)\n  {\n    dd[0] += dd[j];\n  }\n\n  sum2 += sum1 + dd[0];\n}\n\n", "pragma": "omp parallel for private(i,j,k,noff,moff,npp,npoff,nps,nn,mm,nm,x,y,vx,vy,vz,dxp,dyp,amx, amy,dx,dy,dz,ox,oy,oz,acx,acy,acz,omxt,omyt,omzt,omt,anorm,rot1,rot2, rot3,rot4,rot5,rot6,rot7,rot8,rot9,sum1,v_noff,v_moff,v_nn,v_mm,v_it, v_x,v_y,v_vx,v_vy,v_vz,v_dxp,v_dyp,v_amx,v_amy,v_dx,v_dy,v_dz,v_at, v_d,v_sum1,a,b,c,d,e,f,g,h,ll,dd,sfxy,sbxy) reduction(+:sum2)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_vectorization/vmbpic2/ssembpush2/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = rand() % 10;\n  B[i] = rand() % 10;\n  C[i] = rand() % 10;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Toskor/openMP_lab/lab_5_openMP/0"}
{"code": "for (int k = 0; k < D; k++)\n{\n  for (int i = 0; i < items; i++)\n  {\n    dim[k] += root->data.at(i)->dim[k];\n  }\n\n  dim[k] = dim[k] / items;\n  root->pivot[k] = dim[k];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kate-mcardle/tree-based-parallel-kNN/src-balltree/balltree/5"}
{"code": "for (i = 0; i < dim; i++)\n{\n  x[i] = libre[i];\n  for (j = 0; j < i; j++)\n    x[i] -= L[i][j] * x[j];\n\n  x[i] = x[i] / L[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gdimitriu/parallel_works/numeric/solve-sec/ver-2.0/crout-omp/3"}
{"code": "for (uint b = 0; b < molKind.bondList.count; ++b)\n{\n  double molLength = vecs.Get(b).Length();\n  energy += forcefield.bonds.Calc(molKind.bondList.kinds[b], molLength);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/6"}
{"code": "for (y = 1; y < (rows - 1); y++)\n{\n  for (x = 1; x < (columns - 1); x++)\n  {\n    printf(\"%c\", *((grid + (y * columns)) + x));\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KeyC0de/GameOfLife_Serial_OpenMp_Cuda/gol_serial_openmp_alt_1dArr/6"}
{"code": "for (__i__ = 0; __i__ < __num_target_devices__; __i__++)\n{\n  args[i].a = a;\n  args[i].n = n;\n  __offloading_info__.offloadings[i].args = &args[i];\n  __offloading_info__.offloadings[i].kernel_launcher = OUT__3__5904__launcher;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gssrinivasan/offomp/benchmarks/axpy/axpy_ompacc/0"}
{"code": "for (size_t l = 0; l < weights_layout[i - 1]; ++l)\n  weights[i][j][l] = stod(values[l]);\n\n", "pragma": "                #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Denkisen/OpenMP_NNetwork/Networks/MLP/5"}
{"code": "for (int t = 0; t < (rows - 1); t++)\n{\n  temp = src;\n  src = dst;\n  dst = temp;\n  kernel(t, cols, src, dst);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MCAPro2015/OpenMP_MCA_Project/libopenmp-OpenUH/mca_benchmarks/pathfinder/pathfinder/0"}
{"code": "for (i_imopVarPre75 = 0; i_imopVarPre75 < dims[2][0]; i_imopVarPre75++)\n{\n  ii = (((((i_imopVarPre75 + 1) + xstart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n  ii2 = ii * ii;\n  for (j = 0; j < dims[2][1]; j++)\n  {\n    jj = (((((j + 1) + ystart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n    ij2 = (jj * jj) + ii2;\n    for (k = 0; k < dims[2][2]; k++)\n    {\n      kk = (((((k + 1) + zstart[2]) - 2) + (64 / 2)) % 64) - (64 / 2);\n      indexmap[k][j][i_imopVarPre75] = (kk * kk) + ij2;\n    }\n\n  }\n\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/runner/NPB3.0-omp-C-master/FT/ft/7"}
{"code": "for (int i = 0; i < snpCount; i++)\n{\n  causalCount += configure_x[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jxzb1988/Parallel_CAVIAR/PostCal/2"}
{"code": "for (int i = 0; i < x; i++)\n{\n  for (int j = 0; j < y; j++)\n  {\n    arr[i][j] = rand() % 5;\n    if (i == j)\n    {\n      arr[i][j] *= -1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/koksing456/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/Solving-Massive-Linear-Equations/OpenMP/OpenMP/parallel/8"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    U[0][i] = A[0][i];\n    L[i][0] = A[i][0] / U[0][0];\n    double sum = 0.;\n    for (int k = 0; k < i; k++)\n    {\n      sum += L[i][k] * U[k][j];\n    }\n\n    U[i][j] = A[i][j] - sum;\n    if (i > j)\n    {\n      L[j][i] = 0;\n    }\n    else\n    {\n      sum = 0;\n      for (int k = 0; k < i; k++)\n      {\n        sum += L[j][k] * U[k][i];\n      }\n\n      L[j][i] = (A[j][i] - sum) / U[i][i];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for firstprivate (j, k, sum) lastprivate(i) shared(A, L, U)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/6_openmp/2"}
{"code": "for (i = 0; i < 1024; i += 16)\n  for (j = 0; j < 1024; j += 16)\n  for (k = 0; k < 1024; k += 16)\n  for (y = i; y < (i + 16); y++)\n  for (x = j; x < (j + 16); x++)\n  for (z = k; z < (k + 16); z++)\n  C[y][x] += A[y][z] * B[z][x];\n\n\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/victorrebli/ProgrammingParallelCudaOpenmp/openmp_sequencial_double/1"}
{"code": "for (i = 0; i < rows; i++)\n{\n  matrix[i] = (int *) malloc((sizeof(int)) * cols);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jcFW/CITS3402/Assignment1/OpenMP/1"}
{"code": "for (int j = 0; j < 256; j++)\n{\n  new_color[j] = shift_color(j);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vanerk03/Auto-contrast/hw5/0"}
{"code": "for (int i = 0; i < clusters; i++)\n{\n  oldclustermeansx[i] = arr[i][0];\n  oldclustermeansy[i] = arr[i][1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Udbhavbisarya23/OpenMP-Codes/Lab7-Clustering/clusters/1"}
{"code": "for (i = 0; i < 4; i++)\n{\n  for (j = 0; j < 4; j++)\n  {\n    for (k = 0; k < 4; k++)\n    {\n      c[i][j] += a[i][k] * b[k][j];\n    }\n\n    int test;\n    test++;\n    thread_id = omp_get_thread_num();\n    printf(\"teste: %d thread_id %d calculou c[%d][%d] = %d\\n\", test, thread_id, i, j, c[i][j]);\n  }\n\n}\n\n", "pragma": "omp parallel for private (j, k) num_threads(4)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/soareswallace/openMP/for/0"}
{"code": "for (int i = 0; i < size_target; i++)\n{\n  W[0][0] += tar_c[i].x * cor_c[i].x;\n  W[0][1] += tar_c[i].y * cor_c[i].x;\n  W[0][2] += tar_c[i].z * cor_c[i].x;\n  W[1][0] += tar_c[i].x * cor_c[i].y;\n  W[1][1] += tar_c[i].y * cor_c[i].y;\n  W[1][2] += tar_c[i].z * cor_c[i].y;\n  W[2][0] += tar_c[i].x * cor_c[i].z;\n  W[2][1] += tar_c[i].y * cor_c[i].z;\n  W[2][2] += tar_c[i].z * cor_c[i].z;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vinayakvivek/Iterative-Closest-Point/src/icp/6"}
{"code": "for (i = twice_jump; i <= x; i += twice_jump)\n  input[i - 1] = input[i - 1] + input[(i - jumper) - 1];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/inplace/1"}
{"code": "for (i = 0; i <= (public.in_mod_elem - 1); i += 1)\n{\n  in_final_sum = in_final_sum + d_in[i];\n}\n\n", "pragma": "omp parallel for private (i) reduction (+:in_final_sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/rodinia_3.1/openmp/heartwall/kernel/0"}
{"code": "for (int i = 0; i < numParticles; i++)\n{\n  if (particleType[i] == dummyWall)\n  {\n    particleBC[i] = other;\n    continue;\n  }\n\n  if (pndSmall[i] < betaPnd)\n  {\n    particleBC[i] = surface;\n  }\n  else\n  {\n    particleBC[i] = inner;\n  }\n\n  if (freeSurfType == PND_NEIGH)\n  {\n    if ((pndSmall[i] < betaPnd) && (numNeigh[i] < betaNeigh))\n    {\n      particleBC[i] = surface;\n    }\n    else\n    {\n      particleBC[i] = inner;\n    }\n\n  }\n  else\n    if (freeSurfType == PND_NPCD)\n  {\n    if (particleBC[i] == surface)\n    {\n      if ((numNeigh[i] > 4) && (npcdDeviation2[i] < delta2))\n      {\n        particleBC[i] = inner;\n      }\n\n    }\n\n  }\n  else\n    if (freeSurfType == PND_ARC)\n  {\n    double normalXi = normal[i * 3];\n    double normalYi = normal[(i * 3) + 1];\n    double normalZi = normal[(i * 3) + 2];\n    double norm2 = ((normalXi * normalXi) + (normalYi * normalYi)) + (normalZi * normalZi);\n    if (((pndi[i] >= betaPnd) && (numNeigh[i] >= betaNeigh)) && (norm2 <= normThreshold2))\n    {\n      particleBC[i] = inner;\n    }\n    else\n    {\n      double posXi = pos[i * 3];\n      double posYi = pos[(i * 3) + 1];\n      double posZi = pos[(i * 3) + 2];\n      double posMirrorXi = mirrorParticlePos[i * 3];\n      double posMirrorYi = mirrorParticlePos[(i * 3) + 1];\n      double posMirrorZi = mirrorParticlePos[(i * 3) + 2];\n      if (norm2 > 1.0e-8)\n      {\n        double norm = sqrt(norm2);\n        normalXi /= norm;\n        normalYi /= norm;\n        normalZi /= norm;\n      }\n      else\n      {\n        normalXi = 0.0;\n        normalYi = 0.0;\n        normalZi = 0.0;\n      }\n\n      double Rref_i[9];\n      double normaliw[3];\n      double normalMod2;\n      normaliw[0] = 0.5 * (posXi - posMirrorXi);\n      normaliw[1] = 0.5 * (posYi - posMirrorYi);\n      normaliw[2] = 0.5 * (posZi - posMirrorZi);\n      normalMod2 = ((normaliw[0] * normaliw[0]) + (normaliw[1] * normaliw[1])) + (normaliw[2] * normaliw[2]);\n      if (normalMod2 > 1.0e-8)\n      {\n        double normalMod = sqrt(normalMod2);\n        normaliw[0] /= normalMod;\n        normaliw[1] /= normalMod;\n        normaliw[2] /= normalMod;\n      }\n      else\n      {\n        normaliw[0] = 0.0;\n        normaliw[1] = 0.0;\n        normaliw[2] = 0;\n      }\n\n      Rref_i[0] = 1.0 - ((2.0 * normaliw[0]) * normaliw[0]);\n      Rref_i[1] = 0.0 - ((2.0 * normaliw[0]) * normaliw[1]);\n      Rref_i[2] = 0.0 - ((2.0 * normaliw[0]) * normaliw[2]);\n      Rref_i[3] = 0.0 - ((2.0 * normaliw[1]) * normaliw[0]);\n      Rref_i[4] = 1.0 - ((2.0 * normaliw[1]) * normaliw[1]);\n      Rref_i[5] = 0.0 - ((2.0 * normaliw[1]) * normaliw[2]);\n      Rref_i[6] = 0.0 - ((2.0 * normaliw[2]) * normaliw[0]);\n      Rref_i[7] = 0.0 - ((2.0 * normaliw[2]) * normaliw[1]);\n      Rref_i[8] = 1.0 - ((2.0 * normaliw[2]) * normaliw[2]);\n      double normalMirrorXi = ((Rref_i[0] * normalXi) + (Rref_i[1] * normalYi)) + (Rref_i[2] * normalZi);\n      double normalMirrorYi = ((Rref_i[3] * normalXi) + (Rref_i[4] * normalYi)) + (Rref_i[5] * normalZi);\n      double normalMirrorZi = ((Rref_i[6] * normalXi) + (Rref_i[7] * normalYi)) + (Rref_i[8] * normalZi);\n      double normMirror2 = ((normalMirrorXi * normalMirrorXi) + (normalMirrorYi * normalMirrorYi)) + (normalMirrorZi * normalMirrorZi);\n      if (normMirror2 > 1.0e-8)\n      {\n        double normMirror = sqrt(normMirror2);\n        normalMirrorXi /= normMirror;\n        normalMirrorYi /= normMirror;\n        normalMirrorZi /= normMirror;\n      }\n      else\n      {\n        normalMirrorXi = 0.0;\n        normalMirrorYi = 0.0;\n        normalMirrorZi = 0.0;\n      }\n\n      int ix;\n      int iy;\n      int iz;\n      bucketCoordinates(ix, iy, iz, posXi, posYi, posZi);\n      int minZ = (iz - 1) * ((int) (dim - 2.0));\n      int maxZ = (iz + 1) * ((int) (dim - 2.0));\n      for (int jz = minZ; jz <= maxZ; jz++)\n      {\n        for (int jy = iy - 1; jy <= (iy + 1); jy++)\n        {\n          for (int jx = ix - 1; jx <= (ix + 1); jx++)\n          {\n            int jb = ((jz * numBucketsXY) + (jy * numBucketsX)) + jx;\n            int j = firstParticleInBucket[jb];\n            if (j == (-1))\n              continue;\n\n            double plx;\n            double ply;\n            double plz;\n            getPeriodicLengths(jb, plx, ply, plz);\n            while (true)\n            {\n              double v0ij;\n              double v1ij;\n              double v2ij;\n              double v0imj;\n              double v1imj;\n              double v2imj;\n              double dstij2;\n              double dstimj2;\n              sqrDistBetweenParticles(j, posXi, posYi, posZi, v0ij, v1ij, v2ij, dstij2, plx, ply, plz);\n              sqrDistBetweenParticles(j, posMirrorXi, posMirrorYi, posMirrorZi, v0imj, v1imj, v2imj, dstimj2, plx, ply, plz);\n              if ((dstij2 < reS2) && ((dstij2 < dstimj2) || (wallType == PARTICLE)))\n              {\n                if (j != i)\n                {\n                  double v0inj;\n                  double v1inj;\n                  double v2inj;\n                  double dstinj2;\n                  sqrDistBetweenParticles(j, posXi + (partDist * normalXi), posYi + (partDist * normalYi), posZi + (partDist * normalZi), v0inj, v1inj, v2inj, dstinj2, plx, ply, plz);\n                  double rijn = ((v0ij * normalXi) + (v1ij * normalYi)) + (v2ij * normalZi);\n                  double ang = acos(rijn / sqrt(dstij2));\n                  if ((dstij2 >= dstThreshold2) && (dstinj2 < hThreshold2))\n                  {\n                    particleBC[i] = inner;\n                    goto endloop;\n                  }\n                  else\n                    if ((dstij2 < dstThreshold2) && (ang < thetaArc))\n                  {\n                    particleBC[i] = inner;\n                    goto endloop;\n                  }\n                  else\n                  {\n                    particleBC[i] = surface;\n                  }\n\n\n                }\n\n              }\n\n              if (wallType == POLYGON)\n              {\n                if (((dstij2 < reS2) && (dstimj2 < reS2)) && (dstij2 < dstimj2))\n                {\n                  if (j != i)\n                  {\n                    double v0imnj;\n                    double v1imnj;\n                    double v2imnj;\n                    double dstimnj2;\n                    sqrDistBetweenParticles(j, posMirrorXi + (partDist * normalMirrorXi), posMirrorYi + (partDist * normalMirrorYi), posMirrorZi + (partDist * normalMirrorZi), v0imnj, v1imnj, v2imnj, dstimnj2, plx, ply, plz);\n                    double rimjn = ((v0imj * normalMirrorXi) + (v1imj * normalMirrorYi)) + (v2imj * normalMirrorZi);\n                    double angm = acos(rimjn / sqrt(dstimj2));\n                    if ((dstimj2 >= dstThreshold2) && (dstimnj2 < hThreshold2))\n                    {\n                      particleBC[i] = inner;\n                      goto endloop;\n                    }\n                    else\n                      if ((dstimj2 < dstThreshold2) && (angm < thetaArc))\n                    {\n                      particleBC[i] = inner;\n                      goto endloop;\n                    }\n                    else\n                    {\n                      particleBC[i] = surface;\n                    }\n\n\n                  }\n\n                }\n\n              }\n\n              j = nextParticleInSameBucket[j];\n              if (j == (-1))\n                break;\n\n            }\n\n          }\n\n        }\n\n      }\n\n      endloop:\n      ;\n\n    }\n\n  }\n\n\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rubensamarojr/polymps/src/MpsParticle/48"}
{"code": "for (i = 0; i < MemorySize; i++)\n{\n  h_idataCPU[i] = (i & 0xFF) + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/aligned-types-omp/main/1"}
{"code": "for (int j = 0; j < N; j += SMALL_N)\n{\n  int sub_N = (SMALL_N < (N - j)) ? (SMALL_N) : (N - j);\n  compute(A + ((i * lda) + (k * 4)), B + ((j * lda) + k), C + ((j * lda) + i), sub_M, sub_N, sub_K, lda);\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/xingyousong/Multithreaded-Matrix-Multiply-CS267-HW1-Part2/not-so-good4/4"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  float prevPageRank = stats->pageRanks[v];\n  float nextPageRank = stats->base_pr + (stats->damp * pageRanksNext[v]);\n  stats->pageRanks[v] = nextPageRank;\n  pageRanksNext[v] = 0.0f;\n  double error = fabs(nextPageRank - prevPageRank);\n  error_total += error / graph->num_vertices;\n  if (error >= arguments->epsilon)\n  {\n    activeVertices++;\n  }\n\n}\n\n", "pragma": "omp parallel for private(v) shared(arguments, pageRanksNext, stats) reduction(+ : error_total, activeVertices)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/pageRank/4"}
{"code": "for (int i = 0; i < no_of_nodes; i++)\n{\n  h_cost[i] = -1;\n  h_cost_ref[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/bfs-omp/bfs/5"}
{"code": "for (int i = 0; i < (Nx * Ny); i++)\n{\n  U[i] = 0.0;\n  V[i] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/raihaan123/HPC/CPP/archived/ReactionDiffusion/0"}
{"code": "for (int i = 0; i < G->size; i++)\n{\n  G->nodes[i] = (Node *) malloc(sizeof(Node));\n  G->nodes[i] = R->nodes[i];\n  G->nodes[i]->label = i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/z3y50n/ReverseCuthillMcKee/src/functions/4"}
{"code": "for (int i = 0; i < command_line_args.seq_num; i++)\n{\n  for (int j = 0; j < command_line_args.seq_len; j++)\n  {\n    (cout << m_arrays[i][j]) << ' ';\n  }\n\n  cout << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dimserk/Parallels/DDZ_A/main/3"}
{"code": "for (size_t s = 0; s < n_samples; s++)\n{\n  t_layer_outputs[0] = inputs[s];\n  for (size_t l = 1; l < n_layers; l++)\n  {\n    double *bias = biases[l - 1];\n    double *weight = weights[l - 1];\n    double *prev_output = t_layer_outputs[l - 1];\n    double *output = t_layer_outputs[l];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double z = bias[n];\n      for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n      {\n        z += prev_output[prev_n] * weight[(prev_n * this_nodes) + n];\n      }\n\n      output[n] = 1 / (1 + exp(-z));\n    }\n\n  }\n\n  double *sample_expected = expected[s];\n  double *last_delta_bias = delta_biases[s][n_layers - 2];\n  double *last_delta_weight = delta_weights[s][n_layers - 2];\n  double *output = t_layer_outputs[n_layers - 1];\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    double output_val = output[n];\n    t_prev_deltas[n] = ((sample_expected[n] - output_val) * output_val) * (1 - output_val);\n  }\n\n  for (size_t n = 0; n < last_nodes; n++)\n  {\n    last_delta_bias[n] = t_prev_deltas[n];\n  }\n\n  double *last_prev_output = t_layer_outputs[n_layers - 2];\n  for (size_t prev_n = 0; prev_n < last_prev_nodes; prev_n++)\n  {\n    for (size_t n = 0; n < last_nodes; n++)\n    {\n      last_delta_weight[(prev_n * last_nodes) + n] = last_prev_output[prev_n] * t_prev_deltas[n];\n    }\n\n  }\n\n  if ((i == half_iters) && (s == half_samples))\n  {\n    gettimeofday(&e_bck_out, 0);\n    gettimeofday(&s_bck_hid, 0);\n  }\n\n  for (size_t l = n_layers - 2; l > 0; l--)\n  {\n    double *delta_bias = delta_biases[s][l - 1];\n    double *delta_weight = delta_weights[s][l - 1];\n    double *output = t_layer_outputs[l];\n    double *prev_output = t_layer_outputs[l - 1];\n    size_t next_nodes = nodes_per_layer[l + 1];\n    size_t this_nodes = nodes_per_layer[l];\n    size_t prev_nodes = nodes_per_layer[l - 1];\n    double *weight_next = weights[l];\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      double error = 0;\n      for (size_t next_n = 0; next_n < next_nodes; next_n++)\n      {\n        error += t_prev_deltas[next_n] * weight_next[(n * next_nodes) + next_n];\n      }\n\n      double output_val = output[n];\n      t_deltas[n] = (error * output_val) * (1 - output_val);\n    }\n\n    for (size_t n = 0; n < this_nodes; n++)\n    {\n      delta_bias[n] = t_deltas[n];\n    }\n\n    for (size_t prev_n = 0; prev_n < prev_nodes; prev_n++)\n    {\n      for (size_t n = 0; n < this_nodes; n++)\n      {\n        delta_weight[(prev_n * this_nodes) + n] = prev_output[prev_n] * t_deltas[n];\n      }\n\n    }\n\n    double *temp = t_deltas;\n    t_deltas = t_prev_deltas;\n    t_prev_deltas = temp;\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Lut99/NeuralNetwork/src/lib/NeuralNetwork/NeuralNetwork_OMP_CPU3/7"}
{"code": "for (int i = 1; i < argc; i++)\n{\n  if (strcmp(argv[i], \"-n\") == 0)\n  {\n    N = atol(argv[++i]) * 1024;\n  }\n  else\n    if (strcmp(argv[i], \"-s\") == 0)\n  {\n    MIN_SORT_SIZE = atol(argv[++i]);\n  }\n  else\n    if (strcmp(argv[i], \"-m\") == 0)\n  {\n    MIN_MERGE_SIZE = atol(argv[++i]);\n  }\n  else\n  {\n    fprintf(stderr, \"Usage: %s [-n vector_size -s MIN_SORT_SIZE -m MIN_MERGE_SIZE] -c CUTOFF\\n\", argv[0]);\n    fprintf(stderr, \"       -n to specify the size of the vector (in Kelements) to sort (default 32768)\\n\");\n    fprintf(stderr, \"       -s to specify the size of the vector (in elements) that breaks recursion in the sort phase (default 1024)\\n\");\n    fprintf(stderr, \"       -m to specify the size of the vector (in elements) that breaks recursion in the merge phase (default 1024)\\n\");\n    fprintf(stderr, \"       -c to specify the cut off recursion level to stop task generation in OpenMP (default 16)\\n\");\n    return 1;\n  }\n\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/andyfratello/PAR/Laboratori/Lab4/codesLab4/multisort-optional2/4"}
{"code": "for (int i = 0; i < (SUBKEYS_LEN - 1); i++)\n{\n  result_e.quadword = 0x0;\n  result_e = e_bit_selection(r[i]);\n  block64 keyXORebit;\n  keyXORebit.quadword = result_e.quadword ^ subkeys[count - i].quadword;\n  afterBox.nibble._7 = boxS8(keyXORebit);\n  afterBox.nibble._6 = boxS7(keyXORebit);\n  afterBox.nibble._5 = boxS6(keyXORebit);\n  afterBox.nibble._4 = boxS5(keyXORebit);\n  afterBox.nibble._3 = boxS4(keyXORebit);\n  afterBox.nibble._2 = boxS3(keyXORebit);\n  afterBox.nibble._1 = boxS2(keyXORebit);\n  afterBox.nibble._0 = boxS1(keyXORebit);\n  afterBox = permutationP(afterBox);\n  l[i + 1].doubleWord = r[i].doubleWord;\n  r[i + 1].doubleWord = l[i].doubleWord ^ afterBox.doubleWord;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arthurhoch/des-cipher-openmp/src/des/4"}
{"code": "for (int i = 1; i < ntasks; ++i)\n{\n  int to_recv = total_images / ntasks;\n  int start = to_recv;\n  if ((i + 1) == ntasks)\n  {\n    to_recv = (total_images % ntasks) ? (to_recv + (total_images % ntasks)) : (to_recv);\n  }\n\n  MPI_Recv((encoded_images_sz + start) + vec_step, to_recv, (MPI_Datatype) 0x4c000408, i, 0, 1, (MPI_Status *) 1);\n  for (int j = 0; j < to_recv; ++j)\n  {\n    int current_image_idx = (start + vec_step) + j;\n    encoded_images[current_image_idx] = malloc(encoded_images_sz[current_image_idx] * (sizeof(unsigned char)));\n    MPI_Recv(encoded_images[current_image_idx], encoded_images_sz[current_image_idx], (MPI_Datatype) 0x4c00010d, i, 0, 1, (MPI_Status *) 1);\n  }\n\n  vec_step += to_recv;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/craciunoiuc/multiprocessor-structures/image_IO_MPI/7"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  for (int j = 0; j < num_splines; j++)\n    eval_UBspline_3d_z_vgh(norm_splines[j], x, y, z, &norm_vals[j], &norm_grads[3 * j], &norm_hess[9 * j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/16"}
{"code": "for (int i = 0; i < g->N; i++)\n{\n  node *cur = elem_at(&g->vertices, i);\n  payload *data = cur->data;\n  if (data->in_mis)\n    1(\"%d \", cur->label);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/mis/5"}
{"code": "for (int i = 0; i < (dim * dim); i++)\n{\n  self_mat[i] = ((1 - a) * self_mat[i]) + (a * mat[i]);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kirillston/OpenMP-MPI/mpp/matop/0"}
{"code": "for (r = 0; r < nranks; ++r)\n{\n  size_t size = (whole_size / weighted_nranks) * weights[r];\n  MPI_Status status;\n  if (r == 0)\n  {\n    size += radius * nx_ny_pad;\n    memcpy(data_ptr, my_data, size * (sizeof(float)));\n  }\n  else\n    if (r < (nranks - 1))\n  {\n    MPI_Recv(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1, &status);\n  }\n  else\n  {\n    size += radius * nx_ny_pad;\n    MPI_Recv(data_ptr, size, (MPI_Datatype) 0x4c00040a, r, 0, 1, &status);\n  }\n\n\n  data_ptr += size;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/erwold/3d-Finite-difference/iso-3dfd_main/2"}
{"code": "for (i = nyi - 1; i < nyt; i++)\n{\n  joff = (ndim * nxhd) * i;\n  kmr = nxy / nx;\n  for (j = 1; j < nxhh; j++)\n  {\n    t3 = cimagf(sct[kmr * j]) + (crealf(sct[kmr * j]) * _Complex_I);\n    for (jj = 0; jj < ndim; jj++)\n    {\n      t2 = conjf(f[(jj + (ndim * (nxh - j))) + joff]);\n      t1 = f[(jj + (ndim * j)) + joff] + t2;\n      t2 = (f[(jj + (ndim * j)) + joff] - t2) * t3;\n      f[(jj + (ndim * j)) + joff] = t1 + t2;\n      f[(jj + (ndim * (nxh - j))) + joff] = conjf(t1 - t2);\n    }\n\n  }\n\n  for (jj = 0; jj < ndim; jj++)\n  {\n    f[(jj + (ndim * nxhh)) + joff] = 2.0 * conjf(f[(jj + (ndim * nxhh)) + joff]);\n    f[jj + joff] = (crealf(f[jj + joff]) + cimagf(f[jj + joff])) + ((crealf(f[jj + joff]) - cimagf(f[jj + joff])) * _Complex_I);\n  }\n\n  for (j = 0; j < nxh; j++)\n  {\n    j1 = (mixup[j] - 1) / nrxb;\n    if (j < j1)\n    {\n      for (jj = 0; jj < ndim; jj++)\n      {\n        t1 = f[(jj + (ndim * j1)) + joff];\n        f[(jj + (ndim * j1)) + joff] = f[(jj + (ndim * j)) + joff];\n        f[(jj + (ndim * j)) + joff] = t1;\n      }\n\n    }\n\n  }\n\n  ns = 1;\n  for (l = 0; l < indx1; l++)\n  {\n    ns2 = ns + ns;\n    km = nxhh / ns;\n    kmr = km * nrx;\n    for (k = 0; k < km; k++)\n    {\n      k1 = ns2 * k;\n      k2 = k1 + ns;\n      for (j = 0; j < ns; j++)\n      {\n        j1 = j + k1;\n        j2 = j + k2;\n        t1 = conjf(sct[kmr * j]);\n        for (jj = 0; jj < ndim; jj++)\n        {\n          t2 = t1 * f[(jj + (ndim * j2)) + joff];\n          f[(jj + (ndim * j2)) + joff] = f[(jj + (ndim * j1)) + joff] - t2;\n          f[(jj + (ndim * j1)) + joff] += t2;\n        }\n\n      }\n\n    }\n\n    ns = ns2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i,j,k,l,ns,ns2,km,kmr,k1,k2,jj,j1,j2,joff,t1,t2,t3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp/mdpic2/mdpush2/11"}
{"code": "for (j = 0; j < innerreps; j++)\n{\n  delay(delaylength);\n  aaaa += 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lapesd/libgomp/src/libgomp/benchs/EPCC/syncbench/3"}
{"code": "for (int i = last_sends[rank]; i < mpi_sends[rank].size(); i++)\n  if (mpi_sends[rank][i].done == 0)\n{\n  MPI_Type_size(mpi_sends[rank][i].datatype, &s);\n  mpi_sends[rank][i].dt_size = s;\n  sizes[rank] += s * mpi_sends[rank][i].count;\n  ns[rank]++;\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/5"}
{"code": "for (n = 0; n < 27; n++)\n  CommunicateThisDir[n] = faces[n] + edges[n];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/AMDComputeLibraries/OpenMPApps/hpgmg-mp4/finite-volume/source/level/18"}
{"code": "for (int i = 0; !(!i); i++)\n  c[i] = a[i];\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/llvm/tools/clang/test/OpenMP/for_loop_messages/16"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    ru1 = rho_i[i][j][k];\n    uu = us[i][j][k];\n    vv = vs[i][j][k];\n    ww = ws[i][j][k];\n    ac = speed[i][j][k];\n    ac2inv = ainv[i][j][k] * ainv[i][j][k];\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = (c2 * ac2inv) * (((((qs[i][j][k] * r1) - (uu * r2)) - (vv * r3)) - (ww * r4)) + r5);\n    t2 = (bt * ru1) * ((uu * r1) - r2);\n    t3 = ((bt * ru1) * ac) * t1;\n    rhs[0][i][j][k] = r1 - t1;\n    rhs[1][i][j][k] = (-ru1) * ((ww * r1) - r4);\n    rhs[2][i][j][k] = ru1 * ((vv * r1) - r3);\n    rhs[3][i][j][k] = (-t2) + t3;\n    rhs[4][i][j][k] = t2 + t3;\n  }\n\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,ru1 ,uu ,vv ,ww ,ac ,ac2inv ,r1 ,r2 ,r3 ,r4 ,t1 ,t2 ,t3 ,c2 ,bt ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/155"}
{"code": "for (i = 0; i < x; i++)\n  input[i][0] = input1[i];\n\n", "pragma": "\t#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ankesh007/Parallel-Programming/Programming Assignment 1/Old/inplace_no_rec/3"}
{"code": "for (i = 0; i < dim; i++)\n{\n  g[i] = (((2 * sqrt(quartic(x, dim))) * 2) * (i + 1)) * x[i];\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mazury/Parallel-Programming-C-Project/conjugate-gradient-openmp/0"}
{"code": "for (i = 0; i < matrix.rows; i++)\n{\n  int elements = matrix.ia[i + 1] - matrix.ia[i];\n  int elements2 = matrix2.ia[i + 1] - matrix2.ia[i];\n  int m1seen = 0;\n  int m2seen = 0;\n  int pos = matrix.ia[i];\n  int pos2 = matrix2.ia[i];\n  while ((m1seen != elements) || (m2seen != elements2))\n  {\n    if (m1seen == elements)\n    {\n      while (m2seen < elements2)\n      {\n        result_local[i].elements[result_local[i].count].y = matrix2.ja[pos2];\n        result_local[i].elements[result_local[i].count].x = i;\n        result_local[i].elements[result_local[i].count++].value.i = matrix2.nnz.i[pos2++];\n        m2seen++;\n      }\n\n      break;\n    }\n    else\n      if (m2seen == elements2)\n    {\n      while (m1seen < elements)\n      {\n        result_local[i].elements[result_local[i].count].y = matrix.ja[pos];\n        result_local[i].elements[result_local[i].count].x = i;\n        result_local[i].elements[result_local[i].count++].value.i = matrix.nnz.i[pos++];\n        m1seen++;\n      }\n\n      break;\n    }\n    else\n    {\n      if (matrix.ja[pos] < matrix2.ja[pos2])\n      {\n        result_local[i].elements[result_local[i].count].y = matrix.ja[pos];\n        result_local[i].elements[result_local[i].count].x = i;\n        result_local[i].elements[result_local[i].count++].value.i = matrix.nnz.i[pos++];\n        m1seen++;\n      }\n      else\n        if (matrix2.ja[pos2] < matrix.ja[pos])\n      {\n        result_local[i].elements[result_local[i].count].y = matrix2.ja[pos2];\n        result_local[i].elements[result_local[i].count].x = i;\n        result_local[i].elements[result_local[i].count++].value.i = matrix2.nnz.i[pos2++];\n        m2seen++;\n      }\n      else\n      {\n        result_local[i].elements[result_local[i].count].y = matrix2.ja[pos2];\n        result_local[i].elements[result_local[i].count].x = i;\n        result_local[i].elements[result_local[i].count++].value.i = matrix.nnz.i[pos++] + matrix2.nnz.i[pos2++];\n        m1seen++;\n        m2seen++;\n      }\n\n\n    }\n\n\n  }\n\n  totalcount += result_local[i].count;\n}\n\n", "pragma": "omp parallel for reduction(+:totalcount) shared(matrix,matrix2) num_threads(param.threads)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brucehow/matrix/routines/4"}
{"code": "for (i = 0; i < 32768; i++)\n  vec[i] = i + 1;\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NamanGangwani/Cluster-Computing/Program 4/Pgm4/1"}
{"code": "for (k = 0; k < 128; k++)\n  for (l = k + 1; l < 128; l++)\n  for (i = 0; i < 128; i++)\n  for (j = 0; j < 128; j++)\n  C[k][l] += 0.5 * ((A[l][i][j] * B[k][i][j]) + (A[k][i][j] * B[l][i][j]));\n\n\n\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/smallsimple/MatrixMultiplicationParallelization/PA2/PA2-BoboShi 2/PP2/PA2-Prob2-bobo/0"}
{"code": "for (int i = 0; i < ColN; i++)\n  Result[i] = 0.0;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/valerii-martell/High-Performance-Computing/Lab4_MPI_CustomDataTypes/Linalg/3"}
{"code": "for (int i = 0; i < N; i++)\n{\n  C[i] = A[i + 10] + B[i];\n}\n\n", "pragma": "#pragma omp target parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/examples/tools/asan/global_buffer_overflow/openmp/vecadd-GBO/2"}
{"code": "for (int i = 0; i < station->nr; ++i)\n{\n  if (((idx_station[i].x > (-1)) && (idx_station[i].y > (-1))) && (idx_station[i].z > (-1)))\n  {\n    Rhxx[ktime + (i * station->nt)] = GetVal(station->pos_recep[i], \"Hxx\");\n    Rhxy[ktime + (i * station->nt)] = GetVal(station->pos_recep[i], \"Hxy\");\n    Rhxz[ktime + (i * station->nt)] = (-1.0) * GetVal(station->pos_recep[i], \"Hxz\");\n    Rhyy[ktime + (i * station->nt)] = GetVal(station->pos_recep[i], \"Hyy\");\n    Rhyz[ktime + (i * station->nt)] = (-1.0) * GetVal(station->pos_recep[i], \"Hyz\");\n    Rhzz[ktime + (i * station->nt)] = GetVal(station->pos_recep[i], \"Hzz\");\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/armandoespindola/wave3Dfd/src/sdm/25"}
{"code": "for (i = 0; i < n; i++)\n{\n  printf(\"%lf\\n\", x[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mGrad10/Parallel-Gaussian/gaussian/4"}
{"code": "for (i = 0; i < m1; i++)\n{\n  temp1 = i * n1;\n  for (j = 0; j < n2; j++)\n  {\n    sum = 0.0;\n    temp2 = j * m2;\n    for (k = 0; k < n1; k++)\n    {\n      sum += M_1[temp1 + k] * M_2_T[temp2 + k];\n    }\n\n    result[(i * n2) + j] = sum;\n  }\n\n}\n\n", "pragma": "omp parallel for private(i, j, k, sum, temp1, temp2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arneish/parallel-PCA-openmp/lab2_omp/1"}
{"code": "for (int i = 0; i < n_walkers; i++)\n{\n  fprintf(walkOPEN, \"%f \", A[i]);\n  fprintf(walkOPEN, \"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/juandapradam12/JuanPrada_Ejercicio30/walkOPEN/3"}
{"code": "for (i = 0; i < NCELLS; i++)\n  cell(i).scale(scaleFactor);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/37"}
{"code": "for (i = 0; i < (1 << 16); i++)\n{\n  key_array[--key_buff_ptr_global[key_buff2[i]]] = key_buff2[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/amannougrahiya/imop-compiler/tests/testis/3"}
{"code": "for (i = 0; i < 20; i++)\n{\n  for (j = 0; j < 20; j++)\n  {\n    if (0 > 0)\n    {\n      printf(\"Play Game\\ti = %d, j = %d, threadId = %d \\n\", i, j, omp_get_thread_num());\n    }\n\n    threads_matrix[i][j] = omp_get_thread_num();\n    destMatrix[i][j] = getValue(srcMatrix, i, j);\n  }\n\n}\n\n", "pragma": "omp parallel for private(j) shared(destMatrix) num_threads(NUM_OF_THREADS) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/cbalkig/Parallel-Processing-Assignment-2/parallel_v1/0"}
{"code": "for (i = 0; i < mDIM; i++)\n{\n  for (j = 0; j < nDIM; j++)\n  {\n    for (k = 0; k < lDIM; k++)\n    {\n      matmul_tile(tileA[(i * lDIM) + k], tileB[(k * nDIM) + j], tileC[(i * nDIM) + j]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/him-28/OpenMP-Test/lab-01-matmul/.config/matmul.1/0"}
{"code": "for (short it = 6; it <= 20; it -= -4)\n{\n  a += 1;\n  aa += 1;\n}\n\n", "pragma": "  #pragma omp target parallel for if(target: n>10)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/flang-cavium/flang7/tools/flang-driver/test/OpenMP/target_parallel_for_codegen/3"}
{"code": "for (i = 0; i < imax; i++)\n{\n  for (j = 0; j < jmax; j++)\n    a[k++] = ((float) rand()) / ((float) RAND_MAX);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daseibert2/OpenMP_Exercises/collapse_timing/0"}
{"code": "for (i = 0; i < leny; i++)\n{\n  sum = 0.0;\n  ;\n  aij = ai;\n  jx = kx;\n  #pragma code_align(16)\n  for (j = 0; j < lenx; j++)\n  {\n    a_elem = a[aij];\n    x_elem = x[jx];\n    prod = a_elem * x_elem;\n    sum = sum + prod;\n    aij += incaij;\n    jx += incx;\n  }\n\n  tmp1 = sum * alpha_i;\n  y_elem = y[iy];\n  tmp2 = y_elem * beta_i;\n  tmp1 = tmp1 + tmp2;\n  y[iy] = tmp1;\n  ai += incai;\n  iy += incy;\n}\n\n", "pragma": "omp parallel for schedule(static,4) default(none) reduction(+:sum) shared(a_i,x_i,y_i) private(i,aij,jx,j,a_elem,x_elem,prod,ai,yi,tmp1,tmp2,y_elem)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bgin/Guided_Missile_Simulation/xblas/BLAS_dgemv_x/6"}
{"code": "for (i = 0; i < rows; ++i)\n{\n  for (j = 0; j < cols; ++j)\n  {\n    fscanf(pf, \"%s\", k);\n    a[(i * cols) + j] = strtof(k, 0);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EliseuPHP/PAD/OpenMP/src/exerc/3"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if ((i != 0) && ((i % 10) == 0))\n    cout << endl;\n\n  (cout << \"\\t\") << arr[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ninadkheratkar/Openmp-Programs/Openmp Programs/Parallel_binary_search_openmp/1"}
{"code": "for (unsigned i = 0; i < ((sizeof(locks)) / (sizeof(*locks))); ++i)\n{\n  omp_destroy_lock(&locks[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Yowgf/delta-stepping/lib/main/appliance/Alg/deltaStepping/2"}
{"code": "for (j = 0; j < M; ++j)\n{\n  for (i = 0; i < M; ++i)\n  {\n    cij = C[(j * M) + i];\n    for (k = 0; k < M; ++k)\n    {\n      cij += A[(k * M) + i] * B[(j * M) + k];\n    }\n\n    C[(j * M) + i] = cij;\n  }\n\n}\n\n", "pragma": "omp parallel for private(cij) collapse(2) schedule(static)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SumedhArani/Parallel-Computing/matmul/basic/0"}
{"code": "for (i = 0; i < m; i++)\n{\n  b[i] = 2.0;\n  a[i] = -1.0;\n  c[i] = -1.0;\n  d[i] = 1.0;\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP4.0/Codes/Q2omp/0"}
{"code": "for (int i = 0; i < ARRAY_SIZE; i++)\n  a[i] = rand() % 10;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture15/globalSum_reductionClause/globalSum_reductionClause/0"}
{"code": "for (u = 6; u > 1; u -= 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/18"}
{"code": "for (int k = y_min - depth; k <= (y_max + depth); k++)\n{\n  #pragma ivdep\n  for (int j = 1; j <= depth; j++)\n  {\n    density1[FTNREF2D(x_max + j, k, x_max + 4, x_min - 2, y_min - 2)] = density1[FTNREF2D((x_max + 1) - j, k, x_max + 4, x_min - 2, y_min - 2)];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UoB-HPC/CloverLeaf-OpenMP4/ext_update_halo/7"}
{"code": "for (int i = 0; i < p; ++i)\n  prows[i] *= columns;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/rdb987/2DConvolution/src/hpc_conv_hybrid/4"}
{"code": "for (int i = 1; i < numprocs; i++)\n{\n  int begin = (i - 1) * distributerow;\n  int end = begin + distributerow;\n  if (i == (numprocs - 1))\n    end = n;\n\n  int count = (end - begin) * n;\n  MPI_Send((void *) A[begin], count, MPI_FLOAT, i, 0, MPI_COMM_WORLD);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/MPI_omp_AVX_row/5"}
{"code": "for (int ii = 0; ii < omp_mats.size(); ii++)\n{\n  omp_mats.at(ii).setTo(0);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HenryZh47/lidar-depth-image-renderer/src/lidar_depth_renderer/0"}
{"code": "for (i = 0; i < 256; i++)\n{\n  if (fscanf(ColMap, \" %3d %3d %3d\", &cm[0][i], &cm[1][i], &cm[2][i]) < 3)\n  {\n    fprintf(stderr, \"Error reading colour map at line %d: r, g, b =\", i + 1);\n    fprintf(stderr, \" %3.3d %3.3d %3.3d\\n\", cm[0][i], cm[1][i], cm[2][i]);\n    exit(1);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/aparangement/course_MPI_OpenMP_Cineca_PoliMi_Yan/openmp-force-compt0/10"}
{"code": "for (i = 0; i < NGRUPOS; i++)\n{\n  for (j = 0; j < (NCAR / 2); j++)\n  {\n    cent[i][j] = (rand() % 10000) / 100.0;\n    cent[i][j + (NCAR / 2)] = cent[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iyan22/Genetics/vparallel/gengrupos_p/5"}
{"code": "for (int i = 0; i < 11; i++)\n  for (int j = 0; j < 38; j++)\n  if (glider_gun[i][j])\n  cur_img(i + x, y - j) = couleur;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tseignette/lejeudelavie/src/vie/11"}
{"code": "for (int i = 0; i < nF; i++)\n{\n  free((*R)[i]);\n  free((*newR)[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/catamaro/CPD_Project/OpenMP/matFact-omp/13"}
{"code": "for (int i = 0; i < 16; i++)\n{\n  free(p[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/9"}
{"code": "for (size_t i = 0; i < n; i++)\n{\n  a[i] = 1e-3;\n  b[i] = 1e-3;\n}\n\n", "pragma": "\t#pragma omp parallel for schedule(dynamic,10000)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/SerpentByte/omp_learn/dot_pdt/0"}
{"code": "for (m = 0; m < 5; m++)\n{\n  sum_local[m] = 0.0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/LU/l2norm/1"}
{"code": "for (size_t i = 0; i < localRes.size(); i++)\n{\n  descriptors.push_back(localRes[i].descriptor);\n  blurArgs.push_back(localRes[i].blurArgs);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LucaLovagnini/parallelHesaff/src/pyramid/7"}
{"code": "for (int n = 0; n < num_nodes; ++n)\n{\n  node = nodes[n];\n  for (int c_in = 0; c_in < node->dim_features; ++c_in)\n  {\n    for (int c_out = 0; c_out < node->dim_hidden; ++c_out)\n    {\n      node->tmp_hidden[c_out] += node->x[c_in] * model.weight_1[(c_in * node->dim_hidden) + c_out];\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/xinyuejohn/Parallel-Programming-for-Graph-Convolutional-Neural-Networks/gcn_hybrid/0"}
{"code": "for (int i = 0; i < len1; i++)\n  sum += vec1[i] * vec2[i];\n\n", "pragma": "omp parallel for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/taghizaad/openMP/cFiles/matrix/10"}
{"code": "for (i = 0; i < n; ++i)\n{\n  x = (double) randomU();\n  y = (double) randomU();\n  z = (x * x) + (y * y);\n  if (z <= 1)\n  {\n    ++count;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) reduction(+: count) private(x,y,z,i)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pradeepsinngh/practice-parallel-programming/openmp/monte-carlo-pi/monte_carlo_pi/0"}
{"code": "for (int j = 0; j < numHidden2Nodes; ++j)\n{\n  layer2_bias[j] += h2_err[j] * lr;\n  for (int k = 0; k < numHidden1Nodes; ++k)\n  {\n    layer2_weights[j][k] += (layer1[k] * h2_err[j]) * lr;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mase28/OpenMPNeuralNetwork/main_par_layer/12"}
{"code": "for (int i = 0; i < num_vals; i++)\n{\n  double rx = drand48();\n  double x = (rx * x_grid.start) + ((1.0 - rx) * x_grid.end);\n  double ry = drand48();\n  double y = (ry * y_grid.start) + ((1.0 - ry) * y_grid.end);\n  double rz = drand48();\n  double z = (rz * z_grid.start) + ((1.0 - rz) * z_grid.end);\n  for (int j = 0; j < num_splines; j++)\n    eval_UBspline_3d_d_vgh(norm_splines[j], x, y, z, &norm_vals[j], &norm_grads[3 * j], &norm_hess[9 * j]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/einspline/time_multi_new/11"}
{"code": "for (i = k1; i >= j1; --i)\n{\n  if ((i < j2) || (i > k2))\n    ++e;\n\n  ++c;\n}\n\n", "pragma": "omp for schedule (dynamic)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/pr29947-1/1"}
{"code": "for (i = 0; i < 6; i++)\n{\n  printf(\"Thread %d: Adding %d and %d + %d \\n\", tid, nums3[i], nums2[i], share);\n  nums3[i] += nums2[i] + share;\n}\n\n", "pragma": "\t\t#pragma omp for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wibeck/c-edu/ParallelTest/ForExample/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  for (int j = 0; j < m; j++)\n    centroids[i][j] = dataset[ranNum[i]][j];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gioele-maruccia/parallel-K-means-openmp/src/first_implementation/19"}
{"code": "for (i = 0; i < (NUM_THREADS_PER_MESH_CELL * NUM_MESH_CELLS); i++)\n{\n  cidx = i / NUM_THREADS_PER_MESH_CELL;\n  ctid = i % NUM_THREADS_PER_MESH_CELL;\n  x = mesh_cells[cidx].x;\n  ALIGNED(x);\n  y = mesh_cells[cidx].y;\n  ALIGNED(y);\n  z = mesh_cells[cidx].z;\n  ALIGNED(z);\n  u = mesh_cells[cidx].u;\n  ALIGNED(u);\n  v = mesh_cells[cidx].v;\n  ALIGNED(v);\n  w = mesh_cells[cidx].w;\n  ALIGNED(w);\n  _xavg = mesh_cells[cidx]._xavg;\n  ALIGNED(_xavg);\n  _yavg = mesh_cells[cidx]._yavg;\n  ALIGNED(_yavg);\n  _zavg = mesh_cells[cidx]._zavg;\n  ALIGNED(_zavg);\n  field_component_0 = mesh_cells[cidx].field_component_0;\n  ALIGNED(field_component_0);\n  field_component_1 = mesh_cells[cidx].field_component_1;\n  ALIGNED(field_component_1);\n  field_component_2 = mesh_cells[cidx].field_component_2;\n  ALIGNED(field_component_2);\n  field_component_3 = mesh_cells[cidx].field_component_3;\n  ALIGNED(field_component_3);\n  field_component_4 = mesh_cells[cidx].field_component_4;\n  ALIGNED(field_component_4);\n  field_component_5 = mesh_cells[cidx].field_component_5;\n  ALIGNED(field_component_5);\n  field_component_6 = mesh_cells[cidx].field_component_6;\n  ALIGNED(field_component_6);\n  field_component_7 = mesh_cells[cidx].field_component_7;\n  ALIGNED(field_component_7);\n  num_pcls = mesh_cells[cidx].num_pcls;\n  num_vecs = num_pcls / vec_length;\n  rest_num_pcls = num_pcls % vec_length;\n  ctid_num_pcls[0] = ((num_vecs / 2) + (num_vecs % 2)) * vec_length;\n  ctid_num_pcls[1] = ((num_vecs / 2) * vec_length) + rest_num_pcls;\n  ctid_start_pidx[0] = 0;\n  ctid_start_pidx[1] = ctid_num_pcls[0];\n  if (1 == NUM_THREADS_PER_MESH_CELL)\n  {\n    ctid_start_pidx[0] = 0;\n    ctid_num_pcls[0] = num_pcls;\n  }\n\n  my_start_pidx = ctid_start_pidx[ctid];\n  my_num_pcls = ctid_num_pcls[ctid];\n  for (block_disp = 0; block_disp < my_num_pcls; block_disp += BLOCKSIZE)\n  {\n    cpidx = my_start_pidx + block_disp;\n    for (j = 0, pidx = cpidx; j < BLOCKSIZE; j++, pidx++)\n    {\n      abs_pos[0] = _xavg[pidx];\n      abs_pos[1] = _yavg[pidx];\n      abs_pos[2] = _zavg[pidx];\n      rel_pos[0] = abs_pos[0] - xstart;\n      rel_pos[1] = abs_pos[1] - ystart;\n      rel_pos[2] = abs_pos[2] - zstart;\n      cm1_pos[0] = rel_pos[0] * inv_dx;\n      cm1_pos[1] = rel_pos[1] * inv_dy;\n      cm1_pos[2] = rel_pos[2] * inv_dz;\n      w1[0] = cx - cm1_pos[0];\n      w1[1] = cy - cm1_pos[1];\n      w1[2] = cz - cm1_pos[2];\n      w0[0] = 1 - w1[0];\n      w0[1] = 1 - w1[1];\n      w0[2] = 1 - w1[2];\n      weight[0] = w0[0] * w0[1];\n      weight[1] = w0[0] * w1[1];\n      weight[2] = w1[0] * w0[1];\n      weight[3] = w1[0] * w1[1];\n      weights_0[j] = weight[0] * w0[2];\n      weights_1[j] = weight[0] * w1[2];\n      weights_2[j] = weight[1] * w0[2];\n      weights_3[j] = weight[1] * w1[2];\n      weights_4[j] = weight[2] * w0[2];\n      weights_5[j] = weight[2] * w1[2];\n      weights_6[j] = weight[3] * w0[2];\n      weights_7[j] = weight[3] * w1[2];\n    }\n\n    for (j = 0; j < 6; j++)\n    {\n      ptr = BxyzExyz_l[j];\n      ALIGNED(ptr);\n      #pragma ivdep\n      for (k = 0; k < BLOCKSIZE; k++)\n      {\n        ptr[k] = 0.0;\n        ptr[k] += weights_0[k] * field_component_0[j];\n        ptr[k] += weights_1[k] * field_component_1[j];\n        ptr[k] += weights_2[k] * field_component_2[j];\n        ptr[k] += weights_3[k] * field_component_3[j];\n        ptr[k] += weights_4[k] * field_component_4[j];\n        ptr[k] += weights_5[k] * field_component_5[j];\n        ptr[k] += weights_6[k] * field_component_6[j];\n        ptr[k] += weights_7[k] * field_component_7[j];\n      }\n\n    }\n\n    for (j = 0, pidx = cpidx; j < BLOCKSIZE; j++, pidx++)\n    {\n      Om[0] = qdto2mc * Bxl[j];\n      Om[1] = qdto2mc * Byl[j];\n      Om[2] = qdto2mc * Bzl[j];\n      omsq = ((Om[0] * Om[0]) + (Om[1] * Om[1])) + (Om[2] * Om[2]);\n      denom = 1.0 / (1.0 + omsq);\n      t[0] = u[pidx] + (qdto2mc * Exl[j]);\n      t[1] = v[pidx] + (qdto2mc * Eyl[j]);\n      t[2] = w[pidx] + (qdto2mc * Ezl[j]);\n      udotOm = ((t[0] * Om[0]) + (t[1] * Om[1])) + (t[2] * Om[2]);\n      avg[0] = (t[0] + (((t[1] * Om[2]) - (t[2] * Om[1])) + (udotOm * Om[0]))) * denom;\n      avg[1] = (t[1] + (((t[2] * Om[0]) - (t[0] * Om[2])) + (udotOm * Om[1]))) * denom;\n      avg[2] = (t[2] + (((t[0] * Om[1]) - (t[1] * Om[0])) + (udotOm * Om[2]))) * denom;\n      _xavg[pidx] = x[pidx] + (avg[0] * dto2);\n      _yavg[pidx] = y[pidx] + (avg[1] * dto2);\n      _zavg[pidx] = z[pidx] + (avg[2] * dto2);\n    }\n\n  }\n\n}\n\n", "pragma": "        #pragma omp for schedule(static,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/tests/testvrinke/1"}
{"code": "for (i = 0; i < 3; i++)\n{\n  for (j = 0; j < 3; j++)\n  {\n    printf(\"%d \", mat1[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Defcon27/Parallel-Computing-in-C-using-OpenMP/Matrices/matrix_difference/1"}
{"code": "for (i = 0; i < SIZE; i++)\n{\n  for (j = 0; j < SIZE; j++)\n  {\n    ex[(i * SIZE) + j] = ((((DATA_TYPE) i) * (j + 1)) + 1) / SIZE;\n    ey[(i * SIZE) + j] = ((((DATA_TYPE) (i - 1)) * (j + 2)) + 2) / SIZE;\n    hz[(i * SIZE) + j] = ((((DATA_TYPE) (i - 9)) * (j + 4)) + 3) / SIZE;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/uasys/openmp-split/tests/splitTesting/FDTD2D/fdtd2d/5"}
{"code": "for (i = 0; i < n; i++)\n{\n  for (j = 0; j < n; j++)\n  {\n    A[(i * n) + j] = m++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/shashankheda/algorithms_advanced_architectures/AAA/Shashank CP2.2/Shashank_CP2.2_11110094_Report+Codes/Shashank_CP2.2_11110094_Report+Codes/Codes for OpenMP_Shashank/Q1/serial_mat_mult/3"}
{"code": "for (int thr = 0; thr < nthreads; thr++)\n{\n  double thr_wall_t1;\n  double thr_wall_t2;\n  double thr_cpu_t1;\n  double thr_cpu_t2;\n  op_timers_core(&thr_cpu_t1, &thr_wall_t1);\n  int start = (set->size * thr) / nthreads;\n  int finish = (set->size * (thr + 1)) / nthreads;\n  for (int n = start; n < finish; n++)\n  {\n    down_v2_kernel_post(&((double *) arg0.data)[5 * n], &((double *) arg1.data)[1 * n], &((double *) arg2.data)[5 * n], &((double *) arg3.data)[5 * n]);\n  }\n\n  op_timers_core(&thr_cpu_t2, &thr_wall_t2);\n  OP_kernels[21].times[thr] += thr_wall_t2 - thr_wall_t1;\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/warwick-hpsc/MG-CFD-app-OP2/openmp/down_v2_kernel_post_kernel/0"}
{"code": "for (i = 0; i < size; i++)\n{\n  sum = sum + (v[i] * v[i]);\n}\n\n", "pragma": "omp parallel for schedule(static) default(none) shared(size, v) private(i) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/EPCCed/adept-kernel-openmp/blas_op/9"}
{"code": "for (i = 0; i < num_trials; i++)\n{\n  x = drandom();\n  y = drandom();\n  test = (x * x) + (y * y);\n  if (test <= (r * r))\n    Ncirc++;\n\n}\n\n", "pragma": "      #pragma omp for reduction(+:Ncirc) private(x,y,test)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RachitB11/openmp_tutorials/pi_mc/pi_mc/0"}
{"code": "for (i = 0; i < num_threads; i++)\n{\n  best_fitness[i] = INFINITY;\n  g[i] = -1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/pg443/Particle-Swarm-Optimizer-OpenMP/optimize_using_omp/4"}
{"code": "for (int i = 0; i < total_edges; i++)\n{\n  fgets(data, sizeof(data), fp);\n  fscanf(fp, \"%d %d\", &temp1[i], &temp2[i]);\n  matrix[(temp1[i] * array_size) + temp2[i]] = 1;\n  nodes[temp2[i]].in_edges++;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/iamtsac/Khan-Algorithm-openmp/parallel/1"}
{"code": "for (i = ((-3LL) * 0x7fffffff) - 20000LL; i <= (0x7fffffff + 10000LL); i += 0x7fffffff + 200LL)\n{\n  if (i == (((-3LL) * 0x7fffffff) - 20000LL))\n    set(5, 0);\n  else\n    if (i == ((((-2LL) * 0x7fffffff) - 20000LL) + 200LL))\n    set(5, 1);\n  else\n    if (i == (((-0x7fffffff) - 20000LL) + 400LL))\n    set(5, 2);\n  else\n    if (i == ((-20000LL) + 600LL))\n    set(5, 3);\n  else\n    if (i == ((0x7fffffff - 20000LL) + 800LL))\n    set(5, 4);\n  else\n    e = 1;\n\n\n\n\n\n}\n\n", "pragma": "omp for schedule(dynamic,1) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/klueska/libgomp-parlib/libgomp/testsuite/libgomp.c/loop-6/5"}
{"code": "for (int i = k + 1; i < n; i++)\n{\n  if (abs(a[i][k]) > max)\n  {\n    max = abs(a[i][k]);\n    index = i;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PAAnisimofff/SLAU_OpenMP/SLAU_OpenMP/SLAU_OpenMP/0"}
{"code": "for (size_t i = 1; i < totalNum; i++)\n{\n  double dis = fabs(positionX[i] - positionX[i - 1]);\n  m_fMinParticleSpacing = min(m_fMinParticleSpacing, dis);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HsinchiangChen/LPFluidCode/lp_solver/64"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    for (int k = 0; k < p; k++)\n    {\n      A[i][k] = rand();\n      B[k][j] = rand();\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/code7777/MatrixMultiplierParallelProcessing/hw1/0"}
{"code": "for (j = 0; j < 10; j++)\n{\n  k++;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/OpenCMISS-Dependencies/opari2/test/data/test9/1"}
{"code": "for (int i = start1; i < (start1 + pointsPerProcess); i++)\n{\n  int thread = omp_get_thread_num();\n  for (int j = start2; j < (start2 + pointsPerProcess); j++)\n  {\n    calcForces(i, j, j - start2, thread);\n  }\n\n}\n\n", "pragma": "\t\t\t#pragma omp parallel for schedule(dynamic, block) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Garrus007/GravSim2/MPIGrav/Simulator/MpiGravSim/7"}
{"code": "for (i = 0; i <= n; i++)\n  if (iterations[i] == which_thread)\n  stop_iter = i;\nelse\n{\n  printf(\"%4d  \\t\\t%d -- %d\\n\", which_thread, start_iter, stop_iter);\n  which_thread = iterations[i];\n  start_iter = (stop_iter = i);\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/J-Aguirre/openmp/ch5/omp_sin_sum/3"}
{"code": "for (i = 1; i < (LX1 - 1); i++)\n{\n  mor_s_v[0][i - 1] = idmo[ntemp3][jjface[face]][0][0][LX1 - 1][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/UA/mason/14"}
{"code": "for (k = 1; k < nyh; k++)\n{\n  k1 = ny - k;\n  at2 = (-ci2) * crealf(ffe[k]);\n  at1 = at2 * at2;\n  exy[3 * k] = at2 * dcu[3 * k];\n  exy[1 + (3 * k)] = at2 * dcu[1 + (3 * k)];\n  exy[2 + (3 * k)] = at2 * dcu[2 + (3 * k)];\n  exy[3 * k1] = zero;\n  exy[1 + (3 * k1)] = zero;\n  exy[2 + (3 * k1)] = zero;\n  wp += at1 * (((dcu[3 * k] * conjf(dcu[3 * k])) + (dcu[1 + (3 * k)] * conjf(dcu[1 + (3 * k)]))) + (dcu[2 + (3 * k)] * conjf(dcu[2 + (3 * k)])));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/UCLA-Plasma-Simulation-Group/PIC-skeleton-codes/openmp_mpi/mpdpic2/mpdpush2/19"}
{"code": "for (i = 0; i < 7; i++)\n{\n  t1 = Z[k++];\n  key[j--] = Z[k++];\n  key[j--] = t1;\n  t1 = inv(Z[k++]);\n  t2 = (-Z[k++]) & 0xffff;\n  t3 = (-Z[k++]) & 0xffff;\n  key[j--] = inv(Z[k++]);\n  key[j--] = t2;\n  key[j--] = t3;\n  key[j--] = t1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/frobino/openmp_introduction/Examples/crypt/crypt_omp_adv/3"}
{"code": "for (int g = 0; g < egroups; g++)\n{\n  FSR_flux[g] += tally[g];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/simplemoc-omp/main/8"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  for (j = 0; j < num_vertices; j++)\n  {\n    graph[(i * num_vertices) + j] = (data_t) 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/srrcboy/dijkstra-CUDA/dijkstra_serial/9"}
{"code": "for (int i = (block * BS) + 1; i < (((block + 1) * BS) + 1); i++)\n{\n  double v = 0.0;\n  int end = i - 1;\n  if (with_i)\n    end = i;\n\n  for (int j = 1; j <= end; j++)\n  {\n    double kv = kb(1 - A, j - 1, j, i, points, NULL);\n    v += kv * F[j];\n  }\n\n  if (space_der == 1)\n  {\n    for (int j = i + 1; j < N; j++)\n    {\n      double kv = -kb(1 - A, j, j + 1, i, points, NULL);\n      v += kv * F[j];\n    }\n\n  }\n\n  V[i - ((block * BS) + 1)] = v;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fpde_hpc_1d/45"}
{"code": "for (int real = 0; real <= num; real++)\n{\n  for (int img = 0; img <= num; img++)\n  {\n    c = (real_lower + (real * real_step)) + ((img_lower + (img * img_step)) * I);\n    count += inset(c, maxiter);\n  }\n\n}\n\n", "pragma": "        #pragma omp for reduction(+:count) schedule(dynamic)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/victorskl/openmp-mandelbrot/mandelbrot/1"}
{"code": "for (x = 0; x < topK_array_size; ++x)\n{\n  if (ref_stats->num_vertices < topK_array[x])\n    break;\n\n  fprintf(stdout, \"%-14u \", topK_array[x]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/utils/graphStats/18"}
{"code": "for (int i = 0; i < m; i++)\n{\n  y[i] = 0.0;\n  for (int j = 0; j < n; j++)\n  {\n    temp = A[(i * n) + j] * x[j];\n    y[i] += temp;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(thread_count) default(none) private(temp) shared(A, x, y, m, n)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/junstar92/parallel_programming_study/OpenMP/12_omp_mat_vec_mul/0"}
{"code": "for (int i = 0; i < (n - 1); i++)\n{\n  double sum = 0;\n  for (int j = 0; j < d; j++)\n  {\n    sum += pow((*(((X + (j * n)) + n) - 1)) - (*((X + (j * n)) + i)), 2);\n  }\n\n  distances[i] = sqrt(sum);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vagzikopis/vptree/src/vptree_openmp/0"}
{"code": "for (k = 1; k < (grid_points[2] - 1); k++)\n{\n  vijk = vs[i][j][k];\n  vp1 = vs[i][j + 1][k];\n  vm1 = vs[i][j - 1][k];\n  rhs[i][j][k][0] = (rhs[i][j][k][0] + (dy1ty1 * ((u[i][j + 1][k][0] - (2.0 * u[i][j][k][0])) + u[i][j - 1][k][0]))) - (ty2 * (u[i][j + 1][k][2] - u[i][j - 1][k][2]));\n  rhs[i][j][k][1] = ((rhs[i][j][k][1] + (dy2ty1 * ((u[i][j + 1][k][1] - (2.0 * u[i][j][k][1])) + u[i][j - 1][k][1]))) + (yycon2 * ((us[i][j + 1][k] - (2.0 * us[i][j][k])) + us[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][1] * vp1) - (u[i][j - 1][k][1] * vm1)));\n  rhs[i][j][k][2] = ((rhs[i][j][k][2] + (dy3ty1 * ((u[i][j + 1][k][2] - (2.0 * u[i][j][k][2])) + u[i][j - 1][k][2]))) + ((yycon2 * con43) * ((vp1 - (2.0 * vijk)) + vm1))) - (ty2 * (((u[i][j + 1][k][2] * vp1) - (u[i][j - 1][k][2] * vm1)) + ((((u[i][j + 1][k][4] - square[i][j + 1][k]) - u[i][j - 1][k][4]) + square[i][j - 1][k]) * c2)));\n  rhs[i][j][k][3] = ((rhs[i][j][k][3] + (dy4ty1 * ((u[i][j + 1][k][3] - (2.0 * u[i][j][k][3])) + u[i][j - 1][k][3]))) + (yycon2 * ((ws[i][j + 1][k] - (2.0 * ws[i][j][k])) + ws[i][j - 1][k]))) - (ty2 * ((u[i][j + 1][k][3] * vp1) - (u[i][j - 1][k][3] * vm1)));\n  rhs[i][j][k][4] = ((((rhs[i][j][k][4] + (dy5ty1 * ((u[i][j + 1][k][4] - (2.0 * u[i][j][k][4])) + u[i][j - 1][k][4]))) + (yycon3 * ((qs[i][j + 1][k] - (2.0 * qs[i][j][k])) + qs[i][j - 1][k]))) + (yycon4 * (((vp1 * vp1) - ((2.0 * vijk) * vijk)) + (vm1 * vm1)))) + (yycon5 * (((u[i][j + 1][k][4] * rho_i[i][j + 1][k]) - ((2.0 * u[i][j][k][4]) * rho_i[i][j][k])) + (u[i][j - 1][k][4] * rho_i[i][j - 1][k])))) - (ty2 * ((((c1 * u[i][j + 1][k][4]) - (c2 * square[i][j + 1][k])) * vp1) - (((c1 * u[i][j - 1][k][4]) - (c2 * square[i][j - 1][k])) * vm1)));\n}\n\n", "pragma": "omp parallel for firstprivate(j ,k ,vijk ,vp1 ,vm1 ,ty2 ,dy1ty1 ,yycon2 ,dy2ty1 ,c2 ,dy3ty1 ,con43 ,dy4ty1 ,c1 ,yycon5 ,yycon3 ,dy5ty1 ,yycon4 ,i )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/BT/bt/95"}
{"code": "for (i = 1; i < (N - 1); i += 2)\n{\n  if (a[i] > a[i + 1])\n  {\n    temp = a[i];\n    a[i] = a[i + 1];\n    a[i + 1] = temp;\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for num_threads(2) default(none) shared(a, N), private(i, temp)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaezyq/openMpStudy/ParityTransformSort/1"}
{"code": "for (int k = 0; k < n; k++)\n{\n  if (k == 0)\n  {\n    for (int i = 0; i < thread_count; i++)\n    {\n      pthread_create(&threadID[i], NULL, dealwithbycol, (void *) (&id[i]));\n    }\n\n  }\n\n  for (int i = 0; i < thread_count; i++)\n  {\n    sem_wait(&sem_parent);\n  }\n\n  pthread_barrier_wait(&childbarrier_col);\n  A[k][k] = 1;\n  for (int i = k + 1; i < n; i++)\n    A[i][k] = 0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tinsir888/parallel-programming/main/6"}
{"code": "for (int contador = 0; contador < n; contador++)\n{\n  float a1 = contador * intervalo;\n  float b1 = (contador + 1) * intervalo;\n  totalIntegral += Simpson(a1, b1);\n  totalerro += SimpsonErro(a1, b1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vbiazon/OpenMP/IntegralNumericaOMP/0"}
{"code": "for (int i = 0; i < 10; i++)\n{\n  if ((i == 3) || (i == 6))\n  {\n    x++;\n  }\n\n  printf(\"Thread ID %d, i: %d, x: %d\\n\", omp_get_thread_num(), i, x);\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HydraQYH/OpenMP_practice/parallel8/0"}
{"code": "for (int blockid = 0; blockid < howmany; ++blockid)\n{\n  int i_start = lowerb(blockid, howmany, sizex);\n  int i_end = upperb(blockid, howmany, sizex);\n  for (int i = max(1, i_start); i <= min(sizex - 2, i_end); i++)\n  {\n    for (int j = 1; j <= (sizey - 2); j++)\n    {\n      utmp[(i * sizey) + j] = 0.25 * (((u[(i * sizey) + (j - 1)] + u[(i * sizey) + (j + 1)]) + u[((i - 1) * sizey) + j]) + u[((i + 1) * sizey) + j]);\n      diff = utmp[(i * sizey) + j] - u[(i * sizey) + j];\n      sum += diff * diff;\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(diff) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/felixarpa/PAR-Lab/boada/lab5/solver-omp-for_gauss/1"}
{"code": "for (int i = 0; i < m_threads; ++i)\n{\n  gamma += exp((custos_correntes[i] - max_custo_corrente) / tmp_ac);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/leandrosfj/OpenMP_CSA/C\u00f3digos/OMP_CSA/2"}
{"code": "for (int i = 0; i < (n / 2); ++i)\n{\n  p_0[i] = p[2 * i];\n  p_1[i] = p[(2 * i) + 1];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mlchkhn/parallel_algorithms/multiplication/3"}
{"code": "for (i = 0; i < N; i++)\n{\n  for (j = 0; j < N; j++)\n  {\n    if (E[(i * N) + j] != E_CLOUD[(i * N) + j])\n    {\n      fail++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task12/code-t12-cloud/16"}
{"code": "for (i = 0; i < nblocks; i++)\n{\n  for (j = 0; j < nblocks; j++)\n  {\n    proc_num = BlockOwner(i, j);\n    a[i + (j * nblocks)] = last_malloc[proc_num];\n    if ((i == (nblocks - 1)) && (j == (nblocks - 1)))\n    {\n      size = edge * edge;\n    }\n    else\n      if ((i == (nblocks - 1)) || (j == (nblocks - 1)))\n    {\n      size = edge * block_size;\n    }\n    else\n    {\n      size = block_size * block_size;\n    }\n\n\n    last_malloc[proc_num] += size;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexandrehsd/splash2-lu_cb/src/lu/4"}
{"code": "for (i = 0; i < max_threads; i++)\n  yescrypt_init_local(&local[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/django_scrypt_fmt_plug/1"}
{"code": "for (int i = 0; i < num_buckets; i++)\n{\n  for (int tid = 0; tid < omp_get_thread_num(); tid++)\n  {\n    histogram[i] += tmp_hist[tid][i];\n  }\n\n}\n\n", "pragma": "omp parallel for shared (tmp_hist, histogram)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bereydev/multiprocessor-architecture/A2/sharing/1"}
{"code": "for (int i = 0; i < width_; i++)\n{\n  for (int j = 0; j < height_; j++)\n  {\n    grid_cell_[(i * width_) + j]->diffuse_protein();\n    grid_cell_[(i * width_) + j]->degrade_protein();\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/nathan-K-/PC-optimisation/src/World/5"}
{"code": "for (i = 0; i < (k - 1); i++)\n{\n  w[i] = w[i] + ((alpha * ((double) sign)) * point.values[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ritafridman/ParallelFinalProject/Assignment3/PerceptronAlgorithm/2"}
{"code": "for (i = 0; i < MAX; i++)\n{\n  Summa += a[i];\n  for (j = 0; j < MAX; j++)\n    Summa = Summa;\n\n}\n\n", "pragma": "        #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/DisperseWic/PP3d/SummOMP/1"}
{"code": "for (i = 0; i < 100; i++)\n{\n  printf(\"Offset of BigBuckets %d = %d\\n\", i, bigBucketsOffsets[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Andrzej97/OpenMP/alg3/12"}
{"code": "for (i = 0; i < nrep; i++)\n{\n  matmul(m, l, n, mDIM, lDIM, nDIM, a, b, c);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chenxuhao/gardenia/src/vecAdd/matmul_tiled/10"}
{"code": "for (int i = 0; i < timePoints.size(); i++)\n{\n  if (ISF[i] < exp(-1))\n  {\n    tao = timePoints[i];\n    break;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/108"}
{"code": "for (int iw = 0; iw < P_list.size(); iw++)\n{\n  P_list[iw]->activePtcl = iat;\n  P_list[iw]->activePos = P_list[iw]->R[iat] + displs[iw];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jhuber6/cgo2022-artifacts/miniqmc/src/Particle/ParticleSet/20"}
{"code": "for (row = 30 - 1; row >= 0; row--)\n{\n  X[row] = B[row];\n  for (col = 30 - 1; col > row; col--)\n  {\n    X[row] -= A[row][col] * X[col];\n  }\n\n  X[row] /= A[row][row];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alexanderjpowell/Gaussian-Elimination/testomp/5"}
{"code": "for (i = 0; i < 10; i++)\n  a[i] = 10 - i;\n\n", "pragma": "omp for schedule(runtime)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/combined-1/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  printf(\"c[%d] = %f\\n\", i, c[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tony-yang/learning-openmp/02_for_loop/2"}
{"code": "for (int i = R1; i <= B4; i++)\n{\n  linebuf[i] = (linebuf[i - 1] + params->line_width) + 2;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darktable-org/rawspeed/src/librawspeed/decompressors/FujiDecompressor/1"}
{"code": "for (i = 0; i < jmax; i++)\n{\n  for (j = 0; j < jmax; j++)\n    a[k++] *= scale;\n\n}\n\n", "pragma": "\t#pragma omp parallel for collapse(2) private (k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/daseibert2/OpenMP_Exercises/collapse_timing/1"}
{"code": "for (int index = 0; index < n; index++)\n  result += x[index] * y[index];\n\n", "pragma": "#pragma omp target teams distribute parallel for reduction(+:result) \\", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/zjin-lcf/HeCBench/lanczos-omp/lanczos/2"}
{"code": "for (int i = 0; i < 20000; i++)\n{\n  int maxnum = 0;\n  for (int z = 0; z < 20000; z++)\n  {\n    if (mass[i][z] > maxnum)\n    {\n      maxnum = mass[i][z];\n    }\n\n  }\n\n  sum += maxnum;\n  maxnum = 0;\n}\n\n", "pragma": "omp parallel for default(none) shared(mass) num_threads(1) reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Bernishik/University_parallelProgramming/lab2/main/0"}
{"code": "for (z = 0; z < t; z++)\n{\n  if (x <= 1000)\n    show(univ, w, h);\n\n  gettimeofday(&start, 0);\n  evolve(univ, w, h);\n  gettimeofday(&end, 0);\n  tot_time += (double) elapsed_wtime(start, end);\n  if (x > 1000)\n    printf(\"Iteration %d is : %f ms\\n\", z, (double) elapsed_wtime(start, end));\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LazyRacc00n/HPC-project/Project/OpenMP/experiment01/3"}
{"code": "for (int i = 0; i < (nThreads + 1); i++)\n  sum1P[i] = (sum2P[i] = 0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/sum/4"}
{"code": "for (int i = 0; i < 1; ++i)\n{\n  bar();\n}\n\n", "pragma": "omp for nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/symbolicAnalysisFramework/src/ompAnal/test_example.valid_rose_output/0"}
{"code": "for (I = 0; I < M; I++)\n{\n  UNEW[I + 1][N] = UNEW[I + 1][0];\n  VNEW[I][0] = VNEW[I][N];\n  PNEW[I][N] = PNEW[I][0];\n}\n\n", "pragma": "omp for simd nowait schedule(simd:static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/afdezfraga/APP_Lab1/Vect/swim-parallel-vect/5"}
{"code": "for (int ai = 0; ai < this->nnz_; ++ai)\n{\n  this->mat_.val[ai] += alpha;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/59"}
{"code": "for (j = low; j < high; ++j)\n{\n  if (compare_string(str[j], pivot))\n  {\n    i++;\n    swap(&str[i], &str[j]);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DragosUnguru/ParallelFrameworksAnalyze/parallel_sorter/2"}
{"code": "for (int i = 0; i < ((int) ceil(((double) N) / 2)); i++)\n{\n  kernel_matrix(i, i) = diag;\n  for (int j = 0; j < i; j++)\n  {\n    kernel_matrix(j, i) = exp(-sum(pow(X.row(i) - X.row(j), 2)));\n    kernel_matrix(i, j) = kernel_matrix(j, i);\n  }\n\n  int m = (N - i) - 1;\n  kernel_matrix(m, m) = diag;\n  for (int j = 0; j < m; j++)\n  {\n    kernel_matrix(j, m) = exp(-sum(pow(X.row(m) - X.row(j), 2)));\n    kernel_matrix(m, j) = kernel_matrix(j, m);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for schedule(static) num_threads(ncore)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincentskywalkers/orthoDr/orthoDr/src/utilities/0"}
{"code": "for (index = 0; index < loops; ++index)\n{\n  SHA_CTX ctx;\n  SHA1_Init(&ctx);\n  SHA1_Update(&ctx, (unsigned char *) saved_key[index], strlen(saved_key[index]));\n  SHA1_Final((unsigned char *) crypt_key[index], &ctx);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/rawSHA1_fmt_plug/0"}
{"code": "for (int i = 0; i < n_clusters; i++)\n{\n  for (int j = 0; j < n_features; j++)\n  {\n    cluster_sizes[i] = 0;\n    centroids[i][j] = 0;\n    new_centroids[i][j] = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/pavelbodrov/parallel-kmeans/kmeans_parallel/6"}
{"code": "for (u = 6; u >= 1; u -= 2)\n  ;\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/pr39495-1/19"}
{"code": "for (ii = 1; ii < (srcImage->height() - 1); ii++)\n{\n  for (jj = 1; jj < (srcImage->width() - 1); jj++)\n  {\n    pixelValue = 0;\n    for (int i = -1; i <= 1; i++)\n    {\n      for (int j = -1; j <= 1; j++)\n      {\n        blue = qBlue(srcImage->pixel(jj + j, ii + i));\n        pixelValue += weight_y[i + 1][j + 1] * blue;\n      }\n\n    }\n\n    if (pixelValue > 255)\n      pixelValue = 255;\n\n    if (pixelValue < 0)\n      pixelValue = 0;\n\n    dstImage->setPixel(jj, ii, QColor(pixelValue, pixelValue, pixelValue).rgba());\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jupcan/openmp/sobel/sobel2/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < m; j++)\n    printf(\"%lf \", a[i][j]);\n\n  printf(\"%lf\\n\", b[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rafaeldcampbell/GaussianEliminationParallel/src/openMPGaussianElimination/3"}
{"code": "for (j = 1; j <= (grid_points[1] - 2); j++)\n{\n  for (k = 1; k <= (grid_points[2] - 2); k++)\n  {\n    r1 = rhs[0][i][j][k];\n    r2 = rhs[1][i][j][k];\n    r3 = rhs[2][i][j][k];\n    r4 = rhs[3][i][j][k];\n    r5 = rhs[4][i][j][k];\n    t1 = bt * r3;\n    t2 = 0.5 * (r4 + r5);\n    rhs[0][i][j][k] = -r2;\n    rhs[1][i][j][k] = r1;\n    rhs[2][i][j][k] = bt * (r4 - r5);\n    rhs[3][i][j][k] = (-t1) + t2;\n    rhs[4][i][j][k] = t1 + t2;\n  }\n\n}\n\n", "pragma": "omp parallel for private(r1 ,r2 ,r3 ,r4 ,r5 ,t1 ,t2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/40"}
{"code": "for (int64_t i = n - 1; i > (-1); i--)\n{\n  double rightSide = matrixY_[i];\n  for (uint64_t j = n - 1; j > i; j--)\n  {\n    rightSide -= compactMatrix_[(i * n) + j] * matrixX_[j];\n  }\n\n  matrixX_[i] = rightSide / compactMatrix_[(i * n) + i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_GaussianProcessRegression/gpr/2"}
{"code": "for (j = 1; j <= 2000; j++)\n{\n  old[j] = old[(2000 * nj) + j];\n  old[((2000 + 1) * nj) + j] = old[(1 * nj) + j];\n}\n\n", "pragma": "omp parallel for private(j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/otavio-r-filho/openmp_training/game_of_life/par-game_of_life/2"}
{"code": "for (int i = 0; i < RBN; i++)\n{\n  suma += cont1[i] + cont2[i];\n}\n\n", "pragma": "            #pragma omp parallel for shared (cont1, cont2) reduction(+: suma)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/facuMH/HeisenbergModel/OpenMP/main/1"}
{"code": "for (int i = y; i < (y + height); i += height - 1)\n{\n  for (int j = x; j < ((x + width) - reste); j += 8)\n  {\n    res = compute_vect512_long(i, j);\n    change_vect = _mm512_or_si512(change_vect, res);\n  }\n\n  int j = (x + width) - reste;\n  for (int k = 0; k < reste; k++)\n    change += compute_new_state_vect(i, j + k);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/tfurelaud/PAP/easypap-se/easypap-se/kernel/c/sable/28"}
{"code": "for (uint i = 0; i < reports.size(); ++i)\n{\n  fprintf(f, \"%d %d %d %d\\n\", reports[i].resAProducers, reports[i].resAmaxPrice, reports[i].resBProducers, reports[i].resBmaxPrice);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yonutix/Settlers-economy-OpenMP-/main/7"}
{"code": "for (size_t i = 0; i < N; i++)\n{\n  A_h[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCm-Developer-Tools/aomp/test/hip-openmp/aomp_hip_launch_test/hiplaunch/1"}
{"code": "for (int i = 0; i < n; i++)\n{\n  if (a[i] > maxval)\n    maxval = a[i];\n\n  if (b[i] > maxval)\n    maxval = b[i];\n\n  if (c[i] > maxval)\n    maxval = c[i];\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rhaas80/ncsa-pire/examples/stream/2"}
{"code": "for (int i = 0; i < 10; i++)\n  printf(\"%d\\t\", vector[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/skeptlk/openmp/lab3/task2/2"}
{"code": "for (long pidx_darts_counter_temp1083 = *pidx; (pidx_darts_counter_temp1083 < endRange) && (pidx_darts_counter_temp1083 < this->inputsTPParent->lastIteration1083); pidx_darts_counter_temp1083++)\n{\n  {\n    update_part(partArray[pidx_darts_counter_temp1083], *deposit);\n  }\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/clomp_v1.2/clomp.output.darts/40"}
{"code": "for (int i = 0; i < SIZE; i += R)\n  for (int j = 0; j < SIZE; j += R)\n  for (int k = 0; k < SIZE; k += R)\n  for (int ii = i; ii < (i + R); ii++)\n  for (int jj = j; jj < (j + R); jj++)\n{\n  for (int kk = k; kk < (k + R); kk++)\n    matrix_r[ii][jj] += matrix_a[ii][kk] * matrix_b[kk][jj];\n\n}\n\n\n\n\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/darek74123/PR-OpenMP-Project/Code/matrix/1"}
{"code": "for (int i = 0; i < nn; i++)\n  INTEGER(result)[i] = vec[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/emittman/dpOMP/src/funcs/1"}
{"code": "for (int i = 0; i < dummydim; i++)\n{\n  dummymatrix->SetElem(0, i, 1);\n  dummymatrix->SetElem(i, 0, 1);\n  dummymatrix->SetElem(100, i, 1);\n  dummymatrix->SetElem(i, 100, 1);\n  dummymatrix->SetElem(1000, i, 1);\n  dummymatrix->SetElem(i, 1000, 1);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/fpaboim/gpufem/src/Test/SPRmatrixTest/0"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double recbuf_energy = 0;\n      energy = calculateKernel(whites, blacks);\n      MPI_Reduce(&energy, &recbuf_energy, 1, (MPI_Datatype) 0x4c00080b, (MPI_Op) 0x58000003, 0, (MPI_Comm) 0x44000000);\n      MPI_Gather(Ma, Q, (MPI_Datatype) 0x4c000406, T, Q, (MPI_Datatype) 0x4c000406, 0, (MPI_Comm) 0x44000000);\n      if (myrank_mpi == 0)\n      {\n        unsigned int M_max = 0;\n        M_max = maxProcessing();\n        double mag = 0.0;\n        mag = (((Q * M_max) / (1.0 * (L * L))) - 1) / ((double) (Q - 1));\n        e += recbuf_energy;\n        e2 += recbuf_energy * recbuf_energy;\n        e4 += ((recbuf_energy * recbuf_energy) * recbuf_energy) * recbuf_energy;\n        m += mag;\n        m2 += mag * mag;\n        m4 += ((mag * mag) * mag) * mag;\n        measurments++;\n      }\n\n    }\n\n  }\n\n  if (myrank_mpi == 0)\n  {\n    assert(index < (1 + ((int) ((0.75 - 0.7) / 0.00005))));\n    stats[index].t = temp;\n    stats[index].e += e / measurments;\n    stats[index].e2 += e2 / measurments;\n    stats[index].e4 += e4 / measurments;\n    stats[index].m += m / measurments;\n    stats[index].m2 += m2 / measurments;\n    stats[index].m4 += m4 / measurments;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/pott_Hybrid/potts3-cpu-HYBR/63"}
{"code": "for (long i = start; i < stop; ++i)\n  localsum += A[i] * B[i];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GMAP/NPB-CPP/libs/fastflow/tests/test_dotprod_parfor/3"}
{"code": "for (i = 0; i < (1 << 26); i++)\n  inp[i] = rand() % (1 << 20);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/satyajitghana/OpenMP-Programming/07-locks/03_locks/2"}
{"code": "for (i = 0; i < (16 + 2); i++)\n{\n  tmp = 0;\n  for (j = 0; j < 4; j++)\n  {\n    tmp <<= 8;\n    if (sign_extension_bug)\n      tmp |= (int) ((signed char) (*ptr));\n    else\n      tmp |= (unsigned char) (*ptr);\n\n    if (!(*ptr))\n      ptr = key;\n    else\n      ptr++;\n\n  }\n\n  BF_exp_key[i] = tmp;\n  BF_init_key[i] = BF_init_state.P[i] ^ tmp;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john-core/src/BF_std/0"}
{"code": "for (ci = 0; ci < NCELLS; ci++)\n{\n  cell(ci).setkint(1.0);\n  cell(ci).setdel(1.0);\n  cell(ci).seta(0.0);\n  cell(ci).setCForce(0, 0.0);\n  cell(ci).setCForce(1, 0.0);\n  cell(ci).setkl(0);\n  cell(ci).setka(0);\n  cell(ci).setgam(0);\n  cell(ci).setkb(0);\n  for (vi = 0; vi < cell(ci).getNV(); vi++)\n    cell(ci).setUInt(vi, 0.0);\n\n  cell(ci).cal_inertia();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/YUXUANCHENG/DPM_OMP/src/cellPacking2D/98"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i += 1)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j += 1)\n  {\n    rhs[m][i][j][k] = rhs[m][i][j][k] - (dssp * (((((-4.0) * u[m][i][j][k - 1]) + (6.0 * u[m][i][j][k])) - (4.0 * u[m][i][j][k + 1])) + u[m][i][j][k + 2]));\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/SP/sp/139"}
{"code": "for (i = 0; i < n; ++i)\n{\n  for (j = 0; j < p; ++j)\n  {\n    (cout << \" \") << mult[i][j];\n    if (j == (p - 1))\n      cout << endl;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Atulsingh92/HPC-Project/Task2(a+b)/3"}
{"code": "for (int i = 0; i < 100; i++)\n{\n  array[i] = i;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Ayush9719/Parallel-and-Distributed-Computing-Lab/Lab 04- Critical Construct and Reduction Clause/Code/thread4_1/1"}
{"code": "for (int i = (input->np / 4) * 4; i < input->np; i++)\n{\n  sup->W[i] = input->wscale / 2;\n  sup->w_sum = sup->w_sum + sup->W[i];\n  sup->f_curr[i] = evaluate_f(input->x, input->c, i, input->d);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/thatsimo/progetto-21-22/progetti/1/fss32comp/13"}
{"code": "for (int k = 0; k < n; k++)\n{\n  scanf(\"%d\", &a[k]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ayan2809/Parallel-and-Distributed-Computing/Lab 2/code4/0"}
{"code": "for (i3 = 0; i3 < (mm3 - 1); i3++)\n{\n  for (i2 = 0; i2 < (mm2 - 1); i2++)\n  {\n    for (i1 = 0; i1 < mm1; i1++)\n    {\n      z1[i1] = z[i3][i2 + 1][i1] + z[i3][i2][i1];\n      z2[i1] = z[i3 + 1][i2][i1] + z[i3][i2][i1];\n      z3[i1] = (z[i3 + 1][i2 + 1][i1] + z[i3 + 1][i2][i1]) + z1[i1];\n    }\n\n    for (i1 = 0; i1 < (mm1 - 1); i1++)\n    {\n      u[2 * i3][2 * i2][2 * i1] = u[2 * i3][2 * i2][2 * i1] + z[i3][i2][i1];\n      u[2 * i3][2 * i2][(2 * i1) + 1] = u[2 * i3][2 * i2][(2 * i1) + 1] + (0.5 * (z[i3][i2][i1 + 1] + z[i3][i2][i1]));\n    }\n\n    for (i1 = 0; i1 < (mm1 - 1); i1++)\n    {\n      u[2 * i3][(2 * i2) + 1][2 * i1] = u[2 * i3][(2 * i2) + 1][2 * i1] + (0.5 * z1[i1]);\n      u[2 * i3][(2 * i2) + 1][(2 * i1) + 1] = u[2 * i3][(2 * i2) + 1][(2 * i1) + 1] + (0.25 * (z1[i1] + z1[i1 + 1]));\n    }\n\n    for (i1 = 0; i1 < (mm1 - 1); i1++)\n    {\n      u[(2 * i3) + 1][2 * i2][2 * i1] = u[(2 * i3) + 1][2 * i2][2 * i1] + (0.5 * z2[i1]);\n      u[(2 * i3) + 1][2 * i2][(2 * i1) + 1] = u[(2 * i3) + 1][2 * i2][(2 * i1) + 1] + (0.25 * (z2[i1] + z2[i1 + 1]));\n    }\n\n    for (i1 = 0; i1 < (mm1 - 1); i1++)\n    {\n      u[(2 * i3) + 1][(2 * i2) + 1][2 * i1] = u[(2 * i3) + 1][(2 * i2) + 1][2 * i1] + (0.25 * z3[i1]);\n      u[(2 * i3) + 1][(2 * i2) + 1][(2 * i1) + 1] = u[(2 * i3) + 1][(2 * i2) + 1][(2 * i1) + 1] + (0.125 * (z3[i1] + z3[i1 + 1]));\n    }\n\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jacob-lidman/rose/projects/OpenMP_Translator/tests/npb2.3-omp-c/MG/mg/3"}
{"code": "for (uint64_t i = 0; i < gridM; i++)\n{\n  for (uint64_t j = i; j < gridM; j++)\n  {\n    double withoutNoise = 1 - (gridPositionSubtractedFromHalfAndSquared[i] + gridPositionSubtractedFromHalfAndSquared[j]);\n    observedValues[(i * gridM) + j] = withoutNoise + get5HundredthsRandom();\n    observedValues[(j * gridM) + i] = withoutNoise + get5HundredthsRandom();\n  }\n\n}\n\n", "pragma": "            #pragma omp for nowait ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alireza-safdari/OpenMP_GaussianProcessRegression/gpr/5"}
{"code": "for (unsigned int k = 0; k < _n; k++)\n{\n  rank = (edgeSize(k) > rank) ? (edgeSize(k)) : (rank);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/alex-87/HyperGraphLib/src/model/AdjacentMatrix/6"}
{"code": "for (int i = 0; i < 12; i++)\n{\n  a[i] = rand();\n  b[i] = rand();\n  printf(\"a[%d] = %d, b[%d] = %d, thread = %d \\n\", i, a[i], i, b[i], omp_get_thread_num());\n}\n\n", "pragma": "#pragma omp parallel for schedule(static, 4) num_threads(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EvgeniiSamarin/OPenMP/openMP/main/9"}
{"code": "for (int i = 1; i < cities; i++)\n{\n  line(x[i - 1], y[i - 1], x[i], y[i], 127, (unsigned char *) pic, width);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kelldork/OpenMP/tsp_omp/3"}
{"code": "for (i = 1; i < (L - 1); i++)\n{\n  for (j = 1; j < (L - 1); j += 2)\n  {\n    int shift;\n    if ((i % 2) == 0)\n    {\n      shift = 1;\n    }\n    else\n    {\n      shift = 0;\n    }\n\n    int index = getIndex(i, j + shift, m);\n    int pos_l = getIndex(i, (j - 1) + shift, m);\n    int pos_r = getIndex(i, (j + 1) + shift, m);\n    int pos_u = getIndex(i + 1, j + shift, m);\n    int pos_d = getIndex(i - 1, j + shift, m);\n    phi[index] = (p.scale[lev] * (((phi[pos_l] + phi[pos_r]) + phi[pos_u]) + phi[pos_d])) + res[index];\n  }\n\n}\n\n", "pragma": "omp parallel for collapse(2) shared(phi, res)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NancyYixuanXiao/Multigrid/Old_Code/parallel_mg/0"}
{"code": "for (int i = 0; i < num; ++i)\n{\n  a += i;\n  printf(\"Thread %d has a value of a = %d\\n\", omp_get_thread_num(), a);\n}\n\n", "pragma": "#pragma omp parallel for private(a)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HPC-lab-ITIS/OpenMP-and-MPI/materials/lec_1/code/test_4_1/0"}
{"code": "for (i = n - 1; i >= 0; i--)\n{\n  x[i] = matrix1[i][n];\n  for (j = i + 1; j < n; j++)\n    if (j != i)\n    x[i] = x[i] - (matrix1[i][j] * x[j]);\n\n\n  x[i] = x[i] / matrix1[i][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/wjankowski96/OpenMP/gauss/3"}
{"code": "for (int i = 0; i < wClones.size(); i++)\n  numW += wClones[i]->getActiveWalkers();\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/qmcpack/src/QMCDrivers/QMCCostFunctionOMP/8"}
{"code": "for (j = 1; j < (y - 1); j++)\n{\n  if (dom[i][j][k] == 1)\n  {\n    for (l = -1; l < 2; l++)\n    {\n      if (l == 0)\n        continue;\n\n      if (dom[i + l][j][k] == 0)\n      {\n        total_pressure_force += pressure_on_solid[i + l][j][k] * (xmax / x);\n      }\n\n      if (dom[i][j + l][k] == 0)\n      {\n        total_pressure_force += pressure_on_solid[i][j + l][k] * (xmax / x);\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/kapferer/tycho_cfd/tycho_release_v1.3.0/sources/data_explorer/3"}
{"code": "for (l = N_E[0][k]; l < N_E[0][k + 1]; l++)\n  for (m = E_N[0][N_E[1][l]]; m < E_N[0][N_E[1][l] + 1]; m++)\n{\n  q = count[k];\n  if (q == 0)\n  {\n    tja[k][1] = E_N[1][m];\n    count[k]++;\n  }\n  else\n    if ((q == 1) && (tja[k][1] > E_N[1][m]))\n  {\n    tja[k][2] = tja[k][1];\n    tja[k][1] = E_N[1][m];\n    count[k]++;\n  }\n  else\n    if (tja[k][q] < E_N[1][m])\n  {\n    tja[k][q + 1] = E_N[1][m];\n    count[k]++;\n  }\n  else\n  {\n    for (o = 1; o <= q; o++)\n    {\n      if (tja[k][o] == E_N[1][m])\n        o = q;\n      else\n        if ((E_N[1][m] > tja[k][o]) && (E_N[1][m] < tja[k][o + 1]))\n      {\n        for (p = q; p > o; p--)\n        {\n          tja[k][p + 1] = tja[k][p];\n        }\n\n        tja[k][o + 1] = E_N[1][m];\n        o = q;\n        count[k]++;\n      }\n\n\n    }\n\n  }\n\n\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vincehouhou/PMG3D/SparseMXNdsetup/0"}
{"code": "for (int i = 0; i < 20; i++)\n{\n  A[i] = i;\n  B[i] = i * i;\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/utpalbora/LLOV/test/2.norace7/0"}
{"code": "for (step = 0; step < stepCount; step++)\n{\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y += 8)\n    {\n      int ind = OMP_Index(0, y, z);\n      u[ind] *= boundryScale;\n      u[ind + OMP_xMax] *= boundryScale;\n      u[(ind + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((ind + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[(((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      u[((((((ind + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] *= boundryScale;\n      for (x = 1; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - 1] * nu;\n        u[xyzInd + OMP_xMax] += u[(xyzInd + OMP_xMax) - 1] * nu;\n        u[(xyzInd + OMP_xMax) + OMP_xMax] += u[((xyzInd + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[(((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n        u[((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax] += u[(((((((xyzInd + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) + OMP_xMax) - 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      u[OMP_Index(0, y, z)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = OMP_xMax - 2; x >= 0; x--)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + 1] * nu;\n      }\n\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, 0, z)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 1; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd - OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  int yval = OMP_yMax - 1;\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (x = 0; x < OMP_xMax; x++)\n    {\n      u[OMP_Index(x, yval, z)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = OMP_yMax - 2; y >= 0; y--)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + OMP_xMax] * nu;\n      }\n\n    }\n\n  }\n\n  for (x = 0; x < OMP_xMax; x++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      u[OMP_Index(x, y, 0)] *= boundryScale;\n    }\n\n  }\n\n  for (z = 1; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] = u[xyzInd - xyMax] * nu;\n      }\n\n    }\n\n  }\n\n  int zval = OMP_zMax - 1;\n  for (x = 0; x < OMP_xMax; x++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      u[OMP_Index(x, y, zval)] *= boundryScale;\n    }\n\n  }\n\n  for (z = OMP_zMax - 2; z >= 0; z--)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        u[xyzInd] += u[xyzInd + xyMax] * nu;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.7/hompDeblur/0"}
{"code": "for (int t = 1; t < ntau; t++)\n{\n  T sum = 0.0;\n  for (int i = 0; i < ((maxt == (-1)) ? (t) : ((maxt < t) ? (maxt) : (t))); i++)\n    sum += ((F == NULL) ? (dF[i]) : ((F[i + 1] - F[i]) / tau)) * bkk[(t - i) - 1];\n\n  sum /= g2a;\n  DF[t] = sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/sevaboh/FPDE_HPC/fr_do/2"}
{"code": "for (int i = 0; i < (threadnum - distance); i += 2 * distance)\n{\n  if (do_first_query)\n    mergeWeekLethalArray(&week_lethal_vector[i][0], week_lethal_vector[i + distance]);\n\n  if (do_second_query)\n    mergeFactor(factor_map_vector[i + distance], factor_map_vector[i]);\n\n  if (do_third_query)\n    mergeBorough(borough_map_vector[i + distance], borough_map_vector[i]);\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Leods96/MPI_OpenMP_Middleware/src/main/2"}
{"code": "for (vertex_id = 0; vertex_id < num_vertices; vertex_id++)\n{\n  vertex_v = labels[vertex_id];\n  if ((*parents)[vertex_id] >= 0)\n  {\n    (*parents_DualOrder)[vertex_v] = labels[(*parents)[vertex_id]];\n  }\n  else\n  {\n    (*parents_DualOrder)[vertex_v] = (*parents)[vertex_id];\n  }\n\n}\n\n", "pragma": "omp parallel for default(none) private(vertex_id,vertex_v) shared(parents,parents_DualOrder,labels,num_vertices) num_threads(num_threads_max)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/BFS/3"}
{"code": "for (k = 0; k < NBFS; ++k)\n  tm[k] = bfs_nedge[k] / bfs_time[k];\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/jandres742/omp2cd/darts-x86/omp2cd-examples/benchmarks/graph500-2.1.4/graph500.output.darts/8"}
{"code": "for (i = 0; i <= 99; i += 1)\n{\n  for (j = 0; j <= 99; j += 1)\n  {\n    a[i][j] = a[i][j] + 1;\n  }\n\n}\n\n", "pragma": "omp parallel for private (i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/dataracebench/DRB046-doall2-orig-no/2"}
{"code": "for (u = 0; u < stats->num_vertices; u++)\n{\n  counts += stats->counts[u];\n}\n\n", "pragma": "omp parallel for default(none) reduction (+ : counts) private(u) shared(stats)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/triangleCount/2"}
{"code": "for (int step = 0; step < nr_steps; ++step)\n  x0 = (x0 * 3.1) * (1.0 - x0);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/gjbex/training-material/OpenMP/Iterators/vector/2"}
{"code": "for (int is = 0; is < ns; is++)\n  for (int i = 0; i < nxc; i++)\n  for (int j = 0; j < nyc; j++)\n  for (int k = 0; k < nzc; k++)\n{\n  rhocs[is][i][j][k] = col->getFluidRhoCenter(i, j, k, is);\n}\n\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/56"}
{"code": "for (i = 0; i < N; i++)\n{\n  tempSum += v[i][0];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/apooreapo/PageRank/pageRankParallelFinal/6"}
{"code": "for (int l = lBegin; l < lEnd; ++l)\n{\n  prefixSum[l] += local_sum;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/GraphReorderAndConverter/graph-reordering/reordering/other-reorderings/SpMP/reordering/RCM/4"}
{"code": "for (int i = 0; i < drawsNumber; i++)\n{\n  hmax += balls - i;\n  hmin += i + 1;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/PaulGrishunin/OpenMP/Experiment/0"}
{"code": "for (int i = 0; i < m; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    if (dabs(C[i][j] - C1[i][j]) > ERR_THRESHOLD)\n    {\n      printf(\"%f  %f at [%d][%d]\\n\", C[i][j], C1[i][j], i, j);\n      code = 1;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/tgmattso/OpenMP_Exercises/challenge_problems/Matmul/Solutions/matmul_recur_par/3"}
{"code": "for (i = 0; i < arraysize; i++)\n{\n  sum = sum + array_A[i];\n}\n\n", "pragma": "omp parallel for reduction(+ : sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/darshanpatil18/OPENMP-and-MPI-PARALLEL-CODING/OPENMPforClause/0"}
{"code": "for (int i = 0; i < nxn; i++)\n{\n  for (int j = 0; j < nyn; j++)\n    for (int k = 0; k < nzn; k++)\n  {\n    Jxs[is][i][j][k] += invVOL * moments[i][j][k][1];\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/EPCCed/MPI_OpenMP_threads/ipic3d/fields/EMfields3D/3"}
{"code": "for (int i = 0; i < size; ++i)\n{\n  result[i] = column[i] * rate;\n}\n\n", "pragma": "omp parallel for default(none) shared(column, result, rate, size)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/artme-uni/OpenMP/OpenMP_2/matrix/column/2"}
{"code": "for (j = 0; j < (ciphertext.size() - 2); j++)\n{\n  writeObj << ciphertext[j];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Shaunak04/PDC-Parallel-Encryption-Algorithms/Des/parallelImplementation/0"}
{"code": "for (i = 0; i < dim1; i++)\n{\n  mat[i] = rand_vec(dim2);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bzurkowski/parallel-computing/lab5/exc1/matmul/2"}
{"code": "for (int i = 0, index = p->index; i < p->length; i++, index++)\n{\n  local_sum += p->array[index];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lchsk/pearson-coefficient-openmp/parallel/6"}
{"code": "for (iterator i = Agents.begin(); i != Agents.end(); ++i)\n{\n  i->connection_replace = replace(gen);\n  replace.reset();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c6/1"}
{"code": "for (index = 0, temp = min; (modifier * temp) <= (modifier * max); index++, temp += step)\n{\n  for (unsigned int j = 0; j < 2000; j++)\n  {\n    update(temp, whites, blacks);\n  }\n\n  unsigned int measurments = 0;\n  double e = 0.0;\n  double e2 = 0.0;\n  double e4 = 0.0;\n  double m = 0.0;\n  double m2 = 0.0;\n  double m4 = 0.0;\n  for (unsigned int j = 0; j < TMAX; j++)\n  {\n    update(temp, whites, blacks);\n    if ((j % calc_step) == 0)\n    {\n      double energy = 0.0;\n      double mag = 0.0;\n      unsigned int M_max = 0;\n      energy = calculateKernel(whites, blacks, &M_max);\n      mag = (((9 * M_max) / (1.0 * (2048 * 2048))) - 1) / ((double) (9 - 1));\n      e += energy;\n      e2 += energy * energy;\n      e4 += ((energy * energy) * energy) * energy;\n      m += mag;\n      m2 += mag * mag;\n      m4 += ((mag * mag) * mag) * mag;\n      measurments++;\n    }\n\n  }\n\n  assert(index < (1 + ((int) ((TEMP_MAX - TEMP_MIN) / 0.00005))));\n  stats[index].t = temp;\n  stats[index].e += e / measurments;\n  stats[index].e2 += e2 / measurments;\n  stats[index].e4 += e4 / measurments;\n  stats[index].m += m / measurments;\n  stats[index].m2 += m2 / measurments;\n  stats[index].m4 += m4 / measurments;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/javiercba/potts_tesis_javier_uranga_2012/potts_OpenMP/potts3-cpu-OMP/13"}
{"code": "for (int i = 0; i < total; ++i)\n{\n  y[i] = predict(X[i]);\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/joyeecheung/parallel-random-forest/src/RandomForest/2"}
{"code": "for (i = 0; i < 1000; i++)\n{\n  for (j = 0; j < 1000; j++)\n    C[i][j] = 0.0;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/chunkaichang/OpenMP-MatrixOP/tiled/1"}
{"code": "for (i = 0; i < a_fila; i++)\n{\n  for (j = 0; j < a_col; j++)\n  {\n    for (k = 0; k < b_col; k++)\n    {\n      C[i][j] = C[i][j] + (A[i][k] * B[k][j]);\n    }\n\n  }\n\n}\n\n", "pragma": "    #pragma omp for schedule (static, pedazos)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Diegox777/openmp-tests/mat_mult_omp/3"}
{"code": "for (i = 1; i <= (grid_points[0] - 2); i++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    lhs[2][i][j][k] = lhs[2][i][j][k] + comz5;\n    lhs[3][i][j][k] = lhs[3][i][j][k] - comz4;\n    lhs[4][i][j][k] = lhs[4][i][j][k] + comz1;\n    lhs[1][i][j][k + 1] = lhs[1][i][j][k + 1] - comz4;\n    lhs[2][i][j][k + 1] = lhs[2][i][j][k + 1] + comz6;\n    lhs[3][i][j][k + 1] = lhs[3][i][j][k + 1] - comz4;\n    lhs[4][i][j][k + 1] = lhs[4][i][j][k + 1] + comz1;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/SP/sp/33"}
{"code": "for (exp = 0; exp < 32; exp++)\n{\n  start = _rdtsc();\n  mat_mult0(M1, M2, M3);\n  end = _rdtsc();\n  experiments[exp] = end - start;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hughnatt/blas-library-openmp/src/exo/19"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  for (j = jst; j <= jend; j++)\n  {\n    tmp1 = 1.0 / u[i][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    d[i][j][0][0] = 1.0 + ((dt * 2.0) * (((tx1 * dx1) + (ty1 * dy1)) + (tz1 * dz1)));\n    d[i][j][0][1] = 0.0;\n    d[i][j][0][2] = 0.0;\n    d[i][j][0][3] = 0.0;\n    d[i][j][0][4] = 0.0;\n    d[i][j][1][0] = (dt * 2.0) * (((tx1 * ((((-r43) * c34) * tmp2) * u[i][j][k][1])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][1]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][1])));\n    d[i][j][1][1] = (1.0 + ((dt * 2.0) * (((((tx1 * r43) * c34) * tmp1) + ((ty1 * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx2) + (ty1 * dy2)) + (tz1 * dz2)));\n    d[i][j][1][2] = 0.0;\n    d[i][j][1][3] = 0.0;\n    d[i][j][1][4] = 0.0;\n    d[i][j][2][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][2])) + (ty1 * ((((-r43) * c34) * tmp2) * u[i][j][k][2]))) + (tz1 * (((-c34) * tmp2) * u[i][j][k][2])));\n    d[i][j][2][1] = 0.0;\n    d[i][j][2][2] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + (((ty1 * r43) * c34) * tmp1)) + ((tz1 * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx3) + (ty1 * dy3)) + (tz1 * dz3)));\n    d[i][j][2][3] = 0.0;\n    d[i][j][2][4] = 0.0;\n    d[i][j][3][0] = (dt * 2.0) * (((tx1 * (((-c34) * tmp2) * u[i][j][k][3])) + (ty1 * (((-c34) * tmp2) * u[i][j][k][3]))) + (tz1 * ((((-r43) * c34) * tmp2) * u[i][j][k][3])));\n    d[i][j][3][1] = 0.0;\n    d[i][j][3][2] = 0.0;\n    d[i][j][3][3] = (1.0 + ((dt * 2.0) * ((((tx1 * c34) * tmp1) + ((ty1 * c34) * tmp1)) + (((tz1 * r43) * c34) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx4) + (ty1 * dy4)) + (tz1 * dz4)));\n    d[i][j][3][4] = 0.0;\n    d[i][j][4][0] = (dt * 2.0) * (((tx1 * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))) + (ty1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4])))) + (tz1 * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i][j][k][2]))) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j][k][3]))) - ((c1345 * tmp2) * u[i][j][k][4]))));\n    d[i][j][4][1] = (dt * 2.0) * (((((tx1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][1]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][1])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][1]));\n    d[i][j][4][2] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]) + (((ty1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][2])) + (((tz1 * (c34 - c1345)) * tmp2) * u[i][j][k][2]));\n    d[i][j][4][3] = (dt * 2.0) * (((((tx1 * (c34 - c1345)) * tmp2) * u[i][j][k][3]) + (((ty1 * (c34 - c1345)) * tmp2) * u[i][j][k][3])) + (((tz1 * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k][3]));\n    d[i][j][4][4] = (1.0 + ((dt * 2.0) * ((((tx1 * c1345) * tmp1) + ((ty1 * c1345) * tmp1)) + ((tz1 * c1345) * tmp1)))) + ((dt * 2.0) * (((tx1 * dx5) + (ty1 * dy5)) + (tz1 * dz5)));\n    tmp1 = 1.0 / u[i][j][k - 1][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    a[i][j][0][0] = ((-dt) * tz1) * dz1;\n    a[i][j][0][1] = 0.0;\n    a[i][j][0][2] = 0.0;\n    a[i][j][0][3] = (-dt) * tz2;\n    a[i][j][0][4] = 0.0;\n    a[i][j][1][0] = (((-dt) * tz2) * ((-(u[i][j][k - 1][1] * u[i][j][k - 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k - 1][1]));\n    a[i][j][1][1] = ((((-dt) * tz2) * (u[i][j][k - 1][3] * tmp1)) - (((dt * tz1) * c34) * tmp1)) - ((dt * tz1) * dz2);\n    a[i][j][1][2] = 0.0;\n    a[i][j][1][3] = ((-dt) * tz2) * (u[i][j][k - 1][1] * tmp1);\n    a[i][j][1][4] = 0.0;\n    a[i][j][2][0] = (((-dt) * tz2) * ((-(u[i][j][k - 1][2] * u[i][j][k - 1][3])) * tmp2)) - ((dt * tz1) * (((-c34) * tmp2) * u[i][j][k - 1][2]));\n    a[i][j][2][1] = 0.0;\n    a[i][j][2][2] = ((((-dt) * tz2) * (u[i][j][k - 1][3] * tmp1)) - ((dt * tz1) * (c34 * tmp1))) - ((dt * tz1) * dz3);\n    a[i][j][2][3] = ((-dt) * tz2) * (u[i][j][k - 1][2] * tmp1);\n    a[i][j][2][4] = 0.0;\n    a[i][j][3][0] = (((-dt) * tz2) * (((-(u[i][j][k - 1][3] * tmp1)) * (u[i][j][k - 1][3] * tmp1)) + ((0.50 * C2) * ((((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + (u[i][j][k - 1][3] * u[i][j][k - 1][3])) * tmp2)))) - ((dt * tz1) * ((((-r43) * c34) * tmp2) * u[i][j][k - 1][3]));\n    a[i][j][3][1] = ((-dt) * tz2) * ((-C2) * (u[i][j][k - 1][1] * tmp1));\n    a[i][j][3][2] = ((-dt) * tz2) * ((-C2) * (u[i][j][k - 1][2] * tmp1));\n    a[i][j][3][3] = (((((-dt) * tz2) * (2.0 - C2)) * (u[i][j][k - 1][3] * tmp1)) - ((dt * tz1) * ((r43 * c34) * tmp1))) - ((dt * tz1) * dz4);\n    a[i][j][3][4] = ((-dt) * tz2) * C2;\n    a[i][j][4][0] = (((-dt) * tz2) * ((((C2 * (((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + (u[i][j][k - 1][3] * u[i][j][k - 1][3]))) * tmp2) - (C1 * (u[i][j][k - 1][4] * tmp1))) * (u[i][j][k - 1][3] * tmp1))) - ((dt * tz1) * ((((((-(c34 - c1345)) * tmp3) * (u[i][j][k - 1][1] * u[i][j][k - 1][1])) - (((c34 - c1345) * tmp3) * (u[i][j][k - 1][2] * u[i][j][k - 1][2]))) - ((((r43 * c34) - c1345) * tmp3) * (u[i][j][k - 1][3] * u[i][j][k - 1][3]))) - ((c1345 * tmp2) * u[i][j][k - 1][4])));\n    a[i][j][4][1] = (((-dt) * tz2) * (((-C2) * (u[i][j][k - 1][1] * u[i][j][k - 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k - 1][1]);\n    a[i][j][4][2] = (((-dt) * tz2) * (((-C2) * (u[i][j][k - 1][2] * u[i][j][k - 1][3])) * tmp2)) - ((((dt * tz1) * (c34 - c1345)) * tmp2) * u[i][j][k - 1][2]);\n    a[i][j][4][3] = (((-dt) * tz2) * ((C1 * (u[i][j][k - 1][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j][k - 1][1] * u[i][j][k - 1][1]) + (u[i][j][k - 1][2] * u[i][j][k - 1][2])) + ((3.0 * u[i][j][k - 1][3]) * u[i][j][k - 1][3])) * tmp2)))) - ((((dt * tz1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j][k - 1][3]);\n    a[i][j][4][4] = ((((-dt) * tz2) * (C1 * (u[i][j][k - 1][3] * tmp1))) - (((dt * tz1) * c1345) * tmp1)) - ((dt * tz1) * dz5);\n    tmp1 = 1.0 / u[i][j - 1][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    b[i][j][0][0] = ((-dt) * ty1) * dy1;\n    b[i][j][0][1] = 0.0;\n    b[i][j][0][2] = (-dt) * ty2;\n    b[i][j][0][3] = 0.0;\n    b[i][j][0][4] = 0.0;\n    b[i][j][1][0] = (((-dt) * ty2) * ((-(u[i][j - 1][k][1] * u[i][j - 1][k][2])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j - 1][k][1]));\n    b[i][j][1][1] = ((((-dt) * ty2) * (u[i][j - 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy2);\n    b[i][j][1][2] = ((-dt) * ty2) * (u[i][j - 1][k][1] * tmp1);\n    b[i][j][1][3] = 0.0;\n    b[i][j][1][4] = 0.0;\n    b[i][j][2][0] = (((-dt) * ty2) * (((-(u[i][j - 1][k][2] * tmp1)) * (u[i][j - 1][k][2] * tmp1)) + ((0.50 * C2) * ((((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + (u[i][j - 1][k][2] * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3])) * tmp2)))) - ((dt * ty1) * ((((-r43) * c34) * tmp2) * u[i][j - 1][k][2]));\n    b[i][j][2][1] = ((-dt) * ty2) * ((-C2) * (u[i][j - 1][k][1] * tmp1));\n    b[i][j][2][2] = ((((-dt) * ty2) * ((2.0 - C2) * (u[i][j - 1][k][2] * tmp1))) - ((dt * ty1) * ((r43 * c34) * tmp1))) - ((dt * ty1) * dy3);\n    b[i][j][2][3] = ((-dt) * ty2) * ((-C2) * (u[i][j - 1][k][3] * tmp1));\n    b[i][j][2][4] = ((-dt) * ty2) * C2;\n    b[i][j][3][0] = (((-dt) * ty2) * ((-(u[i][j - 1][k][2] * u[i][j - 1][k][3])) * tmp2)) - ((dt * ty1) * (((-c34) * tmp2) * u[i][j - 1][k][3]));\n    b[i][j][3][1] = 0.0;\n    b[i][j][3][2] = ((-dt) * ty2) * (u[i][j - 1][k][3] * tmp1);\n    b[i][j][3][3] = ((((-dt) * ty2) * (u[i][j - 1][k][2] * tmp1)) - ((dt * ty1) * (c34 * tmp1))) - ((dt * ty1) * dy4);\n    b[i][j][3][4] = 0.0;\n    b[i][j][4][0] = (((-dt) * ty2) * ((((C2 * (((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + (u[i][j - 1][k][2] * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3]))) * tmp2) - (C1 * (u[i][j - 1][k][4] * tmp1))) * (u[i][j - 1][k][2] * tmp1))) - ((dt * ty1) * ((((((-(c34 - c1345)) * tmp3) * pow2(u[i][j - 1][k][1])) - ((((r43 * c34) - c1345) * tmp3) * pow2(u[i][j - 1][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i][j - 1][k][3]))) - ((c1345 * tmp2) * u[i][j - 1][k][4])));\n    b[i][j][4][1] = (((-dt) * ty2) * (((-C2) * (u[i][j - 1][k][1] * u[i][j - 1][k][2])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j - 1][k][1]);\n    b[i][j][4][2] = (((-dt) * ty2) * ((C1 * (u[i][j - 1][k][4] * tmp1)) - ((0.50 * C2) * ((((u[i][j - 1][k][1] * u[i][j - 1][k][1]) + ((3.0 * u[i][j - 1][k][2]) * u[i][j - 1][k][2])) + (u[i][j - 1][k][3] * u[i][j - 1][k][3])) * tmp2)))) - ((((dt * ty1) * ((r43 * c34) - c1345)) * tmp2) * u[i][j - 1][k][2]);\n    b[i][j][4][3] = (((-dt) * ty2) * (((-C2) * (u[i][j - 1][k][2] * u[i][j - 1][k][3])) * tmp2)) - ((((dt * ty1) * (c34 - c1345)) * tmp2) * u[i][j - 1][k][3]);\n    b[i][j][4][4] = ((((-dt) * ty2) * (C1 * (u[i][j - 1][k][2] * tmp1))) - (((dt * ty1) * c1345) * tmp1)) - ((dt * ty1) * dy5);\n    tmp1 = 1.0 / u[i - 1][j][k][0];\n    tmp2 = tmp1 * tmp1;\n    tmp3 = tmp1 * tmp2;\n    c[i][j][0][0] = ((-dt) * tx1) * dx1;\n    c[i][j][0][1] = (-dt) * tx2;\n    c[i][j][0][2] = 0.0;\n    c[i][j][0][3] = 0.0;\n    c[i][j][0][4] = 0.0;\n    c[i][j][1][0] = (((-dt) * tx2) * (((-(u[i - 1][j][k][1] * tmp1)) * (u[i - 1][j][k][1] * tmp1)) + (((C2 * 0.50) * (((u[i - 1][j][k][1] * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3]))) * tmp2))) - ((dt * tx1) * ((((-r43) * c34) * tmp2) * u[i - 1][j][k][1]));\n    c[i][j][1][1] = ((((-dt) * tx2) * ((2.0 - C2) * (u[i - 1][j][k][1] * tmp1))) - ((dt * tx1) * ((r43 * c34) * tmp1))) - ((dt * tx1) * dx2);\n    c[i][j][1][2] = ((-dt) * tx2) * ((-C2) * (u[i - 1][j][k][2] * tmp1));\n    c[i][j][1][3] = ((-dt) * tx2) * ((-C2) * (u[i - 1][j][k][3] * tmp1));\n    c[i][j][1][4] = ((-dt) * tx2) * C2;\n    c[i][j][2][0] = (((-dt) * tx2) * ((-(u[i - 1][j][k][1] * u[i - 1][j][k][2])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i - 1][j][k][2]));\n    c[i][j][2][1] = ((-dt) * tx2) * (u[i - 1][j][k][2] * tmp1);\n    c[i][j][2][2] = ((((-dt) * tx2) * (u[i - 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx3);\n    c[i][j][2][3] = 0.0;\n    c[i][j][2][4] = 0.0;\n    c[i][j][3][0] = (((-dt) * tx2) * ((-(u[i - 1][j][k][1] * u[i - 1][j][k][3])) * tmp2)) - ((dt * tx1) * (((-c34) * tmp2) * u[i - 1][j][k][3]));\n    c[i][j][3][1] = ((-dt) * tx2) * (u[i - 1][j][k][3] * tmp1);\n    c[i][j][3][2] = 0.0;\n    c[i][j][3][3] = ((((-dt) * tx2) * (u[i - 1][j][k][1] * tmp1)) - ((dt * tx1) * (c34 * tmp1))) - ((dt * tx1) * dx4);\n    c[i][j][3][4] = 0.0;\n    c[i][j][4][0] = (((-dt) * tx2) * ((((C2 * (((u[i - 1][j][k][1] * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3]))) * tmp2) - (C1 * (u[i - 1][j][k][4] * tmp1))) * (u[i - 1][j][k][1] * tmp1))) - ((dt * tx1) * ((((((-((r43 * c34) - c1345)) * tmp3) * pow2(u[i - 1][j][k][1])) - (((c34 - c1345) * tmp3) * pow2(u[i - 1][j][k][2]))) - (((c34 - c1345) * tmp3) * pow2(u[i - 1][j][k][3]))) - ((c1345 * tmp2) * u[i - 1][j][k][4])));\n    c[i][j][4][1] = (((-dt) * tx2) * ((C1 * (u[i - 1][j][k][4] * tmp1)) - ((0.50 * C2) * (((((3.0 * u[i - 1][j][k][1]) * u[i - 1][j][k][1]) + (u[i - 1][j][k][2] * u[i - 1][j][k][2])) + (u[i - 1][j][k][3] * u[i - 1][j][k][3])) * tmp2)))) - ((((dt * tx1) * ((r43 * c34) - c1345)) * tmp2) * u[i - 1][j][k][1]);\n    c[i][j][4][2] = (((-dt) * tx2) * (((-C2) * (u[i - 1][j][k][2] * u[i - 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i - 1][j][k][2]);\n    c[i][j][4][3] = (((-dt) * tx2) * (((-C2) * (u[i - 1][j][k][3] * u[i - 1][j][k][1])) * tmp2)) - ((((dt * tx1) * (c34 - c1345)) * tmp2) * u[i - 1][j][k][3]);\n    c[i][j][4][4] = ((((-dt) * tx2) * (C1 * (u[i - 1][j][k][1] * tmp1))) - (((dt * tx1) * c1345) * tmp1)) - ((dt * tx1) * dx5);\n  }\n\n}\n\n", "pragma": "omp for private(tmp1, tmp2, tmp3)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/reference_cpu_threading/NPB3.0-omp-c/LU/lu/21"}
{"code": "for (int i = 0; i < N; i++)\n{\n  A[i] = i;\n  if (i == 1)\n  {\n    A[0] = 1;\n  }\n\n}\n\n", "pragma": "omp parallel for shared(A)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/dataracebench/micro-benchmarks/DRB179-thread-sensitivity-yes/0"}
{"code": "for (b = 0; b < batch; b++)\n{\n  sum = 0;\n  for (i = 0; i < N; i++)\n  {\n    if (input[(b * N) + i] > largest)\n      largest = input[(b * N) + i];\n\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    float e = exp(input[(b * N) + i] - largest);\n    output[(b * N) + i] = e;\n    sum += e;\n  }\n\n  for (i = 0; i < N; i++)\n  {\n    output[(b * N) + i] = output[(b * N) + i] / sum;\n  }\n\n}\n\n", "pragma": "#pragma omp target teams distribute parallel for private(i) reduction(+:sum) map(to:input[0:HWC_in]) map(tofrom:output[0:HWC_out])", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ambipomyan/CNN_OpenMP/conv-omp-gpu/2"}
{"code": "for (i = 0; i < ARCHnodes; i++)\n  for (j = 0; j < 3; j++)\n  disp[disptplus][i][j] = 0.0;\n\n\n", "pragma": "omp parallel for private(i,j) firstprivate(ARCHnodes,disptplus)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rainaby/quakeSimulatorOpenMP/superQuakeV2/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    printf(\"Hello from thread #%d iteration i#%d j#%d\\n\", omp_get_thread_num(), i, j);\n  }\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vitorgt/OpenMP-tests/nest/0"}
{"code": "for (ei = start_edge; ei < end_edge; ++ei)\n{\n  mrg_state new_state = state;\n  mrg_skip(&new_state, 0, (uint64_t) ei, 0);\n  make_one_edge(nverts, 0, logN, &new_state, edges + (ei - start_edge), val0, val1);\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/graph500-2.1.4/mpi-tuned-2d/generator/graph_generator/0"}
{"code": "for (wI = 0; wI < SMALLN_MATR; wI++)\n{\n  for (wJ = 0; wJ < wI; wJ++)\n  {\n    wTemp = aMatr1[wI][wJ];\n    aMatr1[wI][wJ] = aMatr1[wJ][wI];\n    aMatr1[wJ][wI] = wTemp;\n  }\n\n}\n\n", "pragma": "omp parallel for private(wI, wJ, wTemp) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gattazr-student/MN-openmp/src/matrs/8"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (i <= 10)\n  {\n    work(i);\n  }\n\n  if (i > 10)\n  {\n    work(i + 1);\n  }\n\n}\n\n", "pragma": "omp for ordered", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/gcc.dg/gomp/appendix-a/a.21.3/0"}
{"code": "for (p++; m[p]; p++)\n  ;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Mrrvm/CPD/Labs/1617E2/sieve/1"}
{"code": "for (int j = 0; j <= n; j++)\n  C[indexOf(0, j)] = 0;\n\n", "pragma": "  #pragma omp for schedule(runtime) ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/shiva49814/OpenMPTasks/LCS/3"}
{"code": "for (int y = 0; y < HEI; y++)\n  for (int x = 0; x < WID; x++)\n{\n  float d = 0;\n  int i = 0;\n  do\n    d += F[i] * rsqrt(((X[i] - x) * (X[i] - x)) + ((Y[i] - y) * (Y[i] - y)));\n  while ((++i) < ms);\n  memcpy(manor + (((((HEI - 1) - y) * WID) + x) * 3), col[(d > 255) ? (255) : ((d < 0) ? (0) : ((unsigned char) d))], 3);\n}\n\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/serprex/Metaballs/meta/3"}
{"code": "for (int i = 0; i < image->height; i++)\n{\n  for (unsigned j = 0; j < image->width; j++)\n  {\n    const int id = (i * image->width) + j;\n    image->pixelData[id].red = encodeSrgb(image->pixelData[id].red);\n    image->pixelData[id].green = encodeSrgb(image->pixelData[id].green);\n    image->pixelData[id].blue = encodeSrgb(image->pixelData[id].blue);\n  }\n\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/apardyl/raytracer/CUDA-RayTracer/backends/post_processing/SRGBEncode/0"}
{"code": "for (int cout = 0; cout < kernel.Cout; cout++)\n{\n  for (int cin = 0; cin < kernel.Cin; cin++)\n  {\n    for (int hk = 0; hk < kernel.H; hk++)\n    {\n      for (int wk = 0; wk < kernel.W; wk++)\n      {\n        posH = hk * kernel.dilH;\n        posW = wk * kernel.dilW;\n        kernel_idx = find_kernel_idx(cout, cin, hk, wk, kernel);\n        kernel_idx_new = find_CCHW_idx(cout, cin, posH, posW, kernel.Cout, kernel.Cin, newH, newW);\n        B_dil[kernel_idx_new] = kernel.data[kernel_idx];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yuzhouhe2000/Dilated-Winograd-Convolution/cpu/utils/10"}
{"code": "for (i = 0; i < m; i++)\n{\n  for (j = 0; j < n; j++)\n    for (k = 0; k < o; k++)\n  {\n    bar(i, j, k);\n  }\n\n\n}\n\n", "pragma": "omp for collapse(2) ordered(3)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/sink-1/5"}
{"code": "for (int j = 0; j != numTeams; j++)\n{\n  foo++;\n}\n\n", "pragma": "omp target teams distribute parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ROCm-Developer-Tools/aomp/test/smoke/CanonNE/CanonNE/0"}
{"code": "for (i = 0; i < n; i++)\n{\n  const unsigned char color[] = {(unsigned char) (m[i] / SQRT_MAX_WEIGHT), 255, (unsigned char) (((int) m[i]) % SQRT_MAX_WEIGHT)};\n  img.draw_circle(x[i], y[i], 1, color);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brabemi/ctu-fit-mi-pap-mod/main/2"}
{"code": "for (int i = 0; i < tm.rows(); i++)\n{\n  for (int j = 0; j < tm.cols(); j++)\n  {\n    tm(i, j) = 1.0 / tm(i, j);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vaishmantha/parallelImageStitcher/examples/image_stitching_cuda/image_stitching/7"}
{"code": "for (i = 0; i < batch_size; i++)\n{\n  const int mm = m_vbatch[i];\n  const int nn = n_vbatch[i];\n  const int kk = k_vbatch[i];\n  const char transa = transa_vbatch[i];\n  const char transb = transb_vbatch[i];\n  const double alpha = alpha_vbatch[i];\n  const double beta = beta_vbatch[i];\n  const int lda = lda_vbatch[i];\n  const int ldb = ldb_vbatch[i];\n  const int ldc = ldc_vbatch[i];\n  const double *pa = a_vbatch[i];\n  const double *pb = b_vbatch[i];\n  double *pc = c_vbatch[i];\n  dgemm_(&transa, &transb, &mm, &nn, &kk, &alpha, pa, &lda, pb, &ldb, &beta, pc, &ldc);\n}\n\n", "pragma": "omp parallel for private(i) schedule(dynamic)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/arghyac007/DMRG-openMP/Analysis/dmrg_vbatch/0"}
{"code": "for (int i = 0; i < 8; i++)\n{\n  fgets(buf, sizeof(buf), fp);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GChaitanya2001/HP3-OpenMP/Many Body Simulation/many-body-sim-program/5"}
{"code": "for (idx_t n = 0; n < N; ++n)\n{\n  A->vals[n + (n * N)] = 1.;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ShadenSmith/splatt/src/matrix/14"}
{"code": "for (int i = rank - 1; i >= 0; i--)\n{\n  x[indices[i]] = b[i];\n}\n\n", "pragma": "    #pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/htakeuchi0/openmp_sample/src/matutil/38"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < 2048; j++)\n  {\n    grid[i][j] = rand() % 2;\n    numCell += grid[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/brunosampaio08-zz/Game-Of-Life-PCD/gof-openmp/6"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  for (int i = 0; i < 10; ++i)\n    ++a;\n\n}\n\n", "pragma": "#pragma omp distribute parallel for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/AstroVPK/LLVM-4.0.0/llvm/tools/clang/test/OpenMP/nesting_of_regions/26"}
{"code": "for (i = 0; i < params->n; i++)\n{\n  x = left + (i * delta);\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "omp for reduction(+:sum)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gjbex/training-material/LinuxTools/Checkpointing/Hybrid/pi/0"}
{"code": "for (int i = 0; i < 10; i++)\n  b[i] = computeValB(i);\n\n", "pragma": "\t\t#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bluekds/OpenMP-Programming/Lecture6/nowait_clause/nowait_clause/1"}
{"code": "for (NUMTHREADS = STARTNUMTHREAD; NUMTHREADS <= 20; NUMTHREADS++)\n{\n  for (i = 0; i < controlLength; i++)\n  {\n    gettimeofday(&t0, 0);\n    processData(controlData[0][i], controlData[1][i], controlData[2][i]);\n    gettimeofday(&t1, 0);\n    wallclockMicro = ((t1.tv_sec - t0.tv_sec) * 1000000) + (t1.tv_usec - t0.tv_usec);\n    if (textLength[controlData[1][i]] == patternLength[controlData[2][i]])\n      worstcaseComparisons[i] = (long long) textLength[controlData[1][i]];\n    else\n      worstcaseComparisons[i] = ((long long) patternLength[controlData[2][i]]) * (((long long) textLength[controlData[1][i]]) - ((long long) patternLength[controlData[2][i]]));\n\n    if ((wallclockMicro < minWallclockMicro[i]) || (NUMTHREADS == STARTNUMTHREAD))\n    {\n      minWallclockMicro[i] = wallclockMicro;\n      optimal_NUMTHREADS[i] = NUMTHREADS;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/paullewisjohnston/hpc-pattern-searching/project_OMP/1"}
{"code": "for (i = 0; i < ((2048 * 2048) / maxThreads); i++)\n{\n  for (j = 0; j < maxThreads; j++)\n  {\n    sorted[(maxThreads * i) + j] = v[(subArraySize * j) + i];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/BTHgruppen/OpenMPDV2544project/QuickSort_Parallell/2"}
{"code": "for (int i = 0; i < N_b; ++i)\n{\n  seq_b_floats[i] = char_seqb[i];\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(static, 16)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/memaskal/sequence-alignment/smwt-paral/smwt-paral/0"}
{"code": "for (j = 1; j <= m; j += 1)\n{\n  t = 3.141592653589793238 / ln;\n  for (i = 0; i <= (ln - 1); i += 1)\n  {\n    ti = i * t;\n    u[i + ku].real = cos(ti);\n    u[i + ku].imag = sin(ti);\n  }\n\n  ku = ku + ln;\n  ln = 2 * ln;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/Autopar/NPB3.0-omp-c/FT/ft/27"}
{"code": "for (int i = M - 100; i < M; ++i)\n{\n  (cout << alleleFreqVec[i]) << ' ';\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/styvon/sparseLMM/src/sparseLMM_OMP/7"}
{"code": "for (int i = 0; i < 5; i++)\n{\n  for (int j = 0; j < 5; j++)\n  {\n    printf(\"%d\\t\", a[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/josephv7/OpenMP_Repo/flush1/5"}
{"code": "for (int i = 0; i < 992; i++)\n{\n  dpA[i + 100] = (dpC[i + 200] + dpD[i + 300]) + 1;\n}\n\n", "pragma": "omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/clang-ykt/omptests/t-unified-target-api/test/0"}
{"code": "for (x = 0; x < 10; x++)\n{\n  for (y = 0; y < 10; y++)\n    v++;\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sharanyansrikanthan/OpenMP_MAP/gcc/testsuite/c-c++-common/gomp/pr53580/0"}
{"code": "for (;;)\n{\n  read_fd = master;\n  fflush(stdout);\n  scaduto = select(maxfd + 1, &read_fd, 0, 0, 0);\n  if (scaduto == (-1))\n  {\n    printf(\"errrore select\\n\");\n    exit(1);\n  }\n\n  for (i = 0; i <= maxfd; i++)\n  {\n    if (FD_ISSET(i, &read_fd))\n    {\n      if (i == 0)\n      {\n        tastiera();\n      }\n      else\n        if (i == sk)\n        mexserver();\n\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DamianoBarone/Pmac_security/client/10"}
{"code": "for (j = 0; j < STREAM_ARRAY_SIZE; j++)\n{\n  if (((((b[j] / bj) - 1.0) >= 0) ? ((b[j] / bj) - 1.0) : (-((b[j] / bj) - 1.0))) > epsilon)\n  {\n    ierr++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/yoyz/openmp/mcalpin_stream/stream/24"}
{"code": "for (int ai = 0; ai < this->nrow_; ++ai)\n{\n  row_key += (row_sign * row_tmp) * (row_mask & this->mat_.row_offset[ai]);\n  row_key = row_key ^ (row_key >> 16);\n  row_sign = sgn(row_tmp - (row_mask & this->mat_.row_offset[ai]));\n  row_tmp = row_mask & this->mat_.row_offset[ai];\n  int row_beg = this->mat_.row_offset[ai];\n  int row_end = this->mat_.row_offset[ai + 1];\n  for (int aj = row_beg; aj < row_end; ++aj)\n  {\n    col_key += (col_sign * col_tmp) * (col_mask | this->mat_.col[aj]);\n    col_key = col_key ^ (col_key >> 16);\n    col_sign = sgn(row_tmp - (col_mask | this->mat_.col[aj]));\n    col_tmp = col_mask | this->mat_.col[aj];\n    double double_val = abs(this->mat_.val[aj]);\n    long int val = 0;\n    assert((sizeof(long int)) == (sizeof(double)));\n    memcpy(&val, &double_val, sizeof(long int));\n    val_key += (val_sign * val_tmp) * ((long int) (val_mask | val));\n    val_key = val_key ^ (val_key >> 16);\n    if (sgn(this->mat_.val[aj]) > 0)\n    {\n      val_key = val_key ^ val;\n    }\n    else\n    {\n      val_key = val_key | val;\n    }\n\n    val_sign = sgn(val_tmp - ((long int) (val_mask | val)));\n    val_tmp = val_mask | val;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ROCmSoftwarePlatform/rocALUTION/src/base/host/host_matrix_csr/119"}
{"code": "for (i = 0; i <= max_aa; i++)\n  for (j = 1; j <= i; j++)\n{\n  if (matrix[i][j] < min)\n    min = matrix[i][j];\n\n  if (matrix[i][j] > max)\n    max = matrix[i][j];\n\n}\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/joao-lima/bots-omp4/omp-tasks/alignment/alignment_for/alignment/4"}
{"code": "for (int i = 0; i < v.size(); i++)\n  (cout << v[i]) << \" \";\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/VladislavSmekhnov/OpenMP_tasks/openmp_8/0"}
{"code": "for (i = 1; i < iterations; ++i)\n{\n  SHA256_Init(&ctx);\n  SHA256_Update(&ctx, digest, 32);\n  SHA256_Final(digest, &ctx);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/keyring_fmt_plug/3"}
{"code": "for (j = 2; j <= N; j++)\n{\n  if (array[j] == 0)\n  {\n    fprintf(f, \"%d%s %d%s %d\\n\", counter, \",\", j, \",\", j - previousPrime);\n    previousPrime = j;\n    counter++;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adithepnarula/Parallel-computing/OpenMP/genprime/1"}
{"code": "for (sh = 0; sh < sheight; ++sh)\n{\n  printf(\"================= sh : %d ================\\n\", sh);\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    for (h = 0; h < 32; h++)\n    {\n      for (w = 0; w < 32; ++w)\n      {\n        for (c = 0; c < 3; ++c)\n        {\n          tile_buf[c][h][w] = img[(((((sh * 32) + h) * width) + ((sw * 32) + w)) * 3) + c];\n        }\n\n      }\n\n    }\n\n    memcpy((void *) (thread_buf + (sw * 3072)), tile_buf, 3072);\n  }\n\n  printf(\"================= sh : %d, copy complete ================\\n\", sh);\n  for (sw = 0; sw < swidth; ++sw)\n  {\n    int min_diff = 2147483647;\n    int min_i = -1;\n    for (i = 0; i < 60000; ++i)\n    {\n      int diff = 0;\n      for (c = 0; c < 3; ++c)\n      {\n        for (h = 0; h < 32; ++h)\n        {\n          for (w = 0; w < 32; ++w)\n          {\n            int pixel_diff = ((int) thread_buf[(((((sw * 3) + c) * 32) + h) * 32) + w]) - ((int) dataset[(((((i * 3) + c) * 32) + h) * 32) + w]);\n            diff += pixel_diff * pixel_diff;\n          }\n\n        }\n\n      }\n\n      if (min_diff > diff)\n      {\n        min_diff = diff;\n        min_i = i;\n      }\n\n    }\n\n    idx[(sh * swidth) + sw] = min_i;\n  }\n\n  printf(\"================= sh : %d, computation complete ================\\n\", sh);\n}\n\n", "pragma": "omp for schedule(static) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mr3coi/Photomosaic_acceleration/A/photomosaic/7"}
{"code": "for (int i = 0; i < rows; i++)\n  for (int j = 0; j < columns; j++)\n  fscanf(fin, \"%d\", &init_board[i][j]);\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SilverSoldier/game-of-life/gol/4"}
{"code": "for (int i = 0; i < size; i++)\n{\n  setQueen(queens, row + 1, i, size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/CSalih/Parallel-Programming/Assignment7/Task2/NQueensParallel/2"}
{"code": "for (size_t i = 0; i < 10; i++)\n{\n  printf(\"\\t\");\n  for (size_t j = 0; j < 10; j++)\n  {\n    printf(\" %d \", C[i][j]);\n  }\n\n  printf(\"\\n\");\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/djaliiil/OpenMP/omp_tp1_exo3/4"}
{"code": "for (i = 0; i < (c->ncols + 1); ++i)\n  printf(\"%u \", (int) c->colPtr[i]);\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crosstreet74/spmv-omp-phi/sparse/9"}
{"code": "for (int i = 0; i < num_steps; i++)\n{\n  x = (i + 0.5) * step;\n  sum += 4.0 / (1.0 + (x * x));\n}\n\n", "pragma": "\t#pragma omp parallel for private(x) reduction(+:sum)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/chenthillrulz/openmp/parallel_pi_loop_construct_private/0"}
{"code": "for (int i = 0; i < agentcounta; ++i)\n{\n  if (i == 0)\n    out << \",\";\n\n  (out << \"cted \") << i;\n  if (i <= 98)\n    out << \",\";\n\n  if (i == 99)\n    out << \"\\n\";\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/lschweiger/NK_space_cpp_gomez/NK_space_action-c6/2"}
{"code": "for (int i = 0; i < n; i++)\n{\n  float pi = 0;\n  int v = source[i];\n  for (int ki = 0; ki <= k; ki++)\n  {\n    pi += (ki + v) / (((2 * k) * 0.29) + 1.33);\n  }\n\n  pi *= 4;\n  dest[i] = (int) pi;\n}\n\n", "pragma": "\t\t\t#pragma omp for schedule(auto) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/map/0"}
{"code": "for (j = 0; j < size; j++)\n{\n  oldPageRank[j] = 1.0 / max;\n}\n\n", "pragma": "\t\t\t\t#pragma omp for schedule (static,chunk)\t", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/srinivasbalaji-1/openmpProject/facebookEgo/3"}
{"code": "for (int k = 0; k < n; k++)\n{\n  pthread_t *threadMain;\n  threadMain = malloc(thread_count * (sizeof(pthread_t)));\n  max = 0;\n  remain = thread_count;\n  struct findMaxArgs mstr[thread_count];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    mstr[thread].rank = thread;\n    mstr[thread].sizeForAlgo = n;\n    mstr[thread].arr = a;\n    mstr[thread].k = k;\n    pthread_create(&threadMain[thread], 0, findMax, (void *) (&mstr[thread]));\n  }\n\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    pthread_join(threadMain[thread], 0);\n  }\n\n  if (max == 0)\n  {\n    printf(\"Matrix is Singular\\n\");\n    break;\n  }\n\n  double tmp;\n  tmp = pi[k];\n  pi[k] = pi[kdash];\n  pi[kdash] = tmp;\n  struct swapAArgs swapastr[thread_count];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    swapastr[thread].rank = thread;\n    swapastr[thread].sizeForAlgo = n;\n    swapastr[thread].arr = a;\n    swapastr[thread].k = k;\n    pthread_create(&threadMain[thread], 0, swap, (void *) (&swapastr[thread]));\n  }\n\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    pthread_join(threadMain[thread], 0);\n  }\n\n  struct swapAArgs swaplstr[thread_count];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    swaplstr[thread].rank = thread;\n    swaplstr[thread].sizeForAlgo = k;\n    swaplstr[thread].arr = l;\n    swaplstr[thread].k = k;\n    pthread_create(&threadMain[thread], 0, swap, (void *) (&swaplstr[thread]));\n  }\n\n  u[(k * n) + k] = a[(k * n) + k];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    pthread_join(threadMain[thread], 0);\n  }\n\n  struct ForArgs firstforstr[thread_count];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    firstforstr[thread].k = k;\n    firstforstr[thread].rank = thread;\n    firstforstr[thread].sizeForAlgo = n;\n    firstforstr[thread].a = a;\n    firstforstr[thread].l = l;\n    firstforstr[thread].u = u;\n    firstforstr[thread].start = k + 1;\n    pthread_create(&threadMain[thread], 0, firstFor, (void *) (&firstforstr[thread]));\n  }\n\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    pthread_join(threadMain[thread], 0);\n  }\n\n  struct ForArgs secforstr[thread_count];\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    secforstr[thread].k = k;\n    secforstr[thread].rank = thread;\n    secforstr[thread].sizeForAlgo = n;\n    secforstr[thread].a = a;\n    secforstr[thread].l = l;\n    secforstr[thread].u = u;\n    secforstr[thread].start = k + 1;\n    pthread_create(&threadMain[thread], 0, SecondFor, (void *) (&secforstr[thread]));\n  }\n\n  for (thread = 0; thread < thread_count; thread++)\n  {\n    pthread_join(threadMain[thread], 0);\n  }\n\n  free(threadMain);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/crekIron/Parallel_Implementation_of_LU_Decomposition/main/10"}
{"code": "for (i = 2; i < t; i++)\n{\n  if (skip)\n    continue;\n\n  if ((t % i) == 0)\n    continue;\n\n  flag = prime(i);\n  if ((((flag == 1) && (i != p)) && (i != q)) && (i != r))\n  {\n    e[k] = i;\n    long int ed = 1;\n    while (1)\n    {\n      ed = ed + t;\n      if ((ed % e[k]) == 0)\n      {\n        flag = ed / e[k];\n        break;\n      }\n\n    }\n\n    if (flag > 0)\n    {\n      d[k] = flag;\n      k++;\n    }\n\n    if (k == 99)\n      skip = true;\n\n  }\n\n}\n\n", "pragma": "    #pragma omp parallel for firstprivate(k)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/iownit15/Parallelized-RSA-Algorithm/projfinal/0"}
{"code": "for (k = 0; k <= (nz2 + 1); k++)\n{\n  for (j = 0; j <= (ny2 + 1); j++)\n  {\n    for (i = 0; i <= (nx2 + 1); i++)\n    {\n      for (m = 0; m < 5; m++)\n      {\n        rhs[k][j][i][m] = forcing[k][j][i][m];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/rlyerly/NUMA-ExtWorkload-OMP-Scheduler/bench/NPB3.3-OMP-C/SP/rhs/1"}
{"code": "for (int i = 0; i < s; i++)\n{\n  int rond = (rand() % 100) + 1;\n  ilgi[i] = rond;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/OsamaTab/openMp/OpenMp/Source/2"}
{"code": "for (i = 0; i < n; i++)\n{\n  sum = max(a[i] + b[i], (4 * a[i]) - b[i]);\n  if (sum > 1)\n  {\n    totalf += sum;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/7ydini/OpenMP/lab5/Main/0"}
{"code": "for (int i = 0; i < nrow; i++)\n{\n  sum[omp_get_thread_num()] += RowGetEventProb(ncol, c_nrolls, c_ndicePerRoll, c_nsidesPerDie, hv, passprob, i);\n}\n\n", "pragma": " #pragma omp parallel for schedule(static,1)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/UCDNJJ/Parallel-Programming/Proj/ompdice/7"}
{"code": "for (int i = 0; i < iterations; i++)\n{\n  queuelist *recv = new_queuelist(N, sizeof(message));\n  queuelist *send = new_queuelist(N, sizeof(message));\n  begin_timer();\n  init_energy_measure();\n  initialize_graph(g);\n  root_message(g, recv);\n  while (messages_in_queue(g->N, recv))\n  {\n    recv_and_send(g, recv, send);\n    propagate_messages(g, recv, send);\n  }\n\n  total_energy += total_energy_used();\n  duration += time_elapsed();\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/adtac/openmp-graph/src/bellman_ford/6"}
{"code": "for (int i = 0; i < ((int) nTrials); ++i)\n{\n  weights[i] = exp(((-1) * data->ff.beta) * (energies[i] + nonbonded_1_3[i]));\n  stepWeight += weights[i];\n}\n\n", "pragma": "    #pragma omp parallel for default(none) shared(energies, nonbonded_1_3, nTrials, weights) reduction(+:stepWeight)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/cbmc/DCHedron/11"}
{"code": "for (int data_size_MB = 128; data_size_MB < 4096; data_size_MB += 1024)\n{\n  int data_size = ((data_size_MB / (sizeof(int))) * 1024) * 1024;\n  test_scatter_intrinsic(data_size);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/RapidsAtHKUST/Efficient-DPP/obsolete/OpenMP/gather_scatter_MIC/10"}
{"code": "for (i = 0; i < 150; i++)\n{\n  a1[2][i] = e[2][i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Annirudh2810/GA-implementation-using-C/Rosenbrock parallel/10"}
{"code": "for (j = i; j < (i + m); j++)\n{\n  k = ((m + i) - 1) - j;\n  x = fun(k, j);\n  if (k == 0)\n  {\n    if (X[k] == Y[j])\n      a[x] = 1;\n    else\n      a[x] = a[fun(k, j - 1)];\n\n  }\n  else\n  {\n    if (X[k] == Y[j])\n      a[x] = a[fun(k - 1, j - 1)] + 1;\n    else\n      a[x] = (a[fun(k - 1, j)] >= a[fun(k, j - 1)]) ? (a[fun(k - 1, j)]) : (a[fun(k, j - 1)]);\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(j,k,x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/DN612/Parallel-implementation-of-longest-common-subsequence/codes/parallel_cache/1"}
{"code": "for (int i = 0; i < 10; ++i)\n{\n  {\n    bar();\n  }\n}\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang/test/OpenMP/nesting_of_regions/0"}
{"code": "for (v = 0; v < graph->num_vertices; v++)\n{\n  if (getBit(bitmapCurr, v))\n  {\n    degree = graph->vertices[v].out_degree;\n    nodes = graph->vertices[v].outNodes;\n    uint32_t j;\n    for (j = 0; j < degree; j++)\n    {\n      uint32_t src = nodes->edges_array_src[j];\n      uint32_t dest = nodes->edges_array_dest[j];\n      float weight = 1;\n      if (arguments->algo_numThreads == 1)\n        activeVertices += bellmanFordRelax(src, dest, weight, stats, bitmapNext);\n      else\n        activeVertices += bellmanFordAtomicRelax(src, dest, weight, stats, bitmapNext);\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for private(nodes,degree,v) shared(graph,stats,bitmapNext,bitmapCurr) reduction(+ : activeVertices) schedule (dynamic,128)", "exist": 1, "private": 1, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/AccelGraph/02_capi_graph/src/algorithms/capi/bellmanFord/11"}
{"code": "for (x = 0; x < Nparticles; x++)\n{\n  ____num_tasks[omp_get_thread_num()]++;\n  {\n    for (y = 0; y < countOnes; y++)\n    {\n      indX = roundDouble(arrayX[x]) + objxy[(y * 2) + 1];\n      indY = roundDouble(arrayY[x]) + objxy[y * 2];\n      ind[(x * countOnes) + y] = fabs((((indX * IszY) * Nfr) + (indY * Nfr)) + k);\n      if (ind[(x * countOnes) + y] >= max_size)\n        ind[(x * countOnes) + y] = 0;\n\n    }\n\n    likelihood[x] = 0;\n    for (y = 0; y < countOnes; y++)\n      likelihood[x] += (pow(I[ind[(x * countOnes) + y]] - 100, 2) - pow(I[ind[(x * countOnes) + y]] - 228, 2)) / 50.0;\n\n    likelihood[x] = likelihood[x] / ((double) countOnes);\n  }\n  ;\n}\n\n", "pragma": "omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/sbak5/OMP_SLATE_eval/hclib/test/performance-regression/full-apps/rodinia/particlefilter/ex_particle_OPENMP_seq.balance/3"}
{"code": "for (v = 0; v < graphAdjLinkedList->num_vertices; ++v)\n{\n  pCrawl = graphAdjLinkedList->vertices[v].outNodes;\n  pFree = graphAdjLinkedList->vertices[v].outNodes;\n  while (pCrawl)\n  {\n    pFree = pCrawl;\n    pCrawl = pCrawl->next;\n    if (pFree)\n      free(pFree);\n\n  }\n\n  pCrawl = graphAdjLinkedList->vertices[v].inNodes;\n  pFree = graphAdjLinkedList->vertices[v].inNodes;\n  while (pCrawl)\n  {\n    pFree = pCrawl;\n    pCrawl = pCrawl->next;\n    if (pFree)\n      free(pFree);\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/graphAdjLinkedList/6"}
{"code": "for (i = ist; i <= iend; i++)\n{\n  rsd[i][j][k][0] = rsd[i][j][k][0] + ((dx1 * tx1) * ((u[i - 1][j][k][0] - (2.0 * u[i][j][k][0])) + u[i + 1][j][k][0]));\n  rsd[i][j][k][1] = (rsd[i][j][k][1] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][1] - flux[i][j][k][1]))) + ((dx2 * tx1) * ((u[i - 1][j][k][1] - (2.0 * u[i][j][k][1])) + u[i + 1][j][k][1]));\n  rsd[i][j][k][2] = (rsd[i][j][k][2] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][2] - flux[i][j][k][2]))) + ((dx3 * tx1) * ((u[i - 1][j][k][2] - (2.0 * u[i][j][k][2])) + u[i + 1][j][k][2]));\n  rsd[i][j][k][3] = (rsd[i][j][k][3] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][3] - flux[i][j][k][3]))) + ((dx4 * tx1) * ((u[i - 1][j][k][3] - (2.0 * u[i][j][k][3])) + u[i + 1][j][k][3]));\n  rsd[i][j][k][4] = (rsd[i][j][k][4] + (((tx3 * C3) * C4) * (flux[i + 1][j][k][4] - flux[i][j][k][4]))) + ((dx5 * tx1) * ((u[i - 1][j][k][4] - (2.0 * u[i][j][k][4])) + u[i + 1][j][k][4]));\n}\n\n", "pragma": "omp parallel for firstprivate(jend ,m ,i ,jst ,k ,u21i ,u31i ,u41i ,u51i ,tmp ,u21im1 ,u31im1 ,u41im1 ,u51im1 ,tx2 ,ist ,iend ,tx3 ,L2 ,tx1 ,dx1 ,dx2 ,dx3 ,dx4 ,dx5 ,dssp ,nx ,nz ,j )", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/LU/lu/73"}
{"code": "for (uint i = 0; i < mols.kindsCount; ++i)\n{\n  for (uint j = 0; j < mols.kindsCount; ++j)\n  {\n    tailCorrection += ((mols.pairEnCorrections[(i * mols.kindsCount) + j] * kCount[i]) * kCount[j]) * currentAxes.volInv[box];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/GOMC-WSU/GOMC/src/CalculateEnergy/22"}
{"code": "for (it = 1; it <= nit; it++)\n{\n  mg3P(u, v, r, a, c, n1, n2, n3, lt);\n  resid(u[lt], v, r[lt], n1, n2, n3, a, lt);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dalvangriebler/NPB-CPP/NPB-OMP/MG/mg/5"}
{"code": "for (int i = 0; i < n; i++)\n{\n  for (int j = 0; j < n; j++)\n  {\n    align_A[i][j] = A[i][j];\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/huxiaotaostasy/OpenMP/code_OpenMP/main/6"}
{"code": "for (c1 = (ni > nk) ? (ni) : (nk); c1 <= (((nj + (-1)) < (nm + (-1))) ? (nj + (-1)) : (nm + (-1))); c1++)\n{\n  for (c2 = 0; c2 <= (nm + (-1)); c2++)\n  {\n    C[c1][c2] = (((double) c1) * (c2 + 3)) / nl;\n  }\n\n}\n\n", "pragma": "omp parallel for private(c2)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/rexompiler/tests/nonsmoke/functional/CompileTests/OpenMP_tests/dataRaceBench/3mm-parallel-no/25"}
{"code": "for (int i = 0; i < m->nrows; ++i)\n  for (int j = 0; j < m->ncols; ++j)\n  TERRAIN(m, i, j) = 0;\n\n\n", "pragma": "omp parallel for collapse(2)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/main/0"}
{"code": "for (i = 0; i < N; i++)\n{\n  A = a[i] + b[i];\n  B = (4 * a[i]) - b[i];\n  if ((A >= B) && (A > 1))\n    sum1 += A;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/Wolfram18/OpenMP-Practice/OpenMP-Project/Project345/Synchronization/2"}
{"code": "for (int v = 0; v < 8; v++)\n{\n  const int n1 = i + VOISINS[v][0];\n  const int n2 = j + VOISINS[v][1];\n  CHECK((((n1 >= 0) && (n1 < nrows)) && (n2 >= 0)) && (n2 < ncols));\n  if (Wprec[(n1 * ncols) + n2] == m->no_data)\n    continue;\n\n  CHECK(TERRAIN(m, i, j) > m->no_data);\n  CHECK(Wprec[(i * ncols) + j] > m->no_data);\n  CHECK(Wprec[(n1 * ncols) + n2] > m->no_data);\n  const float Wn = Wprec[(n1 * ncols) + n2] + EPSILON;\n  if (TERRAIN(m, i, j) >= Wn)\n  {\n    W[(i * ncols) + j] = TERRAIN(m, i, j);\n    modif = 1;\n  }\n  else\n    if (Wprec[(i * ncols) + j] > Wn)\n  {\n    W[(i * ncols) + j] = Wn;\n    modif = 1;\n    if (W[(i * ncols) + j] < min_darboux)\n      min_darboux = W[(i * ncols) + j];\n\n  }\n\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/SchawnnDev/MNT/src/darboux/4"}
{"code": "for (; i < N; i++)\n{\n  P_a = particles + i;\n  P_a->x = doubleRand(r, bnd_far);\n  P_a->y = doubleRand(r, bnd_far);\n  P_a->vx = (1 - (2 * (rand() % 2))) * doubleRand((L / ((double) 8.0)) / r, L / ((double) 4.0));\n  P_a->vy = (1 - (2 * (rand() % 2))) * doubleRand((L / ((double) 8.0)) / r, L / ((double) 4.0));\n  P_a->colli_p = 0;\n  P_a->colli_w = 0;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/nexuslrf/Parallelizable_Particle_Collision_Simulation/collision_grid_p/2"}
{"code": "for (long i = 0; i < 500000000; i++)\n{\n  double x;\n  double y;\n  x = randUint(i);\n  y = randUint(i);\n  if (((x * x) + (y * y)) <= 1)\n    count = count + 1;\n\n}\n\n", "pragma": "omp parallel for reduction(+ : count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/dukanacv/parallel-montecarlo-pi/pi/0"}
{"code": "for (j = -tt; j < (tt + 1); j++)\n{\n  for (k = -tt; k < (tt + 1); k++)\n  {\n    if (((((xx + j) >= 0) && ((xx + j) < xsize)) && ((yy + k) >= 0)) && ((yy + k) < ysize))\n    {\n      local_image[((yy + k) * xsize) + (xx + j)] += mm * cubic_kernel(sqrt((((float) j) * ((float) j)) + (((float) k) * ((float) k))), tt);\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/alejandrobll/py-sphviewer/sphviewer/extensions/rendermodule/3"}
{"code": "for (size_t j = 0; j < result.cols(); ++j)\n  for (size_t i = 0; i < result.rows(); ++i)\n{\n  result(i, j) = 0;\n  for (size_t k = 0; k < result.rows(); ++k)\n    result(i, j) += first(i, k) * second(j, k);\n\n}\n\n\n", "pragma": "\t\t#pragma omp parallel for shared(result, first, second)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/frostbolt/openmp/first/Matrix/2"}
{"code": "for (unsigned int block = 0; block < totalBlocks; block++)\n{\n  block_dim[block] = (block < (totalBlocks - 1)) ? (MIN_BLOCK_SIZE) : (nz % MIN_BLOCK_SIZE);\n  if (block_dim[block] == 0)\n  {\n    block_dim[block] = MIN_BLOCK_SIZE;\n  }\n\n  if (((nx > 1) && (ny > 1)) && (nz > 1))\n  {\n    field[block] = zfp_field_3d(&array[((block * MIN_BLOCK_SIZE) * ny) * nx], type, nx, ny, block_dim[block]);\n  }\n  else\n  {\n    field[block] = zfp_field_2d(&array[(block * MIN_BLOCK_SIZE) * nx], type, nx, block_dim[block]);\n  }\n\n  zfp[block] = zfp_stream_open(nullptr);\n  if (zfp_is_relative)\n  {\n    zfp_stream_set_precision(zfp[block], tolerance);\n  }\n  else\n  {\n    zfp_stream_set_accuracy(zfp[block], tolerance);\n  }\n\n  buffer_size[block] = zfp_stream_maximum_size(zfp[block], field[block]);\n  buffer[block] = malloc(buffer_size[block]);\n  stream[block] = stream_open(buffer[block], buffer_size[block]);\n  zfp_stream_set_bit_stream(zfp[block], stream[block]);\n}\n\n", "pragma": "#pragma omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/brightskiesinc/Reverse_Time_Migration/libs/SeismicOperations/src/utils/compressor/Compressor/4"}
{"code": "for (i = 0; i < n; i++)\n{\n  if (observations[0] == \"Heads\")\n  {\n    fwd[0][i] = pi[i] * b[i][0];\n  }\n  else\n  {\n    fwd[0][i] = pi[i] * b[i][1];\n  }\n\n}\n\n", "pragma": "\t#pragma omp parallel for shared(observations)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/mesh12/HMM/parallelhmm/11"}
{"code": "for (i = (j = 0); i < len; i++)\n{\n  if (j != 4)\n  {\n    msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[j + 1]];\n    j++;\n  }\n  else\n  {\n    msg_mac[j] = msg[i] ^ ebits_to_num[msg_mac[j] ^ msg_mac[0]];\n    j = 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/john/src/lotus85_fmt_plug/5"}
{"code": "for (int i = 0; i < (n - 1); ++i)\n{\n  fprintf(file, \"%lf \", x[i]);\n}\n\n", "pragma": "omp for simd", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/lolodino77/projet_hpc/mpi_et_openmp/cg/0"}
{"code": "for (i = 0; i < N1; i++)\n{\n  int j;\n  for (j = 0; j < N2; j++)\n  {\n    a[i][j] = i - j;\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/bsc-pm/mcxx/tests/07_phases_omp.dg/common/c/success_parallel_for_04/0"}
{"code": "for (j = 0; j < matrixScale; j++)\n{\n  for (k = 0; k < matrixScale; k++)\n    matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n\n}\n\n", "pragma": "omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Nersle/parallelProgramingProject/cannon/cannonOpenMP/4"}
{"code": "for (i = 0; i <= m; i++)\n{\n  c[i] = calloc(n + 1, sizeof(short int));\n  b[i] = calloc(n + 1, sizeof(char));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/auriza/pairwise-openmp/rowwise/1"}
{"code": "for (iteration = 0; (iteration < maxIterations) && (converged != fullyConverged); iteration++)\n{\n  for (z = 1; z < (OMP_zMax - 1); z++)\n  {\n    for (y = 1; y < (OMP_yMax - 1); y++)\n    {\n      for (x = 1; x < (OMP_xMax - 1); x += 2)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        int xyz_xmin = xyzInd - 1;\n        int xyz_xplu = xyzInd + 1;\n        int xyz_ymin = xyzInd - OMP_xMax;\n        int xyz_yplu = xyzInd + OMP_xMax;\n        int xyz_zmin = xyzInd - xyMax;\n        int xyz_zplu = xyzInd + xyMax;\n        double uInd = u[xyzInd];\n        g[xyzInd] = 1.0 / sqrt((((((epsilon + OMP_SQR(uInd - u[xyz_xplu])) + OMP_SQR(uInd - u[xyz_xmin])) + OMP_SQR(uInd - u[xyz_yplu])) + OMP_SQR(uInd - u[xyz_ymin])) + OMP_SQR(uInd - u[xyz_zplu])) + OMP_SQR(uInd - u[xyz_zmin]));\n        double uInd1 = u[xyzInd + 1];\n        g[xyzInd + 1] = 1.0 / sqrt((((((epsilon + OMP_SQR(uInd1 - u[xyz_xplu + 1])) + OMP_SQR(uInd1 - u[xyz_xmin + 1])) + OMP_SQR(uInd1 - u[xyz_yplu + 1])) + OMP_SQR(uInd1 - u[xyz_ymin + 1])) + OMP_SQR(uInd1 - u[xyz_zplu + 1])) + OMP_SQR(uInd1 - u[xyz_zmin + 1]));\n      }\n\n    }\n\n  }\n\n  memcpy(conv, u, (((sizeof(double)) * OMP_xMax) * OMP_yMax) * OMP_zMax);\n  OMP_GaussianBlur(conv, Ksigma, 3);\n  for (z = 0; z < OMP_zMax; z++)\n  {\n    for (y = 0; y < OMP_yMax; y++)\n    {\n      for (x = 0; x < OMP_xMax; x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        double r = (conv[xyzInd] * f[xyzInd]) / sigma2;\n        r = (r * (2.38944 + (r * (0.950037 + r)))) / (4.65314 + (r * (2.57541 + (r * (1.48937 + r)))));\n        conv[xyzInd] -= f[xyzInd] * r;\n      }\n\n    }\n\n  }\n\n  OMP_GaussianBlur(conv, Ksigma, 3);\n  converged = 0;\n  for (z = 1; z < (OMP_zMax - 1); z++)\n  {\n    for (y = 1; y < (OMP_yMax - 1); y++)\n    {\n      for (x = 1; x < (OMP_xMax - 1); x++)\n      {\n        int xyzInd = OMP_Index(x, y, z);\n        int xyz_xmin = xyzInd - 1;\n        int xyz_xplu = xyzInd + 1;\n        int xyz_ymin = xyzInd - OMP_xMax;\n        int xyz_yplu = xyzInd + OMP_xMax;\n        int xyz_zmin = xyzInd - xyMax;\n        int xyz_zplu = xyzInd + xyMax;\n        double g_xmin = g[xyz_xmin];\n        double g_xplu = g[xyz_xplu];\n        double g_ymin = g[xyz_ymin];\n        double g_yplu = g[xyz_yplu];\n        double g_zmin = g[xyz_zmin];\n        double g_zplu = g[xyz_zplu];\n        double oldVal = u[xyzInd];\n        double newVal = (oldVal + (dt * (((((((u[xyz_xmin] * g_xmin) + (u[xyz_xplu] * g_xplu)) + (u[xyz_ymin] * g_ymin)) + (u[xyz_yplu] * g_yplu)) + (u[xyz_zmin] * g_zmin)) + (u[xyz_zplu] * g_zplu)) - (gamma * conv[xyzInd])))) / (1.0 + (dt * (((((g_xplu + g_xmin) + g_yplu) + g_ymin) + g_zplu) + g_zmin)));\n        if (fabs(oldVal - newVal) < epsilon)\n        {\n          converged++;\n        }\n\n        u[xyzInd] = newVal;\n      }\n\n    }\n\n  }\n\n  if (converged > lastConverged)\n  {\n    printf(\"%d pixels have converged on iteration %d\\n\", converged, iteration);\n    lastConverged = converged;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.8/FoldompDeblur/0"}
{"code": "for (int i = 0; i < dim1; i++)\n  for (int j = 0; j < dim2; j++)\n  if (random)\n  Matr[(i * N) + j] = rand() % 10;\n\n\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MarieMin/openmp/matrix_modified_multiplication/0"}
{"code": "for (i = 0; i < (avg + 1); i++)\n{\n  for (j = 0; j < col; j++)\n  {\n    if (id == (p - 1))\n    {\n      if ((((i == ((row / p) - 1)) || (i == 0)) || (j == 0)) || (j == (col - 1)))\n      {\n        if (((i == ((row / p) - 1)) || (j == 0)) || (j == (col - 1)))\n          out[(i * col) + j] = sub_s[(i * col) + j];\n\n      }\n      else\n      {\n        sum_kernal = ((((((((kernal[8] * sub_s[((i - 1) * col) + (j - 1)]) + (kernal[7] * sub_s[(i * col) + (j - 1)])) + (kernal[6] * sub_s[((i + 1) * col) + (j - 1)])) + (kernal[5] * sub_s[((i - 1) * col) + j])) + (kernal[4] * sub_s[(i * col) + j])) + (kernal[3] * sub_s[((i + 1) * col) + j])) + (kernal[2] * sub_s[((i - 1) * col) + (j + 1)])) + (kernal[1] * sub_s[(i * col) + (j + 1)])) + (kernal[0] * sub_s[((i + 1) * col) + (j + 1)]);\n        out[(i * col) + j] = sum_kernal / total_kernal;\n      }\n\n    }\n    else\n    {\n      if (((i == 0) || (j == 0)) || (j == (col - 1)))\n      {\n        if ((j == 0) || (j == (col - 1)))\n          out[(i * col) + j] = sub_s[(i * col) + j];\n\n      }\n      else\n      {\n        sum_kernal = ((((((((kernal[8] * sub_s[((i - 1) * col) + (j - 1)]) + (kernal[7] * sub_s[(i * col) + (j - 1)])) + (kernal[6] * sub_s[((i + 1) * col) + (j - 1)])) + (kernal[5] * sub_s[((i - 1) * col) + j])) + (kernal[4] * sub_s[(i * col) + j])) + (kernal[3] * sub_s[((i + 1) * col) + j])) + (kernal[2] * sub_s[((i - 1) * col) + (j + 1)])) + (kernal[1] * sub_s[(i * col) + (j + 1)])) + (kernal[0] * sub_s[((i + 1) * col) + (j + 1)]);\n        out[(i * col) + j] = sum_kernal / total_kernal;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for schedule(dynamic) num_threads(t) private(sum_kernal,i,j)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/saalimon/parallel/exam_final/final/1"}
{"code": "for (int i = 0; i < 2048; i++)\n{\n  for (int j = 0; j < 2048; j++)\n  {\n    layer7[i] = weight712[i][j] * layer62[j];\n  }\n\n  layer7[i] += 1;\n  layer7[i] = max((double) 0, layer7[i]);\n}\n\n", "pragma": "                    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LorenzoPorro/OpenMP-CNN/architecture/17"}
{"code": "for (int p = 0; p < h; p++)\n{\n  sum2 += L[h][p] * y[p];\n}\n\n", "pragma": "    #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/propellermint/distributed-computing-and-parallel-programming/posix-thread-and-openmp/6_openmp/5"}
{"code": "for (int k = 0; k < cmb.size(); k++)\n{\n  mpz_invert(to_be_multiplied.get_mpz_t(), L[cmb[k]].get_mpz_t(), p.get_mpz_t());\n  prod *= to_be_multiplied;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/vamartid/NSK-birthday-attack/parallel/Ns/10"}
{"code": "for (size_t i = 0; i < n; ++i)\n{\n  count += count_bits_in_word(v[i]);\n}\n\n", "pragma": "    #pragma omp parallel for reduction(+:count)", "exist": 1, "private": 0, "reduction": 1, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bcumming/openmp-examples/cxx/bitcounter/bitcounter/0"}
{"code": "for (i = 0; i < MAX; i++)\n{\n  a[i] = rand() % 1000;\n}\n\n", "pragma": "#pragma omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/dnyaneshwargiri/Cuda-Openmp/vector_matrix_operations_openmp/par_add_large_vectors/0"}
{"code": "for (i = 0; i < sizeA; i++)\n{\n  printf(\"A[%d]=%d,%s\", i, A[i], (A[i] > 9) ? (\" \") : (\"  \"));\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/hdantas/parallel-programming/B/ass2-openmp/7"}
{"code": "for (int i = 1; i <= rows_per_proc; i++)\n{\n  MPI_File_seek(fh, ((bytes * ((start_row + i) - 1)) * width) + (bytes * start_col), MPI_SEEK_SET);\n  MPI_File_read(fh, &t0[((bytes * (cols_per_proc + 2)) * i) + bytes], bytes * cols_per_proc, (MPI_Datatype) 0x4c00010d, &status);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/NickLekkas01/img-convolution/src/imgconv/1"}
{"code": "for (i = 0; i < n; i++)\n  index[i] = i;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/ebardes/cluster/src/cluster/6"}
{"code": "for (int i = 0; i < n; i++)\n{\n  printf(\"%.7f \", d[i]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/ggeraldina/parallel_programming/example4/main/0"}
{"code": "for (int i = 0; i < n; i++)\n{\n  int tno = omp_get_thread_num();\n  if (P[max_x[tno]].a < P[i].a)\n  {\n    max_x[tno] = i;\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp for schedule(dynamic) nowait", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/aman33459/ParallelConvexHull/quickHull/quickhullpara/1"}
{"code": "for (c1 = 0; c1 <= (N / 16); c1 += 1)\n{\n  for (c2 = 0; c2 <= ((1 < (((-8) * c1) + (N / 2))) ? (1) : (((-8) * c1) + (N / 2))); c2 += 1)\n  {\n    if (c2 == 1)\n    {\n      for (c3 = 0; c3 <= ((-c1) + ((N - 2) / 16)); c3 += 1)\n        for (c5 = 16 * c1; c5 <= ((((16 * c1) + 15) < ((N - (16 * c3)) - 2)) ? ((16 * c1) + 15) : ((N - (16 * c3)) - 2)); c5 += 1)\n        for (c7 = ((16 * c3) + c5) + 1; c7 <= (((N - 1) < (((16 * c3) + c5) + 16)) ? (N - 1) : (((16 * c3) + c5) + 16)); c7 += 1)\n        Puu[c5] += (-1) * Pbp[c5][c7 + 1];\n\n\n\n    }\n    else\n    {\n      for (c5 = 16 * c1; c5 <= ((N < ((16 * c1) + 15)) ? (N) : ((16 * c1) + 15)); c5 += 1)\n        Puu[c5] = 1;\n\n    }\n\n  }\n\n  for (c3 = 0; c3 <= ((c1 < floor(((double) (N - 1)) / ((double) 16))) ? (c1) : (floor(((double) (N - 1)) / ((double) 16)))); c3 += 1)\n    for (c5 = ((16 * c1) > ((16 * c3) + 1)) ? (16 * c1) : ((16 * c3) + 1); c5 <= ((N < ((16 * c1) + 15)) ? (N) : ((16 * c1) + 15)); c5 += 1)\n    for (c7 = 16 * c3; c7 <= ((((16 * c3) + 15) < (c5 - 1)) ? ((16 * c3) + 15) : (c5 - 1)); c7 += 1)\n    Puu[c5] += (-1) * Pbp[k][c5 + 1];\n\n\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/markpal/NPDP_Bench/mea/mea_puu_traco/2"}
{"code": "for (int i = 0; i < thrower(); i++)\n  ;\n\n", "pragma": "#pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/atmnpatel/openmp-rpc-offloading/clang-tools-extra/test/clang-tidy/checkers/bugprone-exception-escape-openmp/0"}
{"code": "for (int i = 0; i < N; i++)\n{\n  x = ((-1.0) + (i * delta)) + (delta * 0.5);\n  for (int j = 0; j < N; j++)\n  {\n    y = ((-1.0) + (j * delta)) + (delta * 0.5);\n    u = U[(i * N) + j];\n    fprintf(matrix, \"%g\\t%g\\t%g\\n\", x, y, u);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/anderslaunerbaek/HPC/projects/assign_2/func/2"}
{"code": "for (int i = 0; i < k; i++)\n{\n  double *centroid_i = centroids[i];\n  distance = getDistance(point, centroid_i, nCol);\n  if (distance < oldDistance)\n  {\n    index = i;\n    oldDistance = distance;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/MattBlue92/PC_2020_Kmean_OpenMP/KmeansOpenMP/1"}
{"code": "for (i = 1; i < (mat_size - 1); i++)\n{\n  for (j = 1; j < (mat_size - 1); j++)\n  {\n    sum = ((fabs(matrix[i][j] - matrix[i - 1][j]) + fabs(matrix[i][j] - matrix[i + 1][j])) + fabs(matrix[i][j] - matrix[i][j - 1])) + fabs(matrix[i][j] - matrix[i][j + 1]);\n    k = (int) (sum * ((float) mat_size));\n    histogram[k] += 1;\n    if (sum > max)\n      max = sum;\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mratsim/weave/benchmarks/histogram_2D/openmp_histogram/2"}
{"code": "for (i = 0; i < 480; i++)\n{\n  fgets(tmpLine, 20, handler);\n  bufferInt[i] = atoi(tmpLine);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/passlab/homp/benchmarks/radixsort/radix/1"}
{"code": "for (long long i = 0L; i < n; ++i)\n  a[i] = true;\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/LilyOSullivan/twin_primes_openMP/main/0"}
{"code": "for (int j = 2; j < n; j += 2)\n{\n  if (A[j] < A[j - 1])\n  {\n    int temp = A[j];\n    A[j] = A[j - 1];\n    A[j - 1] = temp;\n  }\n\n}\n\n", "pragma": "      #pragma omp for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/prayassrode/openMP/bubblesort/2"}
{"code": "for (int i = 0; i < offset; i++)\n  printf(\" \");\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/GuyKabiri/Parallel-Sequence-Alignment/cpu_funcs/9"}
{"code": "for (i = 1; i < size; i++)\n{\n  if (genArray[i - 1] <= genArray[i])\n  {\n  }\n  else\n  {\n    return 0;\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/KaliszAd/OpenACC_OpenMP/newbit_acc/4"}
{"code": "for (int i = 1; i < (n - 1); i++)\n{\n  out[i] = ((0.25 * in[i - 1]) + (0.5 * in[i])) + (0.25 * in[i + 1]);\n}\n\n", "pragma": "omp parallel for schedule(static)", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/Borroot/heat/src/openmp/major/relax_split/0"}
{"code": "for (y = 0; y < OMP_yMax; y++)\n{\n  for (x = 0; x < OMP_xMax; x += 16)\n  {\n    int ind = OMP_Index(x, y, 0);\n    u[ind] *= boundryScale;\n    u[ind + 1] *= boundryScale;\n    u[ind + 2] *= boundryScale;\n    u[ind + 3] *= boundryScale;\n    u[ind + 4] *= boundryScale;\n    u[ind + 5] *= boundryScale;\n    u[ind + 6] *= boundryScale;\n    u[ind + 7] *= boundryScale;\n    u[ind + 8] *= boundryScale;\n    u[ind + 9] *= boundryScale;\n    u[ind + 10] *= boundryScale;\n    u[ind + 11] *= boundryScale;\n    u[ind + 12] *= boundryScale;\n    u[ind + 13] *= boundryScale;\n    u[ind + 14] *= boundryScale;\n    u[ind + 15] *= boundryScale;\n  }\n\n}\n\n", "pragma": "omp parallel for num_threads(16) private (x)", "exist": 1, "private": 1, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/vvndn/openmp-lab/6.8/BoldompDeblur/2"}
{"code": "for (int channel = 0; channel < source_nchannel; channel++)\n{\n  for (int y = 0; y < source_height; y++)\n  {\n    for (int x = 0; x < source_width; x++)\n    {\n      int id = (x + (y * source_width)) + ((channel * source_width) * source_height);\n      if (boundary_array[id] == INSIDE_MASK)\n      {\n        outimg[id] = targetimg[id];\n      }\n      else\n      {\n        outimg[id] = srcimg[id];\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/kaychenziqi/parallel-image-edit/poisson/omp/PoissonImageEdit/7"}
{"code": "for (i = 0; i < rowsNumber; i++)\n{\n  for (j = 0; j < (3 * colsNumber); j++)\n  {\n    fputc(final2D[i][j], outputFile);\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/stathismast/parallel-matrix-convolution/Versions/Openmp/color/11"}
{"code": "for (int i = N[0]; i < end; i++)\n{\n  padsum += encrypt(i, keys->key1[0]) * encrypt(i, keys->key2[0]);\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/jimlinntu/Parallel-Programming-2019/quiz/20019/main/2"}
{"code": "for (int i = sx; i <= ex; i++)\n{\n  for (int j = sy; j <= ey; j++)\n  {\n    for (int k = sz; k <= ez; k++)\n    {\n      soa->x[counter] = i;\n      soa->y[counter] = j;\n      soa->z[counter] = k;\n      soa->mass[counter] = (fabs(i) + fabs(j)) + fabs(k);\n      counter++;\n    }\n\n  }\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/mishig25/2017Block2/patterns/reduce/openmp/1"}
{"code": "for (m = 0; m < 3; m++)\n{\n  for (j = 1; j <= (grid_points[1] - 2); j++)\n  {\n    for (k = 1; k <= (grid_points[2] - 2); k++)\n    {\n      rhs[m][i][j][k] = (rhs[m][i][j][k] - (lhs[n + 3][i][j][k] * rhs[m][i1][j][k])) - (lhs[n + 4][i][j][k] * rhs[m][i2][j][k]);\n    }\n\n  }\n\n}\n\n", "pragma": "omp parallel for", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/LLNL/AutoParBench/benchmarks/baseline/NPB3.0-omp-c/SP/sp/170"}
{"code": "for (i = 0; i < num_vertices; i++)\n{\n  in_degree = maxTwoIntegers(in_degree, vertex_array->out_degree[i]);\n  if (vertex_array->out_degree[i] == in_degree)\n    index = i;\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/atmughrabi/OpenGraph/00_graph_bench/src/structures/vertex/7"}
{"code": "for (int i = 0; i < args->numinputs; i++)\n{\n  if (args->inputs[i])\n    free(args->inputs[i]);\n\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/gciotto/MO644/task6/md5_bmark_parallel/3"}
{"code": "for (int tid = 0; tid < no_of_nodes; tid++)\n{\n  if (h_graph_mask[tid] == true)\n  {\n    h_graph_mask[tid] = false;\n    for (int i = h_graph_nodes[tid].starting; i < (h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n    {\n      int id = h_graph_edges[i];\n      if (!h_graph_visited[id])\n      {\n        h_cost[id] = h_cost[tid] + 1;\n        h_updating_graph_mask[id] = true;\n      }\n\n    }\n\n  }\n\n}\n\n", "pragma": "\t\t#pragma omp parallel for ", "exist": 1, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/HSAFoundation/HSA-OpenMP-GCC-AMD/examples/usecases/rodinia_bfs/bfs/3"}
{"code": "for (int i = 0; i < size; i++)\n{\n  ((((((cout << \"    rank: \") << i) << \" with task load: \") << rank_load[i]) << \"/\") << cells_per_proccess) << endl;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/yangxvlin/multiple-sequence-alignment-openMP-openMPI/testing8/test/1"}
{"code": "for (int i = 0; i < MAXSIZE; i++)\n{\n  x_vals[i] = (i + 1) * INDEL;\n  y_vals[i] = x_vals[i];\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/cpp_loops/bergerom/nw_parallel/nw-openmp/5"}
{"code": "for (base = 0; base < top; base += step)\n{\n  uint32_t start = base << (5 + shift);\n  uint32_t next = (base + step) << (5 + shift);\n  clock_t running_time = times(&tms) - start_time;\n  fprintf(stderr, \"\\rFound %llu, trying 0x%08x - 0x%08x, speed %.1f Mseeds/s \", (unsigned long long) found, start, next - 1, (((double) start) * clk_tck) / ((running_time) ? (running_time * 1e6) : (1e6)));\n  recent = crack_range(base, base + step, match, flavor);\n  found += recent;\n}\n\n", "pragma": "", "exist": 0, "private": 0, "reduction": 0, "path": "/home/talkad/LIGHTBITS_SHARE/c_loops/openwall/php_mt_seed/php_mt_seed/1"}
